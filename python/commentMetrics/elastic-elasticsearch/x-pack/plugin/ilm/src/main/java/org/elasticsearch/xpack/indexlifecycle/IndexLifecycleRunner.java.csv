# id;timestamp;commentText;codeText;commentWords;codeWords
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1534879781;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index the index to modify_@param clusterState the cluster state to modify_@param stepInfo the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData idxMeta = clusterState.getMetaData().index(index)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.get(idxMeta.getSettings()))) {_            return clusterState__        }_        Settings.Builder indexSettings = Settings.builder().put(idxMeta.getSettings())_            .put(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.getKey(), stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithIndexSettings(index, clusterState, indexSettings)__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,idx,meta,cluster,state,get,meta,data,index,index,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,settings,get,idx,meta,get,settings,return,cluster,state,settings,builder,index,settings,settings,builder,put,idx,meta,get,settings,put,lifecycle,settings,get,key,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,index,settings,index,cluster,state,index,settings,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1534899572;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index the index to modify_@param clusterState the cluster state to modify_@param stepInfo the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData idxMeta = clusterState.getMetaData().index(index)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.get(idxMeta.getSettings()))) {_            return clusterState__        }_        Settings.Builder indexSettings = Settings.builder().put(idxMeta.getSettings())_            .put(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.getKey(), stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithIndexSettings(index, clusterState, indexSettings)__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,idx,meta,cluster,state,get,meta,data,index,index,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,settings,get,idx,meta,get,settings,return,cluster,state,settings,builder,index,settings,settings,builder,put,idx,meta,get,settings,put,lifecycle,settings,get,key,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,index,settings,index,cluster,state,index,settings,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1535060222;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index the index to modify_@param clusterState the cluster state to modify_@param stepInfo the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData idxMeta = clusterState.getMetaData().index(index)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.get(idxMeta.getSettings()))) {_            return clusterState__        }_        Settings.Builder indexSettings = Settings.builder().put(idxMeta.getSettings())_            .put(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.getKey(), stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithIndexSettings(index, clusterState, indexSettings)__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,idx,meta,cluster,state,get,meta,data,index,index,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,settings,get,idx,meta,get,settings,return,cluster,state,settings,builder,index,settings,settings,builder,put,idx,meta,get,settings,put,lifecycle,settings,get,key,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,index,settings,index,cluster,state,index,settings,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1536172520;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index the index to modify_@param clusterState the cluster state to modify_@param stepInfo the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData idxMeta = clusterState.getMetaData().index(index)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.get(idxMeta.getSettings()))) {_            return clusterState__        }_        Settings.Builder indexSettings = Settings.builder().put(idxMeta.getSettings())_            .put(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.getKey(), stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithIndexSettings(index, clusterState, indexSettings)__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,idx,meta,cluster,state,get,meta,data,index,index,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,settings,get,idx,meta,get,settings,return,cluster,state,settings,builder,index,settings,settings,builder,put,idx,meta,get,settings,put,lifecycle,settings,get,key,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,index,settings,index,cluster,state,index,settings,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1536187065;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index the index to modify_@param clusterState the cluster state to modify_@param stepInfo the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData idxMeta = clusterState.getMetaData().index(index)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.get(idxMeta.getSettings()))) {_            return clusterState__        }_        Settings.Builder indexSettings = Settings.builder().put(idxMeta.getSettings())_            .put(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.getKey(), stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithIndexSettings(index, clusterState, indexSettings)__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,idx,meta,cluster,state,get,meta,data,index,index,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,settings,get,idx,meta,get,settings,return,cluster,state,settings,builder,index,settings,settings,builder,put,idx,meta,get,settings,put,lifecycle,settings,get,key,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,index,settings,index,cluster,state,index,settings,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1536322011;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index the index to modify_@param clusterState the cluster state to modify_@param stepInfo the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData idxMeta = clusterState.getMetaData().index(index)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.get(idxMeta.getSettings()))) {_            return clusterState__        }_        Settings.Builder indexSettings = Settings.builder().put(idxMeta.getSettings())_            .put(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.getKey(), stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithIndexSettings(index, clusterState, indexSettings)__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,idx,meta,cluster,state,get,meta,data,index,index,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,settings,get,idx,meta,get,settings,return,cluster,state,settings,builder,index,settings,settings,builder,put,idx,meta,get,settings,put,lifecycle,settings,get,key,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,index,settings,index,cluster,state,index,settings,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1536957503;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index the index to modify_@param clusterState the cluster state to modify_@param stepInfo the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData idxMeta = clusterState.getMetaData().index(index)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.get(idxMeta.getSettings()))) {_            return clusterState__        }_        Settings.Builder indexSettings = Settings.builder().put(idxMeta.getSettings())_            .put(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.getKey(), stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithIndexSettings(index, clusterState, indexSettings)__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,idx,meta,cluster,state,get,meta,data,index,index,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,settings,get,idx,meta,get,settings,return,cluster,state,settings,builder,index,settings,settings,builder,put,idx,meta,get,settings,put,lifecycle,settings,get,key,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,index,settings,index,cluster,state,index,settings,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1537228800;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index the index to modify_@param clusterState the cluster state to modify_@param stepInfo the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData idxMeta = clusterState.getMetaData().index(index)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.get(idxMeta.getSettings()))) {_            return clusterState__        }_        Settings.Builder indexSettings = Settings.builder().put(idxMeta.getSettings())_            .put(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.getKey(), stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithIndexSettings(index, clusterState, indexSettings)__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,idx,meta,cluster,state,get,meta,data,index,index,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,settings,get,idx,meta,get,settings,return,cluster,state,settings,builder,index,settings,settings,builder,put,idx,meta,get,settings,put,lifecycle,settings,get,key,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,index,settings,index,cluster,state,index,settings,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1537312077;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index the index to modify_@param clusterState the cluster state to modify_@param stepInfo the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData idxMeta = clusterState.getMetaData().index(index)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.get(idxMeta.getSettings()))) {_            return clusterState__        }_        Settings.Builder indexSettings = Settings.builder().put(idxMeta.getSettings())_            .put(LifecycleSettings.LIFECYCLE_STEP_INFO_SETTING.getKey(), stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithIndexSettings(index, clusterState, indexSettings)__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,idx,meta,cluster,state,get,meta,data,index,index,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,settings,get,idx,meta,get,settings,return,cluster,state,settings,builder,index,settings,settings,builder,put,idx,meta,get,settings,put,lifecycle,settings,get,key,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,index,settings,index,cluster,state,index,settings,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1537390248;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1538423126;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1538424609;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1538532170;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1538662915;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1539019518;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1539729790;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1539758388;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1540329641;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1540394099;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1540477624;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1542051179;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1542231605;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1545246690;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException;1548261991;Conditionally updates cluster state with new step info. The new cluster state is only_built if the step info has changed, otherwise the same old <code>clusterState</code> is_returned__@param index        the index to modify_@param clusterState the cluster state to modify_@param stepInfo     the new step info to update_@return Updated cluster state with <code>stepInfo</code> if changed, otherwise the same cluster state_if no changes to step info exist_@throws IOException if parsing step info fails;static ClusterState addStepInfoToClusterState(Index index, ClusterState clusterState, ToXContentObject stepInfo) throws IOException {_        IndexMetaData indexMetaData = clusterState.getMetaData().index(index)__        if (indexMetaData == null) {_            _            return clusterState__        }_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        final String stepInfoString__        try (XContentBuilder infoXContentBuilder = JsonXContent.contentBuilder()) {_            stepInfo.toXContent(infoXContentBuilder, ToXContent.EMPTY_PARAMS)__            stepInfoString = BytesReference.bytes(infoXContentBuilder).utf8ToString()__        }_        if (stepInfoString.equals(lifecycleState.getStepInfo())) {_            return clusterState__        }_        LifecycleExecutionState.Builder newState = LifecycleExecutionState.builder(lifecycleState)__        newState.setStepInfo(stepInfoString)__        ClusterState.Builder newClusterStateBuilder = newClusterStateWithLifecycleState(index, clusterState, newState.build())__        return newClusterStateBuilder.build()__    };conditionally,updates,cluster,state,with,new,step,info,the,new,cluster,state,is,only,built,if,the,step,info,has,changed,otherwise,the,same,old,code,cluster,state,code,is,returned,param,index,the,index,to,modify,param,cluster,state,the,cluster,state,to,modify,param,step,info,the,new,step,info,to,update,return,updated,cluster,state,with,code,step,info,code,if,changed,otherwise,the,same,cluster,state,if,no,changes,to,step,info,exist,throws,ioexception,if,parsing,step,info,fails;static,cluster,state,add,step,info,to,cluster,state,index,index,cluster,state,cluster,state,to,xcontent,object,step,info,throws,ioexception,index,meta,data,index,meta,data,cluster,state,get,meta,data,index,index,if,index,meta,data,null,return,cluster,state,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,final,string,step,info,string,try,xcontent,builder,info,xcontent,builder,json,xcontent,content,builder,step,info,to,xcontent,info,xcontent,builder,to,xcontent,step,info,string,bytes,reference,bytes,info,xcontent,builder,utf8to,string,if,step,info,string,equals,lifecycle,state,get,step,info,return,cluster,state,lifecycle,execution,state,builder,new,state,lifecycle,execution,state,builder,lifecycle,state,new,state,set,step,info,step,info,string,cluster,state,builder,new,cluster,state,builder,new,cluster,state,with,lifecycle,state,index,cluster,state,new,state,build,return,new,cluster,state,builder,build
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1533229511;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        Step nextStep = stepRegistry.getStep(indexPolicySetting, nextStepKey)__        if (nextStep == null) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,step,next,step,step,registry,get,step,index,policy,setting,next,step,key,if,next,step,null,throw,new,illegal,argument,exception,step,next,step,key,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1534567515;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1534879781;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1534899572;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1535060222;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1536172520;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1536187065;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1536322011;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1536957503;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1537228800;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1537312077;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected._@param indexName_The index whose step is to change_@param currentState_The current {@link ClusterState}_@param currentStepKey_The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey_The next step to move the index into_@param nowSupplier_The current-time supplier for updating when steps changed_@param stepRegistry_The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(indexSettings)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,index,settings,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1537390248;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1538423126;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1538424609;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1538532170;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1538662915;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1539019518;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1539729790;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1539758388;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1540329641;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1540394099;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry);1540477624;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey, nextStepKey, nowSupplier)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1533229511;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1534567515;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1534879781;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1534899572;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1535060222;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1536172520;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1536187065;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1536322011;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1536957503;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1537228800;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(Settings indexSettings);1537312077;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param indexSettings_the index settings to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(Settings indexSettings) {_        String currentPhase = LifecycleSettings.LIFECYCLE_PHASE_SETTING.get(indexSettings)__        String currentAction = LifecycleSettings.LIFECYCLE_ACTION_SETTING.get(indexSettings)__        String currentStep = LifecycleSettings.LIFECYCLE_STEP_SETTING.get(indexSettings)__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,index,settings,the,index,settings,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,settings,index,settings,string,current,phase,lifecycle,settings,get,index,settings,string,current,action,lifecycle,settings,get,index,settings,string,current,step,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1536187065;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        final Settings indexSettings = indexMetaData.getSettings()__        if (indexSettings.hasValue(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE) == false) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final long lifecycleDate = indexSettings.getAsLong(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE, -1L)__        assert lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,final,settings,index,settings,index,meta,data,get,settings,if,index,settings,has,value,lifecycle,settings,false,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,index,settings,get,as,long,lifecycle,settings,1l,assert,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1536322011;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        final Settings indexSettings = indexMetaData.getSettings()__        if (indexSettings.hasValue(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE) == false) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final long lifecycleDate = indexSettings.getAsLong(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE, -1L)__        assert lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,final,settings,index,settings,index,meta,data,get,settings,if,index,settings,has,value,lifecycle,settings,false,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,index,settings,get,as,long,lifecycle,settings,1l,assert,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1536957503;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        final Settings indexSettings = indexMetaData.getSettings()__        if (indexSettings.hasValue(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE) == false) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final long lifecycleDate = indexSettings.getAsLong(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE, -1L)__        assert lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,final,settings,index,settings,index,meta,data,get,settings,if,index,settings,has,value,lifecycle,settings,false,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,index,settings,get,as,long,lifecycle,settings,1l,assert,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1537228800;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        final Settings indexSettings = indexMetaData.getSettings()__        if (indexSettings.hasValue(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE) == false) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final long lifecycleDate = indexSettings.getAsLong(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE, -1L)__        assert lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,final,settings,index,settings,index,meta,data,get,settings,if,index,settings,has,value,lifecycle,settings,false,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,index,settings,get,as,long,lifecycle,settings,1l,assert,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1537312077;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        final Settings indexSettings = indexMetaData.getSettings()__        if (indexSettings.hasValue(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE) == false) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final long lifecycleDate = indexSettings.getAsLong(LifecycleSettings.LIFECYCLE_INDEX_CREATION_DATE, -1L)__        assert lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,final,settings,index,settings,index,meta,data,get,settings,if,index,settings,has,value,lifecycle,settings,false,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,index,settings,get,as,long,lifecycle,settings,1l,assert,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1537390248;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1538423126;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1538424609;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1538532170;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1538662915;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1539019518;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1539729790;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1539758388;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1540329641;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1540394099;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1540477624;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1542051179;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1542231605;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1545246690;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase);1548261991;Return true or false depending on whether the index is ready to be in {@code phase};boolean isReadyToTransitionToThisPhase(final String policy, final IndexMetaData indexMetaData, final String phase) {_        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (lifecycleState.getLifecycleDate() == null) {_            logger.trace("no index creation date has been set yet")__            return true__        }_        final Long lifecycleDate = lifecycleState.getLifecycleDate()__        assert lifecycleDate != null && lifecycleDate >= 0 : "expected index to have a lifecycle date but it did not"__        final TimeValue after = stepRegistry.getIndexAgeForPhase(policy, phase)__        final long now = nowSupplier.getAsLong()__        final TimeValue age = new TimeValue(now - lifecycleDate)__        if (logger.isTraceEnabled()) {_            logger.trace("[{}] checking for index age to be at least [{}] before performing actions in " +_                    "the \"{}\" phase. Now: {}, lifecycle date: {}, age: [{}/{}s]",_                indexMetaData.getIndex().getName(), after, phase,_                new TimeValue(now).seconds(),_                new TimeValue(lifecycleDate).seconds(),_                age, age.seconds())__        }_        return now >= lifecycleDate + after.getMillis()__    };return,true,or,false,depending,on,whether,the,index,is,ready,to,be,in,code,phase;boolean,is,ready,to,transition,to,this,phase,final,string,policy,final,index,meta,data,index,meta,data,final,string,phase,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,state,get,lifecycle,date,null,logger,trace,no,index,creation,date,has,been,set,yet,return,true,final,long,lifecycle,date,lifecycle,state,get,lifecycle,date,assert,lifecycle,date,null,lifecycle,date,0,expected,index,to,have,a,lifecycle,date,but,it,did,not,final,time,value,after,step,registry,get,index,age,for,phase,policy,phase,final,long,now,now,supplier,get,as,long,final,time,value,age,new,time,value,now,lifecycle,date,if,logger,is,trace,enabled,logger,trace,checking,for,index,age,to,be,at,least,before,performing,actions,in,the,phase,now,lifecycle,date,age,s,index,meta,data,get,index,get,name,after,phase,new,time,value,now,seconds,new,time,value,lifecycle,date,seconds,age,age,seconds,return,now,lifecycle,date,after,get,millis
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1538532170;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("running periodic policy with current-step [{}]", currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.debug("cs-change-async-wait-callback, current-step: " + currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("ignoring non periodic step execution from step transition [{}]", currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,debug,cs,change,async,wait,callback,current,step,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1538662915;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("running periodic policy with current-step [{}]", currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.debug("cs-change-async-wait-callback, current-step: " + currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("ignoring non periodic step execution from step transition [{}]", currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,debug,cs,change,async,wait,callback,current,step,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1539019518;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1539729790;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1539758388;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1540329641;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1540394099;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1540477624;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1542051179;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1542231605;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1545246690;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void runPeriodicStep(String policy, IndexMetaData indexMetaData);1548261991;Run the current step, only if it is an asynchronous wait step. These_wait criteria are checked periodically from the ILM scheduler;public void runPeriodicStep(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running periodic step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        _        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof AsyncWaitStep) {_            logger.debug("[{}] running periodic policy with current-step [{}]", index, currentStep.getKey())__            ((AsyncWaitStep) currentStep).evaluateCondition(indexMetaData, new AsyncWaitStep.Listener() {__                @Override_                public void onResponse(boolean conditionMet, ToXContentObject stepInfo) {_                    logger.trace("cs-change-async-wait-callback, [{}] current-step: {}", index, currentStep.getKey())__                    if (conditionMet) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    } else if (stepInfo != null) {_                        setStepInfo(indexMetaData.getIndex(), policy, currentStep.getKey(), stepInfo)__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non periodic step execution from step transition [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,only,if,it,is,an,asynchronous,wait,step,these,wait,criteria,are,checked,periodically,from,the,ilm,scheduler;public,void,run,periodic,step,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,periodic,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,async,wait,step,logger,debug,running,periodic,policy,with,current,step,index,current,step,get,key,async,wait,step,current,step,evaluate,condition,index,meta,data,new,async,wait,step,listener,override,public,void,on,response,boolean,condition,met,to,xcontent,object,step,info,logger,trace,cs,change,async,wait,callback,current,step,index,current,step,get,key,if,condition,met,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,step,info,null,set,step,info,index,meta,data,get,index,policy,current,step,get,key,step,info,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,periodic,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1537390248;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1538423126;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1538424609;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1538532170;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1538662915;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1539019518;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1539729790;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1539758388;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1540329641;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1540394099;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1540477624;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1542051179;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1542231605;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1545246690;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState);1548261991;Retrieves the current {@link StepKey} from the index settings. Note that_it is illegal for the step to be set with the phase and/or action unset,_or for the step to be unset with the phase and/or action set. All three_settings must be either present or missing.__@param lifecycleState the index custom data to extract the {@link StepKey} from.;public static StepKey getCurrentStepKey(LifecycleExecutionState lifecycleState) {_        String currentPhase = lifecycleState.getPhase()__        String currentAction = lifecycleState.getAction()__        String currentStep = lifecycleState.getStep()__        if (Strings.isNullOrEmpty(currentStep)) {_            assert Strings.isNullOrEmpty(currentPhase) : "Current phase is not empty: " + currentPhase__            assert Strings.isNullOrEmpty(currentAction) : "Current action is not empty: " + currentAction__            return null__        } else {_            assert Strings.isNullOrEmpty(currentPhase) == false__            assert Strings.isNullOrEmpty(currentAction) == false__            return new StepKey(currentPhase, currentAction, currentStep)__        }_    };retrieves,the,current,link,step,key,from,the,index,settings,note,that,it,is,illegal,for,the,step,to,be,set,with,the,phase,and,or,action,unset,or,for,the,step,to,be,unset,with,the,phase,and,or,action,set,all,three,settings,must,be,either,present,or,missing,param,lifecycle,state,the,index,custom,data,to,extract,the,link,step,key,from;public,static,step,key,get,current,step,key,lifecycle,execution,state,lifecycle,state,string,current,phase,lifecycle,state,get,phase,string,current,action,lifecycle,state,get,action,string,current,step,lifecycle,state,get,step,if,strings,is,null,or,empty,current,step,assert,strings,is,null,or,empty,current,phase,current,phase,is,not,empty,current,phase,assert,strings,is,null,or,empty,current,action,current,action,is,not,empty,current,action,return,null,else,assert,strings,is,null,or,empty,current,phase,false,assert,strings,is,null,or,empty,current,action,false,return,new,step,key,current,phase,current,action,current,step
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1538532170;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("ignoring step execution from cluster state change event [{}]", currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1538662915;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("ignoring step execution from cluster state change event [{}]", currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1539019518;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1539729790;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1539758388;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1540329641;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1540394099;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1540477624;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1542051179;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1542231605;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1545246690;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData);1548261991;Run the current step that either waits for index age, or updates/waits-on cluster state._Invoked after the cluster state has been changed;public void runPolicyAfterStateChange(String policy, IndexMetaData indexMetaData) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            if (stepRegistry.policyExists(policy) == false) {_                markPolicyDoesNotExist(policy, indexMetaData.getIndex(), lifecycleState)__                return__            } else {_                logger.error("current step [{}] for index [{}] with policy [{}] is not recognized",_                    getCurrentStepKey(lifecycleState), index, policy)__                return__            }_        }__        if (currentStep instanceof TerminalPolicyStep) {_            logger.debug("policy [{}] for index [{}] complete, skipping execution", policy, index)__            return__        } else if (currentStep instanceof ErrorStep) {_            logger.debug("policy [{}] for index [{}] on an error step, skipping execution", policy, index)__            return__        }__        logger.trace("[{}] maybe running step ({}) after state change: {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep instanceof PhaseCompleteStep) {_            _            if (isReadyToTransitionToThisPhase(policy, indexMetaData, currentStep.getNextStepKey().getPhase())) {_                moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__            }_        } else if (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_            logger.debug("[{}] running policy with current-step [{}]", indexMetaData.getIndex().getName(), currentStep.getKey())__            clusterService.submitStateUpdateTask("ilm-execute-cluster-state-steps",_                new ExecuteStepsUpdateTask(policy, indexMetaData.getIndex(), currentStep, stepRegistry, this, nowSupplier))__        } else {_            logger.trace("[{}] ignoring step execution from cluster state change event [{}]", index, currentStep.getKey())__        }_    };run,the,current,step,that,either,waits,for,index,age,or,updates,waits,on,cluster,state,invoked,after,the,cluster,state,has,been,changed;public,void,run,policy,after,state,change,string,policy,index,meta,data,index,meta,data,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,if,step,registry,policy,exists,policy,false,mark,policy,does,not,exist,policy,index,meta,data,get,index,lifecycle,state,return,else,logger,error,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,instanceof,terminal,policy,step,logger,debug,policy,for,index,complete,skipping,execution,policy,index,return,else,if,current,step,instanceof,error,step,logger,debug,policy,for,index,on,an,error,step,skipping,execution,policy,index,return,logger,trace,maybe,running,step,after,state,change,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,instanceof,phase,complete,step,if,is,ready,to,transition,to,this,phase,policy,index,meta,data,current,step,get,next,step,key,get,phase,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,else,if,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,logger,debug,running,policy,with,current,step,index,meta,data,get,index,get,name,current,step,get,key,cluster,service,submit,state,update,task,ilm,execute,cluster,state,steps,new,execute,steps,update,task,policy,index,meta,data,get,index,current,step,step,registry,this,now,supplier,else,logger,trace,ignoring,step,execution,from,cluster,state,change,event,index,current,step,get,key
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry, boolean forcePhaseDefinitionRefresh);1542051179;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@param forcePhaseDefinitionRefresh When true, step information will be recompiled from the latest version of the_policy. Otherwise, existing phase definition is used._@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry, boolean forcePhaseDefinitionRefresh) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey,_            nextStepKey, nowSupplier, forcePhaseDefinitionRefresh)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,param,force,phase,definition,refresh,when,true,step,information,will,be,recompiled,from,the,latest,version,of,the,policy,otherwise,existing,phase,definition,is,used,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,boolean,force,phase,definition,refresh,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier,force,phase,definition,refresh
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry, boolean forcePhaseDefinitionRefresh);1542231605;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@param forcePhaseDefinitionRefresh When true, step information will be recompiled from the latest version of the_policy. Otherwise, existing phase definition is used._@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry, boolean forcePhaseDefinitionRefresh) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey,_            nextStepKey, nowSupplier, forcePhaseDefinitionRefresh)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,param,force,phase,definition,refresh,when,true,step,information,will,be,recompiled,from,the,latest,version,of,the,policy,otherwise,existing,phase,definition,is,used,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,boolean,force,phase,definition,refresh,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier,force,phase,definition,refresh
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry, boolean forcePhaseDefinitionRefresh);1545246690;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@param forcePhaseDefinitionRefresh When true, step information will be recompiled from the latest version of the_policy. Otherwise, existing phase definition is used._@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry, boolean forcePhaseDefinitionRefresh) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey,_            nextStepKey, nowSupplier, forcePhaseDefinitionRefresh)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,param,force,phase,definition,refresh,when,true,step,information,will,be,recompiled,from,the,latest,version,of,the,policy,otherwise,existing,phase,definition,is,used,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,boolean,force,phase,definition,refresh,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier,force,phase,definition,refresh
IndexLifecycleRunner -> static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,                                                StepKey nextStepKey, LongSupplier nowSupplier,                                                PolicyStepsRegistry stepRegistry, boolean forcePhaseDefinitionRefresh);1548261991;This method is intended for handling moving to different steps from {@link TransportAction} executions._For this reason, it is reasonable to throw {@link IllegalArgumentException} when state is not as expected.__@param indexName      The index whose step is to change_@param currentState   The current {@link ClusterState}_@param currentStepKey The current {@link StepKey} found for the index in the current cluster state_@param nextStepKey    The next step to move the index into_@param nowSupplier    The current-time supplier for updating when steps changed_@param stepRegistry   The steps registry to check a step-key's existence in the index's current policy_@param forcePhaseDefinitionRefresh When true, step information will be recompiled from the latest version of the_policy. Otherwise, existing phase definition is used._@return The updated cluster state where the index moved to <code>nextStepKey</code>;static ClusterState moveClusterStateToStep(String indexName, ClusterState currentState, StepKey currentStepKey,_                                               StepKey nextStepKey, LongSupplier nowSupplier,_                                               PolicyStepsRegistry stepRegistry, boolean forcePhaseDefinitionRefresh) {_        IndexMetaData idxMeta = currentState.getMetaData().index(indexName)__        Settings indexSettings = idxMeta.getSettings()__        String indexPolicySetting = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings)___        _        if (Strings.isNullOrEmpty(indexPolicySetting)) {_            throw new IllegalArgumentException("index [" + indexName + "] is not associated with an Index Lifecycle Policy")__        }__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta)__        if (currentStepKey.equals(IndexLifecycleRunner.getCurrentStepKey(lifecycleState)) == false) {_            throw new IllegalArgumentException("index [" + indexName + "] is not on current step [" + currentStepKey + "]")__        }__        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {_            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +_                "] with policy [" + indexPolicySetting + "] does not exist")__        }__        return IndexLifecycleRunner.moveClusterStateToNextStep(idxMeta.getIndex(), currentState, currentStepKey,_            nextStepKey, nowSupplier, forcePhaseDefinitionRefresh)__    };this,method,is,intended,for,handling,moving,to,different,steps,from,link,transport,action,executions,for,this,reason,it,is,reasonable,to,throw,link,illegal,argument,exception,when,state,is,not,as,expected,param,index,name,the,index,whose,step,is,to,change,param,current,state,the,current,link,cluster,state,param,current,step,key,the,current,link,step,key,found,for,the,index,in,the,current,cluster,state,param,next,step,key,the,next,step,to,move,the,index,into,param,now,supplier,the,current,time,supplier,for,updating,when,steps,changed,param,step,registry,the,steps,registry,to,check,a,step,key,s,existence,in,the,index,s,current,policy,param,force,phase,definition,refresh,when,true,step,information,will,be,recompiled,from,the,latest,version,of,the,policy,otherwise,existing,phase,definition,is,used,return,the,updated,cluster,state,where,the,index,moved,to,code,next,step,key,code;static,cluster,state,move,cluster,state,to,step,string,index,name,cluster,state,current,state,step,key,current,step,key,step,key,next,step,key,long,supplier,now,supplier,policy,steps,registry,step,registry,boolean,force,phase,definition,refresh,index,meta,data,idx,meta,current,state,get,meta,data,index,index,name,settings,index,settings,idx,meta,get,settings,string,index,policy,setting,lifecycle,settings,get,index,settings,if,strings,is,null,or,empty,index,policy,setting,throw,new,illegal,argument,exception,index,index,name,is,not,associated,with,an,index,lifecycle,policy,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,idx,meta,if,current,step,key,equals,index,lifecycle,runner,get,current,step,key,lifecycle,state,false,throw,new,illegal,argument,exception,index,index,name,is,not,on,current,step,current,step,key,if,step,registry,step,exists,index,policy,setting,next,step,key,false,throw,new,illegal,argument,exception,step,next,step,key,for,index,idx,meta,get,index,get,name,with,policy,index,policy,setting,does,not,exist,return,index,lifecycle,runner,move,cluster,state,to,next,step,idx,meta,get,index,current,state,current,step,key,next,step,key,now,supplier,force,phase,definition,refresh
IndexLifecycleRunner -> public static boolean canUpdatePolicy(String policyName, LifecyclePolicy newPolicy, ClusterState currentState);1533229511;Returns <code>true</code> if the provided policy is allowed to be updated_given the current {@link ClusterState}. In practice this method checks_that all the indexes using the provided <code>policyName</code> is in a_state where it is able to deal with the policy being updated to_<code>newPolicy</code>. If any of these indexes is not in a state wheree_it can deal with the update the method will return <code>false</code>.__@param policyName_the name of the policy being updated_@param newPolicy_the new version of the {@link LifecyclePolicy}_@param currentState_the current {@link ClusterState};public static boolean canUpdatePolicy(String policyName, LifecyclePolicy newPolicy, ClusterState currentState) {_        Map<String, LifecyclePolicy> policiesMap = ((IndexLifecycleMetadata) currentState.metaData().custom(IndexLifecycleMetadata.TYPE))_                .getPolicies()__        for (ObjectCursor<IndexMetaData> cursor : currentState.getMetaData().indices().values()) {_            IndexMetaData idxMetadata = cursor.value__            Settings idxSettings = idxMetadata.getSettings()__            String currentPolicyName = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(idxSettings)__            LifecyclePolicy currentPolicy = null__            if (Strings.hasLength(currentPolicyName)) {_                currentPolicy = policiesMap.get(currentPolicyName)__            }_            if (policyName.equals(currentPolicyName)) {_                StepKey currentStepKey = IndexLifecycleRunner.getCurrentStepKey(idxSettings)__                if (canSetPolicy(currentStepKey, currentPolicy, newPolicy) == false) {_                    return false__                }_            }_        }_        return true__    };returns,code,true,code,if,the,provided,policy,is,allowed,to,be,updated,given,the,current,link,cluster,state,in,practice,this,method,checks,that,all,the,indexes,using,the,provided,code,policy,name,code,is,in,a,state,where,it,is,able,to,deal,with,the,policy,being,updated,to,code,new,policy,code,if,any,of,these,indexes,is,not,in,a,state,wheree,it,can,deal,with,the,update,the,method,will,return,code,false,code,param,policy,name,the,name,of,the,policy,being,updated,param,new,policy,the,new,version,of,the,link,lifecycle,policy,param,current,state,the,current,link,cluster,state;public,static,boolean,can,update,policy,string,policy,name,lifecycle,policy,new,policy,cluster,state,current,state,map,string,lifecycle,policy,policies,map,index,lifecycle,metadata,current,state,meta,data,custom,index,lifecycle,metadata,type,get,policies,for,object,cursor,index,meta,data,cursor,current,state,get,meta,data,indices,values,index,meta,data,idx,metadata,cursor,value,settings,idx,settings,idx,metadata,get,settings,string,current,policy,name,lifecycle,settings,get,idx,settings,lifecycle,policy,current,policy,null,if,strings,has,length,current,policy,name,current,policy,policies,map,get,current,policy,name,if,policy,name,equals,current,policy,name,step,key,current,step,key,index,lifecycle,runner,get,current,step,key,idx,settings,if,can,set,policy,current,step,key,current,policy,new,policy,false,return,false,return,true
IndexLifecycleRunner -> public static boolean canUpdatePolicy(String policyName, LifecyclePolicy newPolicy, ClusterState currentState);1534567515;Returns <code>true</code> if the provided policy is allowed to be updated_given the current {@link ClusterState}. In practice this method checks_that all the indexes using the provided <code>policyName</code> is in a_state where it is able to deal with the policy being updated to_<code>newPolicy</code>. If any of these indexes is not in a state wheree_it can deal with the update the method will return <code>false</code>.__@param policyName_the name of the policy being updated_@param newPolicy_the new version of the {@link LifecyclePolicy}_@param currentState_the current {@link ClusterState};public static boolean canUpdatePolicy(String policyName, LifecyclePolicy newPolicy, ClusterState currentState) {_        Map<String, LifecyclePolicy> policiesMap = ((IndexLifecycleMetadata) currentState.metaData().custom(IndexLifecycleMetadata.TYPE))_                .getPolicies()__        for (ObjectCursor<IndexMetaData> cursor : currentState.getMetaData().indices().values()) {_            IndexMetaData idxMetadata = cursor.value__            Settings idxSettings = idxMetadata.getSettings()__            String currentPolicyName = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(idxSettings)__            LifecyclePolicy currentPolicy = null__            if (Strings.hasLength(currentPolicyName)) {_                currentPolicy = policiesMap.get(currentPolicyName)__            }_            if (policyName.equals(currentPolicyName)) {_                StepKey currentStepKey = IndexLifecycleRunner.getCurrentStepKey(idxSettings)__                if (canSetPolicy(currentStepKey, currentPolicy, newPolicy) == false) {_                    return false__                }_            }_        }_        return true__    };returns,code,true,code,if,the,provided,policy,is,allowed,to,be,updated,given,the,current,link,cluster,state,in,practice,this,method,checks,that,all,the,indexes,using,the,provided,code,policy,name,code,is,in,a,state,where,it,is,able,to,deal,with,the,policy,being,updated,to,code,new,policy,code,if,any,of,these,indexes,is,not,in,a,state,wheree,it,can,deal,with,the,update,the,method,will,return,code,false,code,param,policy,name,the,name,of,the,policy,being,updated,param,new,policy,the,new,version,of,the,link,lifecycle,policy,param,current,state,the,current,link,cluster,state;public,static,boolean,can,update,policy,string,policy,name,lifecycle,policy,new,policy,cluster,state,current,state,map,string,lifecycle,policy,policies,map,index,lifecycle,metadata,current,state,meta,data,custom,index,lifecycle,metadata,type,get,policies,for,object,cursor,index,meta,data,cursor,current,state,get,meta,data,indices,values,index,meta,data,idx,metadata,cursor,value,settings,idx,settings,idx,metadata,get,settings,string,current,policy,name,lifecycle,settings,get,idx,settings,lifecycle,policy,current,policy,null,if,strings,has,length,current,policy,name,current,policy,policies,map,get,current,policy,name,if,policy,name,equals,current,policy,name,step,key,current,step,key,index,lifecycle,runner,get,current,step,key,idx,settings,if,can,set,policy,current,step,key,current,policy,new,policy,false,return,false,return,true
IndexLifecycleRunner -> public static boolean canUpdatePolicy(String policyName, LifecyclePolicy newPolicy, ClusterState currentState);1534879781;Returns <code>true</code> if the provided policy is allowed to be updated_given the current {@link ClusterState}. In practice this method checks_that all the indexes using the provided <code>policyName</code> is in a_state where it is able to deal with the policy being updated to_<code>newPolicy</code>. If any of these indexes is not in a state wheree_it can deal with the update the method will return <code>false</code>.__@param policyName_the name of the policy being updated_@param newPolicy_the new version of the {@link LifecyclePolicy}_@param currentState_the current {@link ClusterState};public static boolean canUpdatePolicy(String policyName, LifecyclePolicy newPolicy, ClusterState currentState) {_        Map<String, LifecyclePolicy> policiesMap = ((IndexLifecycleMetadata) currentState.metaData().custom(IndexLifecycleMetadata.TYPE))_                .getPolicies()__        for (ObjectCursor<IndexMetaData> cursor : currentState.getMetaData().indices().values()) {_            IndexMetaData idxMetadata = cursor.value__            Settings idxSettings = idxMetadata.getSettings()__            String currentPolicyName = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(idxSettings)__            LifecyclePolicy currentPolicy = null__            if (Strings.hasLength(currentPolicyName)) {_                currentPolicy = policiesMap.get(currentPolicyName)__            }_            if (policyName.equals(currentPolicyName)) {_                StepKey currentStepKey = IndexLifecycleRunner.getCurrentStepKey(idxSettings)__                if (canSetPolicy(currentStepKey, currentPolicy, newPolicy) == false) {_                    return false__                }_            }_        }_        return true__    };returns,code,true,code,if,the,provided,policy,is,allowed,to,be,updated,given,the,current,link,cluster,state,in,practice,this,method,checks,that,all,the,indexes,using,the,provided,code,policy,name,code,is,in,a,state,where,it,is,able,to,deal,with,the,policy,being,updated,to,code,new,policy,code,if,any,of,these,indexes,is,not,in,a,state,wheree,it,can,deal,with,the,update,the,method,will,return,code,false,code,param,policy,name,the,name,of,the,policy,being,updated,param,new,policy,the,new,version,of,the,link,lifecycle,policy,param,current,state,the,current,link,cluster,state;public,static,boolean,can,update,policy,string,policy,name,lifecycle,policy,new,policy,cluster,state,current,state,map,string,lifecycle,policy,policies,map,index,lifecycle,metadata,current,state,meta,data,custom,index,lifecycle,metadata,type,get,policies,for,object,cursor,index,meta,data,cursor,current,state,get,meta,data,indices,values,index,meta,data,idx,metadata,cursor,value,settings,idx,settings,idx,metadata,get,settings,string,current,policy,name,lifecycle,settings,get,idx,settings,lifecycle,policy,current,policy,null,if,strings,has,length,current,policy,name,current,policy,policies,map,get,current,policy,name,if,policy,name,equals,current,policy,name,step,key,current,step,key,index,lifecycle,runner,get,current,step,key,idx,settings,if,can,set,policy,current,step,key,current,policy,new,policy,false,return,false,return,true
IndexLifecycleRunner -> public static boolean canUpdatePolicy(String policyName, LifecyclePolicy newPolicy, ClusterState currentState);1534899572;Returns <code>true</code> if the provided policy is allowed to be updated_given the current {@link ClusterState}. In practice this method checks_that all the indexes using the provided <code>policyName</code> is in a_state where it is able to deal with the policy being updated to_<code>newPolicy</code>. If any of these indexes is not in a state wheree_it can deal with the update the method will return <code>false</code>.__@param policyName_the name of the policy being updated_@param newPolicy_the new version of the {@link LifecyclePolicy}_@param currentState_the current {@link ClusterState};public static boolean canUpdatePolicy(String policyName, LifecyclePolicy newPolicy, ClusterState currentState) {_        Map<String, LifecyclePolicy> policiesMap = ((IndexLifecycleMetadata) currentState.metaData().custom(IndexLifecycleMetadata.TYPE))_                .getPolicies()__        for (ObjectCursor<IndexMetaData> cursor : currentState.getMetaData().indices().values()) {_            IndexMetaData idxMetadata = cursor.value__            Settings idxSettings = idxMetadata.getSettings()__            String currentPolicyName = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(idxSettings)__            LifecyclePolicy currentPolicy = null__            if (Strings.hasLength(currentPolicyName)) {_                currentPolicy = policiesMap.get(currentPolicyName)__            }_            if (policyName.equals(currentPolicyName)) {_                StepKey currentStepKey = IndexLifecycleRunner.getCurrentStepKey(idxSettings)__                if (canSetPolicy(currentStepKey, currentPolicy, newPolicy) == false) {_                    return false__                }_            }_        }_        return true__    };returns,code,true,code,if,the,provided,policy,is,allowed,to,be,updated,given,the,current,link,cluster,state,in,practice,this,method,checks,that,all,the,indexes,using,the,provided,code,policy,name,code,is,in,a,state,where,it,is,able,to,deal,with,the,policy,being,updated,to,code,new,policy,code,if,any,of,these,indexes,is,not,in,a,state,wheree,it,can,deal,with,the,update,the,method,will,return,code,false,code,param,policy,name,the,name,of,the,policy,being,updated,param,new,policy,the,new,version,of,the,link,lifecycle,policy,param,current,state,the,current,link,cluster,state;public,static,boolean,can,update,policy,string,policy,name,lifecycle,policy,new,policy,cluster,state,current,state,map,string,lifecycle,policy,policies,map,index,lifecycle,metadata,current,state,meta,data,custom,index,lifecycle,metadata,type,get,policies,for,object,cursor,index,meta,data,cursor,current,state,get,meta,data,indices,values,index,meta,data,idx,metadata,cursor,value,settings,idx,settings,idx,metadata,get,settings,string,current,policy,name,lifecycle,settings,get,idx,settings,lifecycle,policy,current,policy,null,if,strings,has,length,current,policy,name,current,policy,policies,map,get,current,policy,name,if,policy,name,equals,current,policy,name,step,key,current,step,key,index,lifecycle,runner,get,current,step,key,idx,settings,if,can,set,policy,current,step,key,current,policy,new,policy,false,return,false,return,true
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1538532170;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("running policy with async action step [{}]", currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.debug("cs-change-async-action-callback, current-step: [{}]", currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("ignoring non async action step execution from step transition [{}]", currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,debug,cs,change,async,action,callback,current,step,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1538662915;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("running policy with async action step [{}]", currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.debug("cs-change-async-action-callback, current-step: [{}]", currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("ignoring non async action step execution from step transition [{}]", currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,debug,cs,change,async,action,callback,current,step,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1539019518;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1539729790;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1539758388;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1540329641;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1540394099;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        Settings indexSettings = indexMetaData.getSettings()__        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        if (LifecycleSettings.LIFECYCLE_SKIP_SETTING.get(indexSettings)) {_            logger.info("skipping policy [{}] for index [{}]: {} == true", policy, index, LifecycleSettings.LIFECYCLE_SKIP)__            return__        }_        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,settings,index,settings,index,meta,data,get,settings,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,if,lifecycle,settings,get,index,settings,logger,info,skipping,policy,for,index,true,policy,index,lifecycle,settings,return,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1540477624;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1542051179;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1542231605;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1545246690;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState, new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
IndexLifecycleRunner -> public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey);1548261991;If the current step (matching the expected step key) is an asynchronous action step, run it;public void maybeRunAsyncAction(ClusterState currentState, IndexMetaData indexMetaData, String policy, StepKey expectedStepKey) {_        String index = indexMetaData.getIndex().getName()__        LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(indexMetaData)__        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData, lifecycleState)__        if (currentStep == null) {_            logger.warn("current step [{}] for index [{}] with policy [{}] is not recognized",_                getCurrentStepKey(lifecycleState), index, policy)__            return__        }__        logger.trace("[{}] maybe running async action step ({}) with current step {}",_            index, currentStep.getClass().getSimpleName(), currentStep.getKey())__        if (currentStep.getKey().equals(expectedStepKey) == false) {_            throw new IllegalStateException("expected index [" + indexMetaData.getIndex().getName() + "] with policy [" + policy +_                "] to have current step consistent with provided step key (" + expectedStepKey + ") but it was " + currentStep.getKey())__        }_        if (currentStep instanceof AsyncActionStep) {_            logger.debug("[{}] running policy with async action step [{}]", index, currentStep.getKey())__            ((AsyncActionStep) currentStep).performAction(indexMetaData, currentState,_                new ClusterStateObserver(clusterService, null, logger, threadPool.getThreadContext()), new AsyncActionStep.Listener() {__                @Override_                public void onResponse(boolean complete) {_                    logger.trace("cs-change-async-action-callback, [{}], current-step: {}", index, currentStep.getKey())__                    if (complete && ((AsyncActionStep) currentStep).indexSurvives()) {_                        moveToStep(indexMetaData.getIndex(), policy, currentStep.getKey(), currentStep.getNextStepKey())__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    moveToErrorStep(indexMetaData.getIndex(), policy, currentStep.getKey(), e)__                }_            })__        } else {_            logger.trace("[{}] ignoring non async action step execution from step transition [{}]", index, currentStep.getKey())__        }_    };if,the,current,step,matching,the,expected,step,key,is,an,asynchronous,action,step,run,it;public,void,maybe,run,async,action,cluster,state,current,state,index,meta,data,index,meta,data,string,policy,step,key,expected,step,key,string,index,index,meta,data,get,index,get,name,lifecycle,execution,state,lifecycle,state,lifecycle,execution,state,from,index,metadata,index,meta,data,step,current,step,get,current,step,step,registry,policy,index,meta,data,lifecycle,state,if,current,step,null,logger,warn,current,step,for,index,with,policy,is,not,recognized,get,current,step,key,lifecycle,state,index,policy,return,logger,trace,maybe,running,async,action,step,with,current,step,index,current,step,get,class,get,simple,name,current,step,get,key,if,current,step,get,key,equals,expected,step,key,false,throw,new,illegal,state,exception,expected,index,index,meta,data,get,index,get,name,with,policy,policy,to,have,current,step,consistent,with,provided,step,key,expected,step,key,but,it,was,current,step,get,key,if,current,step,instanceof,async,action,step,logger,debug,running,policy,with,async,action,step,index,current,step,get,key,async,action,step,current,step,perform,action,index,meta,data,current,state,new,cluster,state,observer,cluster,service,null,logger,thread,pool,get,thread,context,new,async,action,step,listener,override,public,void,on,response,boolean,complete,logger,trace,cs,change,async,action,callback,current,step,index,current,step,get,key,if,complete,async,action,step,current,step,index,survives,move,to,step,index,meta,data,get,index,policy,current,step,get,key,current,step,get,next,step,key,override,public,void,on,failure,exception,e,move,to,error,step,index,meta,data,get,index,policy,current,step,get,key,e,else,logger,trace,ignoring,non,async,action,step,execution,from,step,transition,index,current,step,get,key
