commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;11;;@Override protected IndexLifecycleMetadata createTestInstance() {     int numPolicies = randomIntBetween(1, 5).     Map<String, LifecyclePolicyMetadata> policies = new HashMap<>(numPolicies).     for (int i = 0. i < numPolicies. i++) {         LifecyclePolicy policy = randomTimeseriesLifecyclePolicy(randomAlphaOfLength(4) + i).         policies.put(policy.getName(), new LifecyclePolicyMetadata(policy, Collections.emptyMap(), randomNonNegativeLong(), randomNonNegativeLong())).     }     return new IndexLifecycleMetadata(policies, randomFrom(OperationMode.values())). }
false;protected;1;4;;@Override protected IndexLifecycleMetadata doParseInstance(XContentParser parser) throws IOException {     return IndexLifecycleMetadata.PARSER.apply(parser, null). }
false;protected;0;4;;@Override protected Reader<MetaData.Custom> instanceReader() {     return IndexLifecycleMetadata::new. }
false;protected;0;17;;@Override protected NamedWriteableRegistry getNamedWriteableRegistry() {     return new NamedWriteableRegistry(Arrays.asList(new NamedWriteableRegistry.Entry(LifecycleType.class, TimeseriesLifecycleType.TYPE, (in) -> TimeseriesLifecycleType.INSTANCE), new NamedWriteableRegistry.Entry(LifecycleAction.class, AllocateAction.NAME, AllocateAction::new), new NamedWriteableRegistry.Entry(LifecycleAction.class, DeleteAction.NAME, DeleteAction::new), new NamedWriteableRegistry.Entry(LifecycleAction.class, ForceMergeAction.NAME, ForceMergeAction::new), new NamedWriteableRegistry.Entry(LifecycleAction.class, ReadOnlyAction.NAME, ReadOnlyAction::new), new NamedWriteableRegistry.Entry(LifecycleAction.class, RolloverAction.NAME, RolloverAction::new), new NamedWriteableRegistry.Entry(LifecycleAction.class, ShrinkAction.NAME, ShrinkAction::new), new NamedWriteableRegistry.Entry(LifecycleAction.class, FreezeAction.NAME, FreezeAction::new), new NamedWriteableRegistry.Entry(LifecycleAction.class, SetPriorityAction.NAME, SetPriorityAction::new), new NamedWriteableRegistry.Entry(LifecycleAction.class, UnfollowAction.NAME, UnfollowAction::new))). }
false;protected;0;18;;@Override protected NamedXContentRegistry xContentRegistry() {     List<NamedXContentRegistry.Entry> entries = new ArrayList<>(ClusterModule.getNamedXWriteables()).     entries.addAll(Arrays.asList(new NamedXContentRegistry.Entry(LifecycleType.class, new ParseField(TimeseriesLifecycleType.TYPE), (p) -> TimeseriesLifecycleType.INSTANCE), new NamedXContentRegistry.Entry(LifecycleAction.class, new ParseField(AllocateAction.NAME), AllocateAction::parse), new NamedXContentRegistry.Entry(LifecycleAction.class, new ParseField(DeleteAction.NAME), DeleteAction::parse), new NamedXContentRegistry.Entry(LifecycleAction.class, new ParseField(ForceMergeAction.NAME), ForceMergeAction::parse), new NamedXContentRegistry.Entry(LifecycleAction.class, new ParseField(ReadOnlyAction.NAME), ReadOnlyAction::parse), new NamedXContentRegistry.Entry(LifecycleAction.class, new ParseField(RolloverAction.NAME), RolloverAction::parse), new NamedXContentRegistry.Entry(LifecycleAction.class, new ParseField(ShrinkAction.NAME), ShrinkAction::parse), new NamedXContentRegistry.Entry(LifecycleAction.class, new ParseField(FreezeAction.NAME), FreezeAction::parse), new NamedXContentRegistry.Entry(LifecycleAction.class, new ParseField(SetPriorityAction.NAME), SetPriorityAction::parse), new NamedXContentRegistry.Entry(LifecycleAction.class, new ParseField(UnfollowAction.NAME), UnfollowAction::parse))).     return new NamedXContentRegistry(entries). }
false;protected;1;15;;@Override protected MetaData.Custom mutateInstance(MetaData.Custom instance) {     IndexLifecycleMetadata metadata = (IndexLifecycleMetadata) instance.     Map<String, LifecyclePolicyMetadata> policies = metadata.getPolicyMetadatas().     policies = new TreeMap<>(policies).     OperationMode mode = metadata.getOperationMode().     if (randomBoolean()) {         String policyName = randomAlphaOfLength(10).         policies.put(policyName, new LifecyclePolicyMetadata(randomTimeseriesLifecyclePolicy(policyName), Collections.emptyMap(), randomNonNegativeLong(), randomNonNegativeLong())).     } else {         mode = randomValueOtherThan(metadata.getOperationMode(), () -> randomFrom(OperationMode.values())).     }     return new IndexLifecycleMetadata(policies, mode). }
false;protected;1;4;;@Override protected Custom makeTestChanges(Custom testInstance) {     return mutateInstance(testInstance). }
false;protected;0;4;;@Override protected Reader<Diff<Custom>> diffReader() {     return IndexLifecycleMetadataDiff::new. }
false;public;0;3;;public void testMinimumSupportedVersion() {     assertEquals(Version.V_7_0_0, createTestInstance().getMinimalSupportedVersion()). }
false;public;0;3;;public void testcontext() {     assertEquals(MetaData.ALL_CONTEXTS, createTestInstance().context()). }
false;public,static;2;20;;public static IndexLifecycleMetadata createTestInstance(int numPolicies, OperationMode mode) {     SortedMap<String, LifecyclePolicyMetadata> policies = new TreeMap<>().     for (int i = 0. i < numPolicies. i++) {         int numberPhases = randomInt(5).         Map<String, Phase> phases = new HashMap<>(numberPhases).         for (int j = 0. j < numberPhases. j++) {             TimeValue after = TimeValue.parseTimeValue(randomTimeValue(0, 1000000000, "s", "m", "h", "d"), "test_after").             Map<String, LifecycleAction> actions = Collections.emptyMap().             if (randomBoolean()) {                 actions = Collections.singletonMap(DeleteAction.NAME, new DeleteAction()).             }             String phaseName = randomAlphaOfLength(10).             phases.put(phaseName, new Phase(phaseName, after, actions)).         }         String policyName = randomAlphaOfLength(10).         policies.put(policyName, new LifecyclePolicyMetadata(newTestLifecyclePolicy(policyName, phases), Collections.emptyMap(), randomNonNegativeLong(), randomNonNegativeLong())).     }     return new IndexLifecycleMetadata(policies, mode). }
