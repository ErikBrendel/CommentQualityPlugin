commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected boolean shouldCollect(final boolean isElectedMaster) {     // This collector can always collect data on the master node     return isElectedMaster. }
false;protected;3;29;;@Override protected Collection<MonitoringDoc> doCollect(final MonitoringDoc.Node node, final long interval, final ClusterState clusterState) throws Exception {     final Supplier<ClusterStatsResponse> clusterStatsSupplier = () -> client.admin().cluster().prepareClusterStats().get(getCollectionTimeout()).     final Supplier<List<XPackFeatureSet.Usage>> usageSupplier = () -> new XPackUsageRequestBuilder(client).get().getUsages().     final ClusterStatsResponse clusterStats = clusterStatsSupplier.get().     final String clusterName = clusterService.getClusterName().value().     final String clusterUuid = clusterUuid(clusterState).     final String version = Version.CURRENT.toString().     final License license = licenseService.getLicense().     final List<XPackFeatureSet.Usage> xpackUsage = collect(usageSupplier).     final boolean apmIndicesExist = doAPMIndicesExist(clusterState).     // if they have any other type of license, then they are either okay or already know     final boolean clusterNeedsTLSEnabled = license.operationMode() == License.OperationMode.TRIAL && settings.hasValue(SECURITY_ENABLED.getKey()) && SECURITY_ENABLED.get(settings) && TRANSPORT_SSL_ENABLED.get(settings) == false.     // Adds a cluster stats document     return Collections.singleton(new ClusterStatsMonitoringDoc(clusterUuid, timestamp(), interval, node, clusterName, version, clusterStats.getStatus(), license, apmIndicesExist, xpackUsage, clusterStats, clusterState, clusterNeedsTLSEnabled)). }
false;;1;10;;boolean doAPMIndicesExist(final ClusterState clusterState) {     try {         final Index[] indices = indexNameExpressionResolver.concreteIndices(clusterState, IndicesOptions.lenientExpandOpen(), "apm-*").         return indices.length > 0.     } catch (IndexNotFoundException | IllegalArgumentException e) {         return false.     } }
false;private;1;15;;@Nullable private <T> T collect(final Supplier<T> supplier) {     try {         return supplier.get().     } catch (ElasticsearchSecurityException e) {         if (LicenseUtils.isLicenseExpiredException(e)) {             logger.trace((Supplier<?>) () -> new ParameterizedMessage("collector [{}] - " + "unable to collect data because of expired license", name()), e).         } else {             throw e.         }     }     return null. }
