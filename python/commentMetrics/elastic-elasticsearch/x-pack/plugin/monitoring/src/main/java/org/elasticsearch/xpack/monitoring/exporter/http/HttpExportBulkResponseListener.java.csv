commented;modifiers;parameterAmount;loc;comment;code
true;public;1;31;/**  * Success is relative with bulk responses because unless it's rejected outright, it returns with a 200.  * <p>  * Individual documents can fail and since we know how we're making them, that means that .  */ ;/**  * Success is relative with bulk responses because unless it's rejected outright, it returns with a 200.  * <p>  * Individual documents can fail and since we know how we're making them, that means that .  */ @Override public void onSuccess(final Response response) {     // EMPTY is safe here because we never call namedObject     try (XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, response.getEntity().getContent())) {         // avoid parsing the entire payload if we don't need too         XContentParser.Token token = parser.nextToken().         if (token == XContentParser.Token.START_OBJECT) {             String currentFieldName = null.             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     currentFieldName = parser.currentName().                 } else if (token.isValue()) {                     if ("errors".equals(currentFieldName)) {                         // no errors? then we can stop looking                         if (parser.booleanValue() == false) {                             return.                         }                     }                 } else if (token == XContentParser.Token.START_ARRAY) {                     // note: this assumes that "items" is the only array portion of the response (currently true)                     parseErrors(parser).                     return.                 }             }         }     } catch (IOException | RuntimeException e) {         onError("unexpected exception while verifying bulk response", e).     } }
true;private;1;14;/**  * Logs every <code>error</code> field's value until it hits the end of an array.  *  * @param parser The bulk response parser  * @throws IOException if any parsing error occurs  */ ;/**  * Logs every <code>error</code> field's value until it hits the end of an array.  *  * @param parser The bulk response parser  * @throws IOException if any parsing error occurs  */ private void parseErrors(final XContentParser parser) throws IOException {     XContentParser.Token token.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if ("error".equals(currentFieldName)) {                 onItemError(parser.text()).             }         }     } }
true;public;1;7;/**  * Log obvious failures.  * <p>  * In the future, we should queue replayable failures.  */ ;/**  * Log obvious failures.  * <p>  * In the future, we should queue replayable failures.  */ @Override public void onFailure(final Exception exception) {     // queueable exceptions:     // - RestStatus.TOO_MANY_REQUESTS.getStatus()     // - possibly other, non-ResponseExceptions     onError("bulk request failed unexpectedly", exception). }
false;;2;3;;void onError(final String msg, final Throwable cause) {     logger.warn(msg, cause). }
false;;1;3;;void onItemError(final String text) {     logger.warn("unexpected error while indexing monitoring document: [{}]", text). }
