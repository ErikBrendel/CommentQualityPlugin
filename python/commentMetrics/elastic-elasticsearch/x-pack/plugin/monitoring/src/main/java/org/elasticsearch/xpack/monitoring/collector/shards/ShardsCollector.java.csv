commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected boolean shouldCollect(final boolean isElectedMaster) {     return isElectedMaster && super.shouldCollect(isElectedMaster). }
false;protected;3;32;;@Override protected Collection<MonitoringDoc> doCollect(final MonitoringDoc.Node node, final long interval, final ClusterState clusterState) throws Exception {     final List<MonitoringDoc> results = new ArrayList<>(1).     if (clusterState != null) {         RoutingTable routingTable = clusterState.routingTable().         if (routingTable != null) {             List<ShardRouting> shards = routingTable.allShards().             if (shards != null) {                 final String clusterUuid = clusterUuid(clusterState).                 final String stateUUID = clusterState.stateUUID().                 final long timestamp = timestamp().                 final String[] indices = getCollectionIndices().                 final boolean isAllIndices = IndexNameExpressionResolver.isAllIndices(Arrays.asList(indices)).                 for (ShardRouting shard : shards) {                     if (isAllIndices || Regex.simpleMatch(indices, shard.getIndexName())) {                         MonitoringDoc.Node shardNode = null.                         if (shard.assignedToNode()) {                             // If the shard is assigned to a node, the shard monitoring document refers to this node                             shardNode = convertNode(node.getTimestamp(), clusterState.getNodes().get(shard.currentNodeId())).                         }                         results.add(new ShardMonitoringDoc(clusterUuid, timestamp, interval, shardNode, shard, stateUUID)).                     }                 }             }         }     }     return Collections.unmodifiableCollection(results). }
