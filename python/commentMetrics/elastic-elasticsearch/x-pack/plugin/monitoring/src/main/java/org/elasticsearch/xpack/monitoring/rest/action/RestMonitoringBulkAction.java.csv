commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "monitoring_bulk". }
false;public;2;17;;@Override public RestResponse buildResponse(MonitoringBulkResponse response, XContentBuilder builder) throws Exception {     builder.startObject().     {         builder.field("took", response.getTookInMillis()).         builder.field("ignored", response.isIgnored()).         final MonitoringBulkResponse.Error error = response.getError().         builder.field("errors", error != null).         if (error != null) {             builder.field("error", response.getError()).         }     }     builder.endObject().     return new BytesRestResponse(response.status(), builder). }
false;public;2;54;;@Override public RestChannelConsumer doPrepareRequest(RestRequest request, XPackClient client) throws IOException {     final String defaultType = request.param("type").     final String id = request.param(MONITORING_ID).     if (Strings.isEmpty(id)) {         throw new IllegalArgumentException("no [" + MONITORING_ID + "] for monitoring bulk request").     }     final String version = request.param(MONITORING_VERSION).     if (Strings.isEmpty(version)) {         throw new IllegalArgumentException("no [" + MONITORING_VERSION + "] for monitoring bulk request").     }     final String intervalAsString = request.param(INTERVAL).     if (Strings.isEmpty(intervalAsString)) {         throw new IllegalArgumentException("no [" + INTERVAL + "] for monitoring bulk request").     }     if (false == request.hasContentOrSourceParam()) {         throw new ElasticsearchParseException("no body content for monitoring bulk request").     }     final MonitoredSystem system = MonitoredSystem.fromSystem(id).     if (isSupportedSystemVersion(system, version) == false) {         throw new IllegalArgumentException(MONITORING_VERSION + " [" + version + "] is not supported by " + MONITORING_ID + " [" + id + "]").     }     final long timestamp = System.currentTimeMillis().     final long intervalMillis = parseTimeValue(intervalAsString, INTERVAL).getMillis().     final MonitoringBulkRequestBuilder requestBuilder = client.monitoring().prepareMonitoringBulk().     requestBuilder.add(system, defaultType, request.content(), request.getXContentType(), timestamp, intervalMillis).     return channel -> requestBuilder.execute(new RestBuilderListener<MonitoringBulkResponse>(channel) {          @Override         public RestResponse buildResponse(MonitoringBulkResponse response, XContentBuilder builder) throws Exception {             builder.startObject().             {                 builder.field("took", response.getTookInMillis()).                 builder.field("ignored", response.isIgnored()).                 final MonitoringBulkResponse.Error error = response.getError().                 builder.field("errors", error != null).                 if (error != null) {                     builder.field("error", response.getError()).                 }             }             builder.endObject().             return new BytesRestResponse(response.status(), builder).         }     }). }
false;public;0;4;;@Override public boolean supportsContentStream() {     return true. }
true;private;2;4;/**  * Indicate if the given {@link MonitoredSystem} and system api version pair is supported by  * the Monitoring Bulk API.  *  * @param system the {@link MonitoredSystem}  * @param version the system API version  * @return true if supported, false otherwise  */ ;/**  * Indicate if the given {@link MonitoredSystem} and system api version pair is supported by  * the Monitoring Bulk API.  *  * @param system the {@link MonitoredSystem}  * @param version the system API version  * @return true if supported, false otherwise  */ private boolean isSupportedSystemVersion(final MonitoredSystem system, final String version) {     final List<String> monitoredSystem = supportedApiVersions.getOrDefault(system, emptyList()).     return monitoredSystem.contains(version). }
