commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;String getClusterName() {     return clusterName. }
false;;0;3;;String getVersion() {     return version. }
false;;0;3;;License getLicense() {     return license. }
false;;0;3;;boolean getAPMIndicesExist() {     return apmIndicesExist. }
false;;0;3;;List<XPackFeatureSet.Usage> getUsages() {     return usages. }
false;;0;3;;ClusterStatsResponse getClusterStats() {     return clusterStats. }
false;;0;3;;ClusterState getClusterState() {     return clusterState. }
false;;0;3;;ClusterHealthStatus getStatus() {     return status. }
false;;0;3;;boolean getClusterNeedsTLSEnabled() {     return clusterNeedsTLSEnabled. }
false;;0;7;;String getClusterDisplayName() {     MetaData metaData = this.clusterState.getMetaData().     if (metaData == null) {         return null.     }     return metaData.settings().get(SETTING_DISPLAY_NAME). }
false;protected;2;75;;@Override protected void innerToXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("cluster_name", clusterName).     builder.field("version", version).     if (license != null) {         builder.startObject("license").         {             Map<String, String> extraParams = new MapBuilder<String, String>().put(License.REST_VIEW_MODE, "true").map().             params = new ToXContent.DelegatingMapParams(extraParams, params).             license.toInnerXContent(builder, params).             if (clusterNeedsTLSEnabled) {                 builder.field("cluster_needs_tls", true).             }         }         builder.endObject().     }     if (clusterStats != null) {         builder.startObject("cluster_stats").         {             clusterStats.toXContent(builder, params).         }         builder.endObject().     }     if (clusterState != null) {         builder.startObject("cluster_state").         {             builder.field("nodes_hash", nodesHash(clusterState.nodes())).             builder.field("status", status.name().toLowerCase(Locale.ROOT)).             clusterState.toXContent(builder, CLUSTER_STATS_PARAMS).         }         builder.endObject().     }     String displayName = getClusterDisplayName().     if (displayName != null) {         builder.startObject("cluster_settings").         {             builder.startObject("cluster").             {                 builder.startObject("metadata").                 {                     builder.field("display_name", displayName).                 }                 builder.endObject().             }             builder.endObject().         }         builder.endObject().     }     builder.startObject("stack_stats").     {         // in the future, it may be useful to pass in an object that represents APM (and others), but for now this         // is good enough         builder.startObject("apm").         {             builder.field("found", apmIndicesExist).         }         builder.endObject().         if (usages != null) {             builder.startObject("xpack").             for (final XPackFeatureSet.Usage usage : usages) {                 builder.field(usage.name(), usage).             }             builder.endObject().         }     }     builder.endObject(). }
true;public,static;1;10;/**  * Create a simple hash value that can be used to determine if the nodes listing has changed since the last report.  *  * @param nodes All nodes in the cluster state.  * @return A hash code value whose value can be used to determine if the node listing has changed (including node restarts).  */ ;/**  * Create a simple hash value that can be used to determine if the nodes listing has changed since the last report.  *  * @param nodes All nodes in the cluster state.  * @return A hash code value whose value can be used to determine if the node listing has changed (including node restarts).  */ public static int nodesHash(final DiscoveryNodes nodes) {     final StringBuilder temp = new StringBuilder().     // adds the Ephemeral ID (as opposed to the Persistent UUID) to catch node restarts, which is critical for 1 node clusters     for (final DiscoveryNode node : nodes) {         temp.append(node.getEphemeralId()).     }     return temp.toString().hashCode(). }
