commented;modifiers;parameterAmount;loc;comment;code
true;protected;2;7;/**  * Determine if the current {@linkplain #pipelineName pipeline} exists.  */ ;/**  * Determine if the current {@linkplain #pipelineName pipeline} exists.  */ @Override protected void doCheck(final RestClient client, final ActionListener<Boolean> listener) {     versionCheckForResource(client, listener, logger, "/_ingest/pipeline", pipelineName, "monitoring pipeline", resourceOwnerName, "monitoring cluster", XContentType.JSON.xContent(), MonitoringTemplateUtils.LAST_UPDATED_VERSION). }
true;protected;2;6;/**  * Publish the current {@linkplain #pipelineName pipeline}.  */ ;/**  * Publish the current {@linkplain #pipelineName pipeline}.  */ @Override protected void doPublish(final RestClient client, final ActionListener<Boolean> listener) {     putResource(client, listener, logger, "/_ingest/pipeline", pipelineName, Collections.emptyMap(), this::pipelineToHttpEntity, "monitoring pipeline", resourceOwnerName, "monitoring cluster"). }
true;;0;3;/**  * Create a {@link HttpEntity} for the {@link #pipeline}.  *  * @return Never {@code null}.  */ ;/**  * Create a {@link HttpEntity} for the {@link #pipeline}.  *  * @return Never {@code null}.  */ HttpEntity pipelineToHttpEntity() {     return new ByteArrayEntity(pipeline.get(), ContentType.APPLICATION_JSON). }
