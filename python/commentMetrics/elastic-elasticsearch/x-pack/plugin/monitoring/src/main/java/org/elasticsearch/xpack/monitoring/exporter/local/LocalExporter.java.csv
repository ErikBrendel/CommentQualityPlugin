# id;timestamp;commentText;codeText;commentWords;codeWords
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener);1533815246;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,acknowledged,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener);1534362961;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,acknowledged,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener);1540847035;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,acknowledged,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener);1543346894;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,acknowledged,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener);1544118724;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,acknowledged,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener);1544735606;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,acknowledged,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener);1546850547;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,acknowledged,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener);1549288028;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,acknowledged,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> @Override     public void licenseStateChanged();1544118724;When the license changes, we need to ensure that Watcher is setup properly.;@Override_    public void licenseStateChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;override,public,void,license,state,changed,watcher,setup,set,false
LocalExporter -> @Override     public void licenseStateChanged();1544735606;When the license changes, we need to ensure that Watcher is setup properly.;@Override_    public void licenseStateChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;override,public,void,license,state,changed,watcher,setup,set,false
LocalExporter -> @Override     public void licenseStateChanged();1546850547;When the license changes, we need to ensure that Watcher is setup properly.;@Override_    public void licenseStateChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;override,public,void,license,state,changed,watcher,setup,set,false
LocalExporter -> @Override     public void licenseStateChanged();1549288028;When the license changes, we need to ensure that Watcher is setup properly.;@Override_    public void licenseStateChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;override,public,void,license,state,changed,watcher,setup,set,false
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1524684173;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlock(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1532028790;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlock(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1533063033;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlock(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1533815246;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlock(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1534362961;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlock(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1540847035;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlock(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1543346894;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlock(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1544118724;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlock(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1544735606;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlock(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = client.threadPool().getThreadContext().stashWithOrigin(MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,client,thread,pool,get,thread,context,stash,with,origin,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1546850547;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlockWithLevel(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = client.threadPool().getThreadContext().stashWithOrigin(MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,with,level,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,client,thread,pool,get,thread,context,stash,with,origin,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,                                          final boolean clusterStateChange);1549288028;When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter._If those resources do not exist, then we will create them.__@param clusterState The current cluster state._@param templates All template names that should exist._@param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)_@return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates,_                                         final boolean clusterStateChange) {_        _        _        if (clusterState.blocks().hasGlobalBlockWithLevel(ClusterBlockLevel.METADATA_WRITE)) {_            logger.debug("waiting until metadata writes are unblocked")__            return false__        }__        if (installingSomething.get() == true) {_            logger.trace("already installing something, waiting for install to complete")__            return false__        }__        _        final List<Runnable> asyncActions = new ArrayList<>()__        final AtomicInteger pendingResponses = new AtomicInteger(0)___        _        final List<Entry<String, String>> missingTemplates = templates.entrySet()_                .stream()_                .filter((e) -> hasTemplate(clusterState, e.getKey()) == false)_                .collect(Collectors.toList())___        if (missingTemplates.isEmpty() == false) {_            logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found",_                    missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList())))__            for (Entry<String, String> template : missingTemplates) {_                asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(),_                        new ResponseActionListener<>("template", template.getKey(), pendingResponses)))__            }_        }__        if (useIngest) {_            final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS)_                    .filter(id -> hasIngestPipeline(clusterState, id) == false)_                    .collect(Collectors.toList())___            _            if (missingPipelines.isEmpty() == false) {_                for (final String pipelineId : missingPipelines) {_                    final String pipelineName = pipelineName(pipelineId)__                    logger.debug("pipeline [{}] not found", pipelineName)__                    asyncActions.add(() -> putIngestPipeline(pipelineId,_                                                             new ResponseActionListener<>("pipeline",_                                                                                          pipelineName,_                                                                                          pendingResponses)))__                }_            } else {_                logger.trace("all pipelines found")__            }_        }__        _        _        if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {_            final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX)__            final boolean indexExists = watches != null && watches.allPrimaryShardsActive()___            _            if (watches != null && watches.allPrimaryShardsActive() == false) {_                logger.trace("cannot manage cluster alerts because [.watches] index is not allocated")__            } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {_                getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses)__            }_        }__        if (asyncActions.size() > 0) {_            if (installingSomething.compareAndSet(false, true)) {_                pendingResponses.set(asyncActions.size())__                try (ThreadContext.StoredContext ignore = client.threadPool().getThreadContext().stashWithOrigin(MONITORING_ORIGIN)) {_                    asyncActions.forEach(Runnable::run)__                }_            } else {_                _                return false__            }_        } else {_            logger.debug("monitoring index templates and pipelines are installed on master node, service can start")__        }__        _        return true__    };when,on,the,elected,master,we,setup,all,resources,mapping,types,templates,and,pipelines,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,we,will,create,them,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,param,cluster,state,change,code,true,if,a,cluster,state,change,caused,this,call,don,t,block,it,return,code,true,indicates,that,all,resources,are,ready,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,elected,master,final,cluster,state,cluster,state,final,map,string,string,templates,final,boolean,cluster,state,change,if,cluster,state,blocks,has,global,block,with,level,cluster,block,level,logger,debug,waiting,until,metadata,writes,are,unblocked,return,false,if,installing,something,get,true,logger,trace,already,installing,something,waiting,for,install,to,complete,return,false,final,list,runnable,async,actions,new,array,list,final,atomic,integer,pending,responses,new,atomic,integer,0,final,list,entry,string,string,missing,templates,templates,entry,set,stream,filter,e,has,template,cluster,state,e,get,key,false,collect,collectors,to,list,if,missing,templates,is,empty,false,logger,debug,supplier,new,parameterized,message,template,not,found,missing,templates,stream,map,map,entry,get,key,collect,collectors,to,list,for,entry,string,string,template,missing,templates,async,actions,add,put,template,template,get,key,template,get,value,new,response,action,listener,template,template,get,key,pending,responses,if,use,ingest,final,list,string,missing,pipelines,arrays,stream,filter,id,has,ingest,pipeline,cluster,state,id,false,collect,collectors,to,list,if,missing,pipelines,is,empty,false,for,final,string,pipeline,id,missing,pipelines,final,string,pipeline,name,pipeline,name,pipeline,id,logger,debug,pipeline,not,found,pipeline,name,async,actions,add,put,ingest,pipeline,pipeline,id,new,response,action,listener,pipeline,pipeline,name,pending,responses,else,logger,trace,all,pipelines,found,if,state,get,state,running,cluster,state,change,false,can,use,watcher,final,index,routing,table,watches,cluster,state,routing,table,index,watch,index,final,boolean,index,exists,watches,null,watches,all,primary,shards,active,if,watches,null,watches,all,primary,shards,active,false,logger,trace,cannot,manage,cluster,alerts,because,watches,index,is,not,allocated,else,if,watches,null,index,exists,watcher,setup,compare,and,set,false,true,get,cluster,alerts,installation,async,actions,index,exists,async,actions,pending,responses,if,async,actions,size,0,if,installing,something,compare,and,set,false,true,pending,responses,set,async,actions,size,try,thread,context,stored,context,ignore,client,thread,pool,get,thread,context,stash,with,origin,async,actions,for,each,runnable,run,else,return,false,else,logger,debug,monitoring,index,templates,and,pipelines,are,installed,on,master,node,service,can,start,return,true
LocalExporter -> boolean isExporterReady();1524684173;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1532028790;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1533063033;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1533815246;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1534362961;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1540847035;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1543346894;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1544118724;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1544735606;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1546850547;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> boolean isExporterReady();1549288028;Determine if this {@link LocalExporter} is ready to use.__@return {@code true} if it is ready. {@code false} if not.;boolean isExporterReady() {_        _        final boolean running = resolveBulk(clusterService.state(), false) != null___        return running && installingSomething.get() == false__    };determine,if,this,link,local,exporter,is,ready,to,use,return,code,true,if,it,is,ready,code,false,if,not;boolean,is,exporter,ready,final,boolean,running,resolve,bulk,cluster,service,state,false,null,return,running,installing,something,get,false
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1524684173;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1532028790;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1533063033;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1533815246;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1534362961;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1540847035;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1543346894;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1544118724;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1544735606;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1546850547;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,                                                           final AtomicInteger pendingResponses);1549288028;Install Cluster Alerts (Watches) into the cluster__@param asyncActions Asynchronous actions are added to for each Watch._@param pendingResponses Pending response countdown we use to track completion.;private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,_                                                          final AtomicInteger pendingResponses) {_        final XPackClient xpackClient = new XPackClient(client)__        final WatcherClient watcher = xpackClient.watcher()__        final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed()___        for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {_            final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId)__            final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false___            _            if (indexExists) {_                if (addWatch) {_                    logger.trace("checking monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId),_                                                            new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId,_                                                                                                     pendingResponses)))__                } else {_                    logger.trace("pruning monitoring watch [{}]", uniqueWatchId)___                    asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId),_                                                               new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses)))__                }_            } else if (addWatch) {_                asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses))__            }_        }_    };install,cluster,alerts,watches,into,the,cluster,param,async,actions,asynchronous,actions,are,added,to,for,each,watch,param,pending,responses,pending,response,countdown,we,use,to,track,completion;private,void,get,cluster,alerts,installation,async,actions,final,boolean,index,exists,final,list,runnable,async,actions,final,atomic,integer,pending,responses,final,xpack,client,xpack,client,new,xpack,client,client,final,watcher,client,watcher,xpack,client,watcher,final,boolean,can,add,watches,license,state,is,monitoring,cluster,alerts,allowed,for,final,string,watch,id,cluster,alerts,util,final,string,unique,watch,id,cluster,alerts,util,create,unique,watch,id,cluster,service,watch,id,final,boolean,add,watch,can,add,watches,cluster,alert,blacklist,contains,watch,id,false,if,index,exists,if,add,watch,logger,trace,checking,monitoring,watch,unique,watch,id,async,actions,add,watcher,get,watch,new,get,watch,request,unique,watch,id,new,get,and,put,watch,response,action,listener,watcher,watch,id,unique,watch,id,pending,responses,else,logger,trace,pruning,monitoring,watch,unique,watch,id,async,actions,add,watcher,delete,watch,new,delete,watch,request,unique,watch,id,new,response,action,listener,watch,unique,watch,id,pending,responses,else,if,add,watch,async,actions,add,put,watch,watcher,watch,id,unique,watch,id,pending,responses
LocalExporter -> private void licenseChanged();1524684173;When the license changes, we need to ensure that Watcher is setup properly.;private void licenseChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;private,void,license,changed,watcher,setup,set,false
LocalExporter -> private void licenseChanged();1532028790;When the license changes, we need to ensure that Watcher is setup properly.;private void licenseChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;private,void,license,changed,watcher,setup,set,false
LocalExporter -> private void licenseChanged();1533063033;When the license changes, we need to ensure that Watcher is setup properly.;private void licenseChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;private,void,license,changed,watcher,setup,set,false
LocalExporter -> private void licenseChanged();1533815246;When the license changes, we need to ensure that Watcher is setup properly.;private void licenseChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;private,void,license,changed,watcher,setup,set,false
LocalExporter -> private void licenseChanged();1534362961;When the license changes, we need to ensure that Watcher is setup properly.;private void licenseChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;private,void,license,changed,watcher,setup,set,false
LocalExporter -> private void licenseChanged();1540847035;When the license changes, we need to ensure that Watcher is setup properly.;private void licenseChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;private,void,license,changed,watcher,setup,set,false
LocalExporter -> private void licenseChanged();1543346894;When the license changes, we need to ensure that Watcher is setup properly.;private void licenseChanged() {_        watcherSetup.set(false)__    };when,the,license,changes,we,need,to,ensure,that,watcher,is,setup,properly;private,void,license,changed,watcher,setup,set,false
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1524684173;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1532028790;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1533063033;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1533815246;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1534362961;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1540847035;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1543346894;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1544118724;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1544735606;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1546850547;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates);1549288028;When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we_attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the_monitoring cluster (this one, as the local exporter) is not setup yet.__@param clusterState The current cluster state._@param templates All template names that should exist._@return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.;private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {_        _        for (final String template : templates) {_            if (hasTemplate(clusterState, template) == false) {_                logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)",_                             template)__                return false__            }_        }__        _        if (useIngest) {_            for (final String pipelineId : PIPELINE_IDS) {_                if (hasIngestPipeline(clusterState, pipelineId) == false) {_                    logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)",_                                 pipelineName(pipelineId))__                    return false__                }_            }_        }__        logger.trace("monitoring index templates and pipelines are installed, service can start")___        _        return true__    };when,not,on,the,elected,master,we,require,all,resources,mapping,types,templates,and,pipelines,to,be,available,before,we,attempt,to,run,the,exporter,if,those,resources,do,not,exist,then,it,means,the,elected,master,s,exporter,has,not,yet,run,so,the,monitoring,cluster,this,one,as,the,local,exporter,is,not,setup,yet,param,cluster,state,the,current,cluster,state,param,templates,all,template,names,that,should,exist,return,code,true,indicates,that,all,resources,are,available,and,the,exporter,can,be,used,code,false,to,stop,and,wait;private,boolean,setup,if,not,elected,master,final,cluster,state,cluster,state,final,set,string,templates,for,final,string,template,templates,if,has,template,cluster,state,template,false,logger,debug,monitoring,index,template,does,not,exist,so,service,cannot,start,waiting,on,master,template,return,false,if,use,ingest,for,final,string,pipeline,id,if,has,ingest,pipeline,cluster,state,pipeline,id,false,logger,debug,monitoring,ingest,pipeline,does,not,exist,so,service,cannot,start,waiting,on,master,pipeline,name,pipeline,id,return,false,logger,trace,monitoring,index,templates,and,pipelines,are,installed,service,can,start,return,true
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1524684173;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1532028790;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1533063033;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1533815246;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1534362961;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1540847035;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1543346894;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1544118724;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1544735606;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1546850547;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private boolean hasValidVersion(final Object version, final long minimumVersion);1549288028;Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.__@param version The version to check_@param minimumVersion The minimum version required to be a "valid" version_@return {@code true} if the version exists and it's &gt_= to the minimum version. {@code false} otherwise.;private boolean hasValidVersion(final Object version, final long minimumVersion) {_        return version instanceof Number && ((Number)version).intValue() >= minimumVersion__    };determine,if,the,code,version,is,defined,and,greater,than,or,equal,to,the,code,minimum,version,param,version,the,version,to,check,param,minimum,version,the,minimum,version,required,to,be,a,valid,version,return,code,true,if,the,version,exists,and,it,s,gt,to,the,minimum,version,code,false,otherwise;private,boolean,has,valid,version,final,object,version,final,long,minimum,version,return,version,instanceof,number,number,version,int,value,minimum,version
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<WritePipelineResponse> listener);1524684173;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<WritePipelineResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,write,pipeline,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<WritePipelineResponse> listener);1532028790;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<WritePipelineResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,write,pipeline,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private void putIngestPipeline(final String pipelineId, final ActionListener<WritePipelineResponse> listener);1533063033;Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline_is initially empty, but it can be replaced later with one that translates it as-needed)._<p>_This should only be invoked by the <em>elected</em> master node._<p>_Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is_older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change._<pre><code>__"description": "...",_"pipelines" : [ ... ],_"version": 6000001__</code></pre>;private void putIngestPipeline(final String pipelineId, final ActionListener<WritePipelineResponse> listener) {_        final String pipelineName = pipelineName(pipelineId)__        final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON))__        final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON)___        logger.debug("installing ingest pipeline [{}]", pipelineName)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener,_                client.admin().cluster()::putPipeline)__    };create,the,pipeline,required,to,handle,past,data,as,well,as,to,future,proof,ingestion,for,em,current,em,documents,the,pipeline,is,initially,empty,but,it,can,be,replaced,later,with,one,that,translates,it,as,needed,p,this,should,only,be,invoked,by,the,em,elected,em,master,node,p,whenever,we,eventually,make,a,backwards,incompatible,change,then,we,need,to,override,any,pipeline,that,already,exists,that,is,older,than,this,one,this,uses,the,elasticsearch,version,down,to,the,alpha,portion,to,determine,the,version,of,the,last,change,pre,code,description,pipelines,version,6000001,code,pre;private,void,put,ingest,pipeline,final,string,pipeline,id,final,action,listener,write,pipeline,response,listener,final,string,pipeline,name,pipeline,name,pipeline,id,final,bytes,reference,pipeline,bytes,reference,bytes,load,pipeline,pipeline,id,xcontent,type,json,final,put,pipeline,request,request,new,put,pipeline,request,pipeline,name,pipeline,xcontent,type,json,logger,debug,installing,ingest,pipeline,pipeline,name,execute,async,with,origin,client,thread,pool,get,thread,context,request,listener,client,admin,cluster,put,pipeline
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1524684173;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1532028790;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1533063033;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1533815246;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1534362961;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1540847035;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1543346894;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1544118724;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1544735606;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1546850547;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId);1549288028;Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.__@param clusterState The current cluster state_@param pipelineId The ID of the pipeline to check (e.g., "3")_@return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version;private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {_        final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId)__        final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE)___        _        if (ingestMetadata != null) {_            final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName)___            return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION)__        }__        return false__    };determine,if,the,ingest,pipeline,for,code,pipeline,id,exists,in,the,cluster,or,not,with,an,appropriate,minimum,version,param,cluster,state,the,current,cluster,state,param,pipeline,id,the,id,of,the,pipeline,to,check,e,g,3,return,code,true,if,the,code,cluster,state,contains,the,pipeline,with,an,appropriate,minimum,version;private,boolean,has,ingest,pipeline,final,cluster,state,cluster,state,final,string,pipeline,id,final,string,pipeline,name,monitoring,template,utils,pipeline,name,pipeline,id,final,ingest,metadata,ingest,metadata,cluster,state,get,meta,data,custom,ingest,metadata,type,if,ingest,metadata,null,final,pipeline,configuration,pipeline,ingest,metadata,get,pipelines,get,pipeline,name,return,pipeline,null,has,valid,version,pipeline,get,config,as,map,get,version,return,false
LocalExporter -> private boolean canUseWatcher();1524684173;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1532028790;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1533063033;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1533815246;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1534362961;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1540847035;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1543346894;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1544118724;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1544735606;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1546850547;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
LocalExporter -> private boolean canUseWatcher();1549288028;Determine if the cluster can use Watcher.__@return {@code true} to use Cluster Alerts.;private boolean canUseWatcher() {_        return XPackSettings.WATCHER_ENABLED.get(config.settings()) &&_                CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())__    };determine,if,the,cluster,can,use,watcher,return,code,true,to,use,cluster,alerts;private,boolean,can,use,watcher,return,xpack,settings,get,config,settings,get,concrete,setting,for,namespace,config,name,get,config,settings
