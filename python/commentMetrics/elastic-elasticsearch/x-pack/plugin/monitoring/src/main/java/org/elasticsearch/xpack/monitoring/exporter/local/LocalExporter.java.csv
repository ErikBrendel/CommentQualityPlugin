commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void clusterChanged(ClusterChangedEvent event) {     if (state.get() == State.INITIALIZED) {         resolveBulk(event.state(), true).     } }
true;public;0;4;/**  * When the license changes, we need to ensure that Watcher is setup properly.  */ ;/**  * When the license changes, we need to ensure that Watcher is setup properly.  */ @Override public void licenseStateChanged() {     watcherSetup.set(false). }
true;;0;6;/**  * Determine if this {@link LocalExporter} is ready to use.  *  * @return {@code true} if it is ready. {@code false} if not.  */ ;/**  * Determine if this {@link LocalExporter} is ready to use.  *  * @return {@code true} if it is ready. {@code false} if not.  */ boolean isExporterReady() {     // forces the setup to occur if it hasn't already     final boolean running = resolveBulk(clusterService.state(), false) != null.     return running && installingSomething.get() == false. }
false;public;1;12;;@Override public void openBulk(final ActionListener<ExportBulk> listener) {     if (state.get() != State.RUNNING) {         listener.onResponse(null).     } else {         try {             listener.onResponse(resolveBulk(clusterService.state(), false)).         } catch (Exception e) {             listener.onFailure(e).         }     } }
false;public;0;10;;@Override public void doClose() {     if (state.getAndSet(State.TERMINATED) != State.TERMINATED) {         logger.trace("stopped").         // we also remove the listener in resolveBulk after we get to RUNNING, but it's okay to double-remove         clusterService.removeListener(this).         cleanerService.remove(this).         licenseState.removeListener(this).     } }
false;;2;38;;LocalBulk resolveBulk(ClusterState clusterState, boolean clusterStateChange) {     if (clusterService.localNode() == null || clusterState == null) {         return null.     }     // List of templates     final Map<String, String> templates = Arrays.stream(MonitoringTemplateUtils.TEMPLATE_IDS).collect(Collectors.toMap(MonitoringTemplateUtils::templateName, MonitoringTemplateUtils::loadTemplate)).     boolean setup = true.     // elected master node needs to setup templates. non-master nodes need to wait for it to be setup     if (clusterService.state().nodes().isLocalNodeElectedMaster()) {         setup = setupIfElectedMaster(clusterState, templates, clusterStateChange).     } else if (setupIfNotElectedMaster(clusterState, templates.keySet()) == false) {         // the first pass will be false so that we don't bother users if the master took one-go to setup         if (waitedForSetup.getAndSet(true)) {             logger.info("waiting for elected master node [{}] to setup local exporter [{}] (does it have x-pack installed?)", clusterService.state().nodes().getMasterNode(), config.name()).         }         setup = false.     }     // any failure/delay to setup the local exporter stops it until the next pass (10s by default)     if (setup == false) {         return null.     }     if (state.compareAndSet(State.INITIALIZED, State.RUNNING)) {         logger.debug("started").         // we no longer need to receive cluster state updates         clusterService.removeListener(this).     }     return new LocalBulk(name(), logger, client, dateTimeFormatter, useIngest). }
true;private;2;26;/**  * When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we  * attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the  * monitoring cluster (this one, as the local exporter) is not setup yet.  *  * @param clusterState The current cluster state.  * @param templates All template names that should exist.  * @return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.  */ ;/**  * When not on the elected master, we require all resources (mapping types, templates, and pipelines) to be available before we  * attempt to run the exporter. If those resources do not exist, then it means the elected master's exporter has not yet run, so the  * monitoring cluster (this one, as the local exporter) is not setup yet.  *  * @param clusterState The current cluster state.  * @param templates All template names that should exist.  * @return {@code true} indicates that all resources are available and the exporter can be used. {@code false} to stop and wait.  */ private boolean setupIfNotElectedMaster(final ClusterState clusterState, final Set<String> templates) {     // any required template is not yet installed in the given cluster state, we'll wait.     for (final String template : templates) {         if (hasTemplate(clusterState, template) == false) {             logger.debug("monitoring index template [{}] does not exist, so service cannot start (waiting on master)", template).             return false.         }     }     // if we don't have the ingest pipeline, then it's going to fail anyway     if (useIngest) {         for (final String pipelineId : PIPELINE_IDS) {             if (hasIngestPipeline(clusterState, pipelineId) == false) {                 logger.debug("monitoring ingest pipeline [{}] does not exist, so service cannot start (waiting on master)", pipelineName(pipelineId)).                 return false.             }         }     }     logger.trace("monitoring index templates and pipelines are installed, service can start").     // everything is setup     return true. }
true;private;3;84;/**  * When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter.  * If those resources do not exist, then we will create them.  *  * @param clusterState The current cluster state.  * @param templates All template names that should exist.  * @param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)  * @return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.  */ ;/**  * When on the elected master, we setup all resources (mapping types, templates, and pipelines) before we attempt to run the exporter.  * If those resources do not exist, then we will create them.  *  * @param clusterState The current cluster state.  * @param templates All template names that should exist.  * @param clusterStateChange {@code true} if a cluster state change caused this call (don't block it!)  * @return {@code true} indicates that all resources are "ready" and the exporter can be used. {@code false} to stop and wait.  */ private boolean setupIfElectedMaster(final ClusterState clusterState, final Map<String, String> templates, final boolean clusterStateChange) {     // Check that there is nothing that could block metadata updates     if (clusterState.blocks().hasGlobalBlockWithLevel(ClusterBlockLevel.METADATA_WRITE)) {         logger.debug("waiting until metadata writes are unblocked").         return false.     }     if (installingSomething.get() == true) {         logger.trace("already installing something, waiting for install to complete").         return false.     }     // build a list of runnables for everything that is missing, but do not start execution     final List<Runnable> asyncActions = new ArrayList<>().     final AtomicInteger pendingResponses = new AtomicInteger(0).     // Check that each required template exists, installing it if needed     final List<Entry<String, String>> missingTemplates = templates.entrySet().stream().filter((e) -> hasTemplate(clusterState, e.getKey()) == false).collect(Collectors.toList()).     if (missingTemplates.isEmpty() == false) {         logger.debug((Supplier<?>) () -> new ParameterizedMessage("template {} not found", missingTemplates.stream().map(Map.Entry::getKey).collect(Collectors.toList()))).         for (Entry<String, String> template : missingTemplates) {             asyncActions.add(() -> putTemplate(template.getKey(), template.getValue(), new ResponseActionListener<>("template", template.getKey(), pendingResponses))).         }     }     if (useIngest) {         final List<String> missingPipelines = Arrays.stream(PIPELINE_IDS).filter(id -> hasIngestPipeline(clusterState, id) == false).collect(Collectors.toList()).         // if we don't have the ingest pipeline, then install it         if (missingPipelines.isEmpty() == false) {             for (final String pipelineId : missingPipelines) {                 final String pipelineName = pipelineName(pipelineId).                 logger.debug("pipeline [{}] not found", pipelineName).                 asyncActions.add(() -> putIngestPipeline(pipelineId, new ResponseActionListener<>("pipeline", pipelineName, pendingResponses))).             }         } else {             logger.trace("all pipelines found").         }     }     // change     if (state.get() == State.RUNNING && clusterStateChange == false && canUseWatcher()) {         final IndexRoutingTable watches = clusterState.routingTable().index(Watch.INDEX).         final boolean indexExists = watches != null && watches.allPrimaryShardsActive().         // we cannot do anything with watches until the index is allocated, so we wait until it's ready         if (watches != null && watches.allPrimaryShardsActive() == false) {             logger.trace("cannot manage cluster alerts because [.watches] index is not allocated").         } else if ((watches == null || indexExists) && watcherSetup.compareAndSet(false, true)) {             getClusterAlertsInstallationAsyncActions(indexExists, asyncActions, pendingResponses).         }     }     if (asyncActions.size() > 0) {         if (installingSomething.compareAndSet(false, true)) {             pendingResponses.set(asyncActions.size()).             try (ThreadContext.StoredContext ignore = client.threadPool().getThreadContext().stashWithOrigin(MONITORING_ORIGIN)) {                 asyncActions.forEach(Runnable::run).             }         } else {             // let the cluster catch up since requested installations may be ongoing             return false.         }     } else {         logger.debug("monitoring index templates and pipelines are installed on master node, service can start").     }     // everything is setup (or running)     return true. }
false;private;3;12;;private void responseReceived(final AtomicInteger pendingResponses, final boolean success, @Nullable final AtomicBoolean setup) {     if (setup != null && success == false) {         setup.set(false).     }     if (pendingResponses.decrementAndGet() <= 0) {         logger.trace("all installation requests returned a response").         if (installingSomething.compareAndSet(true, false) == false) {             throw new IllegalStateException("could not reset installing flag to false").         }     } }
true;private;2;13;/**  * Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.  *  * @param clusterState The current cluster state  * @param pipelineId The ID of the pipeline to check (e.g., "3")  * @return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version  */ ;/**  * Determine if the ingest pipeline for {@code pipelineId} exists in the cluster or not with an appropriate minimum version.  *  * @param clusterState The current cluster state  * @param pipelineId The ID of the pipeline to check (e.g., "3")  * @return {@code true} if the {@code clusterState} contains the pipeline with an appropriate minimum version  */ private boolean hasIngestPipeline(final ClusterState clusterState, final String pipelineId) {     final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId).     final IngestMetadata ingestMetadata = clusterState.getMetaData().custom(IngestMetadata.TYPE).     // we ensure that we both have the pipeline and its version represents the current (or later) version     if (ingestMetadata != null) {         final PipelineConfiguration pipeline = ingestMetadata.getPipelines().get(pipelineName).         return pipeline != null && hasValidVersion(pipeline.getConfigAsMap().get("version"), LAST_UPDATED_VERSION).     }     return false. }
true;private;2;10;/**  * Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline  * is initially empty, but it can be replaced later with one that translates it as-needed).  * <p>  * This should only be invoked by the <em>elected</em> master node.  * <p>  * Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is  * older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change.  * <pre><code>  * {  *   "description": "...",  *   "pipelines" : [ ... ],  *   "version": 6000001  * }  * </code></pre>  */ ;/**  * Create the pipeline required to handle past data as well as to future-proof ingestion for <em>current</em> documents (the pipeline  * is initially empty, but it can be replaced later with one that translates it as-needed).  * <p>  * This should only be invoked by the <em>elected</em> master node.  * <p>  * Whenever we eventually make a backwards incompatible change, then we need to override any pipeline that already exists that is  * older than this one. This uses the Elasticsearch version, down to the alpha portion, to determine the version of the last change.  * <pre><code>  * {  *   "description": "...",  *   "pipelines" : [ ... ],  *   "version": 6000001  * }  * </code></pre>  */ private void putIngestPipeline(final String pipelineId, final ActionListener<AcknowledgedResponse> listener) {     final String pipelineName = pipelineName(pipelineId).     final BytesReference pipeline = BytesReference.bytes(loadPipeline(pipelineId, XContentType.JSON)).     final PutPipelineRequest request = new PutPipelineRequest(pipelineName, pipeline, XContentType.JSON).     logger.debug("installing ingest pipeline [{}]", pipelineName).     executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener, client.admin().cluster()::putPipeline). }
false;private;2;5;;private boolean hasTemplate(final ClusterState clusterState, final String templateName) {     final IndexTemplateMetaData template = clusterState.getMetaData().getTemplates().get(templateName).     return template != null && hasValidVersion(template.getVersion(), LAST_UPDATED_VERSION). }
true;private;3;9;// FIXME this should use the IndexTemplateMetaDataUpgrader ;// FIXME this should use the IndexTemplateMetaDataUpgrader private void putTemplate(String template, String source, ActionListener<AcknowledgedResponse> listener) {     logger.debug("installing template [{}]", template).     PutIndexTemplateRequest request = new PutIndexTemplateRequest(template).source(source, XContentType.JSON).     assert !Thread.currentThread().isInterrupted() : "current thread has been interrupted before putting index template!!!".     executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, listener, client.admin().indices()::putTemplate). }
true;private;2;3;/**  * Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.  *  * @param version The version to check  * @param minimumVersion The minimum version required to be a "valid" version  * @return {@code true} if the version exists and it's &gt.= to the minimum version. {@code false} otherwise.  */ ;/**  * Determine if the {@code version} is defined and greater than or equal to the {@code minimumVersion}.  *  * @param version The version to check  * @param minimumVersion The minimum version required to be a "valid" version  * @return {@code true} if the version exists and it's &gt.= to the minimum version. {@code false} otherwise.  */ private boolean hasValidVersion(final Object version, final long minimumVersion) {     return version instanceof Number && ((Number) version).intValue() >= minimumVersion. }
true;private;3;29;/**  * Install Cluster Alerts (Watches) into the cluster  *  * @param asyncActions Asynchronous actions are added to for each Watch.  * @param pendingResponses Pending response countdown we use to track completion.  */ ;/**  * Install Cluster Alerts (Watches) into the cluster  *  * @param asyncActions Asynchronous actions are added to for each Watch.  * @param pendingResponses Pending response countdown we use to track completion.  */ private void getClusterAlertsInstallationAsyncActions(final boolean indexExists, final List<Runnable> asyncActions, final AtomicInteger pendingResponses) {     final XPackClient xpackClient = new XPackClient(client).     final WatcherClient watcher = xpackClient.watcher().     final boolean canAddWatches = licenseState.isMonitoringClusterAlertsAllowed().     for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {         final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId).         final boolean addWatch = canAddWatches && clusterAlertBlacklist.contains(watchId) == false.         // we aren't sure if no watches exist yet, so add them         if (indexExists) {             if (addWatch) {                 logger.trace("checking monitoring watch [{}]", uniqueWatchId).                 asyncActions.add(() -> watcher.getWatch(new GetWatchRequest(uniqueWatchId), new GetAndPutWatchResponseActionListener(watcher, watchId, uniqueWatchId, pendingResponses))).             } else {                 logger.trace("pruning monitoring watch [{}]", uniqueWatchId).                 asyncActions.add(() -> watcher.deleteWatch(new DeleteWatchRequest(uniqueWatchId), new ResponseActionListener<>("watch", uniqueWatchId, pendingResponses))).             }         } else if (addWatch) {             asyncActions.add(() -> putWatch(watcher, watchId, uniqueWatchId, pendingResponses)).         }     } }
false;private;4;11;;private void putWatch(final WatcherClient watcher, final String watchId, final String uniqueWatchId, final AtomicInteger pendingResponses) {     final String watch = ClusterAlertsUtil.loadWatch(clusterService, watchId).     logger.trace("adding monitoring watch [{}]", uniqueWatchId).     executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, new PutWatchRequest(uniqueWatchId, new BytesArray(watch), XContentType.JSON), new ResponseActionListener<PutWatchResponse>("watch", uniqueWatchId, pendingResponses, watcherSetup), watcher::putWatch). }
true;private;0;4;/**  * Determine if the cluster can use Watcher.  *  * @return {@code true} to use Cluster Alerts.  */ ;/**  * Determine if the cluster can use Watcher.  *  * @return {@code true} to use Cluster Alerts.  */ private boolean canUseWatcher() {     return XPackSettings.WATCHER_ENABLED.get(config.settings()) && CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()). }
false;public;1;61;;@Override public void onCleanUpIndices(TimeValue retention) {     if (state.get() != State.RUNNING) {         logger.debug("exporter not ready").         return.     }     if (clusterService.state().nodes().isLocalNodeElectedMaster()) {         // Reference date time will be compared to index.creation_date settings,         // that's why it must be in UTC         ZonedDateTime expiration = ZonedDateTime.now(ZoneOffset.UTC).minus(retention.millis(), ChronoUnit.MILLIS).         logger.debug("cleaning indices [expiration={}, retention={}]", expiration, retention).         ClusterState clusterState = clusterService.state().         if (clusterState != null) {             final long expirationTimeMillis = expiration.toInstant().toEpochMilli().             final long currentTimeMillis = System.currentTimeMillis().             final boolean cleanUpWatcherHistory = clusterService.getClusterSettings().get(CLEAN_WATCHER_HISTORY).             // list of index patterns that we clean up. watcher history can be included             final String[] indexPatterns = cleanUpWatcherHistory ? new String[] { ".monitoring-*", ".watcher-history*" } : new String[] { ".monitoring-*" }.             // Get the names of the current monitoring indices             final Set<String> currents = MonitoredSystem.allSystems().map(s -> MonitoringTemplateUtils.indexName(dateTimeFormatter, s, currentTimeMillis)).collect(Collectors.toSet()).             // avoid deleting the current alerts index, but feel free to delete older ones             currents.add(".monitoring-alerts-" + TEMPLATE_VERSION).             Set<String> indices = new HashSet<>().             for (ObjectObjectCursor<String, IndexMetaData> index : clusterState.getMetaData().indices()) {                 String indexName = index.key.                 if (Regex.simpleMatch(indexPatterns, indexName)) {                     // Never delete any "current" index (e.g., today's index or the most recent version no timestamp, like alerts)                     if (currents.contains(indexName)) {                         continue.                     }                     long creationDate = index.value.getCreationDate().                     if (creationDate <= expirationTimeMillis) {                         if (logger.isDebugEnabled()) {                             logger.debug("detected expired index [name={}, created={}, expired={}]", indexName, Instant.ofEpochMilli(creationDate).atZone(ZoneOffset.UTC), expiration).                         }                         indices.add(indexName).                     }                 }             }             if (!indices.isEmpty()) {                 logger.info("cleaning up [{}] old indices", indices.size()).                 deleteIndices(indices).             } else {                 logger.debug("no old indices found for clean up").             }         }     } }
false;public;1;10;;@Override public void onResponse(AcknowledgedResponse response) {     if (response.isAcknowledged()) {         logger.debug("{} indices deleted", indices.size()).     } else {         // Probably means that the delete request has timed out,         // the indices will survive until the next clean up.         logger.warn("deletion of {} indices wasn't acknowledged", indices.size()).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.error("failed to delete indices", e). }
false;private;1;22;;private void deleteIndices(Set<String> indices) {     logger.trace("deleting {} indices: [{}]", indices.size(), collectionToCommaDelimitedString(indices)).     final DeleteIndexRequest request = new DeleteIndexRequest(indices.toArray(new String[indices.size()])).     executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, request, new ActionListener<AcknowledgedResponse>() {          @Override         public void onResponse(AcknowledgedResponse response) {             if (response.isAcknowledged()) {                 logger.debug("{} indices deleted", indices.size()).             } else {                 // Probably means that the delete request has timed out,                 // the indices will survive until the next clean up.                 logger.warn("deletion of {} indices wasn't acknowledged", indices.size()).             }         }          @Override         public void onFailure(Exception e) {             logger.error("failed to delete indices", e).         }     }, client.admin().indices()::delete). }
false;public;1;13;;@Override public void onResponse(Response response) {     responseReceived(countDown, true, setup).     if (response instanceof AcknowledgedResponse) {         if (((AcknowledgedResponse) response).isAcknowledged()) {             logger.trace("successfully set monitoring {} [{}]", type, name).         } else {             logger.error("failed to set monitoring {} [{}]", type, name).         }     } else {         logger.trace("successfully handled monitoring {} [{}]", type, name).     } }
false;public;1;5;;@Override public void onFailure(Exception e) {     responseReceived(countDown, false, setup).     logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to set monitoring {} [{}]", type, name), e). }
false;public;1;11;;@Override public void onResponse(GetWatchResponse response) {     if (response.isFound() && hasValidVersion(response.getSource().getValue("metadata.xpack.version_created"), ClusterAlertsUtil.LAST_UPDATED_VERSION)) {         logger.trace("found monitoring watch [{}]", uniqueWatchId).         responseReceived(countDown, true, watcherSetup).     } else {         putWatch(watcher, watchId, uniqueWatchId, countDown).     } }
false;public;1;9;;@Override public void onFailure(Exception e) {     responseReceived(countDown, false, watcherSetup).     if ((e instanceof IndexNotFoundException) == false) {         logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to get monitoring watch [{}]", uniqueWatchId), e).     } }
