commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String name() {     return name. }
false;public;0;4;;@Override public String toString() {     return name(). }
true;protected;1;7;/**  * Indicates if the current collector is allowed to collect data  *  * @param isElectedMaster true if the current local node is the elected master node  */ ;/**  * Indicates if the current collector is allowed to collect data  *  * @param isElectedMaster true if the current local node is the elected master node  */ protected boolean shouldCollect(final boolean isElectedMaster) {     if (licenseState.isMonitoringAllowed() == false) {         logger.trace("collector [{}] can not collect data due to invalid license", name()).         return false.     }     return true. }
false;public;3;14;;public Collection<MonitoringDoc> collect(final long timestamp, final long interval, final ClusterState clusterState) {     try {         final boolean isElectedMaster = clusterState.getNodes().isLocalNodeElectedMaster().         if (shouldCollect(isElectedMaster)) {             logger.trace("collector [{}] - collecting data...", name()).             return doCollect(convertNode(timestamp, clusterService.localNode()), interval, clusterState).         }     } catch (ElasticsearchTimeoutException e) {         logger.error((Supplier<?>) () -> new ParameterizedMessage("collector [{}] timed out when collecting data", name())).     } catch (Exception e) {         logger.error((Supplier<?>) () -> new ParameterizedMessage("collector [{}] failed to collect data", name()), e).     }     return null. }
false;protected,abstract;3;3;;protected abstract Collection<MonitoringDoc> doCollect(MonitoringDoc.Node node, long interval, ClusterState clusterState) throws Exception.
true;protected,static;0;3;/**  * Returns a timestamp to use in {@link MonitoringDoc}  *  * @return the timestamp  */ ;/**  * Returns a timestamp to use in {@link MonitoringDoc}  *  * @return the timestamp  */ protected static long timestamp() {     return System.currentTimeMillis(). }
true;protected,static;1;3;/**  * Extracts the current cluster's UUID from a {@link ClusterState}  *  * @param clusterState the {@link ClusterState}  * @return the cluster's UUID  */ ;/**  * Extracts the current cluster's UUID from a {@link ClusterState}  *  * @param clusterState the {@link ClusterState}  * @return the cluster's UUID  */ protected static String clusterUuid(final ClusterState clusterState) {     return clusterState.metaData().clusterUUID(). }
true;public;0;6;/**  * Returns the value of the collection timeout configured for the current {@link Collector}.  *  * @return the collection timeout, or {@code null} if the collector has not timeout defined.  */ ;/**  * Returns the value of the collection timeout configured for the current {@link Collector}.  *  * @return the collection timeout, or {@code null} if the collector has not timeout defined.  */ public TimeValue getCollectionTimeout() {     if (collectionTimeoutSetting == null) {         return null.     }     return clusterService.getClusterSettings().get(collectionTimeoutSetting). }
true;public;0;9;/**  * Returns the names of indices Monitoring collects data from.  *  * @return a array of indices  */ ;/**  * Returns the names of indices Monitoring collects data from.  *  * @return a array of indices  */ public String[] getCollectionIndices() {     final List<String> indices = clusterService.getClusterSettings().get(INDICES).     assert indices != null.     if (indices.isEmpty()) {         return Strings.EMPTY_ARRAY.     } else {         return indices.toArray(new String[indices.size()]).     } }
true;public,static;2;11;/**  * Creates a {@link MonitoringDoc.Node} from a {@link DiscoveryNode} and a timestamp, copying over the  * required information.  *  * @param timestamp the node's timestamp  * @param node the {@link DiscoveryNode}  *  * @return a {@link MonitoringDoc.Node} instance, or {@code null} if the given discovery node is null.  */ ;/**  * Creates a {@link MonitoringDoc.Node} from a {@link DiscoveryNode} and a timestamp, copying over the  * required information.  *  * @param timestamp the node's timestamp  * @param node the {@link DiscoveryNode}  *  * @return a {@link MonitoringDoc.Node} instance, or {@code null} if the given discovery node is null.  */ public static MonitoringDoc.Node convertNode(final long timestamp, @Nullable final DiscoveryNode node) {     if (node == null) {         return null.     }     return new MonitoringDoc.Node(node.getId(), node.getHostName(), node.getAddress().toString(), node.getHostAddress(), node.getName(), timestamp). }
false;protected,static;1;4;;protected static String collectionSetting(final String settingName) {     Objects.requireNonNull(settingName, "setting name must not be null").     return XPackField.featureSettingPrefix(XPackField.MONITORING) + ".collection." + settingName. }
false;protected,static;1;4;;protected static Setting<TimeValue> collectionTimeoutSetting(final String settingName) {     String name = collectionSetting(settingName).     return timeSetting(name, TimeValue.timeValueSeconds(10), Property.Dynamic, Property.NodeScope). }
