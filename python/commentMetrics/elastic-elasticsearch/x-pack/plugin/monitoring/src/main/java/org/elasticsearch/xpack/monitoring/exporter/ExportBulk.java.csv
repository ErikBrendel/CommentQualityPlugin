commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Get the name used for any logging messages.  *  * @return Never {@code null}.  */ ;/**  * Get the name used for any logging messages.  *  * @return Never {@code null}.  */ public String getName() {     return name. }
true;public;1;5;/**  * Add documents to the exporting bulk  */ ;/**  * Add documents to the exporting bulk  */ public void add(Collection<MonitoringDoc> docs) throws ExportException {     if (state.get() == State.INITIALIZING) {         doAdd(docs).     } }
false;protected,abstract;1;1;;protected abstract void doAdd(Collection<MonitoringDoc> docs) throws ExportException.
true;public;1;7;/**  * Flush the exporting bulk  */ ;/**  * Flush the exporting bulk  */ public void flush(ActionListener<Void> listener) {     if (state.compareAndSet(State.INITIALIZING, State.FLUSHING)) {         doFlush(listener).     } else {         listener.onResponse(null).     } }
false;protected,abstract;1;1;;protected abstract void doFlush(ActionListener<Void> listener).
true;public;2;11;/**  * Close the exporting bulk  */ ;/**  * Close the exporting bulk  */ public void close(boolean flush, ActionListener<Void> listener) {     if (state.getAndSet(State.CLOSED) != State.CLOSED) {         if (flush) {             flushAndClose(listener).         } else {             doClose(listener).         }     } else {         listener.onResponse(null).     } }
false;public;1;4;;@Override public void onResponse(Void aVoid) {     doClose(listener). }
false;public;1;4;;@Override public void onResponse(Void aVoid) {     listener.onFailure(exportException). }
false;public;1;5;;@Override public void onFailure(Exception e) {     exportException.addSuppressed(e).     listener.onFailure(exportException). }
false;public;1;19;;@Override public void onFailure(Exception e) {     // we need to close in spite of the failure, but we will return the failure     doClose(new ActionListener<Void>() {          private final ExportException exportException = new ExportException("Exception when closing export bulk", e).          @Override         public void onResponse(Void aVoid) {             listener.onFailure(exportException).         }          @Override         public void onFailure(Exception e) {             exportException.addSuppressed(e).             listener.onFailure(exportException).         }     }). }
false;private;1;28;;private void flushAndClose(ActionListener<Void> listener) {     doFlush(new ActionListener<Void>() {          @Override         public void onResponse(Void aVoid) {             doClose(listener).         }          @Override         public void onFailure(Exception e) {             // we need to close in spite of the failure, but we will return the failure             doClose(new ActionListener<Void>() {                  private final ExportException exportException = new ExportException("Exception when closing export bulk", e).                  @Override                 public void onResponse(Void aVoid) {                     listener.onFailure(exportException).                 }                  @Override                 public void onFailure(Exception e) {                     exportException.addSuppressed(e).                     listener.onFailure(exportException).                 }             }).         }     }). }
false;protected,abstract;1;1;;protected abstract void doClose(ActionListener<Void> listener).
false;protected;0;3;;protected boolean isClosed() {     return state.get() == State.CLOSED. }
false;protected;1;17;;@Override protected void doAdd(Collection<MonitoringDoc> docs) throws ExportException {     ExportException exception = null.     for (ExportBulk bulk : bulks) {         try {             bulk.add(docs).         } catch (ExportException e) {             if (exception == null) {                 exception = new ExportException("failed to add documents to export bulks").             }             exception.addExportException(e).         }     }     if (exception != null) {         throw exception.     } }
false;protected;1;24;;@Override protected void doFlush(ActionListener<Void> listener) {     final SetOnce<ExportException> exceptionRef = new SetOnce<>().     final BiConsumer<ExportBulk, ActionListener<Void>> bulkBiConsumer = (exportBulk, iteratingListener) -> {         // for every export bulk we flush and pass back the response, which should always be         // null. When we have an exception, we wrap the first and then add suppressed exceptions         exportBulk.flush(ActionListener.wrap(iteratingListener::onResponse, e -> {             if (exceptionRef.get() == null) {                 exceptionRef.set(new ExportException("failed to flush export bulks", e)).             } else if (e instanceof ExportException) {                 exceptionRef.get().addExportException((ExportException) e).             } else {                 exceptionRef.get().addSuppressed(e).             }             // this is tricky to understand but basically we suppress the exception for use             // later on and call the passed in listener so that iteration continues             iteratingListener.onResponse(null).         })).     }.     IteratingActionListener<Void, ExportBulk> iteratingActionListener = new IteratingActionListener<>(newExceptionHandlingListener(exceptionRef, listener), bulkBiConsumer, bulks, threadContext).     iteratingActionListener.run(). }
false;protected;1;24;;@Override protected void doClose(ActionListener<Void> listener) {     final SetOnce<ExportException> exceptionRef = new SetOnce<>().     final BiConsumer<ExportBulk, ActionListener<Void>> bulkBiConsumer = (exportBulk, iteratingListener) -> {         // for every export bulk we close and pass back the response, which should always be         // null. When we have an exception, we wrap the first and then add suppressed exceptions         exportBulk.doClose(ActionListener.wrap(iteratingListener::onResponse, e -> {             if (exceptionRef.get() == null) {                 exceptionRef.set(new ExportException("failed to close export bulks", e)).             } else if (e instanceof ExportException) {                 exceptionRef.get().addExportException((ExportException) e).             } else {                 exceptionRef.get().addSuppressed(e).             }             // this is tricky to understand but basically we suppress the exception for use             // later on and call the passed in listener so that iteration continues             iteratingListener.onResponse(null).         })).     }.     IteratingActionListener<Void, ExportBulk> iteratingActionListener = new IteratingActionListener<>(newExceptionHandlingListener(exceptionRef, listener), bulkBiConsumer, bulks, threadContext).     iteratingActionListener.run(). }
false;public;1;8;;@Override public void onResponse(Void aVoid) {     if (exceptionRef.get() == null) {         listener.onResponse(null).     } else {         listener.onFailure(exceptionRef.get()).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;private,static;2;18;;private static ActionListener<Void> newExceptionHandlingListener(SetOnce<ExportException> exceptionRef, ActionListener<Void> listener) {     return new ActionListener<Void>() {          @Override         public void onResponse(Void aVoid) {             if (exceptionRef.get() == null) {                 listener.onResponse(null).             } else {                 listener.onFailure(exceptionRef.get()).             }         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }. }
