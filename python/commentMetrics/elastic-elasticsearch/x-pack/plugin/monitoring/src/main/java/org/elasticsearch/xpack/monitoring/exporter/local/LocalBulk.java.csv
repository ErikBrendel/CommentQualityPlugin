commented;modifiers;parameterAmount;loc;comment;code
false;public;1;46;;@Override public void doAdd(Collection<MonitoringDoc> docs) throws ExportException {     ExportException exception = null.     for (MonitoringDoc doc : docs) {         if (isClosed()) {             return.         }         if (requestBuilder == null) {             requestBuilder = client.prepareBulk().         }         try {             final String index = MonitoringTemplateUtils.indexName(formatter, doc.getSystem(), doc.getTimestamp()).             final IndexRequest request = new IndexRequest(index).             if (Strings.hasText(doc.getId())) {                 request.id(doc.getId()).             }             final BytesReference source = XContentHelper.toXContent(doc, XContentType.SMILE, false).             request.source(source, XContentType.SMILE).             // allow the use of ingest pipelines to be completely optional             if (usePipeline) {                 request.setPipeline(MonitoringTemplateUtils.pipelineName(MonitoringTemplateUtils.TEMPLATE_VERSION)).             }             requestBuilder.add(request).             if (logger.isTraceEnabled()) {                 logger.trace("local exporter [{}] - added index request [index={}, id={}, pipeline={}, monitoring data type={}]", name, request.index(), request.id(), request.getPipeline(), doc.getType()).             }         } catch (Exception e) {             if (exception == null) {                 exception = new ExportException("failed to add documents to export bulk [{}]", name).             }             exception.addExportException(new ExportException("failed to add document [{}]", e, doc, name)).         }     }     if (exception != null) {         throw exception.     } }
false;public;1;21;;@Override public void doFlush(ActionListener<Void> listener) {     if (requestBuilder == null || requestBuilder.numberOfActions() == 0 || isClosed()) {         listener.onResponse(null).     } else {         try {             logger.trace("exporter [{}] - exporting {} documents", name, requestBuilder.numberOfActions()).             executeAsyncWithOrigin(client.threadPool().getThreadContext(), MONITORING_ORIGIN, requestBuilder.request(), ActionListener.<BulkResponse>wrap(bulkResponse -> {                 if (bulkResponse.hasFailures()) {                     throwExportException(bulkResponse.getItems(), listener).                 } else {                     listener.onResponse(null).                 }             }, e -> listener.onFailure(new ExportException("failed to flush export bulk [{}]", e, name))), client::bulk).         } finally {             requestBuilder = null.         }     } }
false;;2;17;;void throwExportException(BulkItemResponse[] bulkItemResponses, ActionListener<Void> listener) {     ExportException exception = new ExportException("bulk [{}] reports failures when exporting documents", name).     Arrays.stream(bulkItemResponses).filter(BulkItemResponse::isFailed).map(item -> new ExportException(item.getFailure().getCause())).forEach(exception::addExportException).     if (exception.hasExportExceptions()) {         for (ExportException e : exception) {             logger.warn("unexpected error while indexing monitoring document", e).         }         listener.onFailure(exception).     } else {         listener.onResponse(null).     } }
false;protected;1;7;;@Override protected void doClose(ActionListener<Void> listener) {     if (isClosed() == false) {         requestBuilder = null.     }     listener.onResponse(null). }
