commented;modifiers;parameterAmount;loc;comment;code
false;;1;4;;void setElasticsearchCollectionEnabled(final boolean enabled) {     this.elasticsearchCollectionEnabled = enabled.     scheduleExecution(). }
false;;1;4;;void setMonitoringActive(final boolean enabled) {     this.enabled = enabled.     scheduleExecution(). }
false;;1;4;;void setInterval(final TimeValue interval) {     this.interval = interval.     scheduleExecution(). }
false;public;0;3;;public TimeValue getInterval() {     return interval. }
false;public;0;3;;public boolean isMonitoringActive() {     return isStarted() && enabled. }
false;;0;3;;boolean isElasticsearchCollectionEnabled() {     return this.elasticsearchCollectionEnabled. }
false;;0;3;;boolean shouldScheduleExecution() {     return isElasticsearchCollectionEnabled() && isMonitoringActive(). }
false;private;0;3;;private String threadPoolName() {     return ThreadPool.Names.GENERIC. }
false;;0;3;;boolean isStarted() {     return started.get(). }
false;protected;0;14;;@Override protected void doStart() {     if (started.compareAndSet(false, true)) {         try {             logger.debug("monitoring service is starting").             scheduleExecution().             logger.debug("monitoring service started").         } catch (Exception e) {             logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to start monitoring service"), e).             started.set(false).             throw e.         }     } }
false;protected;0;8;;@Override protected void doStop() {     if (started.getAndSet(false)) {         logger.debug("monitoring service is stopping").         cancelExecution().         logger.debug("monitoring service stopped").     } }
false;protected;0;7;;@Override protected void doClose() {     logger.debug("monitoring service is closing").     monitor.close().     exporters.close().     logger.debug("monitoring service closed"). }
false;;0;8;;void scheduleExecution() {     if (scheduler != null) {         cancelExecution().     }     if (shouldScheduleExecution()) {         scheduler = threadPool.scheduleWithFixedDelay(monitor, interval, threadPoolName()).     } }
false;;0;9;;void cancelExecution() {     if (scheduler != null) {         try {             scheduler.cancel().         } finally {             scheduler = null.         }     } }
false;protected;0;30;;@Override protected void doRun() throws Exception {     final long timestamp = System.currentTimeMillis().     final long intervalInMillis = interval.getMillis().     final ClusterState clusterState = clusterService.state().     final Collection<MonitoringDoc> results = new ArrayList<>().     for (Collector collector : collectors) {         if (isStarted() == false) {             // otherwise some collectors might just fail.             return.         }         try {             Collection<MonitoringDoc> result = collector.collect(timestamp, intervalInMillis, clusterState).             if (result != null) {                 results.addAll(result).             }         } catch (Exception e) {             logger.warn((Supplier<?>) () -> new ParameterizedMessage("monitoring collector [{}] failed to collect data", collector.name()), e).         }     }     if (shouldScheduleExecution()) {         exporters.export(results, ActionListener.wrap(r -> semaphore.release(), this::onFailure)).     } else {         semaphore.release().     } }
false;public;1;5;;@Override public void onFailure(Exception e) {     logger.warn("monitoring execution failed", e).     semaphore.release(). }
false;public;1;5;;@Override public void onRejection(Exception e) {     logger.warn("monitoring execution has been rejected", e).     semaphore.release(). }
false;public;0;57;;@Override public void doRun() {     if (shouldScheduleExecution() == false) {         logger.debug("monitoring execution is skipped").         return.     }     if (semaphore.tryAcquire() == false) {         logger.debug("monitoring execution is skipped until previous execution terminated").         return.     }     threadPool.executor(threadPoolName()).submit(new AbstractRunnable() {          @Override         protected void doRun() throws Exception {             final long timestamp = System.currentTimeMillis().             final long intervalInMillis = interval.getMillis().             final ClusterState clusterState = clusterService.state().             final Collection<MonitoringDoc> results = new ArrayList<>().             for (Collector collector : collectors) {                 if (isStarted() == false) {                     // otherwise some collectors might just fail.                     return.                 }                 try {                     Collection<MonitoringDoc> result = collector.collect(timestamp, intervalInMillis, clusterState).                     if (result != null) {                         results.addAll(result).                     }                 } catch (Exception e) {                     logger.warn((Supplier<?>) () -> new ParameterizedMessage("monitoring collector [{}] failed to collect data", collector.name()), e).                 }             }             if (shouldScheduleExecution()) {                 exporters.export(results, ActionListener.wrap(r -> semaphore.release(), this::onFailure)).             } else {                 semaphore.release().             }         }          @Override         public void onFailure(Exception e) {             logger.warn("monitoring execution failed", e).             semaphore.release().         }          @Override         public void onRejection(Exception e) {             logger.warn("monitoring execution has been rejected", e).             semaphore.release().         }     }). }
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.warn("monitoring execution failed", e). }
false;public;0;12;;@Override public void close() {     try {         // the semaphore to not get released and then the node will hang forever on shutdown         if (semaphore.tryAcquire(10L, TimeUnit.SECONDS) == false) {             logger.warn("monitoring execution did not complete after waiting for 10s").         }     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } }
