commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected boolean shouldCollect(final boolean isElectedMaster) {     return isElectedMaster && super.shouldCollect(isElectedMaster). }
false;protected;3;43;;@Override protected Collection<MonitoringDoc> doCollect(final MonitoringDoc.Node node, final long interval, final ClusterState clusterState) throws Exception {     final List<MonitoringDoc> results = new ArrayList<>().     final IndicesStatsResponse indicesStatsResponse = client.admin().indices().prepareStats().setIndices(getCollectionIndices()).setIndicesOptions(IndicesOptions.lenientExpandOpen()).clear().setDocs(true).setFieldData(true).setIndexing(true).setMerge(true).setSearch(true).setSegments(true).setStore(true).setRefresh(true).setQueryCache(true).setRequestCache(true).get(getCollectionTimeout()).     final long timestamp = timestamp().     final String clusterUuid = clusterUuid(clusterState).     final MetaData metadata = clusterState.metaData().     final RoutingTable routingTable = clusterState.routingTable().     // Filters the indices stats to only return the statistics for the indices known by the collector's     // local cluster state. This way indices/index/shards stats all share a common view of indices state.     final List<IndexStats> indicesStats = new ArrayList<>().     for (final String indexName : metadata.getConcreteAllIndices()) {         final IndexStats indexStats = indicesStatsResponse.getIndex(indexName).         if (indexStats != null) {             // The index appears both in the local cluster state and indices stats response             indicesStats.add(indexStats).             results.add(new IndexStatsMonitoringDoc(clusterUuid, timestamp, interval, node, indexStats, metadata.index(indexName), routingTable.index(indexName))).         }     }     results.add(new IndicesStatsMonitoringDoc(clusterUuid, timestamp, interval, node, indicesStats)).     return Collections.unmodifiableCollection(results). }
