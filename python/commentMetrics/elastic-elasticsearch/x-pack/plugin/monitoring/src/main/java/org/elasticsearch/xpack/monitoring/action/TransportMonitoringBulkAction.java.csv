commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;22;;@Override protected void doExecute(Task task, MonitoringBulkRequest request, ActionListener<MonitoringBulkResponse> listener) {     clusterService.state().blocks().globalBlockedRaiseException(ClusterBlockLevel.WRITE).     // ignore incoming bulk requests when collection is disabled in ES     if (monitoringService.isMonitoringActive() == false) {         listener.onResponse(new MonitoringBulkResponse(0, true)).         return.     }     final long timestamp = System.currentTimeMillis().     final String cluster = clusterService.state().metaData().clusterUUID().     final DiscoveryNode discoveryNode = clusterService.localNode().     final MonitoringDoc.Node node = new MonitoringDoc.Node(discoveryNode.getId(), discoveryNode.getHostName(), discoveryNode.getAddress().toString(), discoveryNode.getHostAddress(), discoveryNode.getName(), timestamp).     new AsyncAction(threadPool, request, listener, exportService, cluster, timestamp, node).start(). }
false;;0;3;;void start() {     executeExport(createMonitoringDocs(request.getDocs()), System.nanoTime(), listener). }
true;;1;6;/**  * Iterate over the list of {@link MonitoringBulkDoc} to create the corresponding  * list of {@link MonitoringDoc}.  */ ;/**  * Iterate over the list of {@link MonitoringBulkDoc} to create the corresponding  * list of {@link MonitoringDoc}.  */ Collection<MonitoringDoc> createMonitoringDocs(Collection<MonitoringBulkDoc> bulkDocs) {     return bulkDocs.stream().filter(bulkDoc -> bulkDoc.getSystem() != MonitoredSystem.UNKNOWN).map(this::createMonitoringDoc).collect(Collectors.toList()). }
true;;1;18;/**  * Create a {@link MonitoringDoc} from a {@link MonitoringBulkDoc}.  *  * @param bulkDoc the {@link MonitoringBulkDoc}  * @return the {@link MonitoringDoc} to export  */ ;/**  * Create a {@link MonitoringDoc} from a {@link MonitoringBulkDoc}.  *  * @param bulkDoc the {@link MonitoringBulkDoc}  * @return the {@link MonitoringDoc} to export  */ MonitoringDoc createMonitoringDoc(final MonitoringBulkDoc bulkDoc) {     final MonitoredSystem system = bulkDoc.getSystem().     final String type = bulkDoc.getType().     final String id = bulkDoc.getId().     final long intervalMillis = bulkDoc.getIntervalMillis().     final XContentType xContentType = bulkDoc.getXContentType().     final BytesReference source = bulkDoc.getSource().     final long timestamp.     if (bulkDoc.getTimestamp() != 0L) {         timestamp = bulkDoc.getTimestamp().     } else {         timestamp = defaultTimestamp.     }     return new BytesReferenceMonitoringDoc(defaultClusterUUID, timestamp, intervalMillis, defaultNode, system, type, id, xContentType, source). }
false;protected;0;10;;@Override protected void doRun() {     exportService.export(docs, ActionListener.wrap(r -> listener.onResponse(response(startTimeNanos)), this::onFailure)). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onResponse(response(startTimeNanos, e)). }
true;;3;20;/**  * Exports the documents  */ ;/**  * Exports the documents  */ void executeExport(final Collection<MonitoringDoc> docs, final long startTimeNanos, final ActionListener<MonitoringBulkResponse> delegate) {     threadPool.executor(ThreadPool.Names.GENERIC).execute(new ActionRunnable<MonitoringBulkResponse>(delegate) {          @Override         protected void doRun() {             exportService.export(docs, ActionListener.wrap(r -> listener.onResponse(response(startTimeNanos)), this::onFailure)).         }          @Override         public void onFailure(Exception e) {             listener.onResponse(response(startTimeNanos, e)).         }     }). }
false;private,static;1;3;;private static MonitoringBulkResponse response(final long start) {     return new MonitoringBulkResponse(took(start), false). }
false;private,static;2;3;;private static MonitoringBulkResponse response(final long start, final Exception e) {     return new MonitoringBulkResponse(took(start), new MonitoringBulkResponse.Error(e)). }
false;private,static;1;3;;private static long took(final long start) {     return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start). }
