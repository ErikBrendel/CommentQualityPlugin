commented;modifiers;parameterAmount;loc;comment;code
false;public;1;18;;@Override public void doAdd(Collection<MonitoringDoc> docs) throws ExportException {     try {         if (docs != null && docs.isEmpty() == false) {             try (BytesStreamOutput payload = new BytesStreamOutput()) {                 for (MonitoringDoc monitoringDoc : docs) {                     // any failure caused by an individual doc will be written as an empty byte[], thus not impacting the rest                     payload.write(toBulkBytes(monitoringDoc)).                 }                 // store the payload until we flush                 this.payload = BytesReference.toBytes(payload.bytes()).             }         }     } catch (Exception e) {         throw new ExportException("failed to add documents to export bulk [{}]", e, name).     } }
false;public;1;8;;@Override public void onSuccess(Response response) {     try {         HttpExportBulkResponseListener.INSTANCE.onSuccess(response).     } finally {         listener.onResponse(null).     } }
false;public;1;8;;@Override public void onFailure(Exception exception) {     try {         HttpExportBulkResponseListener.INSTANCE.onFailure(exception).     } finally {         listener.onFailure(exception).     } }
false;public;1;32;;@Override public void doFlush(ActionListener<Void> listener) throws ExportException {     if (payload == null) {         listener.onFailure(new ExportException("unable to send documents because none were loaded for export bulk [{}]", name)).     } else if (payload.length != 0) {         final Request request = new Request("POST", "/_bulk").         for (Map.Entry<String, String> param : params.entrySet()) {             request.addParameter(param.getKey(), param.getValue()).         }         request.setEntity(new NByteArrayEntity(payload, ContentType.APPLICATION_JSON)).         client.performRequestAsync(request, new ResponseListener() {              @Override             public void onSuccess(Response response) {                 try {                     HttpExportBulkResponseListener.INSTANCE.onSuccess(response).                 } finally {                     listener.onResponse(null).                 }             }              @Override             public void onFailure(Exception exception) {                 try {                     HttpExportBulkResponseListener.INSTANCE.onFailure(exception).                 } finally {                     listener.onFailure(exception).                 }             }         }).     } }
false;protected;1;4;;@Override protected void doClose(ActionListener<Void> listener) {     listener.onResponse(null). }
false;private;1;46;;private byte[] toBulkBytes(final MonitoringDoc doc) throws IOException {     final XContentType xContentType = XContentType.JSON.     final XContent xContent = xContentType.xContent().     final String index = MonitoringTemplateUtils.indexName(formatter, doc.getSystem(), doc.getTimestamp()).     final String id = doc.getId().     try (BytesStreamOutput out = new BytesStreamOutput()) {         try (XContentBuilder builder = new XContentBuilder(xContent, out)) {             // Builds the bulk action metadata line             builder.startObject().             {                 builder.startObject("index").                 {                     builder.field("_index", index).                     if (id != null) {                         builder.field("_id", id).                     }                 }                 builder.endObject().             }             builder.endObject().         }         // Adds action metadata line bulk separator         out.write(xContent.streamSeparator()).         // Adds the source of the monitoring document         final BytesRef source = XContentHelper.toXContent(doc, xContentType, false).toBytesRef().         out.write(source.bytes, source.offset, source.length).         // Adds final bulk separator         out.write(xContent.streamSeparator()).         logger.trace("http exporter [{}] - added index request [index={}, id={}, monitoring data type={}]", name, index, id, doc.getType()).         return BytesReference.toBytes(out.bytes()).     } catch (Exception e) {         logger.warn((Supplier<?>) () -> new ParameterizedMessage("failed to render document [{}], skipping it [{}]", doc, name), e).         return BytesRef.EMPTY_BYTES.     } }
