commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void onSuccess(final Response response) {     try {         // malformed responses can cause exceptions during validation         listener.onResponse(validateVersion(response)).     } catch (Exception e) {         onFailure(e).     } }
false;public;1;9;;@Override public void onFailure(final Exception exception) {     logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to verify minimum version [{}] on the [{}] monitoring cluster", minimumVersion, resourceOwnerName), exception).     listener.onFailure(exception). }
true;protected;2;29;/**  * Verify that the minimum {@link Version} is supported on the remote cluster.  * <p>  * If it does not, then there is nothing that can be done except wait until it does. There is no publishing aspect to this operation.  */ ;/**  * Verify that the minimum {@link Version} is supported on the remote cluster.  * <p>  * If it does not, then there is nothing that can be done except wait until it does. There is no publishing aspect to this operation.  */ @Override protected void doCheckAndPublish(final RestClient client, final ActionListener<Boolean> listener) {     logger.trace("checking [{}] to ensure that it supports the minimum version [{}]", resourceOwnerName, minimumVersion).     final Request request = new Request("GET", "/").     request.addParameter("filter_path", "version.number").     client.performRequestAsync(request, new ResponseListener() {          @Override         public void onSuccess(final Response response) {             try {                 // malformed responses can cause exceptions during validation                 listener.onResponse(validateVersion(response)).             } catch (Exception e) {                 onFailure(e).             }         }          @Override         public void onFailure(final Exception exception) {             logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to verify minimum version [{}] on the [{}] monitoring cluster", minimumVersion, resourceOwnerName), exception).             listener.onFailure(exception).         }     }). }
true;private;1;19;/**  * Ensure that the {@code response} contains a {@link Version} that is {@linkplain Version#onOrAfter(Version) on or after} the  * {@link #minimumVersion}.  *  * @param response The response to parse.  * @return {@code true} if the remote cluster is running a supported version.  * @throws NullPointerException if the response is malformed.  * @throws ClassCastException if the response is malformed.  * @throws IOException if any parsing issue occurs.  */ ;/**  * Ensure that the {@code response} contains a {@link Version} that is {@linkplain Version#onOrAfter(Version) on or after} the  * {@link #minimumVersion}.  *  * @param response The response to parse.  * @return {@code true} if the remote cluster is running a supported version.  * @throws NullPointerException if the response is malformed.  * @throws ClassCastException if the response is malformed.  * @throws IOException if any parsing issue occurs.  */ private boolean validateVersion(final Response response) throws IOException {     Map<String, Object> map = XContentHelper.convertToMap(JsonXContent.jsonXContent, response.getEntity().getContent(), false).     // the response should be filtered to just '{"version":{"number":"xyz"}}', so this is cheap and guaranteed     @SuppressWarnings("unchecked")     final String versionNumber = (String) ((Map<String, Object>) map.get("version")).get("number").     final Version version = Version.fromString(versionNumber.replace("-SNAPSHOT", "").replaceFirst("-(alpha\\d+|beta\\d+|rc\\d+)", "")).     if (version.onOrAfter(minimumVersion)) {         logger.debug("version [{}] >= [{}] and supported for [{}]", version, minimumVersion, resourceOwnerName).         return true.     } else {         logger.error("version [{}] < [{}] and NOT supported for [{}]", version, minimumVersion, resourceOwnerName).         return false.     } }
