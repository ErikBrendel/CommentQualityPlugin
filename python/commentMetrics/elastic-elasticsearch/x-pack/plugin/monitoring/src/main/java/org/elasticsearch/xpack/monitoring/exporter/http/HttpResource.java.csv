commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Get the resource owner for this {@link HttpResource}.  *  * @return Never {@code null}.  */ ;/**  * Get the resource owner for this {@link HttpResource}.  *  * @return Never {@code null}.  */ public String getResourceOwnerName() {     return resourceOwnerName. }
true;public;0;3;/**  * Determine if the resource needs to be checked.  *  * @return {@code true} to indicate that the resource should block follow-on actions that require it.  * @see #checkAndPublish(RestClient, ActionListener)  */ ;/**  * Determine if the resource needs to be checked.  *  * @return {@code true} to indicate that the resource should block follow-on actions that require it.  * @see #checkAndPublish(RestClient, ActionListener)  */ public boolean isDirty() {     return state.get() != State.CLEAN. }
true;public,final;0;3;/**  * Mark the resource as {@linkplain #isDirty() dirty}.  */ ;/**  * Mark the resource as {@linkplain #isDirty() dirty}.  */ public final void markDirty() {     state.set(State.DIRTY). }
true;public,final;2;7;/**  * If the resource is currently {@linkplain #isDirty() dirty}, then check and, if necessary, publish this {@link HttpResource}.  * <p>  * Expected usage:  * <pre><code>  * resource.checkAndPublishIfDirty(client, ActionListener.wrap((success) -&gt. {  *     if (success) {  *         // use client with resources having been verified  *     }  * }, listener::onFailure).  * </code></pre>  *  * @param client The REST client to make the request(s).  * @param listener Returns {@code true} if the resource is available for use. {@code false} to stop.  */ ;/**  * If the resource is currently {@linkplain #isDirty() dirty}, then check and, if necessary, publish this {@link HttpResource}.  * <p>  * Expected usage:  * <pre><code>  * resource.checkAndPublishIfDirty(client, ActionListener.wrap((success) -&gt. {  *     if (success) {  *         // use client with resources having been verified  *     }  * }, listener::onFailure).  * </code></pre>  *  * @param client The REST client to make the request(s).  * @param listener Returns {@code true} if the resource is available for use. {@code false} to stop.  */ public final void checkAndPublishIfDirty(final RestClient client, final ActionListener<Boolean> listener) {     if (state.get() == State.CLEAN) {         listener.onResponse(true).     } else {         checkAndPublish(client, listener).     } }
true;public,final;2;14;/**  * Check and, if necessary, publish this {@link HttpResource}.  * <p>  * This will perform the check regardless of the {@linkplain #isDirty() dirtiness} and it will update the dirtiness.  * Using this directly can be useful if there is ever a need to double-check dirtiness without having to {@linkplain #markDirty() mark}  * it as dirty.  * <p>  * If you do mark this as dirty while this is running (e.g., asynchronously something invalidates a resource), then the resource will  * still be dirty at the end, but the success of it will still return based on the checks it ran.  *  * @param client The REST client to make the request(s).  * @param listener Returns {@code true} if the resource is available for use. {@code false} to stop.  * @see #isDirty()  */ ;/**  * Check and, if necessary, publish this {@link HttpResource}.  * <p>  * This will perform the check regardless of the {@linkplain #isDirty() dirtiness} and it will update the dirtiness.  * Using this directly can be useful if there is ever a need to double-check dirtiness without having to {@linkplain #markDirty() mark}  * it as dirty.  * <p>  * If you do mark this as dirty while this is running (e.g., asynchronously something invalidates a resource), then the resource will  * still be dirty at the end, but the success of it will still return based on the checks it ran.  *  * @param client The REST client to make the request(s).  * @param listener Returns {@code true} if the resource is available for use. {@code false} to stop.  * @see #isDirty()  */ public final void checkAndPublish(final RestClient client, final ActionListener<Boolean> listener) {     // we always check when asked, regardless of clean or dirty, but we do not run parallel checks     if (state.getAndSet(State.CHECKING) != State.CHECKING) {         doCheckAndPublish(client, ActionListener.wrap(success -> {             state.compareAndSet(State.CHECKING, success ? State.CLEAN : State.DIRTY).             listener.onResponse(success).         }, e -> {             state.compareAndSet(State.CHECKING, State.DIRTY).             listener.onFailure(e).         })).     } else {         listener.onResponse(false).     } }
true;protected,abstract;2;1;/**  * Perform whatever is necessary to check and publish this {@link HttpResource}.  *  * @param client The REST client to make the request(s).  * @param listener Returns {@code true} if the resource is available for use. {@code false} to stop.  */ ;/**  * Perform whatever is necessary to check and publish this {@link HttpResource}.  *  * @param client The REST client to make the request(s).  * @param listener Returns {@code true} if the resource is available for use. {@code false} to stop.  */ protected abstract void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener).
