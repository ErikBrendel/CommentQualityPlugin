commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;8;;@Override protected boolean shouldCollect(final boolean isElectedMaster) {     // this can only run when monitoring is allowed and CCR is enabled and allowed, but also only on the elected master node     return isElectedMaster && super.shouldCollect(isElectedMaster) && XPackSettings.CCR_ENABLED_SETTING.get(settings) && licenseState.isCcrAllowed(). }
false;protected;3;27;;@Override protected Collection<MonitoringDoc> doCollect(final MonitoringDoc.Node node, final long interval, final ClusterState clusterState) throws Exception {     try (ThreadContext.StoredContext ignore = stashWithOrigin(threadContext, MONITORING_ORIGIN)) {         final long timestamp = timestamp().         final String clusterUuid = clusterUuid(clusterState).         final CcrStatsAction.Request request = new CcrStatsAction.Request().         final CcrStatsAction.Response response = ccrClient.stats(request).actionGet(getCollectionTimeout()).         final AutoFollowStatsMonitoringDoc autoFollowStatsDoc = new AutoFollowStatsMonitoringDoc(clusterUuid, timestamp, interval, node, response.getAutoFollowStats()).         Set<String> collectionIndices = new HashSet<>(Arrays.asList(getCollectionIndices())).         List<MonitoringDoc> docs = response.getFollowStats().getStatsResponses().stream().filter(statsResponse -> collectionIndices.isEmpty() || collectionIndices.contains(statsResponse.status().followerIndex())).map(stats -> new FollowStatsMonitoringDoc(clusterUuid, timestamp, interval, node, stats.status())).collect(Collectors.toList()).         docs.add(autoFollowStatsDoc).         return docs.     } }
