commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;@Override protected void doStart() {     logger.debug("starting cleaning service").     threadPool.schedule(runnable, executionScheduler.nextExecutionDelay(ZonedDateTime.now(Clock.systemDefaultZone())), executorName()).     logger.debug("cleaning service started"). }
false;protected;0;6;;@Override protected void doStop() {     logger.debug("stopping cleaning service").     listeners.clear().     logger.debug("cleaning service stopped"). }
false;protected;0;6;;@Override protected void doClose() {     logger.debug("closing cleaning service").     runnable.cancel().     logger.debug("cleaning service closed"). }
false;private;0;3;;private String executorName() {     return ThreadPool.Names.GENERIC. }
true;public;0;9;/**  * Get the retention that can be used.  * <p>  * This will ignore the global retention if the license does not allow retention updates.  *  * @return Never {@code null}  * @see XPackLicenseState#isUpdateRetentionAllowed()  */ ;/**  * Get the retention that can be used.  * <p>  * This will ignore the global retention if the license does not allow retention updates.  *  * @return Never {@code null}  * @see XPackLicenseState#isUpdateRetentionAllowed()  */ public TimeValue getRetention() {     // we only care about their value if they are allowed to set it     if (licenseState.isUpdateRetentionAllowed() && globalRetention != null) {         return globalRetention.     } else {         return MonitoringField.HISTORY_DURATION.getDefault(Settings.EMPTY).     } }
true;public;1;8;/**  * Set the global retention. This is expected to be used by the cluster settings to dynamically control the global retention time.  * <p>  * Even if the current license prevents retention updates, it will accept the change so that they do not need to re-set it if they  * upgrade their license (they can always unset it).  *  * @param globalRetention The global retention to use dynamically.  */ ;/**  * Set the global retention. This is expected to be used by the cluster settings to dynamically control the global retention time.  * <p>  * Even if the current license prevents retention updates, it will accept the change so that they do not need to re-set it if they  * upgrade their license (they can always unset it).  *  * @param globalRetention The global retention to use dynamically.  */ public void setGlobalRetention(TimeValue globalRetention) {     // notify the user that their setting will be ignored until they get the right license     if (licenseState.isUpdateRetentionAllowed() == false) {         logger.warn("[{}] setting will be ignored until an appropriate license is applied", MonitoringField.HISTORY_DURATION.getKey()).     }     this.globalRetention = globalRetention. }
true;public;1;3;/**  * Add a {@code listener} that is executed by the internal {@code IndicesCleaner} given the {@link #getRetention() retention} time.  *  * @param listener A listener used to control retention  */ ;/**  * Add a {@code listener} that is executed by the internal {@code IndicesCleaner} given the {@link #getRetention() retention} time.  *  * @param listener A listener used to control retention  */ public void add(Listener listener) {     listeners.add(listener). }
true;public;1;3;/**  * Remove a {@code listener}.  *  * @param listener A listener used to control retention  * @see #add(Listener)  */ ;/**  * Remove a {@code listener}.  *  * @param listener A listener used to control retention  * @see #add(Listener)  */ public void remove(Listener listener) {     listeners.remove(listener). }
true;;1;1;/**  * This method is called on listeners so that they can  * clean indices.  *  * @param retention global retention value, it can be overridden at exporter level  */ ;/**  * This method is called on listeners so that they can  * clean indices.  *  * @param retention global retention value, it can be overridden at exporter level  */ void onCleanUpIndices(TimeValue retention).
false;protected;0;23;;@Override protected void doRunInLifecycle() throws Exception {     if (licenseState.isMonitoringAllowed() == false) {         logger.debug("cleaning service is disabled due to invalid license").         return.     }     // fetch the retention, which is depends on a bunch of rules     TimeValue retention = getRetention().     logger.trace("cleaning up indices with retention [{}]", retention).     // Note: listeners are free to override the retention     for (Listener listener : listeners) {         try {             listener.onCleanUpIndices(retention).         } catch (Exception e) {             logger.error("listener failed to clean indices", e).         }     }     logger.trace("done cleaning up indices"). }
true;protected;0;17;/**  * Reschedule the cleaner if the service is not stopped.  */ ;/**  * Reschedule the cleaner if the service is not stopped.  */ @Override protected void onAfterInLifecycle() {     ZonedDateTime start = ZonedDateTime.now(Clock.systemUTC()).     TimeValue delay = executionScheduler.nextExecutionDelay(start).     logger.debug("scheduling next execution in [{}] seconds", delay.seconds()).     try {         cancellable = threadPool.schedule(this, delay, executorName()).     } catch (EsRejectedExecutionException e) {         if (e.isExecutorShutdown()) {             logger.debug("couldn't schedule new execution of the cleaner, executor is shutting down", e).         } else {             throw e.         }     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.error("failed to clean indices", e). }
true;public;0;5;/**  * Cancel/stop the cleaning service.  * <p>  * This will kill any scheduled {@link #cancellable} from running. It's possible that this will be executed concurrently with the  * {@link #onAfter() rescheduling code}, at which point it will be stopped during the next execution <em>if</em> the service is  * stopped.  */ ;/**  * Cancel/stop the cleaning service.  * <p>  * This will kill any scheduled {@link #cancellable} from running. It's possible that this will be executed concurrently with the  * {@link #onAfter() rescheduling code}, at which point it will be stopped during the next execution <em>if</em> the service is  * stopped.  */ public void cancel() {     if (cancellable != null && cancellable.isCancelled() == false) {         cancellable.cancel().     } }
true;;1;1;/**  * Calculates the delay in millis between "now" and the next execution.  *  * @param now the current time  * @return the delay in millis  */ ;/**  * Calculates the delay in millis between "now" and the next execution.  *  * @param now the current time  * @return the delay in millis  */ TimeValue nextExecutionDelay(ZonedDateTime now).
false;public;1;12;;@Override public TimeValue nextExecutionDelay(ZonedDateTime now) {     // Runs at 01:00 AM today or the next day if it's too late     ZonedDateTime next = now.toLocalDate().atStartOfDay(now.getZone()).plusHours(1).     // if it's not after now, then it needs to be the next day!     if (next.isAfter(now) == false) {         next = next.plusDays(1).     }     return TimeValue.timeValueMillis(Duration.between(now, next).toMillis()). }
