# id;timestamp;commentText;codeText;commentWords;codeWords
CleanerService -> public void remove(Listener listener);1524684173;Remove a {@code listener}.__@param listener A listener used to control retention_@see #add(Listener);public void remove(Listener listener) {_        listeners.remove(listener)__    };remove,a,code,listener,param,listener,a,listener,used,to,control,retention,see,add,listener;public,void,remove,listener,listener,listeners,remove,listener
CleanerService -> public void remove(Listener listener);1542646292;Remove a {@code listener}.__@param listener A listener used to control retention_@see #add(Listener);public void remove(Listener listener) {_        listeners.remove(listener)__    };remove,a,code,listener,param,listener,a,listener,used,to,control,retention,see,add,listener;public,void,remove,listener,listener,listeners,remove,listener
CleanerService -> public void remove(Listener listener);1547625930;Remove a {@code listener}.__@param listener A listener used to control retention_@see #add(Listener);public void remove(Listener listener) {_        listeners.remove(listener)__    };remove,a,code,listener,param,listener,a,listener,used,to,control,retention,see,add,listener;public,void,remove,listener,listener,listeners,remove,listener
CleanerService -> public void remove(Listener listener);1548953505;Remove a {@code listener}.__@param listener A listener used to control retention_@see #add(Listener);public void remove(Listener listener) {_        listeners.remove(listener)__    };remove,a,code,listener,param,listener,a,listener,used,to,control,retention,see,add,listener;public,void,remove,listener,listener,listeners,remove,listener
CleanerService -> public void remove(Listener listener);1549288028;Remove a {@code listener}.__@param listener A listener used to control retention_@see #add(Listener);public void remove(Listener listener) {_        listeners.remove(listener)__    };remove,a,code,listener,param,listener,a,listener,used,to,control,retention,see,add,listener;public,void,remove,listener,listener,listeners,remove,listener
CleanerService -> public void setGlobalRetention(TimeValue globalRetention);1524684173;Set the global retention. This is expected to be used by the cluster settings to dynamically control the global retention time._<p>_Even if the current license prevents retention updates, it will accept the change so that they do not need to re-set it if they_upgrade their license (they can always unset it).__@param globalRetention The global retention to use dynamically.;public void setGlobalRetention(TimeValue globalRetention) {_        _        if (licenseState.isUpdateRetentionAllowed() == false) {_            logger.warn("[{}] setting will be ignored until an appropriate license is applied", MonitoringField.HISTORY_DURATION.getKey())__        }__        this.globalRetention = globalRetention__    };set,the,global,retention,this,is,expected,to,be,used,by,the,cluster,settings,to,dynamically,control,the,global,retention,time,p,even,if,the,current,license,prevents,retention,updates,it,will,accept,the,change,so,that,they,do,not,need,to,re,set,it,if,they,upgrade,their,license,they,can,always,unset,it,param,global,retention,the,global,retention,to,use,dynamically;public,void,set,global,retention,time,value,global,retention,if,license,state,is,update,retention,allowed,false,logger,warn,setting,will,be,ignored,until,an,appropriate,license,is,applied,monitoring,field,get,key,this,global,retention,global,retention
CleanerService -> public void setGlobalRetention(TimeValue globalRetention);1542646292;Set the global retention. This is expected to be used by the cluster settings to dynamically control the global retention time._<p>_Even if the current license prevents retention updates, it will accept the change so that they do not need to re-set it if they_upgrade their license (they can always unset it).__@param globalRetention The global retention to use dynamically.;public void setGlobalRetention(TimeValue globalRetention) {_        _        if (licenseState.isUpdateRetentionAllowed() == false) {_            logger.warn("[{}] setting will be ignored until an appropriate license is applied", MonitoringField.HISTORY_DURATION.getKey())__        }__        this.globalRetention = globalRetention__    };set,the,global,retention,this,is,expected,to,be,used,by,the,cluster,settings,to,dynamically,control,the,global,retention,time,p,even,if,the,current,license,prevents,retention,updates,it,will,accept,the,change,so,that,they,do,not,need,to,re,set,it,if,they,upgrade,their,license,they,can,always,unset,it,param,global,retention,the,global,retention,to,use,dynamically;public,void,set,global,retention,time,value,global,retention,if,license,state,is,update,retention,allowed,false,logger,warn,setting,will,be,ignored,until,an,appropriate,license,is,applied,monitoring,field,get,key,this,global,retention,global,retention
CleanerService -> public void setGlobalRetention(TimeValue globalRetention);1547625930;Set the global retention. This is expected to be used by the cluster settings to dynamically control the global retention time._<p>_Even if the current license prevents retention updates, it will accept the change so that they do not need to re-set it if they_upgrade their license (they can always unset it).__@param globalRetention The global retention to use dynamically.;public void setGlobalRetention(TimeValue globalRetention) {_        _        if (licenseState.isUpdateRetentionAllowed() == false) {_            logger.warn("[{}] setting will be ignored until an appropriate license is applied", MonitoringField.HISTORY_DURATION.getKey())__        }__        this.globalRetention = globalRetention__    };set,the,global,retention,this,is,expected,to,be,used,by,the,cluster,settings,to,dynamically,control,the,global,retention,time,p,even,if,the,current,license,prevents,retention,updates,it,will,accept,the,change,so,that,they,do,not,need,to,re,set,it,if,they,upgrade,their,license,they,can,always,unset,it,param,global,retention,the,global,retention,to,use,dynamically;public,void,set,global,retention,time,value,global,retention,if,license,state,is,update,retention,allowed,false,logger,warn,setting,will,be,ignored,until,an,appropriate,license,is,applied,monitoring,field,get,key,this,global,retention,global,retention
CleanerService -> public void setGlobalRetention(TimeValue globalRetention);1548953505;Set the global retention. This is expected to be used by the cluster settings to dynamically control the global retention time._<p>_Even if the current license prevents retention updates, it will accept the change so that they do not need to re-set it if they_upgrade their license (they can always unset it).__@param globalRetention The global retention to use dynamically.;public void setGlobalRetention(TimeValue globalRetention) {_        _        if (licenseState.isUpdateRetentionAllowed() == false) {_            logger.warn("[{}] setting will be ignored until an appropriate license is applied", MonitoringField.HISTORY_DURATION.getKey())__        }__        this.globalRetention = globalRetention__    };set,the,global,retention,this,is,expected,to,be,used,by,the,cluster,settings,to,dynamically,control,the,global,retention,time,p,even,if,the,current,license,prevents,retention,updates,it,will,accept,the,change,so,that,they,do,not,need,to,re,set,it,if,they,upgrade,their,license,they,can,always,unset,it,param,global,retention,the,global,retention,to,use,dynamically;public,void,set,global,retention,time,value,global,retention,if,license,state,is,update,retention,allowed,false,logger,warn,setting,will,be,ignored,until,an,appropriate,license,is,applied,monitoring,field,get,key,this,global,retention,global,retention
CleanerService -> public void setGlobalRetention(TimeValue globalRetention);1549288028;Set the global retention. This is expected to be used by the cluster settings to dynamically control the global retention time._<p>_Even if the current license prevents retention updates, it will accept the change so that they do not need to re-set it if they_upgrade their license (they can always unset it).__@param globalRetention The global retention to use dynamically.;public void setGlobalRetention(TimeValue globalRetention) {_        _        if (licenseState.isUpdateRetentionAllowed() == false) {_            logger.warn("[{}] setting will be ignored until an appropriate license is applied", MonitoringField.HISTORY_DURATION.getKey())__        }__        this.globalRetention = globalRetention__    };set,the,global,retention,this,is,expected,to,be,used,by,the,cluster,settings,to,dynamically,control,the,global,retention,time,p,even,if,the,current,license,prevents,retention,updates,it,will,accept,the,change,so,that,they,do,not,need,to,re,set,it,if,they,upgrade,their,license,they,can,always,unset,it,param,global,retention,the,global,retention,to,use,dynamically;public,void,set,global,retention,time,value,global,retention,if,license,state,is,update,retention,allowed,false,logger,warn,setting,will,be,ignored,until,an,appropriate,license,is,applied,monitoring,field,get,key,this,global,retention,global,retention
CleanerService -> public void add(Listener listener);1524684173;Add a {@code listener} that is executed by the internal {@code IndicesCleaner} given the {@link #getRetention() retention} time.__@param listener A listener used to control retention;public void add(Listener listener) {_        listeners.add(listener)__    };add,a,code,listener,that,is,executed,by,the,internal,code,indices,cleaner,given,the,link,get,retention,retention,time,param,listener,a,listener,used,to,control,retention;public,void,add,listener,listener,listeners,add,listener
CleanerService -> public void add(Listener listener);1542646292;Add a {@code listener} that is executed by the internal {@code IndicesCleaner} given the {@link #getRetention() retention} time.__@param listener A listener used to control retention;public void add(Listener listener) {_        listeners.add(listener)__    };add,a,code,listener,that,is,executed,by,the,internal,code,indices,cleaner,given,the,link,get,retention,retention,time,param,listener,a,listener,used,to,control,retention;public,void,add,listener,listener,listeners,add,listener
CleanerService -> public void add(Listener listener);1547625930;Add a {@code listener} that is executed by the internal {@code IndicesCleaner} given the {@link #getRetention() retention} time.__@param listener A listener used to control retention;public void add(Listener listener) {_        listeners.add(listener)__    };add,a,code,listener,that,is,executed,by,the,internal,code,indices,cleaner,given,the,link,get,retention,retention,time,param,listener,a,listener,used,to,control,retention;public,void,add,listener,listener,listeners,add,listener
CleanerService -> public void add(Listener listener);1548953505;Add a {@code listener} that is executed by the internal {@code IndicesCleaner} given the {@link #getRetention() retention} time.__@param listener A listener used to control retention;public void add(Listener listener) {_        listeners.add(listener)__    };add,a,code,listener,that,is,executed,by,the,internal,code,indices,cleaner,given,the,link,get,retention,retention,time,param,listener,a,listener,used,to,control,retention;public,void,add,listener,listener,listeners,add,listener
CleanerService -> public void add(Listener listener);1549288028;Add a {@code listener} that is executed by the internal {@code IndicesCleaner} given the {@link #getRetention() retention} time.__@param listener A listener used to control retention;public void add(Listener listener) {_        listeners.add(listener)__    };add,a,code,listener,that,is,executed,by,the,internal,code,indices,cleaner,given,the,link,get,retention,retention,time,param,listener,a,listener,used,to,control,retention;public,void,add,listener,listener,listeners,add,listener
CleanerService -> IndicesCleaner -> @Override         protected void onAfterInLifecycle();1524684173;Reschedule the cleaner if the service is not stopped.;@Override_        protected void onAfterInLifecycle() {_            DateTime start = new DateTime(ISOChronology.getInstance())__            TimeValue delay = executionScheduler.nextExecutionDelay(start)___            logger.debug("scheduling next execution in [{}] seconds", delay.seconds())___            try {_                future = threadPool.schedule(delay, executorName(), this)__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    logger.debug("couldn't schedule new execution of the cleaner, executor is shutting down", e)__                } else {_                    throw e__                }_            }_        };reschedule,the,cleaner,if,the,service,is,not,stopped;override,protected,void,on,after,in,lifecycle,date,time,start,new,date,time,isochronology,get,instance,time,value,delay,execution,scheduler,next,execution,delay,start,logger,debug,scheduling,next,execution,in,seconds,delay,seconds,try,future,thread,pool,schedule,delay,executor,name,this,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,couldn,t,schedule,new,execution,of,the,cleaner,executor,is,shutting,down,e,else,throw,e
CleanerService -> IndicesCleaner -> @Override         protected void onAfterInLifecycle();1542646292;Reschedule the cleaner if the service is not stopped.;@Override_        protected void onAfterInLifecycle() {_            DateTime start = new DateTime(ISOChronology.getInstance())__            TimeValue delay = executionScheduler.nextExecutionDelay(start)___            logger.debug("scheduling next execution in [{}] seconds", delay.seconds())___            try {_                future = threadPool.schedule(delay, executorName(), this)__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    logger.debug("couldn't schedule new execution of the cleaner, executor is shutting down", e)__                } else {_                    throw e__                }_            }_        };reschedule,the,cleaner,if,the,service,is,not,stopped;override,protected,void,on,after,in,lifecycle,date,time,start,new,date,time,isochronology,get,instance,time,value,delay,execution,scheduler,next,execution,delay,start,logger,debug,scheduling,next,execution,in,seconds,delay,seconds,try,future,thread,pool,schedule,delay,executor,name,this,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,couldn,t,schedule,new,execution,of,the,cleaner,executor,is,shutting,down,e,else,throw,e
CleanerService -> IndicesCleaner -> @Override         protected void onAfterInLifecycle();1547625930;Reschedule the cleaner if the service is not stopped.;@Override_        protected void onAfterInLifecycle() {_            DateTime start = new DateTime(ISOChronology.getInstance())__            TimeValue delay = executionScheduler.nextExecutionDelay(start)___            logger.debug("scheduling next execution in [{}] seconds", delay.seconds())___            try {_                future = threadPool.schedule(delay, executorName(), this)__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    logger.debug("couldn't schedule new execution of the cleaner, executor is shutting down", e)__                } else {_                    throw e__                }_            }_        };reschedule,the,cleaner,if,the,service,is,not,stopped;override,protected,void,on,after,in,lifecycle,date,time,start,new,date,time,isochronology,get,instance,time,value,delay,execution,scheduler,next,execution,delay,start,logger,debug,scheduling,next,execution,in,seconds,delay,seconds,try,future,thread,pool,schedule,delay,executor,name,this,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,couldn,t,schedule,new,execution,of,the,cleaner,executor,is,shutting,down,e,else,throw,e
CleanerService -> IndicesCleaner -> @Override         protected void onAfterInLifecycle();1548953505;Reschedule the cleaner if the service is not stopped.;@Override_        protected void onAfterInLifecycle() {_            DateTime start = new DateTime(ISOChronology.getInstance())__            TimeValue delay = executionScheduler.nextExecutionDelay(start)___            logger.debug("scheduling next execution in [{}] seconds", delay.seconds())___            try {_                cancellable = threadPool.schedule(this, delay, executorName())__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    logger.debug("couldn't schedule new execution of the cleaner, executor is shutting down", e)__                } else {_                    throw e__                }_            }_        };reschedule,the,cleaner,if,the,service,is,not,stopped;override,protected,void,on,after,in,lifecycle,date,time,start,new,date,time,isochronology,get,instance,time,value,delay,execution,scheduler,next,execution,delay,start,logger,debug,scheduling,next,execution,in,seconds,delay,seconds,try,cancellable,thread,pool,schedule,this,delay,executor,name,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,couldn,t,schedule,new,execution,of,the,cleaner,executor,is,shutting,down,e,else,throw,e
CleanerService -> IndicesCleaner -> @Override         protected void onAfterInLifecycle();1549288028;Reschedule the cleaner if the service is not stopped.;@Override_        protected void onAfterInLifecycle() {_            ZonedDateTime start = ZonedDateTime.now(Clock.systemUTC())__            TimeValue delay = executionScheduler.nextExecutionDelay(start)___            logger.debug("scheduling next execution in [{}] seconds", delay.seconds())___            try {_                cancellable = threadPool.schedule(this, delay, executorName())__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    logger.debug("couldn't schedule new execution of the cleaner, executor is shutting down", e)__                } else {_                    throw e__                }_            }_        };reschedule,the,cleaner,if,the,service,is,not,stopped;override,protected,void,on,after,in,lifecycle,zoned,date,time,start,zoned,date,time,now,clock,system,utc,time,value,delay,execution,scheduler,next,execution,delay,start,logger,debug,scheduling,next,execution,in,seconds,delay,seconds,try,cancellable,thread,pool,schedule,this,delay,executor,name,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,couldn,t,schedule,new,execution,of,the,cleaner,executor,is,shutting,down,e,else,throw,e
CleanerService -> Listener -> void onCleanUpIndices(TimeValue retention)_;1524684173;This method is called on listeners so that they can_clean indices.__@param retention global retention value, it can be overridden at exporter level;void onCleanUpIndices(TimeValue retention)_;this,method,is,called,on,listeners,so,that,they,can,clean,indices,param,retention,global,retention,value,it,can,be,overridden,at,exporter,level;void,on,clean,up,indices,time,value,retention
CleanerService -> Listener -> void onCleanUpIndices(TimeValue retention)_;1542646292;This method is called on listeners so that they can_clean indices.__@param retention global retention value, it can be overridden at exporter level;void onCleanUpIndices(TimeValue retention)_;this,method,is,called,on,listeners,so,that,they,can,clean,indices,param,retention,global,retention,value,it,can,be,overridden,at,exporter,level;void,on,clean,up,indices,time,value,retention
CleanerService -> Listener -> void onCleanUpIndices(TimeValue retention)_;1547625930;This method is called on listeners so that they can_clean indices.__@param retention global retention value, it can be overridden at exporter level;void onCleanUpIndices(TimeValue retention)_;this,method,is,called,on,listeners,so,that,they,can,clean,indices,param,retention,global,retention,value,it,can,be,overridden,at,exporter,level;void,on,clean,up,indices,time,value,retention
CleanerService -> Listener -> void onCleanUpIndices(TimeValue retention)_;1548953505;This method is called on listeners so that they can_clean indices.__@param retention global retention value, it can be overridden at exporter level;void onCleanUpIndices(TimeValue retention)_;this,method,is,called,on,listeners,so,that,they,can,clean,indices,param,retention,global,retention,value,it,can,be,overridden,at,exporter,level;void,on,clean,up,indices,time,value,retention
CleanerService -> Listener -> void onCleanUpIndices(TimeValue retention)_;1549288028;This method is called on listeners so that they can_clean indices.__@param retention global retention value, it can be overridden at exporter level;void onCleanUpIndices(TimeValue retention)_;this,method,is,called,on,listeners,so,that,they,can,clean,indices,param,retention,global,retention,value,it,can,be,overridden,at,exporter,level;void,on,clean,up,indices,time,value,retention
CleanerService -> IndicesCleaner -> public void cancel();1524684173;Cancel/stop the cleaning service._<p>_This will kill any scheduled {@link #future} from running. It's possible that this will be executed concurrently with the_{@link #onAfter() rescheduling code}, at which point it will be stopped during the next execution <em>if</em> the service is_stopped.;public void cancel() {_            if (future != null && future.isCancelled() == false) {_                FutureUtils.cancel(future)__            }_        };cancel,stop,the,cleaning,service,p,this,will,kill,any,scheduled,link,future,from,running,it,s,possible,that,this,will,be,executed,concurrently,with,the,link,on,after,rescheduling,code,at,which,point,it,will,be,stopped,during,the,next,execution,em,if,em,the,service,is,stopped;public,void,cancel,if,future,null,future,is,cancelled,false,future,utils,cancel,future
CleanerService -> IndicesCleaner -> public void cancel();1542646292;Cancel/stop the cleaning service._<p>_This will kill any scheduled {@link #future} from running. It's possible that this will be executed concurrently with the_{@link #onAfter() rescheduling code}, at which point it will be stopped during the next execution <em>if</em> the service is_stopped.;public void cancel() {_            if (future != null && future.isCancelled() == false) {_                FutureUtils.cancel(future)__            }_        };cancel,stop,the,cleaning,service,p,this,will,kill,any,scheduled,link,future,from,running,it,s,possible,that,this,will,be,executed,concurrently,with,the,link,on,after,rescheduling,code,at,which,point,it,will,be,stopped,during,the,next,execution,em,if,em,the,service,is,stopped;public,void,cancel,if,future,null,future,is,cancelled,false,future,utils,cancel,future
CleanerService -> IndicesCleaner -> public void cancel();1547625930;Cancel/stop the cleaning service._<p>_This will kill any scheduled {@link #future} from running. It's possible that this will be executed concurrently with the_{@link #onAfter() rescheduling code}, at which point it will be stopped during the next execution <em>if</em> the service is_stopped.;public void cancel() {_            if (future != null && future.isCancelled() == false) {_                FutureUtils.cancel(future)__            }_        };cancel,stop,the,cleaning,service,p,this,will,kill,any,scheduled,link,future,from,running,it,s,possible,that,this,will,be,executed,concurrently,with,the,link,on,after,rescheduling,code,at,which,point,it,will,be,stopped,during,the,next,execution,em,if,em,the,service,is,stopped;public,void,cancel,if,future,null,future,is,cancelled,false,future,utils,cancel,future
CleanerService -> IndicesCleaner -> public void cancel();1548953505;Cancel/stop the cleaning service._<p>_This will kill any scheduled {@link #cancellable} from running. It's possible that this will be executed concurrently with the_{@link #onAfter() rescheduling code}, at which point it will be stopped during the next execution <em>if</em> the service is_stopped.;public void cancel() {_            if (cancellable != null && cancellable.isCancelled() == false) {_                cancellable.cancel()__            }_        };cancel,stop,the,cleaning,service,p,this,will,kill,any,scheduled,link,cancellable,from,running,it,s,possible,that,this,will,be,executed,concurrently,with,the,link,on,after,rescheduling,code,at,which,point,it,will,be,stopped,during,the,next,execution,em,if,em,the,service,is,stopped;public,void,cancel,if,cancellable,null,cancellable,is,cancelled,false,cancellable,cancel
CleanerService -> IndicesCleaner -> public void cancel();1549288028;Cancel/stop the cleaning service._<p>_This will kill any scheduled {@link #cancellable} from running. It's possible that this will be executed concurrently with the_{@link #onAfter() rescheduling code}, at which point it will be stopped during the next execution <em>if</em> the service is_stopped.;public void cancel() {_            if (cancellable != null && cancellable.isCancelled() == false) {_                cancellable.cancel()__            }_        };cancel,stop,the,cleaning,service,p,this,will,kill,any,scheduled,link,cancellable,from,running,it,s,possible,that,this,will,be,executed,concurrently,with,the,link,on,after,rescheduling,code,at,which,point,it,will,be,stopped,during,the,next,execution,em,if,em,the,service,is,stopped;public,void,cancel,if,cancellable,null,cancellable,is,cancelled,false,cancellable,cancel
CleanerService -> IndicesCleaner -> IndicesCleaner();1524684173;Enable automatic logging and stopping of the runnable based on the {@link #lifecycle}.;IndicesCleaner() {_            super(lifecycle, logger)__        };enable,automatic,logging,and,stopping,of,the,runnable,based,on,the,link,lifecycle;indices,cleaner,super,lifecycle,logger
CleanerService -> IndicesCleaner -> IndicesCleaner();1542646292;Enable automatic logging and stopping of the runnable based on the {@link #lifecycle}.;IndicesCleaner() {_            super(lifecycle, logger)__        };enable,automatic,logging,and,stopping,of,the,runnable,based,on,the,link,lifecycle;indices,cleaner,super,lifecycle,logger
CleanerService -> IndicesCleaner -> IndicesCleaner();1547625930;Enable automatic logging and stopping of the runnable based on the {@link #lifecycle}.;IndicesCleaner() {_            super(lifecycle, logger)__        };enable,automatic,logging,and,stopping,of,the,runnable,based,on,the,link,lifecycle;indices,cleaner,super,lifecycle,logger
CleanerService -> IndicesCleaner -> IndicesCleaner();1548953505;Enable automatic logging and stopping of the runnable based on the {@link #lifecycle}.;IndicesCleaner() {_            super(lifecycle, logger)__        };enable,automatic,logging,and,stopping,of,the,runnable,based,on,the,link,lifecycle;indices,cleaner,super,lifecycle,logger
CleanerService -> IndicesCleaner -> IndicesCleaner();1549288028;Enable automatic logging and stopping of the runnable based on the {@link #lifecycle}.;IndicesCleaner() {_            super(lifecycle, logger)__        };enable,automatic,logging,and,stopping,of,the,runnable,based,on,the,link,lifecycle;indices,cleaner,super,lifecycle,logger
CleanerService -> ExecutionScheduler -> TimeValue nextExecutionDelay(DateTime now)_;1524684173;Calculates the delay in millis between "now" and the next execution.__@param now the current time_@return the delay in millis;TimeValue nextExecutionDelay(DateTime now)_;calculates,the,delay,in,millis,between,now,and,the,next,execution,param,now,the,current,time,return,the,delay,in,millis;time,value,next,execution,delay,date,time,now
CleanerService -> ExecutionScheduler -> TimeValue nextExecutionDelay(DateTime now)_;1542646292;Calculates the delay in millis between "now" and the next execution.__@param now the current time_@return the delay in millis;TimeValue nextExecutionDelay(DateTime now)_;calculates,the,delay,in,millis,between,now,and,the,next,execution,param,now,the,current,time,return,the,delay,in,millis;time,value,next,execution,delay,date,time,now
CleanerService -> ExecutionScheduler -> TimeValue nextExecutionDelay(DateTime now)_;1547625930;Calculates the delay in millis between "now" and the next execution.__@param now the current time_@return the delay in millis;TimeValue nextExecutionDelay(DateTime now)_;calculates,the,delay,in,millis,between,now,and,the,next,execution,param,now,the,current,time,return,the,delay,in,millis;time,value,next,execution,delay,date,time,now
CleanerService -> ExecutionScheduler -> TimeValue nextExecutionDelay(DateTime now)_;1548953505;Calculates the delay in millis between "now" and the next execution.__@param now the current time_@return the delay in millis;TimeValue nextExecutionDelay(DateTime now)_;calculates,the,delay,in,millis,between,now,and,the,next,execution,param,now,the,current,time,return,the,delay,in,millis;time,value,next,execution,delay,date,time,now
CleanerService -> public TimeValue getRetention();1524684173;Get the retention that can be used._<p>_This will ignore the global retention if the license does not allow retention updates.__@return Never {@code null}_@see XPackLicenseState#isUpdateRetentionAllowed();public TimeValue getRetention() {_        _        if (licenseState.isUpdateRetentionAllowed() && globalRetention != null) {_            return globalRetention__        }_        else {_            return MonitoringField.HISTORY_DURATION.getDefault(Settings.EMPTY)__        }_    };get,the,retention,that,can,be,used,p,this,will,ignore,the,global,retention,if,the,license,does,not,allow,retention,updates,return,never,code,null,see,xpack,license,state,is,update,retention,allowed;public,time,value,get,retention,if,license,state,is,update,retention,allowed,global,retention,null,return,global,retention,else,return,monitoring,field,get,default,settings,empty
CleanerService -> public TimeValue getRetention();1542646292;Get the retention that can be used._<p>_This will ignore the global retention if the license does not allow retention updates.__@return Never {@code null}_@see XPackLicenseState#isUpdateRetentionAllowed();public TimeValue getRetention() {_        _        if (licenseState.isUpdateRetentionAllowed() && globalRetention != null) {_            return globalRetention__        }_        else {_            return MonitoringField.HISTORY_DURATION.getDefault(Settings.EMPTY)__        }_    };get,the,retention,that,can,be,used,p,this,will,ignore,the,global,retention,if,the,license,does,not,allow,retention,updates,return,never,code,null,see,xpack,license,state,is,update,retention,allowed;public,time,value,get,retention,if,license,state,is,update,retention,allowed,global,retention,null,return,global,retention,else,return,monitoring,field,get,default,settings,empty
CleanerService -> public TimeValue getRetention();1547625930;Get the retention that can be used._<p>_This will ignore the global retention if the license does not allow retention updates.__@return Never {@code null}_@see XPackLicenseState#isUpdateRetentionAllowed();public TimeValue getRetention() {_        _        if (licenseState.isUpdateRetentionAllowed() && globalRetention != null) {_            return globalRetention__        }_        else {_            return MonitoringField.HISTORY_DURATION.getDefault(Settings.EMPTY)__        }_    };get,the,retention,that,can,be,used,p,this,will,ignore,the,global,retention,if,the,license,does,not,allow,retention,updates,return,never,code,null,see,xpack,license,state,is,update,retention,allowed;public,time,value,get,retention,if,license,state,is,update,retention,allowed,global,retention,null,return,global,retention,else,return,monitoring,field,get,default,settings,empty
CleanerService -> public TimeValue getRetention();1548953505;Get the retention that can be used._<p>_This will ignore the global retention if the license does not allow retention updates.__@return Never {@code null}_@see XPackLicenseState#isUpdateRetentionAllowed();public TimeValue getRetention() {_        _        if (licenseState.isUpdateRetentionAllowed() && globalRetention != null) {_            return globalRetention__        }_        else {_            return MonitoringField.HISTORY_DURATION.getDefault(Settings.EMPTY)__        }_    };get,the,retention,that,can,be,used,p,this,will,ignore,the,global,retention,if,the,license,does,not,allow,retention,updates,return,never,code,null,see,xpack,license,state,is,update,retention,allowed;public,time,value,get,retention,if,license,state,is,update,retention,allowed,global,retention,null,return,global,retention,else,return,monitoring,field,get,default,settings,empty
CleanerService -> public TimeValue getRetention();1549288028;Get the retention that can be used._<p>_This will ignore the global retention if the license does not allow retention updates.__@return Never {@code null}_@see XPackLicenseState#isUpdateRetentionAllowed();public TimeValue getRetention() {_        _        if (licenseState.isUpdateRetentionAllowed() && globalRetention != null) {_            return globalRetention__        }_        else {_            return MonitoringField.HISTORY_DURATION.getDefault(Settings.EMPTY)__        }_    };get,the,retention,that,can,be,used,p,this,will,ignore,the,global,retention,if,the,license,does,not,allow,retention,updates,return,never,code,null,see,xpack,license,state,is,update,retention,allowed;public,time,value,get,retention,if,license,state,is,update,retention,allowed,global,retention,null,return,global,retention,else,return,monitoring,field,get,default,settings,empty
