commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;17;/**  * Adds a validator for the {@link #SSL_SETTING} to prevent dynamic updates when secure settings also exist within that setting  * groups (ssl context).  * Because it is not possible to re-read the secure settings during a dynamic update, we cannot rebuild the {@link SSLIOSessionStrategy}  * (see {@link #configureSecurity(RestClientBuilder, Config, SSLService)} if this exporter has been configured with secure settings  */ ;/**  * Adds a validator for the {@link #SSL_SETTING} to prevent dynamic updates when secure settings also exist within that setting  * groups (ssl context).  * Because it is not possible to re-read the secure settings during a dynamic update, we cannot rebuild the {@link SSLIOSessionStrategy}  * (see {@link #configureSecurity(RestClientBuilder, Config, SSLService)} if this exporter has been configured with secure settings  */ public static void registerSettingValidators(ClusterService clusterService) {     clusterService.getClusterSettings().addAffixUpdateConsumer(SSL_SETTING, (ignoreKey, ignoreSettings) -> {     // no-op update. We only care about the validator     }, (namespace, settings) -> {         final List<String> secureSettings = SSLConfigurationSettings.withoutPrefix().getSecureSettingsInUse(settings).stream().map(Setting::getKey).collect(Collectors.toList()).         if (secureSettings.isEmpty() == false) {             throw new IllegalStateException("Cannot dynamically update SSL settings for the exporter [" + namespace + "] as it depends on the secure setting(s) [" + Strings.collectionToCommaDelimitedString(secureSettings) + "]").         }     }). }
true;static;3;23;/**  * Create a {@link RestClientBuilder} from the HTTP Exporter's {@code config}.  *  * @param config The HTTP Exporter's configuration  * @param sslService The SSL Service used to create the SSL Context necessary for TLS / SSL communication  * @param listener The node failure listener used to log node failures  * @return Never {@code null}.  * @throws SettingsException if any required setting is missing or any setting is malformed  */ ;/**  * Create a {@link RestClientBuilder} from the HTTP Exporter's {@code config}.  *  * @param config The HTTP Exporter's configuration  * @param sslService The SSL Service used to create the SSL Context necessary for TLS / SSL communication  * @param listener The node failure listener used to log node failures  * @return Never {@code null}.  * @throws SettingsException if any required setting is missing or any setting is malformed  */ static RestClient createRestClient(final Config config, final SSLService sslService, final NodeFailureListener listener) {     final RestClientBuilder builder = RestClient.builder(createHosts(config)).setFailureListener(listener).     Setting<String> concreteSetting = PROXY_BASE_PATH_SETTING.getConcreteSettingForNamespace(config.name()).     final String proxyBasePath = concreteSetting.get(config.settings()).     // allow the user to configure proxies     if (Strings.isNullOrEmpty(proxyBasePath) == false) {         try {             builder.setPathPrefix(proxyBasePath).         } catch (final IllegalArgumentException e) {             throw new SettingsException("[" + concreteSetting.getKey() + "] is malformed [" + proxyBasePath + "]", e).         }     }     // allow the user to configure headers that go along with _every_ request     configureHeaders(builder, config).     // commercial X-Pack users can have Security enabled (auth and SSL/TLS), and also clusters behind proxies     configureSecurity(builder, config, sslService).     // timeouts for requests     configureTimeouts(builder, config).     return builder.build(). }
true;static;3;23;/**  * Create a {@link Sniffer} from the HTTP Exporter's {@code config} for the {@code client}.  *  * @param config The HTTP Exporter's configuration  * @param client The REST client to sniff  * @param listener The node failure listener used to help improve sniffing  * @return Can be {@code null} if the sniffer is disabled.  * @throws IndexOutOfBoundsException if no {@linkplain #HOST_SETTING hosts} are set  */ ;/**  * Create a {@link Sniffer} from the HTTP Exporter's {@code config} for the {@code client}.  *  * @param config The HTTP Exporter's configuration  * @param client The REST client to sniff  * @param listener The node failure listener used to help improve sniffing  * @return Can be {@code null} if the sniffer is disabled.  * @throws IndexOutOfBoundsException if no {@linkplain #HOST_SETTING hosts} are set  */ static Sniffer createSniffer(final Config config, final RestClient client, final NodeFailureListener listener) {     Sniffer sniffer = null.     // the sniffer is allowed to be ENABLED. it's disabled by default until we think it's ready for use     boolean sniffingEnabled = SNIFF_ENABLED_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     if (sniffingEnabled) {         final List<String> hosts = HOST_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).         // createHosts(config) ensures that all schemes are the same for all hosts!         final ElasticsearchNodesSniffer.Scheme scheme = hosts.get(0).startsWith("https") ? ElasticsearchNodesSniffer.Scheme.HTTPS : ElasticsearchNodesSniffer.Scheme.HTTP.         final ElasticsearchNodesSniffer hostsSniffer = new ElasticsearchNodesSniffer(client, ElasticsearchNodesSniffer.DEFAULT_SNIFF_REQUEST_TIMEOUT, scheme).         sniffer = Sniffer.builder(client).setNodesSniffer(hostsSniffer).build().         // inform the sniffer whenever there's a node failure         listener.setSniffer(sniffer).         logger.debug("exporter [{}] using host sniffing", config.name()).     }     return sniffer. }
true;static;1;17;/**  * Create a {@link MultiHttpResource} that can be used to block bulk exporting until all expected resources are available.  *  * @param config The HTTP Exporter's configuration  * @return Never {@code null}.  */ ;/**  * Create a {@link MultiHttpResource} that can be used to block bulk exporting until all expected resources are available.  *  * @param config The HTTP Exporter's configuration  * @return Never {@code null}.  */ static MultiHttpResource createResources(final Config config) {     final String resourceOwnerName = "xpack.monitoring.exporters." + config.name().     // order controls the order that each is checked. more direct checks should always happen first (e.g., version checks)     final List<HttpResource> resources = new ArrayList<>().     // block the exporter from working against a monitoring cluster with the wrong version     resources.add(new VersionHttpResource(resourceOwnerName, MIN_SUPPORTED_CLUSTER_VERSION)).     // load all templates (template bodies are lazily loaded on demand)     configureTemplateResources(config, resourceOwnerName, resources).     // load the pipeline (this will get added to as the monitoring API version increases)     configurePipelineResources(config, resourceOwnerName, resources).     // load the watches for cluster alerts if Watcher is available     configureClusterAlertsResources(config, resourceOwnerName, resources).     return new MultiHttpResource(resourceOwnerName, resources). }
true;private,static;1;40;/**  * Create the {@link HttpHost}s that will be connected too.  *  * @param config The exporter's configuration  * @return Never {@code null} or empty.  * @throws SettingsException if any setting is malformed or if no host is set  */ ;/**  * Create the {@link HttpHost}s that will be connected too.  *  * @param config The exporter's configuration  * @return Never {@code null} or empty.  * @throws SettingsException if any setting is malformed or if no host is set  */ private static HttpHost[] createHosts(final Config config) {     final List<String> hosts = HOST_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     String configKey = HOST_SETTING.getConcreteSettingForNamespace(config.name()).getKey().     if (hosts.isEmpty()) {         throw new SettingsException("missing required setting [" + configKey + "]").     }     final List<HttpHost> httpHosts = new ArrayList<>(hosts.size()).     boolean httpHostFound = false.     boolean httpsHostFound = false.     // every host must be configured     for (final String host : hosts) {         final HttpHost httpHost.         try {             httpHost = HttpHostBuilder.builder(host).build().         } catch (IllegalArgumentException e) {             throw new SettingsException("[" + configKey + "] invalid host: [" + host + "]", e).         }         if ("http".equals(httpHost.getSchemeName())) {             httpHostFound = true.         } else {             httpsHostFound = true.         }         // fail if we find them configuring the scheme/protocol in different ways         if (httpHostFound && httpsHostFound) {             throw new SettingsException("[" + configKey + "] must use a consistent scheme: http or https").         }         httpHosts.add(httpHost).     }     logger.debug("exporter [{}] using hosts {}", config.name(), hosts).     return httpHosts.toArray(new HttpHost[httpHosts.size()]). }
true;private,static;2;35;/**  * Configures the {@linkplain RestClientBuilder#setDefaultHeaders(Header[]) default headers} to use with <em>all</em> requests.  *  * @param builder The REST client builder to configure  * @param config The exporter's configuration  * @throws SettingsException if any header is {@linkplain #BLACKLISTED_HEADERS blacklisted}  */ ;/**  * Configures the {@linkplain RestClientBuilder#setDefaultHeaders(Header[]) default headers} to use with <em>all</em> requests.  *  * @param builder The REST client builder to configure  * @param config The exporter's configuration  * @throws SettingsException if any header is {@linkplain #BLACKLISTED_HEADERS blacklisted}  */ private static void configureHeaders(final RestClientBuilder builder, final Config config) {     Setting<Settings> concreteSetting = HEADERS_SETTING.getConcreteSettingForNamespace(config.name()).     final Settings headerSettings = concreteSetting.get(config.settings()).     final Set<String> names = headerSettings.names().     // Most users won't define headers     if (names.isEmpty()) {         return.     }     final List<Header> headers = new ArrayList<>().     // record and validate each header as best we can     for (final String name : names) {         if (BLACKLISTED_HEADERS.contains(name)) {             throw new SettingsException("header cannot be overwritten via [" + concreteSetting.getKey() + name + "]").         }         final List<String> values = headerSettings.getAsList(name).         if (values.isEmpty()) {             throw new SettingsException("headers must have values, missing for setting [" + concreteSetting.getKey() + name + "]").         }         // Warning: xyz         for (final String value : values) {             headers.add(new BasicHeader(name, value)).         }     }     builder.setDefaultHeaders(headers.toArray(new Header[headers.size()])). }
true;private,static;3;27;/**  * Configure the {@link RestClientBuilder} to use {@linkplain CredentialsProvider user authentication} and/or  * {@linkplain SSLContext SSL / TLS}.  *  * @param builder The REST client builder to configure  * @param config The exporter's configuration  * @param sslService The SSL Service used to create the SSL Context necessary for TLS / SSL communication  * @throws SettingsException if any setting causes issues  */ ;/**  * Configure the {@link RestClientBuilder} to use {@linkplain CredentialsProvider user authentication} and/or  * {@linkplain SSLContext SSL / TLS}.  *  * @param builder The REST client builder to configure  * @param config The exporter's configuration  * @param sslService The SSL Service used to create the SSL Context necessary for TLS / SSL communication  * @throws SettingsException if any setting causes issues  */ private static void configureSecurity(final RestClientBuilder builder, final Config config, final SSLService sslService) {     final Setting<Settings> concreteSetting = SSL_SETTING.getConcreteSettingForNamespace(config.name()).     final Settings sslSettings = concreteSetting.get(config.settings()).     final SSLIOSessionStrategy sslStrategy.     if (SSLConfigurationSettings.withoutPrefix().getSecureSettingsInUse(sslSettings).isEmpty()) {         // This configuration does not use secure settings, so it is possible that is has been dynamically updated.         // We need to load a new SSL strategy in case these settings differ from the ones that the SSL service was configured with.         sslStrategy = sslService.sslIOSessionStrategy(sslSettings).     } else {         // This configuration uses secure settings. We cannot load a new SSL strategy, as the secure settings have already been closed.         // Due to #registerSettingValidators we know that the settings not been dynamically updated, and the pre-configured strategy         // is still the correct configuration for use in this exporter.         final SSLConfiguration sslConfiguration = sslService.getSSLConfiguration(concreteSetting.getKey()).         sslStrategy = sslService.sslIOSessionStrategy(sslConfiguration).     }     final CredentialsProvider credentialsProvider = createCredentialsProvider(config).     List<String> hostList = HOST_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     // sending credentials in plaintext!     if (credentialsProvider != null && hostList.stream().findFirst().orElse("").startsWith("https") == false) {         logger.warn("exporter [{}] is not using https, but using user authentication with plaintext " + "username/password!", config.name()).     }     if (sslStrategy != null) {         builder.setHttpClientConfigCallback(new SecurityHttpClientConfigCallback(sslStrategy, credentialsProvider)).     } }
true;private,static;2;9;/**  * Configure the {@link RestClientBuilder} to use initial connection and socket timeouts.  *  * @param builder The REST client builder to configure  * @param config The exporter's configuration  */ ;/**  * Configure the {@link RestClientBuilder} to use initial connection and socket timeouts.  *  * @param builder The REST client builder to configure  * @param config The exporter's configuration  */ private static void configureTimeouts(final RestClientBuilder builder, final Config config) {     final TimeValue connectTimeout = CONNECTION_TIMEOUT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     final TimeValue socketTimeout = CONNECTION_READ_TIMEOUT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     // if the values could ever be null, then we should only set it if they're not null     builder.setRequestConfigCallback(new TimeoutRequestConfigCallback(connectTimeout, socketTimeout)). }
true;private,static;1;21;/**  * Creates the optional {@link CredentialsProvider} with the username/password to use with <em>all</em> requests for user  * authentication.  *  * @param config The exporter's configuration  * @return {@code null} if username and password not are provided. Otherwise the {@link CredentialsProvider} to use.  * @throws SettingsException if the username is missing, but a password is supplied  */ ;/**  * Creates the optional {@link CredentialsProvider} with the username/password to use with <em>all</em> requests for user  * authentication.  *  * @param config The exporter's configuration  * @return {@code null} if username and password not are provided. Otherwise the {@link CredentialsProvider} to use.  * @throws SettingsException if the username is missing, but a password is supplied  */ @Nullable private static CredentialsProvider createCredentialsProvider(final Config config) {     final String username = AUTH_USERNAME_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     final String password = AUTH_PASSWORD_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     // username is required for any auth     if (Strings.isNullOrEmpty(username)) {         if (Strings.isNullOrEmpty(password) == false) {             throw new SettingsException("[" + AUTH_PASSWORD_SETTING.getConcreteSettingForNamespace(config.name()).getKey() + "] without [" + AUTH_USERNAME_SETTING.getConcreteSettingForNamespace(config.name()).getKey() + "]").         }         // nothing to configure. default situation for most users         return null.     }     final CredentialsProvider credentialsProvider = new BasicCredentialsProvider().     credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(username, password)).     return credentialsProvider. }
true;static;1;19;/**  * Create the default parameters to use with bulk indexing operations.  *  * @param config The exporter's configuration  * @return Never {@code null}. Can be empty.  */ ;/**  * Create the default parameters to use with bulk indexing operations.  *  * @param config The exporter's configuration  * @return Never {@code null}. Can be empty.  */ static Map<String, String> createDefaultParams(final Config config) {     final TimeValue bulkTimeout = BULK_TIMEOUT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     final MapBuilder<String, String> params = new MapBuilder<>().     if (TimeValue.MINUS_ONE.equals(bulkTimeout) == false) {         params.put("timeout", bulkTimeout.toString()).     }     // allow the use of ingest pipelines to be completely optional     if (USE_INGEST_PIPELINE_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())) {         params.put("pipeline", MonitoringTemplateUtils.pipelineName(MonitoringTemplateUtils.TEMPLATE_VERSION)).     }     // widdle down the response to just what we care to check     params.put("filter_path", "errors,items.*.error").     return params.immutableMap(). }
true;private,static;3;26;/**  * Adds the {@code resources} necessary for checking and publishing monitoring templates.  *  * @param config The HTTP Exporter's configuration  * @param resourceOwnerName The resource owner name to display for any logging messages.  * @param resources The resources to add too.  */ ;/**  * Adds the {@code resources} necessary for checking and publishing monitoring templates.  *  * @param config The HTTP Exporter's configuration  * @param resourceOwnerName The resource owner name to display for any logging messages.  * @param resources The resources to add too.  */ private static void configureTemplateResources(final Config config, final String resourceOwnerName, final List<HttpResource> resources) {     final TimeValue templateTimeout = TEMPLATE_CHECK_TIMEOUT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     // add templates not managed by resolvers     for (final String templateId : MonitoringTemplateUtils.TEMPLATE_IDS) {         final String templateName = MonitoringTemplateUtils.templateName(templateId).         final Supplier<String> templateLoader = () -> MonitoringTemplateUtils.loadTemplate(templateId).         resources.add(new TemplateHttpResource(resourceOwnerName, templateTimeout, templateName, templateLoader)).     }     // add old templates, like ".monitoring-data-2" and ".monitoring-es-2" so that other versions can continue to work     boolean createLegacyTemplates = TEMPLATE_CREATE_LEGACY_VERSIONS_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     if (createLegacyTemplates) {         for (final String templateId : MonitoringTemplateUtils.OLD_TEMPLATE_IDS) {             final String templateName = MonitoringTemplateUtils.oldTemplateName(templateId).             final Supplier<String> templateLoader = () -> MonitoringTemplateUtils.createEmptyTemplate(templateId).             resources.add(new TemplateHttpResource(resourceOwnerName, templateTimeout, templateName, templateLoader)).         }     } }
true;private,static;3;19;/**  * Adds the {@code resources} necessary for checking and publishing monitoring pipelines.  *  * @param config The HTTP Exporter's configuration  * @param resourceOwnerName The resource owner name to display for any logging messages.  * @param resources The resources to add too.  */ ;/**  * Adds the {@code resources} necessary for checking and publishing monitoring pipelines.  *  * @param config The HTTP Exporter's configuration  * @param resourceOwnerName The resource owner name to display for any logging messages.  * @param resources The resources to add too.  */ private static void configurePipelineResources(final Config config, final String resourceOwnerName, final List<HttpResource> resources) {     // don't require pipelines if we're not using them     if (USE_INGEST_PIPELINE_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())) {         final TimeValue pipelineTimeout = PIPELINE_CHECK_TIMEOUT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).         // add all pipelines         for (final String pipelineId : MonitoringTemplateUtils.PIPELINE_IDS) {             final String pipelineName = MonitoringTemplateUtils.pipelineName(pipelineId).             // lazily load the pipeline             final Supplier<byte[]> pipeline = () -> BytesReference.toBytes(BytesReference.bytes(MonitoringTemplateUtils.loadPipeline(pipelineId, XContentType.JSON))).             resources.add(new PipelineHttpResource(resourceOwnerName, pipelineTimeout, pipelineName, pipeline)).         }     } }
true;private,static;3;23;/**  * Adds the {@code resources} necessary for checking and publishing cluster alerts.  *  * @param config The HTTP Exporter's configuration  * @param resourceOwnerName The resource owner name to display for any logging messages.  * @param resources The resources to add too.  */ ;/**  * Adds the {@code resources} necessary for checking and publishing cluster alerts.  *  * @param config The HTTP Exporter's configuration  * @param resourceOwnerName The resource owner name to display for any logging messages.  * @param resources The resources to add too.  */ private static void configureClusterAlertsResources(final Config config, final String resourceOwnerName, final List<HttpResource> resources) {     // don't create watches if we're not using them     if (CLUSTER_ALERTS_MANAGEMENT_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings())) {         final ClusterService clusterService = config.clusterService().         final List<HttpResource> watchResources = new ArrayList<>().         final List<String> blacklist = ClusterAlertsUtil.getClusterAlertsBlacklist(config).         // add a resource per watch         for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {             final boolean blacklisted = blacklist.contains(watchId).             // lazily load the cluster state to fetch the cluster UUID once it's loaded             final Supplier<String> uniqueWatchId = () -> ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId).             final Supplier<String> watch = blacklisted ? null : () -> ClusterAlertsUtil.loadWatch(clusterService, watchId).             watchResources.add(new ClusterAlertHttpResource(resourceOwnerName, config.licenseState(), uniqueWatchId, watch)).         }         // wrap the watches in a conditional resource check to ensure the remote cluster has watcher available / enabled         resources.add(new WatcherExistsHttpResource(resourceOwnerName, clusterService, new MultiHttpResource(resourceOwnerName, watchResources))).     } }
false;public;1;20;;@Override public void openBulk(final ActionListener<ExportBulk> listener) {     final boolean canUseClusterAlerts = config.licenseState().isMonitoringClusterAlertsAllowed().     // if this changes between updates, then we need to add OR remove the watches     if (clusterAlertsAllowed.compareAndSet(!canUseClusterAlerts, canUseClusterAlerts)) {         resource.markDirty().     }     resource.checkAndPublishIfDirty(client, ActionListener.wrap((success) -> {         if (success) {             final String name = "xpack.monitoring.exporters." + config.name().             listener.onResponse(new HttpExportBulk(name, client, defaultParams, dateTimeFormatter, threadContext)).         } else {             // we're not ready yet, so keep waiting             listener.onResponse(null).         }     }, listener::onFailure)). }
false;public;0;16;;@Override public void doClose() {     try {         if (sniffer != null) {             sniffer.close().         }     } catch (Exception e) {         logger.error("an error occurred while closing the internal client sniffer", e).     } finally {         try {             client.close().         } catch (Exception e) {             logger.error("an error occurred while closing the internal client", e).         }     } }
false;public,static;0;5;;public static List<Setting.AffixSetting<?>> getSettings() {     return Arrays.asList(HOST_SETTING, TEMPLATE_CREATE_LEGACY_VERSIONS_SETTING, AUTH_PASSWORD_SETTING, AUTH_USERNAME_SETTING, BULK_TIMEOUT_SETTING, CONNECTION_READ_TIMEOUT_SETTING, CONNECTION_TIMEOUT_SETTING, PIPELINE_CHECK_TIMEOUT_SETTING, PROXY_BASE_PATH_SETTING, SNIFF_ENABLED_SETTING, TEMPLATE_CHECK_TIMEOUT_SETTING, SSL_SETTING, HEADERS_SETTING). }
