commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Get the Watch resources that are managed by this resource.  *  * @return Never {@code null}.  */ ;/**  * Get the Watch resources that are managed by this resource.  *  * @return Never {@code null}.  */ public MultiHttpResource getWatches() {     return watches. }
true;protected;2;10;/**  * Determine if X-Pack is installed and, if so, if Watcher is both available <em>and</em> enabled so that it can be used.  * <p>  * If it is not both available and enabled, then we mark that it {@code EXISTS} so that no follow-on work is performed relative to  * Watcher. We do the same thing if the current node is not the elected master node.  */ ;/**  * Determine if X-Pack is installed and, if so, if Watcher is both available <em>and</em> enabled so that it can be used.  * <p>  * If it is not both available and enabled, then we mark that it {@code EXISTS} so that no follow-on work is performed relative to  * Watcher. We do the same thing if the current node is not the elected master node.  */ @Override protected void doCheck(final RestClient client, final ActionListener<Boolean> listener) {     // only the master manages watches     if (clusterService.state().nodes().isLocalNodeElectedMaster()) {         checkXPackForWatcher(client, listener).     } else {         // not the elected master         listener.onResponse(true).     } }
true;private;2;12;/**  * Reach out to the remote cluster to determine the usability of Watcher.  *  * @param client The REST client to make the request(s).  * @param listener Returns {@code true} to <em>skip</em> cluster alert creation. {@code false} to check/create them.  */ ;/**  * Reach out to the remote cluster to determine the usability of Watcher.  *  * @param client The REST client to make the request(s).  * @param listener Returns {@code true} to <em>skip</em> cluster alert creation. {@code false} to check/create them.  */ private void checkXPackForWatcher(final RestClient client, final ActionListener<Boolean> listener) {     final CheckedFunction<Response, Boolean, IOException> responseChecker = (response) -> canUseWatcher(response, XContentType.JSON.xContent()).     // use DNE to pretend that we're all set. it means that Watcher is unusable     final CheckedFunction<Response, Boolean, IOException> doesNotExistChecker = (response) -> false.     checkForResource(client, listener, logger, "", "_xpack", "watcher check", resourceOwnerName, "monitoring cluster", GET_EXISTS, Sets.newHashSet(RestStatus.NOT_FOUND.getStatus(), RestStatus.BAD_REQUEST.getStatus()), responseChecker, doesNotExistChecker). }
true;private;2;17;/**  * Determine if Watcher exists ({@code EXISTS}) or does not exist ({@code DOES_NOT_EXIST}).  *  * @param response The filtered response from the _xpack info API  * @param xContent The XContent parser to use  * @return {@code true} represents it can be used. {@code false} that it cannot be used.  * @throws IOException if any issue occurs while parsing the {@code xContent} {@code response}.  * @throws RuntimeException if the response format is changed.  */ ;/**  * Determine if Watcher exists ({@code EXISTS}) or does not exist ({@code DOES_NOT_EXIST}).  *  * @param response The filtered response from the _xpack info API  * @param xContent The XContent parser to use  * @return {@code true} represents it can be used. {@code false} that it cannot be used.  * @throws IOException if any issue occurs while parsing the {@code xContent} {@code response}.  * @throws RuntimeException if the response format is changed.  */ private boolean canUseWatcher(final Response response, final XContent xContent) throws IOException {     // no named content used. so EMPTY is fine     final Map<String, Object> xpackInfo = XContentHelper.convertToMap(xContent, response.getEntity().getContent(), false).     // if it's empty, then there's no features.watcher response because of filter_path usage     if (xpackInfo.isEmpty() == false) {         @SuppressWarnings("unchecked")         final Map<String, Object> features = (Map<String, Object>) xpackInfo.get("features").         @SuppressWarnings("unchecked")         final Map<String, Object> watcher = (Map<String, Object>) features.get("watcher").         // if Watcher is both available _and_ enabled, then we can use it. either being true is not sufficient         return Boolean.TRUE == watcher.get("available") && Boolean.TRUE == watcher.get("enabled").     }     return false. }
true;protected;2;4;/**  * Add Watches to the remote cluster.  */ ;/**  * Add Watches to the remote cluster.  */ @Override protected void doPublish(final RestClient client, final ActionListener<Boolean> listener) {     watches.checkAndPublish(client, listener). }
