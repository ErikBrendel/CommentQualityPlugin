commented;modifiers;parameterAmount;loc;comment;code
true;protected;2;7;/**  * Determine if the current {@linkplain #templateName template} exists with a relevant version (&gt.= to expected).  *  * @see MonitoringTemplateUtils#LAST_UPDATED_VERSION  */ ;/**  * Determine if the current {@linkplain #templateName template} exists with a relevant version (&gt.= to expected).  *  * @see MonitoringTemplateUtils#LAST_UPDATED_VERSION  */ @Override protected void doCheck(final RestClient client, final ActionListener<Boolean> listener) {     versionCheckForResource(client, listener, logger, "/_template", templateName, "monitoring template", resourceOwnerName, "monitoring cluster", XContentType.JSON.xContent(), MonitoringTemplateUtils.LAST_UPDATED_VERSION). }
true;protected;2;7;/**  * Publish the missing {@linkplain #templateName template}.  */ ;/**  * Publish the missing {@linkplain #templateName template}.  */ @Override protected void doPublish(final RestClient client, final ActionListener<Boolean> listener) {     Map<String, String> parameters = Collections.singletonMap(INCLUDE_TYPE_NAME_PARAMETER, "true").     putResource(client, listener, logger, "/_template", templateName, parameters, this::templateToHttpEntity, "monitoring template", resourceOwnerName, "monitoring cluster"). }
true;;0;3;/**  * Create a {@link HttpEntity} for the {@link #template}.  *  * @return Never {@code null}.  */ ;/**  * Create a {@link HttpEntity} for the {@link #template}.  *  * @return Never {@code null}.  */ HttpEntity templateToHttpEntity() {     return new StringEntity(template.get(), ContentType.APPLICATION_JSON). }
