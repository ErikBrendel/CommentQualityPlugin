commented;modifiers;parameterAmount;loc;comment;code
false;private;1;6;;private void setExportersSetting(Settings exportersSetting) {     if (this.lifecycle.started()) {         Map<String, Exporter> updated = initExporters(exportersSetting).         closeExporters(logger, this.exporters.getAndSet(updated)).     } }
false;protected;0;4;;@Override protected void doStart() {     exporters.set(initExporters(settings)). }
false;protected;0;4;;@Override protected void doStop() {     closeExporters(logger, exporters.get()). }
false;protected;0;3;;@Override protected void doClose() { }
false;public;1;3;;public Exporter getExporter(String name) {     return exporters.get().get(name). }
true;public;0;3;/**  * Get all enabled {@linkplain Exporter}s.  *  * @return Never {@code null}. Can be empty if none are enabled.  */ ;/**  * Get all enabled {@linkplain Exporter}s.  *  * @return Never {@code null}. Can be empty if none are enabled.  */ public Collection<Exporter> getEnabledExporters() {     return exporters.get().values(). }
false;static;2;9;;static void closeExporters(Logger logger, Map<String, Exporter> exporters) {     for (Exporter exporter : exporters.values()) {         try {             exporter.close().         } catch (Exception e) {             logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to close exporter [{}]", exporter.name()), e).         }     } }
false;;1;49;;Map<String, Exporter> initExporters(Settings settings) {     Set<String> singletons = new HashSet<>().     Map<String, Exporter> exporters = new HashMap<>().     boolean hasDisabled = false.     Settings exportersSettings = settings.getByPrefix("xpack.monitoring.exporters.").     for (String name : exportersSettings.names()) {         Settings exporterSettings = exportersSettings.getAsSettings(name).         String type = exporterSettings.get("type").         if (type == null) {             throw new SettingsException("missing exporter type for [" + name + "] exporter").         }         Exporter.Factory factory = factories.get(type).         if (factory == null) {             throw new SettingsException("unknown exporter type [" + type + "] set for exporter [" + name + "]").         }         Exporter.Config config = new Exporter.Config(name, type, settings, clusterService, licenseState).         if (!config.enabled()) {             hasDisabled = true.             if (logger.isDebugEnabled()) {                 logger.debug("exporter [{}/{}] is disabled", type, name).             }             continue.         }         Exporter exporter = factory.create(config).         if (exporter.isSingleton()) {             // (there can only be one instance of a singleton exporter)             if (singletons.contains(type)) {                 throw new SettingsException("multiple [" + type + "] exporters are configured. there can " + "only be one [" + type + "] exporter configured").             }             singletons.add(type).         }         exporters.put(config.name(), exporter).     }     //      if (exporters.isEmpty() && !hasDisabled) {         Exporter.Config config = new Exporter.Config("default_" + LocalExporter.TYPE, LocalExporter.TYPE, settings, clusterService, licenseState).         exporters.put(config.name(), factories.get(LocalExporter.TYPE).create(config)).     }     return exporters. }
true;;1;25;/**  * Wrap every {@linkplain Exporter}'s {@linkplain ExportBulk} in a {@linkplain ExportBulk.Compound}.  *  * @param listener {@code null} if no exporters are ready or available.  */ ;/**  * Wrap every {@linkplain Exporter}'s {@linkplain ExportBulk} in a {@linkplain ExportBulk.Compound}.  *  * @param listener {@code null} if no exporters are ready or available.  */ void wrapExportBulk(final ActionListener<ExportBulk> listener) {     final ClusterState state = clusterService.state().     // wait until we have a usable cluster state     if (state.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || ClusterState.UNKNOWN_UUID.equals(state.metaData().clusterUUID()) || state.version() == ClusterState.UNKNOWN_VERSION) {         logger.trace("skipping exporters because the cluster state is not loaded").         listener.onResponse(null).         return.     }     final Map<String, Exporter> exporterMap = exporters.get().     final AtomicArray<ExportBulk> accumulatedBulks = new AtomicArray<>(exporterMap.size()).     final CountDown countDown = new CountDown(exporterMap.size()).     int i = 0.     // get every exporter's ExportBulk and, when they've all responded, respond with a wrapped version     for (final Exporter exporter : exporterMap.values()) {         exporter.openBulk(new AccumulatingExportBulkActionListener(exporter.name(), i++, accumulatedBulks, countDown, threadContext, listener)).     } }
true;public;2;15;/**  * Exports a collection of monitoring documents using the configured exporters  */ ;/**  * Exports a collection of monitoring documents using the configured exporters  */ public void export(final Collection<MonitoringDoc> docs, final ActionListener<Void> listener) throws ExportException {     if (this.lifecycleState() != Lifecycle.State.STARTED) {         listener.onFailure(new ExportException("Export service is not started")).     } else if (docs != null && docs.size() > 0) {         wrapExportBulk(ActionListener.wrap(bulk -> {             if (bulk != null) {                 doExport(bulk, docs, listener).             } else {                 listener.onResponse(null).             }         }, listener::onFailure)).     } else {         listener.onResponse(null).     } }
true;private;3;17;/**  * Add {@code docs} and send the {@code bulk}, then respond to the {@code listener}.  *  * @param bulk The bulk object to send {@code docs} through.  * @param docs The monitoring documents to send.  * @param listener Returns {@code null} when complete, or failure where relevant.  */ ;/**  * Add {@code docs} and send the {@code bulk}, then respond to the {@code listener}.  *  * @param bulk The bulk object to send {@code docs} through.  * @param docs The monitoring documents to send.  * @param listener Returns {@code null} when complete, or failure where relevant.  */ private void doExport(final ExportBulk bulk, final Collection<MonitoringDoc> docs, final ActionListener<Void> listener) {     final AtomicReference<ExportException> exceptionRef = new AtomicReference<>().     try {         bulk.add(docs).     } catch (ExportException e) {         exceptionRef.set(e).     } finally {         bulk.close(lifecycleState() == Lifecycle.State.STARTED, ActionListener.wrap(r -> {             if (exceptionRef.get() == null) {                 listener.onResponse(null).             } else {                 listener.onFailure(exceptionRef.get()).             }         }, listener::onFailure)).     } }
true;public,static;0;6;/**  * Return all the settings of all the exporters, no matter if HTTP or Local  */ ;/**  * Return all the settings of all the exporters, no matter if HTTP or Local  */ public static List<Setting.AffixSetting<?>> getSettings() {     List<Setting.AffixSetting<?>> settings = new ArrayList<>().     settings.addAll(Exporter.getSettings()).     settings.addAll(HttpExporter.getSettings()).     return settings. }
false;public;1;10;;@Override public void onResponse(final ExportBulk exportBulk) {     if (exportBulk == null) {         logger.debug("skipping exporter [{}] as it is not ready yet", name).     } else {         accumulatedBulks.set(indexPosition, exportBulk).     }     delegateIfComplete(). }
false;public;1;6;;@Override public void onFailure(Exception e) {     logger.error((Supplier<?>) () -> new ParameterizedMessage("exporter [{}] failed to open exporting bulk", name), e).     delegateIfComplete(). }
true;;0;11;/**  * Once all {@linkplain Exporter}'s have responded, whether it was success or failure, then this responds with all successful  * {@linkplain ExportBulk}s wrapped using an {@linkplain ExportBulk.Compound} wrapper.  */ ;/**  * Once all {@linkplain Exporter}'s have responded, whether it was success or failure, then this responds with all successful  * {@linkplain ExportBulk}s wrapped using an {@linkplain ExportBulk.Compound} wrapper.  */ void delegateIfComplete() {     if (countDown.countDown()) {         final List<ExportBulk> bulkList = accumulatedBulks.asList().         if (bulkList.isEmpty()) {             delegate.onResponse(null).         } else {             delegate.onResponse(new ExportBulk.Compound(bulkList, threadContext)).         }     } }
