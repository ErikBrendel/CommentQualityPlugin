commented;modifiers;parameterAmount;loc;comment;code
true;protected;2;19;/**  * Determine if the current {@linkplain #watchId Watch} exists.  */ ;/**  * Determine if the current {@linkplain #watchId Watch} exists.  */ @Override protected void doCheck(final RestClient client, final ActionListener<Boolean> listener) {     // if we should be adding, then we need to check for existence     if (isWatchDefined() && licenseState.isMonitoringClusterAlertsAllowed()) {         final CheckedFunction<Response, Boolean, IOException> watchChecker = (response) -> shouldReplaceClusterAlert(response, XContentType.JSON.xContent(), LAST_UPDATED_VERSION).         checkForResource(client, listener, logger, "/_watcher/watch", watchId.get(), "monitoring cluster alert", resourceOwnerName, "monitoring cluster", GET_EXISTS, GET_DOES_NOT_EXIST, watchChecker, this::alwaysReplaceResource).     } else {         // if we should be deleting, then just try to delete it (same level of effort as checking)         deleteResource(client, listener, logger, "/_watcher/watch", watchId.get(), "monitoring cluster alert", resourceOwnerName, "monitoring cluster").     } }
true;protected;2;6;/**  * Publish the missing {@linkplain #watchId Watch}.  */ ;/**  * Publish the missing {@linkplain #watchId Watch}.  */ @Override protected void doPublish(final RestClient client, final ActionListener<Boolean> listener) {     putResource(client, listener, logger, "/_watcher/watch", watchId.get(), Collections.emptyMap(), this::watchToHttpEntity, "monitoring cluster alert", resourceOwnerName, "monitoring cluster"). }
true;;0;3;/**  * Determine if the {@link #watch} is defined. If not, then we should always delete the watch.  *  * @return {@code true} if {@link #watch} is defined (non-{@code null}). Otherwise {@code false}.  */ ;/**  * Determine if the {@link #watch} is defined. If not, then we should always delete the watch.  *  * @return {@code true} if {@link #watch} is defined (non-{@code null}). Otherwise {@code false}.  */ boolean isWatchDefined() {     return watch != null. }
true;;0;3;/**  * Create a {@link HttpEntity} for the {@link #watch}.  *  * @return Never {@code null}.  */ ;/**  * Create a {@link HttpEntity} for the {@link #watch}.  *  * @return Never {@code null}.  */ HttpEntity watchToHttpEntity() {     return new StringEntity(watch.get(), ContentType.APPLICATION_JSON). }
true;;3;21;/**  * Determine if the {@code response} contains a Watch whose value  *  * <p>  * This expects a response like:  * <pre><code>  * {  *   "metadata": {  *     "xpack": {  *       "version": 6000002  *     }  *   }  * }  * </code></pre>  *  * @param response The filtered response from the Get Watcher API  * @param xContent The XContent parser to use  * @param minimumVersion The minimum version allowed without being replaced (expected to be the last updated version).  * @return {@code true} represents that it should be replaced. {@code false} that it should be left alone.  * @throws IOException if any issue occurs while parsing the {@code xContent} {@code response}.  * @throws RuntimeException if the response format is changed.  */ ;/**  * Determine if the {@code response} contains a Watch whose value  *  * <p>  * This expects a response like:  * <pre><code>  * {  *   "metadata": {  *     "xpack": {  *       "version": 6000002  *     }  *   }  * }  * </code></pre>  *  * @param response The filtered response from the Get Watcher API  * @param xContent The XContent parser to use  * @param minimumVersion The minimum version allowed without being replaced (expected to be the last updated version).  * @return {@code true} represents that it should be replaced. {@code false} that it should be left alone.  * @throws IOException if any issue occurs while parsing the {@code xContent} {@code response}.  * @throws RuntimeException if the response format is changed.  */ boolean shouldReplaceClusterAlert(final Response response, final XContent xContent, final int minimumVersion) throws IOException {     // no named content used. so EMPTY is fine     final Map<String, Object> resources = XContentHelper.convertToMap(xContent, response.getEntity().getContent(), false).     // if it's empty, then there's no version in the response thanks to filter_path     if (resources.isEmpty() == false) {         @SuppressWarnings("unchecked")         final Map<String, Object> metadata = (Map<String, Object>) resources.get("metadata").         @SuppressWarnings("unchecked")         final Map<String, Object> xpack = metadata != null ? (Map<String, Object>) metadata.get("xpack") : null.         final Object version = xpack != null ? xpack.get("version_created") : null.         // if we don't have it (perhaps more fields were returned), then we need to replace it         if (version instanceof Number) {             // the version in the cluster alert is expected to include the alpha/beta/rc codes as well             return ((Number) version).intValue() < minimumVersion.         }     }     return true. }
