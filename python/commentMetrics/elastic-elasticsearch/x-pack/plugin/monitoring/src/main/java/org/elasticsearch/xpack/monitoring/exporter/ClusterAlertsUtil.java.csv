commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Create a unique identifier for the watch and cluster.  *  * @param clusterService The cluster service used to fetch the latest cluster state.  * @param watchId The watch's ID.  * @return Never {@code null}.  * @see #WATCH_IDS  */ ;/**  * Create a unique identifier for the watch and cluster.  *  * @param clusterService The cluster service used to fetch the latest cluster state.  * @param watchId The watch's ID.  * @return Never {@code null}.  * @see #WATCH_IDS  */ public static String createUniqueWatchId(final ClusterService clusterService, final String watchId) {     return createUniqueWatchId(clusterService.state().metaData().clusterUUID(), watchId). }
true;private,static;2;3;/**  * Create a unique identifier for the watch and cluster.  *  * @param clusterUuid The cluster's UUID.  * @param watchId The watch's ID.  * @return Never {@code null}.  * @see #WATCH_IDS  */ ;/**  * Create a unique identifier for the watch and cluster.  *  * @param clusterUuid The cluster's UUID.  * @param watchId The watch's ID.  * @return Never {@code null}.  * @see #WATCH_IDS  */ private static String createUniqueWatchId(final String clusterUuid, final String watchId) {     return clusterUuid + "_" + watchId. }
true;public,static;2;19;/**  * Create a unique watch ID and load the {@code watchId} resource by replacing variables,  * such as the cluster's UUID.  *  * @param clusterService The cluster service used to fetch the latest cluster state.  * @param watchId The watch's ID.  * @return Never {@code null}. The key is the unique watch ID. The value is the Watch source.  * @throws RuntimeException if the watch does not exist  */ ;/**  * Create a unique watch ID and load the {@code watchId} resource by replacing variables,  * such as the cluster's UUID.  *  * @param clusterService The cluster service used to fetch the latest cluster state.  * @param watchId The watch's ID.  * @return Never {@code null}. The key is the unique watch ID. The value is the Watch source.  * @throws RuntimeException if the watch does not exist  */ public static String loadWatch(final ClusterService clusterService, final String watchId) {     final String resource = String.format(Locale.ROOT, WATCH_FILE, watchId).     try {         final String clusterUuid = clusterService.state().metaData().clusterUUID().         final String uniqueWatchId = createUniqueWatchId(clusterUuid, watchId).         // load the resource as-is         String source = loadResource(resource).utf8ToString().         source = CLUSTER_UUID_PROPERTY.matcher(source).replaceAll(clusterUuid).         source = WATCH_ID_PROPERTY.matcher(source).replaceAll(watchId).         source = UNIQUE_WATCH_ID_PROPERTY.matcher(source).replaceAll(uniqueWatchId).         return source.     } catch (final IOException e) {         throw new RuntimeException("Unable to load Watch [" + watchId + "]", e).     } }
false;private,static;1;9;;private static BytesReference loadResource(final String resource) throws IOException {     try (InputStream is = ClusterAlertsUtil.class.getResourceAsStream(resource)) {         try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {             Streams.copy(is, out).             return new BytesArray(out.toByteArray()).         }     } }
true;public,static;1;18;/**  * Get any blacklisted cluster alerts by their ID.  *  * @param config The {@link Exporter}'s configuration, which is used for the {@link SettingsException}.  * @return Never {@code null}. Can be empty.  * @throws SettingsException if an unknown cluster alert ID exists in the blacklist.  */ ;/**  * Get any blacklisted cluster alerts by their ID.  *  * @param config The {@link Exporter}'s configuration, which is used for the {@link SettingsException}.  * @return Never {@code null}. Can be empty.  * @throws SettingsException if an unknown cluster alert ID exists in the blacklist.  */ public static List<String> getClusterAlertsBlacklist(final Exporter.Config config) {     final List<String> blacklist = CLUSTER_ALERTS_BLACKLIST_SETTING.getConcreteSettingForNamespace(config.name()).get(config.settings()).     // validate the blacklist only contains recognized IDs     if (blacklist.isEmpty() == false) {         final List<String> watchIds = Arrays.asList(ClusterAlertsUtil.WATCH_IDS).         final Set<String> unknownIds = blacklist.stream().filter(id -> watchIds.contains(id) == false).collect(Collectors.toSet()).         if (unknownIds.isEmpty() == false) {             throw new SettingsException("[" + CLUSTER_ALERTS_BLACKLIST_SETTING.getConcreteSettingForNamespace(config.name()).getKey() + "] contains unrecognized Cluster Alert IDs [" + String.join(", ", unknownIds) + "]").         }     }     return blacklist. }
