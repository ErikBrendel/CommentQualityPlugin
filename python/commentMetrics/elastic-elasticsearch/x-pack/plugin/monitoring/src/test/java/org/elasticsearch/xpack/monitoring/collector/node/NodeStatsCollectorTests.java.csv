commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;public void testShouldCollectReturnsFalseIfMonitoringNotAllowed() {     // this controls the blockage     when(licenseState.isMonitoringAllowed()).thenReturn(false).     final boolean isElectedMaster = randomBoolean().     whenLocalNodeElectedMaster(isElectedMaster).     final NodeStatsCollector collector = new NodeStatsCollector(clusterService, licenseState, client).     assertThat(collector.shouldCollect(isElectedMaster), is(false)).     if (isElectedMaster) {         verify(licenseState).isMonitoringAllowed().     } }
false;public;0;9;;public void testShouldCollectReturnsTrue() {     when(licenseState.isMonitoringAllowed()).thenReturn(true).     final boolean isElectedMaster = true.     final NodeStatsCollector collector = new NodeStatsCollector(clusterService, licenseState, client).     assertThat(collector.shouldCollect(isElectedMaster), is(true)).     verify(licenseState).isMonitoringAllowed(). }
false;public;0;22;;public void testDoCollectWithFailures() throws Exception {     when(licenseState.isMonitoringAllowed()).thenReturn(true).     final TimeValue timeout = TimeValue.parseTimeValue(randomPositiveTimeValue(), NodeStatsCollectorTests.class.getName()).     withCollectionTimeout(NodeStatsCollector.NODE_STATS_TIMEOUT, timeout).     final NodesStatsResponse nodesStatsResponse = mock(NodesStatsResponse.class).     when(nodesStatsResponse.hasFailures()).thenReturn(true).     final FailedNodeException exception = new FailedNodeException("_node_id", "_msg", new Exception()).     when(nodesStatsResponse.failures()).thenReturn(Collections.singletonList(exception)).     final Client client = mock(Client.class).     thenReturnNodeStats(client, timeout, nodesStatsResponse).     final NodeStatsCollector collector = new NodeStatsCollector(clusterService, licenseState, client).     assertEquals(timeout, collector.getCollectionTimeout()).     final FailedNodeException e = expectThrows(FailedNodeException.class, () -> collector.doCollect(randomMonitoringNode(random()), randomNonNegativeLong(), clusterState)).     assertEquals(exception, e). }
false;public;0;54;;public void testDoCollect() throws Exception {     when(licenseState.isMonitoringAllowed()).thenReturn(true).     final TimeValue timeout = TimeValue.timeValueSeconds(randomIntBetween(1, 120)).     withCollectionTimeout(NodeStatsCollector.NODE_STATS_TIMEOUT, timeout).     final boolean isMaster = randomBoolean().     whenLocalNodeElectedMaster(isMaster).     final String clusterUUID = UUID.randomUUID().toString().     whenClusterStateWithUUID(clusterUUID).     final MonitoringDoc.Node node = randomMonitoringNode(random()).     final NodesStatsResponse nodesStatsResponse = mock(NodesStatsResponse.class).     when(nodesStatsResponse.hasFailures()).thenReturn(false).     final NodeStats nodeStats = mock(NodeStats.class).     when(nodesStatsResponse.getNodes()).thenReturn(Collections.singletonList(nodeStats)).     final long timestamp = randomNonNegativeLong().     when(nodeStats.getTimestamp()).thenReturn(timestamp).     final Client client = mock(Client.class).     thenReturnNodeStats(client, timeout, nodesStatsResponse).     final NodeStatsCollector collector = new NodeStatsCollector(clusterService, licenseState, client).     assertEquals(timeout, collector.getCollectionTimeout()).     final long interval = randomNonNegativeLong().     final Collection<MonitoringDoc> results = collector.doCollect(node, interval, clusterState).     verify(clusterState).metaData().     verify(metaData).clusterUUID().     assertEquals(1, results.size()).     final MonitoringDoc monitoringDoc = results.iterator().next().     assertThat(monitoringDoc, instanceOf(NodeStatsMonitoringDoc.class)).     final NodeStatsMonitoringDoc document = (NodeStatsMonitoringDoc) monitoringDoc.     assertThat(document.getCluster(), equalTo(clusterUUID)).     assertThat(document.getTimestamp(), equalTo(timestamp)).     assertThat(document.getIntervalMillis(), equalTo(interval)).     assertThat(document.getNode(), equalTo(node)).     assertThat(document.getSystem(), is(MonitoredSystem.ES)).     assertThat(document.getType(), equalTo(NodeStatsMonitoringDoc.TYPE)).     assertThat(document.getId(), nullValue()).     assertThat(document.isNodeMaster(), equalTo(isMaster)).     assertThat(document.getNodeId(), equalTo(node.getUUID())).     assertThat(document.getNodeStats(), is(nodeStats)).     assertThat(document.isMlockall(), equalTo(BootstrapInfo.isMemoryLocked())). }
false;private;3;12;;private void thenReturnNodeStats(final Client client, final TimeValue timeout, final NodesStatsResponse nodesStatsResponse) {     @SuppressWarnings("unchecked")     final ActionFuture<NodesStatsResponse> future = (ActionFuture<NodesStatsResponse>) mock(ActionFuture.class).     when(future.actionGet(eq(timeout))).thenReturn(nodesStatsResponse).     final ClusterAdminClient clusterAdminClient = mock(ClusterAdminClient.class).     when(clusterAdminClient.nodesStats(any(NodesStatsRequest.class))).thenReturn(future).     final AdminClient adminClient = mock(AdminClient.class).     when(adminClient.cluster()).thenReturn(clusterAdminClient).     when(client.admin()).thenReturn(adminClient). }
