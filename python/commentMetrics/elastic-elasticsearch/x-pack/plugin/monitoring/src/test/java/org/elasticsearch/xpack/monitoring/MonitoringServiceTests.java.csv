commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected XPackLicenseState getLicenseState() {     return licenseState. }
false;public;0;19;;@Before public void setUp() throws Exception {     super.setUp().     threadPool = new TestThreadPool(getTestName()).     clusterService = mock(ClusterService.class).     Settings settings = Settings.builder().put("path.home", createTempDir()).build().     final Monitoring monitoring = new Monitoring(settings) {          @Override         protected XPackLicenseState getLicenseState() {             return licenseState.         }     }.     clusterSettings = new ClusterSettings(Settings.EMPTY, new HashSet<>(monitoring.getSettings())).     when(clusterService.getClusterSettings()).thenReturn(clusterSettings).     when(clusterService.state()).thenReturn(mock(ClusterState.class)). }
false;public;0;7;;@After public void terminate() throws Exception {     if (monitoringService != null) {         monitoringService.close().     }     terminate(threadPool). }
false;public;0;22;;public void testIsMonitoringActive() throws Exception {     monitoringService = new MonitoringService(Settings.EMPTY, clusterService, threadPool, emptySet(), new CountingExporter()).     monitoringService.start().     assertBusy(() -> assertTrue(monitoringService.isStarted())).     assertFalse(monitoringService.isMonitoringActive()).     monitoringService.setMonitoringActive(true).     assertTrue(monitoringService.isMonitoringActive()).     monitoringService.stop().     assertBusy(() -> assertFalse(monitoringService.isStarted())).     assertFalse(monitoringService.isMonitoringActive()).     monitoringService.start().     assertBusy(() -> assertTrue(monitoringService.isStarted())).     assertTrue(monitoringService.isMonitoringActive()).     monitoringService.close().     assertBusy(() -> assertFalse(monitoringService.isStarted())).     assertFalse(monitoringService.isMonitoringActive()). }
false;public;0;23;;public void testInterval() throws Exception {     final Settings settings = Settings.builder().put("xpack.monitoring.collection.interval", MonitoringService.MIN_INTERVAL).build().     CountingExporter exporter = new CountingExporter().     monitoringService = new MonitoringService(settings, clusterService, threadPool, emptySet(), exporter).     monitoringService.start().     assertBusy(() -> assertTrue(monitoringService.isStarted())).     assertFalse("interval does not start the monitoring execution", monitoringService.isMonitoringActive()).     assertEquals(0, exporter.getExportsCount()).     monitoringService.setMonitoringActive(true).     assertTrue(monitoringService.isMonitoringActive()).     // now the interval should take place     assertBusy(() -> assertThat(exporter.getExportsCount(), greaterThan(0))).     // take down threads     monitoringService.setMonitoringActive(false). }
false;public;0;22;;public void testSkipExecution() throws Exception {     final CountDownLatch latch = new CountDownLatch(1).     final BlockingExporter exporter = new BlockingExporter(latch).     final Settings settings = Settings.builder().put("xpack.monitoring.collection.enabled", true).put("xpack.monitoring.collection.interval", MonitoringService.MIN_INTERVAL).build().     monitoringService = new MonitoringService(settings, clusterService, threadPool, emptySet(), exporter).     monitoringService.start().     assertBusy(() -> assertTrue(monitoringService.isStarted())).     assertBusy(() -> assertThat(exporter.getExportsCount(), equalTo(1))).     monitoringService.cancelExecution().     latch.countDown().     assertThat(exporter.getExportsCount(), equalTo(1)). }
false;public;2;5;;@Override public void export(Collection<MonitoringDoc> docs, ActionListener<Void> listener) {     exports.incrementAndGet().     listener.onResponse(null). }
false;;0;3;;int getExportsCount() {     return exports.get(). }
false;protected;0;3;;@Override protected void doStart() { }
false;protected;0;3;;@Override protected void doStop() { }
false;protected;0;3;;@Override protected void doClose() { }
false;public;2;12;;@Override public void export(Collection<MonitoringDoc> docs, ActionListener<Void> listener) {     super.export(docs, ActionListener.wrap(r -> {         try {             latch.await().             listener.onResponse(null).         } catch (InterruptedException e) {             listener.onFailure(new ExportException("BlockingExporter failed", e)).         }     }, listener::onFailure)). }
false;protected;0;3;;@Override protected void doStart() { }
false;protected;0;3;;@Override protected void doStop() { }
false;protected;0;3;;@Override protected void doClose() { }
