commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Before public void setupClusterState() {     final ClusterState clusterState = mock(ClusterState.class).     final DiscoveryNodes nodes = mock(DiscoveryNodes.class).     when(clusterService.state()).thenReturn(clusterState).     when(clusterState.metaData()).thenReturn(metaData).     when(clusterState.nodes()).thenReturn(nodes).     // always let the watcher resources run for these tests. HttpExporterResourceTests tests it flipping on/off     when(nodes.isLocalNodeElectedMaster()).thenReturn(true). }
false;public;0;20;;public void testExporterWithBlacklistedHeaders() {     final String blacklistedHeader = randomFrom(HttpExporter.BLACKLISTED_HEADERS).     final String expected = "header cannot be overwritten via [xpack.monitoring.exporters._http.headers." + blacklistedHeader + "]".     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", HttpExporter.TYPE).put("xpack.monitoring.exporters._http.host", "http://localhost:9200").put("xpack.monitoring.exporters._http.headers.abc", "xyz").put("xpack.monitoring.exporters._http.headers." + blacklistedHeader, "value should not matter").     if (randomBoolean()) {         builder.put("xpack.monitoring.exporters._http.headers.xyz", "abc").     }     final Config config = createConfig(builder.build()).     final SettingsException exception = expectThrows(SettingsException.class, () -> new HttpExporter(config, sslService, threadContext)).     assertThat(exception.getMessage(), equalTo(expected)). }
false;public;0;19;;public void testExporterWithEmptyHeaders() {     final String name = randomFrom("abc", "ABC", "X-Flag").     final String expected = "headers must have values, missing for setting [xpack.monitoring.exporters._http.headers." + name + "]".     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", HttpExporter.TYPE).put("xpack.monitoring.exporters._http.host", "localhost:9200").put("xpack.monitoring.exporters._http.headers." + name, "").     if (randomBoolean()) {         builder.put("xpack.monitoring.exporters._http.headers.xyz", "abc").     }     final Config config = createConfig(builder.build()).     final SettingsException exception = expectThrows(SettingsException.class, () -> new HttpExporter(config, sslService, threadContext)).     assertThat(exception.getMessage(), equalTo(expected)). }
false;public;0;15;;public void testExporterWithPasswordButNoUsername() {     final String expected = "[xpack.monitoring.exporters._http.auth.password] without [xpack.monitoring.exporters._http.auth.username]".     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", HttpExporter.TYPE).put("xpack.monitoring.exporters._http.host", "localhost:9200").put("xpack.monitoring.exporters._http.auth.password", "_pass").     final Config config = createConfig(builder.build()).     final SettingsException exception = expectThrows(SettingsException.class, () -> new HttpExporter(config, sslService, threadContext)).     assertThat(exception.getMessage(), equalTo(expected)). }
false;public;0;20;;public void testExporterWithMissingHost() {     // forgot host!     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", HttpExporter.TYPE).     if (randomBoolean()) {         builder.put("xpack.monitoring.exporters._http.host", "").     } else if (randomBoolean()) {         builder.putList("xpack.monitoring.exporters._http.host").     } else if (randomBoolean()) {         builder.putNull("xpack.monitoring.exporters._http.host").     }     final Config config = createConfig(builder.build()).     final SettingsException exception = expectThrows(SettingsException.class, () -> new HttpExporter(config, sslService, threadContext)).     assertThat(exception.getMessage(), equalTo("missing required setting [xpack.monitoring.exporters._http.host]")). }
false;public;0;13;;public void testExporterWithInconsistentSchemes() {     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", HttpExporter.TYPE).putList("xpack.monitoring.exporters._http.host", "http://localhost:9200", "https://localhost:9201").     final Config config = createConfig(builder.build()).     final SettingsException exception = expectThrows(SettingsException.class, () -> new HttpExporter(config, sslService, threadContext)).     assertThat(exception.getMessage(), equalTo("[xpack.monitoring.exporters._http.host] must use a consistent scheme: http or https")). }
false;public;0;24;;public void testExporterWithInvalidHost() {     final String invalidHost = randomFrom("://localhost:9200", "gopher!://xyz.my.com").     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", HttpExporter.TYPE).     // sometimes add a valid URL with it     if (randomBoolean()) {         if (randomBoolean()) {             builder.putList("xpack.monitoring.exporters._http.host", "localhost:9200", invalidHost).         } else {             builder.putList("xpack.monitoring.exporters._http.host", invalidHost, "localhost:9200").         }     } else {         builder.put("xpack.monitoring.exporters._http.host", invalidHost).     }     final Config config = createConfig(builder.build()).     final SettingsException exception = expectThrows(SettingsException.class, () -> new HttpExporter(config, sslService, threadContext)).     assertThat(exception.getMessage(), equalTo("[xpack.monitoring.exporters._http.host] invalid host: [" + invalidHost + "]")). }
false;public;0;27;;public void testExporterWithUnknownBlacklistedClusterAlerts() {     final SSLIOSessionStrategy sslStrategy = mock(SSLIOSessionStrategy.class).     when(sslService.sslIOSessionStrategy(any(Settings.class))).thenReturn(sslStrategy).     final List<String> blacklist = new ArrayList<>().     blacklist.add("does_not_exist").     if (randomBoolean()) {         // a valid ID         blacklist.add(randomFrom(ClusterAlertsUtil.WATCH_IDS)).         Collections.shuffle(blacklist, random()).     }     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", HttpExporter.TYPE).put("xpack.monitoring.exporters._http.host", "http://localhost:9200").putList("xpack.monitoring.exporters._http.cluster_alerts.management.blacklist", blacklist).     final Config config = createConfig(builder.build()).     final SettingsException exception = expectThrows(SettingsException.class, () -> new HttpExporter(config, sslService, threadContext)).     assertThat(exception.getMessage(), equalTo("[xpack.monitoring.exporters._http.cluster_alerts.management.blacklist] contains unrecognized Cluster " + "Alert IDs [does_not_exist]")). }
false;public;0;12;;public void testExporterWithHostOnly() throws Exception {     final SSLIOSessionStrategy sslStrategy = mock(SSLIOSessionStrategy.class).     when(sslService.sslIOSessionStrategy(any(Settings.class))).thenReturn(sslStrategy).     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", "http").put("xpack.monitoring.exporters._http.host", "http://localhost:9200").     final Config config = createConfig(builder.build()).     new HttpExporter(config, sslService, threadContext).close(). }
false;public;0;26;;public void testCreateRestClient() throws IOException {     final SSLIOSessionStrategy sslStrategy = mock(SSLIOSessionStrategy.class).     when(sslService.sslIOSessionStrategy(any(Settings.class))).thenReturn(sslStrategy).     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", "http").put("xpack.monitoring.exporters._http.host", "http://localhost:9200").     // use basic auth     if (randomBoolean()) {         builder.put("xpack.monitoring.exporters._http.auth.username", "_user").put("xpack.monitoring.exporters._http.auth.password", "_pass").     }     // use headers     if (randomBoolean()) {         builder.put("xpack.monitoring.exporters._http.headers.abc", "xyz").     }     final Config config = createConfig(builder.build()).     final NodeFailureListener listener = mock(NodeFailureListener.class).     // doesn't explode     HttpExporter.createRestClient(config, sslService, listener).close(). }
false;public;0;9;;public void testCreateSnifferDisabledByDefault() {     final Config config = createConfig(Settings.EMPTY).     final RestClient client = mock(RestClient.class).     final NodeFailureListener listener = mock(NodeFailureListener.class).     assertThat(HttpExporter.createSniffer(config, client, listener), nullValue()).     verifyZeroInteractions(client, listener). }
false;public;0;11;;public void testCreateSnifferWithoutHosts() {     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", "http").put("xpack.monitoring.exporters._http.sniff.enabled", true).     final Config config = createConfig(builder.build()).     final RestClient client = mock(RestClient.class).     final NodeFailureListener listener = mock(NodeFailureListener.class).     expectThrows(IndexOutOfBoundsException.class, () -> HttpExporter.createSniffer(config, client, listener)). }
false;public;0;27;;public void testCreateSniffer() throws IOException {     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", "http").put("xpack.monitoring.exporters._http.host", randomFrom("neither", "http", "https")).put("xpack.monitoring.exporters._http.sniff.enabled", true).     final Config config = createConfig(builder.build()).     final RestClient client = mock(RestClient.class).     final NodeFailureListener listener = mock(NodeFailureListener.class).     final Response response = mock(Response.class).     final StringEntity entity = new StringEntity("{}", ContentType.APPLICATION_JSON).     when(response.getEntity()).thenReturn(entity).     when(client.performRequest(any(Request.class))).thenReturn(response).     try (Sniffer sniffer = HttpExporter.createSniffer(config, client, listener)) {         assertThat(sniffer, not(nullValue())).         verify(listener).setSniffer(sniffer).     }     // it's a race whether it triggers this at all     verify(client, atMost(1)).performRequest(any(Request.class)).     verifyNoMoreInteractions(client, listener). }
false;public;0;79;;public void testCreateResources() {     final boolean useIngest = randomBoolean().     final boolean clusterAlertManagement = randomBoolean().     final boolean createOldTemplates = randomBoolean().     final TimeValue templateTimeout = randomFrom(TimeValue.timeValueSeconds(30), null).     final TimeValue pipelineTimeout = randomFrom(TimeValue.timeValueSeconds(30), null).     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", "http").     if (useIngest == false) {         builder.put("xpack.monitoring.exporters._http.use_ingest", false).     }     if (clusterAlertManagement == false) {         builder.put("xpack.monitoring.exporters._http.cluster_alerts.management.enabled", false).     }     if (createOldTemplates == false) {         builder.put("xpack.monitoring.exporters._http.index.template.create_legacy_templates", false).     }     if (templateTimeout != null) {         builder.put("xpack.monitoring.exporters._http.index.template.master_timeout", templateTimeout.getStringRep()).     }     // note: this shouldn't get used with useIngest == false, but it doesn't hurt to try to cause issues     if (pipelineTimeout != null) {         builder.put("xpack.monitoring.exporters._http.index.pipeline.master_timeout", pipelineTimeout.getStringRep()).     }     final Config config = createConfig(builder.build()).     final MultiHttpResource multiResource = HttpExporter.createResources(config).     final List<HttpResource> resources = multiResource.getResources().     final int version = (int) resources.stream().filter((resource) -> resource instanceof VersionHttpResource).count().     final List<TemplateHttpResource> templates = resources.stream().filter((resource) -> resource instanceof TemplateHttpResource).map(TemplateHttpResource.class::cast).collect(Collectors.toList()).     final List<PipelineHttpResource> pipelines = resources.stream().filter((resource) -> resource instanceof PipelineHttpResource).map(PipelineHttpResource.class::cast).collect(Collectors.toList()).     final List<WatcherExistsHttpResource> watcherCheck = resources.stream().filter((resource) -> resource instanceof WatcherExistsHttpResource).map(WatcherExistsHttpResource.class::cast).collect(Collectors.toList()).     final List<ClusterAlertHttpResource> watches.     if (watcherCheck.isEmpty()) {         watches = Collections.emptyList().     } else {         watches = watcherCheck.get(0).getWatches().getResources().stream().filter((resource) -> resource instanceof ClusterAlertHttpResource).map(ClusterAlertHttpResource.class::cast).collect(Collectors.toList()).     }     // expected number of resources     assertThat(multiResource.getResources().size(), equalTo(version + templates.size() + pipelines.size() + watcherCheck.size())).     assertThat(version, equalTo(1)).     assertThat(templates, hasSize(createOldTemplates ? TEMPLATE_IDS.length + OLD_TEMPLATE_IDS.length : TEMPLATE_IDS.length)).     assertThat(pipelines, hasSize(useIngest ? PIPELINE_IDS.length : 0)).     assertThat(watcherCheck, hasSize(clusterAlertManagement ? 1 : 0)).     assertThat(watches, hasSize(clusterAlertManagement ? ClusterAlertsUtil.WATCH_IDS.length : 0)).     // timeouts     assertMasterTimeoutSet(templates, templateTimeout).     assertMasterTimeoutSet(pipelines, pipelineTimeout).     // logging owner names     final List<String> uniqueOwners = resources.stream().map(HttpResource::getResourceOwnerName).distinct().collect(Collectors.toList()).     assertThat(uniqueOwners, hasSize(1)).     assertThat(uniqueOwners.get(0), equalTo("xpack.monitoring.exporters._http")). }
false;public;0;35;;public void testCreateDefaultParams() {     final TimeValue bulkTimeout = randomFrom(TimeValue.timeValueSeconds(30), null).     final boolean useIngest = randomBoolean().     final Settings.Builder builder = Settings.builder().put("xpack.monitoring.exporters._http.type", "http").     if (bulkTimeout != null) {         builder.put("xpack.monitoring.exporters._http.bulk.timeout", bulkTimeout.toString()).     }     if (useIngest == false) {         builder.put("xpack.monitoring.exporters._http.use_ingest", false).     }     final Config config = createConfig(builder.build()).     final Map<String, String> parameters = new HashMap<>(HttpExporter.createDefaultParams(config)).     assertThat(parameters.remove("filter_path"), equalTo("errors,items.*.error")).     if (bulkTimeout != null) {         assertThat(parameters.remove("timeout"), equalTo(bulkTimeout.toString())).     } else {         assertNull(parameters.remove("timeout")).     }     if (useIngest) {         assertThat(parameters.remove("pipeline"), equalTo(MonitoringTemplateUtils.pipelineName(MonitoringTemplateUtils.TEMPLATE_VERSION))).     }     // should have removed everything     assertThat(parameters.size(), equalTo(0)). }
false;public;0;23;;public void testHttpExporterDirtyResourcesBlock() throws Exception {     final Config config = createConfig(Settings.EMPTY).     final RestClient client = mock(RestClient.class).     final Sniffer sniffer = randomFrom(mock(Sniffer.class), null).     final NodeFailureListener listener = mock(NodeFailureListener.class).     // this is configured to throw an error when the resource is checked     final HttpResource resource = new MockHttpResource(exporterName(), true, null, false).     try (HttpExporter exporter = new HttpExporter(config, client, sniffer, threadContext, listener, resource)) {         verify(listener).setResource(resource).         final CountDownLatch awaitResponseAndClose = new CountDownLatch(1).         final ActionListener<ExportBulk> bulkListener = ActionListener.wrap(bulk -> fail("[onFailure] should have been invoked by failed resource check"), e -> awaitResponseAndClose.countDown()).         exporter.openBulk(bulkListener).         // wait for it to actually respond         assertTrue(awaitResponseAndClose.await(15, TimeUnit.SECONDS)).     } }
false;public;0;27;;public void testHttpExporterReturnsNullForOpenBulkIfNotReady() throws Exception {     final Config config = createConfig(Settings.EMPTY).     final RestClient client = mock(RestClient.class).     final Sniffer sniffer = randomFrom(mock(Sniffer.class), null).     final NodeFailureListener listener = mock(NodeFailureListener.class).     // always has to check, and never succeeds checks but it does not throw an exception (e.g., version check fails)     final HttpResource resource = new MockHttpResource(exporterName(), true, false, false).     try (HttpExporter exporter = new HttpExporter(config, client, sniffer, threadContext, listener, resource)) {         verify(listener).setResource(resource).         final CountDownLatch awaitResponseAndClose = new CountDownLatch(1).         final ActionListener<ExportBulk> bulkListener = ActionListener.wrap(bulk -> {             assertThat(bulk, nullValue()).             awaitResponseAndClose.countDown().         }, e -> fail(e.getMessage())).         exporter.openBulk(bulkListener).         // wait for it to actually respond         assertTrue(awaitResponseAndClose.await(15, TimeUnit.SECONDS)).     } }
false;public;0;27;;public void testHttpExporter() throws Exception {     final Config config = createConfig(Settings.EMPTY).     final RestClient client = mock(RestClient.class).     final Sniffer sniffer = randomFrom(mock(Sniffer.class), null).     final NodeFailureListener listener = mock(NodeFailureListener.class).     // sometimes dirty to start with and sometimes not. but always succeeds on checkAndPublish     final HttpResource resource = new MockHttpResource(exporterName(), randomBoolean()).     try (HttpExporter exporter = new HttpExporter(config, client, sniffer, threadContext, listener, resource)) {         verify(listener).setResource(resource).         final CountDownLatch awaitResponseAndClose = new CountDownLatch(1).         final ActionListener<ExportBulk> bulkListener = ActionListener.wrap(bulk -> {             assertThat(bulk.getName(), equalTo(exporterName())).             awaitResponseAndClose.countDown().         }, e -> fail(e.getMessage())).         exporter.openBulk(bulkListener).         // wait for it to actually respond         assertTrue(awaitResponseAndClose.await(15, TimeUnit.SECONDS)).     } }
false;public;0;27;;public void testHttpExporterShutdown() throws Exception {     final Config config = createConfig(Settings.EMPTY).     final RestClient client = mock(RestClient.class).     final Sniffer sniffer = randomFrom(mock(Sniffer.class), null).     final NodeFailureListener listener = mock(NodeFailureListener.class).     final MultiHttpResource resource = mock(MultiHttpResource.class).     if (sniffer != null && rarely()) {         doThrow(new RuntimeException("expected")).when(sniffer).close().     }     if (rarely()) {         doThrow(randomFrom(new IOException("expected"), new RuntimeException("expected"))).when(client).close().     }     new HttpExporter(config, client, sniffer, threadContext, listener, resource).close().     // order matters. sniffer must close first     if (sniffer != null) {         final InOrder inOrder = inOrder(sniffer, client).         inOrder.verify(sniffer).close().         inOrder.verify(client).close().     } else {         verify(client).close().     } }
false;private;2;9;;private void assertMasterTimeoutSet(final List<? extends HttpResource> resources, final TimeValue timeout) {     if (timeout != null) {         for (final HttpResource resource : resources) {             if (resource instanceof PublishableHttpResource) {                 assertEquals(timeout.getStringRep(), ((PublishableHttpResource) resource).getDefaultParameters().get("master_timeout")).             }         }     } }
true;private;1;3;/**  * Create the {@link Config} named "_http" and select those settings from {@code settings}.  *  * @param settings The settings to select the exporter's settings from  * @return Never {@code null}.  */ ;/**  * Create the {@link Config} named "_http" and select those settings from {@code settings}.  *  * @param settings The settings to select the exporter's settings from  * @return Never {@code null}.  */ private Config createConfig(final Settings settings) {     return new Config("_http", HttpExporter.TYPE, settings, clusterService, licenseState). }
false;private,static;0;3;;private static String exporterName() {     return "xpack.monitoring.exporters._http". }
