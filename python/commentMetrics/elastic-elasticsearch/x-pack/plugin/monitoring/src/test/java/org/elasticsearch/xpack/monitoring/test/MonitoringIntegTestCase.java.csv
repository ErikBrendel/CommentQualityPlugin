commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;15;;@Override protected Settings nodeSettings(int nodeOrdinal) {     Settings.Builder builder = Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(MonitoringService.INTERVAL.getKey(), MonitoringService.MIN_INTERVAL).put("index.store.mock.check_index_on_close", false).     return builder.build(). }
false;protected;0;7;;@Override protected Settings transportClientSettings() {     return Settings.builder().put(super.transportClientSettings()).put(XPackSettings.WATCHER_ENABLED.getKey(), false).build(). }
false;protected;0;7;;@Override protected Collection<Class<? extends Plugin>> getMockPlugins() {     Set<Class<? extends Plugin>> plugins = new HashSet<>(super.getMockPlugins()).     // security has its own transport service     plugins.remove(MockTransportService.TestPlugin.class).     plugins.add(MockFSIndexStore.TestPlugin.class).     return plugins. }
false;protected;0;5;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(LocalStateMonitoring.class, MockPainlessScriptEngine.TestPlugin.class, MockIngestPlugin.class, CommonAnalysisPlugin.class). }
false;protected;0;5;;@Override protected Collection<Class<? extends Plugin>> transportClientPlugins() {     return Arrays.asList(XPackClientPlugin.class, MockPainlessScriptEngine.TestPlugin.class, MockIngestPlugin.class, CommonAnalysisPlugin.class). }
false;protected;0;3;;protected MonitoringClient monitoringClient() {     return randomBoolean() ? new XPackClient(client()).monitoring() : new MonitoringClient(client()). }
false;protected;0;4;;@Override protected Set<String> excludeTemplates() {     return new HashSet<>(monitoringTemplateNames()). }
false;public;0;5;;@Before public void setUp() throws Exception {     super.setUp().     startMonitoringService(). }
false;public;0;5;;@After public void tearDown() throws Exception {     stopMonitoringService().     super.tearDown(). }
false;protected;0;3;;protected void startMonitoringService() {     internalCluster().getInstances(MonitoringService.class).forEach(MonitoringService::start). }
false;protected;0;3;;protected void stopMonitoringService() {     internalCluster().getInstances(MonitoringService.class).forEach(MonitoringService::stop). }
false;protected;0;17;;protected void wipeMonitoringIndices() throws Exception {     CountDown retries = new CountDown(3).     assertBusy(() -> {         try {             boolean exist = client().admin().indices().prepareExists(ALL_MONITORING_INDICES).get().isExists().             if (exist) {                 deleteMonitoringIndices().             } else {                 retries.countDown().             }         } catch (IndexNotFoundException e) {             retries.countDown().         }         assertThat(retries.isCountedDown(), is(true)).     }). }
false;protected;0;3;;protected void deleteMonitoringIndices() {     assertAcked(client().admin().indices().prepareDelete(ALL_MONITORING_INDICES)). }
false;protected;0;3;;protected void ensureMonitoringIndicesYellow() {     ensureYellowAndNoInitializingShards(".monitoring-es-*"). }
false;protected;0;5;;protected List<Tuple<String, String>> monitoringTemplates() {     return Arrays.stream(MonitoringTemplateUtils.TEMPLATE_IDS).map(id -> new Tuple<>(MonitoringTemplateUtils.templateName(id), MonitoringTemplateUtils.loadTemplate(id))).collect(Collectors.toList()). }
false;protected;0;5;;protected List<String> monitoringTemplateNames() {     return Arrays.stream(MonitoringTemplateUtils.TEMPLATE_IDS).map(MonitoringTemplateUtils::templateName).collect(Collectors.toList()). }
false;private;1;6;;private Tuple<String, String> monitoringPipeline(final String pipelineId) {     final XContentType json = XContentType.JSON.     return new Tuple<>(MonitoringTemplateUtils.pipelineName(pipelineId), Strings.toString(MonitoringTemplateUtils.loadPipeline(pipelineId, json))). }
false;protected;0;5;;protected List<Tuple<String, String>> monitoringPipelines() {     return Arrays.stream(MonitoringTemplateUtils.PIPELINE_IDS).map(this::monitoringPipeline).collect(Collectors.toList()). }
false;protected;0;5;;protected List<String> monitoringPipelineNames() {     return Arrays.stream(MonitoringTemplateUtils.PIPELINE_IDS).map(MonitoringTemplateUtils::pipelineName).collect(Collectors.toList()). }
false;protected;0;7;;protected List<Tuple<String, String>> monitoringWatches() {     final ClusterService clusterService = clusterService().     return Arrays.stream(ClusterAlertsUtil.WATCH_IDS).map(id -> new Tuple<>(id, ClusterAlertsUtil.loadWatch(clusterService, id))).collect(Collectors.toList()). }
false;protected;1;9;;protected void assertTemplateInstalled(String name) {     boolean found = false.     for (IndexTemplateMetaData template : client().admin().indices().prepareGetTemplates().get().getIndexTemplates()) {         if (Regex.simpleMatch(name, template.getName())) {             found = true.         }     }     assertTrue("failed to find a template matching [" + name + "]", found). }
false;protected;0;4;;protected void waitForMonitoringIndices() throws Exception {     awaitIndexExists(ALL_MONITORING_INDICES).     assertBusy(this::ensureMonitoringIndicesYellow). }
false;private;1;5;;private void awaitIndexExists(final String index) throws Exception {     assertBusy(() -> {         assertIndicesExists(index).     }, 30, TimeUnit.SECONDS). }
false;private;1;4;;private void assertIndicesExists(String... indices) {     logger.trace("checking if index exists [{}]", Strings.arrayToCommaDelimitedString(indices)).     assertThat(client().admin().indices().prepareExists(indices).get().isExists(), is(true)). }
false;protected;0;4;;protected void enableMonitoringCollection() {     assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put(MonitoringService.ENABLED.getKey(), true))). }
false;protected;0;4;;protected void disableMonitoringCollection() {     assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().putNull(MonitoringService.ENABLED.getKey()))). }
