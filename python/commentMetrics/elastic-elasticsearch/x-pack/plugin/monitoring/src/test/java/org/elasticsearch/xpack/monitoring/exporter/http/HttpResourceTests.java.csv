commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;4;;@Override protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {     listener.onResponse(false). }
false;public;0;8;;public void testConstructorRequiresOwner() {     expectThrows(NullPointerException.class, () -> new HttpResource(null) {          @Override         protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {             listener.onResponse(false).         }     }). }
false;protected;2;4;;@Override protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {     listener.onResponse(false). }
false;public;0;11;;public void testConstructor() {     final HttpResource resource = new HttpResource(owner) {          @Override         protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {             listener.onResponse(false).         }     }.     assertSame(owner, resource.resourceOwnerName).     assertTrue(resource.isDirty()). }
false;protected;2;4;;@Override protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {     listener.onResponse(false). }
false;public;0;12;;public void testConstructorDirtiness() {     final boolean dirty = randomBoolean().     final HttpResource resource = new HttpResource(owner, dirty) {          @Override         protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {             listener.onResponse(false).         }     }.     assertSame(owner, resource.resourceOwnerName).     assertEquals(dirty, resource.isDirty()). }
false;public;0;17;;public void testDirtiness() {     final ActionListener<Boolean> listener = mockBooleanActionListener().     // MockHttpResponse always succeeds for checkAndPublish     final HttpResource resource = new MockHttpResource(owner).     assertTrue(resource.isDirty()).     resource.markDirty().     assertTrue(resource.isDirty()).     // if this fails, then the mocked resource needs to be fixed     resource.checkAndPublish(client, listener).     verify(listener).onResponse(true).     assertFalse(resource.isDirty()). }
false;protected;2;4;;@Override protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {     listener.onResponse(expected). }
false;public;0;15;;public void testCheckAndPublish() {     final ActionListener<Boolean> listener = mockBooleanActionListener().     final boolean expected = randomBoolean().     // the default dirtiness should be irrelevant. it should always be run!     final HttpResource resource = new HttpResource(owner) {          @Override         protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {             listener.onResponse(expected).         }     }.     resource.checkAndPublish(client, listener).     verify(listener).onResponse(expected). }
false;protected;2;4;;@Override protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {     listener.onResponse(supplier.get()). }
false;public;0;23;;public void testCheckAndPublishEvenWhenDirty() {     final ActionListener<Boolean> listener1 = mockBooleanActionListener().     final ActionListener<Boolean> listener2 = mockBooleanActionListener().     @SuppressWarnings("unchecked")     final Supplier<Boolean> supplier = mock(Supplier.class).     when(supplier.get()).thenReturn(true, false).     final HttpResource resource = new HttpResource(owner) {          @Override         protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {             listener.onResponse(supplier.get()).         }     }.     assertTrue(resource.isDirty()).     resource.checkAndPublish(client, listener1).     verify(listener1).onResponse(true).     assertFalse(resource.isDirty()).     resource.checkAndPublish(client, listener2).     verify(listener2).onResponse(false).     verify(supplier, times(2)).get(). }
false;protected;2;16;;@Override protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {     // wait until the second check has had a chance to run to completion,     // then respond here     final Thread thread = new Thread(() -> {         try {             assertTrue(secondCheck.await(15, TimeUnit.SECONDS)).             listener.onResponse(response).         } catch (InterruptedException e) {             listener.onFailure(e).         }         firstCheck.countDown().     }).     thread.start(). }
false;public;0;47;;public void testCheckAndPublishIfDirtyFalseWhileChecking() throws InterruptedException {     final CountDownLatch firstCheck = new CountDownLatch(1).     final CountDownLatch secondCheck = new CountDownLatch(1).     final boolean response = randomBoolean().     final ActionListener<Boolean> listener = mockBooleanActionListener().     // listener used while checking is blocked, and thus should be ignored     final ActionListener<Boolean> checkingListener = ActionListener.wrap(success -> {         // busy checking, so this should be ignored         assertFalse(success).         secondCheck.countDown().     }, e -> {         fail(e.getMessage()).         secondCheck.countDown().     }).     // the default dirtiness should be irrelevant. it should always be run!     final HttpResource resource = new HttpResource(owner) {          @Override         protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {             // wait until the second check has had a chance to run to completion,             // then respond here             final Thread thread = new Thread(() -> {                 try {                     assertTrue(secondCheck.await(15, TimeUnit.SECONDS)).                     listener.onResponse(response).                 } catch (InterruptedException e) {                     listener.onFailure(e).                 }                 firstCheck.countDown().             }).             thread.start().         }     }.     resource.checkAndPublishIfDirty(client, listener).     resource.checkAndPublishIfDirty(client, checkingListener).     assertTrue(firstCheck.await(15, TimeUnit.SECONDS)).     verify(listener).onResponse(response). }
false;protected;2;4;;@Override protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {     listener.onResponse(supplier.get()). }
false;public;0;24;;public void testCheckAndPublishIfDirty() {     final ActionListener<Boolean> listener1 = mockBooleanActionListener().     final ActionListener<Boolean> listener2 = mockBooleanActionListener().     @SuppressWarnings("unchecked")     final Supplier<Boolean> supplier = mock(Supplier.class).     when(supplier.get()).thenReturn(true, false).     final HttpResource resource = new HttpResource(owner) {          @Override         protected void doCheckAndPublish(RestClient client, ActionListener<Boolean> listener) {             listener.onResponse(supplier.get()).         }     }.     assertTrue(resource.isDirty()).     resource.checkAndPublishIfDirty(client, listener1).     verify(listener1).onResponse(true).     assertFalse(resource.isDirty()).     resource.checkAndPublishIfDirty(client, listener2).     verify(listener2).onResponse(true).     // once is the default!     verify(supplier).get(). }
