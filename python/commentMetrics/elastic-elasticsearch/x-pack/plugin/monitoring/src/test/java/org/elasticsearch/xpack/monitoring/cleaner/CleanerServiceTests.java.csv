commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void start() {     clusterSettings = new ClusterSettings(Settings.EMPTY, Collections.singleton(MonitoringField.HISTORY_DURATION)).     threadPool = new TestThreadPool("CleanerServiceTests"). }
false;public;0;4;;@After public void stop() throws InterruptedException {     terminate(threadPool). }
false;public;0;9;;public void testConstructorWithInvalidRetention() {     // invalid setting     expectedException.expect(IllegalArgumentException.class).     TimeValue expected = TimeValue.timeValueHours(1).     Settings settings = Settings.builder().put(MonitoringField.HISTORY_DURATION.getKey(), expected.getStringRep()).build().     new CleanerService(settings, clusterSettings, threadPool, licenseState). }
false;public;0;10;;public void testGetRetentionWithSettingWithUpdatesAllowed() {     TimeValue expected = TimeValue.timeValueHours(25).     Settings settings = Settings.builder().put(MonitoringField.HISTORY_DURATION.getKey(), expected.getStringRep()).build().     when(licenseState.isUpdateRetentionAllowed()).thenReturn(true).     assertEquals(expected, new CleanerService(settings, clusterSettings, threadPool, licenseState).getRetention()).     verify(licenseState).isUpdateRetentionAllowed(). }
false;public;0;8;;public void testGetRetentionDefaultValueWithNoSettings() {     when(licenseState.isUpdateRetentionAllowed()).thenReturn(true).     assertEquals(MonitoringField.HISTORY_DURATION.get(Settings.EMPTY), new CleanerService(Settings.EMPTY, clusterSettings, threadPool, licenseState).getRetention()).     verify(licenseState).isUpdateRetentionAllowed(). }
false;public;0;11;;public void testGetRetentionDefaultValueWithSettingsButUpdatesNotAllowed() {     TimeValue notExpected = TimeValue.timeValueHours(25).     Settings settings = Settings.builder().put(MonitoringField.HISTORY_DURATION.getKey(), notExpected.getStringRep()).build().     when(licenseState.isUpdateRetentionAllowed()).thenReturn(false).     assertEquals(MonitoringField.HISTORY_DURATION.get(Settings.EMPTY), new CleanerService(settings, clusterSettings, threadPool, licenseState).getRetention()).     verify(licenseState).isUpdateRetentionAllowed(). }
false;public;0;15;;public void testSetGlobalRetention() {     // Note: I used this value to ensure we're not double-validating the setter. the cluster state should be the     // only thing calling this method and it will use the settings object to validate the time value     TimeValue expected = TimeValue.timeValueHours(2).     when(licenseState.isUpdateRetentionAllowed()).thenReturn(true).     CleanerService service = new CleanerService(Settings.EMPTY, clusterSettings, threadPool, licenseState).     service.setGlobalRetention(expected).     assertEquals(expected, service.getRetention()).     // once by set, once by get     verify(licenseState, times(2)).isUpdateRetentionAllowed(). }
false;public;0;18;;public void testSetGlobalRetentionAppliesEvenIfLicenseDisallows() {     // Note: I used this value to ensure we're not double-validating the setter. the cluster state should be the     // only thing calling this method and it will use the settings object to validate the time value     TimeValue expected = TimeValue.timeValueHours(2).     // required to be true on the second call for it to see it take effect     when(licenseState.isUpdateRetentionAllowed()).thenReturn(false).thenReturn(true).     CleanerService service = new CleanerService(Settings.EMPTY, clusterSettings, threadPool, licenseState).     // uses allow=false     service.setGlobalRetention(expected).     // uses allow=true     assertEquals(expected, service.getRetention()).     verify(licenseState, times(2)).isUpdateRetentionAllowed(). }
false;public;0;22;;public void testNextExecutionDelay() {     CleanerService.ExecutionScheduler scheduler = new CleanerService.DefaultExecutionScheduler().     ZonedDateTime now = ZonedDateTime.of(2015, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC).     assertThat(scheduler.nextExecutionDelay(now).millis(), equalTo(TimeValue.timeValueHours(1).millis())).     now = ZonedDateTime.of(2015, 1, 1, 1, 0, 0, 0, ZoneOffset.UTC).     assertThat(scheduler.nextExecutionDelay(now).millis(), equalTo(TimeValue.timeValueHours(24).millis())).     now = ZonedDateTime.of(2015, 1, 1, 0, 59, 0, 0, ZoneOffset.UTC).     assertThat(scheduler.nextExecutionDelay(now).millis(), equalTo(TimeValue.timeValueMinutes(1).millis())).     now = ZonedDateTime.of(2015, 1, 1, 23, 59, 0, 0, ZoneOffset.UTC).     assertThat(scheduler.nextExecutionDelay(now).millis(), equalTo(TimeValue.timeValueMinutes(60 + 1).millis())).     ZoneId defaultZone = Clock.systemDefaultZone().getZone().     now = ZonedDateTime.of(2015, 1, 1, 12, 34, 56, 0, defaultZone).     long nextScheduledMillis = ZonedDateTime.of(2015, 1, 2, 1, 0, 0, 0, defaultZone).toInstant().toEpochMilli().     assertThat(scheduler.nextExecutionDelay(now).millis(), equalTo(nextScheduledMillis - now.toInstant().toEpochMilli())). }
false;public;0;27;;public void testExecution() throws InterruptedException {     final int nbExecutions = randomIntBetween(1, 3).     CountDownLatch latch = new CountDownLatch(nbExecutions).     logger.debug("--> creates a cleaner service that cleans every second").     XPackLicenseState licenseState = mock(XPackLicenseState.class).     when(licenseState.isMonitoringAllowed()).thenReturn(true).     CleanerService service = new CleanerService(Settings.EMPTY, clusterSettings, licenseState, threadPool, new TestExecutionScheduler(1_000)).     logger.debug("--> registers cleaning listener").     TestListener listener = new TestListener(latch).     service.add(listener).     try {         logger.debug("--> starts cleaning service").         service.start().         logger.debug("--> waits for listener to be executed").         if (!latch.await(10, TimeUnit.SECONDS)) {             fail("waiting too long for test to complete. Expected listener was not executed").         }     } finally {         service.stop().     }     assertThat(latch.getCount(), equalTo(0L)). }
false;public;1;4;;@Override public void onCleanUpIndices(TimeValue retention) {     latch.countDown(). }
false;public;1;4;;@Override public TimeValue nextExecutionDelay(ZonedDateTime now) {     return TimeValue.timeValueMillis(offset). }
