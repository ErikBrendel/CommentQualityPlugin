commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;public void testCreateWhenResourcesNeedToBeAddedOrUpdated() throws Exception {     // sometimes they need to be added. sometimes they need to be replaced     if (randomBoolean()) {         putResources(oldVersion()).     }     assertResourcesExist(). }
false;public;0;9;;public void testCreateWhenResourcesShouldNotBeReplaced() throws Exception {     putResources(newEnoughVersion()).     assertResourcesExist().     // these were "newer" or at least the same version, so they shouldn't be replaced     assertTemplateNotUpdated().     assertPipelinesNotUpdated(). }
false;private;0;9;;private void createResources() throws Exception {     // wait until the cluster is ready (this is done at the "Exporters" level)     // this is not a busy assertion because it's checked earlier     assertThat(clusterService().state().version(), not(ClusterState.UNKNOWN_VERSION)).     try (LocalExporter exporter = createLocalExporter()) {         assertBusy(() -> assertThat(exporter.isExporterReady(), is(true))).     } }
true;private,static;2;27;/**  * Generates a basic template that loosely represents a monitoring template.  */ ;/**  * Generates a basic template that loosely represents a monitoring template.  */ private static BytesReference generateTemplateSource(final String name, final Integer version) throws IOException {     final XContentBuilder builder = jsonBuilder().startObject().     // this would totally break Monitoring UI, but the idea is that it's different from a real template and     // the version controls that. it also won't break indexing (just searching) so this test can use it blindly     builder.field("index_patterns", name).startObject("settings").field("index.number_of_shards", 1).field("index.number_of_replicas", 0).endObject().startObject("mappings").startObject("doc").startObject("_meta").field("test", true).endObject().field("enabled", false).endObject().endObject().     if (version != null) {         builder.field("version", version).     }     return BytesReference.bytes(builder.endObject()). }
false;private;1;6;;private void putResources(final Integer version) throws Exception {     waitNoPendingTasksOnAll().     putTemplate(version).     putPipelines(version). }
false;private;1;6;;private void putTemplate(final Integer version) throws Exception {     final String templateName = MonitoringTemplateUtils.templateName(system.getSystem()).     final BytesReference source = generateTemplateSource(templateName, version).     assertAcked(client().admin().indices().preparePutTemplate(templateName).setSource(source, XContentType.JSON).get()). }
false;private;1;5;;private void putPipelines(final Integer version) throws Exception {     for (final String pipelineId : MonitoringTemplateUtils.PIPELINE_IDS) {         putPipeline(MonitoringTemplateUtils.pipelineName(pipelineId), version).     } }
false;private;2;3;;private void putPipeline(final String pipelineName, final Integer version) throws Exception {     assertAcked(client().admin().cluster().preparePutPipeline(pipelineName, replaceablePipeline(version), XContentType.JSON).get()). }
true;private;1;22;/**  * Create a pipeline with nothing in it whose description is literally "test".  *  * @param version Version to add to the pipeline, if any  * @return Never {@code null}.  */ ;/**  * Create a pipeline with nothing in it whose description is literally "test".  *  * @param version Version to add to the pipeline, if any  * @return Never {@code null}.  */ private BytesReference replaceablePipeline(final Integer version) {     try {         final XContentBuilder builder = XContentBuilder.builder(XContentType.JSON.xContent()).         builder.startObject().         {             builder.startArray("processors").endArray().             // something we can quickly check to ensure we have/have not replaced it             builder.field("description", getTestName()).             // sometimes give it a version that should be overwritten (and sometimes don't give it a version at all)             if (version != null) {                 builder.field("version", version).             }         }         return BytesReference.bytes(builder.endObject()).     } catch (final IOException e) {         throw new RuntimeException("Failed to create pipeline", e).     } }
false;private;0;6;;private Integer oldVersion() {     final int minimumVersion = Math.min(ClusterAlertsUtil.LAST_UPDATED_VERSION, MonitoringTemplateUtils.LAST_UPDATED_VERSION).     // randomly supply an older version, or no version at all     return randomBoolean() ? minimumVersion - randomIntBetween(1, 100000) : null. }
false;private;0;6;;private int newEnoughVersion() {     final int maximumVersion = Math.max(ClusterAlertsUtil.LAST_UPDATED_VERSION, MonitoringTemplateUtils.LAST_UPDATED_VERSION).     // randomly supply a newer version or the expected version     return randomFrom(maximumVersion + randomIntBetween(1, 100000), maximumVersion). }
false;private;0;5;;private void assertTemplatesExist() {     for (String templateName : monitoringTemplateNames()) {         assertTemplateInstalled(templateName).     } }
false;private;0;8;;private void assertPipelinesExist() {     for (PipelineConfiguration pipeline : client().admin().cluster().prepareGetPipeline("xpack_monitoring_*").get().pipelines()) {         final Object description = pipeline.getConfigAsMap().get("description").         // this just ensures that it's set. not who set it         assertThat(description, notNullValue()).     } }
false;private;0;10;;private void assertResourcesExist() throws Exception {     createResources().     waitNoPendingTasksOnAll().     assertBusy(() -> {         assertTemplatesExist().         assertPipelinesExist().     }). }
false;private;0;10;;private void assertTemplateNotUpdated() {     final String name = MonitoringTemplateUtils.templateName(system.getSystem()).     for (IndexTemplateMetaData template : client().admin().indices().prepareGetTemplates(name).get().getIndexTemplates()) {         final String docMapping = template.getMappings().get("doc").toString().         assertThat(docMapping, notNullValue()).         assertThat(docMapping, containsString("test")).     } }
false;private;0;7;;private void assertPipelinesNotUpdated() {     for (PipelineConfiguration pipeline : client().admin().cluster().prepareGetPipeline("xpack_monitoring_*").get().pipelines()) {         final Object description = pipeline.getConfigAsMap().get("description").         assertThat(description, equalTo(getTestName())).     } }
