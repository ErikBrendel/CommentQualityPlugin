commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;public void testDoCheckIgnoresClientWhenNotElectedMaster() {     whenNotElectedMaster().     resource.doCheck(client, listener).     verify(listener).onResponse(true).     verifyZeroInteractions(client). }
false;public;0;7;;public void testDoCheckExistsFor404() {     whenElectedMaster().     // /_xpack returning a 404 means ES didn't handle the request properly and X-Pack doesn't exist     doCheckWithStatusCode(resource, "", "_xpack", notFoundCheckStatus(), GET_EXISTS, XPACK_DOES_NOT_EXIST, true). }
false;public;0;7;;public void testDoCheckExistsFor400() {     whenElectedMaster().     // /_xpack returning a 400 means X-Pack does not exist     doCheckWithStatusCode(resource, "", "_xpack", RestStatus.BAD_REQUEST, GET_EXISTS, XPACK_DOES_NOT_EXIST, true). }
false;public;0;23;;public void testDoCheckExistsAsElectedMaster() {     whenElectedMaster().     final String[] noWatcher = { "{}", "{\"features\":{\"watcher\":{\"available\":true,\"enabled\":false}}}", "{\"features\":{\"watcher\":{\"available\":false,\"enabled\":true}}}", "{\"features\":{\"watcher\":{\"available\":true}}}", "{\"features\":{\"watcher\":{\"enabled\":true}}}" }.     final String endpoint = "/_xpack".     // success only implies that it responded. it also needs to be available and enabled     final Response response = response("GET", endpoint, successfulCheckStatus()).     final HttpEntity responseEntity = new StringEntity(randomFrom(noWatcher), ContentType.APPLICATION_JSON).     when(response.getEntity()).thenReturn(responseEntity).     // returning EXISTS implies that we CANNOT use Watcher to avoid running the publish phase     doCheckWithStatusCode(resource, expectedParameters, endpoint, true, response).     verify(response).getEntity(). }
false;public;0;20;;public void testDoCheckDoesNotExist() {     whenElectedMaster().     final String[] hasWatcher = { "{\"features\":{\"watcher\":{\"available\":true,\"enabled\":true}}}", "{\"features\":{\"watcher\":{\"enabled\":true,\"available\":true}}}" }.     final String endpoint = "/_xpack".     // success only implies that it responded. it also needs to be available and enabled     final Response response = response("GET", endpoint, successfulCheckStatus()).     final HttpEntity responseEntity = new StringEntity(randomFrom(hasWatcher), ContentType.APPLICATION_JSON).     when(response.getEntity()).thenReturn(responseEntity).     // returning DOES_NOT_EXIST implies that we CAN use Watcher and need to run the publish phase     doCheckWithStatusCode(resource, expectedParameters, endpoint, false, response).     verify(response).getEntity(). }
false;public;0;19;;public void testDoCheckErrorWithDataException() {     whenElectedMaster().     final String[] errorWatcher = { // missing watcher object 'string'     "{\"features\":{}}", // missing features outer object     "{\"watcher\":{\"enabled\":true,\"available\":true}}", // extra {     "{{}" }.     final String endpoint = "/_xpack".     // success only implies that it responded. it also needs to be available and enabled     final Response response = response("GET", endpoint, successfulCheckStatus()).     final HttpEntity responseEntity = new StringEntity(randomFrom(errorWatcher), ContentType.APPLICATION_JSON).     when(response.getEntity()).thenReturn(responseEntity).     // returning an error implies that we CAN use Watcher and need to run the publish phase     doCheckWithStatusCode(resource, expectedParameters, endpoint, null, response). }
false;public;0;5;;public void testDoCheckErrorWithResponseException() {     whenElectedMaster().     assertCheckWithException(resource, expectedParameters, "", "_xpack"). }
false;public;0;14;;public void testDoPublishTrue() {     final boolean checkResponse = randomBoolean().     final boolean publish = checkResponse == false.     final MockHttpResource mockWatch = new MockHttpResource(owner, randomBoolean(), checkResponse, publish).     final MultiHttpResource watches = new MultiHttpResource(owner, Collections.singletonList(mockWatch)).     final WatcherExistsHttpResource resource = new WatcherExistsHttpResource(owner, clusterService, watches).     resource.doPublish(client, listener).     verifyListener(true).     assertThat(mockWatch.checked, is(1)).     assertThat(mockWatch.published, is(publish ? 1 : 0)). }
false;public;0;12;;public void testDoPublishFalse() {     final MockHttpResource mockWatch = new MockHttpResource(owner, true, false, false).     final MultiHttpResource watches = new MultiHttpResource(owner, Collections.singletonList(mockWatch)).     final WatcherExistsHttpResource resource = new WatcherExistsHttpResource(owner, clusterService, watches).     resource.doPublish(client, listener).     verifyListener(false).     assertThat(mockWatch.checked, is(1)).     assertThat(mockWatch.published, is(1)). }
false;public;0;12;;public void testDoPublishException() {     final MockHttpResource mockWatch = new MockHttpResource(owner, true, false, null).     final MultiHttpResource watches = new MultiHttpResource(owner, Collections.singletonList(mockWatch)).     final WatcherExistsHttpResource resource = new WatcherExistsHttpResource(owner, clusterService, watches).     resource.doPublish(client, listener).     verifyListener(null).     assertThat(mockWatch.checked, is(1)).     assertThat(mockWatch.published, is(1)). }
false;public;0;7;;public void testParameters() {     final Map<String, String> parameters = resource.getDefaultParameters().     assertThat(parameters.get("filter_path"), is(WatcherExistsHttpResource.WATCHER_CHECK_PARAMETERS.get("filter_path"))).     assertThat(parameters.size(), is(1)). }
false;public;0;3;;public void testGetResources() {     assertThat(resource.getWatches(), sameInstance(watches)). }
false;private;0;8;;private void whenElectedMaster() {     final ClusterState state = mock(ClusterState.class).     final DiscoveryNodes nodes = mock(DiscoveryNodes.class).     when(clusterService.state()).thenReturn(state).     when(state.nodes()).thenReturn(nodes).     when(nodes.isLocalNodeElectedMaster()).thenReturn(true). }
false;private;0;8;;private void whenNotElectedMaster() {     final ClusterState state = mock(ClusterState.class).     final DiscoveryNodes nodes = mock(DiscoveryNodes.class).     when(clusterService.state()).thenReturn(state).     when(state.nodes()).thenReturn(nodes).     when(nodes.isLocalNodeElectedMaster()).thenReturn(false). }
