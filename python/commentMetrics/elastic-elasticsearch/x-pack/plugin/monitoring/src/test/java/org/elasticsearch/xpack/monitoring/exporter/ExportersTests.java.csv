commented;modifiers;parameterAmount;loc;comment;code
false;public;0;25;;@Before public void init() {     factories = new HashMap<>().     Client client = mock(Client.class).     ThreadPool threadPool = mock(ThreadPool.class).     threadContext = new ThreadContext(Settings.EMPTY).     when(client.threadPool()).thenReturn(threadPool).     when(threadPool.getThreadContext()).thenReturn(threadContext).     clusterService = mock(ClusterService.class).     // default state.version() will be 0, which is "valid"     state = mock(ClusterState.class).     Set<Setting<?>> settingsSet = new HashSet<>(Exporters.getSettings()).     settingsSet.add(MonitoringService.INTERVAL).     clusterSettings = new ClusterSettings(Settings.EMPTY, settingsSet).     when(clusterService.getClusterSettings()).thenReturn(clusterSettings).     when(clusterService.state()).thenReturn(state).     when(state.blocks()).thenReturn(blocks).     when(state.metaData()).thenReturn(metadata).     // we always need to have the local exporter as it serves as the default one     factories.put(LocalExporter.TYPE, config -> new LocalExporter(config, client, mock(CleanerService.class))).     exporters = new Exporters(Settings.EMPTY, factories, clusterService, licenseState, threadContext). }
false;public;0;14;;public void testExporterIndexPattern() {     Exporter.Config config = mock(Exporter.Config.class).     when(config.name()).thenReturn("anything").     when(config.settings()).thenReturn(Settings.EMPTY).     DateFormatter formatter = Exporter.dateTimeFormatter(config).     Instant instant = Instant.ofEpochSecond(randomLongBetween(0, 86400 * 365 * 130L)).     ZonedDateTime zonedDateTime = instant.atZone(ZoneOffset.UTC).     int year = zonedDateTime.getYear().     int month = zonedDateTime.getMonthValue().     int day = zonedDateTime.getDayOfMonth().     String expecdateDate = String.format(Locale.ROOT, "%02d.%02d.%02d", year, month, day).     String formattedDate = formatter.format(instant).     assertThat("input date was " + instant, expecdateDate, is(formattedDate)). }
false;public;0;9;;public void testInitExportersDefault() throws Exception {     factories.put("_type", TestExporter::new).     Map<String, Exporter> internalExporters = exporters.initExporters(Settings.builder().build()).     assertThat(internalExporters, notNullValue()).     assertThat(internalExporters.size(), is(1)).     assertThat(internalExporters, hasKey("default_" + LocalExporter.TYPE)).     assertThat(internalExporters.get("default_" + LocalExporter.TYPE), instanceOf(LocalExporter.class)). }
false;public;0;12;;public void testInitExportersSingle() throws Exception {     factories.put("local", TestExporter::new).     Map<String, Exporter> internalExporters = exporters.initExporters(Settings.builder().put("xpack.monitoring.exporters._name.type", "local").build()).     assertThat(internalExporters, notNullValue()).     assertThat(internalExporters.size(), is(1)).     assertThat(internalExporters, hasKey("_name")).     assertThat(internalExporters.get("_name"), instanceOf(TestExporter.class)).     assertThat(internalExporters.get("_name").config().type(), is("local")). }
false;public;0;12;;public void testInitExportersSingleDisabled() throws Exception {     factories.put("local", TestExporter::new).     Map<String, Exporter> internalExporters = exporters.initExporters(Settings.builder().put("xpack.monitoring.exporters._name.type", "local").put("xpack.monitoring.exporters._name.enabled", false).build()).     assertThat(internalExporters, notNullValue()).     // the only configured exporter is disabled... yet we intentionally don't fallback on the default     assertThat(internalExporters.size(), is(0)). }
false;public;0;6;;public void testInitExportersSingleUnknownType() throws Exception {     SettingsException e = expectThrows(SettingsException.class, () -> exporters.initExporters(Settings.builder().put("xpack.monitoring.exporters._name.type", "unknown_type").build())).     assertThat(e.getMessage(), containsString("unknown exporter type [unknown_type]")). }
false;public;0;5;;public void testInitExportersSingleMissingExporterType() throws Exception {     SettingsException e = expectThrows(SettingsException.class, () -> exporters.initExporters(Settings.builder().put("xpack.monitoring.exporters._name.foo", "bar").build())).     assertThat(e.getMessage(), containsString("missing exporter type for [_name]")). }
false;public;0;16;;public void testInitExportersMultipleSameType() throws Exception {     factories.put("_type", TestExporter::new).     Map<String, Exporter> internalExporters = exporters.initExporters(Settings.builder().put("xpack.monitoring.exporters._name0.type", "_type").put("xpack.monitoring.exporters._name1.type", "_type").build()).     assertThat(internalExporters, notNullValue()).     assertThat(internalExporters.size(), is(2)).     assertThat(internalExporters, hasKey("_name0")).     assertThat(internalExporters.get("_name0"), instanceOf(TestExporter.class)).     assertThat(internalExporters.get("_name0").config().type(), is("_type")).     assertThat(internalExporters, hasKey("_name1")).     assertThat(internalExporters.get("_name1"), instanceOf(TestExporter.class)).     assertThat(internalExporters.get("_name1").config().type(), is("_type")). }
false;public;0;10;;public void testInitExportersMultipleSameTypeSingletons() throws Exception {     factories.put("local", TestSingletonExporter::new).     SettingsException e = expectThrows(SettingsException.class, () -> exporters.initExporters(Settings.builder().put("xpack.monitoring.exporters._name0.type", "local").put("xpack.monitoring.exporters._name1.type", "local").build())).     assertThat(e.getMessage(), containsString("multiple [local] exporters are configured. there can only be one")). }
false;;1;5;;@Override Map<String, Exporter> initExporters(Settings settings) {     settingsHolder.set(settings).     return super.initExporters(settings). }
false;public;0;42;;public void testSettingsUpdate() throws Exception {     factories.put("http", TestExporter::new).     factories.put("local", TestExporter::new).     final AtomicReference<Settings> settingsHolder = new AtomicReference<>().     Settings nodeSettings = Settings.builder().put("xpack.monitoring.exporters._name0.type", "local").put("xpack.monitoring.exporters._name1.type", "http").build().     clusterSettings = new ClusterSettings(nodeSettings, new HashSet<>(Exporters.getSettings())).     when(clusterService.getClusterSettings()).thenReturn(clusterSettings).     exporters = new Exporters(nodeSettings, factories, clusterService, licenseState, threadContext) {          @Override         Map<String, Exporter> initExporters(Settings settings) {             settingsHolder.set(settings).             return super.initExporters(settings).         }     }.     exporters.start().     assertThat(settingsHolder.get(), notNullValue()).     Settings settings = settingsHolder.get().     assertThat(settings.size(), is(2)).     assertEquals(settings.get("xpack.monitoring.exporters._name0.type"), "local").     assertEquals(settings.get("xpack.monitoring.exporters._name1.type"), "http").     Settings update = Settings.builder().put("xpack.monitoring.exporters._name0.use_ingest", true).put("xpack.monitoring.exporters._name1.use_ingest", false).build().     clusterSettings.applySettings(update).     assertThat(settingsHolder.get(), notNullValue()).     settings = settingsHolder.get().     logger.info(settings).     assertThat(settings.size(), is(4)).     assertEquals(settings.get("xpack.monitoring.exporters._name0.type"), "local").     assertEquals(settings.get("xpack.monitoring.exporters._name0.use_ingest"), "true").     assertEquals(settings.get("xpack.monitoring.exporters._name1.type"), "http").     assertEquals(settings.get("xpack.monitoring.exporters._name1.use_ingest"), "false"). }
false;public;0;26;;public void testExporterBlocksOnClusterState() {     if (rarely()) {         when(metadata.clusterUUID()).thenReturn(ClusterState.UNKNOWN_UUID).     } else if (rarely()) {         when(blocks.hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)).thenReturn(true).     } else {         when(state.version()).thenReturn(ClusterState.UNKNOWN_VERSION).     }     final int nbExporters = randomIntBetween(1, 5).     final Settings.Builder settings = Settings.builder().     for (int i = 0. i < nbExporters. i++) {         settings.put("xpack.monitoring.exporters._name" + String.valueOf(i) + ".type", "record").     }     final Exporters exporters = new Exporters(settings.build(), factories, clusterService, licenseState, threadContext).     // synchronously checks the cluster state     exporters.wrapExportBulk(ActionListener.wrap(bulk -> assertThat(bulk, is(nullValue())), e -> fail(e.getMessage()))).     verify(state).blocks(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     exceptions.add(e). }
false;protected;0;13;;@Override protected void doRun() throws Exception {     List<MonitoringDoc> docs = new ArrayList<>().     for (int n = 0. n < threadDocs. n++) {         docs.add(new TestMonitoringDoc(randomAlphaOfLength(5), randomNonNegativeLong(), randomNonNegativeLong(), null, MonitoredSystem.ES, randomAlphaOfLength(5), null, String.valueOf(n))).     }     barrier.await(10, TimeUnit.SECONDS).     exporters.export(docs, ActionListener.wrap(r -> logger.debug("--> thread [{}] successfully exported {} documents", threadNum, threadDocs), e -> logger.debug("--> thread [{}] failed to export {} documents", threadNum, threadDocs))). }
true;public;0;61;/**  * This test creates N threads that export a random number of document  * using a {@link Exporters} instance.  */ ;/**  * This test creates N threads that export a random number of document  * using a {@link Exporters} instance.  */ public void testConcurrentExports() throws Exception {     final int nbExporters = randomIntBetween(1, 5).     Settings.Builder settings = Settings.builder().     for (int i = 0. i < nbExporters. i++) {         settings.put("xpack.monitoring.exporters._name" + String.valueOf(i) + ".type", "record").     }     factories.put("record", (s) -> new CountingExporter(s, threadContext)).     Exporters exporters = new Exporters(settings.build(), factories, clusterService, licenseState, threadContext).     exporters.start().     final Thread[] threads = new Thread[3 + randomInt(7)].     final CyclicBarrier barrier = new CyclicBarrier(threads.length).     final List<Throwable> exceptions = new CopyOnWriteArrayList<>().     int total = 0.     for (int i = 0. i < threads.length. i++) {         int nbDocs = randomIntBetween(10, 50).         total += nbDocs.         final int threadNum = i.         final int threadDocs = nbDocs.         threads[i] = new Thread(new AbstractRunnable() {              @Override             public void onFailure(Exception e) {                 exceptions.add(e).             }              @Override             protected void doRun() throws Exception {                 List<MonitoringDoc> docs = new ArrayList<>().                 for (int n = 0. n < threadDocs. n++) {                     docs.add(new TestMonitoringDoc(randomAlphaOfLength(5), randomNonNegativeLong(), randomNonNegativeLong(), null, MonitoredSystem.ES, randomAlphaOfLength(5), null, String.valueOf(n))).                 }                 barrier.await(10, TimeUnit.SECONDS).                 exporters.export(docs, ActionListener.wrap(r -> logger.debug("--> thread [{}] successfully exported {} documents", threadNum, threadDocs), e -> logger.debug("--> thread [{}] failed to export {} documents", threadNum, threadDocs))).             }         }, "export_thread_" + i).         threads[i].start().     }     for (Thread thread : threads) {         thread.join().     }     assertThat(exceptions, empty()).     for (Exporter exporter : exporters.getEnabledExporters()) {         assertThat(exporter, instanceOf(CountingExporter.class)).         assertThat(((CountingExporter) exporter).getExportedCount(), equalTo(total)).     }     exporters.close(). }
false;public;1;4;;@Override public void openBulk(final ActionListener<ExportBulk> listener) {     listener.onResponse(mock(ExportBulk.class)). }
false;public;0;3;;@Override public void doClose() { }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;1;7;;@Override public void openBulk(final ActionListener<ExportBulk> listener) {     CountingBulk bulk = new CountingBulk(config.type() + "#" + count.getAndIncrement(), threadContext).     bulks.add(bulk).     listener.onResponse(bulk). }
false;public;0;3;;@Override public void doClose() { }
false;public;0;7;;public int getExportedCount() {     int exported = 0.     for (CountingBulk bulk : bulks) {         exported += bulk.getCount().     }     return exported. }
false;protected;1;4;;@Override protected void doAdd(Collection<MonitoringDoc> docs) throws ExportException {     count.addAndGet(docs.size()). }
false;protected;1;4;;@Override protected void doFlush(ActionListener<Void> listener) {     listener.onResponse(null). }
false;protected;1;4;;@Override protected void doClose(ActionListener<Void> listener) {     listener.onResponse(null). }
false;;0;3;;int getCount() {     return count.get(). }
false;protected;2;4;;@Override protected void innerToXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("test", value). }
