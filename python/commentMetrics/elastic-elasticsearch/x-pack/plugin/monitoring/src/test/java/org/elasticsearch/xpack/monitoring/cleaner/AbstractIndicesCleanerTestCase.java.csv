commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public void testNothingToDelete() throws Exception {     internalCluster().startNode().     CleanerService.Listener listener = getListener().     listener.onCleanUpIndices(days(0)).     assertIndicesCount(0). }
false;public;0;10;;public void testDeleteIndex() throws Exception {     internalCluster().startNode().     createTimestampedIndex(now().minusDays(10)).     assertIndicesCount(1).     CleanerService.Listener listener = getListener().     listener.onCleanUpIndices(days(10)).     assertIndicesCount(0). }
false;public;0;15;;public void testIgnoreCurrentAlertsIndex() throws Exception {     internalCluster().startNode().     // Will be deleted     createTimestampedIndex(now().minusDays(10)).     // Won't be deleted     createAlertsIndex(now().minusYears(1)).     assertIndicesCount(2).     CleanerService.Listener listener = getListener().     listener.onCleanUpIndices(days(0)).     assertIndicesCount(1). }
false;public;0;24;;public void testDoesNotIgnoreIndicesInOtherVersions() throws Exception {     internalCluster().startNode().     // Will be deleted     createTimestampedIndex(now().minusDays(10)).     createIndex(".monitoring-data-2", now().minusDays(10)).     createAlertsIndex(now().minusYears(1), MonitoringTemplateUtils.OLD_TEMPLATE_VERSION).     createTimestampedIndex(now().minusDays(10), "0").     createTimestampedIndex(now().minusDays(10), "1").     createTimestampedIndex(now().minusYears(1), MonitoringTemplateUtils.OLD_TEMPLATE_VERSION).     // In the past, this index would not be deleted, but starting in 6.x the monitoring cluster     // will be required to be a newer template version than the production cluster, so the index     // pushed to it will never be "unknown" in terms of their version     createTimestampedIndex(now().minusDays(10), String.valueOf(Integer.MAX_VALUE)).     // Won't be deleted     createAlertsIndex(now().minusYears(1)).     assertIndicesCount(8).     CleanerService.Listener listener = getListener().     listener.onCleanUpIndices(days(0)).     assertIndicesCount(1). }
false;public;0;15;;public void testIgnoreCurrentTimestampedIndex() throws Exception {     internalCluster().startNode().     // Will be deleted     createTimestampedIndex(now().minusDays(10)).     // Won't be deleted     createTimestampedIndex(now()).     assertIndicesCount(2).     CleanerService.Listener listener = getListener().     listener.onCleanUpIndices(days(0)).     assertIndicesCount(1). }
false;public;0;37;;public void testDeleteIndices() throws Exception {     internalCluster().startNode().     CleanerService.Listener listener = getListener().     final ZonedDateTime now = now().     createTimestampedIndex(now.minusYears(1)).     createTimestampedIndex(now.minusMonths(6)).     createTimestampedIndex(now.minusMonths(1)).     createTimestampedIndex(now.minusDays(10)).     createTimestampedIndex(now.minusDays(1)).     assertIndicesCount(5).     // Clean indices that have expired two years ago     listener.onCleanUpIndices(years(2)).     assertIndicesCount(5).     // Clean indices that have expired 8 months ago     listener.onCleanUpIndices(months(8)).     assertIndicesCount(4).     // Clean indices that have expired 3 months ago     listener.onCleanUpIndices(months(3)).     assertIndicesCount(3).     // Clean indices that have expired 15 days ago     listener.onCleanUpIndices(days(15)).     assertIndicesCount(2).     // Clean indices that have expired 7 days ago     listener.onCleanUpIndices(days(7)).     assertIndicesCount(1).     // Clean indices until now     listener.onCleanUpIndices(days(0)).     assertIndicesCount(0). }
false;public;0;17;;public void testRetentionAsGlobalSetting() throws Exception {     final int max = 10.     final int retention = randomIntBetween(1, max).     internalCluster().startNode(Settings.builder().put(MonitoringField.HISTORY_DURATION.getKey(), String.format(Locale.ROOT, "%dd", retention))).     final ZonedDateTime now = now().     for (int i = 0. i < max. i++) {         createTimestampedIndex(now.minusDays(i)).     }     assertIndicesCount(max).     // Clean indices that have expired for N days, as specified in the global retention setting     CleanerService.Listener listener = getListener().     listener.onCleanUpIndices(days(retention)).     assertIndicesCount(retention). }
false;protected;0;9;;protected CleanerService.Listener getListener() {     Exporters exporters = internalCluster().getInstance(Exporters.class, internalCluster().getMasterName()).     for (Exporter exporter : exporters.getEnabledExporters()) {         if (exporter instanceof CleanerService.Listener) {             return (CleanerService.Listener) exporter.         }     }     throw new IllegalStateException("unable to find listener"). }
true;protected;1;3;/**  * Creates a monitoring alerts index from the current version.  */ ;/**  * Creates a monitoring alerts index from the current version.  */ protected void createAlertsIndex(final ZonedDateTime creationDate) {     createAlertsIndex(creationDate, MonitoringTemplateUtils.TEMPLATE_VERSION). }
true;protected;2;3;/**  * Creates a monitoring alerts index from the specified version.  */ ;/**  * Creates a monitoring alerts index from the specified version.  */ protected void createAlertsIndex(final ZonedDateTime creationDate, final String version) {     createIndex(".monitoring-alerts-" + version, creationDate). }
true;protected;1;6;/**  * Creates a watcher history index from the current version.  */ ;/**  * Creates a watcher history index from the current version.  */ protected void createWatcherHistoryIndex(final ZonedDateTime creationDate) {     if (INDEX_TEMPLATE_VERSION == null) {         INDEX_TEMPLATE_VERSION = randomIntBetween(1, 20).     }     createWatcherHistoryIndex(creationDate, String.valueOf(INDEX_TEMPLATE_VERSION)). }
true;protected;2;5;/**  * Creates a watcher history index from the specified version.  */ ;/**  * Creates a watcher history index from the specified version.  */ protected void createWatcherHistoryIndex(final ZonedDateTime creationDate, final String version) {     final String index = ".watcher-history-" + version + "-" + DATE_FORMATTER.format(creationDate).     createIndex(index, creationDate). }
true;protected;1;3;/**  * Creates a monitoring timestamped index using the current template version.  */ ;/**  * Creates a monitoring timestamped index using the current template version.  */ protected void createTimestampedIndex(ZonedDateTime creationDate) {     createTimestampedIndex(creationDate, MonitoringTemplateUtils.TEMPLATE_VERSION). }
true;protected;2;4;/**  * Creates a monitoring timestamped index using a given template version.  */ ;/**  * Creates a monitoring timestamped index using a given template version.  */ protected void createTimestampedIndex(ZonedDateTime creationDate, String version) {     final String index = ".monitoring-es-" + version + "-" + DATE_FORMATTER.format(creationDate).     createIndex(index, creationDate). }
false;protected,abstract;2;1;;protected abstract void createIndex(String name, ZonedDateTime creationDate).
false;protected,abstract;1;1;;protected abstract void assertIndicesCount(int count) throws Exception.
false;protected,static;1;4;;protected static TimeValue years(int years) {     ZonedDateTime now = now().     return TimeValue.timeValueMillis(now.toInstant().toEpochMilli() - now.minusYears(years).toInstant().toEpochMilli()). }
false;protected,static;1;4;;protected static TimeValue months(int months) {     ZonedDateTime now = now().     return TimeValue.timeValueMillis(now.toInstant().toEpochMilli() - now.minusMonths(months).toInstant().toEpochMilli()). }
false;protected,static;1;3;;protected static TimeValue days(int days) {     return TimeValue.timeValueHours(days * 24). }
false;protected,static;0;3;;protected static ZonedDateTime now() {     return ZonedDateTime.now(ZoneOffset.UTC). }
