commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public void testIsWatchDefined() {     final ClusterAlertHttpResource noWatchResource = new ClusterAlertHttpResource(owner, licenseState, () -> watchId, null).     assertThat(noWatchResource.isWatchDefined(), is(false)).     assertThat(resource.isWatchDefined(), is(true)). }
false;public;0;15;;public void testWatchToHttpEntity() throws IOException {     final byte[] watchValueBytes = watchValue.getBytes(ContentType.APPLICATION_JSON.getCharset()).     final byte[] actualBytes = new byte[watchValueBytes.length].     final HttpEntity entity = resource.watchToHttpEntity().     assertThat(entity.getContentType().getValue(), is(ContentType.APPLICATION_JSON.toString())).     final InputStream byteStream = entity.getContent().     assertThat(byteStream.available(), is(watchValueBytes.length)).     assertThat(byteStream.read(actualBytes), is(watchValueBytes.length)).     assertArrayEquals(watchValueBytes, actualBytes).     assertThat(byteStream.available(), is(0)). }
false;public;0;7;;public void testDoCheckGetWatchExists() throws IOException {     when(licenseState.isMonitoringClusterAlertsAllowed()).thenReturn(true).     final HttpEntity entity = entityForClusterAlert(true, minimumVersion).     doCheckWithStatusCode(resource, "/_watcher/watch", watchId, successfulCheckStatus(), true, entity). }
false;public;0;13;;public void testDoCheckGetWatchDoesNotExist() throws IOException {     when(licenseState.isMonitoringClusterAlertsAllowed()).thenReturn(true).     if (randomBoolean()) {         // it does not exist because it's literally not there         assertCheckDoesNotExist(resource, "/_watcher/watch", watchId).     } else {         // it does not exist because we need to replace it         final HttpEntity entity = entityForClusterAlert(false, minimumVersion).         doCheckWithStatusCode(resource, "/_watcher/watch", watchId, successfulCheckStatus(), false, entity).     } }
false;public;0;13;;public void testDoCheckWithExceptionGetWatchError() throws IOException {     when(licenseState.isMonitoringClusterAlertsAllowed()).thenReturn(true).     if (randomBoolean()) {         // error because of a server error         assertCheckWithException(resource, "/_watcher/watch", watchId).     } else {         // error because of a malformed response         final HttpEntity entity = entityForClusterAlert(null, minimumVersion).         doCheckWithStatusCode(resource, "/_watcher/watch", watchId, successfulCheckStatus(), null, entity).     } }
false;public;0;9;;public void testDoCheckAsDeleteWatchExistsWhenNoWatchIsSpecified() throws IOException {     final ClusterAlertHttpResource noWatchResource = new ClusterAlertHttpResource(owner, licenseState, () -> watchId, null).     final boolean clusterAlertsAllowed = randomBoolean().     // should not matter     when(licenseState.isMonitoringClusterAlertsAllowed()).thenReturn(clusterAlertsAllowed).     assertCheckAsDeleteExists(noWatchResource, "/_watcher/watch", watchId). }
false;public;0;9;;public void testDoCheckWithExceptionAsDeleteWatchErrorWhenNoWatchIsSpecified() throws IOException {     final ClusterAlertHttpResource noWatchResource = new ClusterAlertHttpResource(owner, licenseState, () -> watchId, null).     final boolean clusterAlertsAllowed = randomBoolean().     // should not matter     when(licenseState.isMonitoringClusterAlertsAllowed()).thenReturn(clusterAlertsAllowed).     assertCheckAsDeleteWithException(noWatchResource, "/_watcher/watch", watchId). }
false;public;0;5;;public void testDoCheckAsDeleteWatchExists() throws IOException {     when(licenseState.isMonitoringClusterAlertsAllowed()).thenReturn(false).     assertCheckAsDeleteExists(resource, "/_watcher/watch", watchId). }
false;public;0;5;;public void testDoCheckWithExceptionAsDeleteWatchError() throws IOException {     when(licenseState.isMonitoringClusterAlertsAllowed()).thenReturn(false).     assertCheckAsDeleteWithException(resource, "/_watcher/watch", watchId). }
false;public;0;3;;public void testDoPublishTrue() throws IOException {     assertPublishSucceeds(resource, "/_watcher/watch", watchId, Collections.emptyMap(), StringEntity.class). }
false;public;0;3;;public void testDoPublishFalseWithException() throws IOException {     assertPublishWithException(resource, "/_watcher/watch", watchId, Collections.emptyMap(), StringEntity.class). }
false;public;0;10;;public void testShouldReplaceClusterAlertRethrowsIOException() throws IOException {     final Response response = mock(Response.class).     final HttpEntity entity = mock(HttpEntity.class).     final XContent xContent = mock(XContent.class).     when(response.getEntity()).thenReturn(entity).     when(entity.getContent()).thenThrow(new IOException("TEST - expected")).     expectThrows(IOException.class, () -> resource.shouldReplaceClusterAlert(response, xContent, randomInt())). }
false;public;0;9;;public void testShouldReplaceClusterAlertThrowsExceptionForMalformedResponse() {     final Response response = mock(Response.class).     final HttpEntity entity = entityForClusterAlert(null, randomInt()).     final XContent xContent = XContentType.JSON.xContent().     when(response.getEntity()).thenReturn(entity).     expectThrows(RuntimeException.class, () -> resource.shouldReplaceClusterAlert(response, xContent, randomInt())). }
false;public;0;10;;public void testShouldReplaceClusterAlertReturnsTrueVersionIsNotExpected() throws IOException {     final int minimumVersion = randomInt().     final Response response = mock(Response.class).     final HttpEntity entity = entityForClusterAlert(false, minimumVersion).     final XContent xContent = XContentType.JSON.xContent().     when(response.getEntity()).thenReturn(entity).     assertThat(resource.shouldReplaceClusterAlert(response, xContent, minimumVersion), is(true)). }
false;public;0;13;;public void testShouldReplaceCheckAlertChecksVersion() throws IOException {     final int minimumVersion = randomInt().     final int version = randomInt().     final boolean shouldReplace = version < minimumVersion.     final Response response = mock(Response.class).     final HttpEntity entity = entityForClusterAlert(true, version).     final XContent xContent = XContentType.JSON.xContent().     when(response.getEntity()).thenReturn(entity).     assertThat(resource.shouldReplaceClusterAlert(response, xContent, minimumVersion), is(shouldReplace)). }
false;public;0;6;;public void testParameters() {     final Map<String, String> parameters = new HashMap<>(resource.getDefaultParameters()).     assertThat(parameters.remove("filter_path"), is("metadata.xpack.version_created")).     assertThat(parameters.isEmpty(), is(true)). }
