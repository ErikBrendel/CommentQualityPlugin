commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setup() {     when(clusterService.state()).thenReturn(clusterState).     when(clusterState.metaData()).thenReturn(metaData).     when(metaData.clusterUUID()).thenReturn(clusterUuid). }
false;public;0;5;;public void testWatchIdsAreAllUnique() {     final List<String> watchIds = Arrays.asList(ClusterAlertsUtil.WATCH_IDS).     assertThat(watchIds, hasSize(new HashSet<>(watchIds).size())). }
false;public;0;7;;public void testCreateUniqueWatchId() {     final String watchId = randomFrom(ClusterAlertsUtil.WATCH_IDS).     final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService, watchId).     assertThat(uniqueWatchId, equalTo(clusterUuid + "_" + watchId)). }
false;public;0;16;;public void testLoadWatch() {     for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {         final String watch = ClusterAlertsUtil.loadWatch(clusterService, watchId).         assertThat(watch, notNullValue()).         assertThat(watch, containsString(clusterUuid)).         assertThat(watch, containsString(watchId)).         if ("elasticsearch_nodes".equals(watchId) == false) {             assertThat(watch, containsString(clusterUuid + "_" + watchId)).         }         // validate that it's well formed JSON         assertThat(XContentHelper.convertToMap(XContentType.JSON.xContent(), watch, false), notNullValue()).     } }
false;public;0;3;;public void testLoadWatchFails() {     expectThrows(RuntimeException.class, () -> ClusterAlertsUtil.loadWatch(clusterService, "watch-does-not-exist")). }
false;public;0;25;;public void testGetClusterAlertsBlacklistThrowsForUnknownWatchId() {     final List<String> watchIds = Arrays.asList(ClusterAlertsUtil.WATCH_IDS).     final List<String> blacklist = randomSubsetOf(watchIds).     blacklist.add("fake1").     if (randomBoolean()) {         blacklist.add("fake2").         if (rarely()) {             blacklist.add("fake3").         }     }     final Set<String> unknownIds = blacklist.stream().filter(id -> watchIds.contains(id) == false).collect(Collectors.toSet()).     final String unknownIdsString = String.join(", ", unknownIds).     final SettingsException exception = expectThrows(SettingsException.class, () -> ClusterAlertsUtil.getClusterAlertsBlacklist(createConfigWithBlacklist("_random", blacklist))).     assertThat(exception.getMessage(), equalTo("[xpack.monitoring.exporters._random.cluster_alerts.management.blacklist] contains unrecognized Cluster " + "Alert IDs [" + unknownIdsString + "]")). }
false;public;0;5;;public void testGetClusterAlertsBlacklist() {     final List<String> blacklist = randomSubsetOf(Arrays.asList(ClusterAlertsUtil.WATCH_IDS)).     assertThat(blacklist, equalTo(ClusterAlertsUtil.getClusterAlertsBlacklist(createConfigWithBlacklist("any", blacklist)))). }
false;private;2;9;;private Exporter.Config createConfigWithBlacklist(final String name, final List<String> blacklist) {     final Settings settings = Settings.builder().putList("xpack.monitoring.exporters." + name + ".cluster_alerts.management.blacklist", blacklist).build().     final ClusterService clusterService = mock(ClusterService.class).     final XPackLicenseState licenseState = mock(XPackLicenseState.class).     return new Exporter.Config(name, "local", settings, clusterService, licenseState). }
