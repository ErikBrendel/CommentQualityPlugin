commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void startWebServer() throws IOException {     webServer = createMockWebServer(). }
false;public;0;6;;@After public void stopWebServer() {     if (webServer != null) {         webServer.close().     } }
false;protected;0;4;;@Override protected boolean ignoreExternalCluster() {     return true. }
false;protected;1;12;;@Override protected Settings nodeSettings(int nodeOrdinal) {     // we make an exporter on demand per test     return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put("xpack.monitoring.exporters._http.type", "http").put("xpack.monitoring.exporters._http.ssl.truststore.password", // ensure that ssl can be used by settings     "foobar").put("xpack.monitoring.exporters._http.headers.ignored", // ensure that headers can be used by settings     "value").put("xpack.monitoring.exporters._http.enabled", false).build(). }
false;private;0;7;;private Settings.Builder baseSettings() {     return Settings.builder().put("xpack.monitoring.exporters._http.type", "http").put("xpack.monitoring.exporters._http.host", getFormattedAddress(webServer)).putList("xpack.monitoring.exporters._http.cluster_alerts.management.blacklist", clusterAlertBlacklist).put("xpack.monitoring.exporters._http.index.template.create_legacy_templates", includeOldTemplates). }
false;public;0;17;;public void testExport() throws Exception {     final Settings settings = baseSettings().build().     enqueueGetClusterVersionResponse(Version.CURRENT).     enqueueSetupResponses(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists).     enqueueResponse(200, "{\"errors\": false, \"msg\": \"successful bulk request\"}").     final int nbDocs = randomIntBetween(1, 25).     export(settings, newRandomMonitoringDocs(nbDocs)).     assertMonitorResources(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists).     assertBulk(webServer, nbDocs). }
false;public;0;31;;public void testExportWithHeaders() throws Exception {     final String headerValue = randomAlphaOfLengthBetween(3, 9).     final String[] array = generateRandomStringArray(2, 4, false, false).     final Map<String, String[]> headers = new HashMap<>().     headers.put("X-Cloud-Cluster", new String[] { headerValue }).     headers.put("X-Found-Cluster", new String[] { headerValue }).     headers.put("Array-Check", array).     final Settings settings = baseSettings().put("xpack.monitoring.exporters._http.headers.X-Cloud-Cluster", headerValue).put("xpack.monitoring.exporters._http.headers.X-Found-Cluster", headerValue).putList("xpack.monitoring.exporters._http.headers.Array-Check", array).build().     enqueueGetClusterVersionResponse(Version.CURRENT).     enqueueSetupResponses(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists).     enqueueResponse(200, "{\"errors\": false, \"msg\": \"successful bulk request\"}").     final int nbDocs = randomIntBetween(1, 25).     export(settings, newRandomMonitoringDocs(nbDocs)).     assertMonitorResources(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists, headers, null).     assertBulk(webServer, nbDocs, headers, null). }
false;public;0;52;;public void testExportWithBasePath() throws Exception {     final boolean useHeaders = randomBoolean().     final String headerValue = randomAlphaOfLengthBetween(3, 9).     final String[] array = generateRandomStringArray(2, 4, false, false).     final Map<String, String[]> headers = new HashMap<>().     if (useHeaders) {         headers.put("X-Cloud-Cluster", new String[] { headerValue }).         headers.put("X-Found-Cluster", new String[] { headerValue }).         headers.put("Array-Check", array).     }     String basePath = "path/to".     if (randomBoolean()) {         basePath += "/something".         if (rarely()) {             basePath += "/proxied".         }     }     if (randomBoolean()) {         basePath = "/" + basePath.     }     final Settings.Builder builder = baseSettings().put("xpack.monitoring.exporters._http.proxy.base_path", basePath + (randomBoolean() ? "/" : "")).     if (useHeaders) {         builder.put("xpack.monitoring.exporters._http.headers.X-Cloud-Cluster", headerValue).put("xpack.monitoring.exporters._http.headers.X-Found-Cluster", headerValue).putList("xpack.monitoring.exporters._http.headers.Array-Check", array).     }     enqueueGetClusterVersionResponse(Version.CURRENT).     enqueueSetupResponses(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists).     enqueueResponse(200, "{\"errors\": false}").     final int nbDocs = randomIntBetween(1, 25).     export(builder.build(), newRandomMonitoringDocs(nbDocs)).     assertMonitorResources(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists, headers, basePath).     assertBulk(webServer, nbDocs, headers, basePath). }
false;public;0;68;;public void testHostChangeReChecksTemplate() throws Exception {     final Settings settings = baseSettings().build().     enqueueGetClusterVersionResponse(Version.CURRENT).     enqueueSetupResponses(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists).     enqueueResponse(200, "{\"errors\": false}").     export(settings, Collections.singletonList(newRandomMonitoringDoc())).     assertMonitorResources(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists).     assertBulk(webServer).     try (MockWebServer secondWebServer = createMockWebServer()) {         String missingTemplate = null.         final Settings newSettings = Settings.builder().put(settings).putList("xpack.monitoring.exporters._http.host", getFormattedAddress(secondWebServer)).build().         enqueueGetClusterVersionResponse(secondWebServer, Version.CURRENT).         // pretend that one of the templates is missing         for (Tuple<String, String> template : monitoringTemplates(includeOldTemplates)) {             if (missingTemplate != null) {                 enqueueResponse(secondWebServer, 200, "{\"" + template.v1() + "\":{\"version\":" + LAST_UPDATED_VERSION + "}}").             } else {                 missingTemplate = template.v1().                 enqueueResponse(secondWebServer, 404, "template [" + template.v1() + "] does not exist").                 enqueueResponse(secondWebServer, 201, "template [" + template.v1() + "] created").             }         }         // opposite of if it existed before         enqueuePipelineResponses(secondWebServer, !pipelineExistsAlready).         enqueueWatcherResponses(secondWebServer, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists).         enqueueResponse(secondWebServer, 200, "{\"errors\": false}").         // second event         export(newSettings, Collections.singletonList(newRandomMonitoringDoc())).         assertMonitorVersion(secondWebServer).         String resourcePrefix = "/_template/".         for (Tuple<String, String> template : monitoringTemplates(includeOldTemplates)) {             MockRequest recordedRequest = secondWebServer.takeRequest().             assertThat(recordedRequest.getMethod(), equalTo("GET")).             assertThat(recordedRequest.getUri().getPath(), equalTo(resourcePrefix + template.v1())).             assertMonitorVersionQueryString(recordedRequest.getUri().getQuery(), Collections.emptyMap()).             if (missingTemplate.equals(template.v1())) {                 recordedRequest = secondWebServer.takeRequest().                 assertThat(recordedRequest.getMethod(), equalTo("PUT")).                 assertThat(recordedRequest.getUri().getPath(), equalTo(resourcePrefix + template.v1())).                 final Map<String, String> parameters = Collections.singletonMap(INCLUDE_TYPE_NAME_PARAMETER, "true").                 assertMonitorVersionQueryString(recordedRequest.getUri().getQuery(), parameters).                 assertThat(recordedRequest.getBody(), equalTo(template.v2())).             }         }         assertMonitorPipelines(secondWebServer, !pipelineExistsAlready, null, null).         assertMonitorWatches(secondWebServer, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists, null, null).         assertBulk(secondWebServer).     } }
false;public;0;38;;public void testUnsupportedClusterVersion() throws Exception {     final Settings settings = Settings.builder().put("xpack.monitoring.exporters._http.type", "http").put("xpack.monitoring.exporters._http.host", getFormattedAddress(webServer)).build().     // returning an unsupported cluster version     enqueueGetClusterVersionResponse(randomFrom(Version.fromString("0.18.0"), Version.fromString("1.0.0"), Version.fromString("1.4.0"), Version.fromString("2.4.0"), Version.fromString("5.0.0"), Version.fromString("5.4.0"))).     // ensure that the exporter is not able to be used     try (HttpExporter exporter = createHttpExporter(settings)) {         final CountDownLatch awaitResponseAndClose = new CountDownLatch(1).         final ActionListener<ExportBulk> listener = ActionListener.wrap(bulk -> {             assertNull(bulk).             awaitResponseAndClose.countDown().         }, e -> fail(e.getMessage())).         exporter.openBulk(listener).         // wait for it to actually respond         assertTrue(awaitResponseAndClose.await(15, TimeUnit.SECONDS)).     }     assertThat(webServer.requests(), hasSize(1)).     assertMonitorVersion(webServer). }
false;public;0;56;;public void testDynamicIndexFormatChange() throws Exception {     final Settings settings = baseSettings().build().     enqueueGetClusterVersionResponse(Version.CURRENT).     enqueueSetupResponses(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists).     enqueueResponse(200, "{\"errors\": false, \"msg\": \"successful bulk request\"}").     MonitoringDoc doc = newRandomMonitoringDoc().     export(settings, Collections.singletonList(doc)).     assertMonitorResources(webServer, templatesExistsAlready, includeOldTemplates, pipelineExistsAlready, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists).     MockRequest recordedRequest = assertBulk(webServer).     DateFormatter formatter = DateFormatter.forPattern("yyyy.MM.dd").withZone(ZoneOffset.UTC).     String indexName = indexName(formatter, doc.getSystem(), doc.getTimestamp()).     byte[] bytes = recordedRequest.getBody().getBytes(StandardCharsets.UTF_8).     Map<String, Object> data = XContentHelper.convertToMap(new BytesArray(bytes), false, XContentType.JSON).v2().     @SuppressWarnings("unchecked")     Map<String, Object> index = (Map<String, Object>) data.get("index").     assertThat(index.get("_index"), equalTo(indexName)).     String newTimeFormat = randomFrom("yy", "yyyy", "yyyy.MM", "yyyy-MM", "MM.yyyy", "MM").     final Settings newSettings = Settings.builder().put(settings).put("xpack.monitoring.exporters._http.index.name.time_format", newTimeFormat).build().     enqueueGetClusterVersionResponse(Version.CURRENT).     enqueueSetupResponses(webServer, true, includeOldTemplates, true, true, true, true).     enqueueResponse(200, "{\"errors\": false, \"msg\": \"successful bulk request\"}").     doc = newRandomMonitoringDoc().     export(newSettings, Collections.singletonList(doc)).     DateFormatter newTimeFormatter = DateFormatter.forPattern(newTimeFormat).withZone(ZoneOffset.UTC).     String expectedMonitoringIndex = ".monitoring-es-" + TEMPLATE_VERSION + "-" + newTimeFormatter.format(Instant.ofEpochMilli(doc.getTimestamp())).     assertMonitorResources(webServer, true, includeOldTemplates, true, true, true, true).     recordedRequest = assertBulk(webServer).     bytes = recordedRequest.getBody().getBytes(StandardCharsets.UTF_8).     data = XContentHelper.convertToMap(new BytesArray(bytes), false, XContentType.JSON).v2().     @SuppressWarnings("unchecked")     final Map<String, Object> newIndex = (Map<String, Object>) data.get("index").     assertThat(newIndex.get("_index"), equalTo(expectedMonitoringIndex)). }
false;private;1;3;;private void assertMonitorVersion(final MockWebServer webServer) throws Exception {     assertMonitorVersion(webServer, null, null). }
false;private;3;12;;private void assertMonitorVersion(final MockWebServer webServer, @Nullable final Map<String, String[]> customHeaders, @Nullable final String basePath) throws Exception {     final MockRequest request = webServer.takeRequest().     assertThat(request.getMethod(), equalTo("GET")).     final String pathPrefix = basePathToAssertablePrefix(basePath).     if (Strings.isEmpty(pathPrefix) == false) {         assertThat(request.getUri().getPath(), equalTo(pathPrefix + "/")).     }     assertThat(request.getUri().getQuery(), equalTo("filter_path=version.number")).     assertHeaders(request, customHeaders). }
false;private;7;9;;private void assertMonitorResources(final MockWebServer webServer, final boolean templateAlreadyExists, final boolean includeOldTemplates, final boolean pipelineAlreadyExists, final boolean remoteClusterAllowsWatcher, final boolean currentLicenseAllowsWatcher, final boolean watcherAlreadyExists) throws Exception {     assertMonitorResources(webServer, templateAlreadyExists, includeOldTemplates, pipelineAlreadyExists, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists, null, null). }
false;private;9;13;;private void assertMonitorResources(final MockWebServer webServer, final boolean templateAlreadyExists, final boolean includeOldTemplates, final boolean pipelineAlreadyExists, final boolean remoteClusterAllowsWatcher, final boolean currentLicenseAllowsWatcher, final boolean watcherAlreadyExists, @Nullable final Map<String, String[]> customHeaders, @Nullable final String basePath) throws Exception {     assertMonitorVersion(webServer, customHeaders, basePath).     assertMonitorTemplates(webServer, templateAlreadyExists, includeOldTemplates, customHeaders, basePath).     assertMonitorPipelines(webServer, pipelineAlreadyExists, customHeaders, basePath).     assertMonitorWatches(webServer, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists, customHeaders, basePath). }
false;private;5;9;;private void assertMonitorTemplates(final MockWebServer webServer, final boolean alreadyExists, final boolean includeOldTemplates, @Nullable final Map<String, String[]> customHeaders, @Nullable final String basePath) throws Exception {     final List<Tuple<String, String>> templates = monitoringTemplates(includeOldTemplates).     assertMonitorVersionResource(webServer, alreadyExists, "/_template/", templates, customHeaders, basePath). }
false;private;4;7;;private void assertMonitorPipelines(final MockWebServer webServer, final boolean alreadyExists, @Nullable final Map<String, String[]> customHeaders, @Nullable final String basePath) throws Exception {     assertMonitorVersionResource(webServer, alreadyExists, "/_ingest/pipeline/", monitoringPipelines(), customHeaders, basePath). }
false;private;6;28;;private void assertMonitorVersionResource(final MockWebServer webServer, final boolean alreadyExists, final String resourcePrefix, final List<Tuple<String, String>> resources, @Nullable final Map<String, String[]> customHeaders, @Nullable final String basePath) throws Exception {     final String pathPrefix = basePathToAssertablePrefix(basePath).     for (Tuple<String, String> resource : resources) {         final MockRequest getRequest = webServer.takeRequest().         assertThat(getRequest.getMethod(), equalTo("GET")).         assertThat(getRequest.getUri().getPath(), equalTo(pathPrefix + resourcePrefix + resource.v1())).         assertMonitorVersionQueryString(getRequest.getUri().getQuery(), Collections.emptyMap()).         assertHeaders(getRequest, customHeaders).         if (alreadyExists == false) {             final MockRequest putRequest = webServer.takeRequest().             assertThat(putRequest.getMethod(), equalTo("PUT")).             assertThat(putRequest.getUri().getPath(), equalTo(pathPrefix + resourcePrefix + resource.v1())).             Map<String, String> parameters = resourcePrefix.startsWith("/_template") ? Collections.singletonMap(INCLUDE_TYPE_NAME_PARAMETER, "true") : Collections.emptyMap().             assertMonitorVersionQueryString(putRequest.getUri().getQuery(), parameters).             assertThat(putRequest.getBody(), equalTo(resource.v2())).             assertHeaders(putRequest, customHeaders).         }     } }
false;private;2;13;;private void assertMonitorVersionQueryString(String query, final Map<String, String> parameters) {     Map<String, String> expectedQueryStringMap = new HashMap<>().     RestUtils.decodeQueryString(query, 0, expectedQueryStringMap).     Map<String, String> resourceVersionQueryStringMap = new HashMap<>().     RestUtils.decodeQueryString(resourceVersionQueryString(), 0, resourceVersionQueryStringMap).     Map<String, String> actualQueryStringMap = new HashMap<>().     actualQueryStringMap.putAll(resourceVersionQueryStringMap).     actualQueryStringMap.putAll(parameters).     assertEquals(expectedQueryStringMap, actualQueryStringMap). }
false;private;6;48;;private void assertMonitorWatches(final MockWebServer webServer, final boolean remoteClusterAllowsWatcher, final boolean currentLicenseAllowsWatcher, final boolean alreadyExists, @Nullable final Map<String, String[]> customHeaders, @Nullable final String basePath) {     final String pathPrefix = basePathToAssertablePrefix(basePath).     MockRequest request.     request = webServer.takeRequest().     // GET /_xpack     assertThat(request.getMethod(), equalTo("GET")).     assertThat(request.getUri().getPath(), equalTo(pathPrefix + "/_xpack")).     assertThat(request.getUri().getQuery(), equalTo(watcherCheckQueryString())).     assertHeaders(request, customHeaders).     if (remoteClusterAllowsWatcher) {         for (final Tuple<String, String> watch : monitoringWatches()) {             final String uniqueWatchId = ClusterAlertsUtil.createUniqueWatchId(clusterService(), watch.v1()).             request = webServer.takeRequest().             // GET / PUT if we are allowed to use it             if (currentLicenseAllowsWatcher && clusterAlertBlacklist.contains(watch.v1()) == false) {                 assertThat(request.getMethod(), equalTo("GET")).                 assertThat(request.getUri().getPath(), equalTo(pathPrefix + "/_watcher/watch/" + uniqueWatchId)).                 assertThat(request.getUri().getQuery(), equalTo(resourceClusterAlertQueryString())).                 assertHeaders(request, customHeaders).                 if (alreadyExists == false) {                     request = webServer.takeRequest().                     assertThat(request.getMethod(), equalTo("PUT")).                     assertThat(request.getUri().getPath(), equalTo(pathPrefix + "/_watcher/watch/" + uniqueWatchId)).                     assertThat(request.getUri().getQuery(), equalTo(resourceClusterAlertQueryString())).                     assertThat(request.getBody(), equalTo(watch.v2())).                     assertHeaders(request, customHeaders).                 }             // DELETE if we're not allowed to use it             } else {                 assertThat(request.getMethod(), equalTo("DELETE")).                 assertThat(request.getUri().getPath(), equalTo(pathPrefix + "/_watcher/watch/" + uniqueWatchId)).                 assertThat(request.getUri().getQuery(), equalTo(resourceClusterAlertQueryString())).                 assertHeaders(request, customHeaders).             }         }     } }
false;private;1;3;;private MockRequest assertBulk(final MockWebServer webServer) throws Exception {     return assertBulk(webServer, -1). }
false;private;2;3;;private MockRequest assertBulk(final MockWebServer webServer, final int docs) throws Exception {     return assertBulk(webServer, docs, null, null). }
false;private;4;17;;private MockRequest assertBulk(final MockWebServer webServer, final int docs, @Nullable final Map<String, String[]> customHeaders, @Nullable final String basePath) throws Exception {     final String pathPrefix = basePathToAssertablePrefix(basePath).     final MockRequest request = webServer.takeRequest().     assertThat(request.getMethod(), equalTo("POST")).     assertThat(request.getUri().getPath(), equalTo(pathPrefix + "/_bulk")).     assertThat(request.getUri().getQuery(), equalTo(bulkQueryString())).     assertHeaders(request, customHeaders).     if (docs != -1) {         assertBulkRequest(request.getBody(), docs).     }     return request. }
false;private;2;15;;private void assertHeaders(final MockRequest request, final Map<String, String[]> customHeaders) {     if (customHeaders != null) {         for (final Map.Entry<String, String[]> entry : customHeaders.entrySet()) {             final String header = entry.getKey().             final String[] values = entry.getValue().             final List<String> headerValues = request.getHeaders().get(header).             if (values.length > 0) {                 assertThat(headerValues, hasSize(values.length)).                 assertThat(headerValues, containsInAnyOrder(values)).             }         }     } }
false;private;1;6;;private HttpExporter createHttpExporter(final Settings settings) {     final Exporter.Config config = new Exporter.Config("_http", "http", settings, clusterService(), new XPackLicenseState(Settings.EMPTY)).     return new HttpExporter(config, new SSLService(settings, environment), new ThreadContext(settings)). }
false;private;2;26;;private void export(final Settings settings, final Collection<MonitoringDoc> docs) throws Exception {     // wait until the cluster is ready (this is done at the "Exporters" level)     assertBusy(() -> assertThat(clusterService().state().version(), not(ClusterState.UNKNOWN_VERSION))).     try (HttpExporter exporter = createHttpExporter(settings)) {         final CountDownLatch awaitResponseAndClose = new CountDownLatch(2).         exporter.openBulk(ActionListener.wrap(exportBulk -> {             final HttpExportBulk bulk = (HttpExportBulk) exportBulk.             assertThat("Bulk should never be null after the exporter is ready", bulk, notNullValue()).             final ActionListener<Void> listener = ActionListener.wrap(ignored -> awaitResponseAndClose.countDown(), e -> fail(e.getMessage())).             bulk.doAdd(docs).             bulk.doFlush(listener).             // reusing the same listener, which is why we expect countDown x2             bulk.doClose(listener).         }, e -> fail("Failed to create HttpExportBulk"))).         // block until the bulk responds         assertTrue(awaitResponseAndClose.await(15, TimeUnit.SECONDS)).     } }
false;private;0;8;;private MonitoringDoc newRandomMonitoringDoc() {     String clusterUUID = internalCluster().getClusterName().     long timestamp = System.currentTimeMillis().     long intervalMillis = randomNonNegativeLong().     MonitoringDoc.Node sourceNode = MonitoringTestUtils.randomMonitoringNode(random()).     return new IndexRecoveryMonitoringDoc(clusterUUID, timestamp, intervalMillis, sourceNode, new RecoveryResponse()). }
false;private;1;7;;private List<MonitoringDoc> newRandomMonitoringDocs(int nb) {     List<MonitoringDoc> docs = new ArrayList<>(nb).     for (int i = 0. i < nb. i++) {         docs.add(newRandomMonitoringDoc()).     }     return docs. }
false;private;1;7;;private String basePathToAssertablePrefix(@Nullable String basePath) {     if (basePath == null) {         return "".     }     basePath = basePath.startsWith("/") ? basePath : "/" + basePath.     return basePath. }
false;private;0;3;;private String resourceClusterAlertQueryString() {     return "filter_path=" + CLUSTER_ALERT_VERSION_PARAMETERS.get("filter_path"). }
false;private;0;3;;private String resourceVersionQueryString() {     return "filter_path=" + FILTER_PATH_RESOURCE_VERSION. }
false;private;0;3;;private String watcherCheckQueryString() {     return "filter_path=" + WATCHER_CHECK_PARAMETERS.get("filter_path"). }
false;private;0;5;;private String bulkQueryString() {     final String pipelineName = MonitoringTemplateUtils.pipelineName(TEMPLATE_VERSION).     return "pipeline=" + pipelineName + "&filter_path=" + "errors,items.*.error". }
false;private;1;3;;private void enqueueGetClusterVersionResponse(Version v) throws IOException {     enqueueGetClusterVersionResponse(webServer, v). }
false;private;2;5;;private void enqueueGetClusterVersionResponse(MockWebServer mockWebServer, Version v) throws IOException {     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(BytesReference.bytes(jsonBuilder().startObject().startObject("version").field("number", v.toString()).endObject().endObject()).utf8ToString())). }
false;private;7;9;;private void enqueueSetupResponses(final MockWebServer webServer, final boolean templatesAlreadyExists, final boolean includeOldTemplates, final boolean pipelineAlreadyExists, final boolean remoteClusterAllowsWatcher, final boolean currentLicenseAllowsWatcher, final boolean watcherAlreadyExists) throws IOException {     enqueueTemplateResponses(webServer, templatesAlreadyExists, includeOldTemplates).     enqueuePipelineResponses(webServer, pipelineAlreadyExists).     enqueueWatcherResponses(webServer, remoteClusterAllowsWatcher, currentLicenseAllowsWatcher, watcherAlreadyExists). }
false;private;3;9;;private void enqueueTemplateResponses(final MockWebServer webServer, final boolean alreadyExists, final boolean includeOldTemplates) throws IOException {     if (alreadyExists) {         enqueueTemplateResponsesExistsAlready(webServer, includeOldTemplates).     } else {         enqueueTemplateResponsesDoesNotExistYet(webServer, includeOldTemplates).     } }
false;private;2;5;;private void enqueueTemplateResponsesDoesNotExistYet(final MockWebServer webServer, final boolean includeOldTemplates) throws IOException {     enqueueVersionedResourceResponsesDoesNotExistYet(monitoringTemplateNames(includeOldTemplates), webServer). }
false;private;2;5;;private void enqueueTemplateResponsesExistsAlready(final MockWebServer webServer, final boolean includeOldTemplates) throws IOException {     enqueueVersionedResourceResponsesExistsAlready(monitoringTemplateNames(includeOldTemplates), webServer). }
false;private;2;7;;private void enqueuePipelineResponses(final MockWebServer webServer, final boolean alreadyExists) throws IOException {     if (alreadyExists) {         enqueuePipelineResponsesExistsAlready(webServer).     } else {         enqueuePipelineResponsesDoesNotExistYet(webServer).     } }
false;private;1;3;;private void enqueuePipelineResponsesDoesNotExistYet(final MockWebServer webServer) throws IOException {     enqueueVersionedResourceResponsesDoesNotExistYet(monitoringPipelineNames(), webServer). }
false;private;1;3;;private void enqueuePipelineResponsesExistsAlready(final MockWebServer webServer) throws IOException {     enqueueVersionedResourceResponsesExistsAlready(monitoringPipelineNames(), webServer). }
false;private;2;17;;private void enqueueVersionedResourceResponsesDoesNotExistYet(final List<String> names, final MockWebServer webServer) throws IOException {     for (String resource : names) {         if (randomBoolean()) {             enqueueResponse(webServer, 404, "[" + resource + "] does not exist").         } else if (randomBoolean()) {             final int version = LAST_UPDATED_VERSION - randomIntBetween(1, 1000000).             // it DOES exist, but it's an older version             enqueueResponse(webServer, 200, "{\"" + resource + "\":{\"version\":" + version + "}}").         } else {             // no version specified             enqueueResponse(webServer, 200, "{\"" + resource + "\":{}}").         }         enqueueResponse(webServer, 201, "[" + resource + "] created").     } }
false;private;2;14;;private void enqueueVersionedResourceResponsesExistsAlready(final List<String> names, final MockWebServer webServer) throws IOException {     for (String resource : names) {         if (randomBoolean()) {             final int newerVersion = randomFrom(Version.CURRENT.id, LAST_UPDATED_VERSION) + randomIntBetween(1, 1000000).             // it's a NEWER resource (template / pipeline)             enqueueResponse(webServer, 200, "{\"" + resource + "\":{\"version\":" + newerVersion + "}}").         } else {             // we already put it             enqueueResponse(webServer, 200, "{\"" + resource + "\":{\"version\":" + LAST_UPDATED_VERSION + "}}").         }     } }
false;private;4;35;;private void enqueueWatcherResponses(final MockWebServer webServer, final boolean remoteClusterAllowsWatcher, final boolean currentLicenseAllowsWatcher, final boolean alreadyExists) throws IOException {     // if the remote cluster doesn't allow watcher, then we only check for it and we're done     if (remoteClusterAllowsWatcher) {         // X-Pack exists and Watcher can be used         enqueueResponse(webServer, 200, "{\"features\":{\"watcher\":{\"available\":true,\"enabled\":true}}}").         // if we have an active license that's not Basic, then we should add watches         if (currentLicenseAllowsWatcher) {             if (alreadyExists) {                 enqueueClusterAlertResponsesExistsAlready(webServer).             } else {                 enqueueClusterAlertResponsesDoesNotExistYet(webServer).             }         // otherwise we need to delete them from the remote cluster         } else {             enqueueDeleteClusterAlertResponses(webServer).         }     } else {         // X-Pack exists but Watcher just cannot be used         if (randomBoolean()) {             final String responseBody = randomFrom("{\"features\":{\"watcher\":{\"available\":false,\"enabled\":true}}}", "{\"features\":{\"watcher\":{\"available\":true,\"enabled\":false}}}", "{}").             enqueueResponse(webServer, 200, responseBody).         // X-Pack is not installed         } else {             enqueueResponse(webServer, 404, "{}").         }     } }
false;private;1;21;;private void enqueueClusterAlertResponsesDoesNotExistYet(final MockWebServer webServer) throws IOException {     for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {         if (clusterAlertBlacklist.contains(watchId)) {             enqueueDeleteClusterAlertResponse(webServer, watchId).         } else {             if (randomBoolean()) {                 enqueueResponse(webServer, 404, "watch [" + watchId + "] does not exist").             } else if (randomBoolean()) {                 final int version = ClusterAlertsUtil.LAST_UPDATED_VERSION - randomIntBetween(1, 1000000).                 // it DOES exist, but it's an older version                 enqueueResponse(webServer, 200, "{\"metadata\":{\"xpack\":{\"version_created\":" + version + "}}}").             } else {                 // no version specified                 enqueueResponse(webServer, 200, "{\"metadata\":{\"xpack\":{}}}").             }             enqueueResponse(webServer, 201, "[" + watchId + "] created").         }     } }
false;private;1;19;;private void enqueueClusterAlertResponsesExistsAlready(final MockWebServer webServer) throws IOException {     for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {         if (clusterAlertBlacklist.contains(watchId)) {             enqueueDeleteClusterAlertResponse(webServer, watchId).         } else {             final int existsVersion.             if (randomBoolean()) {                 // it's a NEWER cluster alert                 existsVersion = randomFrom(Version.CURRENT.id, ClusterAlertsUtil.LAST_UPDATED_VERSION) + randomIntBetween(1, 1000000).             } else {                 // we already put it                 existsVersion = ClusterAlertsUtil.LAST_UPDATED_VERSION.             }             enqueueResponse(webServer, 200, "{\"metadata\":{\"xpack\":{\"version_created\":" + existsVersion + "}}}").         }     } }
false;private;1;5;;private void enqueueDeleteClusterAlertResponses(final MockWebServer webServer) throws IOException {     for (final String watchId : ClusterAlertsUtil.WATCH_IDS) {         enqueueDeleteClusterAlertResponse(webServer, watchId).     } }
false;private;2;7;;private void enqueueDeleteClusterAlertResponse(final MockWebServer webServer, final String watchId) throws IOException {     if (randomBoolean()) {         enqueueResponse(webServer, 404, "watch [" + watchId + "] did not exist").     } else {         enqueueResponse(webServer, 200, "watch [" + watchId + "] deleted").     } }
false;private;2;3;;private void enqueueResponse(int responseCode, String body) throws IOException {     enqueueResponse(webServer, responseCode, body). }
false;private;3;3;;private void enqueueResponse(MockWebServer mockWebServer, int responseCode, String body) throws IOException {     mockWebServer.enqueue(new MockResponse().setResponseCode(responseCode).setBody(body)). }
false;private;2;8;;private void assertBulkRequest(String requestBody, int numberOfActions) throws Exception {     BulkRequest bulkRequest = Requests.bulkRequest().add(new BytesArray(requestBody.getBytes(StandardCharsets.UTF_8)), null, null, XContentType.JSON).     assertThat(bulkRequest.numberOfActions(), equalTo(numberOfActions)).     for (DocWriteRequest actionRequest : bulkRequest.requests()) {         assertThat(actionRequest, instanceOf(IndexRequest.class)).     } }
false;private;1;3;;private String getFormattedAddress(MockWebServer server) {     return server.getHostName() + ":" + server.getPort(). }
false;private;0;5;;private MockWebServer createMockWebServer() throws IOException {     MockWebServer server = new MockWebServer().     server.start().     return server. }
false;private;1;3;;private List<Tuple<String, String>> monitoringTemplates(final boolean includeOldTemplates) {     return includeOldTemplates ? monitoringTemplatesWithOldTemplates() : monitoringTemplates(). }
true;private;0;10;// this can be removed in 7.0 ;// this can be removed in 7.0 private List<Tuple<String, String>> monitoringTemplatesWithOldTemplates() {     final List<Tuple<String, String>> expectedTemplates = monitoringTemplates().     expectedTemplates.addAll(Arrays.stream(MonitoringTemplateUtils.OLD_TEMPLATE_IDS).map(id -> new Tuple<>(MonitoringTemplateUtils.oldTemplateName(id), MonitoringTemplateUtils.createEmptyTemplate(id))).collect(Collectors.toList())).     return expectedTemplates. }
false;private;1;3;;private List<String> monitoringTemplateNames(final boolean includeOldTemplates) {     return includeOldTemplates ? monitoringTemplateNamesWithOldTemplates() : monitoringTemplateNames(). }
true;protected;0;10;// this can be removed in 7.0 ;// this can be removed in 7.0 protected List<String> monitoringTemplateNamesWithOldTemplates() {     final List<String> expectedTemplateNames = monitoringTemplateNames().     expectedTemplateNames.addAll(Arrays.stream(MonitoringTemplateUtils.OLD_TEMPLATE_IDS).map(MonitoringTemplateUtils::oldTemplateName).collect(Collectors.toList())).     return expectedTemplateNames. }
