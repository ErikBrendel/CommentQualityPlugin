commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "migration_upgrade". }
false;public;2;8;;@Override public RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {     if (request.method().equals(POST)) {         return handlePost(request, client).     } else {         throw new IllegalArgumentException("illegal method [" + request.method() + "] for request [" + request.path() + "]").     } }
false;public;2;7;;@Override public RestResponse buildResponse(BulkByScrollResponse response, XContentBuilder builder) throws Exception {     builder.startObject().     response.toXContent(builder, new ToXContent.DelegatingMapParams(params, channel.request())).     builder.endObject().     return new BytesRestResponse(getStatus(response), builder). }
false;private;1;22;;private RestStatus getStatus(BulkByScrollResponse response) {     /*                              * Return the highest numbered rest status under the assumption that higher numbered statuses are "more error"                              * and thus more interesting to the user.                              */     RestStatus status = RestStatus.OK.     if (response.isTimedOut()) {         status = RestStatus.REQUEST_TIMEOUT.     }     for (BulkItemResponse.Failure failure : response.getBulkFailures()) {         if (failure.getStatus().getStatus() > status.getStatus()) {             status = failure.getStatus().         }     }     for (ScrollableHitSource.SearchFailure failure : response.getSearchFailures()) {         RestStatus failureStatus = ExceptionsHelper.status(failure.getReason()).         if (failureStatus.getStatus() > status.getStatus()) {             status = failureStatus.         }     }     return status. }
false;private;2;64;;private RestChannelConsumer handlePost(final RestRequest request, NodeClient client) {     Request upgradeRequest = new Request(request.param("index")).     Map<String, String> params = new HashMap<>().     params.put(BulkByScrollTask.Status.INCLUDE_CREATED, Boolean.toString(true)).     params.put(BulkByScrollTask.Status.INCLUDE_UPDATED, Boolean.toString(true)).     if (request.paramAsBoolean("wait_for_completion", true)) {         return channel -> client.execute(IndexUpgradeAction.INSTANCE, upgradeRequest, new RestBuilderListener<BulkByScrollResponse>(channel) {              @Override             public RestResponse buildResponse(BulkByScrollResponse response, XContentBuilder builder) throws Exception {                 builder.startObject().                 response.toXContent(builder, new ToXContent.DelegatingMapParams(params, channel.request())).                 builder.endObject().                 return new BytesRestResponse(getStatus(response), builder).             }              private RestStatus getStatus(BulkByScrollResponse response) {                 /*                              * Return the highest numbered rest status under the assumption that higher numbered statuses are "more error"                              * and thus more interesting to the user.                              */                 RestStatus status = RestStatus.OK.                 if (response.isTimedOut()) {                     status = RestStatus.REQUEST_TIMEOUT.                 }                 for (BulkItemResponse.Failure failure : response.getBulkFailures()) {                     if (failure.getStatus().getStatus() > status.getStatus()) {                         status = failure.getStatus().                     }                 }                 for (ScrollableHitSource.SearchFailure failure : response.getSearchFailures()) {                     RestStatus failureStatus = ExceptionsHelper.status(failure.getReason()).                     if (failureStatus.getStatus() > status.getStatus()) {                         status = failureStatus.                     }                 }                 return status.             }         }).     } else {         upgradeRequest.setShouldStoreResult(true).         /*              * Validating before forking to make sure we can catch the issues earlier              */         ActionRequestValidationException validationException = upgradeRequest.validate().         if (validationException != null) {             throw validationException.         }         Task task = client.executeLocally(IndexUpgradeAction.INSTANCE, upgradeRequest, LoggingTaskListener.instance()).         // Send task description id instead of waiting for the message         return channel -> {             try (XContentBuilder builder = channel.newBuilder()) {                 builder.startObject().                 builder.field("task", client.getLocalNodeId() + ":" + task.getId()).                 builder.endObject().                 channel.sendResponse(new BytesRestResponse(RestStatus.OK, builder)).             }         }.     } }
