commented;modifiers;parameterAmount;loc;comment;code
true;public;3;13;/**  * Returns the information about required upgrade action for the given indices  *  * @param indices list of indices to check, specify _all for all indices  * @param options wild card resolution option  * @param state   the current cluster state  * @return a list of indices that should be upgraded/reindexed  */ ;/**  * Returns the information about required upgrade action for the given indices  *  * @param indices list of indices to check, specify _all for all indices  * @param options wild card resolution option  * @param state   the current cluster state  * @return a list of indices that should be upgraded/reindexed  */ public Map<String, UpgradeActionRequired> upgradeInfo(String[] indices, IndicesOptions options, ClusterState state) {     Map<String, UpgradeActionRequired> results = new HashMap<>().     String[] concreteIndexNames = indexNameExpressionResolver.concreteIndexNames(state, options, indices).     MetaData metaData = state.getMetaData().     for (String index : concreteIndexNames) {         IndexMetaData indexMetaData = metaData.index(index).         UpgradeActionRequired upgradeActionRequired = upgradeInfo(indexMetaData, index).         if (upgradeActionRequired != null) {             results.put(index, upgradeActionRequired).         }     }     return results. }
false;private;2;28;;private UpgradeActionRequired upgradeInfo(IndexMetaData indexMetaData, String index) {     for (IndexUpgradeCheck check : upgradeChecks) {         UpgradeActionRequired upgradeActionRequired = check.actionRequired(indexMetaData).         logger.trace("[{}] check [{}] returned [{}]", index, check.getName(), upgradeActionRequired).         switch(upgradeActionRequired) {             case UPGRADE:             case REINDEX:                 // this index needs to be upgraded or reindexed - skipping all other checks                 return upgradeActionRequired.             case UP_TO_DATE:                 // this index is good - skipping all other checks                 return null.             case NOT_APPLICABLE:                 // this action is not applicable to this index - skipping to the next one                 break.             default:                 throw new IllegalStateException("unknown upgrade action " + upgradeActionRequired + " for the index " + index).         }     }     // Catch all check for all indices that didn't match the specific checks     if (indexMetaData.getCreationVersion().before(Version.V_6_0_0)) {         return UpgradeActionRequired.REINDEX.     } else {         return null.     } }
false;public;4;27;;public void upgrade(TaskId task, String index, ClusterState state, ActionListener<BulkByScrollResponse> listener) {     IndexMetaData indexMetaData = state.metaData().index(index).     if (indexMetaData == null) {         throw new IndexNotFoundException(index).     }     for (IndexUpgradeCheck check : upgradeChecks) {         UpgradeActionRequired upgradeActionRequired = check.actionRequired(indexMetaData).         switch(upgradeActionRequired) {             case UPGRADE:                 // this index needs to be upgraded - start the upgrade procedure                 check.upgrade(task, indexMetaData, state, listener).                 return.             case REINDEX:                 // this index needs to be re-indexed                 throw new IllegalStateException("Index [" + index + "] cannot be upgraded, it should be reindex instead").             case UP_TO_DATE:                 throw new IllegalStateException("Index [" + index + "] cannot be upgraded, it is up to date").             case NOT_APPLICABLE:                 // this action is not applicable to this index - skipping to the next one                 break.             default:                 throw new IllegalStateException("unknown upgrade action [" + upgradeActionRequired + "] for the index [" + index + "]").         }     }     throw new IllegalStateException("Index [" + index + "] cannot be upgraded"). }
