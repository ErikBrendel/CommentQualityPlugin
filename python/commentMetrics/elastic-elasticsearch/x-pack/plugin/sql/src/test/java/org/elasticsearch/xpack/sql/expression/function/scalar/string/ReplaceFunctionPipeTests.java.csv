commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected ReplaceFunctionPipe randomInstance() {     return randomReplaceFunctionPipe(). }
false;private;0;3;;private Expression randomReplaceFunctionExpression() {     return randomReplaceFunctionPipe().expression(). }
false;public,static;0;7;;public static ReplaceFunctionPipe randomReplaceFunctionPipe() {     return (ReplaceFunctionPipe) (new Replace(randomSource(), randomStringLiteral(), randomStringLiteral(), randomStringLiteral()).makePipe()). }
false;public;0;26;;@Override public void testTransform() {     // test transforming only the properties (source, expression),     // skipping the children (the two parameters of the binary function) which are tested separately     ReplaceFunctionPipe b1 = randomInstance().     Expression newExpression = randomValueOtherThan(b1.expression(), () -> randomReplaceFunctionExpression()).     ReplaceFunctionPipe newB = new ReplaceFunctionPipe(b1.source(), newExpression, b1.src(), b1.pattern(), b1.replacement()).     assertEquals(newB, b1.transformPropertiesOnly(v -> Objects.equals(v, b1.expression()) ? newExpression : v, Expression.class)).     ReplaceFunctionPipe b2 = randomInstance().     Source newLoc = randomValueOtherThan(b2.source(), () -> randomSource()).     newB = new ReplaceFunctionPipe(newLoc, b2.expression(), b2.src(), b2.pattern(), b2.replacement()).     assertEquals(newB, b2.transformPropertiesOnly(v -> Objects.equals(v, b2.source()) ? newLoc : v, Source.class)). }
false;public;0;26;;@Override public void testReplaceChildren() {     ReplaceFunctionPipe b = randomInstance().     Pipe newSource = pipe(((Expression) randomValueOtherThan(b.source(), () -> randomStringLiteral()))).     Pipe newPattern = pipe(((Expression) randomValueOtherThan(b.pattern(), () -> randomStringLiteral()))).     Pipe newR = pipe(((Expression) randomValueOtherThan(b.replacement(), () -> randomStringLiteral()))).     ReplaceFunctionPipe newB = new ReplaceFunctionPipe(b.source(), b.expression(), b.src(), b.pattern(), b.replacement()).     ReplaceFunctionPipe transformed = null.     // generate all the combinations of possible children modifications and test all of them     for (int i = 1. i < 4. i++) {         for (BitSet comb : new Combinations(3, i)) {             transformed = (ReplaceFunctionPipe) newB.replaceChildren(comb.get(0) ? newSource : b.src(), comb.get(1) ? newPattern : b.pattern(), comb.get(2) ? newR : b.replacement()).             assertEquals(transformed.src(), comb.get(0) ? newSource : b.src()).             assertEquals(transformed.pattern(), comb.get(1) ? newPattern : b.pattern()).             assertEquals(transformed.replacement(), comb.get(2) ? newR : b.replacement()).             assertEquals(transformed.expression(), b.expression()).             assertEquals(transformed.source(), b.source()).         }     } }
false;protected;1;19;;@Override protected ReplaceFunctionPipe mutate(ReplaceFunctionPipe instance) {     List<Function<ReplaceFunctionPipe, ReplaceFunctionPipe>> randoms = new ArrayList<>().     for (int i = 1. i < 4. i++) {         for (BitSet comb : new Combinations(3, i)) {             randoms.add(f -> new ReplaceFunctionPipe(f.source(), f.expression(), comb.get(0) ? pipe(((Expression) randomValueOtherThan(f.src(), () -> randomStringLiteral()))) : f.src(), comb.get(1) ? pipe(((Expression) randomValueOtherThan(f.pattern(), () -> randomStringLiteral()))) : f.pattern(), comb.get(2) ? pipe(((Expression) randomValueOtherThan(f.replacement(), () -> randomStringLiteral()))) : f.replacement())).         }     }     return randomFrom(randoms).apply(instance). }
false;protected;1;8;;@Override protected ReplaceFunctionPipe copy(ReplaceFunctionPipe instance) {     return new ReplaceFunctionPipe(instance.source(), instance.expression(), instance.src(), instance.pattern(), instance.replacement()). }
