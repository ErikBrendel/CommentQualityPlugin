commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;public void testInfoParameters() throws Exception {     Constructor<T> ctor = longestCtor(subclass).     Object[] nodeCtorArgs = ctorArgs(ctor).     T node = ctor.newInstance(nodeCtorArgs).     /*          * The count should be the same size as the longest constructor          * by convention. If it isn't then we're missing something.          */     int expectedCount = ctor.getParameterCount().     /*          * Except the first `Location` argument of the ctor is implicit          * in the parameters and not included.          */     expectedCount -= 1.     assertEquals(expectedCount, node.info().properties().size()). }
true;public;0;34;/**  * Test {@link Node#transformPropertiesOnly(java.util.function.Function, Class)}  * implementation on {@link #subclass} which tests the implementation of  * {@link Node#info()}. And tests the actual {@link NodeInfo} subclass  * implementations in the process.  */ ;/**  * Test {@link Node#transformPropertiesOnly(java.util.function.Function, Class)}  * implementation on {@link #subclass} which tests the implementation of  * {@link Node#info()}. And tests the actual {@link NodeInfo} subclass  * implementations in the process.  */ public void testTransform() throws Exception {     Constructor<T> ctor = longestCtor(subclass).     Object[] nodeCtorArgs = ctorArgs(ctor).     T node = ctor.newInstance(nodeCtorArgs).     Type[] argTypes = ctor.getGenericParameterTypes().     // start at 1 because we can't change Location.     for (int changedArgOffset = 1. changedArgOffset < ctor.getParameterCount(). changedArgOffset++) {         Object originalArgValue = nodeCtorArgs[changedArgOffset].         Type changedArgType = argTypes[changedArgOffset].         Object changedArgValue = randomValueOtherThan(nodeCtorArgs[changedArgOffset], () -> makeArg(changedArgType)).         B transformed = node.transformNodeProps(prop -> Objects.equals(prop, originalArgValue) ? changedArgValue : prop, Object.class).         if (node.children().contains(originalArgValue) || node.children().equals(originalArgValue)) {             if (node.children().equals(emptyList()) && originalArgValue.equals(emptyList())) {                 /*                      * If the children are an empty list and the value                      * we want to change is an empty list they'll be                      * equal to one another so they'll come on this branch.                      * This case is rare and hard to reason about so we're                      * just going to assert nothing here and hope to catch                      * it when we write non-reflection hack tests.                      */                 continue.             }             // Transformation shouldn't apply to children.             assertSame(node, transformed).         } else {             assertTransformedOrReplacedChildren(node, transformed, ctor, nodeCtorArgs, changedArgOffset, changedArgValue).         }     } }
true;public;0;76;/**  * Test {@link Node#replaceChildren} implementation on {@link #subclass}.  */ ;/**  * Test {@link Node#replaceChildren} implementation on {@link #subclass}.  */ public void testReplaceChildren() throws Exception {     Constructor<T> ctor = longestCtor(subclass).     Object[] nodeCtorArgs = ctorArgs(ctor).     T node = ctor.newInstance(nodeCtorArgs).     Type[] argTypes = ctor.getGenericParameterTypes().     // start at 1 because we can't change Location.     for (int changedArgOffset = 1. changedArgOffset < ctor.getParameterCount(). changedArgOffset++) {         Object originalArgValue = nodeCtorArgs[changedArgOffset].         Type changedArgType = argTypes[changedArgOffset].         if (originalArgValue instanceof Collection) {             Collection<?> col = (Collection<?>) originalArgValue.             if (col.isEmpty() || col instanceof EnumSet) {                 continue.             }             List<?> originalList = (List<?>) originalArgValue.             if (node.children().equals(originalList)) {                 // The arg we're looking at *is* the children                 // we pass a reasonable type so get reasonable results                 @SuppressWarnings("unchecked")                 List<B> newChildren = (List<B>) makeListOfSameSizeOtherThan(changedArgType, originalList).                 B transformed = node.replaceChildren(newChildren).                 assertTransformedOrReplacedChildren(node, transformed, ctor, nodeCtorArgs, changedArgOffset, newChildren).             } else if (false == originalList.isEmpty() && node.children().containsAll(originalList)) {                 // The arg we're looking at is a collection contained within the children                 // First make the new children                 // we pass a reasonable type so get reasonable results                 @SuppressWarnings("unchecked")                 List<B> newCollection = (List<B>) makeListOfSameSizeOtherThan(changedArgType, originalList).                 // Now merge that list of thildren into the original list of children                 List<B> originalChildren = node.children().                 List<B> newChildren = new ArrayList<>(originalChildren.size()).                 int originalOffset = 0.                 for (int i = 0. i < originalChildren.size(). i++) {                     if (originalOffset < originalList.size() && originalChildren.get(i).equals(originalList.get(originalOffset))) {                         newChildren.add(newCollection.get(originalOffset)).                         originalOffset++.                     } else {                         newChildren.add(originalChildren.get(i)).                     }                 }                 // Finally! We can assert.....                 B transformed = node.replaceChildren(newChildren).                 assertTransformedOrReplacedChildren(node, transformed, ctor, nodeCtorArgs, changedArgOffset, newCollection).             } else {             // The arg we're looking at has nothing to do with the children             }         } else {             if (node.children().contains(originalArgValue)) {                 // The arg we're looking at is one of the children                 List<B> newChildren = new ArrayList<>(node.children()).                 // makeArg produced reasonable values                 @SuppressWarnings("unchecked")                 B newChild = (B) randomValueOtherThan(nodeCtorArgs[changedArgOffset], () -> makeArg(changedArgType)).                 newChildren.replaceAll(e -> Objects.equals(originalArgValue, e) ? newChild : e).                 B transformed = node.replaceChildren(newChildren).                 assertTransformedOrReplacedChildren(node, transformed, ctor, nodeCtorArgs, changedArgOffset, newChild).             } else {             // The arg we're looking at has nothing to do with the children             }         }     } }
false;private;6;37;;private void assertTransformedOrReplacedChildren(T node, B transformed, Constructor<T> ctor, Object[] nodeCtorArgs, int changedArgOffset, Object changedArgValue) throws Exception {     if (node instanceof Function) {         /*              * Functions have a weaker definition of transform then other              * things:              *              * Transforming using the way we did above should only change              * the one property of the node that we intended to transform.              */         assertEquals(node.source(), transformed.source()).         List<Object> op = node.nodeProperties().         List<Object> tp = transformed.nodeProperties().         for (int p = 0. p < op.size(). p++) {             if (p == changedArgOffset - 1) {                 // -1 because location isn't in the list                 assertEquals(changedArgValue, tp.get(p)).             } else {                 assertEquals(op.get(p), tp.get(p)).             }         }     } else {         /*              * The stronger assertion for all non-Functions: transforming              * a node changes *only* the transformed value such that you              * can rebuild a copy of the node using its constructor changing              * only one argument and it'll be *equal* to the result of the              * transformation.              */         Type[] argTypes = ctor.getGenericParameterTypes().         Object[] args = new Object[argTypes.length].         for (int i = 0. i < argTypes.length. i++) {             args[i] = nodeCtorArgs[i] == nodeCtorArgs[changedArgOffset] ? changedArgValue : nodeCtorArgs[i].         }         T reflectionTransformed = ctor.newInstance(args).         assertEquals(reflectionTransformed, transformed).     } }
true;static;1;14;/**  * Find the longest constructor of the given class.  * By convention, for all subclasses of {@link Node},  * this constructor should have "all" of the state of  * the node. All other constructors should all delegate  * to this constructor.  */ ;/**  * Find the longest constructor of the given class.  * By convention, for all subclasses of {@link Node},  * this constructor should have "all" of the state of  * the node. All other constructors should all delegate  * to this constructor.  */ static <T> Constructor<T> longestCtor(Class<T> clazz) {     Constructor<T> longest = null.     for (Constructor<?> ctor : clazz.getConstructors()) {         if (longest == null || longest.getParameterCount() < ctor.getParameterCount()) {             // Safe because the ctor has to be a ctor for T             @SuppressWarnings("unchecked")             Constructor<T> castCtor = (Constructor<T>) ctor.             longest = castCtor.         }     }     if (longest == null) {         throw new IllegalArgumentException("Couldn't find any constructors for [" + clazz.getName() + "]").     }     return longest. }
true;public,static;0;8;/**  * Scans the {@code .class} files to identify all classes and  * checks if they are subclasses of {@link Node}.  */ ;/**  * Scans the {@code .class} files to identify all classes and  * checks if they are subclasses of {@link Node}.  */ @ParametersFactory @SuppressWarnings("rawtypes") public static List<Object[]> nodeSubclasses() throws IOException {     return subclassesOf(Node.class).stream().filter(c -> testClassFor(c) == null).map(c -> new Object[] { c }).collect(toList()). }
true;private,static;1;22;/**  * Build a list of arguments to use when calling  * {@code ctor} that make sense when {@code ctor}  * builds subclasses of {@link Node}.  */ ;/**  * Build a list of arguments to use when calling  * {@code ctor} that make sense when {@code ctor}  * builds subclasses of {@link Node}.  */ private static Object[] ctorArgs(Constructor<? extends Node<?>> ctor) throws Exception {     Type[] argTypes = ctor.getGenericParameterTypes().     Object[] args = new Object[argTypes.length].     for (int i = 0. i < argTypes.length. i++) {         final int currentArgIndex = i.         args[i] = randomValueOtherThanMany(candidate -> {             for (int a = 0. a < currentArgIndex. a++) {                 if (Objects.equals(args[a], candidate)) {                     return true.                 }             }             return false.         }, () -> {             try {                 return makeArg(ctor.getDeclaringClass(), argTypes[currentArgIndex]).             } catch (Exception e) {                 throw new RuntimeException(e).             }         }).     }     return args. }
true;private;1;8;/**  * Make an argument to feed the {@link #subclass}'s ctor.  */ ;/**  * Make an argument to feed the {@link #subclass}'s ctor.  */ private Object makeArg(Type argType) {     try {         return makeArg(subclass, argType).     } catch (Exception e) {         // Wrap to make `randomValueOtherThan` happy.         throw new RuntimeException(e).     } }
false;public;0;4;;@Override public Object get() {     return o. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(o). }
false;public;1;8;;@Override public boolean equals(Object obj) {     if (obj == null || obj.getClass() != getClass()) {         return false.     }     Supplier<?> other = (Supplier<?>) obj.     return Objects.equals(o, other.get()). }
true;private,static;2;169;/**  * Make an argument to feed to the constructor for {@code toBuildClass}.  */ ;/**  * Make an argument to feed to the constructor for {@code toBuildClass}.  */ @SuppressWarnings("unchecked") private static Object makeArg(Class<? extends Node<?>> toBuildClass, Type argType) throws Exception {     if (argType instanceof ParameterizedType) {         ParameterizedType pt = (ParameterizedType) argType.         if (pt.getRawType() == Map.class) {             return makeMap(toBuildClass, pt).         }         if (pt.getRawType() == List.class) {             return makeList(toBuildClass, pt).         }         if (pt.getRawType() == EnumSet.class) {             @SuppressWarnings("rawtypes")             Enum enm = (Enum) makeArg(toBuildClass, pt.getActualTypeArguments()[0]).             return EnumSet.of(enm).         }         if (pt.getRawType() == Supplier.class) {             if (toBuildClass == AggExtractorInput.class) {                 // AggValueInput just needs a valid java type in a supplier                 Object o = randomBoolean() ? null : randomAlphaOfLength(5).                 // But the supplier has to implement equals for randomValueOtherThan                 return new Supplier<Object>() {                      @Override                     public Object get() {                         return o.                     }                      @Override                     public int hashCode() {                         return Objects.hash(o).                     }                      @Override                     public boolean equals(Object obj) {                         if (obj == null || obj.getClass() != getClass()) {                             return false.                         }                         Supplier<?> other = (Supplier<?>) obj.                         return Objects.equals(o, other.get()).                     }                 }.             }         }         throw new IllegalArgumentException("Unsupported parameterized type [" + pt + "]").     }     if (argType instanceof WildcardType) {         WildcardType wt = (WildcardType) argType.         if (wt.getLowerBounds().length > 0 || wt.getUpperBounds().length > 1) {             throw new IllegalArgumentException("Unsupported wildcard type [" + wt + "]").         }         return makeArg(toBuildClass, wt.getUpperBounds()[0]).     }     Class<?> argClass = (Class<?>) argType.     /*          * Sometimes all of the required type information isn't in the ctor          * so we have to hard code it here.          */     if (toBuildClass == InnerAggregate.class) {         // InnerAggregate's AggregateFunction must be an EnclosedAgg. Avg is.         if (argClass == AggregateFunction.class) {             return makeNode(Avg.class).         }     } else if (toBuildClass == FieldAttribute.class) {         // `parent` is nullable.         if (argClass == FieldAttribute.class && randomBoolean()) {             return null.         }     } else if (toBuildClass == ChildrenAreAProperty.class) {         /*              * While any subclass of DummyFunction will do here we want to prevent              * stack overflow so we use the one without children.              */         if (argClass == Dummy.class) {             return makeNode(NoChildren.class).         }     } else if (FullTextPredicate.class.isAssignableFrom(toBuildClass)) {         /*              * FullTextPredicate analyzes its string arguments on              * construction so they have to be valid.              */         if (argClass == String.class) {             int size = between(0, 5).             StringBuilder b = new StringBuilder().             for (int i = 0. i < size. i++) {                 if (i != 0) {                     b.append('.').                 }                 b.append(randomAlphaOfLength(5)).append('=').append(randomAlphaOfLength(5)).             }             return b.toString().         }     } else if (toBuildClass == Like.class) {         if (argClass == LikePattern.class) {             return new LikePattern(randomAlphaOfLength(16), randomFrom('\\', '|', '/', '`')).         }     } else if (toBuildClass == Histogram.class) {         if (argClass == Expression.class) {             return LiteralTests.randomLiteral().         }     } else if (toBuildClass == CurrentDateTime.class) {         if (argClass == Expression.class) {             return Literal.of(SourceTests.randomSource(), randomInt(9)).         }     }     if (Expression.class == argClass) {         /*              * Rather than use any old subclass of expression lets              * use a simple one. Without this we're very prone to              * stackoverflow errors while building the tree.              */         return UnresolvedAttributeTests.randomUnresolvedAttribute().     }     if (Pipe.class == argClass) {         /*              * Similar to expressions, mock pipes to avoid              * stackoverflow errors while building the tree.              */         return BinaryPipesTests.randomUnaryPipe().     }     if (Processor.class == argClass) {         /*              * Similar to expressions, mock pipes to avoid              * stackoverflow errors while building the tree.              */         return new ConstantProcessor(randomAlphaOfLength(16)).     }     if (Node.class.isAssignableFrom(argClass)) {         /*              * Rather than attempting to mock subclasses of node              * and emulate them we just try and instantiate an              * appropriate subclass              */         // safe because this is the lowest possible bounds for Node         @SuppressWarnings("unchecked")         Class<? extends Node<?>> asNodeSubclass = (Class<? extends Node<?>>) argType.         return makeNode(asNodeSubclass).     }     if (argClass.isEnum()) {         // Can't mock enums but luckily we can just pick one         return randomFrom(argClass.getEnumConstants()).     }     if (argClass == boolean.class) {         // Can't mock primitives....         return randomBoolean().     }     if (argClass == int.class) {         return randomInt().     }     if (argClass == String.class) {         // Nor strings         return randomAlphaOfLength(5).     }     if (argClass == Source.class) {         // Location is final and can't be mocked but we have a handy method to generate ones.         return SourceTests.randomSource().     }     try {         return mock(argClass).     } catch (MockitoException e) {         throw new RuntimeException("failed to mock [" + argClass.getName() + "] for [" + toBuildClass.getName() + "]", e).     } }
false;private,static;2;3;;private static List<?> makeList(Class<? extends Node<?>> toBuildClass, ParameterizedType listType) throws Exception {     return makeList(toBuildClass, listType, randomSizeForCollection(toBuildClass)). }
false;private,static;3;7;;private static List<?> makeList(Class<? extends Node<?>> toBuildClass, ParameterizedType listType, int size) throws Exception {     List<Object> list = new ArrayList<>().     for (int i = 0. i < size. i++) {         list.add(makeArg(toBuildClass, listType.getActualTypeArguments()[0])).     }     return list. }
false;private,static;2;10;;private static Object makeMap(Class<? extends Node<?>> toBuildClass, ParameterizedType pt) throws Exception {     Map<Object, Object> map = new HashMap<>().     int size = randomSizeForCollection(toBuildClass).     while (map.size() < size) {         Object key = makeArg(toBuildClass, pt.getActualTypeArguments()[0]).         Object value = makeArg(toBuildClass, pt.getActualTypeArguments()[1]).         map.put(key, value).     }     return map. }
false;private,static;1;9;;private static int randomSizeForCollection(Class<? extends Node<?>> toBuildClass) {     int minCollectionLength = 0.     int maxCollectionLength = 10.     if (CLASSES_WITH_MIN_TWO_CHILDREN.stream().anyMatch(c -> c == toBuildClass)) {         minCollectionLength = 2.     }     return between(minCollectionLength, maxCollectionLength). }
false;private;2;13;;private List<?> makeListOfSameSizeOtherThan(Type listType, List<?> original) throws Exception {     if (original.isEmpty()) {         throw new IllegalArgumentException("Can't make a different empty list").     }     return randomValueOtherThan(original, () -> {         try {             return makeList(subclass, (ParameterizedType) listType, original.size()).         } catch (Exception e) {             throw new RuntimeException(e).         }     }). }
false;public,static;1;14;;public static <T extends Node<?>> T makeNode(Class<? extends T> nodeClass) throws Exception {     if (Modifier.isAbstract(nodeClass.getModifiers())) {         nodeClass = randomFrom(subclassesOf(nodeClass)).     }     Class<?> testSubclassFor = testClassFor(nodeClass).     if (testSubclassFor != null) {         // Delegate to the test class for a node if there is one         Method m = testSubclassFor.getMethod("random" + Strings.capitalize(nodeClass.getSimpleName())).         return nodeClass.cast(m.invoke(null)).     }     Constructor<? extends T> ctor = longestCtor(nodeClass).     Object[] nodeCtorArgs = ctorArgs(ctor).     return ctor.newInstance(nodeCtorArgs). }
false;public;2;31;;@Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {     if (Files.isRegularFile(file) && file.getFileName().toString().endsWith(".class")) {         String className = file.toString().         // Chop off the root and file extension         className = className.substring(rootLength, className.length() - ".class".length()).         // Go from "path" style to class style         className = className.replace(PathUtils.getDefaultFileSystem().getSeparator(), ".").         // (and IDE folders like eclipse)         if (!className.startsWith("org.elasticsearch.xpack.sql")) {             return FileVisitResult.CONTINUE.         }         Class<?> c.         try {             c = Class.forName(className).         } catch (ClassNotFoundException e) {             throw new IOException("Couldn't find " + file, e).         }         if (false == Modifier.isAbstract(c.getModifiers()) && false == c.isAnonymousClass() && clazz.isAssignableFrom(c)) {             Class<? extends T> s = c.asSubclass(clazz).             results.add(s).         }     }     return FileVisitResult.CONTINUE. }
true;public,static;1;49;/**  * Find all subclasses of a particular class.  */ ;/**  * Find all subclasses of a particular class.  */ public static <T> List<Class<? extends T>> subclassesOf(Class<T> clazz) throws IOException {     // The map is built this way     @SuppressWarnings("unchecked")     List<Class<? extends T>> lookup = (List<Class<? extends T>>) subclassCache.get(clazz).     if (lookup != null) {         return lookup.     }     List<Class<? extends T>> results = new ArrayList<>().     String[] paths = System.getProperty("java.class.path").split(System.getProperty("path.separator")).     for (String path : paths) {         Path root = PathUtils.get(path).         int rootLength = root.toString().length() + 1.         Files.walkFileTree(root, new SimpleFileVisitor<Path>() {              @Override             public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {                 if (Files.isRegularFile(file) && file.getFileName().toString().endsWith(".class")) {                     String className = file.toString().                     // Chop off the root and file extension                     className = className.substring(rootLength, className.length() - ".class".length()).                     // Go from "path" style to class style                     className = className.replace(PathUtils.getDefaultFileSystem().getSeparator(), ".").                     // (and IDE folders like eclipse)                     if (!className.startsWith("org.elasticsearch.xpack.sql")) {                         return FileVisitResult.CONTINUE.                     }                     Class<?> c.                     try {                         c = Class.forName(className).                     } catch (ClassNotFoundException e) {                         throw new IOException("Couldn't find " + file, e).                     }                     if (false == Modifier.isAbstract(c.getModifiers()) && false == c.isAnonymousClass() && clazz.isAssignableFrom(c)) {                         Class<? extends T> s = c.asSubclass(clazz).                         results.add(s).                     }                 }                 return FileVisitResult.CONTINUE.             }         }).     }     subclassCache.put(clazz, results).     return results. }
true;private,static;1;12;/**  * The test class for some subclass of node or {@code null}  * if there isn't such a class or it doesn't extend  * {@link AbstractNodeTestCase}.  */ ;/**  * The test class for some subclass of node or {@code null}  * if there isn't such a class or it doesn't extend  * {@link AbstractNodeTestCase}.  */ private static Class<?> testClassFor(Class<?> nodeSubclass) {     String testClassName = nodeSubclass.getName() + "Tests".     try {         Class<?> c = Class.forName(testClassName).         if (AbstractNodeTestCase.class.isAssignableFrom(c)) {             return c.         }         return null.     } catch (ClassNotFoundException e) {         return null.     } }
