commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;11;;public static PagingListCursor randomPagingListCursor() {     int size = between(1, 20).     int depth = between(1, 20).     List<List<?>> values = new ArrayList<>(size).     for (int i = 0. i < size. i++) {         values.add(Arrays.asList(randomArray(depth, s -> new Object[depth], () -> randomByte()))).     }     return new PagingListCursor(values, depth, between(1, 20)). }
false;protected;1;6;;@Override protected PagingListCursor mutateInstance(PagingListCursor instance) throws IOException {     return new PagingListCursor(instance.data(), instance.columnCount(), randomValueOtherThan(instance.pageSize(), () -> between(1, 20))). }
false;protected;0;4;;@Override protected NamedWriteableRegistry getNamedWriteableRegistry() {     return new NamedWriteableRegistry(Cursors.getNamedWriteables()). }
false;protected;0;4;;@Override protected PagingListCursor createTestInstance() {     return randomPagingListCursor(). }
false;protected;0;4;;@Override protected Reader<PagingListCursor> instanceReader() {     return PagingListCursor::new. }
false;protected;2;9;;@Override protected PagingListCursor copyInstance(PagingListCursor instance, Version version) throws IOException {     /* Randomly choose between internal protocol round trip and String based          * round trips used to toXContent. */     if (randomBoolean()) {         return super.copyInstance(instance, version).     }     return (PagingListCursor) Cursors.decodeFromString(Cursors.encodeToString(version, instance)). }
