commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;11;;@Override protected LocateFunctionProcessor createTestInstance() {     // the "start" parameter is optional and is treated as null in the constructor     // when it is not used. Need to take this into account when generating random     // values for it.     Integer start = frequently() ? randomInt() : null.     return new LocateFunctionProcessor(new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)), new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)), new ConstantProcessor(start)). }
false;protected;0;4;;@Override protected Reader<LocateFunctionProcessor> instanceReader() {     return LocateFunctionProcessor::new. }
false;protected;0;4;;@Override protected NamedWriteableRegistry getNamedWriteableRegistry() {     return new NamedWriteableRegistry(Processors.getNamedWriteables()). }
false;public;0;4;;public void testLocateFunctionWithValidInput() {     assertEquals(4, new Locate(EMPTY, l("bar"), l("foobarbar"), l(null)).makePipe().asProcessor().process(null)).     assertEquals(7, new Locate(EMPTY, l("bar"), l("foobarbar"), l(5)).makePipe().asProcessor().process(null)). }
false;public;0;11;;public void testLocateFunctionWithEdgeCasesInputs() {     assertEquals(4, new Locate(EMPTY, l("bar"), l("foobarbar"), l(null)).makePipe().asProcessor().process(null)).     assertNull(new Locate(EMPTY, l("bar"), l(null), l(3)).makePipe().asProcessor().process(null)).     assertEquals(0, new Locate(EMPTY, l(null), l("foobarbar"), l(null)).makePipe().asProcessor().process(null)).     assertEquals(0, new Locate(EMPTY, l(null), l("foobarbar"), l(null)).makePipe().asProcessor().process(null)).     assertEquals(1, new Locate(EMPTY, l("foo"), l("foobarbar"), l(null)).makePipe().asProcessor().process(null)).     assertEquals(1, new Locate(EMPTY, l('o'), l('o'), l(null)).makePipe().asProcessor().process(null)).     assertEquals(9, new Locate(EMPTY, l('r'), l("foobarbar"), l(9)).makePipe().asProcessor().process(null)).     assertEquals(4, new Locate(EMPTY, l("bar"), l("foobarbar"), l(-3)).makePipe().asProcessor().process(null)). }
false;public;0;11;;public void testLocateFunctionValidatingInputs() {     SqlIllegalArgumentException siae = expectThrows(SqlIllegalArgumentException.class, () -> new Locate(EMPTY, l(5), l("foobarbar"), l(3)).makePipe().asProcessor().process(null)).     assertEquals("A string/char is required. received [5]", siae.getMessage()).     siae = expectThrows(SqlIllegalArgumentException.class, () -> new Locate(EMPTY, l("foo"), l(1), l(3)).makePipe().asProcessor().process(null)).     assertEquals("A string/char is required. received [1]", siae.getMessage()).     siae = expectThrows(SqlIllegalArgumentException.class, () -> new Locate(EMPTY, l("foobarbar"), l("bar"), l('c')).makePipe().asProcessor().process(null)).     assertEquals("A number is required. received [c]", siae.getMessage()). }
