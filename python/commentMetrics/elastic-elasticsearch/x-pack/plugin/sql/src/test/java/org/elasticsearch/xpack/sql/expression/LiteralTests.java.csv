commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;public static Literal randomLiteral() {     ValueAndCompatibleTypes gen = randomFrom(GENERATORS).     return new Literal(SourceTests.randomSource(), gen.valueSupplier.get(), randomFrom(gen.validDataTypes)). }
false;protected;0;4;;@Override protected Literal randomInstance() {     return randomLiteral(). }
false;protected;1;4;;@Override protected Literal copy(Literal instance) {     return new Literal(instance.source(), instance.name(), instance.value(), instance.dataType()). }
false;protected;1;13;;@Override protected Literal mutate(Literal instance) {     List<Function<Literal, Literal>> mutators = new ArrayList<>().     // Changing the location doesn't count as mutation because..... it just doesn't, ok?!     // Change the value to another valid value     mutators.add(l -> new Literal(l.source(), randomValueOfTypeOtherThan(l.value(), l.dataType()), l.dataType())).     // If we can change the data type then add that as an option as well     List<DataType> validDataTypes = validReplacementDataTypes(instance.value(), instance.dataType()).     if (validDataTypes.size() > 1) {         mutators.add(l -> new Literal(l.source(), l.value(), randomValueOtherThan(l.dataType(), () -> randomFrom(validDataTypes)))).     }     return randomFrom(mutators).apply(instance). }
false;public;0;17;;@Override public void testTransform() {     Literal literal = randomInstance().     // Replace value     Object newValue = randomValueOfTypeOtherThan(literal.value(), literal.dataType()).     assertEquals(new Literal(literal.source(), newValue, literal.dataType()), literal.transformPropertiesOnly(p -> p == literal.value() ? newValue : p, Object.class)).     // Replace data type if there are more compatible data types     List<DataType> validDataTypes = validReplacementDataTypes(literal.value(), literal.dataType()).     if (validDataTypes.size() > 1) {         DataType newDataType = randomValueOtherThan(literal.dataType(), () -> randomFrom(validDataTypes)).         assertEquals(new Literal(literal.source(), literal.value(), newDataType), literal.transformPropertiesOnly(p -> newDataType, DataType.class)).     } }
false;public;0;5;;@Override public void testReplaceChildren() {     Exception e = expectThrows(UnsupportedOperationException.class, () -> randomInstance().replaceChildren(emptyList())).     assertEquals("this type of node doesn't have any children to replace", e.getMessage()). }
false;private;2;8;;private Object randomValueOfTypeOtherThan(Object original, DataType type) {     for (ValueAndCompatibleTypes gen : GENERATORS) {         if (gen.validDataTypes.get(0) == type) {             return randomValueOtherThan(original, () -> DataTypeConversion.convert(gen.valueSupplier.get(), type)).         }     }     throw new IllegalArgumentException("No native generator for [" + type + "]"). }
false;private;2;15;;private List<DataType> validReplacementDataTypes(Object value, DataType type) {     List<DataType> validDataTypes = new ArrayList<>().     List<DataType> options = Arrays.asList(DataType.BYTE, DataType.SHORT, DataType.INTEGER, DataType.LONG, DataType.FLOAT, DataType.DOUBLE, DataType.BOOLEAN).     for (DataType candidate : options) {         try {             DataTypeConversion.Conversion c = DataTypeConversion.conversionFor(type, candidate).             c.convert(value).             validDataTypes.add(candidate).         } catch (SqlIllegalArgumentException e) {         // invalid conversion then....         }     }     return validDataTypes. }
