commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean ignoreExternalCluster() {     return true. }
false;public;0;4;;@Before public void resetLicensing() throws Exception {     enableJdbcLicensing(). }
false;protected;0;7;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     // Add Netty so we can test JDBC licensing because only exists on the REST layer.     List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins()).     plugins.add(Netty4Plugin.class).     return plugins. }
false;protected;0;4;;@Override protected boolean addMockHttpTransport() {     // enable http     return false. }
false;protected;1;9;;@Override protected Settings nodeSettings(int nodeOrdinal) {     // Enable http so we can test JDBC licensing because only exists on the REST layer.     String httpPlugin = randomBoolean() ? Netty4Plugin.NETTY_HTTP_TRANSPORT_NAME : NioTransportPlugin.NIO_TRANSPORT_NAME.     return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(NetworkModule.HTTP_TYPE_KEY, httpPlugin).build(). }
false;private,static;0;3;;private static OperationMode randomValidSqlLicenseType() {     return randomTrialBasicStandardGoldOrPlatinumMode(). }
false;private,static;0;3;;private static OperationMode randomInvalidSqlLicenseType() {     return OperationMode.MISSING. }
false;private,static;0;3;;private static OperationMode randomValidJdbcLicenseType() {     return randomTrialOrPlatinumMode(). }
false;private,static;0;3;;private static OperationMode randomInvalidJdbcLicenseType() {     return randomBasicStandardOrGold(). }
false;public;0;3;;public void enableSqlLicensing() throws Exception {     updateLicensing(randomValidSqlLicenseType()). }
false;public;0;3;;public void disableSqlLicensing() throws Exception {     updateLicensing(randomInvalidSqlLicenseType()). }
false;public;0;3;;public void enableJdbcLicensing() throws Exception {     updateLicensing(randomValidJdbcLicenseType()). }
false;public;0;3;;public void disableJdbcLicensing() throws Exception {     updateLicensing(randomInvalidJdbcLicenseType()). }
false;public;1;10;;public void updateLicensing(OperationMode licenseOperationMode) throws Exception {     String licenseType = licenseOperationMode.name().toLowerCase(Locale.ROOT).     wipeAllLicenses().     if (licenseType.equals("missing")) {         putLicenseTombstone().     } else {         License license = org.elasticsearch.license.TestUtils.generateSignedLicense(licenseType, TimeValue.timeValueMinutes(1)).         putLicense(license).     } }
false;public;0;12;;public void testSqlQueryActionLicense() throws Exception {     setupTestIndex().     disableSqlLicensing().     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> new SqlQueryRequestBuilder(client(), SqlQueryAction.INSTANCE).query("SELECT * FROM test").get()).     assertThat(e.getMessage(), equalTo("current license is non-compliant for [sql]")).     enableSqlLicensing().     SqlQueryResponse response = new SqlQueryRequestBuilder(client(), SqlQueryAction.INSTANCE).query("SELECT * FROM test").get().     assertThat(response.size(), Matchers.equalTo(2L)). }
false;public;0;13;;public void testSqlQueryActionJdbcModeLicense() throws Exception {     setupTestIndex().     disableJdbcLicensing().     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> new SqlQueryRequestBuilder(client(), SqlQueryAction.INSTANCE).query("SELECT * FROM test").mode("jdbc").get()).     assertThat(e.getMessage(), equalTo("current license is non-compliant for [jdbc]")).     enableJdbcLicensing().     SqlQueryResponse response = new SqlQueryRequestBuilder(client(), SqlQueryAction.INSTANCE).query("SELECT * FROM test").mode("jdbc").get().     assertThat(response.size(), Matchers.equalTo(2L)). }
false;public;0;17;;public void testSqlTranslateActionLicense() throws Exception {     setupTestIndex().     disableSqlLicensing().     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> new SqlTranslateRequestBuilder(client(), SqlTranslateAction.INSTANCE).query("SELECT * FROM test").get()).     assertThat(e.getMessage(), equalTo("current license is non-compliant for [sql]")).     enableSqlLicensing().     SqlTranslateResponse response = new SqlTranslateRequestBuilder(client(), SqlTranslateAction.INSTANCE).query("SELECT * FROM test").get().     SearchSourceBuilder source = response.source().     assertThat(source.docValueFields(), Matchers.contains(new DocValueFieldsContext.FieldAndFormat("count", null))).     FetchSourceContext fetchSource = source.fetchSource().     assertThat(fetchSource.includes(), Matchers.arrayContaining("data")). }
false;private;0;8;;// TODO test SqlGetIndicesAction. Skipping for now because of lack of serialization support. private void setupTestIndex() {     ElasticsearchAssertions.assertAcked(client().admin().indices().prepareCreate("test").get()).     client().prepareBulk().add(new IndexRequest("test").id("1").source("data", "bar", "count", 42)).add(new IndexRequest("test").id("2").source("data", "baz", "count", 43)).setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).get(). }
