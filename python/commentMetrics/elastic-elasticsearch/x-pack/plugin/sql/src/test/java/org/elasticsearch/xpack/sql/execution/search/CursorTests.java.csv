commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;public void testEmptyCursorClearCursor() {     Client clientMock = mock(Client.class).     Cursor cursor = Cursor.EMPTY.     PlainActionFuture<Boolean> future = newFuture().     cursor.clear(TestUtils.TEST_CFG, clientMock, future).     assertFalse(future.actionGet()).     verifyZeroInteractions(clientMock). }
false;public;0;14;;@SuppressWarnings("unchecked") public void testScrollCursorClearCursor() {     Client clientMock = mock(Client.class).     ActionListener<Boolean> listenerMock = mock(ActionListener.class).     String cursorString = randomAlphaOfLength(10).     Cursor cursor = new ScrollCursor(cursorString, Collections.emptyList(), new BitSet(0), randomInt()).     cursor.clear(TestUtils.TEST_CFG, clientMock, listenerMock).     ArgumentCaptor<ClearScrollRequest> request = ArgumentCaptor.forClass(ClearScrollRequest.class).     verify(clientMock).clearScroll(request.capture(), any(ActionListener.class)).     assertEquals(Collections.singletonList(cursorString), request.getValue().getScrollIds()).     verifyZeroInteractions(listenerMock). }
false;private,static;0;12;;private static SqlQueryResponse createRandomSqlResponse() {     int columnCount = between(1, 10).     List<ColumnInfo> columns = null.     if (randomBoolean()) {         columns = new ArrayList<>(columnCount).         for (int i = 0. i < columnCount. i++) {             columns.add(new ColumnInfo(randomAlphaOfLength(10), randomAlphaOfLength(10), randomAlphaOfLength(10), randomInt(25))).         }     }     return new SqlQueryResponse("", randomFrom(Mode.values()), false, columns, Collections.emptyList()). }
false;static;0;25;;@SuppressWarnings("unchecked") static Cursor randomNonEmptyCursor() {     Supplier<Cursor> cursorSupplier = randomFrom(() -> ScrollCursorTests.randomScrollCursor(), () -> {         SqlQueryResponse response = createRandomSqlResponse().         if (response.columns() != null && response.rows() != null) {             return TextFormatterCursor.wrap(ScrollCursorTests.randomScrollCursor(), new BasicFormatter(response.columns(), response.rows(), CLI)).         } else {             return ScrollCursorTests.randomScrollCursor().         }     }, () -> {         SqlQueryResponse response = createRandomSqlResponse().         if (response.columns() != null && response.rows() != null) {             return TextFormatterCursor.wrap(ScrollCursorTests.randomScrollCursor(), new BasicFormatter(response.columns(), response.rows(), TEXT)).         } else {             return ScrollCursorTests.randomScrollCursor().         }     }).     return cursorSupplier.get(). }
false;public;0;11;;public void testVersionHandling() {     Cursor cursor = randomNonEmptyCursor().     assertEquals(cursor, Cursors.decodeFromString(Cursors.encodeToString(Version.CURRENT, cursor))).     Version nextMinorVersion = Version.fromId(Version.CURRENT.id + 10000).     String encodedWithWrongVersion = Cursors.encodeToString(nextMinorVersion, cursor).     SqlException exception = expectThrows(SqlException.class, () -> Cursors.decodeFromString(encodedWithWrongVersion)).     assertEquals("Unsupported cursor version " + nextMinorVersion, exception.getMessage()). }
