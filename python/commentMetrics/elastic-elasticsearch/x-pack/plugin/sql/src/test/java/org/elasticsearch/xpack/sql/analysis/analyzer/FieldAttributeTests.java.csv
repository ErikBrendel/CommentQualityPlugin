commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private LogicalPlan plan(String sql) {     return analyzer.analyze(parser.createStatement(sql), true). }
false;private;1;19;;private FieldAttribute attribute(String fieldName) {     // test multiple version of the attribute name     // to make sure all match the same thing     // NB: the equality is done on the same since each plan bumps the expression counter     // unqualified     FieldAttribute unqualified = parseQueryFor(fieldName).     // unquoted qualifier     FieldAttribute unquotedQualifier = parseQueryFor("test." + fieldName).     assertEquals(unqualified.name(), unquotedQualifier.name()).     assertEquals(unqualified.qualifiedName(), unquotedQualifier.qualifiedName()).     // quoted qualifier     FieldAttribute quotedQualifier = parseQueryFor("\"test\"." + fieldName).     assertEquals(unqualified.name(), quotedQualifier.name()).     assertEquals(unqualified.qualifiedName(), quotedQualifier.qualifiedName()).     return randomFrom(unqualified, unquotedQualifier, quotedQualifier). }
false;private;1;10;;private FieldAttribute parseQueryFor(String fieldName) {     LogicalPlan plan = plan("SELECT " + fieldName + " FROM test").     assertThat(plan, instanceOf(Project.class)).     Project p = (Project) plan.     List<? extends NamedExpression> projections = p.projections().     assertThat(projections, hasSize(1)).     Attribute attribute = projections.get(0).toAttribute().     assertThat(attribute, instanceOf(FieldAttribute.class)).     return (FieldAttribute) attribute. }
false;private;1;4;;private String error(String fieldName) {     VerificationException ve = expectThrows(VerificationException.class, () -> plan("SELECT " + fieldName + " FROM test")).     return ve.getMessage(). }
false;public;0;5;;public void testRootField() {     FieldAttribute attr = attribute("bool").     assertThat(attr.name(), is("bool")).     assertThat(attr.dataType(), is(BOOLEAN)). }
false;public;0;6;;public void testDottedField() {     FieldAttribute attr = attribute("some.dotted.field").     assertThat(attr.path(), is("some.dotted")).     assertThat(attr.name(), is("some.dotted.field")).     assertThat(attr.dataType(), is(KEYWORD)). }
false;public;0;11;;public void testExactKeyword() {     FieldAttribute attr = attribute("some.string").     assertThat(attr.path(), is("some")).     assertThat(attr.name(), is("some.string")).     assertThat(attr.dataType(), is(DataType.TEXT)).     assertTrue(attr.getExactInfo().hasExact()).     FieldAttribute exact = attr.exactAttribute().     assertTrue(exact.getExactInfo().hasExact()).     assertThat(exact.name(), is("some.string.typical")).     assertThat(exact.dataType(), is(KEYWORD)). }
false;public;0;12;;public void testAmbiguousExactKeyword() {     FieldAttribute attr = attribute("some.ambiguous").     assertThat(attr.path(), is("some")).     assertThat(attr.name(), is("some.ambiguous")).     assertThat(attr.dataType(), is(DataType.TEXT)).     assertFalse(attr.getExactInfo().hasExact()).     assertThat(attr.getExactInfo().errorMsg(), is("Multiple exact keyword candidates available for [ambiguous]. specify which one to use")).     SqlIllegalArgumentException e = expectThrows(SqlIllegalArgumentException.class, () -> attr.exactAttribute()).     assertThat(e.getMessage(), is("Multiple exact keyword candidates available for [ambiguous]. specify which one to use")). }
false;public;0;7;;public void testNormalizedKeyword() {     FieldAttribute attr = attribute("some.string.normalized").     assertThat(attr.path(), is("some.string")).     assertThat(attr.name(), is("some.string.normalized")).     assertThat(attr.dataType(), is(KEYWORD)).     assertFalse(attr.getExactInfo().hasExact()). }
false;public;0;3;;public void testDottedFieldPath() {     assertThat(error("some"), is("Found 1 problem(s)\nline 1:8: Cannot use field [some] type [object] only its subfields")). }
false;public;0;4;;public void testDottedFieldPathDeeper() {     assertThat(error("some.dotted"), is("Found 1 problem(s)\nline 1:8: Cannot use field [some.dotted] type [object] only its subfields")). }
false;public;0;4;;public void testDottedFieldPathTypo() {     assertThat(error("some.dotted.fild"), is("Found 1 problem(s)\nline 1:8: Unknown column [some.dotted.fild], did you mean [some.dotted.field]?")). }
false;public;0;10;;public void testStarExpansionExcludesObjectAndUnsupportedTypes() {     LogicalPlan plan = plan("SELECT * FROM test").     List<? extends NamedExpression> list = ((Project) plan).projections().     assertThat(list, hasSize(8)).     List<String> names = Expressions.names(list).     assertThat(names, not(hasItem("some"))).     assertThat(names, not(hasItem("some.dotted"))).     assertThat(names, not(hasItem("unsupported"))).     assertThat(names, hasItems("bool", "text", "keyword", "int")). }
false;public;0;33;;public void testFieldAmbiguity() {     Map<String, EsField> mapping = TypesTests.loadMapping("mapping-dotted-field.json").     EsIndex index = new EsIndex("test", mapping).     getIndexResult = IndexResolution.valid(index).     analyzer = new Analyzer(TestUtils.TEST_CFG, functionRegistry, getIndexResult, verifier).     VerificationException ex = expectThrows(VerificationException.class, () -> plan("SELECT test.bar FROM test")).     assertEquals("Found 1 problem(s)\nline 1:8: Reference [test.bar] is ambiguous (to disambiguate use quotes or qualifiers). " + "matches any of [\"test\".\"bar\", \"test\".\"test.bar\"]", ex.getMessage()).     ex = expectThrows(VerificationException.class, () -> plan("SELECT test.test FROM test")).     assertEquals("Found 1 problem(s)\nline 1:8: Reference [test.test] is ambiguous (to disambiguate use quotes or qualifiers). " + "matches any of [\"test\".\"test\", \"test\".\"test.test\"]", ex.getMessage()).     LogicalPlan plan = plan("SELECT test.test FROM test AS x").     assertThat(plan, instanceOf(Project.class)).     plan = plan("SELECT \"test\".test.test FROM test").     assertThat(plan, instanceOf(Project.class)).     Project p = (Project) plan.     List<? extends NamedExpression> projections = p.projections().     assertThat(projections, hasSize(1)).     Attribute attribute = projections.get(0).toAttribute().     assertThat(attribute, instanceOf(FieldAttribute.class)).     assertThat(attribute.qualifier(), is("test")).     assertThat(attribute.name(), is("test.test")). }
