commented;modifiers;parameterAmount;loc;comment;code
false;private;1;6;;private String error(String pattern) {     ParsingException ex = expectThrows(ParsingException.class, () -> parser.createExpression(format(null, "exp LIKE {}", pattern))).     return ex.getMessage(). }
false;private;1;12;;private LikePattern like(String pattern) {     Expression exp = null.     boolean parameterized = randomBoolean().     if (parameterized) {         exp = parser.createExpression("exp LIKE ?", singletonList(new SqlTypedParamValue(DataType.KEYWORD.typeName, pattern))).     } else {         exp = parser.createExpression(format(null, "exp LIKE '{}'", pattern)).     }     assertThat(exp, instanceOf(Like.class)).     Like l = (Like) exp.     return l.pattern(). }
false;public;0;6;;public void testNoEscaping() {     LikePattern like = like("string").     assertThat(like.pattern(), is("string")).     assertThat(like.asJavaRegex(), is("^string$")).     assertThat(like.asLuceneWildcard(), is("string")). }
false;public;0;4;;public void testEscapingLastChar() {     assertThat(error("'string|' ESCAPE '|'"), is("line 1:11: Pattern [string|] is invalid as escape char [|] at position 6 does not escape anything")). }
false;public;0;4;;public void testEscapingWrongChar() {     assertThat(error("'|string' ESCAPE '|'"), is("line 1:11: Pattern [|string] is invalid as escape char [|] at position 0 can only escape wildcard chars. found [s]")). }
false;public;0;4;;public void testInvalidChar() {     assertThat(error("'%string' ESCAPE '%'"), is("line 1:28: Char [%] cannot be used for escaping")). }
false;public;0;4;;public void testCannotUseStar() {     assertThat(error("'|*string' ESCAPE '|'"), is("line 1:11: Invalid char [*] found in pattern [|*string] at position 1. use [%] or [_] instead")). }
