commented;modifiers;parameterAmount;loc;comment;code
false;static;1;9;;static Query randomQuery(int depth) {     List<Supplier<Query>> options = new ArrayList<>().     options.add(MatchQueryTests::randomMatchQuery).     if (depth > 0) {         options.add(() -> randomNestedQuery(depth - 1)).         options.add(() -> BoolQueryTests.randomBoolQuery(depth - 1)).     }     return randomFrom(options).get(). }
false;static;1;3;;static NestedQuery randomNestedQuery(int depth) {     return new NestedQuery(SourceTests.randomSource(), randomAlphaOfLength(5), randomFields(), randomQuery(depth)). }
false;private,static;0;8;;private static Map<String, Map.Entry<Boolean, String>> randomFields() {     int size = between(0, 5).     Map<String, Map.Entry<Boolean, String>> fields = new HashMap<>(size).     while (fields.size() < size) {         fields.put(randomAlphaOfLength(5), new SimpleImmutableEntry<>(randomBoolean(), null)).     }     return fields. }
false;public;0;3;;public void testEqualsAndHashCode() {     checkEqualsAndHashCode(randomNestedQuery(5), NestedQueryTests::copy, NestedQueryTests::mutate). }
false;private,static;1;3;;private static NestedQuery copy(NestedQuery query) {     return new NestedQuery(query.source(), query.path(), query.fields(), query.child()). }
false;private,static;1;8;;private static NestedQuery mutate(NestedQuery query) {     List<Function<NestedQuery, NestedQuery>> options = Arrays.asList(q -> new NestedQuery(SourceTests.mutate(q.source()), q.path(), q.fields(), q.child()), q -> new NestedQuery(q.source(), randomValueOtherThan(q.path(), () -> randomAlphaOfLength(5)), q.fields(), q.child()), q -> new NestedQuery(q.source(), q.path(), randomValueOtherThan(q.fields(), NestedQueryTests::randomFields), q.child()), q -> new NestedQuery(q.source(), q.path(), q.fields(), randomValueOtherThan(q.child(), () -> randomQuery(5)))).     return randomFrom(options).apply(query). }
false;public;0;8;;public void testContainsNestedField() {     NestedQuery q = randomNestedQuery(0).     for (String field : q.fields().keySet()) {         assertTrue(q.containsNestedField(q.path(), field)).         assertFalse(q.containsNestedField(randomValueOtherThan(q.path(), () -> randomAlphaOfLength(5)), field)).     }     assertFalse(q.containsNestedField(q.path(), randomValueOtherThanMany(q.fields()::containsKey, () -> randomAlphaOfLength(5)))). }
false;public;0;22;;public void testAddNestedField() {     NestedQuery q = randomNestedQuery(0).     for (String field : q.fields().keySet()) {         // add does nothing if the field is already there         assertSame(q, q.addNestedField(q.path(), field, null, randomBoolean())).         String otherPath = randomValueOtherThan(q.path(), () -> randomAlphaOfLength(5)).         // add does nothing if the path doesn't match         assertSame(q, q.addNestedField(otherPath, randomAlphaOfLength(5), null, randomBoolean())).     }     // if the field isn't in the list then add rewrites to a query with all the old fields and the new one     String newField = randomValueOtherThanMany(q.fields()::containsKey, () -> randomAlphaOfLength(5)).     boolean hasDocValues = randomBoolean().     NestedQuery added = (NestedQuery) q.addNestedField(q.path(), newField, null, hasDocValues).     assertNotSame(q, added).     assertThat(added.fields(), hasEntry(newField, new SimpleImmutableEntry<>(hasDocValues, null))).     assertTrue(added.containsNestedField(q.path(), newField)).     for (Map.Entry<String, Map.Entry<Boolean, String>> field : q.fields().entrySet()) {         assertThat(added.fields(), hasEntry(field.getKey(), field.getValue())).         assertTrue(added.containsNestedField(q.path(), field.getKey())).     } }
false;public;0;31;;public void testEnrichNestedSort() {     NestedQuery q = randomNestedQuery(0).     // enrich adds the filter if the path matches     {         NestedSortBuilder sort = new NestedSortBuilder(q.path()).         q.enrichNestedSort(sort).         assertEquals(q.child().asBuilder(), sort.getFilter()).     }     // but doesn't if it doesn't match     {         NestedSortBuilder sort = new NestedSortBuilder(randomValueOtherThan(q.path(), () -> randomAlphaOfLength(5))).         q.enrichNestedSort(sort).         assertNull(sort.getFilter()).     }     // enriching with the same query twice is fine     {         NestedSortBuilder sort = new NestedSortBuilder(q.path()).         q.enrichNestedSort(sort).         assertEquals(q.child().asBuilder(), sort.getFilter()).         q.enrichNestedSort(sort).         // But enriching using another query is not         NestedQuery other = new NestedQuery(SourceTests.randomSource(), q.path(), q.fields(), randomValueOtherThan(q.child(), () -> randomQuery(0))).         Exception e = expectThrows(SqlIllegalArgumentException.class, () -> other.enrichNestedSort(sort)).         assertEquals("nested query should have been grouped in one place", e.getMessage()).     } }
false;public;0;6;;public void testToString() {     NestedQuery q = new NestedQuery(new Source(1, 1, StringUtils.EMPTY), "a.b", singletonMap("f", new SimpleImmutableEntry<>(true, null)), new MatchAll(new Source(1, 1, StringUtils.EMPTY))).     assertEquals("NestedQuery@1:2[a.b.{f=true=null}[MatchAll@1:2[]]]", q.toString()). }
