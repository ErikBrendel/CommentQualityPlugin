commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected NodeInfo<? extends Literal> info() {     return NodeInfo.create(this, Literal::new, value, dataType). }
false;public;0;3;;public Object value() {     return value. }
false;public;0;4;;@Override public boolean foldable() {     return true. }
false;public;0;4;;@Override public Nullability nullable() {     return value == null ? Nullability.TRUE : Nullability.FALSE. }
false;public;0;4;;@Override public DataType dataType() {     return dataType. }
false;public;0;4;;@Override public boolean resolved() {     return true. }
false;public;0;4;;@Override public Object fold() {     return value. }
false;public;0;4;;@Override public Attribute toAttribute() {     return new LiteralAttribute(source(), name(), null, Nullability.FALSE, id(), false, dataType, this). }
false;public;0;4;;@Override public ScriptTemplate asScript() {     return new ScriptTemplate(String.valueOf(value), Params.EMPTY, dataType). }
false;public;1;4;;@Override public Expression replaceChildren(List<Expression> newChildren) {     throw new UnsupportedOperationException("this type of node doesn't have any children to replace"). }
false;public;0;4;;@Override public AttributeSet references() {     return AttributeSet.EMPTY. }
false;protected;0;5;;@Override protected Expression canonicalize() {     String s = String.valueOf(value).     return name().equals(s) ? this : Literal.of(source(), value). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(value, dataType). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     Literal other = (Literal) obj.     return Objects.equals(value, other.value) && Objects.equals(dataType, other.dataType). }
false;public;0;5;;@Override public String toString() {     String s = String.valueOf(value).     return name().equals(s) ? s : name() + "=" + value. }
true;public,static;2;6;/**  * Utility method for creating 'in-line' Literals (out of values instead of expressions).  */ ;/**  * Utility method for creating 'in-line' Literals (out of values instead of expressions).  */ public static Literal of(Source source, Object value) {     if (value instanceof Literal) {         return (Literal) value.     }     return new Literal(source, value, DataTypes.fromJava(value)). }
true;public,static;1;3;/**  * Utility method for creating a literal out of a foldable expression.  * Throws an exception if the expression is not foldable.  */ ;/**  * Utility method for creating a literal out of a foldable expression.  * Throws an exception if the expression is not foldable.  */ public static Literal of(Expression foldable) {     return of((String) null, foldable). }
false;public,static;2;19;;public static Literal of(String name, Expression foldable) {     if (!foldable.foldable()) {         throw new SqlIllegalArgumentException("Foldable expression required for Literal creation. received unfoldable " + foldable).     }     if (foldable instanceof Literal) {         Literal l = (Literal) foldable.         if (name == null || l.name().equals(name)) {             return l.         }     }     Object fold = foldable.fold().     if (name == null) {         name = foldable instanceof NamedExpression ? ((NamedExpression) foldable).name() : String.valueOf(fold).     }     return new Literal(foldable.source(), name, fold, foldable.dataType()). }
false;public,static;2;4;;public static Literal of(Expression source, Object value) {     String name = source instanceof NamedExpression ? ((NamedExpression) source).name() : String.valueOf(value).     return new Literal(source.source(), name, value, source.dataType()). }
