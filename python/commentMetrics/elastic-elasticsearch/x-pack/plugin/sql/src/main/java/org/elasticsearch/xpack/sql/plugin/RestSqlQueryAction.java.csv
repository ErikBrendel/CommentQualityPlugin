commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public RestResponse buildResponse(SqlQueryResponse response) throws Exception {     XContentBuilder builder = XContentBuilder.builder(xContentType.xContent()).     response.toXContent(builder, request).     return new BytesRestResponse(RestStatus.OK, builder). }
false;public;1;17;;@Override public RestResponse buildResponse(SqlQueryResponse response) throws Exception {     Cursor cursor = Cursors.decodeFromString(sqlRequest.cursor()).     final String data = textFormat.format(cursor, request, response).     RestResponse restResponse = new BytesRestResponse(RestStatus.OK, textFormat.contentType(request), data.getBytes(StandardCharsets.UTF_8)).     Cursor responseCursor = textFormat.wrapCursor(cursor, response).     if (responseCursor != Cursor.EMPTY) {         restResponse.addHeader("Cursor", Cursors.encodeToString(Version.CURRENT, responseCursor)).     }     restResponse.addHeader("Took-nanos", Long.toString(System.nanoTime() - startNanos)).     return restResponse. }
false;protected;2;82;;@Override protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {     SqlQueryRequest sqlRequest.     try (XContentParser parser = request.contentOrSourceParamParser()) {         sqlRequest = SqlQueryRequest.fromXContent(parser).     }     /*          * Since we support {@link TextFormat} <strong>and</strong>          * {@link XContent} outputs we can't use {@link RestToXContentListener}          * like everything else. We want to stick as closely as possible to          * Elasticsearch's defaults though, while still layering in ways to          * control the output more easilly.          *          * First we find the string that the user used to specify the response          * format. If there is a {@code format} paramter we use that. If there          * isn't but there is a {@code Accept} header then we use that. If there          * isn't then we use the {@code Content-Type} header which is required.          */     String accept = request.param("format").     if (accept == null) {         accept = request.header("Accept").         if ("*/*".equals(accept)) {             // */* means "I don't care" which we should treat like not specifying the header             accept = null.         }     }     if (accept == null) {         accept = request.header("Content-Type").     }     assert accept != null : "The Content-Type header is required".     /*          * Second, we pick the actual content type to use by first parsing the          * string from the previous step as an {@linkplain XContent} value. If          * that doesn't parse we parse it as a {@linkplain TextFormat} value. If          * that doesn't parse it'll throw an {@link IllegalArgumentException}          * which we turn into a 400 error.          */     XContentType xContentType = accept == null ? XContentType.JSON : XContentType.fromMediaTypeOrFormat(accept).     if (xContentType != null) {         return channel -> client.execute(SqlQueryAction.INSTANCE, sqlRequest, new RestResponseListener<SqlQueryResponse>(channel) {              @Override             public RestResponse buildResponse(SqlQueryResponse response) throws Exception {                 XContentBuilder builder = XContentBuilder.builder(xContentType.xContent()).                 response.toXContent(builder, request).                 return new BytesRestResponse(RestStatus.OK, builder).             }         }).     }     TextFormat textFormat = TextFormat.fromMediaTypeOrFormat(accept).     // which won't work in a columnar fashion     if (sqlRequest.columnar()) {         throw new IllegalArgumentException("Invalid use of [columnar] argument: cannot be used in combination with " + "txt, csv or tsv formats").     }     long startNanos = System.nanoTime().     return channel -> client.execute(SqlQueryAction.INSTANCE, sqlRequest, new RestResponseListener<SqlQueryResponse>(channel) {          @Override         public RestResponse buildResponse(SqlQueryResponse response) throws Exception {             Cursor cursor = Cursors.decodeFromString(sqlRequest.cursor()).             final String data = textFormat.format(cursor, request, response).             RestResponse restResponse = new BytesRestResponse(RestStatus.OK, textFormat.contentType(request), data.getBytes(StandardCharsets.UTF_8)).             Cursor responseCursor = textFormat.wrapCursor(cursor, response).             if (responseCursor != Cursor.EMPTY) {                 restResponse.addHeader("Cursor", Cursors.encodeToString(Version.CURRENT, responseCursor)).             }             restResponse.addHeader("Took-nanos", Long.toString(System.nanoTime() - startNanos)).             return restResponse.         }     }). }
false;public;0;4;;@Override public String getName() {     return "sql_query". }
