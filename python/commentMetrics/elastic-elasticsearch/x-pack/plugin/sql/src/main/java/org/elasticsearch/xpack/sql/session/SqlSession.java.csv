commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public FunctionRegistry functionRegistry() {     return functionRegistry. }
false;public;0;3;;public Client client() {     return client. }
false;public;0;3;;public Planner planner() {     return planner. }
false;public;0;3;;public IndexResolver indexResolver() {     return indexResolver. }
false;public;0;3;;public Optimizer optimizer() {     return optimizer. }
false;public;0;3;;public Verifier verifier() {     return verifier. }
false;public;0;3;;public PlanExecutor planExecutor() {     return planExecutor. }
false;private;2;3;;private LogicalPlan doParse(String sql, List<SqlTypedParamValue> params) {     return new SqlParser().createStatement(sql, params). }
false;public;3;11;;public void analyzedPlan(LogicalPlan parsed, boolean verify, ActionListener<LogicalPlan> listener) {     if (parsed.analyzed()) {         listener.onResponse(parsed).         return.     }     preAnalyze(parsed, c -> {         Analyzer analyzer = new Analyzer(configuration, functionRegistry, c, verifier).         return analyzer.analyze(parsed, verify).     }, listener). }
false;public;2;11;;public void debugAnalyzedPlan(LogicalPlan parsed, ActionListener<RuleExecutor<LogicalPlan>.ExecutionInfo> listener) {     if (parsed.analyzed()) {         listener.onResponse(null).         return.     }     preAnalyze(parsed, r -> {         Analyzer analyzer = new Analyzer(configuration, functionRegistry, r, verifier).         return analyzer.debugAnalyze(parsed).     }, listener). }
false;private;3;26;;private <T> void preAnalyze(LogicalPlan parsed, Function<IndexResolution, T> action, ActionListener<T> listener) {     PreAnalysis preAnalysis = preAnalyzer.preAnalyze(parsed).     // TODO we plan to support joins in the future when possible, but for now we'll just fail early if we see one     if (preAnalysis.indices.size() > 1) {         // Note: JOINs are not supported but we detect them when         listener.onFailure(new MappingException("Queries with multiple indices are not supported")).     } else if (preAnalysis.indices.size() == 1) {         TableIdentifier table = preAnalysis.indices.get(0).         String cluster = table.cluster().         if (Strings.hasText(cluster) && !indexResolver.clusterName().equals(cluster)) {             listener.onFailure(new MappingException("Cannot inspect indices in cluster/catalog [{}]", cluster)).         }         indexResolver.resolveAsMergedMapping(table.index(), null, wrap(indexResult -> listener.onResponse(action.apply(indexResult)), listener::onFailure)).     } else {         try {             // occurs when dealing with local relations (SELECT 5+2)             listener.onResponse(action.apply(IndexResolution.invalid("[none specified]"))).         } catch (Exception ex) {             listener.onFailure(ex).         }     } }
false;public;2;3;;public void optimizedPlan(LogicalPlan verified, ActionListener<LogicalPlan> listener) {     analyzedPlan(verified, true, wrap(v -> listener.onResponse(optimizer.optimize(v)), listener::onFailure)). }
false;public;3;3;;public void physicalPlan(LogicalPlan optimized, boolean verify, ActionListener<PhysicalPlan> listener) {     optimizedPlan(optimized, wrap(o -> listener.onResponse(planner.plan(o, verify)), listener::onFailure)). }
false;public;3;3;;public void sql(String sql, List<SqlTypedParamValue> params, ActionListener<SchemaRowSet> listener) {     sqlExecutable(sql, params, wrap(e -> e.execute(this, listener), listener::onFailure)). }
false;public;3;7;;public void sqlExecutable(String sql, List<SqlTypedParamValue> params, ActionListener<PhysicalPlan> listener) {     try {         physicalPlan(doParse(sql, params), true, listener).     } catch (Exception ex) {         listener.onFailure(ex).     } }
false;public;0;3;;public Configuration configuration() {     return configuration. }
