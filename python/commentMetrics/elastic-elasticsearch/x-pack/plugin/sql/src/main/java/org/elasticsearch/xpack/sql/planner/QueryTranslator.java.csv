commented;modifiers;parameterAmount;loc;comment;code
false;static;2;11;;static QueryTranslation toQuery(Expression e, boolean onAggs) {     QueryTranslation translation = null.     for (ExpressionTranslator<?> translator : QUERY_TRANSLATORS) {         translation = translator.translate(e, onAggs).         if (translation != null) {             return translation.         }     }     throw new SqlIllegalArgumentException("Don't know how to translate {} {}", e.nodeName(), e). }
false;static;2;11;;static LeafAgg toAgg(String id, Function f) {     for (AggTranslator<?> translator : AGG_TRANSLATORS) {         LeafAgg agg = translator.apply(id, f).         if (agg != null) {             return agg.         }     }     throw new SqlIllegalArgumentException("Don't know how to translate {} {}", f.nodeName(), f). }
false;;1;22;;GroupByKey groupFor(Expression exp) {     if (Functions.isAggregate(exp)) {         AggregateFunction f = (AggregateFunction) exp.         // if there's at least one agg in the tree         if (!groupMap.isEmpty()) {             GroupByKey matchingGroup = null.             // group found - finding the dedicated agg             if (f.field() instanceof NamedExpression) {                 matchingGroup = groupMap.get(((NamedExpression) f.field()).id()).             }             // return matching group or the tail (last group)             return matchingGroup != null ? matchingGroup : tail.         } else {             return null.         }     }     if (exp instanceof NamedExpression) {         return groupMap.get(((NamedExpression) exp).id()).     }     throw new SqlIllegalArgumentException("Don't know how to find group for expression {}", exp). }
false;public;0;4;;@Override public String toString() {     return groupMap.toString(). }
true;static;1;92;/**  * Creates the list of GroupBy keys  */ ;/**  * Creates the list of GroupBy keys  */ static GroupingContext groupBy(List<? extends Expression> groupings) {     if (groupings.isEmpty()) {         return null.     }     Map<ExpressionId, GroupByKey> aggMap = new LinkedHashMap<>().     for (Expression exp : groupings) {         GroupByKey key = null.         ExpressionId id.         String aggId.         if (exp instanceof NamedExpression) {             NamedExpression ne = (NamedExpression) exp.             id = ne.id().             aggId = id.toString().             // change analyzed to non non-analyzed attributes             if (exp instanceof FieldAttribute) {                 ne = ((FieldAttribute) exp).exactAttribute().             }             // handle functions differently             if (exp instanceof Function) {                 // dates are handled differently because of date histograms                 if (exp instanceof DateTimeHistogramFunction) {                     DateTimeHistogramFunction dthf = (DateTimeHistogramFunction) exp.                     key = new GroupByDateHistogram(aggId, nameOf(exp), dthf.interval(), dthf.zoneId()).                 } else // all other scalar functions become a script                 if (exp instanceof ScalarFunction) {                     ScalarFunction sf = (ScalarFunction) exp.                     key = new GroupByValue(aggId, sf.asScript()).                 } else // histogram                 if (exp instanceof GroupingFunction) {                     if (exp instanceof Histogram) {                         Histogram h = (Histogram) exp.                         Expression field = h.field().                         // date histogram                         if (h.dataType().isDateBased()) {                             long intervalAsMillis = Intervals.inMillis(h.interval()).                             // than 1 day, then the interval used will be `INTERVAL '1' DAY`.                             if (h.dataType() == DATE) {                                 intervalAsMillis = DateUtils.minDayInterval(intervalAsMillis).                             }                             // TODO: set timezone                             if (field instanceof FieldAttribute) {                                 key = new GroupByDateHistogram(aggId, nameOf(field), intervalAsMillis, h.zoneId()).                             } else if (field instanceof Function) {                                 key = new GroupByDateHistogram(aggId, ((Function) field).asScript(), intervalAsMillis, h.zoneId()).                             }                         } else // numeric histogram                         {                             if (field instanceof FieldAttribute) {                                 key = new GroupByNumericHistogram(aggId, nameOf(field), Foldables.doubleValueOf(h.interval())).                             } else if (field instanceof Function) {                                 key = new GroupByNumericHistogram(aggId, ((Function) field).asScript(), Foldables.doubleValueOf(h.interval())).                             }                         }                         if (key == null) {                             throw new SqlIllegalArgumentException("Unsupported histogram field {}", field).                         }                     } else {                         throw new SqlIllegalArgumentException("Unsupproted grouping function {}", exp).                     }                 } else // bumped into into an invalid function (which should be caught by the verifier)                 {                     throw new SqlIllegalArgumentException("Cannot GROUP BY function {}", exp).                 }             } else {                 key = new GroupByValue(aggId, ne.name()).             }         } else {             throw new SqlIllegalArgumentException("Don't know how to group on {}", exp.nodeString()).         }         aggMap.put(id, key).     }     return new GroupingContext(aggMap). }
false;static;3;28;;static QueryTranslation and(Source source, QueryTranslation left, QueryTranslation right) {     Check.isTrue(left != null || right != null, "Both expressions are null").     if (left == null) {         return right.     }     if (right == null) {         return left.     }     Query newQ = null.     if (left.query != null || right.query != null) {         newQ = and(source, left.query, right.query).     }     AggFilter aggFilter.     if (left.aggFilter == null) {         aggFilter = right.aggFilter.     } else if (right.aggFilter == null) {         aggFilter = left.aggFilter.     } else {         aggFilter = new AndAggFilter(left.aggFilter, right.aggFilter).     }     return new QueryTranslation(newQ, aggFilter). }
false;static;3;10;;static Query and(Source source, Query left, Query right) {     Check.isTrue(left != null || right != null, "Both expressions are null").     if (left == null) {         return right.     }     if (right == null) {         return left.     }     return new BoolQuery(source, true, left, right). }
false;static;3;28;;static QueryTranslation or(Source source, QueryTranslation left, QueryTranslation right) {     Check.isTrue(left != null || right != null, "Both expressions are null").     if (left == null) {         return right.     }     if (right == null) {         return left.     }     Query newQ = null.     if (left.query != null || right.query != null) {         newQ = or(source, left.query, right.query).     }     AggFilter aggFilter = null.     if (left.aggFilter == null) {         aggFilter = right.aggFilter.     } else if (right.aggFilter == null) {         aggFilter = left.aggFilter.     } else {         aggFilter = new OrAggFilter(left.aggFilter, right.aggFilter).     }     return new QueryTranslation(newQ, aggFilter). }
false;static;3;11;;static Query or(Source source, Query left, Query right) {     Check.isTrue(left != null || right != null, "Both expressions are null").     if (left == null) {         return right.     }     if (right == null) {         return left.     }     return new BoolQuery(source, false, left, right). }
false;static;1;12;;static String nameOf(Expression e) {     if (e instanceof DateTimeFunction) {         return nameOf(((DateTimeFunction) e).field()).     }     if (e instanceof NamedExpression) {         return ((NamedExpression) e).name().     }     if (e instanceof Literal) {         return String.valueOf(e.fold()).     }     throw new SqlIllegalArgumentException("Cannot determine name for {}", e). }
false;static;1;6;;static String idOf(Expression e) {     if (e instanceof NamedExpression) {         return ((NamedExpression) e).id().toString().     }     throw new SqlIllegalArgumentException("Cannot determine id for {}", e). }
false;static;1;6;;static String dateFormat(Expression e) {     if (e instanceof DateTimeFunction) {         return ((DateTimeFunction) e).dateTimeFormat().     }     return null. }
false;static;1;17;;static String field(AggregateFunction af) {     Expression arg = af.field().     if (arg instanceof FieldAttribute) {         FieldAttribute field = (FieldAttribute) arg.         // COUNT(DISTINCT) uses cardinality aggregation which works on exact values (not changed by analyzers or normalizers)         if (af instanceof Count && ((Count) af).distinct()) {             // use the `keyword` version of the field, if there is one             return field.exactAttribute().name().         }         return field.name().     }     if (arg instanceof Literal) {         return String.valueOf(((Literal) arg).value()).     }     throw new SqlIllegalArgumentException("Does not know how to convert argument {} for function {}", arg.nodeString(), af.nodeString()). }
false;private,static;2;10;;private static String topAggsField(AggregateFunction af, Expression e) {     if (e == null) {         return null.     }     if (e instanceof FieldAttribute) {         return ((FieldAttribute) e).exactAttribute().name().     }     throw new SqlIllegalArgumentException("Does not know how to convert argument {} for function {}", e.nodeString(), af.nodeString()). }
false;protected;2;35;;@Override protected QueryTranslation asQuery(RegexMatch e, boolean onAggs) {     Query q = null.     boolean inexact = true.     String target = null.     if (e.field() instanceof FieldAttribute) {         target = nameOf(((FieldAttribute) e.field()).exactAttribute()).     } else {         throw new SqlIllegalArgumentException("Scalar function ({}) not allowed (yet) as arguments for LIKE", Expressions.name(e.field())).     }     if (e instanceof Like) {         LikePattern p = ((Like) e).pattern().         if (inexact) {             q = new QueryStringQuery(e.source(), p.asLuceneWildcard(), target).         } else {             q = new WildcardQuery(e.source(), nameOf(e.field()), p.asLuceneWildcard()).         }     }     if (e instanceof RLike) {         String pattern = ((RLike) e).pattern().         if (inexact) {             q = new QueryStringQuery(e.source(), "/" + pattern + "/", target).         } else {             q = new RegexQuery(e.source(), nameOf(e.field()), pattern).         }     }     return q != null ? new QueryTranslation(wrapIfNested(q, e.field())) : null. }
false;protected;2;4;;@Override protected QueryTranslation asQuery(StringQueryPredicate q, boolean onAggs) {     return new QueryTranslation(new QueryStringQuery(q.source(), q.query(), q.fields(), q)). }
false;protected;2;4;;@Override protected QueryTranslation asQuery(MatchQueryPredicate q, boolean onAggs) {     return new QueryTranslation(wrapIfNested(new MatchQuery(q.source(), nameOf(q.field()), q.query(), q), q.field())). }
false;protected;2;4;;@Override protected QueryTranslation asQuery(MultiMatchQueryPredicate q, boolean onAggs) {     return new QueryTranslation(new MultiMatchQuery(q.source(), q.query(), q.fields(), q)). }
false;protected;2;11;;@Override protected QueryTranslation asQuery(org.elasticsearch.xpack.sql.expression.predicate.logical.BinaryLogic e, boolean onAggs) {     if (e instanceof And) {         return and(e.source(), toQuery(e.left(), onAggs), toQuery(e.right(), onAggs)).     }     if (e instanceof Or) {         return or(e.source(), toQuery(e.left(), onAggs), toQuery(e.right(), onAggs)).     }     return null. }
false;protected;2;22;;@Override protected QueryTranslation asQuery(Not not, boolean onAggs) {     Query query = null.     AggFilter aggFilter = null.     if (onAggs) {         aggFilter = new AggFilter(not.id().toString(), not.asScript()).     } else {         Expression e = not.field().         Query wrappedQuery = toQuery(not.field(), false).query.         Query q = wrappedQuery instanceof ScriptQuery ? new ScriptQuery(not.source(), not.asScript()) : new NotQuery(not.source(), wrappedQuery).         if (e instanceof FieldAttribute) {             query = wrapIfNested(q, e).         }         query = q.     }     return new QueryTranslation(query, aggFilter). }
false;protected;2;20;;@Override protected QueryTranslation asQuery(IsNotNull isNotNull, boolean onAggs) {     Query query = null.     AggFilter aggFilter = null.     if (onAggs) {         aggFilter = new AggFilter(isNotNull.id().toString(), isNotNull.asScript()).     } else {         Query q = null.         if (isNotNull.field() instanceof FieldAttribute) {             q = new ExistsQuery(isNotNull.source(), nameOf(isNotNull.field())).         } else {             q = new ScriptQuery(isNotNull.source(), isNotNull.asScript()).         }         final Query qu = q.         query = handleQuery(isNotNull, isNotNull.field(), () -> qu).     }     return new QueryTranslation(query, aggFilter). }
false;protected;2;21;;@Override protected QueryTranslation asQuery(IsNull isNull, boolean onAggs) {     Query query = null.     AggFilter aggFilter = null.     if (onAggs) {         aggFilter = new AggFilter(isNull.id().toString(), isNull.asScript()).     } else {         Query q = null.         if (isNull.field() instanceof FieldAttribute) {             q = new NotQuery(isNull.source(), new ExistsQuery(isNull.source(), nameOf(isNull.field()))).         } else {             q = new ScriptQuery(isNull.source(), isNull.asScript()).         }         final Query qu = q.         query = handleQuery(isNull, isNull.field(), () -> qu).     }     return new QueryTranslation(query, aggFilter). }
false;protected;2;32;;@Override protected QueryTranslation asQuery(BinaryComparison bc, boolean onAggs) {     Check.isTrue(bc.right().foldable(), "Line {}:{}: Comparisons against variables are not (currently) supported. offender [{}] in [{}]", bc.right().sourceLocation().getLineNumber(), bc.right().sourceLocation().getColumnNumber(), Expressions.name(bc.right()), bc.symbol()).     if (bc.left() instanceof NamedExpression) {         NamedExpression ne = (NamedExpression) bc.left().         Query query = null.         AggFilter aggFilter = null.         Attribute at = ne.toAttribute().         //          if (onAggs) {             aggFilter = new AggFilter(at.id().toString(), bc.asScript()).         } else {             query = handleQuery(bc, ne, () -> translateQuery(bc)).         }         return new QueryTranslation(query, aggFilter).     } else //      // if the code gets here it's a bug     //      {         throw new SqlIllegalArgumentException("No idea how to translate " + bc.left()).     } }
false;private,static;1;34;;private static Query translateQuery(BinaryComparison bc) {     Source source = bc.source().     String name = nameOf(bc.left()).     Object value = valueOf(bc.right()).     String format = dateFormat(bc.left()).     if (bc instanceof GreaterThan) {         return new RangeQuery(source, name, value, false, null, false, format).     }     if (bc instanceof GreaterThanOrEqual) {         return new RangeQuery(source, name, value, true, null, false, format).     }     if (bc instanceof LessThan) {         return new RangeQuery(source, name, null, false, value, false, format).     }     if (bc instanceof LessThanOrEqual) {         return new RangeQuery(source, name, null, false, value, true, format).     }     if (bc instanceof Equals || bc instanceof NullEquals || bc instanceof NotEquals) {         if (bc.left() instanceof FieldAttribute) {             // equality should always be against an exact match             // (which is important for strings)             name = ((FieldAttribute) bc.left()).exactAttribute().name().         }         Query query = new TermQuery(source, name, value).         if (bc instanceof NotEquals) {             query = new NotQuery(source, query).         }         return query.     }     throw new SqlIllegalArgumentException("Don't know how to translate binary comparison [{}] in [{}]", bc.right().nodeString(), bc). }
false;protected;2;37;;@Override protected QueryTranslation asQuery(In in, boolean onAggs) {     if (in.value() instanceof NamedExpression) {         NamedExpression ne = (NamedExpression) in.value().         Query query = null.         AggFilter aggFilter = null.         Attribute at = ne.toAttribute().         //          if (onAggs) {             aggFilter = new AggFilter(at.id().toString(), in.asScript()).         } else {             Query q = null.             if (in.value() instanceof FieldAttribute) {                 FieldAttribute fa = (FieldAttribute) in.value().                 // equality should always be against an exact match (which is important for strings)                 q = new TermsQuery(in.source(), fa.exactAttribute().name(), in.list()).             } else {                 q = new ScriptQuery(in.source(), in.asScript()).             }             Query qu = q.             query = handleQuery(in, ne, () -> qu).         }         return new QueryTranslation(query, aggFilter).     } else //      // if the code gets here it's a bug     //      {         throw new SqlIllegalArgumentException("No idea how to translate " + in.value()).     } }
false;protected;2;25;;@Override protected QueryTranslation asQuery(Range r, boolean onAggs) {     Expression e = r.value().     if (e instanceof NamedExpression) {         Query query = null.         AggFilter aggFilter = null.         //          // Agg context means HAVING -> PipelineAggs         //          Attribute at = ((NamedExpression) e).toAttribute().         if (onAggs) {             aggFilter = new AggFilter(at.id().toString(), r.asScript()).         } else {             query = handleQuery(r, r.value(), () -> new RangeQuery(r.source(), nameOf(r.value()), valueOf(r.lower()), r.includeLower(), valueOf(r.upper()), r.includeUpper(), dateFormat(r.value()))).         }         return new QueryTranslation(query, aggFilter).     } else {         throw new SqlIllegalArgumentException("No idea how to translate " + e).     } }
false;protected;2;15;;@Override protected QueryTranslation asQuery(ScalarFunction f, boolean onAggs) {     ScriptTemplate script = f.asScript().     Query query = null.     AggFilter aggFilter = null.     if (onAggs) {         aggFilter = new AggFilter(f.id().toString(), script).     } else {         query = handleQuery(f, f, () -> new ScriptQuery(f.source(), script)).     }     return new QueryTranslation(query, aggFilter). }
false;protected;2;8;;@Override protected LeafAgg toAgg(String id, Count c) {     if (c.distinct()) {         return new CardinalityAgg(id, field(c)).     } else {         return new FilterExistsAgg(id, field(c)).     } }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, Sum s) {     return new SumAgg(id, field(s)). }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, Avg a) {     return new AvgAgg(id, field(a)). }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, Max m) {     return new MaxAgg(id, field(m)). }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, Min m) {     return new MinAgg(id, field(m)). }
false;protected;2;5;;@Override protected LeafAgg toAgg(String id, First f) {     return new TopHitsAgg(id, topAggsField(f, f.field()), f.dataType(), topAggsField(f, f.orderField()), f.orderField() == null ? null : f.orderField().dataType(), SortOrder.ASC). }
false;protected;2;5;;@Override protected LeafAgg toAgg(String id, Last l) {     return new TopHitsAgg(id, topAggsField(l, l.field()), l.dataType(), topAggsField(l, l.orderField()), l.orderField() == null ? null : l.orderField().dataType(), SortOrder.DESC). }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, Stats s) {     return new StatsAgg(id, field(s)). }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, ExtendedStats e) {     return new ExtendedStatsAgg(id, field(e)). }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, MatrixStats m) {     return new MatrixStatsAgg(id, singletonList(field(m))). }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, Percentiles p) {     return new PercentilesAgg(id, field(p), doubleValuesOf(p.percents())). }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, PercentileRanks p) {     return new PercentileRanksAgg(id, field(p), doubleValuesOf(p.values())). }
false;protected;2;4;;@Override protected LeafAgg toAgg(String id, Min m) {     return new MinAgg(id, field(m)). }
false;public,final;2;4;;@SuppressWarnings("unchecked") public final LeafAgg apply(String id, Function f) {     return (typeToken.isInstance(f) ? asAgg(id, (F) f) : null). }
false;protected,abstract;2;1;;protected abstract LeafAgg asAgg(String id, F f).
false;protected,final;2;4;;@Override protected final LeafAgg asAgg(String id, F function) {     return toAgg(id, function). }
false;protected,abstract;2;1;;protected abstract LeafAgg toAgg(String id, F f).
false;protected,final;2;4;;@Override protected final LeafAgg asAgg(String id, C function) {     return toAgg(id, function). }
false;protected,abstract;2;1;;protected abstract LeafAgg toAgg(String id, C f).
false;protected,final;2;4;;@Override protected final LeafAgg asAgg(String id, C function) {     return toAgg(id, function). }
false;protected,abstract;2;1;;protected abstract LeafAgg toAgg(String id, C f).
false;public;2;4;;@SuppressWarnings("unchecked") public QueryTranslation translate(Expression exp, boolean onAggs) {     return (typeToken.isInstance(exp) ? asQuery((E) exp, onAggs) : null). }
false;protected,abstract;2;1;;protected abstract QueryTranslation asQuery(E e, boolean onAggs).
false;protected,static;3;7;;protected static Query handleQuery(ScalarFunction sf, Expression field, Supplier<Query> query) {     Query q = query.get().     if (field instanceof FieldAttribute) {         return wrapIfNested(q, field).     }     return new ScriptQuery(sf.source(), sf.asScript()). }
false;protected,static;2;9;;protected static Query wrapIfNested(Query query, Expression exp) {     if (exp instanceof FieldAttribute) {         FieldAttribute fa = (FieldAttribute) exp.         if (fa.isNested()) {             return new NestedQuery(fa.source(), fa.nestedParent().name(), query).         }     }     return query. }
