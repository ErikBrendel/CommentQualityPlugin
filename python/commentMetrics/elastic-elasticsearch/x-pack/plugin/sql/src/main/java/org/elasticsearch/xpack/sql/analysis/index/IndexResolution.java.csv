commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;4;;public static IndexResolution valid(EsIndex index) {     Objects.requireNonNull(index, "index must not be null if it was found").     return new IndexResolution(index, null). }
false;public,static;1;4;;public static IndexResolution invalid(String invalid) {     Objects.requireNonNull(invalid, "invalid must not be null to signal that the index is invalid").     return new IndexResolution(null, invalid). }
false;public,static;1;4;;public static IndexResolution notFound(String name) {     Objects.requireNonNull(name, "name must not be null").     return invalid("Unknown index [" + name + "]"). }
false;public;1;3;;public boolean matches(String index) {     return isValid() && this.index.name().equals(index). }
true;public;0;6;/**  * Get the {@linkplain EsIndex}  * @throws MappingException if the index is invalid for use with sql  */ ;/**  * Get the {@linkplain EsIndex}  * @throws MappingException if the index is invalid for use with sql  */ public EsIndex get() {     if (invalid != null) {         throw new MappingException(invalid).     }     return index. }
true;public;0;3;/**  * Is the index valid for use with sql? Returns {@code false} if the  * index wasn't found.  */ ;/**  * Is the index valid for use with sql? Returns {@code false} if the  * index wasn't found.  */ public boolean isValid() {     return invalid == null. }
false;public;1;9;;@Override public boolean equals(Object obj) {     if (obj == null || obj.getClass() != getClass()) {         return false.     }     IndexResolution other = (IndexResolution) obj.     return Objects.equals(index, other.index) && Objects.equals(invalid, other.invalid). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(index, invalid). }
false;public;0;4;;@Override public String toString() {     return invalid != null ? invalid : index.name(). }
