commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected NodeInfo<UnresolvedFunction> info() {     return NodeInfo.create(this, UnresolvedFunction::new, name, resolutionType, children(), analyzed, unresolvedMsg). }
false;public;1;4;;@Override public Expression replaceChildren(List<Expression> newChildren) {     return new UnresolvedFunction(source(), name, resolutionType, newChildren, analyzed, unresolvedMsg). }
false;public;1;3;;public UnresolvedFunction withMessage(String message) {     return new UnresolvedFunction(source(), name(), resolutionType, children(), true, message). }
false;public;0;3;;public UnresolvedFunction preprocessStar() {     return resolutionType.preprocessStar(this). }
true;public;2;3;/**  * Build a function to replace this one after resolving the function.  */ ;/**  * Build a function to replace this one after resolving the function.  */ public Function buildResolved(Configuration configuration, FunctionDefinition def) {     return resolutionType.buildResolved(this, configuration, def). }
true;public;2;17;/**  * Build a marker {@link UnresolvedFunction} with an error message  * about the function being missing.  */ ;/**  * Build a marker {@link UnresolvedFunction} with an error message  * about the function being missing.  */ public UnresolvedFunction missing(String normalizedName, Iterable<FunctionDefinition> alternatives) {     // try to find alternatives     Set<String> names = new LinkedHashSet<>().     for (FunctionDefinition def : alternatives) {         if (resolutionType.isValidAlternative(def)) {             names.add(def.name()).             names.addAll(def.aliases()).         }     }     List<String> matches = StringUtils.findSimilar(normalizedName, names).     if (matches.isEmpty()) {         return this.     }     String matchesMessage = matches.size() == 1 ? "[" + matches.get(0) + "]" : "any of " + matches.     return withMessage("Unknown " + resolutionType.type() + " [" + name + "], did you mean " + matchesMessage + "?"). }
false;public;0;4;;@Override public boolean resolved() {     return false. }
false;public;0;4;;@Override public String name() {     return name. }
false;public;0;4;;@Override public String functionName() {     return name. }
false;;0;3;;ResolutionType resolutionType() {     return resolutionType. }
false;public;0;3;;public boolean analyzed() {     return analyzed. }
false;public;1;7;;public boolean sameAs(Count count) {     if (this.resolutionType == ResolutionType.DISTINCT && count.distinct() || this.resolutionType == ResolutionType.STANDARD && count.distinct() == false) {         return true.     }     return false. }
false;public;0;4;;@Override public DataType dataType() {     throw new UnresolvedException("dataType", this). }
false;public;0;4;;@Override public Nullability nullable() {     throw new UnresolvedException("nullable", this). }
false;public;0;4;;@Override public Attribute toAttribute() {     throw new UnresolvedException("attribute", this). }
false;public;0;4;;@Override public ScriptTemplate asScript() {     throw new UnresolvedException("script", this). }
false;public;0;4;;@Override public String unresolvedMessage() {     return unresolvedMsg. }
false;public;0;4;;@Override public String toString() {     return UNRESOLVED_PREFIX + name + children(). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj == null || obj.getClass() != getClass()) {         return false.     }     UnresolvedFunction other = (UnresolvedFunction) obj.     return name.equals(other.name) && resolutionType.equals(other.resolutionType) && children().equals(other.children()) && analyzed == other.analyzed && Objects.equals(unresolvedMsg, other.unresolvedMsg). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(name, resolutionType, children(), analyzed, unresolvedMsg). }
false;public;1;10;;@Override public UnresolvedFunction preprocessStar(UnresolvedFunction uf) {     // dedicated count optimization     if (uf.name.toUpperCase(Locale.ROOT).equals("COUNT")) {         return new UnresolvedFunction(uf.source(), uf.name(), uf.resolutionType, singletonList(Literal.of(uf.arguments().get(0).source(), Integer.valueOf(1)))).     }     return uf. }
false;public;3;4;;@Override public Function buildResolved(UnresolvedFunction uf, Configuration cfg, FunctionDefinition def) {     return def.builder().build(uf, false, cfg). }
false;protected;1;4;;@Override protected boolean isValidAlternative(FunctionDefinition def) {     return true. }
false;protected;0;4;;@Override protected String type() {     return "function". }
false;public;1;4;;@Override public UnresolvedFunction preprocessStar(UnresolvedFunction uf) {     return uf.withMessage("* is not valid with DISTINCT"). }
false;public;3;4;;@Override public Function buildResolved(UnresolvedFunction uf, Configuration cfg, FunctionDefinition def) {     return def.builder().build(uf, true, cfg). }
false;protected;1;4;;@Override protected boolean isValidAlternative(FunctionDefinition def) {     // think about this later.     return false. }
false;protected;0;4;;@Override protected String type() {     return "function". }
false;public;1;4;;@Override public UnresolvedFunction preprocessStar(UnresolvedFunction uf) {     return uf.withMessage("Can't extract from *"). }
false;public;3;7;;@Override public Function buildResolved(UnresolvedFunction uf, Configuration cfg, FunctionDefinition def) {     if (def.extractViable()) {         return def.builder().build(uf, false, cfg).     }     return uf.withMessage("Invalid datetime field [" + uf.name() + "]. Use any datetime function."). }
false;protected;1;4;;@Override protected boolean isValidAlternative(FunctionDefinition def) {     return def.extractViable(). }
false;protected;0;4;;@Override protected String type() {     return "datetime field". }
true;protected,abstract;1;1;/**  * Preprocess a function that contains a star to some other  * form before attempting to resolve it. For example,  * {@code DISTINCT} doesn't support {@code *} so it converts  * this function into a dead end, unresolveable function.  * Or {@code COUNT(*)} can be rewritten to {@code COUNT(1)}  * so we don't have to resolve {@code *}.  */ ;/**  * Preprocess a function that contains a star to some other  * form before attempting to resolve it. For example,  * {@code DISTINCT} doesn't support {@code *} so it converts  * this function into a dead end, unresolveable function.  * Or {@code COUNT(*)} can be rewritten to {@code COUNT(1)}  * so we don't have to resolve {@code *}.  */ protected abstract UnresolvedFunction preprocessStar(UnresolvedFunction uf).
true;protected,abstract;3;1;/**  * Build the real function from this one and resolution metadata.  */ ;/**  * Build the real function from this one and resolution metadata.  */ protected abstract Function buildResolved(UnresolvedFunction uf, Configuration cfg, FunctionDefinition def).
true;protected,abstract;1;1;/**  * Is {@code def} a valid alternative for function invocations  * of this kind. Used to filter the list of "did you mean"  * options sent back to the user when they specify a missing  * function.  */ ;/**  * Is {@code def} a valid alternative for function invocations  * of this kind. Used to filter the list of "did you mean"  * options sent back to the user when they specify a missing  * function.  */ protected abstract boolean isValidAlternative(FunctionDefinition def).
true;protected,abstract;0;1;/**  * The name of the kind of thing being resolved. Used when  * building the error message sent back to the user when  * they specify a function that doesn't exist.  */ ;/**  * The name of the kind of thing being resolved. Used when  * building the error message sent back to the user when  * they specify a function that doesn't exist.  */ protected abstract String type().
