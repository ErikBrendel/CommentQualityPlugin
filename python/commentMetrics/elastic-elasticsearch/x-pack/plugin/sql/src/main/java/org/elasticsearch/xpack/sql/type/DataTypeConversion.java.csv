commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;76;/**  * Returns the type compatible with both left and right types  * <p>  * If one of the types is null - returns another type  * If both types are numeric - returns type with the highest precision int &lt. long &lt. float &lt. double  * If one of the types is string and another numeric - returns numeric  */ ;/**  * Returns the type compatible with both left and right types  * <p>  * If one of the types is null - returns another type  * If both types are numeric - returns type with the highest precision int &lt. long &lt. float &lt. double  * If one of the types is string and another numeric - returns numeric  */ public static DataType commonType(DataType left, DataType right) {     if (left == right) {         return left.     }     if (DataTypes.isNull(left)) {         return right.     }     if (DataTypes.isNull(right)) {         return left.     }     if (left.isNumeric() && right.isNumeric()) {         // if one is int         if (left.isInteger()) {             // promote the highest int             if (right.isInteger()) {                 return left.size > right.size ? left : right.             }             // promote the rational             return right.         }         // try the other side         if (right.isInteger()) {             return left.         }         // promote the highest rational         return left.size > right.size ? left : right.     }     if (left.isString()) {         if (right.isNumeric()) {             return right.         }     }     if (right.isString()) {         if (left.isNumeric()) {             return left.         }     }     // interval and dates     if (left == DATE) {         if (DataTypes.isInterval(right)) {             return left.         }     }     if (right == DATE) {         if (DataTypes.isInterval(left)) {             return right.         }     }     if (left == DATETIME) {         if (right == DATE) {             return left.         }         if (DataTypes.isInterval(right)) {             return left.         }     }     if (right == DATETIME) {         if (left == DATE) {             return right.         }         if (DataTypes.isInterval(left)) {             return right.         }     }     if (DataTypes.isInterval(left)) {         // intervals widening         if (DataTypes.isInterval(right)) {             // null returned for incompatible intervals             return DataTypes.compatibleInterval(left, right).         }     }     // none found     return null. }
true;public,static;2;8;/**  * Returns true if the from type can be converted to the to type, false - otherwise  */ ;/**  * Returns true if the from type can be converted to the to type, false - otherwise  */ public static boolean canConvert(DataType from, DataType to) {     // Special handling for nulls and if conversion is not requires     if (from == to || from == NULL) {         return true.     }     // only primitives are supported so far     return from.isPrimitive() && to.isPrimitive() && conversion(from, to) != null. }
true;public,static;2;18;/**  * Get the conversion from one type to another.  */ ;/**  * Get the conversion from one type to another.  */ public static Conversion conversionFor(DataType from, DataType to) {     // Special handling for nulls and if conversion is not requires     if (from == to) {         return Conversion.IDENTITY.     }     if (to == NULL || from == NULL) {         return Conversion.NULL.     }     if (from == NULL) {         return Conversion.NULL.     }     Conversion conversion = conversion(from, to).     if (conversion == null) {         throw new SqlIllegalArgumentException("cannot convert from [" + from + "] to [" + to + "]").     }     return conversion. }
false;private,static;2;30;;private static Conversion conversion(DataType from, DataType to) {     switch(to) {         case KEYWORD:         case TEXT:             return conversionToString(from).         case IP:             return conversionToIp(from).         case LONG:             return conversionToLong(from).         case INTEGER:             return conversionToInt(from).         case SHORT:             return conversionToShort(from).         case BYTE:             return conversionToByte(from).         case FLOAT:             return conversionToFloat(from).         case DOUBLE:             return conversionToDouble(from).         case DATE:             return conversionToDate(from).         case DATETIME:             return conversionToDateTime(from).         case BOOLEAN:             return conversionToBoolean(from).         default:             return null.     } }
false;private,static;1;9;;private static Conversion conversionToString(DataType from) {     if (from == DATE) {         return Conversion.DATE_TO_STRING.     }     if (from == DATETIME) {         return Conversion.DATETIME_TO_STRING.     }     return Conversion.OTHER_TO_STRING. }
false;private,static;1;6;;private static Conversion conversionToIp(DataType from) {     if (from.isString()) {         return Conversion.STRING_TO_IP.     }     return null. }
false;private,static;1;21;;private static Conversion conversionToLong(DataType from) {     if (from.isRational()) {         return Conversion.RATIONAL_TO_LONG.     }     if (from.isInteger()) {         return Conversion.INTEGER_TO_LONG.     }     if (from == BOOLEAN) {         return Conversion.BOOL_TO_LONG.     }     if (from.isString()) {         return Conversion.STRING_TO_LONG.     }     if (from == DATE) {         return Conversion.DATE_TO_LONG.     }     if (from == DATETIME) {         return Conversion.DATETIME_TO_LONG.     }     return null. }
false;private,static;1;21;;private static Conversion conversionToInt(DataType from) {     if (from.isRational()) {         return Conversion.RATIONAL_TO_INT.     }     if (from.isInteger()) {         return Conversion.INTEGER_TO_INT.     }     if (from == BOOLEAN) {         return Conversion.BOOL_TO_INT.     }     if (from.isString()) {         return Conversion.STRING_TO_INT.     }     if (from == DATE) {         return Conversion.DATE_TO_INT.     }     if (from == DATETIME) {         return Conversion.DATETIME_TO_INT.     }     return null. }
false;private,static;1;21;;private static Conversion conversionToShort(DataType from) {     if (from.isRational()) {         return Conversion.RATIONAL_TO_SHORT.     }     if (from.isInteger()) {         return Conversion.INTEGER_TO_SHORT.     }     if (from == BOOLEAN) {         return Conversion.BOOL_TO_SHORT.     }     if (from.isString()) {         return Conversion.STRING_TO_SHORT.     }     if (from == DATE) {         return Conversion.DATE_TO_SHORT.     }     if (from == DATETIME) {         return Conversion.DATETIME_TO_SHORT.     }     return null. }
false;private,static;1;21;;private static Conversion conversionToByte(DataType from) {     if (from.isRational()) {         return Conversion.RATIONAL_TO_BYTE.     }     if (from.isInteger()) {         return Conversion.INTEGER_TO_BYTE.     }     if (from == BOOLEAN) {         return Conversion.BOOL_TO_BYTE.     }     if (from.isString()) {         return Conversion.STRING_TO_BYTE.     }     if (from == DATE) {         return Conversion.DATE_TO_BYTE.     }     if (from == DATETIME) {         return Conversion.DATETIME_TO_BYTE.     }     return null. }
false;private,static;1;21;;private static Conversion conversionToFloat(DataType from) {     if (from.isRational()) {         return Conversion.RATIONAL_TO_FLOAT.     }     if (from.isInteger()) {         return Conversion.INTEGER_TO_FLOAT.     }     if (from == BOOLEAN) {         return Conversion.BOOL_TO_FLOAT.     }     if (from.isString()) {         return Conversion.STRING_TO_FLOAT.     }     if (from == DATE) {         return Conversion.DATE_TO_FLOAT.     }     if (from == DATETIME) {         return Conversion.DATETIME_TO_FLOAT.     }     return null. }
false;private,static;1;21;;private static Conversion conversionToDouble(DataType from) {     if (from.isRational()) {         return Conversion.RATIONAL_TO_DOUBLE.     }     if (from.isInteger()) {         return Conversion.INTEGER_TO_DOUBLE.     }     if (from == BOOLEAN) {         return Conversion.BOOL_TO_DOUBLE.     }     if (from.isString()) {         return Conversion.STRING_TO_DOUBLE.     }     if (from == DATE) {         return Conversion.DATE_TO_DOUBLE.     }     if (from == DATETIME) {         return Conversion.DATETIME_TO_DOUBLE.     }     return null. }
false;private,static;1;18;;private static Conversion conversionToDate(DataType from) {     if (from.isRational()) {         return Conversion.RATIONAL_TO_DATE.     }     if (from.isInteger()) {         return Conversion.INTEGER_TO_DATE.     }     if (from == BOOLEAN) {         // We emit an int here which is ok because of Java's casting rules         return Conversion.BOOL_TO_DATE.     }     if (from.isString()) {         return Conversion.STRING_TO_DATE.     }     if (from == DATETIME) {         return Conversion.DATETIME_TO_DATE.     }     return null. }
false;private,static;1;18;;private static Conversion conversionToDateTime(DataType from) {     if (from.isRational()) {         return Conversion.RATIONAL_TO_DATETIME.     }     if (from.isInteger()) {         return Conversion.INTEGER_TO_DATETIME.     }     if (from == BOOLEAN) {         // We emit an int here which is ok because of Java's casting rules         return Conversion.BOOL_TO_DATETIME.     }     if (from.isString()) {         return Conversion.STRING_TO_DATETIME.     }     if (from == DATE) {         return Conversion.DATE_TO_DATETIME.     }     return null. }
false;private,static;1;15;;private static Conversion conversionToBoolean(DataType from) {     if (from.isNumeric()) {         return Conversion.NUMERIC_TO_BOOLEAN.     }     if (from.isString()) {         return Conversion.STRING_TO_BOOLEAN.     }     if (from == DATE) {         return Conversion.DATE_TO_BOOLEAN.     }     if (from == DATETIME) {         return Conversion.DATETIME_TO_BOOLEAN.     }     return null. }
false;public,static;1;6;;public static byte safeToByte(long x) {     if (x > Byte.MAX_VALUE || x < Byte.MIN_VALUE) {         throw new SqlIllegalArgumentException("[" + x + "] out of [byte] range").     }     return (byte) x. }
false;public,static;1;6;;public static short safeToShort(long x) {     if (x > Short.MAX_VALUE || x < Short.MIN_VALUE) {         throw new SqlIllegalArgumentException("[" + x + "] out of [short] range").     }     return (short) x. }
false;public,static;1;6;;public static int safeToInt(long x) {     if (x > Integer.MAX_VALUE || x < Integer.MIN_VALUE) {         throw new SqlIllegalArgumentException("[" + x + "] out of [integer] range").     }     return (int) x. }
false;public,static;1;6;;public static long safeToLong(double x) {     if (x > Long.MAX_VALUE || x < Long.MIN_VALUE) {         throw new SqlIllegalArgumentException("[" + x + "] out of [long] range").     }     return Math.round(x). }
false;public,static;2;14;;public static Number toInteger(double x, DataType dataType) {     long l = safeToLong(x).     switch(dataType) {         case BYTE:             return safeToByte(l).         case SHORT:             return safeToShort(l).         case INTEGER:             return safeToInt(l).         default:             return l.     } }
false;public,static;1;7;;public static boolean convertToBoolean(String val) {     String lowVal = val.toLowerCase(Locale.ROOT).     if (Booleans.isBoolean(lowVal) == false) {         throw new SqlIllegalArgumentException("cannot cast [" + val + "] to [boolean]").     }     return Booleans.parseBoolean(lowVal). }
true;public,static;2;7;/**  * Converts arbitrary object to the desired data type.  * <p>  * Throws SqlIllegalArgumentException if such conversion is not possible  */ ;/**  * Converts arbitrary object to the desired data type.  * <p>  * Throws SqlIllegalArgumentException if such conversion is not possible  */ public static Object convert(Object value, DataType dataType) {     DataType detectedType = DataTypes.fromJava(value).     if (detectedType == dataType || value == null) {         return value.     }     return conversionFor(detectedType, dataType).convert(value). }
false;private,static;1;3;;private static Function<Object, Object> fromDouble(DoubleFunction<Object> converter) {     return (Object l) -> converter.apply(((Number) l).doubleValue()). }
false;private,static;1;3;;private static Function<Object, Object> fromLong(LongFunction<Object> converter) {     return (Object l) -> converter.apply(((Number) l).longValue()). }
false;private,static;2;11;;private static Function<Object, Object> fromString(Function<String, Object> converter, String to) {     return (Object value) -> {         try {             return converter.apply(value.toString()).         } catch (NumberFormatException e) {             throw new SqlIllegalArgumentException(e, "cannot cast [{}] to [{}]", value, to).         } catch (DateTimeParseException | IllegalArgumentException e) {             throw new SqlIllegalArgumentException(e, "cannot cast [{}] to [{}]: {}", value, to, e.getMessage()).         }     }. }
false;private,static;1;3;;private static Function<Object, Object> fromBool(Function<Boolean, Object> converter) {     return (Object l) -> converter.apply(((Boolean) l)). }
false;private,static;1;3;;private static Function<Object, Object> fromDateTime(Function<Long, Object> converter) {     return l -> converter.apply(((ZonedDateTime) l).toInstant().toEpochMilli()). }
false;private,static;1;3;;private static Function<Object, Object> toDateTime(Conversion conversion) {     return l -> DateUtils.asDateTime(((Number) conversion.convert(l)).longValue()). }
false;private,static;1;3;;private static Function<Object, Object> toDate(Conversion conversion) {     return l -> DateUtils.asDateOnly(((Number) conversion.convert(l)).longValue()). }
false;private,static;0;3;;private static Function<Object, Object> fromDatetimeToDate() {     return l -> DateUtils.asDateOnly((ZonedDateTime) l). }
false;public;1;6;;public Object convert(Object l) {     if (l == null) {         return null.     }     return converter.apply(l). }
false;public,static;1;7;;public static DataType asInteger(DataType dataType) {     if (!dataType.isNumeric()) {         return dataType.     }     return dataType.isInteger() ? dataType : LONG. }
