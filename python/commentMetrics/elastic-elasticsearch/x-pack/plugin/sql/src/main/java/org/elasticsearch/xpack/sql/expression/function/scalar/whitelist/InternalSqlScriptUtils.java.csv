commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;9;// safe missing mapping/value extractor ;//  // Utilities //  // safe missing mapping/value extractor public static <T> Object docValue(Map<String, ScriptDocValues<T>> doc, String fieldName) {     if (doc.containsKey(fieldName)) {         ScriptDocValues<T> docValues = doc.get(fieldName).         if (!docValues.isEmpty()) {             return docValues.get(0).         }     }     return null. }
false;public,static;1;3;;public static boolean nullSafeFilter(Boolean filter) {     return filter == null ? false : filter.booleanValue(). }
false;public,static;1;3;;public static double nullSafeSortNumeric(Number sort) {     return sort == null ? 0.0d : sort.doubleValue(). }
false;public,static;1;3;;public static String nullSafeSortString(Object sort) {     return sort == null ? StringUtils.EMPTY : sort.toString(). }
true;public,static;2;3;//  ;//  // Operators //  //  // Logical //  public static Boolean eq(Object left, Object right) {     return BinaryComparisonOperation.EQ.apply(left, right). }
false;public,static;2;3;;public static Boolean nulleq(Object left, Object right) {     return BinaryComparisonOperation.NULLEQ.apply(left, right). }
false;public,static;2;3;;public static Boolean neq(Object left, Object right) {     return BinaryComparisonOperation.NEQ.apply(left, right). }
false;public,static;2;3;;public static Boolean lt(Object left, Object right) {     return BinaryComparisonOperation.LT.apply(left, right). }
false;public,static;2;3;;public static Boolean lte(Object left, Object right) {     return BinaryComparisonOperation.LTE.apply(left, right). }
false;public,static;2;3;;public static Boolean gt(Object left, Object right) {     return BinaryComparisonOperation.GT.apply(left, right). }
false;public,static;2;3;;public static Boolean gte(Object left, Object right) {     return BinaryComparisonOperation.GTE.apply(left, right). }
false;public,static;2;3;;public static Boolean and(Boolean left, Boolean right) {     return BinaryLogicOperation.AND.apply(left, right). }
false;public,static;2;3;;public static Boolean or(Boolean left, Boolean right) {     return BinaryLogicOperation.OR.apply(left, right). }
false;public,static;1;3;;public static Boolean not(Boolean expression) {     return NotProcessor.apply(expression). }
false;public,static;1;3;;public static Boolean isNull(Object expression) {     return CheckNullOperation.IS_NULL.apply(expression). }
false;public,static;1;3;;public static Boolean isNotNull(Object expression) {     return CheckNullOperation.IS_NOT_NULL.apply(expression). }
false;public,static;2;3;;public static Boolean in(Object value, List<Object> values) {     return InProcessor.apply(value, values). }
true;public,static;1;3;//  ;//  // Null //  public static Object coalesce(List<Object> expressions) {     return ConditionalOperation.COALESCE.apply(expressions). }
false;public,static;1;3;;public static Object greatest(List<Object> expressions) {     return ConditionalOperation.GREATEST.apply(expressions). }
false;public,static;1;3;;public static Object least(List<Object> expressions) {     return ConditionalOperation.LEAST.apply(expressions). }
false;public,static;2;3;;public static Object nullif(Object left, Object right) {     return NullIfProcessor.apply(left, right). }
true;public,static;2;4;//  ;//  // Regex //  public static Boolean regex(String value, String pattern) {     // TODO: this needs to be improved to avoid creating the pattern on every call     return RegexOperation.match(value, pattern). }
true;public,static;2;3;//  ;//  // Math //  public static Object add(Object left, Object right) {     return BinaryArithmeticOperation.ADD.apply(left, right). }
false;public,static;2;3;;public static Object div(Object left, Object right) {     return BinaryArithmeticOperation.DIV.apply(left, right). }
false;public,static;2;3;;public static Object mod(Object left, Object right) {     return BinaryArithmeticOperation.MOD.apply(left, right). }
false;public,static;2;3;;public static Object mul(Object left, Object right) {     return BinaryArithmeticOperation.MUL.apply(left, right). }
false;public,static;1;3;;public static Number neg(Number value) {     return UnaryArithmeticOperation.NEGATE.apply(value). }
false;public,static;2;3;;public static Object sub(Object left, Object right) {     return BinaryArithmeticOperation.SUB.apply(left, right). }
false;public,static;2;3;;public static Number round(Number v, Number s) {     return BinaryMathOperation.ROUND.apply(v, s). }
false;public,static;2;3;;public static Number truncate(Number v, Number s) {     return BinaryMathOperation.TRUNCATE.apply(v, s). }
false;public,static;1;3;;public static Double abs(Number value) {     return MathOperation.ABS.apply(value). }
false;public,static;1;3;;public static Double acos(Number value) {     return MathOperation.ACOS.apply(value). }
false;public,static;1;3;;public static Double asin(Number value) {     return MathOperation.ASIN.apply(value). }
false;public,static;1;3;;public static Double atan(Number value) {     return MathOperation.ATAN.apply(value). }
false;public,static;1;3;;public static Double cbrt(Number value) {     return MathOperation.CBRT.apply(value). }
false;public,static;1;3;;public static Double ceil(Number value) {     return MathOperation.CEIL.apply(value). }
false;public,static;1;3;;public static Double cos(Number value) {     return MathOperation.COS.apply(value). }
false;public,static;1;3;;public static Double cosh(Number value) {     return MathOperation.COSH.apply(value). }
false;public,static;1;3;;public static Double cot(Number value) {     return MathOperation.COT.apply(value). }
false;public,static;1;3;;public static Double degrees(Number value) {     return MathOperation.DEGREES.apply(value). }
false;public,static;1;3;;public static Double e(Number value) {     return MathOperation.E.apply(value). }
false;public,static;1;3;;public static Double exp(Number value) {     return MathOperation.EXP.apply(value). }
false;public,static;1;3;;public static Double expm1(Number value) {     return MathOperation.EXPM1.apply(value). }
false;public,static;1;3;;public static Double floor(Number value) {     return MathOperation.FLOOR.apply(value). }
false;public,static;1;3;;public static Double log(Number value) {     return MathOperation.LOG.apply(value). }
false;public,static;1;3;;public static Double log10(Number value) {     return MathOperation.LOG10.apply(value). }
false;public,static;1;3;;public static Double pi(Number value) {     return MathOperation.PI.apply(value). }
false;public,static;1;3;;public static Double radians(Number value) {     return MathOperation.RADIANS.apply(value). }
false;public,static;1;3;;public static Double random(Number value) {     return MathOperation.RANDOM.apply(value). }
false;public,static;1;3;;public static Double sign(Number value) {     return MathOperation.SIGN.apply(value). }
false;public,static;1;3;;public static Double sin(Number value) {     return MathOperation.SIN.apply(value). }
false;public,static;1;3;;public static Double sinh(Number value) {     return MathOperation.SINH.apply(value). }
false;public,static;1;3;;public static Double sqrt(Number value) {     return MathOperation.SQRT.apply(value). }
false;public,static;1;3;;public static Double tan(Number value) {     return MathOperation.TAN.apply(value). }
true;public,static;3;6;//  ;//  // Date/Time functions //  public static Integer dateTimeChrono(Object dateTime, String tzId, String chronoName) {     if (dateTime == null || tzId == null || chronoName == null) {         return null.     }     return DateTimeFunction.dateTimeChrono(asDateTime(dateTime), tzId, chronoName). }
false;public,static;2;6;;public static String dayName(Object dateTime, String tzId) {     if (dateTime == null || tzId == null) {         return null.     }     return NameExtractor.DAY_NAME.extract(asDateTime(dateTime), tzId). }
false;public,static;2;6;;public static Integer dayOfWeek(Object dateTime, String tzId) {     if (dateTime == null || tzId == null) {         return null.     }     return NonIsoDateTimeExtractor.DAY_OF_WEEK.extract(asDateTime(dateTime), tzId). }
false;public,static;2;6;;public static String monthName(Object dateTime, String tzId) {     if (dateTime == null || tzId == null) {         return null.     }     return NameExtractor.MONTH_NAME.extract(asDateTime(dateTime), tzId). }
false;public,static;2;6;;public static Integer quarter(Object dateTime, String tzId) {     if (dateTime == null || tzId == null) {         return null.     }     return QuarterProcessor.quarter(asDateTime(dateTime), tzId). }
false;public,static;2;6;;public static Integer weekOfYear(Object dateTime, String tzId) {     if (dateTime == null || tzId == null) {         return null.     }     return NonIsoDateTimeExtractor.WEEK_OF_YEAR.extract(asDateTime(dateTime), tzId). }
false;public,static;1;3;;public static ZonedDateTime asDateTime(Object dateTime) {     return (ZonedDateTime) asDateTime(dateTime, false). }
false;private,static;2;19;;private static Object asDateTime(Object dateTime, boolean lenient) {     if (dateTime == null) {         return null.     }     if (dateTime instanceof JodaCompatibleZonedDateTime) {         return ((JodaCompatibleZonedDateTime) dateTime).getZonedDateTime().     }     if (dateTime instanceof ZonedDateTime) {         return dateTime.     }     if (false == lenient) {         if (dateTime instanceof Number) {             return DateUtils.asDateTime(((Number) dateTime).longValue()).         }         throw new SqlIllegalArgumentException("Invalid date encountered [{}]", dateTime).     }     return dateTime. }
false;public,static;2;6;;public static IntervalDayTime intervalDayTime(String text, String typeName) {     if (text == null || typeName == null) {         return null.     }     return new IntervalDayTime(Duration.parse(text), DataType.fromTypeName(typeName)). }
false;public,static;2;7;;public static IntervalYearMonth intervalYearMonth(String text, String typeName) {     if (text == null || typeName == null) {         return null.     }     return new IntervalYearMonth(Period.parse(text), DataType.fromTypeName(typeName)). }
true;public,static;1;3;//  ;//  // String functions //  public static Integer ascii(String s) {     return (Integer) StringOperation.ASCII.apply(s). }
false;public,static;1;3;;public static Integer bitLength(String s) {     return (Integer) StringOperation.BIT_LENGTH.apply(s). }
false;public,static;1;3;;public static String character(Number n) {     return (String) StringOperation.CHAR.apply(n). }
false;public,static;1;3;;public static Integer charLength(String s) {     return (Integer) StringOperation.CHAR_LENGTH.apply(s). }
false;public,static;2;3;;public static String concat(String s1, String s2) {     return (String) ConcatFunctionProcessor.process(s1, s2). }
false;public,static;4;3;;public static String insert(String s, Number start, Number length, String r) {     return (String) InsertFunctionProcessor.doProcess(s, start, length, r). }
false;public,static;1;3;;public static String lcase(String s) {     return (String) StringOperation.LCASE.apply(s). }
false;public,static;2;3;;public static String left(String s, Number count) {     return BinaryStringNumericOperation.LEFT.apply(s, count). }
false;public,static;1;3;;public static Integer length(String s) {     return (Integer) StringOperation.LENGTH.apply(s). }
false;public,static;2;3;;public static Integer locate(String s1, String s2) {     return locate(s1, s2, null). }
false;public,static;3;3;;public static Integer locate(String s1, String s2, Number pos) {     return LocateFunctionProcessor.doProcess(s1, s2, pos). }
false;public,static;1;3;;public static String ltrim(String s) {     return (String) StringOperation.LTRIM.apply(s). }
false;public,static;1;3;;public static Integer octetLength(String s) {     return (Integer) StringOperation.OCTET_LENGTH.apply(s). }
false;public,static;2;3;;public static Integer position(String s1, String s2) {     return (Integer) BinaryStringStringOperation.POSITION.apply(s1, s2). }
false;public,static;2;3;;public static String repeat(String s, Number count) {     return BinaryStringNumericOperation.REPEAT.apply(s, count). }
false;public,static;3;3;;public static String replace(String s1, String s2, String s3) {     return (String) ReplaceFunctionProcessor.doProcess(s1, s2, s3). }
false;public,static;2;3;;public static String right(String s, Number count) {     return BinaryStringNumericOperation.RIGHT.apply(s, count). }
false;public,static;1;3;;public static String rtrim(String s) {     return (String) StringOperation.RTRIM.apply(s). }
false;public,static;1;3;;public static String space(Number n) {     return (String) StringOperation.SPACE.apply(n). }
false;public,static;3;3;;public static String substring(String s, Number start, Number length) {     return (String) SubstringFunctionProcessor.doProcess(s, start, length). }
false;public,static;1;3;;public static String ucase(String s) {     return (String) StringOperation.UCASE.apply(s). }
true;public,static;2;5;//  ;//  // Casting //  public static Object cast(Object value, String typeName) {     // since casting works for ZonedDateTime objects only     return DataTypeConversion.convert(asDateTime(value, true), DataType.fromTypeName(typeName)). }
