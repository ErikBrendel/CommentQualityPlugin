commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public PhysicalPlan map(LogicalPlan plan) {     return execute(planLater(plan)). }
false;protected;0;9;;@Override protected Iterable<RuleExecutor<PhysicalPlan>.Batch> batches() {     Batch conversion = new Batch("Mapping", new JoinMapper(), new SimpleExecMapper()).     return Arrays.asList(conversion). }
false;private,static;1;3;;private static PhysicalPlan planLater(LogicalPlan plan) {     return new UnplannedExec(plan.source(), plan). }
false;protected;1;48;;@Override protected PhysicalPlan map(LogicalPlan p) {     if (p instanceof Command) {         return new CommandExec(p.source(), (Command) p).     }     if (p instanceof LocalRelation) {         return new LocalExec(p.source(), ((LocalRelation) p).executable()).     }     if (p instanceof Project) {         Project pj = (Project) p.         return new ProjectExec(p.source(), map(pj.child()), pj.projections()).     }     if (p instanceof Filter) {         Filter fl = (Filter) p.         return new FilterExec(p.source(), map(fl.child()), fl.condition()).     }     if (p instanceof OrderBy) {         OrderBy o = (OrderBy) p.         return new OrderExec(p.source(), map(o.child()), o.order()).     }     if (p instanceof Aggregate) {         Aggregate a = (Aggregate) p.         // analysis and optimizations have converted the grouping into actual attributes         return new AggregateExec(p.source(), map(a.child()), a.groupings(), a.aggregates()).     }     if (p instanceof EsRelation) {         EsRelation c = (EsRelation) p.         List<Attribute> output = c.output().         return new EsQueryExec(p.source(), c.index().name(), output, new QueryContainer()).     }     if (p instanceof Limit) {         Limit l = (Limit) p.         return new LimitExec(p.source(), map(l.child()), l.limit()).     }     // TODO: Translate With in a subplan     if (p instanceof With) {         throw new UnsupportedOperationException("With should have been translated already").     }     return planLater(p). }
false;protected;1;4;;@Override protected PhysicalPlan map(Join j) {     return join(j). }
false;private;1;9;;private PhysicalPlan join(Join join) {     throw new UnsupportedOperationException("Don't know how to handle join " + join.nodeString()). }
false;public,final;1;4;;@Override public final PhysicalPlan apply(PhysicalPlan plan) {     return plan.transformUp(this::rule, UnplannedExec.class). }
false;protected,final;1;9;;@SuppressWarnings("unchecked") @Override protected final PhysicalPlan rule(UnplannedExec plan) {     LogicalPlan subPlan = plan.plan().     if (subPlanToken.isInstance(subPlan)) {         return map((SubPlan) subPlan).     }     return plan. }
false;protected,abstract;1;1;;protected abstract PhysicalPlan map(SubPlan plan).
