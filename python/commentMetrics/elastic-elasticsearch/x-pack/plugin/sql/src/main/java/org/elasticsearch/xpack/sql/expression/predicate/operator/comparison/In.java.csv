commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected NodeInfo<In> info() {     return NodeInfo.create(this, In::new, value, list). }
false;public;1;7;;@Override public Expression replaceChildren(List<Expression> newChildren) {     if (newChildren.size() < 2) {         throw new IllegalArgumentException("expected at least [2] children but received [" + newChildren.size() + "]").     }     return new In(source(), newChildren.get(newChildren.size() - 1), newChildren.subList(0, newChildren.size() - 1)). }
false;public;0;3;;public Expression value() {     return value. }
false;public;0;3;;public List<Expression> list() {     return list. }
false;public;0;4;;@Override public DataType dataType() {     return DataType.BOOLEAN. }
false;public;0;4;;@Override public Nullability nullable() {     return Nullability.UNKNOWN. }
false;public;0;5;;@Override public boolean foldable() {     return Expressions.foldable(children()) || (Expressions.foldable(list) && list().stream().allMatch(e -> e.dataType() == DataType.NULL)). }
false;public;0;9;;@Override public Boolean fold() {     // Optimization for early return and Query folding to LocalExec     if (value.dataType() == DataType.NULL || list.size() == 1 && list.get(0).dataType() == DataType.NULL) {         return null.     }     return InProcessor.apply(value.fold(), Foldables.valuesOf(list, value.dataType())). }
false;public;0;15;;@Override public ScriptTemplate asScript() {     ScriptTemplate leftScript = asScript(value).     // fold & remove duplicates     List<Object> values = new ArrayList<>(new LinkedHashSet<>(Foldables.valuesOf(list, value.dataType()))).     return new ScriptTemplate(formatTemplate(format("{sql}.", "in({}, {})", leftScript.template())), paramsBuilder().script(leftScript.params()).variable(values).build(), dataType()). }
false;protected;0;4;;@Override protected Pipe makePipe() {     return new InPipe(source(), this, children().stream().map(Expressions::pipe).collect(Collectors.toList())). }
false;protected;0;16;;@Override protected TypeResolution resolveType() {     TypeResolution resolution = TypeResolutions.isExact(value, functionName(), Expressions.ParamOrdinal.DEFAULT).     if (resolution != TypeResolution.TYPE_RESOLVED) {         return resolution.     }     for (Expression ex : list) {         if (ex.foldable() == false) {             return new TypeResolution(format(null, "Comparisons against variables are not (currently) supported. offender [{}] in [{}]", Expressions.name(ex), name())).         }     }     return super.resolveType(). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(value, list). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     In other = (In) obj.     return Objects.equals(value, other.value) && Objects.equals(list, other.list). }
