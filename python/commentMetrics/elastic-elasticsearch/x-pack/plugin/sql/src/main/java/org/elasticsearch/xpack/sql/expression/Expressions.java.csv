commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static NamedExpression wrapAsNamed(Expression exp) {     return exp instanceof NamedExpression ? (NamedExpression) exp : new Alias(exp.source(), exp.sourceText(), exp). }
false;public,static;1;10;;public static List<Attribute> asAttributes(List<? extends NamedExpression> named) {     if (named.isEmpty()) {         return emptyList().     }     List<Attribute> list = new ArrayList<>(named.size()).     for (NamedExpression exp : named) {         list.add(exp.toAttribute()).     }     return list. }
false;public,static;1;11;;public static AttributeMap<Expression> asAttributeMap(List<? extends NamedExpression> named) {     if (named.isEmpty()) {         return new AttributeMap<>(emptyMap()).     }     AttributeMap<Expression> map = new AttributeMap<>().     for (NamedExpression exp : named) {         map.add(exp.toAttribute(), exp).     }     return map. }
false;public,static;2;8;;public static boolean anyMatch(List<? extends Expression> exps, Predicate<? super Expression> predicate) {     for (Expression exp : exps) {         if (exp.anyMatch(predicate)) {             return true.         }     }     return false. }
false;public,static;2;8;;public static boolean match(List<? extends Expression> exps, Predicate<? super Expression> predicate) {     for (Expression exp : exps) {         if (predicate.test(exp)) {             return true.         }     }     return false. }
false;public,static;1;3;;public static Nullability nullable(List<? extends Expression> exps) {     return Nullability.and(exps.stream().map(Expression::nullable).toArray(Nullability[]::new)). }
false;public,static;1;8;;public static boolean foldable(List<? extends Expression> exps) {     for (Expression exp : exps) {         if (!exp.foldable()) {             return false.         }     }     return true. }
false;public,static;1;11;;public static AttributeSet references(List<? extends Expression> exps) {     if (exps.isEmpty()) {         return AttributeSet.EMPTY.     }     AttributeSet set = new AttributeSet().     for (Expression exp : exps) {         set.addAll(exp.references()).     }     return set. }
false;public,static;1;3;;public static String name(Expression e) {     return e instanceof NamedExpression ? ((NamedExpression) e).name() : e.nodeName(). }
false;public,static;1;3;;public static boolean isNull(Expression e) {     return e.dataType() == DataType.NULL || (e.foldable() && e.fold() == null). }
false;public,static;1;8;;public static List<String> names(Collection<? extends Expression> e) {     List<String> names = new ArrayList<>(e.size()).     for (Expression ex : e) {         names.add(name(ex)).     }     return names. }
false;public,static;1;9;;public static Attribute attribute(Expression e) {     if (e instanceof NamedExpression) {         return ((NamedExpression) e).toAttribute().     }     if (e != null && e.foldable()) {         return Literal.of(e).toAttribute().     }     return null. }
false;public,static;2;7;;public static boolean equalsAsAttribute(Expression left, Expression right) {     if (!left.semanticEquals(right)) {         Attribute l = attribute(left).         return (l != null && l.semanticEquals(attribute(right))).     }     return true. }
false;public,static;1;6;;public static Pipe pipe(Expression e) {     if (e instanceof NamedExpression) {         return ((NamedExpression) e).asPipe().     }     throw new SqlIllegalArgumentException("Cannot create pipe for {}", e). }
false;public,static;1;7;;public static List<Pipe> pipe(List<Expression> expressions) {     List<Pipe> pipes = new ArrayList<>(expressions.size()).     for (Expression e : expressions) {         pipes.add(pipe(e)).     }     return pipes. }
