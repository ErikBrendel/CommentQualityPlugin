commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the field path  */ ;/**  * Returns the field path  */ public String getName() {     return name. }
true;public;0;3;/**  * The field type  */ ;/**  * The field type  */ public DataType getDataType() {     return esDataType. }
true;public;0;3;/**  * This field can be aggregated  */ ;/**  * This field can be aggregated  */ public boolean isAggregatable() {     return aggregatable. }
true;public;0;4;/**  * Returns list of properties for the nested and object fields, list of subfield if the field  * was indexed in a few different ways or null otherwise  */ ;/**  * Returns list of properties for the nested and object fields, list of subfield if the field  * was indexed in a few different ways or null otherwise  */ @Nullable public Map<String, EsField> getProperties() {     return properties. }
true;public;0;3;/**  * Returns the path to the keyword version of this field if this field is text and it has a subfield that is  * indexed as keyword, throws an exception if such field is not found or the field name itself in all other cases.  * To avoid the exception {@link EsField#getExactInfo()} should be used beforehand, to check if an exact field exists  * and if not get the errorMessage which explains why is that.  */ ;/**  * Returns the path to the keyword version of this field if this field is text and it has a subfield that is  * indexed as keyword, throws an exception if such field is not found or the field name itself in all other cases.  * To avoid the exception {@link EsField#getExactInfo()} should be used beforehand, to check if an exact field exists  * and if not get the errorMessage which explains why is that.  */ public EsField getExactField() {     return this. }
true;public;0;3;/**  * Returns the precision of the field  * <p>  * Precision is the specified column size. For numeric data, this is the maximum precision. For character  * data, this is the length in characters. For datetime datatypes, this is the length in characters of the  * String representation (assuming the maximum allowed defaultPrecision of the fractional seconds component).  */ ;/**  * Returns the precision of the field  * <p>  * Precision is the specified column size. For numeric data, this is the maximum precision. For character  * data, this is the length in characters. For datetime datatypes, this is the length in characters of the  * String representation (assuming the maximum allowed defaultPrecision of the fractional seconds component).  */ public int getPrecision() {     return esDataType.defaultPrecision. }
true;public;0;3;/**  * Returns and {@link Exact} object with all the necessary info about the field:  * <ul>  *  <li>If it has an exact underlying field or not</li>  *  <li>and if not an error message why it doesn't</li>  * </ul>  */ ;/**  * Returns and {@link Exact} object with all the necessary info about the field:  * <ul>  *  <li>If it has an exact underlying field or not</li>  *  <li>and if not an error message why it doesn't</li>  * </ul>  */ public Exact getExactInfo() {     return Exact.EXACT_FIELD. }
false;public;0;4;;@Override public String toString() {     return name + "@" + esDataType.name() + "=" + properties. }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     EsField field = (EsField) o.     return aggregatable == field.aggregatable && esDataType == field.esDataType && Objects.equals(name, field.name) && Objects.equals(properties, field.properties). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(esDataType, aggregatable, properties, name). }
false;public;0;3;;public boolean hasExact() {     return hasExact. }
false;public;0;3;;public String errorMsg() {     return errorMsg. }
