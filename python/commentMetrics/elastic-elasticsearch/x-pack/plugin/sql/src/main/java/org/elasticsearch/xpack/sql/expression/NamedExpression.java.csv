commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String name() {     return name. }
false;public;0;3;;public ExpressionId id() {     return id. }
false;public;0;3;;public boolean synthetic() {     return synthetic. }
false;public,abstract;0;1;;public abstract Attribute toAttribute().
false;public;0;7;;public Pipe asPipe() {     if (lazyPipe == null) {         lazyPipe = foldable() ? new ConstantInput(source(), this, fold()) : makePipe().     }     return lazyPipe. }
false;protected;0;3;;protected Pipe makePipe() {     return new AttributeInput(source(), this, toAttribute()). }
false;public,abstract;0;1;;public abstract ScriptTemplate asScript().
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(id, name, synthetic). }
false;public;1;21;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     NamedExpression other = (NamedExpression) obj.     return Objects.equals(synthetic, other.synthetic) && Objects.equals(id, other.id) && /*                  * It is important that the line below be `name`                  * and not `name()` because subclasses might override                  * `name()` in ways that are not compatible with                  * equality. Specifically the `Unresolved` subclasses.                  */     Objects.equals(name, other.name) && Objects.equals(children(), other.children()). }
false;public;0;4;;@Override public String toString() {     return super.toString() + "#" + id(). }
