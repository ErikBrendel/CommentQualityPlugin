commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public Object visit(ParseTree tree) {     Object result = super.visit(tree).     Check.notNull(result, "Don't know how to handle context [{}] with value [{}]", tree.getClass(), tree.getText()).     return result. }
false;protected;2;11;;@SuppressWarnings("unchecked") protected <T> T typedParsing(ParseTree ctx, Class<T> type) {     Object result = ctx.accept(this).     if (type.isInstance(result)) {         return (T) result.     }     throw new ParsingException(source(ctx), "Invalid query '{}'[{}] given. expected {} but found {}", ctx.getText(), ctx.getClass().getSimpleName(), type.getSimpleName(), (result != null ? result.getClass().getSimpleName() : "null")). }
false;protected;1;3;;protected LogicalPlan plan(ParseTree ctx) {     return typedParsing(ctx, LogicalPlan.class). }
false;protected;1;3;;protected List<LogicalPlan> plans(List<? extends ParserRuleContext> ctxs) {     return visitList(ctxs, LogicalPlan.class). }
false;protected;2;7;;protected <T> List<T> visitList(List<? extends ParserRuleContext> contexts, Class<T> clazz) {     List<T> results = new ArrayList<>(contexts.size()).     for (ParserRuleContext context : contexts) {         results.add(clazz.cast(visit(context))).     }     return results. }
false;static;1;6;;static Source source(ParseTree ctx) {     if (ctx instanceof ParserRuleContext) {         return source((ParserRuleContext) ctx).     }     return Source.EMPTY. }
false;static;1;4;;static Source source(TerminalNode terminalNode) {     Check.notNull(terminalNode, "terminalNode is null").     return source(terminalNode.getSymbol()). }
false;static;1;8;;static Source source(ParserRuleContext parserRuleContext) {     Check.notNull(parserRuleContext, "parserRuleContext is null").     Token start = parserRuleContext.start.     Token stop = parserRuleContext.stop != null ? parserRuleContext.stop : start.     Interval interval = new Interval(start.getStartIndex(), stop.getStopIndex()).     String text = start.getInputStream().getText(interval).     return new Source(new Location(start.getLine(), start.getCharPositionInLine()), text). }
false;static;1;5;;static Source source(Token token) {     Check.notNull(token, "token is null").     String text = token.getInputStream().getText(new Interval(token.getStartIndex(), token.getStopIndex())).     return new Source(new Location(token.getLine(), token.getCharPositionInLine()), text). }
false;;2;9;;Source source(ParserRuleContext begin, ParserRuleContext end) {     Check.notNull(begin, "begin is null").     Check.notNull(end, "end is null").     Token start = begin.start.     Token stop = end.stop != null ? end.stop : begin.stop.     Interval interval = new Interval(start.getStartIndex(), stop.getStopIndex()).     String text = start.getInputStream().getText(interval).     return new Source(new Location(start.getLine(), start.getCharPositionInLine()), text). }
false;static;2;8;;static Source source(TerminalNode begin, ParserRuleContext end) {     Check.notNull(begin, "begin is null").     Check.notNull(end, "end is null").     Token start = begin.getSymbol().     Token stop = end.stop != null ? end.stop : start.     String text = start.getInputStream().getText(new Interval(start.getStartIndex(), stop.getStopIndex())).     return new Source(new Location(start.getLine(), start.getCharPositionInLine()), text). }
true;static;1;3;/**  * Retrieves the raw text of the node (without interpreting it as a string literal).  */ ;/**  * Retrieves the raw text of the node (without interpreting it as a string literal).  */ static String text(ParseTree node) {     return node == null ? null : node.getText(). }
true;static;1;3;/**  * Extracts the actual unescaped string (literal) value of a terminal node.  */ ;/**  * Extracts the actual unescaped string (literal) value of a terminal node.  */ static String string(TerminalNode node) {     return node == null ? null : unquoteString(node.getText()). }
false;static;1;4;;static String unquoteString(String text) {     // remove leading and trailing ' for strings and also eliminate escaped single quotes     return text == null ? null : text.substring(1, text.length() - 1).replace("''", "'"). }
false;public;1;5;;@Override public Object visitTerminal(TerminalNode node) {     Source source = source(node).     throw new ParsingException(source, "Does not know how to handle {}", source.text()). }
