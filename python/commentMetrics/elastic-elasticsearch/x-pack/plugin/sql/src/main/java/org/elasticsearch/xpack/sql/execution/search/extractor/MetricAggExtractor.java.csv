commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(name).     out.writeString(property).     out.writeOptionalString(innerKey). }
false;;0;3;;String name() {     return name. }
false;;0;3;;String property() {     return property. }
false;;0;3;;String innerKey() {     return innerKey. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;25;;@Override public Object extract(Bucket bucket) {     InternalAggregation agg = bucket.getAggregations().get(name).     if (agg == null) {         throw new SqlIllegalArgumentException("Cannot find an aggregation named {}", name).     }     if (!containsValues(agg)) {         return null.     }     if (agg instanceof InternalNumericMetricsAggregation.MultiValue) {         // }         return ((InternalNumericMetricsAggregation.MultiValue) agg).value(property).     } else if (agg instanceof InternalFilter) {         // COUNT(expr) and COUNT(ALL expr) uses this type of aggregation to account for non-null values only         return ((InternalFilter) agg).getDocCount().     }     Object v = agg.getProperty(property).     return innerKey != null && v instanceof Map ? ((Map<?, ?>) v).get(innerKey) : v. }
true;private,static;1;20;/**  * Check if the given aggregate has been executed and has computed values  * or not (the bucket is null).  *  * Waiting on https://github.com/elastic/elasticsearch/issues/34903  */ ;/**  * Check if the given aggregate has been executed and has computed values  * or not (the bucket is null).  *  * Waiting on https://github.com/elastic/elasticsearch/issues/34903  */ private static boolean containsValues(InternalAggregation agg) {     // Stats & ExtendedStats     if (agg instanceof InternalStats) {         return ((InternalStats) agg).getCount() != 0.     }     if (agg instanceof MatrixStats) {         return ((MatrixStats) agg).getDocCount() != 0.     }     // sum returns 0 even for null. since that's a common case, we return it as such     if (agg instanceof SingleValue) {         return Double.isFinite(((SingleValue) agg).value()).     }     if (agg instanceof PercentileRanks) {         return Double.isFinite(((PercentileRanks) agg).percent(0)).     }     if (agg instanceof Percentiles) {         return Double.isFinite(((Percentiles) agg).percentile(0)).     }     return true. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(name, property, innerKey). }
false;public;1;15;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     MetricAggExtractor other = (MetricAggExtractor) obj.     return Objects.equals(name, other.name) && Objects.equals(property, other.property) && Objects.equals(innerKey, other.innerKey). }
false;public;0;5;;@Override public String toString() {     String i = innerKey != null ? "[" + innerKey + "]" : "".     return Aggs.ROOT_GROUP_NAME + ">" + name + "." + property + i. }
