commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected NodeInfo<Debug> info() {     return NodeInfo.create(this, Debug::new, plan, type, format). }
false;public;0;3;;public LogicalPlan plan() {     return plan. }
false;public;0;3;;public Format format() {     return format. }
false;public;0;3;;public Type type() {     return type. }
false;public;0;4;;@Override public List<Attribute> output() {     return singletonList(new FieldAttribute(source(), "plan", new KeywordEsField("plan"))). }
false;public;2;14;;@Override public void execute(SqlSession session, ActionListener<SchemaRowSet> listener) {     switch(type) {         case ANALYZED:             session.debugAnalyzedPlan(plan, wrap(i -> handleInfo(i, listener), listener::onFailure)).             break.         case OPTIMIZED:             session.analyzedPlan(plan, true, wrap(analyzedPlan -> handleInfo(session.optimizer().debugOptimize(analyzedPlan), listener), listener::onFailure)).             break.         default:             break.     } }
false;private;2;48;;@SuppressWarnings({ "rawtypes", "unchecked" }) private void handleInfo(ExecutionInfo info, ActionListener<SchemaRowSet> listener) {     String planString = null.     if (format == Format.TEXT) {         StringBuilder sb = new StringBuilder().         if (info == null) {             sb.append(plan.toString()).         } else {             Map<Batch, List<Transformation>> map = info.transformations().             for (Entry<Batch, List<Transformation>> entry : map.entrySet()) {                 // for each batch                 sb.append("***").                 sb.append(entry.getKey().name()).                 sb.append("***").                 for (Transformation tf : entry.getValue()) {                     sb.append(tf.ruleName()).                     sb.append("\n").                     sb.append(NodeUtils.diffString(tf.before(), tf.after())).                     sb.append("\n").                 }             }         }         planString = sb.toString().     } else {         if (info == null) {             planString = Graphviz.dot("Planned", plan).         } else {             Map<String, Node<?>> plans = new LinkedHashMap<>().             Map<Batch, List<Transformation>> map = info.transformations().             plans.put("start", info.before()).             for (Entry<Batch, List<Transformation>> entry : map.entrySet()) {                 // for each batch                 int counter = 0.                 for (Transformation tf : entry.getValue()) {                     if (tf.hasChanged()) {                         plans.put(tf.ruleName() + "#" + ++counter, tf.after()).                     }                 }             }             planString = Graphviz.dot(plans, true).         }     }     listener.onResponse(Rows.singleton(output(), planString)). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(plan, type, format). }
false;public;1;11;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if ((obj == null) || (getClass() != obj.getClass())) {         return false.     }     Debug o = (Debug) obj.     return Objects.equals(format, o.format) && Objects.equals(type, o.type) && Objects.equals(plan, o.plan). }
