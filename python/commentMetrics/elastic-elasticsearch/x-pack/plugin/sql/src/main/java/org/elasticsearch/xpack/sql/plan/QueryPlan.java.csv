commented;modifiers;parameterAmount;loc;comment;code
false;public,abstract;0;1;;public abstract List<Attribute> output().
false;public;0;6;;public AttributeSet outputSet() {     if (lazyOutputSet == null) {         lazyOutputSet = new AttributeSet(output()).     }     return lazyOutputSet. }
false;public;0;10;;public AttributeSet inputSet() {     if (lazyInputSet == null) {         List<Attribute> attrs = new ArrayList<>().         for (PlanType child : children()) {             attrs.addAll(child.output()).         }         lazyInputSet = new AttributeSet(attrs).     }     return lazyInputSet. }
false;public;1;3;;public PlanType transformExpressionsOnly(Function<? super Expression, ? extends Expression> rule) {     return transformPropertiesOnly(e -> doTransformExpression(e, exp -> exp.transformDown(rule)), Object.class). }
false;public;1;3;;public PlanType transformExpressionsDown(Function<? super Expression, ? extends Expression> rule) {     return transformPropertiesDown(e -> doTransformExpression(e, exp -> exp.transformDown(rule)), Object.class). }
false;public;1;3;;public PlanType transformExpressionsUp(Function<? super Expression, ? extends Expression> rule) {     return transformPropertiesUp(e -> doTransformExpression(e, exp -> exp.transformUp(rule)), Object.class). }
false;private;2;34;;private <E extends Expression> Object doTransformExpression(Object arg, Function<? super Expression, E> traversal) {     if (arg instanceof Expression) {         return traversal.apply((Expression) arg).     }     if (arg instanceof DataType || arg instanceof Map) {         return arg.     }     if (arg instanceof Collection) {         Collection<?> c = (Collection<?>) arg.         List<Object> transformed = new ArrayList<>(c.size()).         boolean hasChanged = false.         for (Object e : c) {             Object next = doTransformExpression(e, traversal).             if (!e.equals(next)) {                 hasChanged = true.             } else {                 // use the initial value                 next = e.             }             transformed.add(next).         }         return hasChanged ? transformed : arg.     }     return arg. }
false;public;1;3;;public void forEachExpressionsDown(Consumer<? super Expression> rule) {     forEachPropertiesDown(e -> doForEachExpression(e, exp -> exp.forEachDown(rule)), Object.class). }
false;public;1;3;;public void forEachExpressionsUp(Consumer<? super Expression> rule) {     forEachPropertiesUp(e -> doForEachExpression(e, exp -> exp.forEachUp(rule)), Object.class). }
false;public;1;3;;public void forEachExpressions(Consumer<? super Expression> rule) {     forEachPropertiesOnly(e -> doForEachExpression(e, rule::accept), Object.class). }
false;private;2;11;;private void doForEachExpression(Object arg, Consumer<? super Expression> traversal) {     if (arg instanceof Expression) {         traversal.accept((Expression) arg).     } else if (arg instanceof Collection) {         Collection<?> c = (Collection<?>) arg.         for (Object o : c) {             doForEachExpression(o, traversal).         }     } }
