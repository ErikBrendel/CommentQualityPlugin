commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;15;;public static long inMillis(Literal literal) {     Object fold = Foldables.valueOf(literal).     Check.isTrue(fold instanceof Interval, "Expected interval, received [{}]", fold).     TemporalAmount interval = ((Interval<?>) fold).interval().     long millis = 0.     if (interval instanceof Period) {         Period p = (Period) interval.         millis = p.toTotalMonths() * 30 * 24 * 60 * 60 * 1000.     } else {         Duration d = (Duration) interval.         millis = d.toMillis().     }     return millis. }
false;public,static;3;26;;public static TemporalAmount of(Source source, long duration, TimeUnit unit) {     // Further more Period and Duration have inconsistent addition methods but plus is there     try {         switch(unit) {             case YEAR:                 return Period.ZERO.plusYears(duration).             case MONTH:                 return Period.ZERO.plusMonths(duration).             case DAY:                 return Duration.ZERO.plusDays(duration).             case HOUR:                 return Duration.ZERO.plusHours(duration).             case MINUTE:                 return Duration.ZERO.plusMinutes(duration).             case SECOND:                 return Duration.ZERO.plusSeconds(duration).             case MILLISECOND:                 return Duration.ZERO.plusMillis(duration).             default:                 throw new ParsingException(source, "Cannot parse duration [{}]", unit).         }     } catch (ArithmeticException ae) {         throw new ParsingException(source, "Value [{}] cannot be used as it is too large to convert into [{}]s", duration, unit).     } }
false;public,static;3;43;;public static DataType intervalType(Source source, TimeUnit leading, TimeUnit trailing) {     if (trailing == null) {         switch(leading) {             case YEAR:                 return DataType.INTERVAL_YEAR.             case MONTH:                 return DataType.INTERVAL_MONTH.             case DAY:                 return DataType.INTERVAL_DAY.             case HOUR:                 return DataType.INTERVAL_HOUR.             case MINUTE:                 return DataType.INTERVAL_MINUTE.             case SECOND:                 return DataType.INTERVAL_SECOND.             default:                 throw new ParsingException(source, "Cannot determine datatype for [{}]", leading).         }     } else {         if (leading == TimeUnit.YEAR && trailing == TimeUnit.MONTH) {             return INTERVAL_YEAR_TO_MONTH.         }         if (leading == TimeUnit.DAY && trailing == TimeUnit.HOUR) {             return INTERVAL_DAY_TO_HOUR.         }         if (leading == TimeUnit.DAY && trailing == TimeUnit.MINUTE) {             return INTERVAL_DAY_TO_MINUTE.         }         if (leading == TimeUnit.DAY && trailing == TimeUnit.SECOND) {             return INTERVAL_DAY_TO_SECOND.         }         if (leading == TimeUnit.HOUR && trailing == TimeUnit.MINUTE) {             return INTERVAL_HOUR_TO_MINUTE.         }         if (leading == TimeUnit.HOUR && trailing == TimeUnit.SECOND) {             return INTERVAL_HOUR_TO_SECOND.         }         if (leading == TimeUnit.MINUTE && trailing == TimeUnit.SECOND) {             return INTERVAL_MINUTE_TO_SECOND.         }         throw new ParsingException(source, "Cannot determine datatype for combination [{}] [{}]", leading, trailing).     } }
false;;1;4;;ParserBuilder unit(TimeUnit unit) {     unit(unit, 0).     return this. }
false;;2;5;;ParserBuilder unit(TimeUnit unit, int maxValue) {     units.add(unit).     tokens.add(new Token((char) 0, maxValue, optional)).     return this. }
false;;1;4;;ParserBuilder separator(char ch) {     tokens.add(new Token(ch, 0, optional)).     return this. }
false;;0;4;;ParserBuilder optional() {     optional = true.     return this. }
false;;0;3;;Parser build() {     return new Parser(units, tokens, name). }
false;public;0;4;;@Override public String toString() {     return ch > 0 ? String.valueOf(ch) : "[numeric]". }
false;;2;94;;TemporalAmount parse(Source source, String string) {     int unitIndex = 0.     int startToken = 0.     int endToken = 0.     long[] values = new long[units.size()].     boolean negate = false.     // first check if there's a sign     char maybeSign = string.charAt(0).     if (PLUS == maybeSign) {         startToken = 1.     } else if (MINUS == maybeSign) {         startToken = 1.         negate = true.     }     // validate each token and that the whole string is consumed     for (Token token : tokens) {         endToken = startToken.         if (startToken >= string.length()) {             // consumed the string, bail out             if (token.optional) {                 break.             }             throw new ParsingException(source, invalidIntervalMessage(string) + ": incorrect format, expecting {}", Strings.collectionToDelimitedString(tokens, "")).         }         // char token         if (token.ch != 0) {             char found = string.charAt(startToken).             if (found != token.ch) {                 throw new ParsingException(source, invalidIntervalMessage(string) + ": expected [{}] (at [{}]) but found [{}]", token.ch, startToken, found).             }             startToken++.         } else // number char         {             // go through the group the digits             for (. endToken < string.length() && Character.isDigit(string.charAt(endToken)). endToken++) {             }             if (endToken == startToken) {                 throw new ParsingException(source, invalidIntervalMessage(string) + ": expected digit (at [{}]) but found [{}]", endToken, string.charAt(endToken)).             }             String number = string.substring(startToken, endToken).             try {                 long v = StringUtils.parseLong(number).                 if (token.maxValue > 0 && v > token.maxValue) {                     throw new ParsingException(source, invalidIntervalMessage(string) + ": [{}] unit has illegal value [{}], expected a positive number up to [{}]", units.get(unitIndex).name(), v, token.maxValue).                 }                 if (v < 0) {                     throw new ParsingException(source, invalidIntervalMessage(string) + ": negative value [{}] not allowed (negate the entire interval instead)", v).                 }                 values[unitIndex++] = v.             } catch (SqlIllegalArgumentException siae) {                 throw new ParsingException(source, invalidIntervalMessage(string), siae.getMessage()).             }             startToken = endToken.         }     }     if (endToken <= string.length() - 1) {         throw new ParsingException(source, invalidIntervalMessage(string) + ": unexpected trailing characters found [{}]", string.substring(endToken)).     }     TemporalAmount interval = units.get(0) == TimeUnit.YEAR || units.get(0) == TimeUnit.MONTH ? Period.ZERO : Duration.ZERO.     for (int i = 0. i < values.length. i++) {         TemporalAmount ta = of(source, values[i], units.get(i)).         interval = ta instanceof Period ? ((Period) ta).plus(interval) : ((Duration) ta).plus((Duration) interval).     }     if (negate) {         interval = negate(interval).     }     return interval. }
false;private;1;3;;private String invalidIntervalMessage(String interval) {     return "Invalid [" + name + "] value [" + interval + "]". }
false;public;0;4;;@Override public String toString() {     return name. }
false;public,static;1;4;;public static TemporalAmount negate(TemporalAmount interval) {     // negated is not present on TemporalAmount though present in both Period and Duration so handle each class individually     return interval instanceof Period ? ((Period) interval).negated() : ((Duration) interval).negated(). }
false;public,static;3;3;;public static TemporalAmount parseInterval(Source source, String value, DataType intervalType) {     return PARSERS.get(intervalType).parse(source, value). }
false;public,static;0;8;;public static Collection<? extends Entry> getNamedWriteables() {     List<NamedWriteableRegistry.Entry> entries = new ArrayList<>().     entries.add(new Entry(IntervalDayTime.class, IntervalDayTime.NAME, IntervalDayTime::new)).     entries.add(new Entry(IntervalYearMonth.class, IntervalYearMonth.NAME, IntervalYearMonth::new)).     return entries. }
