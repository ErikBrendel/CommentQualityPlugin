commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;7;;@Override public final Pipe replaceChildren(List<Pipe> newChildren) {     if (newChildren.size() < 2) {         throw new IllegalArgumentException("expected at least [2] children but received [" + newChildren.size() + "]").     }     return new InPipe(source(), expression(), newChildren). }
false;protected;0;4;;@Override protected NodeInfo<InPipe> info() {     return NodeInfo.create(this, InPipe::new, expression(), pipes). }
false;public;0;4;;@Override public boolean supportedByAggsOnlyQuery() {     return pipes.stream().allMatch(FieldExtraction::supportedByAggsOnlyQuery). }
false;public,final;1;8;;@Override public final Pipe resolveAttributes(AttributeResolver resolver) {     List<Pipe> newPipes = new ArrayList<>(pipes.size()).     for (Pipe p : pipes) {         newPipes.add(p.resolveAttributes(resolver)).     }     return replaceChildren(newPipes). }
false;public;0;4;;@Override public boolean resolved() {     return Resolvables.resolved(pipes). }
false;public,final;1;4;;@Override public final void collectFields(SqlSourceBuilder sourceBuilder) {     pipes.forEach(p -> p.collectFields(sourceBuilder)). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(pipes). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     InPipe other = (InPipe) obj.     return Objects.equals(pipes, other.pipes). }
false;public;0;4;;@Override public InProcessor asProcessor() {     return new InProcessor(pipes.stream().map(Pipe::asProcessor).collect(Collectors.toList())). }
