commented;modifiers;parameterAmount;loc;comment;code
false;;1;4;;@Override boolean reached(int runs) {     return runs >= 1. }
false;;1;6;;boolean reached(int runs) {     if (runs >= this.runs) {         throw new RuleExecutionException("Rule execution limit %d reached", runs).     }     return false. }
false;public;0;3;;public String name() {     return name. }
false;protected,abstract;0;1;;protected abstract Iterable<RuleExecutor<TreeType>.Batch> batches().
false;public;0;6;;public boolean hasChanged() {     if (lazyHasChanged == null) {         lazyHasChanged = !before.equals(after).     }     return lazyHasChanged. }
false;public;0;3;;public String ruleName() {     return rule.name(). }
false;public;0;3;;public TreeType before() {     return before. }
false;public;0;3;;public TreeType after() {     return after. }
false;public;0;3;;public TreeType before() {     return before. }
false;public;0;3;;public TreeType after() {     return after. }
false;public;0;3;;public Map<Batch, List<Transformation>> transformations() {     return transformations. }
false;protected;1;3;;protected TreeType execute(TreeType plan) {     return executeWithInfo(plan).after. }
false;protected;1;65;;protected ExecutionInfo executeWithInfo(TreeType plan) {     TreeType currentPlan = plan.     long totalDuration = 0.     Map<Batch, List<Transformation>> transformations = new LinkedHashMap<>().     for (Batch batch : batches) {         int batchRuns = 0.         List<Transformation> tfs = new ArrayList<Transformation>().         transformations.put(batch, tfs).         boolean hasChanged = false.         long batchStart = System.currentTimeMillis().         long batchDuration = 0.         // run each batch until no change occurs or the limit is reached         do {             hasChanged = false.             batchRuns++.             for (Rule<?, TreeType> rule : batch.rules) {                 if (log.isTraceEnabled()) {                     log.trace("About to apply rule {}", rule).                 }                 Transformation tf = new Transformation(currentPlan, rule).                 tfs.add(tf).                 currentPlan = tf.after.                 if (tf.hasChanged()) {                     hasChanged = true.                     if (log.isTraceEnabled()) {                         log.trace("Rule {} applied\n{}", rule, NodeUtils.diffString(tf.before, tf.after)).                     }                 } else {                     if (log.isTraceEnabled()) {                         log.trace("Rule {} applied w/o changes", rule).                     }                 }             }             batchDuration = System.currentTimeMillis() - batchStart.         } while (hasChanged && !batch.limit.reached(batchRuns)).         totalDuration += batchDuration.         if (log.isTraceEnabled()) {             TreeType before = plan.             TreeType after = plan.             if (!tfs.isEmpty()) {                 before = tfs.get(0).before.                 after = tfs.get(tfs.size() - 1).after.             }             log.trace("Batch {} applied took {}\n{}", batch.name, TimeValue.timeValueMillis(batchDuration), NodeUtils.diffString(before, after)).         }     }     if (false == currentPlan.equals(plan) && log.isDebugEnabled()) {         log.debug("Tree transformation took {}\n{}", TimeValue.timeValueMillis(totalDuration), NodeUtils.diffString(plan, currentPlan)).     }     return new ExecutionInfo(plan, currentPlan, transformations). }
