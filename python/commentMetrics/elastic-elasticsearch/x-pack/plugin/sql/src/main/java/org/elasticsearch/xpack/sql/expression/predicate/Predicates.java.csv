commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;10;;public static List<Expression> splitAnd(Expression exp) {     if (exp instanceof And) {         And and = (And) exp.         List<Expression> list = new ArrayList<>().         list.addAll(splitAnd(and.left())).         list.addAll(splitAnd(and.right())).         return list.     }     return singletonList(exp). }
false;public,static;1;10;;public static List<Expression> splitOr(Expression exp) {     if (exp instanceof Or) {         Or or = (Or) exp.         List<Expression> list = new ArrayList<>().         list.addAll(splitOr(or.left())).         list.addAll(splitOr(or.right())).         return list.     }     return singletonList(exp). }
false;public,static;1;3;;public static Expression combineOr(List<Expression> exps) {     return combine(exps, (l, r) -> new Or(l.source(), l, r)). }
false;public,static;1;3;;public static Expression combineAnd(List<Expression> exps) {     return combine(exps, (l, r) -> new And(l.source(), l, r)). }
true;private,static;2;20;/**  * Build a binary 'pyramid' from the given list:  * <pre>  *       AND  *      /   \  *   AND     AND  *  /   \   /   \  * A     B C     D  * </pre>  *  * using the given combiner.  *  * While a bit longer, this method creates a balanced tree as oppose to a plain  * recursive approach which creates an unbalanced one (either to the left or right).  */ ;/**  * Build a binary 'pyramid' from the given list:  * <pre>  *       AND  *      /   \  *   AND     AND  *  /   \   /   \  * A     B C     D  * </pre>  *  * using the given combiner.  *  * While a bit longer, this method creates a balanced tree as oppose to a plain  * recursive approach which creates an unbalanced one (either to the left or right).  */ private static Expression combine(List<Expression> exps, BiFunction<Expression, Expression, Expression> combiner) {     if (exps.isEmpty()) {         return null.     }     // clone the list (to modify it)     List<Expression> result = new ArrayList<>(exps).     while (result.size() > 1) {         // NB: this loop modifies the list (just like an array)         for (int i = 0. i < result.size() - 1. i++) {             Expression l = result.remove(i).             Expression r = result.remove(i).             result.add(i, combiner.apply(l, r)).         }     }     return result.get(0). }
false;public,static;2;11;;public static List<Expression> inCommon(List<Expression> l, List<Expression> r) {     List<Expression> common = new ArrayList<>(Math.min(l.size(), r.size())).     for (Expression lExp : l) {         for (Expression rExp : r) {             if (lExp.semanticEquals(rExp)) {                 common.add(lExp).             }         }     }     return common.isEmpty() ? emptyList() : common. }
false;public,static;2;11;;public static List<Expression> subtract(List<Expression> from, List<Expression> r) {     List<Expression> diff = new ArrayList<>(Math.min(from.size(), r.size())).     for (Expression lExp : from) {         for (Expression rExp : r) {             if (!lExp.semanticEquals(rExp)) {                 diff.add(lExp).             }         }     }     return diff.isEmpty() ? emptyList() : diff. }
false;public,static;2;3;;public static boolean canEvaluate(Expression exp, LogicalPlan plan) {     return exp.references().subsetOf(plan.outputSet()). }
