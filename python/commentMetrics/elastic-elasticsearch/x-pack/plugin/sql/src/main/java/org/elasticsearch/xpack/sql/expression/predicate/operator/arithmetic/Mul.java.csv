commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;24;;@Override protected TypeResolution resolveType() {     if (!childrenResolved()) {         return new TypeResolution("Unresolved children").     }     DataType l = left().dataType().     DataType r = right().dataType().     // 1. both are numbers     if (l.isNumeric() && r.isNumeric()) {         return TypeResolution.TYPE_RESOLVED.     }     if (DataTypes.isInterval(l) && r.isInteger()) {         dataType = l.         return TypeResolution.TYPE_RESOLVED.     } else if (DataTypes.isInterval(r) && l.isInteger()) {         dataType = r.         return TypeResolution.TYPE_RESOLVED.     }     return new TypeResolution(format("[{}] has arguments with incompatible types [{}] and [{}]", symbol(), l, r)). }
false;public;0;7;;@Override public DataType dataType() {     if (dataType == null) {         dataType = super.dataType().     }     return dataType. }
false;protected;0;4;;@Override protected NodeInfo<Mul> info() {     return NodeInfo.create(this, Mul::new, left(), right()). }
false;protected;2;4;;@Override protected Mul replaceChildren(Expression newLeft, Expression newRight) {     return new Mul(source(), newLeft, newRight). }
