commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeGenericValue(data).     out.writeVInt(columnCount).     out.writeVInt(pageSize). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;;0;3;;List<List<?>> data() {     return data. }
false;;0;3;;int columnCount() {     return columnCount. }
false;;0;3;;int pageSize() {     return pageSize. }
false;public;4;6;;@Override public void nextPage(Configuration cfg, Client client, NamedWriteableRegistry registry, ActionListener<RowSet> listener) {     // the check is really a safety measure since the page initialization handles it already (by returning an empty cursor)     List<List<?>> nextData = data.size() > pageSize ? data.subList(pageSize, data.size()) : emptyList().     listener.onResponse(new PagingListRowSet(nextData, columnCount, pageSize)). }
false;public;3;4;;@Override public void clear(Configuration cfg, Client client, ActionListener<Boolean> listener) {     listener.onResponse(true). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(data, columnCount, pageSize). }
false;public;1;15;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     PagingListCursor other = (PagingListCursor) obj.     return Objects.equals(pageSize, other.pageSize) && Objects.equals(columnCount, other.columnCount) && Objects.equals(data, other.data). }
false;public;0;4;;@Override public String toString() {     return "cursor for paging list". }
