commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected NodeInfo<SysTables> info() {     return NodeInfo.create(this, SysTables::new, clusterPattern, index, pattern, types, legacyTableTypes). }
false;public;0;14;;@Override public List<Attribute> output() {     return asList(keyword("TABLE_CAT"), keyword("TABLE_SCHEM"), keyword("TABLE_NAME"), keyword("TABLE_TYPE"), keyword("REMARKS"), keyword("TYPE_CAT"), keyword("TYPE_SCHEM"), keyword("TYPE_NAME"), keyword("SELF_REFERENCING_COL_NAME"), keyword("REF_GENERATION")). }
false;public,final;2;66;;@Override public final void execute(SqlSession session, ActionListener<SchemaRowSet> listener) {     String cluster = session.indexResolver().clusterName().     if (clusterPattern != null && clusterPattern.pattern().equals(SQL_WILDCARD)) {         if ((pattern == null || pattern.pattern().isEmpty()) && CollectionUtils.isEmpty(types)) {             Object[] enumeration = new Object[10].             // send only the cluster, everything else null             enumeration[0] = cluster.             listener.onResponse(Rows.singleton(output(), enumeration)).             return.         }     }     // if no types were specified (the parser takes care of the % case)     if (IndexType.VALID.equals(types)) {         if ((clusterPattern == null || clusterPattern.pattern().isEmpty()) && (pattern == null || pattern.pattern().isEmpty())) {             List<List<?>> values = new ArrayList<>().             // send only the types, everything else null             for (IndexType type : IndexType.VALID) {                 Object[] enumeration = new Object[10].                 enumeration[3] = type.toSql().                 values.add(asList(enumeration)).             }             values.sort(Comparator.comparing(l -> l.get(3).toString())).             listener.onResponse(Rows.of(output(), values)).             return.         }     }     String cRegex = clusterPattern != null ? clusterPattern.asJavaRegex() : null.     // if the catalog doesn't match, don't return any results     if (cRegex != null && !Pattern.matches(cRegex, cluster)) {         listener.onResponse(Rows.empty(output())).         return.     }     String idx = index != null ? index : (pattern != null ? pattern.asIndexNameWildcard() : "*").     String regex = pattern != null ? pattern.asJavaRegex() : null.     session.indexResolver().resolveNames(idx, regex, types, ActionListener.wrap(result -> listener.onResponse(Rows.of(output(), result.stream().sorted(Comparator.<IndexInfo, String>comparing(i -> legacyName(i.type())).thenComparing(Comparator.comparing(i -> i.name()))).map(t -> asList(cluster, EMPTY, t.name(), legacyName(t.type()), EMPTY, null, null, null, null, null)).collect(toList()))), listener::onFailure)). }
false;private;1;3;;private String legacyName(IndexType indexType) {     return legacyTableTypes && indexType == IndexType.INDEX ? "TABLE" : indexType.toSql(). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(clusterPattern, index, pattern, types). }
false;public;1;16;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     SysTables other = (SysTables) obj.     return Objects.equals(clusterPattern, other.clusterPattern) && Objects.equals(index, other.index) && Objects.equals(pattern, other.pattern) && Objects.equals(types, other.types). }
