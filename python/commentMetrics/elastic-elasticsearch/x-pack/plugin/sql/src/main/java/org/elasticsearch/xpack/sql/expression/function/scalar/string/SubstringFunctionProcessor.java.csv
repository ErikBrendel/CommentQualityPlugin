commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;6;;@Override public final void writeTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(source).     out.writeNamedWriteable(start).     out.writeNamedWriteable(length). }
false;public;1;4;;@Override public Object process(Object input) {     return doProcess(source.process(input), start.process(input), length.process(input)). }
false;public,static;3;24;;public static Object doProcess(Object source, Object start, Object length) {     if (source == null) {         return null.     }     if (!(source instanceof String || source instanceof Character)) {         throw new SqlIllegalArgumentException("A string/char is required. received [{}]", source).     }     if (start == null || length == null) {         return source.     }     if (!(start instanceof Number)) {         throw new SqlIllegalArgumentException("A number is required. received [{}]", start).     }     if (!(length instanceof Number)) {         throw new SqlIllegalArgumentException("A number is required. received [{}]", length).     }     if (((Number) length).intValue() < 0) {         throw new SqlIllegalArgumentException("A positive number is required for [length]. received [{}]", length).     }     return StringFunctionUtils.substring(source instanceof Character ? source.toString() : (String) source, // SQL is 1-based when it comes to string manipulation     ((Number) start).intValue() - 1, ((Number) length).intValue()). }
false;protected;0;3;;protected Processor source() {     return source. }
false;protected;0;3;;protected Processor start() {     return start. }
false;protected;0;3;;protected Processor length() {     return length. }
false;public;1;15;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     SubstringFunctionProcessor other = (SubstringFunctionProcessor) obj.     return Objects.equals(source(), other.source()) && Objects.equals(start(), other.start()) && Objects.equals(length(), other.length()). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(source(), start(), length()). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
