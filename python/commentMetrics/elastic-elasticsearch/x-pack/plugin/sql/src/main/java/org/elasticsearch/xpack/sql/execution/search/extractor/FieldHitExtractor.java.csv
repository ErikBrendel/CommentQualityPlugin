commented;modifiers;parameterAmount;loc;comment;code
true;private,static;3;4;/**  * Source extraction requires only the (relative) field name, without its parent path.  */ ;/**  * Source extraction requires only the (relative) field name, without its parent path.  */ private static String[] sourcePath(String name, boolean useDocValue, String hitName) {     return useDocValue ? Strings.EMPTY_ARRAY : Strings.tokenizeToStringArray(hitName == null ? name : name.substring(hitName.length() + 1), "."). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeOptionalString(dataType == null ? null : dataType.typeName).     out.writeBoolean(useDocValue).     out.writeOptionalString(hitName). }
false;public;1;16;;@Override public Object extract(SearchHit hit) {     Object value = null.     if (useDocValue) {         DocumentField field = hit.field(fieldName).         if (field != null) {             value = unwrapMultiValue(field.getValues()).         }     } else {         Map<String, Object> source = hit.getSourceAsMap().         if (source != null) {             value = extractFromSource(source).         }     }     return value. }
false;private;1;29;;private Object unwrapMultiValue(Object values) {     if (values == null) {         return null.     }     if (values instanceof List) {         List<?> list = (List<?>) values.         if (list.isEmpty()) {             return null.         } else {             if (ARRAYS_LENIENCY || list.size() == 1) {                 return unwrapMultiValue(list.get(0)).             } else {                 throw new SqlIllegalArgumentException("Arrays (returned by [{}]) are not supported", fieldName).             }         }     }     if (values instanceof Map) {         throw new SqlIllegalArgumentException("Objects (returned by [{}]) are not supported", fieldName).     }     if (dataType == DataType.DATETIME) {         if (values instanceof String) {             return DateUtils.asDateTime(Long.parseLong(values.toString())).         }     }     if (values instanceof Long || values instanceof Double || values instanceof String || values instanceof Boolean) {         return values.     }     throw new SqlIllegalArgumentException("Type {} (returned by [{}]) is not supported", values.getClass().getSimpleName(), fieldName). }
false;;1;49;;@SuppressWarnings("unchecked") Object extractFromSource(Map<String, Object> map) {     Object value = null.     // Used to avoid recursive method calls     // Holds the sub-maps in the document hierarchy that are pending to be inspected.     // along with the current index of the `path`.     Deque<Tuple<Integer, Map<String, Object>>> queue = new ArrayDeque<>().     queue.add(new Tuple<>(-1, map)).     while (!queue.isEmpty()) {         Tuple<Integer, Map<String, Object>> tuple = queue.removeLast().         int idx = tuple.v1().         Map<String, Object> subMap = tuple.v2().         // Find all possible entries by examining all combinations under the current level ("idx") of the "path"         // e.g.: If the path == "a.b.c.d" and the idx == 0, we need to check the current subMap against the keys:         // "b", "b.c" and "b.c.d"         StringJoiner sj = new StringJoiner(".").         for (int i = idx + 1. i < path.length. i++) {             sj.add(path[i]).             Object node = subMap.get(sj.toString()).             if (node instanceof Map) {                 if (i < path.length - 1) {                     // Add the sub-map to the queue along with the current path index                     queue.add(new Tuple<>(i, (Map<String, Object>) node)).                 } else {                     // We exhausted the path and got a map                     // If it is an object - it will be handled in the value extractor                     value = node.                 }             } else if (node != null) {                 if (i < path.length - 1) {                     // e.g.: map is {"a" : { "b" : "value }} and we are looking for a path: "a.b.c.d"                     throw new SqlIllegalArgumentException("Cannot extract value [{}] from source", fieldName).                 }                 if (value != null) {                     // e.g.: {"a" : {"b" : {"c" : "value"}}}, {"a.b" : {"c" : "value"}}, ...                     throw new SqlIllegalArgumentException("Multiple values (returned by [{}]) are not supported", fieldName).                 }                 value = node.             }         }     }     return unwrapMultiValue(value). }
false;public;0;4;;@Override public String hitName() {     return hitName. }
false;public;0;3;;public String fieldName() {     return fieldName. }
false;public;0;4;;@Override public String toString() {     return fieldName + "@" + hitName. }
false;public;1;10;;@Override public boolean equals(Object obj) {     if (obj == null || obj.getClass() != getClass()) {         return false.     }     FieldHitExtractor other = (FieldHitExtractor) obj.     return fieldName.equals(other.fieldName) && hitName.equals(other.hitName) && useDocValue == other.useDocValue. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(fieldName, useDocValue, hitName). }
