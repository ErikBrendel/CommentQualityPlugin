commented;modifiers;parameterAmount;loc;comment;code
false;public;2;6;;@Override public boolean containsNestedField(String path, String field) {     boolean iContainThisField = this.path.equals(path) && fields.containsKey(field).     boolean myChildContainsThisField = child.containsNestedField(path, field).     return iContainThisField || myChildContainsThisField. }
false;public;4;19;;@Override public Query addNestedField(String path, String field, String format, boolean hasDocValues) {     if (false == this.path.equals(path)) {         // I'm not at the right path so let my child query have a crack at it         Query rewrittenChild = child.addNestedField(path, field, format, hasDocValues).         if (rewrittenChild == child) {             return this.         }         return new NestedQuery(source(), path, fields, rewrittenChild).     }     if (fields.containsKey(field)) {         // I already have the field, no rewriting needed         return this.     }     Map<String, Map.Entry<Boolean, String>> newFields = new HashMap<>(fields.size() + 1).     newFields.putAll(fields).     newFields.put(field, new AbstractMap.SimpleImmutableEntry<>(hasDocValues, format)).     return new NestedQuery(source(), path, unmodifiableMap(newFields), child). }
false;public;1;12;;@Override public void enrichNestedSort(NestedSortBuilder sort) {     child.enrichNestedSort(sort).     if (false == sort.getPath().equals(path)) {         return.     }     QueryBuilder childAsBuilder = child.asBuilder().     if (sort.getFilter() != null && false == sort.getFilter().equals(childAsBuilder)) {         throw new SqlIllegalArgumentException("nested query should have been grouped in one place").     }     sort.setFilter(childAsBuilder). }
false;public;0;36;;@Override public QueryBuilder asBuilder() {     // disable score     NestedQueryBuilder query = nestedQuery(path, child.asBuilder(), ScoreMode.None).     if (!fields.isEmpty()) {         InnerHitBuilder ihb = new InnerHitBuilder().         ihb.setSize(0).         ihb.setSize(MAX_INNER_HITS).         boolean noSourceNeeded = true.         List<String> sourceFields = new ArrayList<>().         for (Map.Entry<String, Map.Entry<Boolean, String>> entry : fields.entrySet()) {             if (entry.getValue().getKey()) {                 ihb.addDocValueField(entry.getKey(), entry.getValue().getValue()).             } else {                 sourceFields.add(entry.getKey()).                 noSourceNeeded = false.             }         }         if (noSourceNeeded) {             ihb.setFetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE).             ihb.setStoredFieldNames(NO_STORED_FIELD).         } else {             ihb.setFetchSourceContext(new FetchSourceContext(true, sourceFields.toArray(new String[sourceFields.size()]), null)).         }         query.innerHit(ihb).     }     return query. }
false;;0;3;;String path() {     return path. }
false;;0;3;;Map<String, Map.Entry<Boolean, String>> fields() {     return fields. }
false;;0;3;;Query child() {     return child. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), path, fields, child). }
false;public;1;10;;@Override public boolean equals(Object obj) {     if (false == super.equals(obj)) {         return false.     }     NestedQuery other = (NestedQuery) obj.     return path.equals(other.path) && fields.equals(other.fields) && child.equals(other.child). }
false;protected;0;4;;@Override protected String innerToString() {     return path + "." + fields + "[" + child + "]". }
