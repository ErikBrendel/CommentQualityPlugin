commented;modifiers;parameterAmount;loc;comment;code
false;private;0;104;;private void defineDefaultFunctions() {     // Aggregate functions     addToMap(def(Avg.class, Avg::new, "AVG"), def(Count.class, Count::new, "COUNT"), def(First.class, First::new, "FIRST", "FIRST_VALUE"), def(Last.class, Last::new, "LAST", "LAST_VALUE"), def(Max.class, Max::new, "MAX"), def(Min.class, Min::new, "MIN"), def(Sum.class, Sum::new, "SUM")).     // Statistics     addToMap(def(StddevPop.class, StddevPop::new, "STDDEV_POP"), def(VarPop.class, VarPop::new, "VAR_POP"), def(Percentile.class, Percentile::new, "PERCENTILE"), def(PercentileRank.class, PercentileRank::new, "PERCENTILE_RANK"), def(SumOfSquares.class, SumOfSquares::new, "SUM_OF_SQUARES"), def(Skewness.class, Skewness::new, "SKEWNESS"), def(Kurtosis.class, Kurtosis::new, "KURTOSIS")).     // histogram     addToMap(def(Histogram.class, Histogram::new, "HISTOGRAM")).     // Scalar functions     // Conditional     addToMap(def(Coalesce.class, Coalesce::new, "COALESCE"), def(IfNull.class, IfNull::new, "IFNULL", "ISNULL", "NVL"), def(NullIf.class, NullIf::new, "NULLIF"), def(Greatest.class, Greatest::new, "GREATEST"), def(Least.class, Least::new, "LEAST")).     // Date     addToMap(def(CurrentDate.class, CurrentDate::new, "CURRENT_DATE", "CURDATE", "TODAY"), def(CurrentDateTime.class, CurrentDateTime::new, "CURRENT_TIMESTAMP", "NOW"), def(DayName.class, DayName::new, "DAY_NAME", "DAYNAME"), def(DayOfMonth.class, DayOfMonth::new, "DAY_OF_MONTH", "DAYOFMONTH", "DAY", "DOM"), def(DayOfWeek.class, DayOfWeek::new, "DAY_OF_WEEK", "DAYOFWEEK", "DOW"), def(DayOfYear.class, DayOfYear::new, "DAY_OF_YEAR", "DAYOFYEAR", "DOY"), def(HourOfDay.class, HourOfDay::new, "HOUR_OF_DAY", "HOUR"), def(IsoDayOfWeek.class, IsoDayOfWeek::new, "ISO_DAY_OF_WEEK", "ISODAYOFWEEK", "ISODOW", "IDOW"), def(IsoWeekOfYear.class, IsoWeekOfYear::new, "ISO_WEEK_OF_YEAR", "ISOWEEKOFYEAR", "ISOWEEK", "IWOY", "IW"), def(MinuteOfDay.class, MinuteOfDay::new, "MINUTE_OF_DAY"), def(MinuteOfHour.class, MinuteOfHour::new, "MINUTE_OF_HOUR", "MINUTE"), def(MonthName.class, MonthName::new, "MONTH_NAME", "MONTHNAME"), def(MonthOfYear.class, MonthOfYear::new, "MONTH_OF_YEAR", "MONTH"), def(SecondOfMinute.class, SecondOfMinute::new, "SECOND_OF_MINUTE", "SECOND"), def(Quarter.class, Quarter::new, "QUARTER"), def(Year.class, Year::new, "YEAR"), def(WeekOfYear.class, WeekOfYear::new, "WEEK_OF_YEAR", "WEEK")).     // Math     addToMap(def(Abs.class, Abs::new, "ABS"), def(ACos.class, ACos::new, "ACOS"), def(ASin.class, ASin::new, "ASIN"), def(ATan.class, ATan::new, "ATAN"), def(ATan2.class, ATan2::new, "ATAN2"), def(Cbrt.class, Cbrt::new, "CBRT"), def(Ceil.class, Ceil::new, "CEIL", "CEILING"), def(Cos.class, Cos::new, "COS"), def(Cosh.class, Cosh::new, "COSH"), def(Cot.class, Cot::new, "COT"), def(Degrees.class, Degrees::new, "DEGREES"), def(E.class, E::new, "E"), def(Exp.class, Exp::new, "EXP"), def(Expm1.class, Expm1::new, "EXPM1"), def(Floor.class, Floor::new, "FLOOR"), def(Log.class, Log::new, "LOG"), def(Log10.class, Log10::new, "LOG10"), // SQL and ODBC require MOD as a _function_     def(Mod.class, Mod::new, "MOD"), def(Pi.class, Pi::new, "PI"), def(Power.class, Power::new, "POWER"), def(Radians.class, Radians::new, "RADIANS"), def(Random.class, Random::new, "RANDOM", "RAND"), def(Round.class, Round::new, "ROUND"), def(Sign.class, Sign::new, "SIGN", "SIGNUM"), def(Sin.class, Sin::new, "SIN"), def(Sinh.class, Sinh::new, "SINH"), def(Sqrt.class, Sqrt::new, "SQRT"), def(Tan.class, Tan::new, "TAN"), def(Truncate.class, Truncate::new, "TRUNCATE")).     // String     addToMap(def(Ascii.class, Ascii::new, "ASCII"), def(BitLength.class, BitLength::new, "BIT_LENGTH"), def(Char.class, Char::new, "CHAR"), def(CharLength.class, CharLength::new, "CHAR_LENGTH", "CHARACTER_LENGTH"), def(Concat.class, Concat::new, "CONCAT"), def(Insert.class, Insert::new, "INSERT"), def(LCase.class, LCase::new, "LCASE"), def(Left.class, Left::new, "LEFT"), def(Length.class, Length::new, "LENGTH"), def(Locate.class, Locate::new, "LOCATE"), def(LTrim.class, LTrim::new, "LTRIM"), def(OctetLength.class, OctetLength::new, "OCTET_LENGTH"), def(Position.class, Position::new, "POSITION"), def(Repeat.class, Repeat::new, "REPEAT"), def(Replace.class, Replace::new, "REPLACE"), def(Right.class, Right::new, "RIGHT"), def(RTrim.class, RTrim::new, "RTRIM"), def(Space.class, Space::new, "SPACE"), def(Substring.class, Substring::new, "SUBSTRING"), def(UCase.class, UCase::new, "UCASE")).     // DataType conversion     addToMap(def(Cast.class, Cast::new, "CAST", "CONVERT")).     // Scalar "meta" functions     addToMap(def(Database.class, Database::new, "DATABASE"), def(User.class, User::new, "USER")).     // Special     addToMap(def(Score.class, Score::new, "SCORE")). }
false;;1;21;;void addToMap(FunctionDefinition... functions) {     // temporary map to hold [function_name/alias_name : function instance]     Map<String, FunctionDefinition> batchMap = new HashMap<>().     for (FunctionDefinition f : functions) {         batchMap.put(f.name(), f).         for (String alias : f.aliases()) {             Object old = batchMap.put(alias, f).             if (old != null || defs.containsKey(alias)) {                 throw new IllegalArgumentException("alias [" + alias + "] is used by " + "[" + (old != null ? old : defs.get(alias).name()) + "] and [" + f.name() + "]").             }             aliases.put(alias, f.name()).         }     }     // sort the temporary map by key name and add it to the global map of functions     defs.putAll(batchMap.entrySet().stream().sorted(Map.Entry.comparingByKey()).collect(Collectors.<Entry<String, FunctionDefinition>, String, FunctionDefinition, LinkedHashMap<String, FunctionDefinition>>toMap(Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -> oldValue, LinkedHashMap::new))). }
false;public;1;9;;public FunctionDefinition resolveFunction(String functionName) {     FunctionDefinition def = defs.get(functionName).     if (def == null) {         throw new SqlIllegalArgumentException("Cannot find function {}. this should have been caught during analysis", functionName).     }     return def. }
false;public;1;4;;public String resolveAlias(String alias) {     String upperCase = alias.toUpperCase(Locale.ROOT).     return aliases.getOrDefault(upperCase, upperCase). }
false;public;1;3;;public boolean functionExists(String functionName) {     return defs.containsKey(functionName). }
false;public;0;7;;public Collection<FunctionDefinition> listFunctions() {     // It is worth double checking if we need this copy. These are immutable anyway.     return defs.entrySet().stream().map(e -> new FunctionDefinition(e.getKey(), emptyList(), e.getValue().clazz(), e.getValue().extractViable(), e.getValue().builder())).collect(toList()). }
false;public;1;9;;public Collection<FunctionDefinition> listFunctions(String pattern) {     // It is worth double checking if we need this copy. These are immutable anyway.     Pattern p = Strings.hasText(pattern) ? Pattern.compile(pattern.toUpperCase(Locale.ROOT)) : null.     return defs.entrySet().stream().filter(e -> p == null || p.matcher(e.getKey()).matches()).map(e -> new FunctionDefinition(e.getKey(), emptyList(), e.getValue().clazz(), e.getValue().extractViable(), e.getValue().builder())).collect(toList()). }
true;static;3;13;/**  * Build a {@linkplain FunctionDefinition} for a no-argument function that  * is not aware of time zone and does not support {@code DISTINCT}.  */ ;/**  * Build a {@linkplain FunctionDefinition} for a no-argument function that  * is not aware of time zone and does not support {@code DISTINCT}.  */ static <T extends Function> FunctionDefinition def(Class<T> function, java.util.function.Function<Source, T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         if (false == children.isEmpty()) {             throw new IllegalArgumentException("expects no arguments").         }         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         return ctorRef.apply(source).     }.     return def(function, builder, false, names). }
true;static;3;14;/**  * Build a {@linkplain FunctionDefinition} for a no-argument function that  * is not aware of time zone, does not support {@code DISTINCT} and needs  * the cluster name (DATABASE()) or the user name (USER()).  */ ;/**  * Build a {@linkplain FunctionDefinition} for a no-argument function that  * is not aware of time zone, does not support {@code DISTINCT} and needs  * the cluster name (DATABASE()) or the user name (USER()).  */ @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, ConfigurationAwareFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         if (false == children.isEmpty()) {             throw new IllegalArgumentException("expects no arguments").         }         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         return ctorRef.build(source, cfg).     }.     return def(function, builder, false, names). }
false;;2;1;;T build(Source source, Configuration configuration).
true;static;3;15;/**  * Build a {@linkplain FunctionDefinition} for a one-argument function that  * is not aware of time zone, does not support {@code DISTINCT} and needs  * the configuration object.  */ ;/**  * Build a {@linkplain FunctionDefinition} for a one-argument function that  * is not aware of time zone, does not support {@code DISTINCT} and needs  * the configuration object.  */ @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, UnaryConfigurationAwareFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         if (children.size() > 1) {             throw new IllegalArgumentException("expects exactly one argument").         }         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         Expression ex = children.size() == 1 ? children.get(0) : null.         return ctorRef.build(source, ex, cfg).     }.     return def(function, builder, false, names). }
false;;3;1;;T build(Source source, Expression exp, Configuration configuration).
true;static;3;14;/**  * Build a {@linkplain FunctionDefinition} for a unary function that is not  * aware of time zone and does not support {@code DISTINCT}.  */ ;/**  * Build a {@linkplain FunctionDefinition} for a unary function that is not  * aware of time zone and does not support {@code DISTINCT}.  */ // These are ambiguous if you aren't using ctor references but we always do @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, BiFunction<Source, Expression, T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         if (children.size() != 1) {             throw new IllegalArgumentException("expects exactly one argument").         }         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         return ctorRef.apply(source, children.get(0)).     }.     return def(function, builder, false, names). }
true;static;3;11;/**  * Build a {@linkplain FunctionDefinition} for multi-arg function that  * is not aware of time zone and does not support {@code DISTINCT}.  */ ;/**  * Build a {@linkplain FunctionDefinition} for multi-arg function that  * is not aware of time zone and does not support {@code DISTINCT}.  */ // These are ambiguous if you aren't using ctor references but we always do @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, MultiFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         return ctorRef.build(source, children).     }.     return def(function, builder, false, names). }
false;;2;1;;T build(Source source, List<Expression> children).
true;static;3;11;/**  * Build a {@linkplain FunctionDefinition} for a unary function that is not  * aware of time zone but does support {@code DISTINCT}.  */ ;/**  * Build a {@linkplain FunctionDefinition} for a unary function that is not  * aware of time zone but does support {@code DISTINCT}.  */ // These are ambiguous if you aren't using ctor references but we always do @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, DistinctAwareUnaryFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         if (children.size() != 1) {             throw new IllegalArgumentException("expects exactly one argument").         }         return ctorRef.build(source, children.get(0), distinct).     }.     return def(function, builder, false, names). }
false;;3;1;;T build(Source source, Expression target, boolean distinct).
true;static;3;14;/**  * Build a {@linkplain FunctionDefinition} for a unary function that  * operates on a datetime.  */ ;/**  * Build a {@linkplain FunctionDefinition} for a unary function that  * operates on a datetime.  */ // These are ambiguous if you aren't using ctor references but we always do @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, DatetimeUnaryFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         if (children.size() != 1) {             throw new IllegalArgumentException("expects exactly one argument").         }         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         return ctorRef.build(source, children.get(0), cfg.zoneId()).     }.     return def(function, builder, true, names). }
false;;3;1;;T build(Source source, Expression target, ZoneId zi).
true;static;3;13;/**  * Build a {@linkplain FunctionDefinition} for a binary function that  * requires a timezone.  */ ;/**  * Build a {@linkplain FunctionDefinition} for a binary function that  * requires a timezone.  */ // These are ambiguous if you aren't using ctor references but we always do @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, DatetimeBinaryFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         if (children.size() != 2) {             throw new IllegalArgumentException("expects exactly two arguments").         }         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         return ctorRef.build(source, children.get(0), children.get(1), cfg.zoneId()).     }.     return def(function, builder, false, names). }
false;;4;1;;T build(Source source, Expression lhs, Expression rhs, ZoneId zi).
true;static;3;19;/**  * Build a {@linkplain FunctionDefinition} for a binary function that is  * not aware of time zone and does not support {@code DISTINCT}.  */ ;/**  * Build a {@linkplain FunctionDefinition} for a binary function that is  * not aware of time zone and does not support {@code DISTINCT}.  */ // These are ambiguous if you aren't using ctor references but we always do @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, BinaryFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         boolean isBinaryOptionalParamFunction = function.isAssignableFrom(Round.class) || function.isAssignableFrom(Truncate.class) || TopHits.class.isAssignableFrom(function).         if (isBinaryOptionalParamFunction && (children.size() > 2 || children.size() < 1)) {             throw new IllegalArgumentException("expects one or two arguments").         } else if (!isBinaryOptionalParamFunction && children.size() != 2) {             throw new IllegalArgumentException("expects exactly two arguments").         }         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         return ctorRef.build(source, children.get(0), children.size() == 2 ? children.get(1) : null).     }.     return def(function, builder, false, names). }
false;;3;1;;T build(Source source, Expression lhs, Expression rhs).
true;private,static;4;15;/**  * Main method to register a function/  * @param names Must always have at least one entry which is the method's primary name  */ ;/**  * Main method to register a function/  * @param names Must always have at least one entry which is the method's primary name  */ @SuppressWarnings("overloads") private static FunctionDefinition def(Class<? extends Function> function, FunctionBuilder builder, boolean datetime, String... names) {     Check.isTrue(names.length > 0, "At least one name must be provided for the function").     String primaryName = names[0].     List<String> aliases = Arrays.asList(names).subList(1, names.length).     FunctionDefinition.Builder realBuilder = (uf, distinct, cfg) -> {         try {             return builder.build(uf.source(), uf.children(), distinct, cfg).         } catch (IllegalArgumentException e) {             throw new ParsingException(uf.source(), "error building [" + primaryName + "]: " + e.getMessage(), e).         }     }.     return new FunctionDefinition(primaryName, unmodifiableList(aliases), function, datetime, realBuilder). }
false;;4;1;;Function build(Source source, List<Expression> children, boolean distinct, Configuration cfg).
false;static;3;17;;// These are ambiguous if you aren't using ctor references but we always do @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, ThreeParametersFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         boolean isLocateFunction = function.isAssignableFrom(Locate.class).         if (isLocateFunction && (children.size() > 3 || children.size() < 2)) {             throw new IllegalArgumentException("expects two or three arguments").         } else if (!isLocateFunction && children.size() != 3) {             throw new IllegalArgumentException("expects exactly three arguments").         }         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         return ctorRef.build(source, children.get(0), children.get(1), children.size() == 3 ? children.get(2) : null).     }.     return def(function, builder, false, names). }
false;;4;1;;T build(Source source, Expression src, Expression exp1, Expression exp2).
false;static;3;14;;// These are ambiguous if you aren't using ctor references but we always do @SuppressWarnings("overloads") static <T extends Function> FunctionDefinition def(Class<T> function, FourParametersFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> {         if (children.size() != 4) {             throw new IllegalArgumentException("expects exactly four arguments").         }         if (distinct) {             throw new IllegalArgumentException("does not support DISTINCT yet it was specified").         }         return ctorRef.build(source, children.get(0), children.get(1), children.get(2), children.get(3)).     }.     return def(function, builder, false, names). }
false;;5;1;;T build(Source source, Expression src, Expression exp1, Expression exp2, Expression exp3).
true;private,static;3;8;/**  * Special method to create function definition for {@link Cast} as its  * signature is not compatible with {@link UnresolvedFunction}  *  * @return Cast function definition  */ ;/**  * Special method to create function definition for {@link Cast} as its  * signature is not compatible with {@link UnresolvedFunction}  *  * @return Cast function definition  */ // These are ambiguous if you aren't using ctor references but we always do @SuppressWarnings("overloads") private static <T extends Function> FunctionDefinition def(Class<T> function, CastFunctionBuilder<T> ctorRef, String... names) {     FunctionBuilder builder = (source, children, distinct, cfg) -> ctorRef.build(source, children.get(0), children.get(0).dataType()).     return def(function, builder, false, names). }
false;;3;1;;T build(Source source, Expression expression, DataType dataType).
