commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;3;;public static TypeResolution isBoolean(Expression e, String operationName, ParamOrdinal paramOrd) {     return isType(e, dt -> dt == BOOLEAN, operationName, paramOrd, "boolean"). }
false;public,static;3;3;;public static TypeResolution isInteger(Expression e, String operationName, ParamOrdinal paramOrd) {     return isType(e, DataType::isInteger, operationName, paramOrd, "integer"). }
false;public,static;3;3;;public static TypeResolution isNumeric(Expression e, String operationName, ParamOrdinal paramOrd) {     return isType(e, DataType::isNumeric, operationName, paramOrd, "numeric"). }
false;public,static;3;3;;public static TypeResolution isString(Expression e, String operationName, ParamOrdinal paramOrd) {     return isType(e, DataType::isString, operationName, paramOrd, "string"). }
false;public,static;3;3;;public static TypeResolution isDate(Expression e, String operationName, ParamOrdinal paramOrd) {     return isType(e, DataType::isDateBased, operationName, paramOrd, "date", "datetime"). }
false;public,static;3;3;;public static TypeResolution isNumericOrDate(Expression e, String operationName, ParamOrdinal paramOrd) {     return isType(e, dt -> dt.isNumeric() || dt.isDateBased(), operationName, paramOrd, "date", "datetime", "numeric"). }
false;public,static;2;9;;public static TypeResolution isExact(Expression e, String message) {     if (e instanceof FieldAttribute) {         EsField.Exact exact = ((FieldAttribute) e).getExactInfo().         if (exact.hasExact() == false) {             return new TypeResolution(format(null, message, e.dataType().typeName, exact.errorMsg())).         }     }     return TypeResolution.TYPE_RESOLVED. }
false;public,static;3;13;;public static TypeResolution isExact(Expression e, String operationName, ParamOrdinal paramOrd) {     if (e instanceof FieldAttribute) {         EsField.Exact exact = ((FieldAttribute) e).getExactInfo().         if (exact.hasExact() == false) {             return new TypeResolution(format(null, "[{}] cannot operate on {}field of data type [{}]: {}", operationName, paramOrd == null || paramOrd == ParamOrdinal.DEFAULT ? "" : paramOrd.name().toLowerCase(Locale.ROOT) + " argument ", e.dataType().typeName, exact.errorMsg())).         }     }     return TypeResolution.TYPE_RESOLVED. }
false;public,static;3;8;;public static TypeResolution isStringAndExact(Expression e, String operationName, ParamOrdinal paramOrd) {     TypeResolution resolution = isString(e, operationName, paramOrd).     if (resolution.unresolved()) {         return resolution.     }     return isExact(e, operationName, paramOrd). }
false;public,static;3;9;;public static TypeResolution isFoldable(Expression e, String operationName, ParamOrdinal paramOrd) {     if (!e.foldable()) {         return new TypeResolution(format(null, "{}argument of [{}] must be a constant, received [{}]", paramOrd == null || paramOrd == ParamOrdinal.DEFAULT ? "" : paramOrd.name().toLowerCase(Locale.ROOT) + " ", operationName, Expressions.name(e))).     }     return TypeResolution.TYPE_RESOLVED. }
false;public,static;3;9;;public static TypeResolution isNotFoldable(Expression e, String operationName, ParamOrdinal paramOrd) {     if (e.foldable()) {         return new TypeResolution(format(null, "{}argument of [{}] must be a table column, found constant [{}]", paramOrd == null || paramOrd == ParamOrdinal.DEFAULT ? "" : paramOrd.name().toLowerCase(Locale.ROOT) + " ", operationName, Expressions.name(e))).     }     return TypeResolution.TYPE_RESOLVED. }
false;public,static;5;14;;public static TypeResolution isType(Expression e, Predicate<DataType> predicate, String operationName, ParamOrdinal paramOrd, String... acceptedTypes) {     return predicate.test(e.dataType()) || DataTypes.isNull(e.dataType()) ? TypeResolution.TYPE_RESOLVED : new TypeResolution(format(null, "{}argument of [{}] must be [{}], found value [{}] type [{}]", paramOrd == null || paramOrd == ParamOrdinal.DEFAULT ? "" : paramOrd.name().toLowerCase(Locale.ROOT) + " ", operationName, acceptedTypesForErrorMsg(acceptedTypes), name(e), e.dataType().typeName)). }
false;private,static;1;11;;private static String acceptedTypesForErrorMsg(String... acceptedTypes) {     StringJoiner sj = new StringJoiner(", ").     for (int i = 0. i < acceptedTypes.length - 1. i++) {         sj.add(acceptedTypes[i]).     }     if (acceptedTypes.length > 1) {         return sj.toString() + " or " + acceptedTypes[acceptedTypes.length - 1].     } else {         return acceptedTypes[0].     } }
