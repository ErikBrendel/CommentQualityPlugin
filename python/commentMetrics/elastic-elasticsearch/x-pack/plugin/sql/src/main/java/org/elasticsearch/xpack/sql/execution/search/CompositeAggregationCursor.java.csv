commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeStringArray(indices).     out.writeByteArray(nextQuery).     out.writeVInt(limit).     out.writeNamedWriteableList(extractors).     out.writeByteArray(mask.toByteArray()). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;;0;3;;String[] indices() {     return indices. }
false;;0;3;;byte[] next() {     return nextQuery. }
false;;0;3;;BitSet mask() {     return mask. }
false;;0;3;;List<BucketExtractor> extractors() {     return extractors. }
false;;0;3;;int limit() {     return limit. }
false;public;1;17;;@Override public void onResponse(SearchResponse r) {     try {         // retry         if (shouldRetryDueToEmptyPage(r)) {             CompositeAggregationCursor.updateCompositeAfterKey(r, search.source()).             client.search(search, this).             return.         }         updateCompositeAfterKey(r, query).         CompositeAggsRowSet rowSet = new CompositeAggsRowSet(extractors, mask, r, limit, serializeQuery(query), indices).         listener.onResponse(rowSet).     } catch (Exception ex) {         listener.onFailure(ex).     } }
false;public;1;4;;@Override public void onFailure(Exception ex) {     listener.onFailure(ex). }
false;public;4;42;;@Override public void nextPage(Configuration cfg, Client client, NamedWriteableRegistry registry, ActionListener<RowSet> listener) {     SearchSourceBuilder q.     try {         q = deserializeQuery(registry, nextQuery).     } catch (Exception ex) {         listener.onFailure(ex).         return.     }     SearchSourceBuilder query = q.     if (log.isTraceEnabled()) {         log.trace("About to execute composite query {} on {}", StringUtils.toString(query), indices).     }     SearchRequest search = Querier.prepareRequest(client, query, cfg.pageTimeout(), indices).     client.search(search, new ActionListener<SearchResponse>() {          @Override         public void onResponse(SearchResponse r) {             try {                 // retry                 if (shouldRetryDueToEmptyPage(r)) {                     CompositeAggregationCursor.updateCompositeAfterKey(r, search.source()).                     client.search(search, this).                     return.                 }                 updateCompositeAfterKey(r, query).                 CompositeAggsRowSet rowSet = new CompositeAggsRowSet(extractors, mask, r, limit, serializeQuery(query), indices).                 listener.onResponse(rowSet).             } catch (Exception ex) {                 listener.onFailure(ex).             }         }          @Override         public void onFailure(Exception ex) {             listener.onFailure(ex).         }     }). }
false;static;1;5;;static boolean shouldRetryDueToEmptyPage(SearchResponse response) {     CompositeAggregation composite = getComposite(response).     // if there are no buckets but a next page, go fetch it instead of sending an empty response to the client     return composite != null && composite.getBuckets().isEmpty() && composite.afterKey() != null && !composite.afterKey().isEmpty(). }
false;static;1;12;;static CompositeAggregation getComposite(SearchResponse response) {     Aggregation agg = response.getAggregations().get(Aggs.ROOT_GROUP_NAME).     if (agg == null) {         return null.     }     if (agg instanceof CompositeAggregation) {         return (CompositeAggregation) agg.     }     throw new SqlIllegalArgumentException("Unrecognized root group found. {}", agg.getClass()). }
false;static;2;20;;static void updateCompositeAfterKey(SearchResponse r, SearchSourceBuilder next) {     CompositeAggregation composite = getComposite(r).     if (composite == null) {         throw new SqlIllegalArgumentException("Invalid server response. no group-by detected").     }     Map<String, Object> afterKey = composite.afterKey().     // a null after-key means done     if (afterKey != null) {         AggregationBuilder aggBuilder = next.aggregations().getAggregatorFactories().iterator().next().         // update after-key with the new value         if (aggBuilder instanceof CompositeAggregationBuilder) {             CompositeAggregationBuilder comp = (CompositeAggregationBuilder) aggBuilder.             comp.aggregateAfter(afterKey).         } else {             throw new SqlIllegalArgumentException("Invalid client request. expected a group-by but instead got {}", aggBuilder).         }     } }
true;static;2;5;/**  * Deserializes the search source from a byte array.  */ ;/**  * Deserializes the search source from a byte array.  */ static SearchSourceBuilder deserializeQuery(NamedWriteableRegistry registry, byte[] source) throws IOException {     try (NamedWriteableAwareStreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(source), registry)) {         return new SearchSourceBuilder(in).     } }
true;static;1;10;/**  * Serializes the search source to a byte array.  */ ;/**  * Serializes the search source to a byte array.  */ static byte[] serializeQuery(SearchSourceBuilder source) throws IOException {     if (source == null) {         return new byte[0].     }     try (BytesStreamOutput out = new BytesStreamOutput()) {         source.writeTo(out).         return BytesReference.toBytes(out.bytes()).     } }
false;public;3;4;;@Override public void clear(Configuration cfg, Client client, ActionListener<Boolean> listener) {     listener.onResponse(true). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(Arrays.hashCode(indices), Arrays.hashCode(nextQuery), extractors, limit). }
false;public;1;11;;@Override public boolean equals(Object obj) {     if (obj == null || obj.getClass() != getClass()) {         return false.     }     CompositeAggregationCursor other = (CompositeAggregationCursor) obj.     return Arrays.equals(indices, other.indices) && Arrays.equals(nextQuery, other.nextQuery) && Objects.equals(extractors, other.extractors) && Objects.equals(limit, other.limit). }
false;public;0;4;;@Override public String toString() {     return "cursor for composite on index [" + Arrays.toString(indices) + "]". }
