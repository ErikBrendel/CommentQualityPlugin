commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected NodeInfo<Order> info() {     return NodeInfo.create(this, Order::new, child, direction, nulls). }
false;public;0;4;;@Override public Nullability nullable() {     return Nullability.FALSE. }
false;protected;0;4;;@Override protected TypeResolution resolveType() {     return isExact(child, "ORDER BY cannot be applied to field of data type [{}]: {}"). }
false;public;0;4;;@Override public DataType dataType() {     return child.dataType(). }
false;public;1;7;;@Override public Order replaceChildren(List<Expression> newChildren) {     if (newChildren.size() != 1) {         throw new IllegalArgumentException("expected [1] child but received [" + newChildren.size() + "]").     }     return new Order(source(), newChildren.get(0), direction, nulls). }
false;public;0;3;;public Expression child() {     return child. }
false;public;0;3;;public OrderDirection direction() {     return direction. }
false;public;0;3;;public NullsPosition nullsPosition() {     return nulls. }
false;public;0;4;;@Override public boolean foldable() {     return false. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(child, direction, nulls). }
false;public;1;15;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     Order other = (Order) obj.     return Objects.equals(direction, other.direction) && Objects.equals(nulls, other.nulls) && Objects.equals(child, other.child). }
