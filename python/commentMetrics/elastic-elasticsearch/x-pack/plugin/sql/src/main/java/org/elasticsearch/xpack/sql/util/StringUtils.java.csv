# id;timestamp;commentText;codeText;commentWords;codeWords
StringUtils -> public static String likeToLuceneWildcard(String pattern, char escape);1524684173;Translates a like pattern to a Lucene wildcard._This methods pays attention to the custom escape char which gets converted into \ (used by Lucene)._<pre>_% -&gt_ *__ -&gt_ ?_escape character - can be 0 (in which case every regex gets escaped) or should be followed by_% or _ (otherwise an exception is thrown)_</pre>;public static String likeToLuceneWildcard(String pattern, char escape) {_        StringBuilder wildcard = new StringBuilder(pattern.length() + 4)___        boolean escaped = false__        for (int i = 0_ i < pattern.length()_ i++) {_            char curr = pattern.charAt(i)___            if (!escaped && (curr == escape) && escape != 0) {_                if (i + 1 == pattern.length()) {_                    throw new SqlIllegalArgumentException("Invalid sequence - escape character is not followed by special wildcard char")__                }_                escaped = true__            } else {_                switch (curr) {_                    case '%':_                        wildcard.append(escaped ? SQL_WILDCARD : "*")__                        break__                    case '_':_                        wildcard.append(escaped ? "_" : "?")__                        break__                    default:_                        if (escaped) {_                            throw new SqlIllegalArgumentException(_                                    "Invalid sequence - escape character is not followed by special wildcard char")__                        }_                        _                        switch (curr) {_                            case '\\':_                            case '*':_                            case '?':_                              wildcard.append('\\')__                        }_                        wildcard.append(curr)__                }_                escaped = false__            }_        }_        return wildcard.toString()__    };translates,a,like,pattern,to,a,lucene,wildcard,this,methods,pays,attention,to,the,custom,escape,char,which,gets,converted,into,used,by,lucene,pre,gt,gt,escape,character,can,be,0,in,which,case,every,regex,gets,escaped,or,should,be,followed,by,or,otherwise,an,exception,is,thrown,pre;public,static,string,like,to,lucene,wildcard,string,pattern,char,escape,string,builder,wildcard,new,string,builder,pattern,length,4,boolean,escaped,false,for,int,i,0,i,pattern,length,i,char,curr,pattern,char,at,i,if,escaped,curr,escape,escape,0,if,i,1,pattern,length,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,escaped,true,else,switch,curr,case,wildcard,append,escaped,break,case,wildcard,append,escaped,break,default,if,escaped,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,switch,curr,case,case,case,wildcard,append,wildcard,append,curr,escaped,false,return,wildcard,to,string
StringUtils -> public static String likeToLuceneWildcard(String pattern, char escape);1531729807;Translates a like pattern to a Lucene wildcard._This methods pays attention to the custom escape char which gets converted into \ (used by Lucene)._<pre>_% -&gt_ *__ -&gt_ ?_escape character - can be 0 (in which case every regex gets escaped) or should be followed by_% or _ (otherwise an exception is thrown)_</pre>;public static String likeToLuceneWildcard(String pattern, char escape) {_        StringBuilder wildcard = new StringBuilder(pattern.length() + 4)___        boolean escaped = false__        for (int i = 0_ i < pattern.length()_ i++) {_            char curr = pattern.charAt(i)___            if (!escaped && (curr == escape) && escape != 0) {_                if (i + 1 == pattern.length()) {_                    throw new SqlIllegalArgumentException("Invalid sequence - escape character is not followed by special wildcard char")__                }_                escaped = true__            } else {_                switch (curr) {_                    case '%':_                        wildcard.append(escaped ? SQL_WILDCARD : "*")__                        break__                    case '_':_                        wildcard.append(escaped ? "_" : "?")__                        break__                    default:_                        if (escaped) {_                            throw new SqlIllegalArgumentException(_                                    "Invalid sequence - escape character is not followed by special wildcard char")__                        }_                        _                        switch (curr) {_                            case '\\':_                            case '*':_                            case '?':_                              wildcard.append('\\')__                        }_                        wildcard.append(curr)__                }_                escaped = false__            }_        }_        return wildcard.toString()__    };translates,a,like,pattern,to,a,lucene,wildcard,this,methods,pays,attention,to,the,custom,escape,char,which,gets,converted,into,used,by,lucene,pre,gt,gt,escape,character,can,be,0,in,which,case,every,regex,gets,escaped,or,should,be,followed,by,or,otherwise,an,exception,is,thrown,pre;public,static,string,like,to,lucene,wildcard,string,pattern,char,escape,string,builder,wildcard,new,string,builder,pattern,length,4,boolean,escaped,false,for,int,i,0,i,pattern,length,i,char,curr,pattern,char,at,i,if,escaped,curr,escape,escape,0,if,i,1,pattern,length,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,escaped,true,else,switch,curr,case,wildcard,append,escaped,break,case,wildcard,append,escaped,break,default,if,escaped,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,switch,curr,case,case,case,wildcard,append,wildcard,append,curr,escaped,false,return,wildcard,to,string
StringUtils -> public static String likeToLuceneWildcard(String pattern, char escape);1536314350;Translates a like pattern to a Lucene wildcard._This methods pays attention to the custom escape char which gets converted into \ (used by Lucene)._<pre>_% -&gt_ *__ -&gt_ ?_escape character - can be 0 (in which case every regex gets escaped) or should be followed by_% or _ (otherwise an exception is thrown)_</pre>;public static String likeToLuceneWildcard(String pattern, char escape) {_        StringBuilder wildcard = new StringBuilder(pattern.length() + 4)___        boolean escaped = false__        for (int i = 0_ i < pattern.length()_ i++) {_            char curr = pattern.charAt(i)___            if (!escaped && (curr == escape) && escape != 0) {_                if (i + 1 == pattern.length()) {_                    throw new SqlIllegalArgumentException("Invalid sequence - escape character is not followed by special wildcard char")__                }_                escaped = true__            } else {_                switch (curr) {_                    case '%':_                        wildcard.append(escaped ? SQL_WILDCARD : "*")__                        break__                    case '_':_                        wildcard.append(escaped ? "_" : "?")__                        break__                    default:_                        if (escaped) {_                            throw new SqlIllegalArgumentException(_                                    "Invalid sequence - escape character is not followed by special wildcard char")__                        }_                        _                        switch (curr) {_                            case '\\':_                            case '*':_                            case '?':_                              wildcard.append('\\')__                        }_                        wildcard.append(curr)__                }_                escaped = false__            }_        }_        return wildcard.toString()__    };translates,a,like,pattern,to,a,lucene,wildcard,this,methods,pays,attention,to,the,custom,escape,char,which,gets,converted,into,used,by,lucene,pre,gt,gt,escape,character,can,be,0,in,which,case,every,regex,gets,escaped,or,should,be,followed,by,or,otherwise,an,exception,is,thrown,pre;public,static,string,like,to,lucene,wildcard,string,pattern,char,escape,string,builder,wildcard,new,string,builder,pattern,length,4,boolean,escaped,false,for,int,i,0,i,pattern,length,i,char,curr,pattern,char,at,i,if,escaped,curr,escape,escape,0,if,i,1,pattern,length,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,escaped,true,else,switch,curr,case,wildcard,append,escaped,break,case,wildcard,append,escaped,break,default,if,escaped,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,switch,curr,case,case,case,wildcard,append,wildcard,append,curr,escaped,false,return,wildcard,to,string
StringUtils -> public static String likeToLuceneWildcard(String pattern, char escape);1542807959;Translates a like pattern to a Lucene wildcard._This methods pays attention to the custom escape char which gets converted into \ (used by Lucene)._<pre>_% -&gt_ *__ -&gt_ ?_escape character - can be 0 (in which case every regex gets escaped) or should be followed by_% or _ (otherwise an exception is thrown)_</pre>;public static String likeToLuceneWildcard(String pattern, char escape) {_        StringBuilder wildcard = new StringBuilder(pattern.length() + 4)___        boolean escaped = false__        for (int i = 0_ i < pattern.length()_ i++) {_            char curr = pattern.charAt(i)___            if (!escaped && (curr == escape) && escape != 0) {_                if (i + 1 == pattern.length()) {_                    throw new SqlIllegalArgumentException("Invalid sequence - escape character is not followed by special wildcard char")__                }_                escaped = true__            } else {_                switch (curr) {_                    case '%':_                        wildcard.append(escaped ? SQL_WILDCARD : "*")__                        break__                    case '_':_                        wildcard.append(escaped ? "_" : "?")__                        break__                    default:_                        if (escaped) {_                            throw new SqlIllegalArgumentException(_                                    "Invalid sequence - escape character is not followed by special wildcard char")__                        }_                        _                        switch (curr) {_                            case '\\':_                            case '*':_                            case '?':_                              wildcard.append('\\')__                        }_                        wildcard.append(curr)__                }_                escaped = false__            }_        }_        return wildcard.toString()__    };translates,a,like,pattern,to,a,lucene,wildcard,this,methods,pays,attention,to,the,custom,escape,char,which,gets,converted,into,used,by,lucene,pre,gt,gt,escape,character,can,be,0,in,which,case,every,regex,gets,escaped,or,should,be,followed,by,or,otherwise,an,exception,is,thrown,pre;public,static,string,like,to,lucene,wildcard,string,pattern,char,escape,string,builder,wildcard,new,string,builder,pattern,length,4,boolean,escaped,false,for,int,i,0,i,pattern,length,i,char,curr,pattern,char,at,i,if,escaped,curr,escape,escape,0,if,i,1,pattern,length,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,escaped,true,else,switch,curr,case,wildcard,append,escaped,break,case,wildcard,append,escaped,break,default,if,escaped,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,switch,curr,case,case,case,wildcard,append,wildcard,append,curr,escaped,false,return,wildcard,to,string
StringUtils -> public static String likeToIndexWildcard(String pattern, char escape);1524684173;Translates a like pattern to pattern for ES index name expression resolver.__Note the resolver only supports * (not ?) and has no notion of escaping. This is not really an issue since we don't allow *_anyway in the pattern.;public static String likeToIndexWildcard(String pattern, char escape) {_        StringBuilder wildcard = new StringBuilder(pattern.length() + 4)___        boolean escaped = false__        for (int i = 0_ i < pattern.length()_ i++) {_            char curr = pattern.charAt(i)___            if (!escaped && (curr == escape) && escape != 0) {_                if (i + 1 == pattern.length()) {_                    throw new SqlIllegalArgumentException("Invalid sequence - escape character is not followed by special wildcard char")__                }_                escaped = true__            } else {_                switch (curr) {_                    case '%':_                        wildcard.append(escaped ? SQL_WILDCARD : "*")__                        break__                    case '_':_                        wildcard.append(escaped ? "_" : "*")__                        break__                    default:_                        if (escaped) {_                            throw new SqlIllegalArgumentException(_                                    "Invalid sequence - escape character is not followed by special wildcard char")__                        }_                        _                        wildcard.append(curr)__                }_                escaped = false__            }_        }_        return wildcard.toString()__    };translates,a,like,pattern,to,pattern,for,es,index,name,expression,resolver,note,the,resolver,only,supports,not,and,has,no,notion,of,escaping,this,is,not,really,an,issue,since,we,don,t,allow,anyway,in,the,pattern;public,static,string,like,to,index,wildcard,string,pattern,char,escape,string,builder,wildcard,new,string,builder,pattern,length,4,boolean,escaped,false,for,int,i,0,i,pattern,length,i,char,curr,pattern,char,at,i,if,escaped,curr,escape,escape,0,if,i,1,pattern,length,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,escaped,true,else,switch,curr,case,wildcard,append,escaped,break,case,wildcard,append,escaped,break,default,if,escaped,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,wildcard,append,curr,escaped,false,return,wildcard,to,string
StringUtils -> public static String likeToIndexWildcard(String pattern, char escape);1531729807;Translates a like pattern to pattern for ES index name expression resolver.__Note the resolver only supports * (not ?) and has no notion of escaping. This is not really an issue since we don't allow *_anyway in the pattern.;public static String likeToIndexWildcard(String pattern, char escape) {_        StringBuilder wildcard = new StringBuilder(pattern.length() + 4)___        boolean escaped = false__        for (int i = 0_ i < pattern.length()_ i++) {_            char curr = pattern.charAt(i)___            if (!escaped && (curr == escape) && escape != 0) {_                if (i + 1 == pattern.length()) {_                    throw new SqlIllegalArgumentException("Invalid sequence - escape character is not followed by special wildcard char")__                }_                escaped = true__            } else {_                switch (curr) {_                    case '%':_                        wildcard.append(escaped ? SQL_WILDCARD : "*")__                        break__                    case '_':_                        wildcard.append(escaped ? "_" : "*")__                        break__                    default:_                        if (escaped) {_                            throw new SqlIllegalArgumentException(_                                    "Invalid sequence - escape character is not followed by special wildcard char")__                        }_                        _                        wildcard.append(curr)__                }_                escaped = false__            }_        }_        return wildcard.toString()__    };translates,a,like,pattern,to,pattern,for,es,index,name,expression,resolver,note,the,resolver,only,supports,not,and,has,no,notion,of,escaping,this,is,not,really,an,issue,since,we,don,t,allow,anyway,in,the,pattern;public,static,string,like,to,index,wildcard,string,pattern,char,escape,string,builder,wildcard,new,string,builder,pattern,length,4,boolean,escaped,false,for,int,i,0,i,pattern,length,i,char,curr,pattern,char,at,i,if,escaped,curr,escape,escape,0,if,i,1,pattern,length,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,escaped,true,else,switch,curr,case,wildcard,append,escaped,break,case,wildcard,append,escaped,break,default,if,escaped,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,wildcard,append,curr,escaped,false,return,wildcard,to,string
StringUtils -> public static String likeToIndexWildcard(String pattern, char escape);1536314350;Translates a like pattern to pattern for ES index name expression resolver.__Note the resolver only supports * (not ?) and has no notion of escaping. This is not really an issue since we don't allow *_anyway in the pattern.;public static String likeToIndexWildcard(String pattern, char escape) {_        StringBuilder wildcard = new StringBuilder(pattern.length() + 4)___        boolean escaped = false__        for (int i = 0_ i < pattern.length()_ i++) {_            char curr = pattern.charAt(i)___            if (!escaped && (curr == escape) && escape != 0) {_                if (i + 1 == pattern.length()) {_                    throw new SqlIllegalArgumentException("Invalid sequence - escape character is not followed by special wildcard char")__                }_                escaped = true__            } else {_                switch (curr) {_                    case '%':_                        wildcard.append(escaped ? SQL_WILDCARD : "*")__                        break__                    case '_':_                        wildcard.append(escaped ? "_" : "*")__                        break__                    default:_                        if (escaped) {_                            throw new SqlIllegalArgumentException(_                                    "Invalid sequence - escape character is not followed by special wildcard char")__                        }_                        _                        wildcard.append(curr)__                }_                escaped = false__            }_        }_        return wildcard.toString()__    };translates,a,like,pattern,to,pattern,for,es,index,name,expression,resolver,note,the,resolver,only,supports,not,and,has,no,notion,of,escaping,this,is,not,really,an,issue,since,we,don,t,allow,anyway,in,the,pattern;public,static,string,like,to,index,wildcard,string,pattern,char,escape,string,builder,wildcard,new,string,builder,pattern,length,4,boolean,escaped,false,for,int,i,0,i,pattern,length,i,char,curr,pattern,char,at,i,if,escaped,curr,escape,escape,0,if,i,1,pattern,length,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,escaped,true,else,switch,curr,case,wildcard,append,escaped,break,case,wildcard,append,escaped,break,default,if,escaped,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,wildcard,append,curr,escaped,false,return,wildcard,to,string
StringUtils -> public static String likeToIndexWildcard(String pattern, char escape);1542807959;Translates a like pattern to pattern for ES index name expression resolver.__Note the resolver only supports * (not ?) and has no notion of escaping. This is not really an issue since we don't allow *_anyway in the pattern.;public static String likeToIndexWildcard(String pattern, char escape) {_        StringBuilder wildcard = new StringBuilder(pattern.length() + 4)___        boolean escaped = false__        for (int i = 0_ i < pattern.length()_ i++) {_            char curr = pattern.charAt(i)___            if (!escaped && (curr == escape) && escape != 0) {_                if (i + 1 == pattern.length()) {_                    throw new SqlIllegalArgumentException("Invalid sequence - escape character is not followed by special wildcard char")__                }_                escaped = true__            } else {_                switch (curr) {_                    case '%':_                        wildcard.append(escaped ? SQL_WILDCARD : "*")__                        break__                    case '_':_                        wildcard.append(escaped ? "_" : "*")__                        break__                    default:_                        if (escaped) {_                            throw new SqlIllegalArgumentException(_                                    "Invalid sequence - escape character is not followed by special wildcard char")__                        }_                        _                        wildcard.append(curr)__                }_                escaped = false__            }_        }_        return wildcard.toString()__    };translates,a,like,pattern,to,pattern,for,es,index,name,expression,resolver,note,the,resolver,only,supports,not,and,has,no,notion,of,escaping,this,is,not,really,an,issue,since,we,don,t,allow,anyway,in,the,pattern;public,static,string,like,to,index,wildcard,string,pattern,char,escape,string,builder,wildcard,new,string,builder,pattern,length,4,boolean,escaped,false,for,int,i,0,i,pattern,length,i,char,curr,pattern,char,at,i,if,escaped,curr,escape,escape,0,if,i,1,pattern,length,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,escaped,true,else,switch,curr,case,wildcard,append,escaped,break,case,wildcard,append,escaped,break,default,if,escaped,throw,new,sql,illegal,argument,exception,invalid,sequence,escape,character,is,not,followed,by,special,wildcard,char,wildcard,append,curr,escaped,false,return,wildcard,to,string
