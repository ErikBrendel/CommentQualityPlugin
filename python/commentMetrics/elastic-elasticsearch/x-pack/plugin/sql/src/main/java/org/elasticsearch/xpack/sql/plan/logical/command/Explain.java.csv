commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String printableName() {     return Strings.capitalize(name().toLowerCase(Locale.ROOT)). }
false;protected;0;4;;@Override protected NodeInfo<Explain> info() {     return NodeInfo.create(this, Explain::new, plan, type, format, verify). }
false;public;0;3;;public LogicalPlan plan() {     return plan. }
false;public;0;3;;public boolean verify() {     return verify. }
false;public;0;3;;public Format format() {     return format. }
false;public;0;3;;public Type type() {     return type. }
false;public;0;4;;@Override public List<Attribute> output() {     return singletonList(new FieldAttribute(source(), "plan", new KeywordEsField("plan"))). }
false;public;2;93;;@Override public void execute(SqlSession session, ActionListener<SchemaRowSet> listener) {     if (type == Type.PARSED) {         listener.onResponse(Rows.singleton(output(), formatPlan(format, plan))).         return.     }     // to avoid duplicating code, the type/verification filtering happens inside the listeners instead of outside using a CASE     session.analyzedPlan(plan, verify, wrap(analyzedPlan -> {         if (type == Type.ANALYZED) {             listener.onResponse(Rows.singleton(output(), formatPlan(format, analyzedPlan))).             return.         }         Planner planner = session.planner().         // verification is on, exceptions can be thrown         if (verify) {             session.optimizedPlan(analyzedPlan, wrap(optimizedPlan -> {                 if (type == Type.OPTIMIZED) {                     listener.onResponse(Rows.singleton(output(), formatPlan(format, optimizedPlan))).                     return.                 }                 PhysicalPlan mappedPlan = planner.mapPlan(optimizedPlan, verify).                 if (type == Type.MAPPED) {                     listener.onResponse(Rows.singleton(output(), formatPlan(format, mappedPlan))).                     return.                 }                 PhysicalPlan executablePlan = planner.foldPlan(mappedPlan, verify).                 if (type == Type.EXECUTABLE) {                     listener.onResponse(Rows.singleton(output(), formatPlan(format, executablePlan))).                     return.                 }                 // Type.All                 listener.onResponse(Rows.singleton(output(), printPlans(format, plan, analyzedPlan, optimizedPlan, mappedPlan, executablePlan))).             }, listener::onFailure)).         } else // check errors manually to see how far the plans work out         {             // no analysis failure, can move on             if (session.verifier().verifyFailures(analyzedPlan).isEmpty()) {                 session.optimizedPlan(analyzedPlan, wrap(optimizedPlan -> {                     if (type == Type.OPTIMIZED) {                         listener.onResponse(Rows.singleton(output(), formatPlan(format, optimizedPlan))).                         return.                     }                     PhysicalPlan mappedPlan = planner.mapPlan(optimizedPlan, verify).                     if (type == Type.MAPPED) {                         listener.onResponse(Rows.singleton(output(), formatPlan(format, mappedPlan))).                         return.                     }                     if (planner.verifyMappingPlanFailures(mappedPlan).isEmpty()) {                         PhysicalPlan executablePlan = planner.foldPlan(mappedPlan, verify).                         if (type == Type.EXECUTABLE) {                             listener.onResponse(Rows.singleton(output(), formatPlan(format, executablePlan))).                             return.                         }                         listener.onResponse(Rows.singleton(output(), printPlans(format, plan, analyzedPlan, optimizedPlan, mappedPlan, executablePlan))).                         return.                     }                     // mapped failed                     if (type != Type.ALL) {                         listener.onResponse(Rows.singleton(output(), formatPlan(format, mappedPlan))).                         return.                     }                     listener.onResponse(Rows.singleton(output(), printPlans(format, plan, analyzedPlan, optimizedPlan, mappedPlan, null))).                 }, listener::onFailure)).             // cannot continue             } else {                 if (type != Type.ALL) {                     listener.onResponse(Rows.singleton(output(), formatPlan(format, analyzedPlan))).                 } else {                     listener.onResponse(Rows.singleton(output(), printPlans(format, plan, analyzedPlan, null, null, null))).                 }             }         }     }, listener::onFailure)). }
false;private,static;6;34;;private static String printPlans(Format format, LogicalPlan parsed, LogicalPlan analyzedPlan, LogicalPlan optimizedPlan, PhysicalPlan mappedPlan, PhysicalPlan executionPlan) {     if (format == Format.TEXT) {         StringBuilder sb = new StringBuilder().         sb.append("Parsed\n").         sb.append("-----------\n").         sb.append(parsed.toString()).         sb.append("\nAnalyzed\n").         sb.append("--------\n").         sb.append(analyzedPlan.toString()).         sb.append("\nOptimized\n").         sb.append("---------\n").         sb.append(nullablePlan(optimizedPlan)).         sb.append("\nMapped\n").         sb.append("---------\n").         sb.append(nullablePlan(mappedPlan)).         sb.append("\nExecutable\n").         sb.append("---------\n").         sb.append(nullablePlan(executionPlan)).         return sb.toString().     } else {         Map<String, QueryPlan<?>> plans = new HashMap<>().         plans.put("Parsed", parsed).         plans.put("Analyzed", analyzedPlan).         if (optimizedPlan != null) {             plans.put("Optimized", optimizedPlan).             plans.put("Mapped", mappedPlan).             plans.put("Execution", executionPlan).         }         return Graphviz.dot(unmodifiableMap(plans), false).     } }
false;private,static;1;3;;private static String nullablePlan(QueryPlan<?> plan) {     return plan != null ? plan.toString() : "<not computed due to failures>". }
false;private;2;3;;private String formatPlan(Format format, QueryPlan<?> plan) {     return (format == Format.TEXT ? nullablePlan(plan) : Graphviz.dot(type.printableName(), plan)). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(plan, type, format, verify). }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if ((obj == null) || (getClass() != obj.getClass())) {         return false.     }     Explain o = (Explain) obj.     return Objects.equals(verify, o.verify) && Objects.equals(format, o.format) && Objects.equals(type, o.type) && Objects.equals(plan, o.plan). }
