commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected NodeInfo<SysColumns> info() {     return NodeInfo.create(this, SysColumns::new, catalog, index, pattern, columnPattern). }
false;public;0;4;;@Override public List<Attribute> output() {     return output(false). }
false;private;1;32;;private List<Attribute> output(boolean odbcCompatible) {     // https://github.com/elastic/elasticsearch/issues/35376     // ODBC expects some fields as SHORT while JDBC as Integer     // which causes conversion issues and CCE     DataType clientBasedType = odbcCompatible ? SHORT : INTEGER.     return asList(keyword("TABLE_CAT"), keyword("TABLE_SCHEM"), keyword("TABLE_NAME"), keyword("COLUMN_NAME"), field("DATA_TYPE", clientBasedType), keyword("TYPE_NAME"), field("COLUMN_SIZE", INTEGER), field("BUFFER_LENGTH", INTEGER), field("DECIMAL_DIGITS", clientBasedType), field("NUM_PREC_RADIX", clientBasedType), field("NULLABLE", clientBasedType), keyword("REMARKS"), keyword("COLUMN_DEF"), field("SQL_DATA_TYPE", clientBasedType), field("SQL_DATETIME_SUB", clientBasedType), field("CHAR_OCTET_LENGTH", INTEGER), field("ORDINAL_POSITION", INTEGER), keyword("IS_NULLABLE"), // JDBC specific     keyword("SCOPE_CATALOG"), keyword("SCOPE_SCHEMA"), keyword("SCOPE_TABLE"), field("SOURCE_DATA_TYPE", SHORT), keyword("IS_AUTOINCREMENT"), keyword("IS_GENERATEDCOLUMN")). }
false;public;2;26;;@Override public void execute(SqlSession session, ActionListener<SchemaRowSet> listener) {     Mode mode = session.configuration().mode().     List<Attribute> output = output(mode == Mode.ODBC).     String cluster = session.indexResolver().clusterName().     // bail-out early if the catalog is present but differs     if (Strings.hasText(catalog) && !cluster.equals(catalog)) {         listener.onResponse(Rows.empty(output)).         return.     }     String idx = index != null ? index : (pattern != null ? pattern.asIndexNameWildcard() : "*").     String regex = pattern != null ? pattern.asJavaRegex() : null.     Pattern columnMatcher = columnPattern != null ? Pattern.compile(columnPattern.asJavaRegex()) : null.     session.indexResolver().resolveAsSeparateMappings(idx, regex, ActionListener.wrap(esIndices -> {         List<List<?>> rows = new ArrayList<>().         for (EsIndex esIndex : esIndices) {             fillInRows(cluster, esIndex.name(), esIndex.mapping(), null, rows, columnMatcher, mode).         }         listener.onResponse(Rows.of(output, rows)).     }, listener::onFailure)). }
false;static;7;57;;static void fillInRows(String clusterName, String indexName, Map<String, EsField> mapping, String prefix, List<List<?>> rows, Pattern columnMatcher, Mode mode) {     int pos = 0.     boolean isOdbcClient = mode == Mode.ODBC.     for (Map.Entry<String, EsField> entry : mapping.entrySet()) {         // JDBC is 1-based so we start with 1 here         pos++.         String name = entry.getKey().         name = prefix != null ? prefix + "." + name : name.         EsField field = entry.getValue().         DataType type = field.getDataType().         // skip the nested, object and unsupported types for JDBC and ODBC         if (type.isPrimitive() || false == Mode.isDriver(mode)) {             if (columnMatcher == null || columnMatcher.matcher(name).matches()) {                 rows.add(asList(clusterName, // schema is not supported                 null, indexName, name, odbcCompatible(type.sqlType.getVendorTypeNumber(), isOdbcClient), type.toString(), type.displaySize, // TODO: is the buffer_length correct?                 type.size, // no DECIMAL support                 null, odbcCompatible(DataTypes.metaSqlRadix(type), isOdbcClient), // everything is nullable                 odbcCompatible(DatabaseMetaData.columnNullable, isOdbcClient), // no remarks                 null, // no column def                 null, // SQL_DATA_TYPE apparently needs to be same as DATA_TYPE except for datetime and interval data types                 odbcCompatible(DataTypes.metaSqlDataType(type), isOdbcClient), // SQL_DATETIME_SUB ?                 odbcCompatible(DataTypes.metaSqlDateTimeSub(type), isOdbcClient), // char octet length                 type.isString() || type == DataType.BINARY ? type.size : null, // position                 pos, "YES", null, null, null, null, "NO", "NO")).             }         }         if (field.getProperties() != null) {             fillInRows(clusterName, indexName, field.getProperties(), name, rows, columnMatcher, mode).         }     } }
false;private,static;2;6;;private static Object odbcCompatible(Integer value, boolean isOdbcClient) {     if (isOdbcClient && value != null) {         return Short.valueOf(value.shortValue()).     }     return value. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(catalog, index, pattern, columnPattern). }
false;public;1;16;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     SysColumns other = (SysColumns) obj.     return Objects.equals(catalog, other.catalog) && Objects.equals(index, other.index) && Objects.equals(pattern, other.pattern) && Objects.equals(columnPattern, other.columnPattern). }
