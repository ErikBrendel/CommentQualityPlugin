commented;modifiers;parameterAmount;loc;comment;code
false;;3;11;;@Override String format(Cursor cursor, RestRequest request, SqlQueryResponse response) {     final BasicFormatter formatter.     if (cursor instanceof TextFormatterCursor) {         formatter = ((TextFormatterCursor) cursor).getFormatter().         return formatter.formatWithoutHeader(response.rows()).     } else {         formatter = new BasicFormatter(response.columns(), response.rows(), TEXT).         return formatter.formatWithHeader(response.columns(), response.rows()).     } }
false;;2;6;;@Override Cursor wrapCursor(Cursor oldCursor, SqlQueryResponse response) {     BasicFormatter formatter = (oldCursor instanceof TextFormatterCursor) ? ((TextFormatterCursor) oldCursor).getFormatter() : new BasicFormatter(response.columns(), response.rows(), TEXT).     return TextFormatterCursor.wrap(super.wrapCursor(oldCursor, response), formatter). }
false;;0;4;;@Override String shortName() {     return "txt". }
false;;0;4;;@Override String contentType() {     return "text/plain". }
false;protected;0;4;;@Override protected String delimiter() {     throw new UnsupportedOperationException(). }
false;protected;0;4;;@Override protected String eol() {     throw new UnsupportedOperationException(). }
false;protected;0;4;;@Override protected String delimiter() {     return ",". }
false;protected;0;5;;@Override protected String eol() {     // LFCR     return "\r\n". }
false;;0;4;;@Override String shortName() {     return "csv". }
false;;0;4;;@Override String contentType() {     return "text/csv". }
false;;1;4;;@Override String contentType(RestRequest request) {     return contentType() + ". charset=utf-8. header=" + (hasHeader(request) ? "present" : "absent"). }
false;;1;28;;@Override String maybeEscape(String value) {     boolean needsEscaping = false.     for (int i = 0. i < value.length(). i++) {         char c = value.charAt(i).         if (c == '"' || c == ',' || c == '\n' || c == '\r') {             needsEscaping = true.             break.         }     }     if (needsEscaping) {         StringBuilder sb = new StringBuilder().         sb.append('"').         for (int i = 0. i < value.length(). i++) {             char c = value.charAt(i).             if (value.charAt(i) == '"') {                 sb.append('"').             }             sb.append(c).         }         sb.append('"').         value = sb.toString().     }     return value. }
false;;1;21;;@Override boolean hasHeader(RestRequest request) {     String header = request.param("header").     if (header == null) {         List<String> values = request.getAllHeaderValues("Accept").         if (values != null) {             // header is a parameter specified by . so try breaking it down             for (String value : values) {                 String[] params = Strings.tokenizeToStringArray(value, ".").                 for (String param : params) {                     if (param.toLowerCase(Locale.ROOT).equals("header=absent")) {                         return false.                     }                 }             }         }         return true.     } else {         return !header.toLowerCase(Locale.ROOT).equals("absent").     } }
false;protected;0;4;;@Override protected String delimiter() {     return "\t". }
false;protected;0;5;;@Override protected String eol() {     // only CR     return "\n". }
false;;0;4;;@Override String shortName() {     return "tsv". }
false;;0;4;;@Override String contentType() {     return "text/tab-separated-values". }
false;;1;4;;@Override String contentType(RestRequest request) {     return contentType() + ". charset=utf-8". }
false;;1;20;;@Override String maybeEscape(String value) {     StringBuilder sb = new StringBuilder().     for (int i = 0. i < value.length(). i++) {         char c = value.charAt(i).         switch(c) {             case '\n':                 sb.append("\\n").                 break.             case '\t':                 sb.append("\\t").                 break.             default:                 sb.append(c).         }     }     return sb.toString(). }
false;;3;15;;String format(Cursor cursor, RestRequest request, SqlQueryResponse response) {     StringBuilder sb = new StringBuilder().     boolean header = hasHeader(request).     if (header) {         row(sb, response.columns(), ColumnInfo::name).     }     for (List<Object> row : response.rows()) {         row(sb, row, f -> f instanceof ZonedDateTime ? DateUtils.toString((ZonedDateTime) f) : Objects.toString(f, StringUtils.EMPTY)).     }     return sb.toString(). }
false;;1;3;;boolean hasHeader(RestRequest request) {     return true. }
false;;2;3;;Cursor wrapCursor(Cursor oldCursor, SqlQueryResponse response) {     return Cursors.decodeFromString(response.cursor()). }
false;static;1;12;;static TextFormat fromMediaTypeOrFormat(String accept) {     for (TextFormat text : values()) {         String contentType = text.contentType().         if (contentType.equalsIgnoreCase(accept) || accept.toLowerCase(Locale.ROOT).startsWith(contentType + ".") || text.shortName().equalsIgnoreCase(accept)) {             return text.         }     }     throw new IllegalArgumentException("invalid format [" + accept + "]"). }
true;abstract;0;1;/**  * Short name typically used by format parameter.  * Can differ from the IANA mime type.  */ ;/**  * Short name typically used by format parameter.  * Can differ from the IANA mime type.  */ abstract String shortName().
true;abstract;0;1;/**  * Formal IANA mime type.  */ ;/**  * Formal IANA mime type.  */ abstract String contentType().
true;;1;3;/**  * Content type depending on the request.  * Might be used by some formatters (like CSV) to specify certain metadata like  * whether the header is returned or not.  */ ;/**  * Content type depending on the request.  * Might be used by some formatters (like CSV) to specify certain metadata like  * whether the header is returned or not.  */ String contentType(RestRequest request) {     return contentType(). }
true;;3;9;// utility method for consuming a row. ;// utility method for consuming a row. <F> void row(StringBuilder sb, List<F> row, Function<F, String> toString) {     for (int i = 0. i < row.size(). i++) {         sb.append(maybeEscape(toString.apply(row.get(i)))).         if (i < row.size() - 1) {             sb.append(delimiter()).         }     }     sb.append(eol()). }
true;protected,abstract;0;1;/**  * Delimiter between fields  */ ;/**  * Delimiter between fields  */ protected abstract String delimiter().
true;protected,abstract;0;1;/**  * String indicating end-of-line or row.  */ ;/**  * String indicating end-of-line or row.  */ protected abstract String eol().
true;;1;3;/**  * Method used for escaping (if needed) a given value.  */ ;/**  * Method used for escaping (if needed) a given value.  */ String maybeEscape(String value) {     return value. }
