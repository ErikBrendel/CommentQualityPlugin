commented;modifiers;parameterAmount;loc;comment;code
false;public;1;17;;@Override public LogicalPlan visitQuery(QueryContext ctx) {     LogicalPlan body = plan(ctx.queryNoWith()).     List<SubQueryAlias> namedQueries = visitList(ctx.namedQuery(), SubQueryAlias.class).     // unwrap query (and validate while at it)     Map<String, SubQueryAlias> cteRelations = new LinkedHashMap<>(namedQueries.size()).     for (SubQueryAlias namedQuery : namedQueries) {         if (cteRelations.put(namedQuery.alias(), namedQuery) != null) {             throw new ParsingException(namedQuery.source(), "Duplicate alias {}", namedQuery.alias()).         }     }     // return WITH     return new With(source(ctx), body, cteRelations). }
false;public;1;4;;@Override public LogicalPlan visitNamedQuery(NamedQueryContext ctx) {     return new SubQueryAlias(source(ctx), plan(ctx.queryNoWith()), ctx.name.getText()). }
false;public;1;21;;@Override public LogicalPlan visitQueryNoWith(QueryNoWithContext ctx) {     LogicalPlan plan = plan(ctx.queryTerm()).     if (!ctx.orderBy().isEmpty()) {         List<OrderByContext> orders = ctx.orderBy().         OrderByContext endContext = orders.get(orders.size() - 1).         plan = new OrderBy(source(ctx.ORDER(), endContext), plan, visitList(ctx.orderBy(), Order.class)).     }     LimitClauseContext limitClause = ctx.limitClause().     if (limitClause != null) {         Token limit = limitClause.limit.         if (limit != null && limitClause.INTEGER_VALUE() != null) {             plan = new Limit(source(limitClause), new Literal(source(limitClause), Integer.parseInt(limit.getText()), DataType.INTEGER), plan).         }     }     return plan. }
false;public;1;50;;@Override public LogicalPlan visitQuerySpecification(QuerySpecificationContext ctx) {     LogicalPlan query.     if (ctx.fromClause() == null) {         query = new LocalRelation(source(ctx), new SingletonExecutable()).     } else {         query = plan(ctx.fromClause()).     }     // add WHERE     if (ctx.where != null) {         query = new Filter(source(ctx), query, expression(ctx.where)).     }     List<NamedExpression> selectTarget = emptyList().     // SELECT a, b, c ...     if (!ctx.selectItem().isEmpty()) {         selectTarget = expressions(ctx.selectItem()).stream().map(e -> (e instanceof NamedExpression) ? (NamedExpression) e : new UnresolvedAlias(e.source(), e)).collect(toList()).     }     // GROUP BY     GroupByContext groupByCtx = ctx.groupBy().     if (groupByCtx != null) {         SetQuantifierContext setQualifierContext = groupByCtx.setQuantifier().         TerminalNode groupByAll = setQualifierContext == null ? null : setQualifierContext.ALL().         if (groupByAll != null) {             throw new ParsingException(source(groupByAll), "GROUP BY ALL is not supported").         }         List<GroupingElementContext> groupingElement = groupByCtx.groupingElement().         List<Expression> groupBy = expressions(groupingElement).         ParserRuleContext endSource = groupingElement.isEmpty() ? groupByCtx : groupingElement.get(groupingElement.size() - 1).         query = new Aggregate(source(ctx.GROUP(), endSource), query, groupBy, selectTarget).     } else if (!selectTarget.isEmpty()) {         query = new Project(source(ctx.selectItem(0)), query, selectTarget).     }     // HAVING     if (ctx.having != null) {         query = new Filter(source(ctx.having), query, expression(ctx.having)).     }     if (ctx.setQuantifier() != null && ctx.setQuantifier().DISTINCT() != null) {         query = new Distinct(source(ctx.setQuantifier()), query).     }     return query. }
false;public;1;8;;@Override public LogicalPlan visitFromClause(FromClauseContext ctx) {     // if there are multiple FROM clauses, convert each pair in a inner join     List<LogicalPlan> plans = plans(ctx.relation()).     return plans.stream().reduce((left, right) -> new Join(source(ctx), left, right, Join.JoinType.IMPLICIT, null)).get(). }
false;public;1;13;;@Override public LogicalPlan visitRelation(RelationContext ctx) {     // check if there are multiple join clauses. ANTLR produces a right nested tree with the left join clause     // at the top. However the fields previously references might be used in the following clauses.     // As such, swap/reverse the tree.     LogicalPlan result = plan(ctx.relationPrimary()).     for (JoinRelationContext j : ctx.joinRelation()) {         result = doJoin(j).     }     return result. }
false;private;1;12;;private Join doJoin(JoinRelationContext ctx) {     JoinCriteriaContext criteria = ctx.joinCriteria().     if (criteria != null) {         if (criteria.USING() != null) {             throw new UnsupportedOperationException().         }     }     // new Join(source(ctx), left, plan(ctx.right), type, condition).     throw new ParsingException(source(ctx), "Queries with JOIN are not yet supported"). }
false;public;1;4;;@Override public Object visitAliasedRelation(AliasedRelationContext ctx) {     return new SubQueryAlias(source(ctx), plan(ctx.relation()), visitQualifiedName(ctx.qualifiedName())). }
false;public;1;4;;@Override public Object visitAliasedQuery(AliasedQueryContext ctx) {     return new SubQueryAlias(source(ctx), plan(ctx.queryNoWith()), visitQualifiedName(ctx.qualifiedName())). }
false;public;1;4;;@Override public Object visitSubquery(SubqueryContext ctx) {     return plan(ctx.queryNoWith()). }
false;public;1;6;;@Override public LogicalPlan visitTableName(TableNameContext ctx) {     String alias = visitQualifiedName(ctx.qualifiedName()).     TableIdentifier tableIdentifier = visitTableIdentifier(ctx.tableIdentifier()).     return new UnresolvedRelation(source(ctx), tableIdentifier, alias). }
