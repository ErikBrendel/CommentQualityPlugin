commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String toSql() {     return toSql. }
false;public,static;1;11;;public static IndexType from(String name) {     if (name != null) {         name = name.toUpperCase(Locale.ROOT).         for (IndexType type : IndexType.VALID) {             if (type.toSql.equals(name)) {                 return type.             }         }     }     return IndexType.UNKNOWN. }
false;public;0;3;;public String name() {     return name. }
false;public;0;3;;public IndexType type() {     return type. }
false;public;0;4;;@Override public String toString() {     return name. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(name, type). }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     IndexResolver.IndexInfo other = (IndexResolver.IndexInfo) obj.     return Objects.equals(name, other.name) && Objects.equals(type, other.type). }
false;public;0;3;;public String clusterName() {     return clusterName. }
true;public;4;31;/**  * Resolves only the names, differentiating between indices and aliases.  * This method is required since the other methods rely on mapping which is tied to an index (not an alias).  */ ;/**  * Resolves only the names, differentiating between indices and aliases.  * This method is required since the other methods rely on mapping which is tied to an index (not an alias).  */ public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {     // first get aliases (if specified)     boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS).     boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX).     String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard).     if (retrieveAliases) {         GetAliasesRequest aliasRequest = new GetAliasesRequest().local(true).aliases(indices).indicesOptions(IndicesOptions.lenientExpandOpen()).         client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases -> resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener), ex -> {             // in both cases, that is allowed and we continue with the indices request             if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {                 resolveIndices(indices, javaRegex, null, retrieveIndices, listener).             } else {                 listener.onFailure(ex).             }         })).     } else {         resolveIndices(indices, javaRegex, null, retrieveIndices, listener).     } }
false;private;5;18;;private void resolveIndices(String[] indices, String javaRegex, GetAliasesResponse aliases, boolean retrieveIndices, ActionListener<Set<IndexInfo>> listener) {     if (retrieveIndices) {         GetIndexRequest indexRequest = new GetIndexRequest().local(true).indices(indices).features(Feature.SETTINGS).includeDefaults(false).indicesOptions(INDICES_ONLY_OPTIONS).         client.admin().indices().getIndex(indexRequest, ActionListener.wrap(response -> filterResults(javaRegex, aliases, response, listener), listener::onFailure)).     } else {         filterResults(javaRegex, aliases, null, listener).     } }
false;private;4;30;;private void filterResults(String javaRegex, GetAliasesResponse aliases, GetIndexResponse indices, ActionListener<Set<IndexInfo>> listener) {     // since the index name does not support ?, filter the results manually     Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null.     Set<IndexInfo> result = new TreeSet<>(Comparator.comparing(IndexInfo::name)).     // filter aliases (if present)     if (aliases != null) {         for (ObjectCursor<List<AliasMetaData>> cursor : aliases.getAliases().values()) {             for (AliasMetaData amd : cursor.value) {                 String alias = amd.alias().                 if (alias != null && (pattern == null || pattern.matcher(alias).matches())) {                     result.add(new IndexInfo(alias, IndexType.ALIAS)).                 }             }         }     }     // filter indices (if present)     String[] indicesNames = indices != null ? indices.indices() : null.     if (indicesNames != null) {         for (String indexName : indicesNames) {             if (pattern == null || pattern.matcher(indexName).matches()) {                 result.add(new IndexInfo(indexName, IndexType.INDEX)).             }         }     }     listener.onResponse(result). }
true;public;3;5;/**  * Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.  */ ;/**  * Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.  */ public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {     FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard).     client.fieldCaps(fieldRequest, ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure)). }
false;static;2;91;;static IndexResolution mergedMapping(String indexPattern, Map<String, Map<String, FieldCapabilities>> fieldCaps) {     if (fieldCaps == null || fieldCaps.isEmpty()) {         return IndexResolution.notFound(indexPattern).     }     StringBuilder errorMessage = new StringBuilder().     NavigableSet<Entry<String, Map<String, FieldCapabilities>>> sortedFields = new TreeSet<>(// for some reason .reversed doesn't work (prolly due to inference)     Collections.reverseOrder(Comparator.comparing(Entry::getKey))).     sortedFields.addAll(fieldCaps.entrySet()).     Map<String, EsField> hierarchicalMapping = new TreeMap<>().     Map<String, EsField> flattedMapping = new LinkedHashMap<>().     // (fields without multi-fields have no children)     for (Entry<String, Map<String, FieldCapabilities>> entry : sortedFields) {         InvalidMappedField invalidField = null.         FieldCapabilities fieldCap = null.         errorMessage.setLength(0).         String name = entry.getKey().         // Skip any of the blacklisted field names.         if (!FIELD_NAMES_BLACKLIST.contains(name)) {             Map<String, FieldCapabilities> types = entry.getValue().             // field is mapped differently across indices             if (types.size() > 1) {                 for (Entry<String, FieldCapabilities> type : types.entrySet()) {                     if (errorMessage.length() > 0) {                         errorMessage.append(", ").                     }                     errorMessage.append("[").                     errorMessage.append(type.getKey()).                     errorMessage.append("] in ").                     errorMessage.append(Arrays.toString(type.getValue().indices())).                 }                 errorMessage.insert(0, "mapped as [" + types.size() + "] incompatible types: ").                 invalidField = new InvalidMappedField(name, errorMessage.toString()).             } else // type is okay, check aggregation             {                 fieldCap = types.values().iterator().next().                 // as well). A meta field named "_version", for example, has the type named "_version".                 if (name.startsWith("_") && fieldCap.getType().startsWith("_")) {                     continue.                 }                 // validate search/agg-able                 if (fieldCap.isAggregatable() && fieldCap.nonAggregatableIndices() != null) {                     errorMessage.append("mapped as aggregatable except in ").                     errorMessage.append(Arrays.toString(fieldCap.nonAggregatableIndices())).                 }                 if (fieldCap.isSearchable() && fieldCap.nonSearchableIndices() != null) {                     if (errorMessage.length() > 0) {                         errorMessage.append(",").                     }                     errorMessage.append("mapped as searchable except in ").                     errorMessage.append(Arrays.toString(fieldCap.nonSearchableIndices())).                 }                 if (errorMessage.length() > 0) {                     invalidField = new InvalidMappedField(name, errorMessage.toString()).                 }             }             // validation passes - create the field             // if the name wasn't added before             final InvalidMappedField invalidF = invalidField.             final FieldCapabilities fieldCapab = fieldCap.             EsField esField = flattedMapping.get(name).             if (esField == null || (invalidF != null && (esField instanceof InvalidMappedField) == false)) {                 createField(name, fieldCaps, hierarchicalMapping, flattedMapping, s -> {                     return invalidF != null ? invalidF : createField(s, fieldCapab.getType(), emptyMap(), fieldCapab.isAggregatable()).                 }).             }         }     }     return IndexResolution.valid(new EsIndex(indexPattern, hierarchicalMapping)). }
false;private,static;5;38;;private static EsField createField(String fieldName, Map<String, Map<String, FieldCapabilities>> globalCaps, Map<String, EsField> hierarchicalMapping, Map<String, EsField> flattedMapping, Function<String, EsField> field) {     Map<String, EsField> parentProps = hierarchicalMapping.     int dot = fieldName.lastIndexOf('.').     String fullFieldName = fieldName.     if (dot >= 0) {         String parentName = fieldName.substring(0, dot).         fieldName = fieldName.substring(dot + 1).         EsField parent = flattedMapping.get(parentName).         if (parent == null) {             Map<String, FieldCapabilities> map = globalCaps.get(parentName).             Function<String, EsField> fieldFunction.             // lack of parent implies the field is an alias             if (map == null) {                 // as such, create the field manually                 fieldFunction = s -> createField(s, DataType.OBJECT.name(), new TreeMap<>(), false).             } else {                 FieldCapabilities parentCap = map.values().iterator().next().                 fieldFunction = s -> createField(s, parentCap.getType(), new TreeMap<>(), parentCap.isAggregatable()).             }             parent = createField(parentName, globalCaps, hierarchicalMapping, flattedMapping, fieldFunction).         }         parentProps = parent.getProperties().     }     EsField esField = field.apply(fieldName).     parentProps.put(fieldName, esField).     flattedMapping.put(fullFieldName, esField).     return esField. }
false;private,static;4;18;;private static EsField createField(String fieldName, String typeName, Map<String, EsField> props, boolean isAggregateable) {     DataType esType = DataType.fromTypeName(typeName).     switch(esType) {         case TEXT:             return new TextEsField(fieldName, props, false).         case KEYWORD:             int length = DataType.KEYWORD.defaultPrecision.             // TODO: to check whether isSearchable/isAggregateable takes into account the presence of the normalizer             boolean normalized = false.             return new KeywordEsField(fieldName, props, isAggregateable, length, normalized).         case DATETIME:             return new DateEsField(fieldName, props, isAggregateable).         case UNSUPPORTED:             return new UnsupportedEsField(fieldName, typeName).         default:             return new EsField(fieldName, esType, props, isAggregateable).     } }
false;private,static;1;8;;private static FieldCapabilitiesRequest createFieldCapsRequest(String index) {     return new FieldCapabilitiesRequest().indices(Strings.commaDelimitedListToStringArray(index)).fields("*").indicesOptions(IndicesOptions.lenientExpandOpen()). }
true;public;3;25;/**  * Resolves a pattern to multiple, separate indices. Doesn't perform validation.  */ ;// TODO: Concrete indices still uses get mapping // waiting on https://github.com/elastic/elasticsearch/pull/34071 //  /**  * Resolves a pattern to multiple, separate indices. Doesn't perform validation.  */ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {     GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard).     client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {         ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings().         List<EsIndex> results = new ArrayList<>(mappings.size()).         Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null.         for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {             /*                  * We support wildcard expressions here, and it's only for commands that only perform the get index call.                  * We can and simply have to use the concrete index name and show that to users.                  * Get index against an alias with security enabled, where the user has only access to get mappings for the alias                  * and not the concrete index: there is a well known information leak of the concrete index name in the response.                  */             String concreteIndex = indexMappings.key.             if (pattern == null || pattern.matcher(concreteIndex).matches()) {                 IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value).                 if (getIndexResult.isValid()) {                     results.add(getIndexResult.get()).                 }             }         }         results.sort(Comparator.comparing(EsIndex::name)).         listener.onResponse(results).     }, listener::onFailure)). }
false;private,static;1;8;;private static GetIndexRequest createGetIndexRequest(String index) {     return new GetIndexRequest().local(true).indices(Strings.commaDelimitedListToStringArray(index)).indicesOptions(IndicesOptions.lenientExpandOpen()). }
false;private,static;3;37;;private static IndexResolution buildGetIndexResult(String concreteIndex, String indexOrAlias, ImmutableOpenMap<String, MappingMetaData> mappings) {     // Make sure that the index contains only a single type     MappingMetaData singleType = null.     List<String> typeNames = null.     for (ObjectObjectCursor<String, MappingMetaData> type : mappings) {         // Default mappings are ignored as they are applied to each type. Each type alone holds all of its fields.         if ("_default_".equals(type.key)) {             continue.         }         if (singleType != null) {             // There are more than one types             if (typeNames == null) {                 typeNames = new ArrayList<>().                 typeNames.add(singleType.type()).             }             typeNames.add(type.key).         }         singleType = type.value.     }     if (singleType == null) {         return IndexResolution.invalid("[" + indexOrAlias + "] doesn't have any types so it is incompatible with sql").     } else if (typeNames != null) {         Collections.sort(typeNames).         return IndexResolution.invalid("[" + indexOrAlias + "] contains more than one type " + typeNames + " so it is incompatible with sql").     } else {         try {             Map<String, EsField> mapping = Types.fromEs(singleType.sourceAsMap()).             return IndexResolution.valid(new EsIndex(indexOrAlias, mapping)).         } catch (MappingException ex) {             return IndexResolution.invalid(ex.getMessage()).         }     } }
