# id;timestamp;commentText;codeText;commentWords;codeWords
IndexResolver -> public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1540313026;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard)__        client.fieldCaps(fieldRequest,_                ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,as,merged,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,field,capabilities,request,field,request,create,field,caps,request,index,wildcard,client,field,caps,field,request,action,listener,wrap,response,listener,on,response,merged,mapping,index,wildcard,response,get,listener,on,failure
IndexResolver -> public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1542807959;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard)__        client.fieldCaps(fieldRequest,_                ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,as,merged,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,field,capabilities,request,field,request,create,field,caps,request,index,wildcard,client,field,caps,field,request,action,listener,wrap,response,listener,on,response,merged,mapping,index,wildcard,response,get,listener,on,failure
IndexResolver -> public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1542814515;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard)__        client.fieldCaps(fieldRequest,_                ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,as,merged,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,field,capabilities,request,field,request,create,field,caps,request,index,wildcard,client,field,caps,field,request,action,listener,wrap,response,listener,on,response,merged,mapping,index,wildcard,response,get,listener,on,failure
IndexResolver -> public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1544702716;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard)__        client.fieldCaps(fieldRequest,_                ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,as,merged,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,field,capabilities,request,field,request,create,field,caps,request,index,wildcard,client,field,caps,field,request,action,listener,wrap,response,listener,on,response,merged,mapping,index,wildcard,response,get,listener,on,failure
IndexResolver -> public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1546446782;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard)__        client.fieldCaps(fieldRequest,_                ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,as,merged,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,field,capabilities,request,field,request,create,field,caps,request,index,wildcard,client,field,caps,field,request,action,listener,wrap,response,listener,on,response,merged,mapping,index,wildcard,response,get,listener,on,failure
IndexResolver -> public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1547151533;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard)__        client.fieldCaps(fieldRequest,_                ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,as,merged,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,field,capabilities,request,field,request,create,field,caps,request,index,wildcard,client,field,caps,field,request,action,listener,wrap,response,listener,on,response,merged,mapping,index,wildcard,response,get,listener,on,failure
IndexResolver -> public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1547652360;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard)__        client.fieldCaps(fieldRequest,_                ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,as,merged,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,field,capabilities,request,field,request,create,field,caps,request,index,wildcard,client,field,caps,field,request,action,listener,wrap,response,listener,on,response,merged,mapping,index,wildcard,response,get,listener,on,failure
IndexResolver -> public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1547713078;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard)__        client.fieldCaps(fieldRequest,_                ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,as,merged,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,field,capabilities,request,field,request,create,field,caps,request,index,wildcard,client,field,caps,field,request,action,listener,wrap,response,listener,on,response,merged,mapping,index,wildcard,response,get,listener,on,failure
IndexResolver -> public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1524684173;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(response -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = response.getMappings()___            List<IndexResolution> resolutions__            if (mappings.size() > 0) {_                resolutions = new ArrayList<>(mappings.size())__                Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__                for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                    String concreteIndex = indexMappings.key__                    if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                        resolutions.add(buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value))__                    }_                }_            } else {_                resolutions = emptyList()__            }__            listener.onResponse(merge(resolutions, indexWildcard))__        }, listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,with,same,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,response,get,mappings,list,index,resolution,resolutions,if,mappings,size,0,resolutions,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,resolutions,add,build,get,index,result,concrete,index,concrete,index,index,mappings,value,else,resolutions,empty,list,listener,on,response,merge,resolutions,index,wildcard,listener,on,failure
IndexResolver -> public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1531179852;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(response -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = response.getMappings()___            List<IndexResolution> resolutions__            if (mappings.size() > 0) {_                resolutions = new ArrayList<>(mappings.size())__                Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__                for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                    String concreteIndex = indexMappings.key__                    if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                        resolutions.add(buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value))__                    }_                }_            } else {_                resolutions = emptyList()__            }__            listener.onResponse(merge(resolutions, indexWildcard))__        }, listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,with,same,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,response,get,mappings,list,index,resolution,resolutions,if,mappings,size,0,resolutions,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,resolutions,add,build,get,index,result,concrete,index,concrete,index,index,mappings,value,else,resolutions,empty,list,listener,on,response,merge,resolutions,index,wildcard,listener,on,failure
IndexResolver -> public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1535723122;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(response -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = response.getMappings()___            List<IndexResolution> resolutions__            if (mappings.size() > 0) {_                resolutions = new ArrayList<>(mappings.size())__                Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__                for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                    String concreteIndex = indexMappings.key__                    if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                        resolutions.add(buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value))__                    }_                }_            } else {_                resolutions = emptyList()__            }__            listener.onResponse(merge(resolutions, indexWildcard))__        }, listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,with,same,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,response,get,mappings,list,index,resolution,resolutions,if,mappings,size,0,resolutions,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,resolutions,add,build,get,index,result,concrete,index,concrete,index,index,mappings,value,else,resolutions,empty,list,listener,on,response,merge,resolutions,index,wildcard,listener,on,failure
IndexResolver -> public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1536137328;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(response -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = response.getMappings()___            List<IndexResolution> resolutions__            if (mappings.size() > 0) {_                resolutions = new ArrayList<>(mappings.size())__                Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__                for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                    String concreteIndex = indexMappings.key__                    if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                        resolutions.add(buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value))__                    }_                }_            } else {_                resolutions = emptyList()__            }__            listener.onResponse(merge(resolutions, indexWildcard))__        }, listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,with,same,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,response,get,mappings,list,index,resolution,resolutions,if,mappings,size,0,resolutions,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,resolutions,add,build,get,index,result,concrete,index,concrete,index,index,mappings,value,else,resolutions,empty,list,listener,on,response,merge,resolutions,index,wildcard,listener,on,failure
IndexResolver -> public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener);1536314350;Resolves a pattern to one (potentially compound meaning that spawns multiple indices) mapping.;public void resolveWithSameMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(response -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = response.getMappings()___            List<IndexResolution> resolutions__            if (mappings.size() > 0) {_                resolutions = new ArrayList<>(mappings.size())__                Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__                for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                    String concreteIndex = indexMappings.key__                    if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                        resolutions.add(buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value))__                    }_                }_            } else {_                resolutions = emptyList()__            }__            listener.onResponse(merge(resolutions, indexWildcard))__        }, listener::onFailure))__    };resolves,a,pattern,to,one,potentially,compound,meaning,that,spawns,multiple,indices,mapping;public,void,resolve,with,same,mapping,string,index,wildcard,string,java,regex,action,listener,index,resolution,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,response,get,mappings,list,index,resolution,resolutions,if,mappings,size,0,resolutions,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,resolutions,add,build,get,index,result,concrete,index,concrete,index,index,mappings,value,else,resolutions,empty,list,listener,on,response,merge,resolutions,index,wildcard,listener,on,failure
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1524684173;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indexWildcard)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indexWildcard, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indexWildcard, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indexWildcard, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,index,wildcard,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,index,wildcard,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,index,wildcard,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,index,wildcard,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1531179852;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indexWildcard)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indexWildcard, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indexWildcard, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indexWildcard, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,index,wildcard,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,index,wildcard,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,index,wildcard,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,index,wildcard,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1535723122;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indexWildcard)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indexWildcard, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indexWildcard, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indexWildcard, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,index,wildcard,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,index,wildcard,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,index,wildcard,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,index,wildcard,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1536137328;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .indices(indices)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,indices,indices,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1536314350;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1540313026;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1542807959;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1542814515;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1544702716;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1546446782;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1547151533;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1547652360;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener);1547713078;Resolves only the names, differentiating between indices and aliases._This method is required since the other methods rely on mapping which is tied to an index (not an alias).;public void resolveNames(String indexWildcard, String javaRegex, EnumSet<IndexType> types, ActionListener<Set<IndexInfo>> listener) {__        _        boolean retrieveAliases = CollectionUtils.isEmpty(types) || types.contains(IndexType.ALIAS)__        boolean retrieveIndices = CollectionUtils.isEmpty(types) || types.contains(IndexType.INDEX)___        String[] indices = Strings.commaDelimitedListToStringArray(indexWildcard)__        if (retrieveAliases) {_            GetAliasesRequest aliasRequest = new GetAliasesRequest()_                    .local(true)_                    .aliases(indices)_                    .indicesOptions(IndicesOptions.lenientExpandOpen())__    _            client.admin().indices().getAliases(aliasRequest, ActionListener.wrap(aliases ->_                            resolveIndices(indices, javaRegex, aliases, retrieveIndices, listener),_                            ex -> {_                                _                                _                                _    _                                _                                if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {_                                    resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__                                } else {_                                    listener.onFailure(ex)__                                }_                            }))__        } else {_            resolveIndices(indices, javaRegex, null, retrieveIndices, listener)__        }_    };resolves,only,the,names,differentiating,between,indices,and,aliases,this,method,is,required,since,the,other,methods,rely,on,mapping,which,is,tied,to,an,index,not,an,alias;public,void,resolve,names,string,index,wildcard,string,java,regex,enum,set,index,type,types,action,listener,set,index,info,listener,boolean,retrieve,aliases,collection,utils,is,empty,types,types,contains,index,type,alias,boolean,retrieve,indices,collection,utils,is,empty,types,types,contains,index,type,index,string,indices,strings,comma,delimited,list,to,string,array,index,wildcard,if,retrieve,aliases,get,aliases,request,alias,request,new,get,aliases,request,local,true,aliases,indices,indices,options,indices,options,lenient,expand,open,client,admin,indices,get,aliases,alias,request,action,listener,wrap,aliases,resolve,indices,indices,java,regex,aliases,retrieve,indices,listener,ex,if,ex,instanceof,index,not,found,exception,ex,instanceof,elasticsearch,security,exception,resolve,indices,indices,java,regex,null,retrieve,indices,listener,else,listener,on,failure,ex,else,resolve,indices,indices,java,regex,null,retrieve,indices,listener
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1524684173;Resolves a pattern to multiple, separate indices.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1531179852;Resolves a pattern to multiple, separate indices.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1535723122;Resolves a pattern to multiple, separate indices.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1536137328;Resolves a pattern to multiple, separate indices.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1536314350;Resolves a pattern to multiple, separate indices.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1540313026;Resolves a pattern to multiple, separate indices. Doesn't perform validation.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices,doesn,t,perform,validation;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1542807959;Resolves a pattern to multiple, separate indices. Doesn't perform validation.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices,doesn,t,perform,validation;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1542814515;Resolves a pattern to multiple, separate indices. Doesn't perform validation.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices,doesn,t,perform,validation;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1544702716;Resolves a pattern to multiple, separate indices. Doesn't perform validation.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices,doesn,t,perform,validation;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1546446782;Resolves a pattern to multiple, separate indices. Doesn't perform validation.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices,doesn,t,perform,validation;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1547151533;Resolves a pattern to multiple, separate indices. Doesn't perform validation.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices,doesn,t,perform,validation;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1547652360;Resolves a pattern to multiple, separate indices. Doesn't perform validation.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices,doesn,t,perform,validation;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
IndexResolver -> public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener);1547713078;Resolves a pattern to multiple, separate indices. Doesn't perform validation.;public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, ActionListener<List<EsIndex>> listener) {_        GetIndexRequest getIndexRequest = createGetIndexRequest(indexWildcard)__        client.admin().indices().getIndex(getIndexRequest, ActionListener.wrap(getIndexResponse -> {_            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.getMappings()__            List<EsIndex> results = new ArrayList<>(mappings.size())__            Pattern pattern = javaRegex != null ? Pattern.compile(javaRegex) : null__            for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexMappings : mappings) {_                _                String concreteIndex = indexMappings.key__                if (pattern == null || pattern.matcher(concreteIndex).matches()) {_                    IndexResolution getIndexResult = buildGetIndexResult(concreteIndex, concreteIndex, indexMappings.value)__                    if (getIndexResult.isValid()) {_                        results.add(getIndexResult.get())__                    }_                }_            }_            results.sort(Comparator.comparing(EsIndex::name))__            listener.onResponse(results)__        }, listener::onFailure))__    };resolves,a,pattern,to,multiple,separate,indices,doesn,t,perform,validation;public,void,resolve,as,separate,mappings,string,index,wildcard,string,java,regex,action,listener,list,es,index,listener,get,index,request,get,index,request,create,get,index,request,index,wildcard,client,admin,indices,get,index,get,index,request,action,listener,wrap,get,index,response,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,mappings,get,index,response,get,mappings,list,es,index,results,new,array,list,mappings,size,pattern,pattern,java,regex,null,pattern,compile,java,regex,null,for,object,object,cursor,string,immutable,open,map,string,mapping,meta,data,index,mappings,mappings,string,concrete,index,index,mappings,key,if,pattern,null,pattern,matcher,concrete,index,matches,index,resolution,get,index,result,build,get,index,result,concrete,index,concrete,index,index,mappings,value,if,get,index,result,is,valid,results,add,get,index,result,get,results,sort,comparator,comparing,es,index,name,listener,on,response,results,listener,on,failure
