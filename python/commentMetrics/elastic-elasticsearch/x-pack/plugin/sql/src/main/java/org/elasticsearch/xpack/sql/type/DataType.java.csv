commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String sqlName() {     return sqlType.getName(). }
false;public;0;3;;public boolean isInteger() {     return isInteger. }
false;public;0;3;;public boolean isRational() {     return isRational. }
false;public;0;3;;public boolean isNumeric() {     return isInteger || isRational. }
true;public;0;4;/**  * Returns true if value is signed, false otherwise (including if the type is not numeric)  */ ;/**  * Returns true if value is signed, false otherwise (including if the type is not numeric)  */ public boolean isSigned() {     // For now all numeric values that es supports are signed     return isNumeric(). }
false;public;0;3;;public boolean isString() {     return this == KEYWORD || this == TEXT. }
false;public;0;3;;public boolean isPrimitive() {     return this != OBJECT && this != NESTED && this != UNSUPPORTED. }
false;public;0;3;;public boolean isDateBased() {     return this == DATE || this == DATETIME. }
false;public,static;1;3;;public static DataType fromOdbcType(String odbcType) {     return odbcToEs.get(odbcType). }
true;public,static;1;11;/**  * Creates returns DataType enum corresponding to the specified es type  */ ;/**  * Creates returns DataType enum corresponding to the specified es type  */ public static DataType fromTypeName(String esType) {     String uppercase = esType.toUpperCase(Locale.ROOT).     if (uppercase.equals("DATE")) {         return DataType.DATETIME.     }     try {         return DataType.valueOf(uppercase).     } catch (IllegalArgumentException ex) {         return DataType.UNSUPPORTED.     } }
false;public;0;3;;public String format() {     return isDateBased() ? DateUtils.DATE_PARSE_FORMAT : null. }
