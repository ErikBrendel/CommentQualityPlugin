commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public CompositeValuesSourceBuilder<?> createSourceBuilder() {     throw new SqlIllegalArgumentException("Default group does not translate to an aggregation"). }
false;protected;4;4;;@Override protected GroupByKey copy(String id, String fieldName, ScriptTemplate script, Direction direction) {     return this. }
false;public;0;3;;public List<GroupByKey> groups() {     return groups. }
false;public;0;31;;public AggregationBuilder asAggBuilder() {     AggregationBuilder rootGroup = null.     if (groups.isEmpty() && simpleAggs.isEmpty()) {         return null.     }     // if there's a group, move everything under the composite agg     if (!groups.isEmpty()) {         List<CompositeValuesSourceBuilder<?>> keys = new ArrayList<>(groups.size()).         // first iterate to compute the sources         for (GroupByKey key : groups) {             keys.add(key.asValueSource()).         }         rootGroup = new CompositeAggregationBuilder(ROOT_GROUP_NAME, keys).     } else {         rootGroup = new FiltersAggregationBuilder(ROOT_GROUP_NAME, matchAllQuery()).     }     for (LeafAgg agg : simpleAggs) {         rootGroup.subAggregation(agg.toBuilder()).     }     for (PipelineAgg agg : pipelineAggs) {         rootGroup.subAggregation(agg.toBuilder()).     }     return rootGroup. }
false;public;0;3;;public boolean useImplicitGroupBy() {     return groups.isEmpty(). }
false;public;1;3;;public Aggs addGroups(Collection<GroupByKey> groups) {     return new Aggs(combine(this.groups, groups), simpleAggs, pipelineAggs). }
false;public;1;6;;public Aggs addAgg(LeafAgg agg) {     if (simpleAggs.contains(agg)) {         return this.     }     return new Aggs(groups, combine(simpleAggs, agg), pipelineAggs). }
false;public;1;3;;public Aggs addAgg(PipelineAgg pipelineAgg) {     return new Aggs(groups, simpleAggs, combine(pipelineAggs, pipelineAgg)). }
false;public;1;16;;public GroupByKey findGroupForAgg(String groupOrAggId) {     for (GroupByKey group : this.groups) {         if (groupOrAggId.equals(group.id())) {             return group.         }     }     // maybe it's the default group agg ?     for (Agg agg : simpleAggs) {         if (groupOrAggId.equals(agg.id())) {             return IMPLICIT_GROUP_KEY.         }     }     return null. }
false;public;1;11;;public Aggs updateGroup(GroupByKey group) {     List<GroupByKey> groups = new ArrayList<>(this.groups).     for (int i = 0. i < groups.size(). i++) {         GroupByKey g = groups.get(i).         if (group.id().equals(g.id())) {             groups.set(i, group).             return with(groups).         }     }     throw new SqlIllegalArgumentException("Could not find group named {}", group.id()). }
false;public;1;3;;public Aggs with(List<GroupByKey> groups) {     return new Aggs(groups, simpleAggs, pipelineAggs). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(groups, simpleAggs, pipelineAggs). }
false;public;1;16;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     Aggs other = (Aggs) obj.     return Objects.equals(groups, other.groups) && Objects.equals(simpleAggs, other.simpleAggs) && Objects.equals(pipelineAggs, other.pipelineAggs). }
