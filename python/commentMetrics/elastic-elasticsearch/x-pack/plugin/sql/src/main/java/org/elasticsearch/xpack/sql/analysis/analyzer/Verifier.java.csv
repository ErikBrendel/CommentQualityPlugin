# id;timestamp;commentText;codeText;commentWords;codeWords
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1524684173;Check validity of Aggregate/GroupBy._This rule is needed for two reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the order/having might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything.;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,two,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,grouping,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,resolved,functions,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1526449283;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the order/having might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,grouping,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,resolved,functions,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1531382259;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,grouping,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,resolved,functions,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1540313026;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,grouping,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,resolved,functions,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1540486836;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,grouping,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,resolved,functions,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1540503333;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,grouping,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,resolved,functions,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1541092382;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,grouping,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,resolved,functions,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1542807959;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,grouping,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,resolved,functions,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1543209103;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures, resolvedFunctions)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,grouping,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,resolved,functions,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1543326371;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1544804437;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1545232441;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1545340316;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1546446877;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1547656870;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1548945185;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1549064305;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1549137947;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1549401172;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
Verifier -> private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,             Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures);1549697312;Check validity of Aggregate/GroupBy._This rule is needed for multiple reasons:_1. a user might specify an invalid aggregate (SELECT foo GROUP BY bar)_2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically_caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved_(because the expression gets resolved little by little without being pushed down,_without the Analyzer modifying anything._2a. HAVING also requires an Aggregate function_3. composite agg (used for GROUP BY) allows ordering only on the group keys;private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,_            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {_        return checkGroupByAgg(p, localFailures, resolvedFunctions)_                && checkGroupByOrder(p, localFailures, groupingFailures)_                && checkGroupByHaving(p, localFailures, groupingFailures, resolvedFunctions)__    };check,validity,of,aggregate,group,by,this,rule,is,needed,for,multiple,reasons,1,a,user,might,specify,an,invalid,aggregate,select,foo,group,by,bar,2,the,order,by,having,might,contain,a,non,grouped,attribute,this,is,typically,caught,by,the,analyzer,however,if,wrapped,in,a,function,abs,it,gets,resolved,because,the,expression,gets,resolved,little,by,little,without,being,pushed,down,without,the,analyzer,modifying,anything,2a,having,also,requires,an,aggregate,function,3,composite,agg,used,for,group,by,allows,ordering,only,on,the,group,keys;private,static,boolean,check,group,by,logical,plan,p,set,failure,local,failures,map,string,function,resolved,functions,set,logical,plan,grouping,failures,return,check,group,by,agg,p,local,failures,resolved,functions,check,group,by,order,p,local,failures,grouping,failures,check,group,by,having,p,local,failures,grouping,failures,resolved,functions
