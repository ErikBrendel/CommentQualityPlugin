commented;modifiers;parameterAmount;loc;comment;code
true;public;0;47;/**  * If needed, create a comparator for each indicated column (which is indicated by an index pointing to the column number from the  * result set).  */ ;/**  * If needed, create a comparator for each indicated column (which is indicated by an index pointing to the column number from the  * result set).  */ @SuppressWarnings({ "rawtypes", "unchecked" }) public List<Tuple<Integer, Comparator>> sortingColumns() {     if (customSort == Boolean.FALSE) {         return emptyList().     }     List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size()).     boolean aggSort = false.     for (Sort s : sort) {         Tuple<Integer, Comparator> tuple = new Tuple<>(Integer.valueOf(-1), null).         if (s instanceof AttributeSort) {             AttributeSort as = (AttributeSort) s.             // find the relevant column of each aggregate function             if (as.attribute() instanceof AggregateFunctionAttribute) {                 aggSort = true.                 AggregateFunctionAttribute afa = (AggregateFunctionAttribute) as.attribute().                 afa = (AggregateFunctionAttribute) aliases.getOrDefault(afa, afa).                 int atIndex = -1.                 for (int i = 0. i < fields.size(). i++) {                     Tuple<FieldExtraction, ExpressionId> field = fields.get(i).                     if (field.v2().equals(afa.innerId())) {                         atIndex = i.                         break.                     }                 }                 if (atIndex == -1) {                     throw new SqlIllegalArgumentException("Cannot find backing column for ordering aggregation [{}]", afa.name()).                 }                 // assemble a comparator for it                 Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder().                 comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp).                 tuple = new Tuple<>(Integer.valueOf(atIndex), comp).             }         }         sortingColumns.add(tuple).     }     if (customSort == null) {         customSort = Boolean.valueOf(aggSort).     }     return aggSort ? sortingColumns : emptyList(). }
true;public;1;24;/**  * Since the container contains both the field extractors and the visible columns,  * compact the information in the listener through a bitset that acts as a mask  * on what extractors are used for the visible columns.  */ ;/**  * Since the container contains both the field extractors and the visible columns,  * compact the information in the listener through a bitset that acts as a mask  * on what extractors are used for the visible columns.  */ public BitSet columnMask(List<Attribute> columns) {     BitSet mask = new BitSet(fields.size()).     for (Attribute column : columns) {         Attribute alias = aliases.get(column).         // find the column index         int index = -1.         ExpressionId id = column instanceof AggregateFunctionAttribute ? ((AggregateFunctionAttribute) column).innerId() : column.id().         ExpressionId aliasId = alias != null ? (alias instanceof AggregateFunctionAttribute ? ((AggregateFunctionAttribute) alias).innerId() : alias.id()) : null.         for (int i = 0. i < fields.size(). i++) {             Tuple<FieldExtraction, ExpressionId> tuple = fields.get(i).             if (tuple.v2().equals(id) || (aliasId != null && tuple.v2().equals(aliasId))) {                 index = i.                 break.             }         }         if (index > -1) {             mask.set(index).         } else {             throw new SqlIllegalArgumentException("Cannot resolve field extractor index for column [{}]", column).         }     }     return mask. }
false;public;0;3;;public Query query() {     return query. }
false;public;0;3;;public Aggs aggs() {     return aggs. }
false;public;0;3;;public List<Tuple<FieldExtraction, ExpressionId>> fields() {     return fields. }
false;public;0;3;;public AttributeMap<Attribute> aliases() {     return aliases. }
false;public;0;3;;public Map<String, GroupByKey> pseudoFunctions() {     return pseudoFunctions. }
false;public;0;3;;public Set<Sort> sort() {     return sort. }
false;public;0;3;;public int limit() {     return limit. }
false;public;0;7;;public boolean isAggsOnly() {     if (aggsOnly == null) {         aggsOnly = Boolean.valueOf(this.fields.stream().allMatch(t -> t.v1().supportedByAggsOnlyQuery())).     }     return aggsOnly.booleanValue(). }
false;public;0;3;;public boolean hasColumns() {     return fields.size() > 0. }
false;public;0;3;;public boolean shouldTrackHits() {     return trackHits. }
false;public;1;3;;//  // copy methods //  public QueryContainer with(Query q) {     return new QueryContainer(q, aggs, fields, aliases, pseudoFunctions, scalarFunctions, sort, limit, trackHits). }
false;public;1;3;;public QueryContainer withAliases(AttributeMap<Attribute> a) {     return new QueryContainer(query, aggs, fields, a, pseudoFunctions, scalarFunctions, sort, limit, trackHits). }
false;public;1;3;;public QueryContainer withPseudoFunctions(Map<String, GroupByKey> p) {     return new QueryContainer(query, aggs, fields, aliases, p, scalarFunctions, sort, limit, trackHits). }
false;public;1;3;;public QueryContainer with(Aggs a) {     return new QueryContainer(query, a, fields, aliases, pseudoFunctions, scalarFunctions, sort, limit, trackHits). }
false;public;1;3;;public QueryContainer withLimit(int l) {     return l == limit ? this : new QueryContainer(query, aggs, fields, aliases, pseudoFunctions, scalarFunctions, sort, l, trackHits). }
false;public;0;3;;public QueryContainer withTrackHits() {     return trackHits ? this : new QueryContainer(query, aggs, fields, aliases, pseudoFunctions, scalarFunctions, sort, limit, true). }
false;public;1;3;;public QueryContainer withScalarProcessors(AttributeMap<Pipe> procs) {     return new QueryContainer(query, aggs, fields, aliases, pseudoFunctions, procs, sort, limit, trackHits). }
false;public;1;5;;public QueryContainer addSort(Sort sortable) {     Set<Sort> sort = new LinkedHashSet<>(this.sort).     sort.add(sortable).     return new QueryContainer(query, aggs, fields, aliases, pseudoFunctions, scalarFunctions, sort, limit, trackHits). }
false;private;1;3;;private String aliasName(Attribute attr) {     return aliases.getOrDefault(attr, attr).name(). }
true;private;1;3;//  ;//  // reference methods //  private FieldExtraction topHitFieldRef(FieldAttribute fieldAttr) {     return new SearchHitFieldRef(aliasName(fieldAttr), fieldAttr.field().getDataType(), fieldAttr.field().isAggregatable()). }
false;private;1;15;;private Tuple<QueryContainer, FieldExtraction> nestedHitFieldRef(FieldAttribute attr) {     // Find the nested query for this field. If there isn't one then create it     List<FieldExtraction> nestedRefs = new ArrayList<>().     String name = aliasName(attr).     Query q = rewriteToContainNestedField(query, attr.source(), attr.nestedParent().name(), name, attr.field().getDataType().format(), attr.field().isAggregatable()).     SearchHitFieldRef nestedFieldRef = new SearchHitFieldRef(name, attr.field().getDataType(), attr.field().isAggregatable(), attr.parent().name()).     nestedRefs.add(nestedFieldRef).     return new Tuple<>(new QueryContainer(q, aggs, fields, aliases, pseudoFunctions, scalarFunctions, sort, limit, trackHits), nestedFieldRef). }
false;static;6;26;;static Query rewriteToContainNestedField(@Nullable Query query, Source source, String path, String name, String format, boolean hasDocValues) {     if (query == null) {         /* There is no query so we must add the nested query              * ourselves to fetch the field. */         return new NestedQuery(source, path, singletonMap(name, new AbstractMap.SimpleImmutableEntry<>(hasDocValues, format)), new MatchAll(source)).     }     if (query.containsNestedField(path, name)) {         // The query already has the nested field. Nothing to do.         return query.     }     /* The query doesn't have the nested field so we have to ask          * it to add it. */     Query rewritten = query.addNestedField(path, name, format, hasDocValues).     if (rewritten != query) {         /* It successfully added it so we can use the rewritten              * query. */         return rewritten.     }     /* There is no nested query with a matching path so we must          * add the nested query ourselves just to fetch the field. */     NestedQuery nested = new NestedQuery(source, path, singletonMap(name, new AbstractMap.SimpleImmutableEntry<>(hasDocValues, format)), new MatchAll(source)).     return new BoolQuery(source, true, query, nested). }
false;public;1;7;;@Override public FieldExtraction resolve(Attribute attribute) {     Attribute attr = aliases.getOrDefault(attribute, attribute).     Tuple<QueryContainer, FieldExtraction> ref = container.toReference(attr).     container = ref.v1().     return ref.v2(). }
true;private;1;39;// replace function/operators's input with references ;// replace function/operators's input with references private Tuple<QueryContainer, FieldExtraction> resolvedTreeComputingRef(ScalarFunctionAttribute ta) {     Attribute attribute = aliases.getOrDefault(ta, ta).     Pipe proc = scalarFunctions.get(attribute).     // check the attribute itself     if (proc == null) {         if (attribute instanceof ScalarFunctionAttribute) {             ta = (ScalarFunctionAttribute) attribute.         }         proc = ta.asPipe().     }     // no need to promote them to the top since the container doesn't have to be aware     class QueryAttributeResolver implements Pipe.AttributeResolver {          private QueryContainer container.          private QueryAttributeResolver(QueryContainer container) {             this.container = container.         }          @Override         public FieldExtraction resolve(Attribute attribute) {             Attribute attr = aliases.getOrDefault(attribute, attribute).             Tuple<QueryContainer, FieldExtraction> ref = container.toReference(attr).             container = ref.v1().             return ref.v2().         }     }     QueryAttributeResolver resolver = new QueryAttributeResolver(this).     proc = proc.resolveAttributes(resolver).     QueryContainer qContainer = resolver.container.     // update proc     Map<Attribute, Pipe> procs = new LinkedHashMap<>(qContainer.scalarFunctions()).     procs.put(attribute, proc).     qContainer = qContainer.withScalarProcessors(new AttributeMap<>(procs)).     return new Tuple<>(qContainer, new ComputedRef(proc)). }
false;public;1;4;;public QueryContainer addColumn(Attribute attr) {     Tuple<QueryContainer, FieldExtraction> tuple = toReference(attr).     return tuple.v1().addColumn(tuple.v2(), attr). }
false;private;1;21;;private Tuple<QueryContainer, FieldExtraction> toReference(Attribute attr) {     if (attr instanceof FieldAttribute) {         FieldAttribute fa = (FieldAttribute) attr.         if (fa.isNested()) {             return nestedHitFieldRef(fa).         } else {             return new Tuple<>(this, topHitFieldRef(fa)).         }     }     if (attr instanceof ScalarFunctionAttribute) {         return resolvedTreeComputingRef((ScalarFunctionAttribute) attr).     }     if (attr instanceof LiteralAttribute) {         return new Tuple<>(this, new ComputedRef(((LiteralAttribute) attr).asPipe())).     }     if (attr instanceof ScoreAttribute) {         return new Tuple<>(this, new ComputedRef(((ScoreAttribute) attr).asPipe())).     }     throw new SqlIllegalArgumentException("Unknown output attribute {}", attr). }
false;public;2;6;;public QueryContainer addColumn(FieldExtraction ref, Attribute attr) {     ExpressionId id = attr instanceof AggregateFunctionAttribute ? ((AggregateFunctionAttribute) attr).innerId() : attr.id().     return new QueryContainer(query, aggs, combine(fields, new Tuple<>(ref, id)), aliases, pseudoFunctions, scalarFunctions, sort, limit, trackHits). }
false;public;0;3;;public AttributeMap<Pipe> scalarFunctions() {     return scalarFunctions. }
false;public;2;3;;//  // agg methods //  public QueryContainer addAgg(String groupId, LeafAgg agg) {     return with(aggs.addAgg(agg)). }
false;public;1;3;;public QueryContainer addGroups(Collection<GroupByKey> values) {     return with(aggs.addGroups(values)). }
false;public;1;3;;public GroupByKey findGroupForAgg(String aggId) {     return aggs.findGroupForAgg(aggId). }
false;public;1;3;;public QueryContainer updateGroup(GroupByKey group) {     return with(aggs.updateGroup(group)). }
false;public;0;4;;//  // boiler plate //  @Override public int hashCode() {     return Objects.hash(query, aggs, fields, aliases, sort, limit). }
false;public;1;18;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     QueryContainer other = (QueryContainer) obj.     return Objects.equals(query, other.query) && Objects.equals(aggs, other.aggs) && Objects.equals(fields, other.fields) && Objects.equals(aliases, other.aliases) && Objects.equals(sort, other.sort) && Objects.equals(limit, other.limit). }
false;public;0;10;;@Override public String toString() {     try (XContentBuilder builder = JsonXContent.contentBuilder()) {         builder.humanReadable(true).prettyPrint().         SourceGenerator.sourceBuilder(this, null, null).toXContent(builder, ToXContent.EMPTY_PARAMS).         return Strings.toString(builder).     } catch (IOException e) {         throw new RuntimeException("error rendering", e).     } }
