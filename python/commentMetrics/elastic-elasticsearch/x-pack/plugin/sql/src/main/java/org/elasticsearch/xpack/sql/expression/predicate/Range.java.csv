commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected NodeInfo<Range> info() {     return NodeInfo.create(this, Range::new, value, lower, includeLower, upper, includeUpper). }
false;public;1;7;;@Override public Expression replaceChildren(List<Expression> newChildren) {     if (newChildren.size() != 3) {         throw new IllegalArgumentException("expected [3] children but received [" + newChildren.size() + "]").     }     return new Range(source(), newChildren.get(0), newChildren.get(1), includeLower, newChildren.get(2), includeUpper). }
false;public;0;3;;public Expression value() {     return value. }
false;public;0;3;;public Expression lower() {     return lower. }
false;public;0;3;;public Expression upper() {     return upper. }
false;public;0;3;;public boolean includeLower() {     return includeLower. }
false;public;0;3;;public boolean includeUpper() {     return includeUpper. }
false;public;0;8;;@Override public boolean foldable() {     if (lower.foldable() && upper.foldable()) {         return areBoundariesInvalid() || value.foldable().     }     return false. }
false;public;0;13;;@Override public Object fold() {     if (areBoundariesInvalid()) {         return Boolean.FALSE.     }     Object val = value.fold().     Integer lowerCompare = BinaryComparison.compare(lower.fold(), val).     Integer upperCompare = BinaryComparison.compare(val, upper().fold()).     boolean lowerComparsion = lowerCompare == null ? false : (includeLower ? lowerCompare <= 0 : lowerCompare < 0).     boolean upperComparsion = upperCompare == null ? false : (includeUpper ? upperCompare <= 0 : upperCompare < 0).     return lowerComparsion && upperComparsion. }
true;private;0;5;/**  * Check whether the boundaries are invalid ( upper &lt. lower) or not.  * If they do, the value does not have to be evaluate.  */ ;/**  * Check whether the boundaries are invalid ( upper &lt. lower) or not.  * If they do, the value does not have to be evaluate.  */ private boolean areBoundariesInvalid() {     Integer compare = BinaryComparison.compare(lower.fold(), upper.fold()).     // upper < lower OR upper == lower and the range doesn't contain any equals     return compare != null && (compare > 0 || (compare == 0 && (!includeLower || !includeUpper))). }
false;public;0;4;;@Override public Nullability nullable() {     return Nullability.and(value.nullable(), lower.nullable(), upper.nullable()). }
false;public;0;4;;@Override public DataType dataType() {     return DataType.BOOLEAN. }
false;public;0;25;;@Override public ScriptTemplate asScript() {     ScriptTemplate valueScript = asScript(value).     ScriptTemplate lowerScript = asScript(lower).     ScriptTemplate upperScript = asScript(upper).     String template = formatTemplate(format(Locale.ROOT, "{sql}.and({sql}.%s(%s, %s), {sql}.%s(%s, %s))", includeLower() ? "gte" : "gt", valueScript.template(), lowerScript.template(), includeUpper() ? "lte" : "lt", valueScript.template(), upperScript.template())).     Params params = paramsBuilder().script(valueScript.params()).script(lowerScript.params()).script(valueScript.params()).script(upperScript.params()).build().     return new ScriptTemplate(template, params, DataType.BOOLEAN). }
false;protected;0;9;;@Override protected Pipe makePipe() {     BinaryComparisonPipe lowerPipe = new BinaryComparisonPipe(source(), this, Expressions.pipe(value()), Expressions.pipe(lower()), includeLower() ? BinaryComparisonOperation.GTE : BinaryComparisonOperation.GT).     BinaryComparisonPipe upperPipe = new BinaryComparisonPipe(source(), this, Expressions.pipe(value()), Expressions.pipe(upper()), includeUpper() ? BinaryComparisonOperation.LTE : BinaryComparisonOperation.LT).     BinaryLogicPipe and = new BinaryLogicPipe(source(), this, lowerPipe, upperPipe, BinaryLogicOperation.AND).     return and. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(includeLower, includeUpper, value, lower, upper). }
false;public;1;17;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     Range other = (Range) obj.     return Objects.equals(includeLower, other.includeLower) && Objects.equals(includeUpper, other.includeUpper) && Objects.equals(value, other.value) && Objects.equals(lower, other.lower) && Objects.equals(upper, other.upper). }
false;private,static;5;24;;private static String name(Expression value, Expression lower, Expression upper, boolean includeLower, boolean includeUpper) {     StringBuilder sb = new StringBuilder().     sb.append(Expressions.name(lower)).     if (!(lower instanceof Literal)) {         sb.insert(0, "(").         sb.append(")").     }     sb.append(includeLower ? " <= " : " < ").     int pos = sb.length().     sb.append(Expressions.name(value)).     if (!(value instanceof Literal)) {         sb.insert(pos, "(").         sb.append(")").     }     sb.append(includeUpper ? " <= " : " < ").     pos = sb.length().     sb.append(Expressions.name(upper)).     if (!(upper instanceof Literal)) {         sb.insert(pos, "(").         sb.append(")").     }     return sb.toString(). }
