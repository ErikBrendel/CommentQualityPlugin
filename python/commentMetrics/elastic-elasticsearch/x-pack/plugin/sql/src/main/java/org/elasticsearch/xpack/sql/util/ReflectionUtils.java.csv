commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;27;;@SuppressWarnings("unchecked") public static <E> Class<E> detectSuperTypeForRuleLike(Class<?> c) {     Class<?> clazz = c.     for (Type type = clazz.getGenericSuperclass(). clazz != Object.class. type = clazz.getGenericSuperclass()) {         if (type instanceof ParameterizedType) {             Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments().             if (typeArguments.length != 2 && typeArguments.length != 1) {                 throw new SqlIllegalArgumentException("Unexpected number of type arguments {} for {}", Arrays.toString(typeArguments), c).             }             Type tp = typeArguments[0].             if (tp instanceof Class<?>) {                 return (Class<E>) tp.             } else if (tp instanceof ParameterizedType) {                 Type rawType = ((ParameterizedType) type).getRawType().                 if (rawType instanceof Class<?>) {                     return (Class<E>) rawType.                 }             }             throw new SqlIllegalArgumentException("Unexpected class structure for class {}", c).         }         clazz = clazz.getSuperclass().     }     throw new SqlIllegalArgumentException("Unexpected class structure for class {}", c). }
true;public,static;1;11;// remove packaging from the name - strategy used for naming rules by default ;// remove packaging from the name - strategy used for naming rules by default public static String ruleLikeNaming(Class<?> c) {     String className = c.getName().     int parentPackage = className.lastIndexOf(".").     if (parentPackage > 0) {         int grandParentPackage = className.substring(0, parentPackage).lastIndexOf(".").         return (grandParentPackage > 0 ? className.substring(grandParentPackage + 1) : className.substring(parentPackage)).     } else {         return className.     } }
