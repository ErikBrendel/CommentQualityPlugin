commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Used only in tests  */ ;/**  * Used only in tests  */ public LogicalPlan createStatement(String sql) {     return createStatement(sql, Collections.emptyList()). }
true;public;2;6;/**  * Parses an SQL statement into execution plan  * @param sql - the SQL statement  * @param params - a list of parameters for the statement if the statement is parametrized  * @return logical plan  */ ;/**  * Parses an SQL statement into execution plan  * @param sql - the SQL statement  * @param params - a list of parameters for the statement if the statement is parametrized  * @return logical plan  */ public LogicalPlan createStatement(String sql, List<SqlTypedParamValue> params) {     if (log.isDebugEnabled()) {         log.debug("Parsing as statement: {}", sql).     }     return invokeParser(sql, params, SqlBaseParser::singleStatement, AstBuilder::plan). }
true;public;1;3;/**  * Parses an expression - used only in tests  */ ;/**  * Parses an expression - used only in tests  */ public Expression createExpression(String expression) {     return createExpression(expression, Collections.emptyList()). }
true;public;2;7;/**  * Parses an expression - Used only in tests  */ ;/**  * Parses an expression - Used only in tests  */ public Expression createExpression(String expression, List<SqlTypedParamValue> params) {     if (log.isDebugEnabled()) {         log.debug("Parsing as expression: {}", expression).     }     return invokeParser(expression, params, SqlBaseParser::singleExpression, AstBuilder::expression). }
false;private;4;44;;private <T> T invokeParser(String sql, List<SqlTypedParamValue> params, Function<SqlBaseParser, ParserRuleContext> parseFunction, BiFunction<AstBuilder, ParserRuleContext, T> visitor) {     SqlBaseLexer lexer = new SqlBaseLexer(new CaseInsensitiveStream(sql)).     lexer.removeErrorListeners().     lexer.addErrorListener(ERROR_LISTENER).     Map<Token, SqlTypedParamValue> paramTokens = new HashMap<>().     TokenSource tokenSource = new ParametrizedTokenSource(lexer, paramTokens, params).     CommonTokenStream tokenStream = new CommonTokenStream(tokenSource).     SqlBaseParser parser = new SqlBaseParser(tokenStream).     parser.addParseListener(new CircuitBreakerListener()).     parser.addParseListener(new PostProcessor(Arrays.asList(parser.getRuleNames()))).     parser.removeErrorListeners().     parser.addErrorListener(ERROR_LISTENER).     parser.getInterpreter().setPredictionMode(PredictionMode.SLL).     if (DEBUG) {         debug(parser).         tokenStream.fill().         for (Token t : tokenStream.getTokens()) {             String symbolicName = SqlBaseLexer.VOCABULARY.getSymbolicName(t.getType()).             String literalName = SqlBaseLexer.VOCABULARY.getLiteralName(t.getType()).             log.info(format(Locale.ROOT, "  %-15s '%s'", symbolicName == null ? literalName : symbolicName, t.getText())).         }     }     ParserRuleContext tree = parseFunction.apply(parser).     if (DEBUG) {         log.info("Parse tree {} " + tree.toStringTree()).     }     return visitor.apply(new AstBuilder(paramTokens), tree). }
false;public;6;3;;@Override public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) { }
false;public;6;3;;@Override public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) { }
false;private,static;1;17;;private static void debug(SqlBaseParser parser) {     // when debugging, use the exact prediction mode (needed for diagnostics as well)     parser.getInterpreter().setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION).     parser.addParseListener(parser.new TraceListener()).     parser.addErrorListener(new DiagnosticErrorListener(false) {          @Override         public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {         }          @Override         public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {         }     }). }
false;public;1;9;;@Override public void exitBackQuotedIdentifier(SqlBaseParser.BackQuotedIdentifierContext context) {     Token token = context.BACKQUOTED_IDENTIFIER().getSymbol().     throw new ParsingException("backquoted identifiers not supported. please use double quotes instead", null, token.getLine(), token.getCharPositionInLine()). }
false;public;1;9;;@Override public void exitDigitIdentifier(SqlBaseParser.DigitIdentifierContext context) {     Token token = context.DIGIT_IDENTIFIER().getSymbol().     throw new ParsingException("identifiers must not start with a digit. please use double quotes", null, token.getLine(), token.getCharPositionInLine()). }
false;public;1;13;;@Override public void exitQuotedIdentifier(SqlBaseParser.QuotedIdentifierContext context) {     // Remove quotes     context.getParent().removeLastChild().     Token token = (Token) context.getChild(0).getPayload().     context.getParent().addChild(new CommonToken(new Pair<>(token.getTokenSource(), token.getInputStream()), SqlBaseLexer.IDENTIFIER, token.getChannel(), token.getStartIndex() + 1, token.getStopIndex() - 1)). }
false;public;1;19;;@Override public void exitNonReserved(SqlBaseParser.NonReservedContext context) {     // tree cannot be modified during rule enter/exit _unless_ it's a terminal node     if (!(context.getChild(0) instanceof TerminalNode)) {         int rule = ((ParserRuleContext) context.getChild(0)).getRuleIndex().         throw new ParsingException("nonReserved can only contain tokens. Found nested rule: " + ruleNames.get(rule)).     }     // replace nonReserved words with IDENT tokens     context.getParent().removeLastChild().     Token token = (Token) context.getChild(0).getPayload().     context.getParent().addChild(new CommonToken(new Pair<>(token.getTokenSource(), token.getInputStream()), SqlBaseLexer.IDENTIFIER, token.getChannel(), token.getStartIndex(), token.getStopIndex())). }
false;public;1;25;;@Override public void enterEveryRule(ParserRuleContext ctx) {     if (inDetected(ctx)) {         insideIn = true.     }     // Also skip the Identifiers as they are "cheap".     if (ctx.getClass() != UnquoteIdentifierContext.class && ctx.getClass() != QuoteIdentifierContext.class && ctx.getClass() != BackQuotedIdentifierContext.class && ctx.getClass() != SqlBaseParser.ConstantContext.class && ctx.getClass() != SqlBaseParser.NumberContext.class && ctx.getClass() != SqlBaseParser.ValueExpressionContext.class && (insideIn == false || ctx.getClass() != PrimaryExpressionContext.class)) {         int currentDepth = depthCounts.putOrAdd(ctx.getClass().getSimpleName(), (short) 1, (short) 1).         if (currentDepth > MAX_RULE_DEPTH) {             throw new ParsingException(source(ctx), "SQL statement too large. " + "halt parsing to prevent memory errors (stopped at depth {})", MAX_RULE_DEPTH).         }     }     super.enterEveryRule(ctx). }
false;public;1;9;;@Override public void exitEveryRule(ParserRuleContext ctx) {     if (inDetected(ctx)) {         insideIn = false.     }     decrementCounter(ctx).     super.exitEveryRule(ctx). }
false;;0;3;;ObjectShortHashMap<String> depthCounts() {     return depthCounts. }
false;private;1;9;;private void decrementCounter(ParserRuleContext ctx) {     String className = ctx.getClass().getSimpleName().     String classNameToDecrement = ENTER_EXIT_RULE_MAPPING.getOrDefault(className, className).     // Avoid having negative numbers     if (depthCounts.containsKey(classNameToDecrement)) {         depthCounts.putOrAdd(classNameToDecrement, (short) 0, (short) -1).     } }
false;private;1;7;;private boolean inDetected(ParserRuleContext ctx) {     if (ctx.getParent() != null && ctx.getParent().getClass() == SqlBaseParser.PredicateContext.class) {         SqlBaseParser.PredicateContext pc = (SqlBaseParser.PredicateContext) ctx.getParent().         return pc.kind != null && pc.kind.getType() == SqlBaseParser.IN.     }     return false. }
false;public;6;5;;@Override public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String message, RecognitionException e) {     throw new ParsingException(message, e, line, charPositionInLine). }
false;public;0;12;;@Override public Token nextToken() {     Token token = delegate.nextToken().     if (token.getType() == SqlBaseLexer.PARAM) {         if (param >= params.size()) {             throw new ParsingException("Not enough actual parameters {} ", params.size()).         }         paramTokens.put(token, params.get(param)).         param++.     }     return token. }
false;public;0;4;;@Override public int getLine() {     return delegate.getLine(). }
false;public;0;4;;@Override public int getCharPositionInLine() {     return delegate.getCharPositionInLine(). }
false;public;0;4;;@Override public CharStream getInputStream() {     return delegate.getInputStream(). }
false;public;0;4;;@Override public String getSourceName() {     return delegate.getSourceName(). }
false;public;1;4;;@Override public void setTokenFactory(TokenFactory<?> factory) {     delegate.setTokenFactory(factory). }
false;public;0;4;;@Override public TokenFactory<?> getTokenFactory() {     return delegate.getTokenFactory(). }
