commented;modifiers;parameterAmount;loc;comment;code
false;private;0;5;;private void checkOpen() throws SQLException {     if (isClosed()) {         throw new SQLException("Connection is closed").     } }
false;public;0;5;;@Override public Statement createStatement() throws SQLException {     checkOpen().     return new JdbcStatement(this, cfg). }
false;public;1;5;;@Override public PreparedStatement prepareStatement(String sql) throws SQLException {     checkOpen().     return new JdbcPreparedStatement(this, cfg, sql). }
false;public;1;4;;@Override public CallableStatement prepareCall(String sql) throws SQLException {     throw new SQLFeatureNotSupportedException("Stored procedures not supported yet"). }
false;public;1;5;;@Override public String nativeSQL(String sql) throws SQLException {     checkOpen().     return sql. }
false;public;1;7;;@Override public void setAutoCommit(boolean autoCommit) throws SQLException {     checkOpen().     if (!autoCommit) {         new SQLFeatureNotSupportedException("Non auto-commit is not supported").     } }
false;public;0;5;;@Override public boolean getAutoCommit() throws SQLException {     checkOpen().     return true. }
false;public;0;8;;@Override public void commit() throws SQLException {     checkOpen().     if (getAutoCommit()) {         throw new SQLException("Auto-commit is enabled").     }     throw new SQLFeatureNotSupportedException("Commit/Rollback not supported"). }
false;public;0;8;;@Override public void rollback() throws SQLException {     checkOpen().     if (getAutoCommit()) {         throw new SQLException("Auto-commit is enabled").     }     throw new SQLFeatureNotSupportedException("Commit/Rollback not supported"). }
false;public;0;7;;@Override public void close() throws SQLException {     if (!isClosed()) {         closed = true.         Debug.release(cfg).     } }
false;public;0;4;;@Override public boolean isClosed() {     return closed. }
false;public;0;4;;@Override public DatabaseMetaData getMetaData() throws SQLException {     return new JdbcDatabaseMetaData(this). }
false;public;1;6;;@Override public void setReadOnly(boolean readOnly) throws SQLException {     if (!readOnly) {         throw new SQLFeatureNotSupportedException("Only read-only mode is supported").     } }
false;public;0;5;;@Override public boolean isReadOnly() throws SQLException {     checkOpen().     return true. }
false;public;1;5;;@Override public void setCatalog(String catalog) throws SQLException {     checkOpen().     this.catalog = catalog. }
false;public;0;5;;@Override public String getCatalog() throws SQLException {     checkOpen().     return catalog. }
false;public;1;7;;@Override public void setTransactionIsolation(int level) throws SQLException {     checkOpen().     if (TRANSACTION_NONE != level) {         throw new SQLFeatureNotSupportedException("Transactions not supported").     } }
false;public;0;5;;@Override public int getTransactionIsolation() throws SQLException {     checkOpen().     return TRANSACTION_NONE. }
false;public;0;5;;@Override public SQLWarning getWarnings() throws SQLException {     checkOpen().     return null. }
false;public;0;5;;@Override public void clearWarnings() throws SQLException {     checkOpen(). // no-op }
false;public;2;5;;@Override public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {     checkResultSet(resultSetType, resultSetConcurrency).     return createStatement(). }
false;public;3;5;;@Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {     checkResultSet(resultSetType, resultSetConcurrency).     return prepareStatement(sql). }
false;public;3;5;;@Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {     checkResultSet(resultSetType, resultSetConcurrency).     return prepareCall(sql). }
false;public;0;5;;@Override public Map<String, Class<?>> getTypeMap() throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("typeMap not supported"). }
false;public;1;5;;@Override public void setTypeMap(Map<String, Class<?>> map) throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("typeMap not supported"). }
false;public;1;5;;@Override public void setHoldability(int holdability) throws SQLException {     checkOpen().     checkHoldability(holdability). }
false;public;0;5;;@Override public int getHoldability() throws SQLException {     checkOpen().     return ResultSet.HOLD_CURSORS_OVER_COMMIT. }
false;public;0;5;;@Override public Savepoint setSavepoint() throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Savepoints not supported"). }
false;public;1;5;;@Override public Savepoint setSavepoint(String name) throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Savepoints not supported"). }
false;public;1;5;;@Override public void rollback(Savepoint savepoint) throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Savepoints not supported"). }
false;public;1;5;;@Override public void releaseSavepoint(Savepoint savepoint) throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Savepoints not supported"). }
false;public;3;6;;@Override public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {     checkOpen().     checkHoldability(resultSetHoldability).     return createStatement(resultSetType, resultSetConcurrency). }
false;public;4;7;;@Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {     checkOpen().     checkHoldability(resultSetHoldability).     return prepareStatement(sql, resultSetType, resultSetConcurrency). }
false;public;4;7;;@Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {     checkOpen().     checkHoldability(resultSetHoldability).     return prepareCall(sql, resultSetType, resultSetConcurrency). }
false;public;2;8;;@Override public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {     checkOpen().     if (autoGeneratedKeys != Statement.NO_GENERATED_KEYS) {         throw new SQLFeatureNotSupportedException("Auto generated keys must be NO_GENERATED_KEYS").     }     return prepareStatement(sql). }
false;public;2;5;;@Override public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Autogenerated key not supported"). }
false;public;2;5;;@Override public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Autogenerated key not supported"). }
false;public;0;5;;@Override public Clob createClob() throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Clob not supported yet"). }
false;public;0;5;;@Override public Blob createBlob() throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Blob not supported yet"). }
false;public;0;5;;@Override public NClob createNClob() throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("NClob not supported yet"). }
false;public;0;5;;@Override public SQLXML createSQLXML() throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("SQLXML not supported yet"). }
false;public;1;7;;@Override public boolean isValid(int timeout) throws SQLException {     if (timeout < 0) {         throw new SQLException("Negative timeout").     }     return !isClosed() && client.ping(TimeUnit.SECONDS.toMillis(timeout)). }
false;private;0;5;;private void checkOpenClientInfo() throws SQLClientInfoException {     if (isClosed()) {         throw new SQLClientInfoException("Connection closed", null).     } }
false;public;2;5;;@Override public void setClientInfo(String name, String value) throws SQLClientInfoException {     checkOpenClientInfo().     throw new SQLClientInfoException("Unsupported operation", null). }
false;public;1;5;;@Override public void setClientInfo(Properties properties) throws SQLClientInfoException {     checkOpenClientInfo().     throw new SQLClientInfoException("Unsupported operation", null). }
false;public;1;6;;@Override public String getClientInfo(String name) throws SQLException {     checkOpenClientInfo().     // we don't support client info - the docs indicate we should return null if properties are not supported     return null. }
false;public;0;6;;@Override public Properties getClientInfo() throws SQLException {     checkOpenClientInfo().     // similar to getClientInfo - return an empty object instead of an exception     return new Properties(). }
false;public;2;5;;@Override public Array createArrayOf(String typeName, Object[] elements) throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Array not supported yet"). }
false;public;2;5;;@Override public Struct createStruct(String typeName, Object[] attributes) throws SQLException {     checkOpen().     throw new SQLFeatureNotSupportedException("Struct not supported yet"). }
false;public;1;5;;@Override public void setSchema(String schema) throws SQLException {     checkOpen().     this.schema = schema. }
false;public;0;5;;@Override public String getSchema() throws SQLException {     checkOpen().     return schema. }
false;public;1;4;;@Override public void abort(Executor executor) throws SQLException {     throw new SQLFeatureNotSupportedException(). }
false;public;2;4;;@Override public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {     throw new SQLFeatureNotSupportedException(). }
false;public;0;4;;@Override public int getNetworkTimeout() throws SQLException {     throw new SQLFeatureNotSupportedException(). }
false;private;2;8;;private void checkResultSet(int resultSetType, int resultSetConcurrency) throws SQLException {     if (ResultSet.TYPE_FORWARD_ONLY != resultSetType) {         throw new SQLFeatureNotSupportedException("ResultSet type can only be TYPE_FORWARD_ONLY").     }     if (ResultSet.CONCUR_READ_ONLY != resultSetConcurrency) {         throw new SQLFeatureNotSupportedException("ResultSet concurrency can only be CONCUR_READ_ONLY").     } }
false;private;1;5;;private void checkHoldability(int resultSetHoldability) throws SQLException {     if (ResultSet.HOLD_CURSORS_OVER_COMMIT != resultSetHoldability) {         throw new SQLFeatureNotSupportedException("Holdability can only be HOLD_CURSORS_OVER_COMMIT").     } }
false;;0;3;;String getURL() {     return url. }
false;;0;3;;String getUserName() {     return userName. }
true;;0;3;// once retrieved ;// There's no checkOpen on these methods since they are used by // DatabaseMetadata that can work on a closed connection as well // in fact, this information is cached by the underlying client // once retrieved int esInfoMajorVersion() throws SQLException {     return client.serverInfo().majorVersion. }
false;;0;3;;int esInfoMinorVersion() throws SQLException {     return client.serverInfo().minorVersion. }
