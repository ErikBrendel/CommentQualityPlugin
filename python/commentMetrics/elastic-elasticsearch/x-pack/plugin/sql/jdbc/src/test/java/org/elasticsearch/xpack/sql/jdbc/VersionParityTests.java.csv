commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;public void testExceptionThrownOnIncompatibleVersions() throws IOException, SQLException {     Version version = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, VersionUtils.getPreviousVersion(Version.CURRENT)).     prepareRequest(version).     String url = JdbcConfiguration.URL_PREFIX + webServer().getHostName() + ":" + webServer().getPort().     SQLException ex = expectThrows(SQLException.class, () -> new JdbcHttpClient(JdbcConfiguration.create(url, null, 0))).     assertEquals("This version of the JDBC driver is only compatible with Elasticsearch version " + org.elasticsearch.xpack.sql.client.Version.CURRENT.toString() + ", attempting to connect to a server version " + version.toString(), ex.getMessage()). }
false;public;0;10;;public void testNoExceptionThrownForCompatibleVersions() throws IOException {     prepareRequest(null).     String url = JdbcConfiguration.URL_PREFIX + webServerAddress().     try {         new JdbcHttpClient(JdbcConfiguration.create(url, null, 0)).     } catch (SQLException sqle) {         fail("JDBC driver version and Elasticsearch server version should be compatible. Error: " + sqle).     } }
false;;1;5;;void prepareRequest(Version version) throws IOException {     MainResponse response = version == null ? createCurrentVersionMainResponse() : createMainResponse(version).     webServer().enqueue(new MockResponse().setResponseCode(200).addHeader("Content-Type", "application/json").setBody(XContentHelper.toXContent(response, XContentType.JSON, false).utf8ToString())). }
