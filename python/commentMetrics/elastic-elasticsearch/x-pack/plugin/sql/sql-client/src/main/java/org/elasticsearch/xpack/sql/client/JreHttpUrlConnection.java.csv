commented;modifiers;parameterAmount;loc;comment;code
false;public,static;4;14;;public static <R> R http(String path, String query, ConnectionConfiguration cfg, Function<JreHttpUrlConnection, R> handler) {     // update path if needed     final URI uriPath = cfg.baseUri().resolve(path).     // update query if needed     final String uriQuery = query == null ? uriPath.getQuery() : query.     final URL url.     try {         url = new URI(uriPath.getScheme(), null, uriPath.getHost(), uriPath.getPort(), uriPath.getPath(), uriQuery, uriPath.getFragment()).toURL().     } catch (URISyntaxException | MalformedURLException ex) {         throw new ClientException("Cannot build url using base: [" + uriPath + "] query: [" + query + "] path: [" + path + "]", ex).     }     try (JreHttpUrlConnection con = new JreHttpUrlConnection(url, cfg)) {         return handler.apply(con).     } }
false;private;1;20;;private void setupConnection(ConnectionConfiguration cfg) {     // setup basic stuff first     // timeouts     con.setConnectTimeout((int) cfg.connectTimeout()).     con.setReadTimeout((int) cfg.networkTimeout()).     // disable content caching     con.setAllowUserInteraction(false).     con.setUseCaches(false).     // HTTP params     // HttpURL adds this header by default, HttpS does not     // adding it here to be consistent     con.setRequestProperty("Accept-Charset", "UTF-8").     // con.setRequestProperty("Accept-Encoding", GZIP).     setupSSL(cfg).     setupBasicAuth(cfg). }
false;private;1;10;;private void setupSSL(ConnectionConfiguration cfg) {     if (cfg.sslConfig().isEnabled()) {         HttpsURLConnection https = (HttpsURLConnection) con.         SSLSocketFactory factory = cfg.sslConfig().sslSocketFactory().         AccessController.doPrivileged((PrivilegedAction<Void>) () -> {             https.setSSLSocketFactory(factory).             return null.         }).     } }
false;private;1;7;;private void setupBasicAuth(ConnectionConfiguration cfg) {     if (StringUtils.hasText(cfg.authUser())) {         String basicValue = cfg.authUser() + ":" + cfg.authPass().         String encoded = StringUtils.asUTFString(Base64.getEncoder().encode(StringUtils.toUTF(basicValue))).         con.setRequestProperty("Authorization", "Basic " + encoded).     } }
false;public;0;9;;public boolean head() throws ClientException {     try {         con.setRequestMethod("HEAD").         int responseCode = con.getResponseCode().         return responseCode == HttpURLConnection.HTTP_OK.     } catch (IOException ex) {         throw new ClientException("Cannot HEAD address " + url + " (" + ex.getMessage() + ")", ex).     } }
false;public;3;28;;public <R> ResponseOrException<R> request(CheckedConsumer<OutputStream, IOException> doc, CheckedBiFunction<InputStream, Function<String, String>, R, IOException> parser, String requestMethod) throws ClientException {     try {         con.setRequestMethod(requestMethod).         con.setDoOutput(true).         con.setRequestProperty("Content-Type", "application/json").         con.setRequestProperty("Accept", "application/json").         if (doc != null) {             try (OutputStream out = con.getOutputStream()) {                 doc.accept(out).             }         }         if (shouldParseBody(con.getResponseCode())) {             try (InputStream stream = getStream(con, con.getInputStream())) {                 return new ResponseOrException<>(parser.apply(new BufferedInputStream(stream), con::getHeaderField)).             }         }         return parserError().     } catch (IOException ex) {         throw new ClientException("Cannot POST address " + url + " (" + ex.getMessage() + ")", ex).     } }
false;private;1;3;;private boolean shouldParseBody(int responseCode) {     return responseCode == 200 || responseCode == 201 || responseCode == 202. }
false;private;0;30;;private <R> ResponseOrException<R> parserError() throws IOException {     RemoteFailure failure.     try (InputStream stream = getStream(con, con.getErrorStream())) {         failure = RemoteFailure.parseFromResponse(stream).     }     if (con.getResponseCode() >= 500) {         return new ResponseOrException<>(new SQLException("Server encountered an error [" + failure.reason() + "]. [" + failure.remoteTrace() + "]", SQL_STATE_BAD_SERVER)).     }     SqlExceptionType type = SqlExceptionType.fromRemoteFailureType(failure.type()).     if (type == null) {         // by checking the error message the server is sending back         if (con.getResponseCode() >= HttpURLConnection.HTTP_BAD_REQUEST && failure.reason().contains(SQL_NOT_AVAILABLE_ERROR_MESSAGE)) {             return new ResponseOrException<>(new SQLException("X-Pack/SQL do not seem to be available" + " on the Elasticsearch node using the access path '" + con.getURL().getHost() + (con.getURL().getPort() > 0 ? ":" + con.getURL().getPort() : "") + "'." + " Please verify X-Pack is installed and SQL enabled. Alternatively, check if any proxy is interfering" + " the communication to Elasticsearch", SQL_STATE_BAD_SERVER)).         }         return new ResponseOrException<>(new SQLException("Server sent bad type [" + failure.type() + "]. Original type was [" + failure.reason() + "]. [" + failure.remoteTrace() + "]", SQL_STATE_BAD_SERVER)).     }     return new ResponseOrException<>(type.asException(failure.reason())). }
false;public;0;7;;public R getResponseOrThrowException() throws SQLException {     if (exception != null) {         throw exception.     }     assert response != null.     return response. }
false;private,static;2;6;;private static InputStream getStream(HttpURLConnection con, InputStream stream) throws IOException {     if (GZIP.equals(con.getContentEncoding())) {         return new GZIPInputStream(stream).     }     return stream. }
false;public;0;10;;public void connect() {     if (closed) {         throw new ClientException("Connection cannot be reused").     }     try {         con.connect().     } catch (IOException ex) {         throw new ClientException("Cannot open connection to " + url + " (" + ex.getMessage() + ")", ex).     } }
false;public;0;9;;@Override public void close() {     if (!closed) {         closed = true.         // consume streams         consumeStreams().     } }
false;public;0;7;;public void disconnect() {     try {         connect().     } finally {         con.disconnect().     } }
true;private;0;15;// http://docs.oracle.com/javase/7/docs/technotes/guides/net/http-keepalive.html ;// http://docs.oracle.com/javase/7/docs/technotes/guides/net/http-keepalive.html private void consumeStreams() {     try (InputStream in = con.getInputStream()) {         while (in != null && in.read() > -1) {         }     } catch (IOException ex) {     // ignore     } finally {         try (InputStream ein = con.getErrorStream()) {             while (ein != null && ein.read() > -1) {             }         } catch (IOException ex) {         // keep on ignoring         }     } }
false;public,static;1;19;;public static SqlExceptionType fromRemoteFailureType(String type) {     switch(type) {         case "analysis_exception":         case "resource_not_found_exception":         case "verification_exception":             return DATA.         case "planning_exception":         case "mapping_exception":             return NOT_SUPPORTED.         case "parsing_exception":             return SYNTAX.         case "security_exception":             return SECURITY.         case "timeout_exception":             return TIMEOUT.         default:             return null.     } }
false;;1;6;;SQLException asException(String message) {     if (message == null) {         throw new IllegalArgumentException("[message] cannot be null").     }     return toException.apply(message). }
