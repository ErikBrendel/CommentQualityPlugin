commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public boolean ping(long timeoutInMs) throws SQLException {     return head("/", timeoutInMs). }
false;public;0;3;;public MainResponse serverInfo() throws SQLException {     return get("/", MainResponse::fromXContent). }
false;public;2;8;;public SqlQueryResponse queryInit(String query, int fetchSize) throws SQLException {     // TODO allow customizing the time zone - this is what session set/reset/get should be about     // method called only from CLI     SqlQueryRequest sqlRequest = new SqlQueryRequest(query, Collections.emptyList(), null, ZoneId.of("Z"), fetchSize, TimeValue.timeValueMillis(cfg.queryTimeout()), TimeValue.timeValueMillis(cfg.pageTimeout()), false, new RequestInfo(Mode.CLI)).     return query(sqlRequest). }
false;public;1;3;;public SqlQueryResponse query(SqlQueryRequest sqlRequest) throws SQLException {     return post(Protocol.SQL_QUERY_REST_ENDPOINT, sqlRequest, SqlQueryResponse::fromXContent). }
false;public;1;6;;public SqlQueryResponse nextPage(String cursor) throws SQLException {     // method called only from CLI     SqlQueryRequest sqlRequest = new SqlQueryRequest(cursor, TimeValue.timeValueMillis(cfg.queryTimeout()), TimeValue.timeValueMillis(cfg.pageTimeout()), new RequestInfo(Mode.CLI)).     return post(Protocol.SQL_QUERY_REST_ENDPOINT, sqlRequest, SqlQueryResponse::fromXContent). }
false;public;2;6;;public boolean queryClose(String cursor, Mode mode) throws SQLException {     SqlClearCursorResponse response = post(Protocol.CLEAR_CURSOR_REST_ENDPOINT, new SqlClearCursorRequest(cursor, new RequestInfo(mode)), SqlClearCursorResponse::fromXContent).     return response.isSucceeded(). }
false;private;3;16;;private <Request extends AbstractSqlRequest, Response> Response post(String path, Request request, CheckedFunction<XContentParser, Response, IOException> responseParser) throws SQLException {     byte[] requestBytes = toXContent(request).     String query = "error_trace".     Tuple<XContentType, byte[]> response = AccessController.doPrivileged((PrivilegedAction<ResponseOrException<Tuple<XContentType, byte[]>>>) () -> JreHttpUrlConnection.http(path, query, cfg, con -> con.request((out) -> out.write(requestBytes), this::readFrom, "POST"))).getResponseOrThrowException().     return fromXContent(response.v1(), response.v2(), responseParser). }
false;private;2;11;;private boolean head(String path, long timeoutInMs) throws SQLException {     ConnectionConfiguration pingCfg = new ConnectionConfiguration(cfg.baseUri(), cfg.connectionString(), cfg.validateProperties(), cfg.connectTimeout(), timeoutInMs, cfg.queryTimeout(), cfg.pageTimeout(), cfg.pageSize(), cfg.authUser(), cfg.authPass(), cfg.sslConfig(), cfg.proxyConfig()).     try {         return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> JreHttpUrlConnection.http(path, "error_trace", pingCfg, JreHttpUrlConnection::head)).     } catch (ClientException ex) {         throw new SQLException("Cannot ping server", ex).     } }
false;private;2;13;;private <Response> Response get(String path, CheckedFunction<XContentParser, Response, IOException> responseParser) throws SQLException {     Tuple<XContentType, byte[]> response = AccessController.doPrivileged((PrivilegedAction<ResponseOrException<Tuple<XContentType, byte[]>>>) () -> JreHttpUrlConnection.http(path, "error_trace", cfg, con -> con.request(null, this::readFrom, "GET"))).getResponseOrThrowException().     return fromXContent(response.v1(), response.v2(), responseParser). }
false;private,static;1;16;;private static <Request extends ToXContent> byte[] toXContent(Request xContent) {     try (ByteArrayOutputStream buffer = new ByteArrayOutputStream()) {         try (XContentBuilder xContentBuilder = new XContentBuilder(REQUEST_BODY_CONTENT_TYPE.xContent(), buffer)) {             if (xContent.isFragment()) {                 xContentBuilder.startObject().             }             xContent.toXContent(xContentBuilder, ToXContent.EMPTY_PARAMS).             if (xContent.isFragment()) {                 xContentBuilder.endObject().             }         }         return buffer.toByteArray().     } catch (IOException ex) {         throw new ClientException("Cannot serialize request", ex).     } }
false;private;2;15;;private Tuple<XContentType, byte[]> readFrom(InputStream inputStream, Function<String, String> headers) {     String contentType = headers.apply("Content-Type").     XContentType xContentType = XContentType.fromMediaTypeOrFormat(contentType).     if (xContentType == null) {         throw new IllegalStateException("Unsupported Content-Type: " + contentType).     }     ByteArrayOutputStream out = new ByteArrayOutputStream().     try {         Streams.copy(inputStream, out).     } catch (IOException ex) {         throw new ClientException("Cannot deserialize response", ex).     }     return new Tuple<>(xContentType, out.toByteArray()). }
false;private;3;10;;private <Response> Response fromXContent(XContentType xContentType, byte[] bytesReference, CheckedFunction<XContentParser, Response, IOException> responseParser) {     try (InputStream stream = new ByteArrayInputStream(bytesReference).         XContentParser parser = xContentType.xContent().createParser(registry, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, stream)) {         return responseParser.apply(parser).     } catch (IOException ex) {         throw new ClientException("Cannot parse response", ex).     } }
