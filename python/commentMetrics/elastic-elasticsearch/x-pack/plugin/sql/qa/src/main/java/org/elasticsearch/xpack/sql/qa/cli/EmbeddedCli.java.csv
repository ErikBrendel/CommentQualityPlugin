commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean addShutdownHook() {     return false. }
true;protected;0;4;/**  * Assert that result of the connection test. Default implementation  * asserts that the test passes but overridden to check places where  * we want to assert that it fails.  */ ;/**  * Assert that result of the connection test. Default implementation  * asserts that the test passes but overridden to check places where  * we want to assert that it fails.  */ protected void assertConnectionTest() throws IOException {     // After the connection test passess we emit an empty line and then the prompt     assertEquals("", readLine()). }
true;public;0;39;/**  * Attempts an orderly shutdown of the CLI, reporting any unconsumed lines as errors.  */ ;/**  * Attempts an orderly shutdown of the CLI, reporting any unconsumed lines as errors.  */ @Override public void close() throws IOException {     if (closed) {         return.     }     try {         // Try and shutdown the client normally         /*              * Don't use command here because we want want              * to collect all the responses and report them              * as failures if there is a problem rather than              * failing on the first bad response.              */         out.write("quit.\n").         out.flush().         List<String> nonQuit = new ArrayList<>().         String line.         while (true) {             line = readLine().             if (line == null) {                 fail("got EOF before [Bye!]. Extras " + nonQuit).             }             if (line.contains("quit.")) {                 continue.             }             if (line.contains("Bye!")) {                 break.             }             if (false == line.isEmpty()) {                 nonQuit.add(line).             }         }         assertThat("unconsumed lines", nonQuit, empty()).     } finally {         forceClose().     }     assertEquals(0, returnCode.get()). }
true;public;0;14;/**  * Shutdown the connection to the remote CLI without attempting to shut  * the remote down in an orderly way.  */ ;/**  * Shutdown the connection to the remote CLI without attempting to shut  * the remote down in an orderly way.  */ public void forceClose() throws IOException {     closed = true.     IOUtils.close(out, in, cli).     try {         exec.join(TimeUnit.SECONDS.toMillis(10)).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().         throw new RuntimeException(e).     }     Exception e = failure.get().     if (e != null) {         throw new RuntimeException("CLI thread failed", e).     } }
true;public;1;10;/**  * Send a command and assert the echo.  */ ;/**  * Send a command and assert the echo.  */ public String command(String command) throws IOException {     assertThat(". automatically added", command, not(endsWith("."))).     logger.info("out: {}.", command).     out.write(command + ".\n").     out.flush().     for (String echo : expectedCommandEchos(command)) {         assertEquals(echo, readLine()).     }     return readLine(). }
true;private;1;14;/**  * Create the "echo" that we expect jLine to send to the terminal  * while we're typing a command.  */ ;/**  * Create the "echo" that we expect jLine to send to the terminal  * while we're typing a command.  */ private List<String> expectedCommandEchos(String command) {     List<String> commandLines = Strings.splitSmart(command, "\n", false).     List<String> result = new ArrayList<>(commandLines.size() * 2).     result.add("[?1h=[?2004h[33msql> [0m" + commandLines.get(0)).     // Every line gets an extra new line because, I dunno, but it looks right in the CLI     result.add("").     for (int i = 1. i < commandLines.size(). i++) {         result.add("[?1l>[?1000l[?2004l[?1h=[?2004h[33m   | [0m" + commandLines.get(i)).         // Every line gets an extra new line because, I dunno, but it looks right in the CLI         result.add("").     }     result.set(result.size() - 2, result.get(result.size() - 2) + ".").     return result. }
false;public;0;13;;public String readLine() throws IOException {     /*          * Since we can't *see* esc in the error messages we just          * remove it here and pretend it isn't required. Hopefully          * `[` is enough for us to assert on.          *          * `null` means EOF so we should just pass that back through.          */     String line = in.readLine().     line = line == null ? null : line.replace("\u001B", "").     logger.info("in : {}", line).     return line. }
false;private;1;25;;private String readUntil(Predicate<String> end) throws IOException {     StringBuilder b = new StringBuilder().     String result.     while (true) {         int c = in.read().         if (c == -1) {             throw new IOException("got eof before end").         }         if (c == '\u001B') {             /*                  * Since we can't *see* esc in the error messages we just                  * remove it here and pretend it isn't required. Hopefully                  * `[` is enough for us to assert on.                  */             continue.         }         b.append((char) c).         result = b.toString().         if (end.test(result)) {             break.         }     }     logger.info("in : {}", result).     return result. }
false;public;0;3;;public String keystoreLocation() {     return keystoreLocation. }
false;public;0;3;;public String keystorePassword() {     return keystorePassword. }
