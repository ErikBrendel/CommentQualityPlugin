commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@After public void checkSearchContent() throws Exception {     // Some context might linger due to fire and forget nature of scroll cleanup     assertNoSearchContexts(). }
true;public,static;0;8;/**  * Read an address for Elasticsearch suitable for the JDBC driver from the system properties.  */ ;/**  * Read an address for Elasticsearch suitable for the JDBC driver from the system properties.  */ public static String elasticsearchAddress() {     String cluster = System.getProperty("tests.rest.cluster").     // JDBC only supports a single node at a time so we just give it one.     return cluster.split(",")[0]. /* This doesn't include "jdbc:es://" because we want the example in          * esJdbc to be obvious and because we want to use getProtocol to add          * https if we are running against https. */ }
false;public;0;3;;public Connection esJdbc() throws SQLException {     return randomBoolean() ? useDriverManager() : useDataSource(). }
false;protected;0;11;;protected Connection useDriverManager() throws SQLException {     String elasticsearchAddress = getProtocol() + "://" + elasticsearchAddress().     // tag::connect-dm     // <1>     String address = "jdbc:es://" + elasticsearchAddress.     // <2>     Properties connectionProperties = connectionProperties().     Connection connection = DriverManager.getConnection(address, connectionProperties).     // end::connect-dm     assertNotNull("The timezone should be specified", connectionProperties.getProperty("timezone")).     return connection. }
false;protected;0;13;;protected Connection useDataSource() throws SQLException {     String elasticsearchAddress = getProtocol() + "://" + elasticsearchAddress().     // tag::connect-ds     EsDataSource dataSource = new EsDataSource().     // <1>     String address = "jdbc:es://" + elasticsearchAddress.     dataSource.setUrl(address).     // <2>     Properties connectionProperties = connectionProperties().     dataSource.setProperties(connectionProperties).     Connection connection = dataSource.getConnection().     // end::connect-ds     assertNotNull("The timezone should be specified", connectionProperties.getProperty("timezone")).     return connection. }
false;public,static;2;3;;public static void index(String index, CheckedConsumer<XContentBuilder, IOException> body) throws IOException {     index(index, "1", body). }
false;public,static;3;9;;public static void index(String index, String documentId, CheckedConsumer<XContentBuilder, IOException> body) throws IOException {     Request request = new Request("PUT", "/" + index + "/_doc/" + documentId).     request.addParameter("refresh", "true").     XContentBuilder builder = JsonXContent.contentBuilder().startObject().     body.accept(builder).     builder.endObject().     request.setJsonEntity(Strings.toString(builder)).     client().performRequest(request). }
false;protected;0;8;;protected String clusterName() {     try {         String response = EntityUtils.toString(client().performRequest(new Request("GET", "/")).getEntity()).         return XContentHelper.convertToMap(JsonXContent.jsonXContent, response, false).get("cluster_name").toString().     } catch (IOException e) {         throw new RuntimeException(e).     } }
true;protected;0;5;/**  * The properties used to build the connection.  */ ;/**  * The properties used to build the connection.  */ protected Properties connectionProperties() {     Properties connectionProperties = new Properties().     connectionProperties.put("timezone", randomKnownTimeZone()).     return connectionProperties. }
false;public,static;0;11;;public static String randomKnownTimeZone() {     // We use system default timezone for the connection that is selected randomly by TestRuleSetupAndRestoreClassEnv     // from all available JDK timezones. While Joda and JDK are generally in sync, some timezones might not be known     // to the current version of Joda and in this case the test might fail. To avoid that, we specify a timezone     // known for both Joda and JDK     Set<String> timeZones = new HashSet<>(JODA_TIMEZONE_IDS).     timeZones.retainAll(JAVA_TIMEZONE_IDS).     List<String> ids = new ArrayList<>(timeZones).     Collections.sort(ids).     return randomFrom(ids). }
