commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setupTestDataIfNeeded() throws Exception {     if (client().performRequest(new Request("HEAD", "/" + indexName())).getStatusLine().getStatusCode() == 404) {         loadDataset(client()).     } }
false;protected;0;3;;protected String indexName() {     return "test_emp". }
false;protected;1;3;;protected void loadDataset(RestClient client) throws Exception {     DataLoader.loadEmpDatasetIntoEs(client). }
false;protected;0;4;;@Override protected boolean preserveIndicesUponCompletion() {     return true. }
false;public,static;0;11;;@AfterClass public static void wipeTestData() throws IOException {     try {         adminClient().performRequest(new Request("DELETE", "/*")).     } catch (ResponseException e) {         // 404 here just means we had no indexes         if (e.getResponse().getStatusLine().getStatusCode() != 404) {             throw e.         }     } }
false;public,final;0;8;;public final void test() throws Throwable {     try {         assumeFalse("Test marked as Ignored", testName.endsWith("-Ignore")).         doTest().     } catch (AssertionError ae) {         throw reworkException(ae).     } }
true;protected,abstract;0;1;/**  * Implementations should pay attention on using  * {@link #executeJdbcQuery(Connection, String)} (typically for  * ES connections) and {@link #assertResults(ResultSet, ResultSet)}  * which takes into account logging/debugging results (through  * {@link #logEsResultSet()}.  */ ;/**  * Implementations should pay attention on using  * {@link #executeJdbcQuery(Connection, String)} (typically for  * ES connections) and {@link #assertResults(ResultSet, ResultSet)}  * which takes into account logging/debugging results (through  * {@link #logEsResultSet()}.  */ protected abstract void doTest() throws Throwable.
false;protected;2;5;;protected ResultSet executeJdbcQuery(Connection con, String query) throws SQLException {     Statement statement = con.createStatement().     statement.setFetchSize(fetchSize()).     return statement.executeQuery(query). }
false;protected;0;3;;protected int fetchSize() {     return between(1, 500). }
true;protected;0;6;// TODO: use UTC for now until deciding on a strategy for handling date extraction ;// TODO: use UTC for now until deciding on a strategy for handling date extraction @Override protected Properties connectionProperties() {     Properties connectionProperties = new Properties().     connectionProperties.setProperty("timezone", "UTC").     return connectionProperties. }
false;protected;0;3;;protected boolean logEsResultSet() {     return false. }
false;protected;2;4;;protected void assertResults(ResultSet expected, ResultSet elastic) throws SQLException {     Logger log = logEsResultSet() ? logger : null.     JdbcAssert.assertResultSets(expected, elastic, log). }
false;private;1;9;;private Throwable reworkException(Throwable th) {     StackTraceElement[] stackTrace = th.getStackTrace().     StackTraceElement[] redone = new StackTraceElement[stackTrace.length + 1].     System.arraycopy(stackTrace, 0, redone, 1, stackTrace.length).     redone[0] = new StackTraceElement(getClass().getName(), groupName + ".test" + testName, fileName, lineNumber).     th.setStackTrace(redone).     return th. }
true;protected,static;2;46;// returns source file, groupName, testName, its line location, and the custom object (based on each test parser) ;//  // spec reader //  // returns source file, groupName, testName, its line location, and the custom object (based on each test parser) protected static List<Object[]> readScriptSpec(String url, Parser parser) throws Exception {     URL source = SpecBaseIntegrationTestCase.class.getResource(url).     Objects.requireNonNull(source, "Cannot find resource " + url).     String fileName = source.getFile().substring(source.getFile().lastIndexOf("/") + 1).     String groupName = fileName.substring(fileName.lastIndexOf('/') + 1, fileName.lastIndexOf(".")).     Map<String, Integer> testNames = new LinkedHashMap<>().     List<Object[]> testCases = new ArrayList<>().     String testName = null.     try (BufferedReader reader = new BufferedReader(new InputStreamReader(readFromJarUrl(source), StandardCharsets.UTF_8))) {         String line.         int lineNumber = 1.         while ((line = reader.readLine()) != null) {             line = line.trim().             // ignore comments             if (!line.isEmpty() && !line.startsWith("//")) {                 // parse test name                 if (testName == null) {                     if (testNames.keySet().contains(line)) {                         throw new IllegalStateException("Duplicate test name '" + line + "' at line " + lineNumber + " (previously seen at line " + testNames.get(line) + ")").                     } else {                         testName = Strings.capitalize(line).                         testNames.put(testName, Integer.valueOf(lineNumber)).                     }                 } else {                     Object result = parser.parse(line).                     // only if the parser is ready, add the object - otherwise keep on serving it lines                     if (result != null) {                         testCases.add(new Object[] { fileName, groupName, testName, Integer.valueOf(lineNumber), result }).                         testName = null.                     }                 }             }             lineNumber++.         }         if (testName != null) {             throw new IllegalStateException("Read a test without a body at the end of [" + fileName + "].").         }     }     assertNull("Cannot find spec for test " + testName, testName).     return testCases. }
false;;1;1;;Object parse(String line).
false;public,static;1;4;;@SuppressForbidden(reason = "test reads from jar") public static InputStream readFromJarUrl(URL source) throws IOException {     return source.openStream(). }
