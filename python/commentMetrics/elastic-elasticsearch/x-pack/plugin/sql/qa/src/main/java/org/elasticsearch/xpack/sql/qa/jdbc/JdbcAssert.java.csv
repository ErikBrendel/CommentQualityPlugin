commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;public static void assertResultSets(ResultSet expected, ResultSet actual) throws SQLException {     assertResultSets(expected, actual, null). }
false;public,static;3;3;;public static void assertResultSets(ResultSet expected, ResultSet actual, Logger logger) throws SQLException {     assertResultSets(expected, actual, logger, false). }
true;public,static;4;3;/**  * Assert the given result sets, potentially in a lenient way.  * When lenientDataType is specified, the type comparison of a column is widden to reach a common, compatible ground.  * This means promoting integer types to long and floating types to double and comparing their values.  * For example in a non-lenient, strict case a comparison between an int and a tinyint would fail, with lenientDataType it will succeed  * as long as the actual value is the same.  */ ;/**  * Assert the given result sets, potentially in a lenient way.  * When lenientDataType is specified, the type comparison of a column is widden to reach a common, compatible ground.  * This means promoting integer types to long and floating types to double and comparing their values.  * For example in a non-lenient, strict case a comparison between an int and a tinyint would fail, with lenientDataType it will succeed  * as long as the actual value is the same.  */ public static void assertResultSets(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType) throws SQLException {     assertResultSets(expected, actual, logger, lenientDataType, true). }
true;public,static;5;7;/**  * Assert the given result sets, potentially in a lenient way.  * When lenientDataType is specified, the type comparison of a column is widden to reach a common, compatible ground.  * This means promoting integer types to long and floating types to double and comparing their values.  * For example in a non-lenient, strict case a comparison between an int and a tinyint would fail, with lenientDataType it will succeed  * as long as the actual value is the same.  * Also, has the option of treating the numeric results for floating point numbers in a leninent way, if chosen to. Usually,  * we would want lenient treatment for floating point numbers in sql-spec tests where the comparison is being made with H2.  */ ;/**  * Assert the given result sets, potentially in a lenient way.  * When lenientDataType is specified, the type comparison of a column is widden to reach a common, compatible ground.  * This means promoting integer types to long and floating types to double and comparing their values.  * For example in a non-lenient, strict case a comparison between an int and a tinyint would fail, with lenientDataType it will succeed  * as long as the actual value is the same.  * Also, has the option of treating the numeric results for floating point numbers in a leninent way, if chosen to. Usually,  * we would want lenient treatment for floating point numbers in sql-spec tests where the comparison is being made with H2.  */ public static void assertResultSets(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType, boolean lenientFloatingNumbers) throws SQLException {     try (ResultSet ex = expected.         ResultSet ac = actual) {         assertResultSetMetadata(ex, ac, logger, lenientDataType).         assertResultSetData(ex, ac, logger, lenientDataType, lenientFloatingNumbers).     } }
false;public,static;3;3;;public static void assertResultSetMetadata(ResultSet expected, ResultSet actual, Logger logger) throws SQLException {     assertResultSetMetadata(expected, actual, logger, false). }
true;public,static;4;71;// metadata doesn't consume a ResultSet thus it shouldn't close it ;// metadata doesn't consume a ResultSet thus it shouldn't close it public static void assertResultSetMetadata(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType) throws SQLException {     ResultSetMetaData expectedMeta = expected.getMetaData().     ResultSetMetaData actualMeta = actual.getMetaData().     if (logger != null) {         JdbcTestUtils.logResultSetMetadata(actual, logger).     }     if (expectedMeta.getColumnCount() != actualMeta.getColumnCount()) {         List<String> expectedCols = new ArrayList<>().         for (int i = 1. i <= expectedMeta.getColumnCount(). i++) {             expectedCols.add(expectedMeta.getColumnName(i)).         }         List<String> actualCols = new ArrayList<>().         for (int i = 1. i <= actualMeta.getColumnCount(). i++) {             actualCols.add(actualMeta.getColumnName(i)).         }         assertEquals(format(Locale.ROOT, "Different number of columns returned (expected %d but was %d).", expectedMeta.getColumnCount(), actualMeta.getColumnCount()), expectedCols.toString(), actualCols.toString()).     }     for (int column = 1. column <= expectedMeta.getColumnCount(). column++) {         String expectedName = expectedMeta.getColumnName(column).         String actualName = actualMeta.getColumnName(column).         if (!expectedName.equals(actualName)) {             // to help debugging, indicate the previous column (which also happened to match and thus was correct)             String expectedSet = expectedName.             String actualSet = actualName.             if (column > 1) {                 expectedSet = expectedMeta.getColumnName(column - 1) + "," + expectedName.                 actualSet = actualMeta.getColumnName(column - 1) + "," + actualName.             }             assertEquals("Different column name [" + column + "]", expectedSet, actualSet).         }         // use the type not the name (timestamp with timezone returns spaces for example)         int expectedType = typeOf(expectedMeta.getColumnType(column), lenientDataType).         int actualType = typeOf(actualMeta.getColumnType(column), lenientDataType).         // since H2 cannot use a fixed timezone, the data is stored in UTC (and thus with timezone)         if (expectedType == Types.TIMESTAMP_WITH_TIMEZONE) {             expectedType = Types.TIMESTAMP.         }         // since csv doesn't support real, we use float instead.....         if (expectedType == Types.FLOAT && expected instanceof CsvResultSet) {             expectedType = Types.REAL.         }         // handle intervals         if ((expectedType == Types.VARCHAR && expected instanceof CsvResultSet) && nameOf(actualType).startsWith("INTERVAL_")) {             expectedType = actualType.         }         // csv doesn't support NULL type so skip type checking         if (actualType == Types.NULL && expected instanceof CsvResultSet) {             expectedType = Types.NULL.         }         // when lenient is used, an int is equivalent to a short, etc...         assertEquals("Different column type for column [" + expectedName + "] (" + nameOf(expectedType) + " != " + nameOf(actualType) + ")", expectedType, actualType).     } }
false;private,static;1;3;;private static String nameOf(int sqlType) {     return SQL_TO_TYPE.get(sqlType).getName(). }
true;public,static;3;3;// The ResultSet is consumed and thus it should be closed ;// The ResultSet is consumed and thus it should be closed public static void assertResultSetData(ResultSet expected, ResultSet actual, Logger logger) throws SQLException {     assertResultSetData(expected, actual, logger, false). }
false;public,static;4;4;;public static void assertResultSetData(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType) throws SQLException {     assertResultSetData(expected, actual, logger, lenientDataType, true). }
false;public,static;5;6;;public static void assertResultSetData(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType, boolean lenientFloatingNumbers) throws SQLException {     try (ResultSet ex = expected.         ResultSet ac = actual) {         doAssertResultSetData(ex, ac, logger, lenientDataType, lenientFloatingNumbers).     } }
false;private,static;5;91;;private static void doAssertResultSetData(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType, boolean lenientFloatingNumbers) throws SQLException {     ResultSetMetaData metaData = expected.getMetaData().     int columns = metaData.getColumnCount().     long count = 0.     try {         for (count = 0. expected.next(). count++) {             assertTrue("Expected more data but no more entries found after [" + count + "]", actual.next()).             if (logger != null) {                 logger.info(JdbcTestUtils.resultSetCurrentData(actual)).             }             for (int column = 1. column <= columns. column++) {                 int type = metaData.getColumnType(column).                 Class<?> expectedColumnClass = null.                 try {                     String columnClassName = metaData.getColumnClassName(column).                     // fix for CSV which returns the shortName not fully-qualified name                     if (!columnClassName.contains(".")) {                         switch(columnClassName) {                             case "Date":                                 columnClassName = "java.sql.Date".                                 break.                             case "Timestamp":                                 columnClassName = "java.sql.Timestamp".                                 break.                             case "Int":                                 columnClassName = "java.lang.Integer".                                 break.                             default:                                 columnClassName = "java.lang." + columnClassName.                                 break.                         }                     }                     expectedColumnClass = Class.forName(columnClassName).                 } catch (ClassNotFoundException cnfe) {                     throw new SQLException(cnfe).                 }                 Object expectedObject = expected.getObject(column).                 Object actualObject = lenientDataType ? actual.getObject(column, expectedColumnClass) : actual.getObject(column).                 String msg = format(Locale.ROOT, "Different result for column [%s], entry [%d]", metaData.getColumnName(column), count + 1).                 // handle nulls first                 if (expectedObject == null || actualObject == null) {                     // hack for JDBC CSV nulls                     if (expectedObject != null && "null".equals(expectedObject.toString().toLowerCase(Locale.ROOT))) {                         assertNull(msg, actualObject).                     } else {                         assertEquals(msg, expectedObject, actualObject).                     }                 } else // then timestamp                 if (type == Types.TIMESTAMP || type == Types.TIMESTAMP_WITH_TIMEZONE) {                     assertEquals(msg, expected.getTimestamp(column), actual.getTimestamp(column)).                 } else // and floats/doubles                 if (type == Types.DOUBLE) {                     assertEquals(msg, (double) expectedObject, (double) actualObject, lenientFloatingNumbers ? 1d : 0.0d).                 } else if (type == Types.FLOAT) {                     assertEquals(msg, (float) expectedObject, (float) actualObject, lenientFloatingNumbers ? 1f : 0.0f).                 } else // intervals                 if (type == Types.VARCHAR && actualObject instanceof TemporalAmount) {                     assertEquals(msg, expectedObject, StringUtils.toString(actualObject)).                 } else // finally the actual comparison                 {                     assertEquals(msg, expectedObject, actualObject).                 }             }         }     } catch (AssertionError ae) {         if (logger != null && actual.next()) {             logger.info("^^^ Assertion failure ^^^").             logger.info(JdbcTestUtils.resultSetCurrentData(actual)).         }         throw ae.     }     if (actual.next()) {         fail("Elasticsearch [" + actual + "] still has data after [" + count + "] entries:\n" + JdbcTestUtils.resultSetCurrentData(actual)).     } }
true;private,static;2;13;/**  * Returns the value of the given type either in a lenient fashion (widened) or strict.  */ ;/**  * Returns the value of the given type either in a lenient fashion (widened) or strict.  */ private static int typeOf(int columnType, boolean lenientDataType) {     if (lenientDataType) {         // integer upcast to long         if (columnType == TINYINT || columnType == SMALLINT || columnType == INTEGER || columnType == BIGINT) {             return BIGINT.         }         if (columnType == FLOAT || columnType == REAL || columnType == DOUBLE) {             return REAL.         }     }     return columnType. }
