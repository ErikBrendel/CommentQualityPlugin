commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Settings restClientSettings() {     return RestSqlIT.securitySettings(). }
false;protected;0;4;;@Override protected String getProtocol() {     return RestSqlIT.SSL_ENABLED ? "https" : "http". }
false;private;0;9;;@Before private void setUpUsers() throws IOException {     int usersCount = name.getMethodName().startsWith("testSingle") ? 1 : randomIntBetween(5, 15).     users = new ArrayList<>(usersCount).     users.addAll(randomUnique(() -> randomAlphaOfLengthBetween(1, 15), usersCount)).     for (String user : users) {         createUser(user, MINIMAL_ACCESS_ROLE).     } }
false;private;0;6;;@After private void clearUsers() throws IOException {     for (String user : users) {         deleteUser(user).     } }
false;public;0;12;;public void testSingleRandomUser() throws IOException {     String mode = randomMode().toString().     String randomUserName = users.get(0).     Map<String, Object> expected = new HashMap<>().     expected.put("columns", Arrays.asList(columnInfo(mode, "USER()", "keyword", JDBCType.VARCHAR, 0))).     expected.put("rows", Arrays.asList(Arrays.asList(randomUserName))).     Map<String, Object> actual = runSql(randomUserName, mode, SQL).     assertResponse(expected, actual). }
false;public;0;16;;public void testSingleRandomUserWithWhereEvaluatingTrue() throws IOException {     index("{\"test\":\"doc1\"}", "{\"test\":\"doc2\"}", "{\"test\":\"doc3\"}").     String mode = randomMode().toString().     String randomUserName = users.get(0).     Map<String, Object> expected = new HashMap<>().     expected.put("columns", Arrays.asList(columnInfo(mode, "USER()", "keyword", JDBCType.VARCHAR, 0))).     expected.put("rows", Arrays.asList(Arrays.asList(randomUserName), Arrays.asList(randomUserName), Arrays.asList(randomUserName))).     Map<String, Object> actual = runSql(randomUserName, mode, SQL + " FROM test WHERE USER()='" + randomUserName + "' LIMIT 3").     assertResponse(expected, actual). }
false;public;0;15;;public void testSingleRandomUserWithWhereEvaluatingFalse() throws IOException {     index("{\"test\":\"doc1\"}", "{\"test\":\"doc2\"}", "{\"test\":\"doc3\"}").     String mode = randomMode().toString().     String randomUserName = users.get(0).     Map<String, Object> expected = new HashMap<>().     expected.put("columns", Arrays.asList(columnInfo(mode, "USER()", "keyword", JDBCType.VARCHAR, 0))).     expected.put("rows", Collections.<ArrayList<String>>emptyList()).     String anotherRandomUserName = randomValueOtherThan(randomUserName, () -> randomAlphaOfLengthBetween(1, 15)).     Map<String, Object> actual = runSql(randomUserName, mode, SQL + " FROM test WHERE USER()='" + anotherRandomUserName + "' LIMIT 3").     assertResponse(expected, actual). }
false;public;0;16;;public void testMultipleRandomUsersAccess() throws IOException {     // run 30 queries and pick randomly each time one of the 5-15 users created previously     for (int i = 0. i < 30. i++) {         String mode = randomMode().toString().         String randomlyPickedUsername = randomFrom(users).         Map<String, Object> expected = new HashMap<>().         expected.put("columns", Arrays.asList(columnInfo(mode, "USER()", "keyword", JDBCType.VARCHAR, 0))).         expected.put("rows", Arrays.asList(Arrays.asList(randomlyPickedUsername))).         Map<String, Object> actual = runSql(randomlyPickedUsername, mode, SQL).         // expect the user that ran the query to be the same as the one returned by the `USER()` function         assertResponse(expected, actual).     } }
false;public;0;17;;public void testSingleUserSelectFromIndex() throws IOException {     index("{\"test\":\"doc1\"}", "{\"test\":\"doc2\"}", "{\"test\":\"doc3\"}").     String mode = randomMode().toString().     String randomUserName = users.get(0).     Map<String, Object> expected = new HashMap<>().     expected.put("columns", Arrays.asList(columnInfo(mode, "USER()", "keyword", JDBCType.VARCHAR, 0))).     expected.put("rows", Arrays.asList(Arrays.asList(randomUserName), Arrays.asList(randomUserName), Arrays.asList(randomUserName))).     Map<String, Object> actual = runSql(randomUserName, mode, "SELECT USER() FROM test LIMIT 3").     assertResponse(expected, actual). }
false;private;2;11;;private void createUser(String name, String role) throws IOException {     Request request = new Request("PUT", "/_security/user/" + name).     XContentBuilder user = JsonXContent.contentBuilder().prettyPrint().     user.startObject().     {         user.field("password", "testpass").         user.field("roles", role).     }     user.endObject().     request.setJsonEntity(Strings.toString(user)).     client().performRequest(request). }
false;private;1;4;;private void deleteUser(String name) throws IOException {     Request request = new Request("DELETE", "/_security/user/" + name).     client().performRequest(request). }
false;private;3;3;;private Map<String, Object> runSql(String asUser, String mode, String sql) throws IOException {     return runSql(asUser, new StringEntity("{\"query\": \"" + sql + "\"" + mode(mode) + "}", ContentType.APPLICATION_JSON)). }
false;private;2;10;;private Map<String, Object> runSql(String asUser, HttpEntity entity) throws IOException {     Request request = new Request("POST", SQL_QUERY_REST_ENDPOINT).     if (asUser != null) {         RequestOptions.Builder options = request.getOptions().toBuilder().         options.addHeader("es-security-runas-user", asUser).         request.setOptions(options).     }     request.setEntity(entity).     return toMap(client().performRequest(request)). }
false;private;2;7;;private void assertResponse(Map<String, Object> expected, Map<String, Object> actual) {     if (false == expected.equals(actual)) {         NotEqualMessageBuilder message = new NotEqualMessageBuilder().         message.compareMaps(actual, expected).         fail("Response does not match:\n" + message.toString()).     } }
false;private,static;1;5;;private static Map<String, Object> toMap(Response response) throws IOException {     try (InputStream content = response.getEntity().getContent()) {         return XContentHelper.convertToMap(JsonXContent.jsonXContent, content, false).     } }
false;private;1;11;;private void index(String... docs) throws IOException {     Request request = new Request("POST", "/test/_bulk").     request.addParameter("refresh", "true").     StringBuilder bulk = new StringBuilder().     for (String doc : docs) {         bulk.append("{\"index\":{}\n").         bulk.append(doc + "\n").     }     request.setJsonEntity(bulk.toString()).     client().performRequest(request). }
