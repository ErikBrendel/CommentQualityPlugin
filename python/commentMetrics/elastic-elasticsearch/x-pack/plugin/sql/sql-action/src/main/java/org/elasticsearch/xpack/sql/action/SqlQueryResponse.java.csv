commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The key that must be sent back to SQL to access the next page of  * results. If equal to "" then there is no next page.  */ ;/**  * The key that must be sent back to SQL to access the next page of  * results. If equal to "" then there is no next page.  */ public String cursor() {     return cursor. }
false;public;0;3;;public long size() {     return rows.size(). }
false;public;0;3;;public List<ColumnInfo> columns() {     return columns. }
false;public;0;3;;public boolean columnar() {     return columnar. }
false;public;0;3;;public List<List<Object>> rows() {     return rows. }
false;public;1;4;;public SqlQueryResponse cursor(String cursor) {     this.cursor = cursor.     return this. }
false;public;1;4;;public SqlQueryResponse columns(List<ColumnInfo> columns) {     this.columns = columns.     return this. }
false;public;1;4;;public SqlQueryResponse rows(List<List<Object>> rows) {     this.rows = rows.     return this. }
false;public;1;29;;@Override public void readFrom(StreamInput in) throws IOException {     cursor = in.readString().     if (in.readBoolean()) {         // We might have rows without columns and we might have columns without rows         // So we send the column size twice, just to keep the protocol simple         int columnCount = in.readVInt().         List<ColumnInfo> columns = new ArrayList<>(columnCount).         for (int c = 0. c < columnCount. c++) {             columns.add(readColumnInfo(in)).         }         this.columns = unmodifiableList(columns).     } else {         this.columns = null.     }     int rowCount = in.readVInt().     List<List<Object>> rows = new ArrayList<>(rowCount).     if (rowCount > 0) {         int columnCount = in.readVInt().         for (int r = 0. r < rowCount. r++) {             List<Object> row = new ArrayList<>(columnCount).             for (int c = 0. c < columnCount. c++) {                 row.add(in.readGenericValue()).             }             rows.add(unmodifiableList(row)).         }     }     this.rows = unmodifiableList(rows). }
false;public;1;22;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(cursor).     if (columns == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         out.writeVInt(columns.size()).         for (ColumnInfo column : columns) {             writeColumnInfo(out, column).         }     }     out.writeVInt(rows.size()).     if (rows.size() > 0) {         out.writeVInt(rows.get(0).size()).         for (List<Object> row : rows) {             for (Object value : row) {                 out.writeGenericValue(value).             }         }     } }
false;public;2;49;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         if (columns != null) {             builder.startArray("columns").             {                 for (ColumnInfo column : columns) {                     column.toXContent(builder, params).                 }             }             builder.endArray().         }         if (columnar) {             // columns can be specified (for the first REST request for example), or not (on a paginated/cursor based request)             // if the columns are missing, we take the first rows' size as the number of columns             long columnsCount = columns != null ? columns.size() : 0.             if (size() > 0) {                 columnsCount = rows().get(0).size().             }             builder.startArray("values").             for (int index = 0. index < columnsCount. index++) {                 builder.startArray().                 for (List<Object> row : rows()) {                     value(builder, mode, row.get(index)).                 }                 builder.endArray().             }             builder.endArray().         } else {             builder.startArray("rows").             for (List<Object> row : rows()) {                 builder.startArray().                 for (Object value : row) {                     value(builder, mode, value).                 }                 builder.endArray().             }             builder.endArray().         }         if (cursor.equals("") == false) {             builder.field(CURSOR.getPreferredName(), cursor).         }     }     return builder.endObject(). }
true;public,static;3;15;/**  * Serializes the provided value in SQL-compatible way based on the client mode  */ ;/**  * Serializes the provided value in SQL-compatible way based on the client mode  */ public static XContentBuilder value(XContentBuilder builder, Mode mode, Object value) throws IOException {     if (value instanceof ZonedDateTime) {         ZonedDateTime zdt = (ZonedDateTime) value.         // use the ISO format         builder.value(StringUtils.toString(zdt)).     } else if (mode == CLI && value != null && value.getClass().getSuperclass().getSimpleName().equals(INTERVAL_CLASS_NAME)) {         // use the SQL format for intervals when sending back the response for CLI         // all other clients will receive ISO 8601 formatted intervals         builder.value(value.toString()).     } else {         builder.value(value).     }     return builder. }
false;public,static;1;8;;public static ColumnInfo readColumnInfo(StreamInput in) throws IOException {     String table = in.readString().     String name = in.readString().     String esType = in.readString().     Integer displaySize = in.readOptionalVInt().     return new ColumnInfo(table, name, esType, displaySize). }
false;public,static;2;6;;public static void writeColumnInfo(StreamOutput out, ColumnInfo columnInfo) throws IOException {     out.writeString(columnInfo.table()).     out.writeString(columnInfo.name()).     out.writeString(columnInfo.esType()).     out.writeOptionalVInt(columnInfo.displaySize()). }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     SqlQueryResponse that = (SqlQueryResponse) o.     return Objects.equals(cursor, that.cursor) && Objects.equals(columns, that.columns) && Objects.equals(rows, that.rows). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(cursor, columns, rows). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
