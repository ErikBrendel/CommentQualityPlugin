commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;3;;public final String apply(Object l) {     return apply.apply(l). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeIntArray(width).     out.writeEnum(formatOption). }
true;public;2;38;/**  * Format the provided {@linkplain SqlQueryResponse} for the set format  * including the header lines.  */ ;/**  * Format the provided {@linkplain SqlQueryResponse} for the set format  * including the header lines.  */ public String formatWithHeader(List<ColumnInfo> columns, List<List<Object>> rows) {     // The header lines     StringBuilder sb = new StringBuilder(estimateSize(rows.size() + 2)).     for (int i = 0. i < width.length. i++) {         if (i > 0) {             sb.append('|').         }         String name = columns.get(i).name().         // left padding         int leftPadding = (width[i] - name.length()) / 2.         for (int j = 0. j < leftPadding. j++) {             sb.append(' ').         }         sb.append(name).         // right padding         for (int j = 0. j < width[i] - name.length() - leftPadding. j++) {             sb.append(' ').         }     }     sb.append('\n').     for (int i = 0. i < width.length. i++) {         if (i > 0) {             sb.append('+').         }         for (int j = 0. j < width[i]. j++) {             // emdash creates issues             sb.append('-').         }     }     sb.append('\n').     /* Now format the results. Sadly, this means that column          * widths are entirely determined by the first batch of          * results. */     return formatWithoutHeader(sb, rows). }
true;public;1;3;/**  * Format the provided {@linkplain SqlQueryResponse} for the set format  * without the header lines.  */ ;/**  * Format the provided {@linkplain SqlQueryResponse} for the set format  * without the header lines.  */ public String formatWithoutHeader(List<List<Object>> rows) {     return formatWithoutHeader(new StringBuilder(estimateSize(rows.size())), rows). }
false;private;2;24;;private String formatWithoutHeader(StringBuilder sb, List<List<Object>> rows) {     for (List<Object> row : rows) {         for (int i = 0. i < width.length. i++) {             if (i > 0) {                 sb.append('|').             }             String string = formatOption.apply(row.get(i)).             if (string.length() <= width[i]) {                 // Pad                 sb.append(string).                 int padding = width[i] - string.length().                 for (int p = 0. p < padding. p++) {                     sb.append(' ').                 }             } else {                 // Trim                 sb.append(string.substring(0, width[i] - 1)).                 sb.append('~').             }         }         sb.append('\n').     }     return sb.toString(). }
true;;1;10;/**  * Pick a good estimate of the buffer size needed to contain the rows.  */ ;/**  * Pick a good estimate of the buffer size needed to contain the rows.  */ int estimateSize(int rows) {     /* Each column has either a '|' or a '\n' after it          * so initialize size to number of columns then add          * up the actual widths of each column. */     int rowWidthEstimate = width.length.     for (int w : width) {         rowWidthEstimate += w.     }     return rowWidthEstimate * rows. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     BasicFormatter that = (BasicFormatter) o.     return Arrays.equals(width, that.width) && formatOption == that.formatOption. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(width, formatOption). }
