commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The key that must be sent back to SQL to access the next page of  * results. If equal to "" then there is no next page.  */ ;/**  * The key that must be sent back to SQL to access the next page of  * results. If equal to "" then there is no next page.  */ public String cursor() {     return cursor. }
false;public;0;3;;public long size() {     return rows.size(). }
false;public;0;3;;public List<ColumnInfo> columns() {     return columns. }
false;public;0;3;;public List<List<Object>> rows() {     return rows. }
false;public,static;1;3;;public static SqlQueryResponse fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
false;public,static;1;11;;public static List<List<Object>> parseRows(XContentParser parser) throws IOException {     List<List<Object>> list = new ArrayList<>().     while (parser.nextToken() != XContentParser.Token.END_ARRAY) {         if (parser.currentToken() == XContentParser.Token.START_ARRAY) {             list.add(parseRow(parser)).         } else {             throw new IllegalStateException("expected start array but got [" + parser.currentToken() + "]").         }     }     return list. }
false;public,static;1;13;;public static List<Object> parseRow(XContentParser parser) throws IOException {     List<Object> list = new ArrayList<>().     while (parser.nextToken() != XContentParser.Token.END_ARRAY) {         if (parser.currentToken().isValue()) {             list.add(ProtoUtils.parseFieldsValue(parser)).         } else if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {             list.add(null).         } else {             throw new IllegalStateException("expected value but got [" + parser.currentToken() + "]").         }     }     return list. }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     SqlQueryResponse that = (SqlQueryResponse) o.     return Objects.equals(cursor, that.cursor) && Objects.equals(columns, that.columns) && Objects.equals(rows, that.rows). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(cursor, columns, rows). }
