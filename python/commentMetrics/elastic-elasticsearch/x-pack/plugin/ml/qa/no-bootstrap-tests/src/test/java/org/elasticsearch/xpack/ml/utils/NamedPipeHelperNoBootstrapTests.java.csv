commented;modifiers;parameterAmount;loc;comment;code
true;private,static,native;8;2;// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365150(v=vs.85).aspx ;// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365150(v=vs.85).aspx private static native Pointer CreateNamedPipeW(WString name, DWord openMode, DWord pipeMode, DWord maxInstances, DWord outBufferSize, DWord inBufferSize, DWord defaultTimeOut, Pointer securityAttributes).
true;private,static,native;2;1;// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365146(v=vs.85).aspx ;// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365146(v=vs.85).aspx private static native boolean ConnectNamedPipe(Pointer handle, Pointer overlapped).
true;private,static,native;1;1;// https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx ;// https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx private static native boolean CloseHandle(Pointer handle).
true;private,static,native;5;2;// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365467(v=vs.85).aspx ;// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365467(v=vs.85).aspx private static native boolean ReadFile(Pointer handle, Pointer buffer, DWord numberOfBytesToRead, IntByReference numberOfBytesRead, Pointer overlapped).
true;private,static,native;5;2;// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx ;// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx private static native boolean WriteFile(Pointer handle, Pointer buffer, DWord numberOfBytesToWrite, IntByReference numberOfBytesWritten, Pointer overlapped).
false;private,static;2;8;;private static Pointer createPipe(String pipeName, boolean forWrite) throws IOException, InterruptedException {     if (Constants.WINDOWS) {         return createPipeWindows(pipeName, forWrite).     }     createPipeUnix(pipeName).     // This won't be used in the *nix version     return INVALID_HANDLE_VALUE. }
false;private,static;1;5;;private static void createPipeUnix(String pipeName) throws IOException, InterruptedException {     if (Runtime.getRuntime().exec("mkfifo " + pipeName).waitFor() != 0) {         throw new IOException("mkfifo failed for pipe " + pipeName).     } }
false;private,static;2;9;;private static Pointer createPipeWindows(String pipeName, boolean forWrite) throws IOException {     Pointer handle = CreateNamedPipeW(new WString(pipeName), new DWord(forWrite ? PIPE_ACCESS_OUTBOUND : PIPE_ACCESS_INBOUND), new DWord(PIPE_TYPE_BYTE | PIPE_WAIT | PIPE_REJECT_REMOTE_CLIENTS), new DWord(1), new DWord(BUFFER_SIZE), new DWord(BUFFER_SIZE), new DWord(NMPWAIT_USE_DEFAULT_WAIT), Pointer.NULL).     if (INVALID_HANDLE_VALUE.equals(handle)) {         throw new IOException("CreateNamedPipeW failed for pipe " + pipeName + " with error " + Native.getLastError()).     }     return handle. }
false;private,static;2;6;;private static String readLineFromPipe(String pipeName, Pointer handle) throws IOException {     if (Constants.WINDOWS) {         return readLineFromPipeWindows(pipeName, handle).     }     return readLineFromPipeUnix(pipeName). }
false;private,static;1;3;;private static String readLineFromPipeUnix(String pipeName) throws IOException {     return Files.readAllLines(PathUtils.get(pipeName), StandardCharsets.UTF_8).get(0). }
false;private,static;2;22;;private static String readLineFromPipeWindows(String pipeName, Pointer handle) throws IOException {     if (!ConnectNamedPipe(handle, Pointer.NULL)) {         // there was no need to connect it again - not a problem         if (Native.getLastError() != ERROR_PIPE_CONNECTED) {             throw new IOException("ConnectNamedPipe failed for pipe " + pipeName + " with error " + Native.getLastError()).         }     }     IntByReference numberOfBytesRead = new IntByReference().     ByteBuffer buf = ByteBuffer.allocateDirect(BUFFER_SIZE).     if (!ReadFile(handle, Native.getDirectBufferPointer(buf), new DWord(BUFFER_SIZE), numberOfBytesRead, Pointer.NULL)) {         throw new IOException("ReadFile failed for pipe " + pipeName + " with error " + Native.getLastError()).     }     byte[] content = new byte[numberOfBytesRead.getValue()].     buf.get(content).     String line = new String(content, StandardCharsets.UTF_8).     int newlinePos = line.indexOf('\n').     if (newlinePos == -1) {         return line.     }     return line.substring(0, newlinePos). }
false;private,static;3;7;;private static void writeLineToPipe(String pipeName, Pointer handle, String line) throws IOException {     if (Constants.WINDOWS) {         writeLineToPipeWindows(pipeName, handle, line).     } else {         writeLineToPipeUnix(pipeName, line).     } }
false;private,static;2;3;;private static void writeLineToPipeUnix(String pipeName, String line) throws IOException {     Files.write(PathUtils.get(pipeName), (line + '\n').getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE). }
false;private,static;3;15;;private static void writeLineToPipeWindows(String pipeName, Pointer handle, String line) throws IOException {     if (!ConnectNamedPipe(handle, Pointer.NULL)) {         // there was no need to connect it again - not a problem         if (Native.getLastError() != ERROR_PIPE_CONNECTED) {             throw new IOException("ConnectNamedPipe failed for pipe " + pipeName + " with error " + Native.getLastError()).         }     }     IntByReference numberOfBytesWritten = new IntByReference().     ByteBuffer buf = ByteBuffer.allocateDirect(BUFFER_SIZE).     buf.put((line + '\n').getBytes(StandardCharsets.UTF_8)).     if (!WriteFile(handle, Native.getDirectBufferPointer(buf), new DWord(buf.position()), numberOfBytesWritten, Pointer.NULL)) {         throw new IOException("WriteFile failed for pipe " + pipeName + " with error " + Native.getLastError()).     } }
false;private,static;2;7;;private static void deletePipe(String pipeName, Pointer handle) throws IOException {     if (Constants.WINDOWS) {         deletePipeWindows(pipeName, handle).     } else {         deletePipeUnix(pipeName).     } }
false;private,static;1;3;;private static void deletePipeUnix(String pipeName) throws IOException {     Files.delete(PathUtils.get(pipeName)). }
false;private,static;2;5;;private static void deletePipeWindows(String pipeName, Pointer handle) throws IOException {     if (!CloseHandle(handle)) {         throw new IOException("CloseHandle failed for pipe " + pipeName + " with error " + Native.getLastError()).     } }
false;public;0;19;;@Override public void run() {     Pointer handle = INVALID_HANDLE_VALUE.     try {         handle = createPipe(pipeName, false).         line = readLineFromPipe(pipeName, handle).     } catch (IOException | InterruptedException e) {         exception = e.     }     try {         deletePipe(pipeName, handle).     } catch (IOException e) {         // Ignore it if the previous block caught an exception, as this probably means we failed to create the pipe         if (exception == null) {             exception = e.         }     } }
false;public;0;3;;public String getLine() {     return line. }
false;public;0;3;;public Exception getException() {     return exception. }
false;public;0;18;;@Override public void run() {     Pointer handle = INVALID_HANDLE_VALUE.     try {         handle = createPipe(pipeName, true).         writeLineToPipe(pipeName, handle, line).     } catch (IOException | InterruptedException e) {         exception = e.     }     try {         deletePipe(pipeName, handle).     } catch (IOException e) {         // Ignore it if the previous block caught an exception, as this probably means we failed to create the pipe         if (exception == null) {             exception = e.         }     } }
false;public;0;3;;public Exception getException() {     return exception. }
false;public;0;30;;public void testOpenForInput() throws IOException, InterruptedException {     Environment env = TestEnvironment.newEnvironment(Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toString()).build()).     String pipeName = NAMED_PIPE_HELPER.getDefaultPipeDirectoryPrefix(env) + "inputPipe" + JvmInfo.jvmInfo().pid().     PipeWriterServer server = new PipeWriterServer(pipeName, HELLO_WORLD).     server.start().     try {         // Timeout is 10 seconds for the very rare case of Amazon EBS volumes created from snapshots         // being slow the first time a particular disk block is accessed.  The same problem as         // https://github.com/elastic/x-pack-elasticsearch/issues/922, which was fixed by         // https://github.com/elastic/x-pack-elasticsearch/pull/987, has been observed in CI tests.         InputStream is = NAMED_PIPE_HELPER.openNamedPipeInputStream(pipeName, Duration.ofSeconds(10)).         assertNotNull(is).         try (BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {             String line = reader.readLine().             assertEquals(HELLO_WORLD, line).         }     } catch (IOException e) {         server.interrupt().         throw e.     } finally {         // If this doesn't join quickly then the server thread is probably deadlocked so there's no         // point waiting a long time.         server.join(1000).     }     assertNull(server.getException()). }
false;public;0;34;;public void testOpenForOutput() throws IOException, InterruptedException {     Environment env = TestEnvironment.newEnvironment(Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toString()).build()).     String pipeName = NAMED_PIPE_HELPER.getDefaultPipeDirectoryPrefix(env) + "outputPipe" + JvmInfo.jvmInfo().pid().     PipeReaderServer server = new PipeReaderServer(pipeName).     server.start().     try {         // Timeout is 10 seconds for the very rare case of Amazon EBS volumes created from snapshots         // being slow the first time a particular disk block is accessed.  The same problem as         // https://github.com/elastic/x-pack-elasticsearch/issues/922, which was fixed by         // https://github.com/elastic/x-pack-elasticsearch/pull/987, has been observed in CI tests.         OutputStream os = NAMED_PIPE_HELPER.openNamedPipeOutputStream(pipeName, Duration.ofSeconds(10)).         assertNotNull(os).         // error with ERROR_NO_DATA         try (OutputStreamWriter writer = new OutputStreamWriter(os, StandardCharsets.UTF_8)) {             writer.write(GOODBYE_WORLD).             writer.write('\n').         }     } catch (IOException e) {         server.interrupt().         throw e.     } finally {         // If this doesn't join quickly then the server thread is probably deadlocked so there's no         // point waiting a long time.         server.join(1000).     }     assertNull(server.getException()).     assertEquals(GOODBYE_WORLD, server.getLine()). }
