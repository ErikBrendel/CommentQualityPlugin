commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@After public void cleanup() throws Exception {     cleanUp(). }
false;public;0;44;;public void testLookbackOnly() throws Exception {     client().admin().indices().prepareCreate("data-1").addMapping("type", "time", "type=date").get().     long numDocs = randomIntBetween(32, 2048).     long now = System.currentTimeMillis().     long oneWeekAgo = now - 604800000.     long twoWeeksAgo = oneWeekAgo - 604800000.     indexDocs(logger, "data-1", numDocs, twoWeeksAgo, oneWeekAgo).     client().admin().indices().prepareCreate("data-2").addMapping("type", "time", "type=date").get().     client().admin().cluster().prepareHealth("data-1", "data-2").setWaitForYellowStatus().get().     long numDocs2 = randomIntBetween(32, 2048).     indexDocs(logger, "data-2", numDocs2, oneWeekAgo, now).     Job.Builder job = createScheduledJob("lookback-job").     registerJob(job).     PutJobAction.Response putJobResponse = putJob(job).     assertThat(putJobResponse.getResponse().getJobVersion(), equalTo(Version.CURRENT)).     openJob(job.getId()).     assertBusy(() -> assertEquals(getJobStats(job.getId()).get(0).getState(), JobState.OPENED)).     List<String> t = new ArrayList<>(2).     t.add("data-1").     t.add("data-2").     DatafeedConfig datafeedConfig = createDatafeed(job.getId() + "-datafeed", job.getId(), t).     registerDatafeed(datafeedConfig).     putDatafeed(datafeedConfig).     startDatafeed(datafeedConfig.getId(), 0L, now).     assertBusy(() -> {         DataCounts dataCounts = getDataCounts(job.getId()).         assertThat(dataCounts.getProcessedRecordCount(), equalTo(numDocs + numDocs2)).         assertThat(dataCounts.getOutOfOrderTimeStampCount(), equalTo(0L)).         GetDatafeedsStatsAction.Request request = new GetDatafeedsStatsAction.Request(datafeedConfig.getId()).         GetDatafeedsStatsAction.Response response = client().execute(GetDatafeedsStatsAction.INSTANCE, request).actionGet().         assertThat(response.getResponse().results().get(0).getDatafeedState(), equalTo(DatafeedState.STOPPED)).     }, 60, TimeUnit.SECONDS).     waitUntilJobIsClosed(job.getId()). }
false;public;0;22;;public void testRealtime() throws Exception {     String jobId = "realtime-job".     String datafeedId = jobId + "-datafeed".     startRealtime(jobId).     try {         StopDatafeedAction.Response stopJobResponse = stopDatafeed(datafeedId).         assertTrue(stopJobResponse.isStopped()).     } catch (Exception e) {         NodesHotThreadsResponse nodesHotThreadsResponse = client().admin().cluster().prepareNodesHotThreads().get().         int i = 0.         for (NodeHotThreads nodeHotThreads : nodesHotThreadsResponse.getNodes()) {             logger.info(i++ + ":\n" + nodeHotThreads.getHotThreads()).         }         throw e.     }     assertBusy(() -> {         GetDatafeedsStatsAction.Request request = new GetDatafeedsStatsAction.Request(datafeedId).         GetDatafeedsStatsAction.Response response = client().execute(GetDatafeedsStatsAction.INSTANCE, request).actionGet().         assertThat(response.getResponse().results().get(0).getDatafeedState(), equalTo(DatafeedState.STOPPED)).     }). }
false;public;0;44;;public void testRealtime_multipleStopCalls() throws Exception {     String jobId = "realtime-job-multiple-stop".     final String datafeedId = jobId + "-datafeed".     startRealtime(jobId).     ConcurrentMapLong<AssertionError> exceptions = ConcurrentCollections.newConcurrentMapLong().     // It's practically impossible to assert that a stop request has waited     // for a concurrently executing request to finish before returning.     // But we can assert the data feed has stopped after the request returns.     Runnable stopDataFeed = () -> {         StopDatafeedAction.Response stopJobResponse = stopDatafeed(datafeedId).         if (stopJobResponse.isStopped() == false) {             exceptions.put(Thread.currentThread().getId(), new AssertionError("Job is not stopped")).         }         GetDatafeedsStatsAction.Request request = new GetDatafeedsStatsAction.Request(datafeedId).         GetDatafeedsStatsAction.Response response = client().execute(GetDatafeedsStatsAction.INSTANCE, request).actionGet().         if (response.getResponse().results().get(0).getDatafeedState() != DatafeedState.STOPPED) {             exceptions.put(Thread.currentThread().getId(), new AssertionError("Expected STOPPED datafeed state got " + response.getResponse().results().get(0).getDatafeedState())).         }     }.     // The idea is to hit the situation where one request waits for     // the other to complete. This is difficult to schedule but     // hopefully it will happen in CI     int numThreads = 5.     Thread[] threads = new Thread[numThreads].     for (int i = 0. i < numThreads. i++) {         threads[i] = new Thread(stopDataFeed).     }     for (int i = 0. i < numThreads. i++) {         threads[i].start().     }     for (int i = 0. i < numThreads. i++) {         threads[i].join().     }     if (exceptions.isEmpty() == false) {         throw exceptions.values().iterator().next().     } }
false;public;0;42;;public void testRealtime_givenSimultaneousStopAndForceDelete() throws Throwable {     String jobId = "realtime-job-stop-and-force-delete".     final String datafeedId = jobId + "-datafeed".     startRealtime(jobId).     AtomicReference<Throwable> exception = new AtomicReference<>().     // The UI now force deletes datafeeds, which means they can be deleted while running.     // The first step is to isolate the datafeed.  But if it was already being stopped then     // the datafeed may not be running by the time the isolate action is executed.  This     // test will sometimes (depending on thread scheduling) achieve this situation and ensure     // the code is robust to it.     Thread deleteDatafeedThread = new Thread(() -> {         try {             DeleteDatafeedAction.Request request = new DeleteDatafeedAction.Request(datafeedId).             request.setForce(true).             AcknowledgedResponse response = client().execute(DeleteDatafeedAction.INSTANCE, request).actionGet().             if (response.isAcknowledged()) {                 GetDatafeedsStatsAction.Request statsRequest = new GetDatafeedsStatsAction.Request(datafeedId).                 expectThrows(ResourceNotFoundException.class, () -> client().execute(GetDatafeedsStatsAction.INSTANCE, statsRequest).actionGet()).             } else {                 exception.set(new AssertionError("Job is not deleted")).             }         } catch (AssertionError | Exception e) {             exception.set(e).         }     }).     deleteDatafeedThread.start().     try {         stopDatafeed(datafeedId).     } catch (ResourceNotFoundException e) {     // This is OK - it means the thread running the delete fully completed before the stop started to execute     } finally {         deleteDatafeedThread.join().     }     if (exception.get() != null) {         throw exception.get().     } }
false;public;0;14;;public void testRealtime_GivenProcessIsKilled() throws Exception {     String jobId = "realtime-job-given-process-is-killed".     String datafeedId = jobId + "-datafeed".     startRealtime(jobId).     KillProcessAction.Request killRequest = new KillProcessAction.Request(jobId).     client().execute(KillProcessAction.INSTANCE, killRequest).actionGet().     assertBusy(() -> {         GetDatafeedsStatsAction.Request request = new GetDatafeedsStatsAction.Request(datafeedId).         GetDatafeedsStatsAction.Response response = client().execute(GetDatafeedsStatsAction.INSTANCE, request).actionGet().         assertThat(response.getResponse().results().get(0).getDatafeedState(), equalTo(DatafeedState.STOPPED)).     }). }
true;public;0;45;/**  * Stopping a lookback closes the associated job _after_ the stop call returns.  * This test ensures that a kill request submitted during this close doesn't  * put the job into the "failed" state.  */ ;/**  * Stopping a lookback closes the associated job _after_ the stop call returns.  * This test ensures that a kill request submitted during this close doesn't  * put the job into the "failed" state.  */ public void testStopLookbackFollowedByProcessKill() throws Exception {     client().admin().indices().prepareCreate("data").addMapping("type", "time", "type=date").get().     long numDocs = randomIntBetween(1024, 2048).     long now = System.currentTimeMillis().     long oneWeekAgo = now - 604800000.     long twoWeeksAgo = oneWeekAgo - 604800000.     indexDocs(logger, "data", numDocs, twoWeeksAgo, oneWeekAgo).     Job.Builder job = createScheduledJob("lookback-job-stopped-then-killed").     registerJob(job).     PutJobAction.Response putJobResponse = putJob(job).     assertThat(putJobResponse.getResponse().getJobVersion(), equalTo(Version.CURRENT)).     openJob(job.getId()).     assertBusy(() -> assertEquals(getJobStats(job.getId()).get(0).getState(), JobState.OPENED)).     List<String> t = Collections.singletonList("data").     DatafeedConfig.Builder datafeedConfigBuilder = createDatafeedBuilder(job.getId() + "-datafeed", job.getId(), t).     // Use lots of chunks so we have time to stop the lookback before it completes     datafeedConfigBuilder.setChunkingConfig(ChunkingConfig.newManual(new TimeValue(1, TimeUnit.SECONDS))).     DatafeedConfig datafeedConfig = datafeedConfigBuilder.build().     registerDatafeed(datafeedConfig).     putDatafeed(datafeedConfig).     startDatafeed(datafeedConfig.getId(), 0L, now).     assertBusy(() -> {         DataCounts dataCounts = getDataCounts(job.getId()).         assertThat(dataCounts.getProcessedRecordCount(), greaterThan(0L)).     }, 60, TimeUnit.SECONDS).     stopDatafeed(datafeedConfig.getId()).     // At this point, stopping the datafeed will have submitted a request for the job to close.     // Depending on thread scheduling, the following kill request might overtake it.  The Thread.sleep()     // call here makes it more likely. to make it inevitable for testing also add a Thread.sleep(10)     // immediately before the checkProcessIsAlive() call in AutodetectCommunicator.close().     Thread.sleep(randomIntBetween(1, 9)).     KillProcessAction.Request killRequest = new KillProcessAction.Request(job.getId()).     client().execute(KillProcessAction.INSTANCE, killRequest).actionGet().     // This should close very quickly, as we killed the process.  If the job goes into the "failed"     // state that's wrong and this test will fail.     waitUntilJobIsClosed(job.getId(), TimeValue.timeValueSeconds(2)). }
false;private;1;34;;private void startRealtime(String jobId) throws Exception {     client().admin().indices().prepareCreate("data").addMapping("type", "time", "type=date").get().     long numDocs1 = randomIntBetween(32, 2048).     long now = System.currentTimeMillis().     long lastWeek = now - 604800000.     indexDocs(logger, "data", numDocs1, lastWeek, now).     Job.Builder job = createScheduledJob(jobId).     registerJob(job).     putJob(job).     openJob(job.getId()).     assertBusy(() -> assertEquals(getJobStats(job.getId()).get(0).getState(), JobState.OPENED)).     DatafeedConfig datafeedConfig = createDatafeed(job.getId() + "-datafeed", job.getId(), Collections.singletonList("data")).     registerDatafeed(datafeedConfig).     putDatafeed(datafeedConfig).     startDatafeed(datafeedConfig.getId(), 0L, null).     assertBusy(() -> {         DataCounts dataCounts = getDataCounts(job.getId()).         assertThat(dataCounts.getProcessedRecordCount(), equalTo(numDocs1)).         assertThat(dataCounts.getOutOfOrderTimeStampCount(), equalTo(0L)).     }).     long numDocs2 = randomIntBetween(2, 64).     now = System.currentTimeMillis().     indexDocs(logger, "data", numDocs2, now + 5000, now + 6000).     assertBusy(() -> {         DataCounts dataCounts = getDataCounts(job.getId()).         assertThat(dataCounts.getProcessedRecordCount(), equalTo(numDocs1 + numDocs2)).         assertThat(dataCounts.getOutOfOrderTimeStampCount(), equalTo(0L)).     }, 30, TimeUnit.SECONDS). }
