commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(LocalStateCompositeXPackPlugin.class, Netty4Plugin.class). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> transportClientPlugins() {     return Arrays.asList(XPackClientPlugin.class, Netty4Plugin.class, ReindexPlugin.class). }
false;protected;0;21;;@Override protected Settings externalClusterClientSettings() {     Path key.     Path certificate.     try {         key = PathUtils.get(getClass().getResource("/testnode.pem").toURI()).         certificate = PathUtils.get(getClass().getResource("/testnode.crt").toURI()).     } catch (URISyntaxException e) {         throw new IllegalStateException("error trying to get keystore path", e).     }     Settings.Builder builder = Settings.builder().     builder.put(NetworkModule.TRANSPORT_TYPE_KEY, SecurityField.NAME4).     builder.put(SecurityField.USER_SETTING.getKey(), "x_pack_rest_user:" + SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING).     builder.put(XPackSettings.MACHINE_LEARNING_ENABLED.getKey(), true).     builder.put("xpack.security.transport.ssl.enabled", true).     builder.put("xpack.security.transport.ssl.key", key.toAbsolutePath().toString()).     builder.put("xpack.security.transport.ssl.certificate", certificate.toAbsolutePath().toString()).     builder.put("xpack.security.transport.ssl.key_passphrase", "testnode").     builder.put("xpack.security.transport.ssl.verification_mode", "certificate").     return builder.build(). }
false;protected;0;4;;protected void cleanUp() {     cleanUpResources().     waitForPendingTasks(). }
false;protected,abstract;0;1;;protected abstract void cleanUpResources().
false;private;0;11;;private void waitForPendingTasks() {     ListTasksRequest listTasksRequest = new ListTasksRequest().     listTasksRequest.setWaitForCompletion(true).     listTasksRequest.setDetailed(true).     listTasksRequest.setTimeout(TimeValue.timeValueSeconds(10)).     try {         admin().cluster().listTasks(listTasksRequest).get().     } catch (Exception e) {         throw new AssertionError("Failed to wait for pending tasks to complete", e).     } }
false;protected;0;49;;@Override protected void ensureClusterStateConsistency() throws IOException {     if (cluster() != null && cluster().size() > 0) {         List<NamedWriteableRegistry.Entry> entries = new ArrayList<>(ClusterModule.getNamedWriteables()).         entries.addAll(new SearchModule(Settings.EMPTY, true, Collections.emptyList()).getNamedWriteables()).         entries.add(new NamedWriteableRegistry.Entry(MetaData.Custom.class, "ml", MlMetadata::new)).         entries.add(new NamedWriteableRegistry.Entry(PersistentTaskParams.class, MlTasks.DATAFEED_TASK_NAME, StartDatafeedAction.DatafeedParams::new)).         entries.add(new NamedWriteableRegistry.Entry(PersistentTaskParams.class, MlTasks.JOB_TASK_NAME, OpenJobAction.JobParams::new)).         entries.add(new NamedWriteableRegistry.Entry(PersistentTaskState.class, JobTaskState.NAME, JobTaskState::new)).         entries.add(new NamedWriteableRegistry.Entry(PersistentTaskState.class, DatafeedState.NAME, DatafeedState::fromStream)).         entries.add(new NamedWriteableRegistry.Entry(ClusterState.Custom.class, TokenMetaData.TYPE, TokenMetaData::new)).         final NamedWriteableRegistry namedWriteableRegistry = new NamedWriteableRegistry(entries).         ClusterState masterClusterState = client().admin().cluster().prepareState().all().get().getState().         byte[] masterClusterStateBytes = ClusterState.Builder.toBytes(masterClusterState).         // remove local node reference         masterClusterState = ClusterState.Builder.fromBytes(masterClusterStateBytes, null, namedWriteableRegistry).         Map<String, Object> masterStateMap = convertToMap(masterClusterState).         int masterClusterStateSize = ClusterState.Builder.toBytes(masterClusterState).length.         String masterId = masterClusterState.nodes().getMasterNodeId().         for (Client client : cluster().getClients()) {             ClusterState localClusterState = client.admin().cluster().prepareState().all().setLocal(true).get().getState().             byte[] localClusterStateBytes = ClusterState.Builder.toBytes(localClusterState).             // remove local node reference             localClusterState = ClusterState.Builder.fromBytes(localClusterStateBytes, null, namedWriteableRegistry).             final Map<String, Object> localStateMap = convertToMap(localClusterState).             final int localClusterStateSize = ClusterState.Builder.toBytes(localClusterState).length.             // that the master node matches the master (otherwise there is no requirement for the cluster state to match)             if (masterClusterState.version() == localClusterState.version() && masterId.equals(localClusterState.nodes().getMasterNodeId())) {                 try {                     assertEquals("clusterstate UUID does not match", masterClusterState.stateUUID(), localClusterState.stateUUID()).                     // We cannot compare serialization bytes since serialization order of maps is not guaranteed                     // but we can compare serialization sizes - they should be the same                     assertEquals("clusterstate size does not match", masterClusterStateSize, localClusterStateSize).                     // Compare JSON serialization                     assertNull("clusterstate JSON serialization does not match", differenceBetweenMapsIgnoringArrayOrder(masterStateMap, localStateMap)).                 } catch (AssertionError error) {                     logger.error("Cluster state from master:\n{}\nLocal cluster state:\n{}", masterClusterState.toString(), localClusterState.toString()).                     throw error.                 }             }         }     } }
