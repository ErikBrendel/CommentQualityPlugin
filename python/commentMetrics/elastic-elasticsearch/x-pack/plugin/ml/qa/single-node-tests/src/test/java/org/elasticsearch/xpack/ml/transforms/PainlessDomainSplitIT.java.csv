commented;modifiers;parameterAmount;loc;comment;code
false;public;0;60;;public void testIsolated() throws Exception {     Settings.Builder settings = Settings.builder().put(IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.getKey(), 1).put(IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey(), 0).     createIndex("painless", settings.build()).     Request createDoc = new Request("PUT", "/painless/_doc/1").     createDoc.setJsonEntity("{\"test\": \"test\"}").     createDoc.addParameter("refresh", "true").     client().performRequest(createDoc).     Pattern pattern = Pattern.compile("domain_split\":\\[(.*?),(.*?)\\]").     Map<String, Object> params = new HashMap<>().     for (TestConfiguration testConfig : tests) {         params.put("host", testConfig.hostName).         String mapAsJson = Strings.toString(jsonBuilder().map(params)).         logger.info("params={}", mapAsJson).         Request searchRequest = new Request("GET", "/painless/_search").         searchRequest.setJsonEntity("{\n" + "    \"query\" : {\n" + "        \"match_all\": {}\n" + "    },\n" + "    \"script_fields\" : {\n" + "        \"domain_split\" : {\n" + "            \"script\" : {\n" + "                \"lang\": \"painless\",\n" + "                \"source\": \"" + " return domainSplit(params['host']). \",\n" + "                \"params\": " + mapAsJson + "\n" + "            }\n" + "        }\n" + "    }\n" + "}").         String responseBody = EntityUtils.toString(client().performRequest(searchRequest).getEntity()).         Matcher m = pattern.matcher(responseBody).         String actualSubDomain = "".         String actualDomain = "".         if (m.find()) {             actualSubDomain = m.group(1).replace("\"", "").             actualDomain = m.group(2).replace("\"", "").         }         String expectedTotal = "[" + testConfig.subDomainExpected + "," + testConfig.domainExpected + "]".         String actualTotal = "[" + actualSubDomain + "," + actualDomain + "]".         // domainSplit() tests had subdomain, testHighestRegisteredDomainCases() do not         if (testConfig.subDomainExpected != null) {             assertThat("Expected subdomain [" + testConfig.subDomainExpected + "] but found [" + actualSubDomain + "]. Actual " + actualTotal + " vs Expected " + expectedTotal, actualSubDomain, equalTo(testConfig.subDomainExpected)).         }         assertThat("Expected domain [" + testConfig.domainExpected + "] but found [" + actualDomain + "].  Actual " + actualTotal + " vs Expected " + expectedTotal, actualDomain, equalTo(testConfig.domainExpected)).     } }
false;public;0;124;;@AwaitsFix(bugUrl = "https://github.com/elastic/elasticsearch/issues/32966") public void testHRDSplit() throws Exception {     // Create job     Request createJobRequest = new Request("PUT", MachineLearning.BASE_PATH + "anomaly_detectors/hrd-split-job").     createJobRequest.setJsonEntity("{\n" + "    \"description\":\"Domain splitting\",\n" + "    \"analysis_config\" : {\n" + "        \"bucket_span\":\"3600s\",\n" + "        \"detectors\" :[{\"function\":\"count\", \"by_field_name\" : \"domain_split\"}]\n" + "    },\n" + "    \"data_description\" : {\n" + "        \"field_delimiter\":\",\",\n" + "        \"time_field\":\"time\"\n" + "        \n" + "    }\n" + "}").     client().performRequest(createJobRequest).     client().performRequest(new Request("POST", MachineLearning.BASE_PATH + "anomaly_detectors/hrd-split-job/_open")).     // Create index to hold data     Settings.Builder settings = Settings.builder().put(IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.getKey(), 1).put(IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey(), 0).     createIndex("painless", settings.build(), "\"properties\": { \"domain\": { \"type\": \"keyword\" }," + "\"time\": { \"type\": \"date\" } }").     // Index some data     ZonedDateTime baseTime = ZonedDateTime.now(Clock.systemDefaultZone()).minusYears(1).     TestConfiguration test = tests.get(randomInt(tests.size() - 1)).     // domainSplit() tests had subdomain, testHighestRegisteredDomainCases() did not, so we need a special case for sub     String expectedSub = test.subDomainExpected == null ? ".*" : test.subDomainExpected.replace(".", "\\.").     String expectedHRD = test.domainExpected.replace(".", "\\.").     Pattern pattern = Pattern.compile("domain_split\":\\[\"(" + expectedSub + "),(" + expectedHRD + ")\"[,\\]]").     for (int i = 0. i < 100. i++) {         ZonedDateTime time = baseTime.plusHours(i).         if (i == 64) {             // Anomaly has 100 docs, but we don't care about the value             for (int j = 0. j < 100. j++) {                 String formattedTime = time.format(DateTimeFormatter.ISO_DATE_TIME).                 Request createDocRequest = new Request("PUT", "/painless/_doc/" + formattedTime + "_" + j).                 createDocRequest.setJsonEntity("{\"domain\": \"" + "bar.bar.com\", \"time\": \"" + formattedTime + "\"}").                 client().performRequest(createDocRequest).             }         } else {             // Non-anomalous values will be what's seen when the anomaly is reported             String formattedTime = time.format(DateTimeFormatter.ISO_DATE_TIME).             Request createDocRequest = new Request("PUT", "/painless/_doc/" + formattedTime).             createDocRequest.setJsonEntity("{\"domain\": \"" + test.hostName + "\", \"time\": \"" + formattedTime + "\"}").             client().performRequest(createDocRequest).         }     }     client().performRequest(new Request("POST", "/painless/_refresh")).     // Create and start datafeed     Request createFeedRequest = new Request("PUT", MachineLearning.BASE_PATH + "datafeeds/hrd-split-datafeed").     createFeedRequest.setJsonEntity("{\n" + "   \"job_id\":\"hrd-split-job\",\n" + "   \"indexes\":[\"painless\"],\n" + "   \"types\":[\"_doc\"],\n" + "   \"script_fields\": {\n" + "      \"domain_split\": {\n" + "         \"script\": \"return domainSplit(doc['domain'].value, params).\"\n" + "      }\n" + "   }\n" + "}").     client().performRequest(createFeedRequest).     client().performRequest(new Request("POST", MachineLearning.BASE_PATH + "datafeeds/hrd-split-datafeed/_start")).     boolean passed = awaitBusy(() -> {         try {             client().performRequest(new Request("POST", "/_refresh")).             Response response = client().performRequest(new Request("GET", MachineLearning.BASE_PATH + "anomaly_detectors/hrd-split-job/results/records")).             String responseBody = EntityUtils.toString(response.getEntity()).             if (responseBody.contains("\"count\":2")) {                 Matcher m = pattern.matcher(responseBody).                 String actualSubDomain = "".                 String actualDomain = "".                 if (m.find()) {                     actualSubDomain = m.group(1).replace("\"", "").                     actualDomain = m.group(2).replace("\"", "").                 }                 String expectedTotal = "[" + test.subDomainExpected + "," + test.domainExpected + "]".                 String actualTotal = "[" + actualSubDomain + "," + actualDomain + "]".                 // domainSplit() tests had subdomain, testHighestRegisteredDomainCases() do not                 if (test.subDomainExpected != null) {                     assertThat("Expected subdomain [" + test.subDomainExpected + "] but found [" + actualSubDomain + "]. Actual " + actualTotal + " vs Expected " + expectedTotal, actualSubDomain, equalTo(test.subDomainExpected)).                 }                 assertThat("Expected domain [" + test.domainExpected + "] but found [" + actualDomain + "].  Actual " + actualTotal + " vs Expected " + expectedTotal, actualDomain, equalTo(test.domainExpected)).                 return true.             } else {                 logger.error(responseBody).                 return false.             }         } catch (Exception e) {             logger.error(e.getMessage()).             return false.         }     }, 5, TimeUnit.SECONDS).     if (!passed) {         fail("Anomaly records were not found within 5 seconds").     } }
