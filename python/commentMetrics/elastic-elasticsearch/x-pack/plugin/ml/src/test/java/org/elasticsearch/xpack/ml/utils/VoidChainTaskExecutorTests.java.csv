commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Override @After public void tearDown() throws Exception {     try {         terminate(threadPool).     } finally {         super.tearDown().     } }
false;public;0;19;;public void testExecute() throws InterruptedException {     final List<String> strings = new ArrayList<>().     ActionListener<List<Void>> finalListener = createBlockingListener(() -> strings.add("last"), e -> fail()).     VoidChainTaskExecutor voidChainTaskExecutor = new VoidChainTaskExecutor(threadPool.generic(), false).     voidChainTaskExecutor.add(listener -> {         strings.add("first").         listener.onResponse(null).     }).     voidChainTaskExecutor.add(listener -> {         strings.add("second").         listener.onResponse(null).     }).     voidChainTaskExecutor.execute(finalListener).     latch.await().     assertThat(strings, contains("first", "second", "last")). }
false;public;0;23;;public void testExecute_GivenSingleFailureAndShortCircuit() throws InterruptedException {     final List<String> strings = new ArrayList<>().     ActionListener<List<Void>> finalListener = createBlockingListener(() -> fail(), e -> assertThat(e.getMessage(), equalTo("some error"))).     VoidChainTaskExecutor voidChainTaskExecutor = new VoidChainTaskExecutor(threadPool.generic(), true).     voidChainTaskExecutor.add(listener -> {         strings.add("before").         listener.onResponse(null).     }).     voidChainTaskExecutor.add(listener -> {         throw new RuntimeException("some error").     }).     voidChainTaskExecutor.add(listener -> {         strings.add("after").         listener.onResponse(null).     }).     voidChainTaskExecutor.execute(finalListener).     latch.await().     assertThat(strings, contains("before")). }
false;public;0;22;;public void testExecute_GivenMultipleFailuresAndShortCircuit() throws InterruptedException {     final List<String> strings = new ArrayList<>().     ActionListener<List<Void>> finalListener = createBlockingListener(() -> fail(), e -> assertThat(e.getMessage(), equalTo("some error 1"))).     VoidChainTaskExecutor voidChainTaskExecutor = new VoidChainTaskExecutor(threadPool.generic(), true).     voidChainTaskExecutor.add(listener -> {         strings.add("before").         listener.onResponse(null).     }).     voidChainTaskExecutor.add(listener -> {         throw new RuntimeException("some error 1").     }).     voidChainTaskExecutor.add(listener -> {         throw new RuntimeException("some error 2").     }).     voidChainTaskExecutor.execute(finalListener).     latch.await().     assertThat(strings, contains("before")). }
false;public;0;22;;public void testExecute_GivenFailureAndNoShortCircuit() throws InterruptedException {     final List<String> strings = new ArrayList<>().     ActionListener<List<Void>> finalListener = createBlockingListener(() -> strings.add("last"), e -> fail()).     VoidChainTaskExecutor voidChainTaskExecutor = new VoidChainTaskExecutor(threadPool.generic(), false).     voidChainTaskExecutor.add(listener -> {         strings.add("before").         listener.onResponse(null).     }).     voidChainTaskExecutor.add(listener -> {         throw new RuntimeException("some error").     }).     voidChainTaskExecutor.add(listener -> {         strings.add("after").         listener.onResponse(null).     }).     voidChainTaskExecutor.execute(finalListener).     latch.await().     assertThat(strings, contains("before", "after", "last")). }
false;public;0;11;;public void testExecute_GivenNoTasksAdded() throws InterruptedException {     final List<String> strings = new ArrayList<>().     ActionListener<List<Void>> finalListener = createBlockingListener(() -> strings.add("last"), e -> fail()).     VoidChainTaskExecutor voidChainTaskExecutor = new VoidChainTaskExecutor(threadPool.generic(), false).     voidChainTaskExecutor.execute(finalListener).     latch.await().     assertThat(strings, contains("last")). }
false;private;2;9;;private ActionListener<List<Void>> createBlockingListener(Runnable runnable, Consumer<Exception> errorHandler) {     return ActionListener.wrap(nullValue -> {         runnable.run().         latch.countDown().     }, e -> {         errorHandler.accept(e).         latch.countDown().     }). }
