commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;15;;@Override protected Settings nodeSettings() {     Settings.Builder newSettings = Settings.builder().     newSettings.put(super.nodeSettings()).     // Disable native ML autodetect_process as the c++ controller won't be available     newSettings.put(MachineLearningField.AUTODETECT_PROCESS.getKey(), false).     newSettings.put(MachineLearningField.MAX_MODEL_MEMORY_LIMIT.getKey(), new ByteSizeValue(1024)).     newSettings.put(LicenseService.SELF_GENERATED_LICENSE_TYPE.getKey(), "trial").     // Disable security otherwise delete-by-query action fails to get authorized     newSettings.put(XPackSettings.SECURITY_ENABLED.getKey(), false).     newSettings.put(XPackSettings.MONITORING_ENABLED.getKey(), false).     newSettings.put(XPackSettings.WATCHER_ENABLED.getKey(), false).     return newSettings.build(). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return pluginList(LocalStateMachineLearning.class). }
true;public;0;22;/**  * This cleanup is to fix the problem described in  * https://github.com/elastic/elasticsearch/issues/38952  */ ;/**  * This cleanup is to fix the problem described in  * https://github.com/elastic/elasticsearch/issues/38952  */ @Override public void tearDown() throws Exception {     try {         logger.trace("[{}#{}]: ML-specific after test cleanup", getTestClass().getSimpleName(), getTestName()).         String[] nonAnnotationMlIndices.         boolean mlAnnotationsIndexExists.         do {             String[] mlIndices = client().admin().indices().prepareGetIndex().addIndices(".ml-*").get().indices().             nonAnnotationMlIndices = Arrays.stream(mlIndices).filter(name -> name.startsWith(".ml-annotations") == false).toArray(String[]::new).             mlAnnotationsIndexExists = mlIndices.length > nonAnnotationMlIndices.length.         } while (nonAnnotationMlIndices.length > 0 && mlAnnotationsIndexExists == false).         if (nonAnnotationMlIndices.length > 0) {             // Delete the ML indices apart from the annotations index.  The annotations index will be deleted by the             // base class cleanup.  We want to delete all the others first so that the annotations index doesn't get             // automatically recreated.             assertAcked(client().admin().indices().prepareDelete(nonAnnotationMlIndices).get()).         }     } finally {         super.tearDown().     } }
false;protected;0;8;;protected void waitForMlTemplates() throws Exception {     // block until the templates are installed     assertBusy(() -> {         ClusterState state = client().admin().cluster().prepareState().get().getState().         assertTrue("Timed out waiting for the ML templates to be installed", MachineLearning.allTemplatesInstalled(state)).     }). }
false;protected;3;17;;protected <T> void blockingCall(Consumer<ActionListener<T>> function, AtomicReference<T> response, AtomicReference<Exception> error) throws InterruptedException {     CountDownLatch latch = new CountDownLatch(1).     ActionListener<T> listener = ActionListener.wrap(r -> {         response.set(r).         latch.countDown().     }, e -> {         error.set(e).         latch.countDown().     }).     function.accept(listener).     latch.await(). }
false;protected;1;9;;protected <T> T blockingCall(Consumer<ActionListener<T>> function) throws Exception {     AtomicReference<Exception> exceptionHolder = new AtomicReference<>().     AtomicReference<T> responseHolder = new AtomicReference<>().     blockingCall(function, responseHolder, exceptionHolder).     if (exceptionHolder.get() != null) {         assertNull(exceptionHolder.get().getMessage(), exceptionHolder.get()).     }     return responseHolder.get(). }
