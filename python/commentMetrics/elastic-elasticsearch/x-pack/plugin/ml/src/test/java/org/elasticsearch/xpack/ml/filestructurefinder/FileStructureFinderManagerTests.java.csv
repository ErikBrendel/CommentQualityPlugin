commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void setup() {     scheduler = new Scheduler.SafeScheduledThreadPoolExecutor(1).     structureFinderManager = new FileStructureFinderManager(scheduler). }
false;public;0;4;;@After public void shutdownScheduler() {     scheduler.shutdown(). }
false;public;0;8;;public void testFindCharsetGivenCharacterWidths() throws Exception {     for (Charset charset : Arrays.asList(StandardCharsets.UTF_8, StandardCharsets.UTF_16LE, StandardCharsets.UTF_16BE)) {         CharsetMatch charsetMatch = structureFinderManager.findCharset(explanation, new ByteArrayInputStream(TEXT_SAMPLE.getBytes(charset)), NOOP_TIMEOUT_CHECKER).         assertEquals(charset.name(), charsetMatch.getName()).     } }
false;public;0;18;;public void testFindCharsetGivenBinary() throws Exception {     // This input should never match a single byte character set.  ICU4J will sometimes decide     // that it matches a double byte character set, hence the two assertion branches.     int size = 1000.     byte[] binaryBytes = randomByteArrayOfLength(size).     for (int i = 0. i < 10. ++i) {         binaryBytes[randomIntBetween(0, size - 1)] = 0.     }     try {         CharsetMatch charsetMatch = structureFinderManager.findCharset(explanation, new ByteArrayInputStream(binaryBytes), NOOP_TIMEOUT_CHECKER).         assertThat(charsetMatch.getName(), startsWith("UTF-16")).     } catch (IllegalArgumentException e) {         assertEquals("Could not determine a usable character encoding for the input - could it be binary data?", e.getMessage()).     } }
false;public;0;4;;public void testMakeBestStructureGivenNdJson() throws Exception {     assertThat(structureFinderManager.makeBestStructureFinder(explanation, NDJSON_SAMPLE, StandardCharsets.UTF_8.name(), randomBoolean(), EMPTY_OVERRIDES, NOOP_TIMEOUT_CHECKER), instanceOf(NdJsonFileStructureFinder.class)). }
false;public;0;10;;public void testMakeBestStructureGivenNdJsonAndDelimitedOverride() throws Exception {     // Need to change the quote character from the default of double quotes     // otherwise the quotes in the NDJSON will stop it parsing as CSV     FileStructureOverrides overrides = FileStructureOverrides.builder().setFormat(FileStructure.Format.DELIMITED).setQuote('\'').build().     assertThat(structureFinderManager.makeBestStructureFinder(explanation, NDJSON_SAMPLE, StandardCharsets.UTF_8.name(), randomBoolean(), overrides, NOOP_TIMEOUT_CHECKER), instanceOf(DelimitedFileStructureFinder.class)). }
false;public;0;4;;public void testMakeBestStructureGivenXml() throws Exception {     assertThat(structureFinderManager.makeBestStructureFinder(explanation, XML_SAMPLE, StandardCharsets.UTF_8.name(), randomBoolean(), EMPTY_OVERRIDES, NOOP_TIMEOUT_CHECKER), instanceOf(XmlFileStructureFinder.class)). }
false;public;0;7;;public void testMakeBestStructureGivenXmlAndTextOverride() throws Exception {     FileStructureOverrides overrides = FileStructureOverrides.builder().setFormat(FileStructure.Format.SEMI_STRUCTURED_TEXT).build().     assertThat(structureFinderManager.makeBestStructureFinder(explanation, XML_SAMPLE, StandardCharsets.UTF_8.name(), randomBoolean(), overrides, NOOP_TIMEOUT_CHECKER), instanceOf(TextLogFileStructureFinder.class)). }
false;public;0;4;;public void testMakeBestStructureGivenCsv() throws Exception {     assertThat(structureFinderManager.makeBestStructureFinder(explanation, CSV_SAMPLE, StandardCharsets.UTF_8.name(), randomBoolean(), EMPTY_OVERRIDES, NOOP_TIMEOUT_CHECKER), instanceOf(DelimitedFileStructureFinder.class)). }
false;public;0;10;;public void testMakeBestStructureGivenCsvAndJsonOverride() {     FileStructureOverrides overrides = FileStructureOverrides.builder().setFormat(FileStructure.Format.NDJSON).build().     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> structureFinderManager.makeBestStructureFinder(explanation, CSV_SAMPLE, StandardCharsets.UTF_8.name(), randomBoolean(), overrides, NOOP_TIMEOUT_CHECKER)).     assertEquals("Input did not match the specified format [ndjson]", e.getMessage()). }
false;public;0;4;;public void testMakeBestStructureGivenText() throws Exception {     assertThat(structureFinderManager.makeBestStructureFinder(explanation, TEXT_SAMPLE, StandardCharsets.UTF_8.name(), randomBoolean(), EMPTY_OVERRIDES, NOOP_TIMEOUT_CHECKER), instanceOf(TextLogFileStructureFinder.class)). }
false;public;0;9;;public void testMakeBestStructureGivenTextAndDelimitedOverride() throws Exception {     // Every line of the text sample has two colons, so colon delimited is possible, just very weird     FileStructureOverrides overrides = FileStructureOverrides.builder().setFormat(FileStructure.Format.DELIMITED).setDelimiter(':').build().     assertThat(structureFinderManager.makeBestStructureFinder(explanation, TEXT_SAMPLE, StandardCharsets.UTF_8.name(), randomBoolean(), overrides, NOOP_TIMEOUT_CHECKER), instanceOf(DelimitedFileStructureFinder.class)). }
false;public;0;41;;public void testFindFileStructureTimeout() throws IOException, InterruptedException {     // The number of lines might need increasing in the future if computers get really fast,     // but currently we're not even close to finding the structure of this much data in 10ms     int linesOfJunk = 10000.     TimeValue timeout = new TimeValue(10, TimeUnit.MILLISECONDS).     try (PipedOutputStream generator = new PipedOutputStream()) {         Thread junkProducer = new Thread(() -> {             try {                 // This is not just junk. this is comma separated junk                 for (int count = 0. count < linesOfJunk. ++count) {                     generator.write(randomAlphaOfLength(100).getBytes(StandardCharsets.UTF_8)).                     generator.write(',').                     generator.write(randomAlphaOfLength(100).getBytes(StandardCharsets.UTF_8)).                     generator.write(',').                     generator.write(randomAlphaOfLength(100).getBytes(StandardCharsets.UTF_8)).                     generator.write('\n').                 }             } catch (IOException e) {             // Expected if timeout occurs and the input stream is closed before junk generation is complete             }         }).         try (InputStream bigInput = new PipedInputStream(generator)) {             junkProducer.start().             ElasticsearchTimeoutException e = expectThrows(ElasticsearchTimeoutException.class, () -> structureFinderManager.findFileStructure(explanation, linesOfJunk - 1, bigInput, EMPTY_OVERRIDES, timeout)).             assertThat(e.getMessage(), startsWith("Aborting structure analysis during [")).             assertThat(e.getMessage(), endsWith("] as it has taken longer than the timeout of [" + timeout + "]")).         }         // This shouldn't take anything like 10 seconds, but VMs can stall so it's best to         // set the timeout fairly high to avoid the work that spurious failures cause         junkProducer.join(10000L).     } }
