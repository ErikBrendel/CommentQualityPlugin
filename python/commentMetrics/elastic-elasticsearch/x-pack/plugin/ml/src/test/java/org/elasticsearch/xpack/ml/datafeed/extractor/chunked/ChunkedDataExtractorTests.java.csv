commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected SearchResponse executeSearchRequest(ActionRequestBuilder<SearchRequest, SearchResponse> searchRequestBuilder) {     capturedSearchRequests.add(searchRequestBuilder.request()).     return nextResponse. }
false;;1;3;;void setNextResponse(SearchResponse searchResponse) {     nextResponse = searchResponse. }
false;public;0;12;;@Before public void setUpTests() {     client = mock(Client.class).     capturedSearchRequests = new ArrayList<>().     jobId = "test-job".     timeField = "time".     indices = Arrays.asList("index-1", "index-2").     query = QueryBuilders.matchAllQuery().     scrollSize = 1000.     chunkSpan = null.     dataExtractorFactory = mock(DataExtractorFactory.class). }
false;public;0;9;;public void testExtractionGivenNoData() throws IOException {     TestDataExtractor extractor = new TestDataExtractor(1000L, 2300L).     extractor.setNextResponse(createSearchResponse(0L, 0L, 0L)).     assertThat(extractor.hasNext(), is(true)).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     Mockito.verifyNoMoreInteractions(dataExtractorFactory). }
false;public;0;39;;public void testExtractionGivenSpecifiedChunk() throws IOException {     chunkSpan = TimeValue.timeValueSeconds(1).     TestDataExtractor extractor = new TestDataExtractor(1000L, 2300L).     extractor.setNextResponse(createSearchResponse(10L, 1000L, 2200L)).     InputStream inputStream1 = mock(InputStream.class).     InputStream inputStream2 = mock(InputStream.class).     InputStream inputStream3 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1, inputStream2).     when(dataExtractorFactory.newExtractor(1000L, 2000L)).thenReturn(subExtactor1).     DataExtractor subExtactor2 = new StubSubExtractor(inputStream3).     when(dataExtractorFactory.newExtractor(2000L, 2300L)).thenReturn(subExtactor2).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream2, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream3, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertThat(extractor.next().isPresent(), is(false)).     verify(dataExtractorFactory).newExtractor(1000L, 2000L).     verify(dataExtractorFactory).newExtractor(2000L, 2300L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory).     assertThat(capturedSearchRequests.size(), equalTo(1)).     String searchRequest = capturedSearchRequests.get(0).toString().replaceAll("\\s", "").     assertThat(searchRequest, containsString("\"size\":0")).     assertThat(searchRequest, containsString("\"query\":{\"bool\":{\"filter\":[{\"match_all\":{\"boost\":1.0}}," + "{\"range\":{\"time\":{\"from\":1000,\"to\":2300,\"include_lower\":true,\"include_upper\":false," + "\"format\":\"epoch_millis\",\"boost\":1.0}}}]")).     assertThat(searchRequest, containsString("\"aggregations\":{\"earliest_time\":{\"min\":{\"field\":\"time\"}}," + "\"latest_time\":{\"max\":{\"field\":\"time\"}}}}")).     assertThat(searchRequest, not(containsString("\"track_total_hits\":false"))).     assertThat(searchRequest, not(containsString("\"sort\""))). }
false;public;0;39;;public void testExtractionGivenSpecifiedChunkAndAggs() throws IOException {     chunkSpan = TimeValue.timeValueSeconds(1).     TestDataExtractor extractor = new TestDataExtractor(1000L, 2300L, true, 1000L).     extractor.setNextResponse(createSearchResponse(0L, 1000L, 2200L)).     InputStream inputStream1 = mock(InputStream.class).     InputStream inputStream2 = mock(InputStream.class).     InputStream inputStream3 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1, inputStream2).     when(dataExtractorFactory.newExtractor(1000L, 2000L)).thenReturn(subExtactor1).     DataExtractor subExtactor2 = new StubSubExtractor(inputStream3).     when(dataExtractorFactory.newExtractor(2000L, 2300L)).thenReturn(subExtactor2).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream2, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream3, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertThat(extractor.next().isPresent(), is(false)).     verify(dataExtractorFactory).newExtractor(1000L, 2000L).     verify(dataExtractorFactory).newExtractor(2000L, 2300L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory).     assertThat(capturedSearchRequests.size(), equalTo(1)).     String searchRequest = capturedSearchRequests.get(0).toString().replaceAll("\\s", "").     assertThat(searchRequest, containsString("\"size\":0")).     assertThat(searchRequest, containsString("\"query\":{\"bool\":{\"filter\":[{\"match_all\":{\"boost\":1.0}}," + "{\"range\":{\"time\":{\"from\":1000,\"to\":2300,\"include_lower\":true,\"include_upper\":false," + "\"format\":\"epoch_millis\",\"boost\":1.0}}}]")).     assertThat(searchRequest, containsString("\"aggregations\":{\"earliest_time\":{\"min\":{\"field\":\"time\"}}," + "\"latest_time\":{\"max\":{\"field\":\"time\"}}}}")).     assertThat(searchRequest, not(containsString("\"track_total_hits\":false"))).     assertThat(searchRequest, not(containsString("\"sort\""))). }
false;public;0;29;;public void testExtractionGivenAutoChunkAndAggs() throws IOException {     chunkSpan = null.     TestDataExtractor extractor = new TestDataExtractor(100_000L, 450_000L, true, 200L).     extractor.setNextResponse(createSearchResponse(0L, 100_000L, 400_000L)).     InputStream inputStream1 = mock(InputStream.class).     InputStream inputStream2 = mock(InputStream.class).     // 200 * 1_000 == 200_000     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1).     when(dataExtractorFactory.newExtractor(100_000L, 300_000L)).thenReturn(subExtactor1).     DataExtractor subExtactor2 = new StubSubExtractor(inputStream2).     when(dataExtractorFactory.newExtractor(300_000L, 450_000L)).thenReturn(subExtactor2).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream2, extractor.next().get()).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     verify(dataExtractorFactory).newExtractor(100_000L, 300_000L).     verify(dataExtractorFactory).newExtractor(300_000L, 450_000L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;13;;public void testExtractionGivenAutoChunkAndAggsAndNoData() throws IOException {     chunkSpan = null.     TestDataExtractor extractor = new TestDataExtractor(100L, 500L, true, 200L).     extractor.setNextResponse(createNullSearchResponse()).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     Mockito.verifyNoMoreInteractions(dataExtractorFactory).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;30;;public void testExtractionGivenAutoChunkAndScrollSize1000() throws IOException {     chunkSpan = null.     scrollSize = 1000.     TestDataExtractor extractor = new TestDataExtractor(100000L, 450000L).     // 300K millis * 1000 * 10 / 15K docs = 200000     extractor.setNextResponse(createSearchResponse(15000L, 100000L, 400000L)).     InputStream inputStream1 = mock(InputStream.class).     InputStream inputStream2 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1).     when(dataExtractorFactory.newExtractor(100000L, 300000L)).thenReturn(subExtactor1).     DataExtractor subExtactor2 = new StubSubExtractor(inputStream2).     when(dataExtractorFactory.newExtractor(300000L, 450000L)).thenReturn(subExtactor2).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream2, extractor.next().get()).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     verify(dataExtractorFactory).newExtractor(100000L, 300000L).     verify(dataExtractorFactory).newExtractor(300000L, 450000L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;28;;public void testExtractionGivenAutoChunkAndScrollSize500() throws IOException {     chunkSpan = null.     scrollSize = 500.     TestDataExtractor extractor = new TestDataExtractor(100000L, 450000L).     // 300K millis * 500 * 10 / 15K docs = 100000     extractor.setNextResponse(createSearchResponse(15000L, 100000L, 400000L)).     InputStream inputStream1 = mock(InputStream.class).     InputStream inputStream2 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1).     when(dataExtractorFactory.newExtractor(100000L, 200000L)).thenReturn(subExtactor1).     DataExtractor subExtactor2 = new StubSubExtractor(inputStream2).     when(dataExtractorFactory.newExtractor(200000L, 300000L)).thenReturn(subExtactor2).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream2, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     verify(dataExtractorFactory).newExtractor(100000L, 200000L).     verify(dataExtractorFactory).newExtractor(200000L, 300000L).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;29;;public void testExtractionGivenAutoChunkIsLessThanMinChunk() throws IOException {     chunkSpan = null.     scrollSize = 1000.     TestDataExtractor extractor = new TestDataExtractor(100000L, 450000L).     // 30K millis * 1000 * 10 / 150K docs = 2000 < min of 60K     extractor.setNextResponse(createSearchResponse(150000L, 100000L, 400000L)).     InputStream inputStream1 = mock(InputStream.class).     InputStream inputStream2 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1).     when(dataExtractorFactory.newExtractor(100000L, 160000L)).thenReturn(subExtactor1).     DataExtractor subExtactor2 = new StubSubExtractor(inputStream2).     when(dataExtractorFactory.newExtractor(160000L, 220000L)).thenReturn(subExtactor2).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream2, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     verify(dataExtractorFactory).newExtractor(100000L, 160000L).     verify(dataExtractorFactory).newExtractor(160000L, 220000L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;23;;public void testExtractionGivenAutoChunkAndDataTimeSpreadIsZero() throws IOException {     chunkSpan = null.     scrollSize = 1000.     TestDataExtractor extractor = new TestDataExtractor(100L, 500L).     extractor.setNextResponse(createSearchResponse(150000L, 300L, 300L)).     InputStream inputStream1 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1).     when(dataExtractorFactory.newExtractor(300L, 500L)).thenReturn(subExtactor1).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     verify(dataExtractorFactory).newExtractor(300L, 500L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;24;;public void testExtractionGivenAutoChunkAndTotalTimeRangeSmallerThanChunk() throws IOException {     chunkSpan = null.     scrollSize = 1000.     TestDataExtractor extractor = new TestDataExtractor(1L, 101L).     // 100 millis * 1000 * 10 / 10 docs = 100000     extractor.setNextResponse(createSearchResponse(10L, 1L, 101L)).     InputStream inputStream1 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1).     when(dataExtractorFactory.newExtractor(1L, 101L)).thenReturn(subExtactor1).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     verify(dataExtractorFactory).newExtractor(1L, 101L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;45;;public void testExtractionGivenAutoChunkAndIntermediateEmptySearchShouldReconfigure() throws IOException {     chunkSpan = null.     scrollSize = 500.     TestDataExtractor extractor = new TestDataExtractor(100000L, 400000L).     // 300K millis * 500 * 10 / 15K docs = 100000     extractor.setNextResponse(createSearchResponse(15000L, 100000L, 400000L)).     InputStream inputStream1 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1).     when(dataExtractorFactory.newExtractor(100000L, 200000L)).thenReturn(subExtactor1).     // This one is empty     DataExtractor subExtactor2 = new StubSubExtractor().     when(dataExtractorFactory.newExtractor(200000, 300000L)).thenReturn(subExtactor2).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     // Now we have: 200K millis * 500 * 10 / 5K docs = 200000     extractor.setNextResponse(createSearchResponse(5000, 200000L, 400000L)).     // This is the last one     InputStream inputStream2 = mock(InputStream.class).     DataExtractor subExtactor3 = new StubSubExtractor(inputStream2).     when(dataExtractorFactory.newExtractor(200000, 400000)).thenReturn(subExtactor3).     assertEquals(inputStream2, extractor.next().get()).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     verify(dataExtractorFactory).newExtractor(100000L, 200000L).     verify(dataExtractorFactory).newExtractor(200000L, 300000L).     verify(dataExtractorFactory).newExtractor(200000L, 400000L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory).     assertThat(capturedSearchRequests.size(), equalTo(2)).     String searchRequest = capturedSearchRequests.get(0).toString().replaceAll("\\s", "").     assertThat(searchRequest, containsString("\"from\":100000,\"to\":400000")).     searchRequest = capturedSearchRequests.get(1).toString().replaceAll("\\s", "").     assertThat(searchRequest, containsString("\"from\":200000,\"to\":400000")). }
false;public;0;18;;public void testCancelGivenNextWasNeverCalled() {     chunkSpan = TimeValue.timeValueSeconds(1).     TestDataExtractor extractor = new TestDataExtractor(1000L, 2300L).     extractor.setNextResponse(createSearchResponse(10L, 1000L, 2200L)).     InputStream inputStream1 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1).     when(dataExtractorFactory.newExtractor(1000L, 2000L)).thenReturn(subExtactor1).     assertThat(extractor.hasNext(), is(true)).     extractor.cancel().     assertThat(extractor.isCancelled(), is(true)).     assertThat(extractor.hasNext(), is(false)).     Mockito.verifyNoMoreInteractions(dataExtractorFactory). }
false;public;0;26;;public void testCancelGivenCurrentSubExtractorHasMore() throws IOException {     chunkSpan = TimeValue.timeValueSeconds(1).     TestDataExtractor extractor = new TestDataExtractor(1000L, 2300L).     extractor.setNextResponse(createSearchResponse(10L, 1000L, 2200L)).     InputStream inputStream1 = mock(InputStream.class).     InputStream inputStream2 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1, inputStream2).     when(dataExtractorFactory.newExtractor(1000L, 2000L)).thenReturn(subExtactor1).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     extractor.cancel().     assertThat(extractor.isCancelled(), is(true)).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream2, extractor.next().get()).     assertThat(extractor.hasNext(), is(true)).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     verify(dataExtractorFactory).newExtractor(1000L, 2000L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory). }
false;public;0;23;;public void testCancelGivenCurrentSubExtractorIsDone() throws IOException {     chunkSpan = TimeValue.timeValueSeconds(1).     TestDataExtractor extractor = new TestDataExtractor(1000L, 2300L).     extractor.setNextResponse(createSearchResponse(10L, 1000L, 2200L)).     InputStream inputStream1 = mock(InputStream.class).     DataExtractor subExtactor1 = new StubSubExtractor(inputStream1).     when(dataExtractorFactory.newExtractor(1000L, 2000L)).thenReturn(subExtactor1).     assertThat(extractor.hasNext(), is(true)).     assertEquals(inputStream1, extractor.next().get()).     extractor.cancel().     assertThat(extractor.isCancelled(), is(true)).     assertThat(extractor.hasNext(), is(true)).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     verify(dataExtractorFactory).newExtractor(1000L, 2000L).     Mockito.verifyNoMoreInteractions(dataExtractorFactory). }
false;public;0;8;;public void testDataSummaryRequestIsNotOk() {     chunkSpan = TimeValue.timeValueSeconds(2).     TestDataExtractor extractor = new TestDataExtractor(1000L, 2300L).     extractor.setNextResponse(createErrorResponse()).     assertThat(extractor.hasNext(), is(true)).     expectThrows(IOException.class, extractor::next). }
false;public;0;8;;public void testDataSummaryRequestHasShardFailures() {     chunkSpan = TimeValue.timeValueSeconds(2).     TestDataExtractor extractor = new TestDataExtractor(1000L, 2300L).     extractor.setNextResponse(createResponseWithShardFailures()).     assertThat(extractor.hasNext(), is(true)).     expectThrows(IOException.class, extractor::next). }
false;private;3;20;;private SearchResponse createSearchResponse(long totalHits, long earliestTime, long latestTime) {     SearchResponse searchResponse = mock(SearchResponse.class).     when(searchResponse.status()).thenReturn(RestStatus.OK).     SearchHit[] hits = new SearchHit[(int) totalHits].     SearchHits searchHits = new SearchHits(hits, new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO), 1).     when(searchResponse.getHits()).thenReturn(searchHits).     List<Aggregation> aggs = new ArrayList<>().     Min min = mock(Min.class).     when(min.getValue()).thenReturn((double) earliestTime).     when(min.getName()).thenReturn("earliest_time").     aggs.add(min).     Max max = mock(Max.class).     when(max.getValue()).thenReturn((double) latestTime).     when(max.getName()).thenReturn("latest_time").     aggs.add(max).     Aggregations aggregations = new Aggregations(aggs) {     }.     when(searchResponse.getAggregations()).thenReturn(aggregations).     return searchResponse. }
false;private;0;20;;private SearchResponse createNullSearchResponse() {     SearchResponse searchResponse = mock(SearchResponse.class).     when(searchResponse.status()).thenReturn(RestStatus.OK).     SearchHit[] hits = new SearchHit[0].     SearchHits searchHits = new SearchHits(hits, new TotalHits(0, TotalHits.Relation.EQUAL_TO), 1).     when(searchResponse.getHits()).thenReturn(searchHits).     List<Aggregation> aggs = new ArrayList<>().     Min min = mock(Min.class).     when(min.getValue()).thenReturn(Double.POSITIVE_INFINITY).     when(min.getName()).thenReturn("earliest_time").     aggs.add(min).     Max max = mock(Max.class).     when(max.getValue()).thenReturn(Double.POSITIVE_INFINITY).     when(max.getName()).thenReturn("latest_time").     aggs.add(max).     Aggregations aggregations = new Aggregations(aggs) {     }.     when(searchResponse.getAggregations()).thenReturn(aggregations).     return searchResponse. }
false;private;0;5;;private SearchResponse createErrorResponse() {     SearchResponse searchResponse = mock(SearchResponse.class).     when(searchResponse.status()).thenReturn(RestStatus.INTERNAL_SERVER_ERROR).     return searchResponse. }
false;private;0;7;;private SearchResponse createResponseWithShardFailures() {     SearchResponse searchResponse = mock(SearchResponse.class).     when(searchResponse.status()).thenReturn(RestStatus.OK).     when(searchResponse.getShardFailures()).thenReturn(new ShardSearchFailure[] { new ShardSearchFailure(new RuntimeException("shard failed")) }).     return searchResponse. }
false;private;2;3;;private ChunkedDataExtractorContext createContext(long start, long end) {     return createContext(start, end, false, null). }
false;private;4;4;;private ChunkedDataExtractorContext createContext(long start, long end, boolean hasAggregations, Long histogramInterval) {     return new ChunkedDataExtractorContext(jobId, timeField, indices, query, scrollSize, start, end, chunkSpan, ChunkedDataExtractorFactory.newIdentityTimeAligner(), Collections.emptyMap(), hasAggregations, histogramInterval). }
false;public;0;4;;@Override public boolean hasNext() {     return hasNext. }
false;public;0;8;;@Override public Optional<InputStream> next() {     if (streams.isEmpty()) {         hasNext = false.         return Optional.empty().     }     return Optional.of(streams.remove(0)). }
false;public;0;4;;@Override public boolean isCancelled() {     return false. }
false;public;0;4;;@Override public void cancel() { // do nothing }
