commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected SearchResponse executeSearchRequest(SearchRequestBuilder searchRequestBuilder) {     capturedSearchRequests.add(searchRequestBuilder).     return nextResponse. }
false;;1;3;;void setNextResponse(SearchResponse searchResponse) {     nextResponse = searchResponse. }
false;public;0;15;;@Before public void setUpTests() {     testClient = mock(Client.class).     capturedSearchRequests = new ArrayList<>().     jobId = "test-job".     timeField = "time".     fields = new HashSet<>().     fields.addAll(Arrays.asList("time", "airline", "responsetime")).     indices = Arrays.asList("index-1", "index-2").     query = QueryBuilders.matchAllQuery().     aggs = new AggregatorFactories.Builder().addAggregator(AggregationBuilders.histogram("time").field("time").interval(1000).subAggregation(AggregationBuilders.terms("airline").field("airline").subAggregation(AggregationBuilders.avg("responsetime").field("responsetime")))). }
false;public;0;35;;public void testExtraction() throws IOException {     List<Histogram.Bucket> histogramBuckets = Arrays.asList(createHistogramBucket(1000L, 3, Arrays.asList(createMax("time", 1999), createTerms("airline", new Term("a", 1, "responsetime", 11.0), new Term("b", 2, "responsetime", 12.0)))), createHistogramBucket(2000L, 0, Collections.emptyList()), createHistogramBucket(3000L, 7, Arrays.asList(createMax("time", 3999), createTerms("airline", new Term("c", 4, "responsetime", 31.0), new Term("b", 3, "responsetime", 32.0))))).     TestDataExtractor extractor = new TestDataExtractor(1000L, 4000L).     SearchResponse response = createSearchResponse("time", histogramBuckets).     extractor.setNextResponse(response).     assertThat(extractor.hasNext(), is(true)).     Optional<InputStream> stream = extractor.next().     assertThat(stream.isPresent(), is(true)).     String expectedStream = "{\"time\":1999,\"airline\":\"a\",\"responsetime\":11.0,\"doc_count\":1} " + "{\"time\":1999,\"airline\":\"b\",\"responsetime\":12.0,\"doc_count\":2} " + "{\"time\":3999,\"airline\":\"c\",\"responsetime\":31.0,\"doc_count\":4} " + "{\"time\":3999,\"airline\":\"b\",\"responsetime\":32.0,\"doc_count\":3}".     assertThat(asString(stream.get()), equalTo(expectedStream)).     assertThat(extractor.hasNext(), is(false)).     assertThat(capturedSearchRequests.size(), equalTo(1)).     String searchRequest = capturedSearchRequests.get(0).toString().replaceAll("\\s", "").     assertThat(searchRequest, containsString("\"size\":0")).     assertThat(searchRequest, containsString("\"query\":{\"bool\":{\"filter\":[{\"match_all\":{\"boost\":1.0}}," + "{\"range\":{\"time\":{\"from\":0,\"to\":4000,\"include_lower\":true,\"include_upper\":false," + "\"format\":\"epoch_millis\",\"boost\":1.0}}}]")).     assertThat(searchRequest, stringContainsInOrder(Arrays.asList("aggregations", "histogram", "time", "terms", "airline", "avg", "responsetime"))). }
false;public;0;31;;public void testExtractionGivenMultipleBatches() throws IOException {     // Each bucket is 4 key-value pairs and there are 2 terms, thus 600 buckets will be 600 * 4 * 2 = 4800     // key-value pairs. They should be processed in 5 batches.     int buckets = 600.     List<Histogram.Bucket> histogramBuckets = new ArrayList<>(buckets).     long timestamp = 1000.     for (int i = 0. i < buckets. i++) {         histogramBuckets.add(createHistogramBucket(timestamp, 3, Arrays.asList(createMax("time", timestamp), createTerms("airline", new Term("c", 4, "responsetime", 31.0), new Term("b", 3, "responsetime", 32.0))))).         timestamp += 1000L.     }     TestDataExtractor extractor = new TestDataExtractor(1000L, timestamp + 1).     SearchResponse response = createSearchResponse("time", histogramBuckets).     extractor.setNextResponse(response).     assertThat(extractor.hasNext(), is(true)).     assertThat(countMatches('{', asString(extractor.next().get())), equalTo(250L)).     assertThat(extractor.hasNext(), is(true)).     assertThat(countMatches('{', asString(extractor.next().get())), equalTo(250L)).     assertThat(extractor.hasNext(), is(true)).     assertThat(countMatches('{', asString(extractor.next().get())), equalTo(250L)).     assertThat(extractor.hasNext(), is(true)).     assertThat(countMatches('{', asString(extractor.next().get())), equalTo(250L)).     assertThat(extractor.hasNext(), is(true)).     assertThat(countMatches('{', asString(extractor.next().get())), equalTo(200L)).     assertThat(extractor.hasNext(), is(false)).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;12;;public void testExtractionGivenResponseHasNullAggs() throws IOException {     TestDataExtractor extractor = new TestDataExtractor(1000L, 2000L).     SearchResponse response = createSearchResponse(null).     extractor.setNextResponse(response).     assertThat(extractor.hasNext(), is(true)).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;12;;public void testExtractionGivenResponseHasEmptyAggs() throws IOException {     TestDataExtractor extractor = new TestDataExtractor(1000L, 2000L).     Aggregations emptyAggs = AggregationTestUtils.createAggs(Collections.emptyList()).     SearchResponse response = createSearchResponse(emptyAggs).     extractor.setNextResponse(response).     assertThat(extractor.hasNext(), is(true)).     assertThat(extractor.next().isPresent(), is(false)).     assertThat(extractor.hasNext(), is(false)).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;16;;public void testExtractionGivenResponseHasMultipleTopLevelAggs() {     TestDataExtractor extractor = new TestDataExtractor(1000L, 2000L).     Histogram histogram1 = mock(Histogram.class).     when(histogram1.getName()).thenReturn("hist_1").     Histogram histogram2 = mock(Histogram.class).     when(histogram2.getName()).thenReturn("hist_2").     Aggregations aggs = AggregationTestUtils.createAggs(Arrays.asList(histogram1, histogram2)).     SearchResponse response = createSearchResponse(aggs).     extractor.setNextResponse(response).     assertThat(extractor.hasNext(), is(true)).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, extractor::next).     assertThat(e.getMessage(), containsString("Multiple top level aggregations not supported. found: [hist_1, hist_2]")). }
false;public;0;8;;public void testExtractionGivenCancelBeforeNext() {     TestDataExtractor extractor = new TestDataExtractor(1000L, 4000L).     SearchResponse response = createSearchResponse("time", Collections.emptyList()).     extractor.setNextResponse(response).     extractor.cancel().     assertThat(extractor.hasNext(), is(false)). }
false;public;0;28;;public void testExtractionGivenCancelHalfWay() throws IOException {     int buckets = 1200.     List<Histogram.Bucket> histogramBuckets = new ArrayList<>(buckets).     long timestamp = 1000.     for (int i = 0. i < buckets. i++) {         histogramBuckets.add(createHistogramBucket(timestamp, 3, Arrays.asList(createMax("time", timestamp), createTerms("airline", new Term("c", 4, "responsetime", 31.0), new Term("b", 3, "responsetime", 32.0))))).         timestamp += 1000L.     }     TestDataExtractor extractor = new TestDataExtractor(1000L, timestamp + 1).     SearchResponse response = createSearchResponse("time", histogramBuckets).     extractor.setNextResponse(response).     assertThat(extractor.hasNext(), is(true)).     assertThat(countMatches('{', asString(extractor.next().get())), equalTo(250L)).     assertThat(extractor.hasNext(), is(true)).     assertThat(countMatches('{', asString(extractor.next().get())), equalTo(250L)).     assertThat(extractor.hasNext(), is(true)).     extractor.cancel().     assertThat(extractor.hasNext(), is(false)).     assertThat(extractor.isCancelled(), is(true)).     assertThat(capturedSearchRequests.size(), equalTo(1)). }
false;public;0;7;;public void testExtractionGivenSearchResponseHasError() throws IOException {     TestDataExtractor extractor = new TestDataExtractor(1000L, 2000L).     extractor.setNextResponse(createErrorResponse()).     assertThat(extractor.hasNext(), is(true)).     expectThrows(IOException.class, extractor::next). }
false;public;0;7;;public void testExtractionGivenSearchResponseHasShardFailures() {     TestDataExtractor extractor = new TestDataExtractor(1000L, 2000L).     extractor.setNextResponse(createResponseWithShardFailures()).     assertThat(extractor.hasNext(), is(true)).     expectThrows(IOException.class, extractor::next). }
false;public;0;8;;public void testExtractionGivenInitSearchResponseEncounteredUnavailableShards() {     TestDataExtractor extractor = new TestDataExtractor(1000L, 2000L).     extractor.setNextResponse(createResponseWithUnavailableShards(2)).     assertThat(extractor.hasNext(), is(true)).     IOException e = expectThrows(IOException.class, extractor::next).     assertThat(e.getMessage(), equalTo("[" + jobId + "] Search request encountered [2] unavailable shards")). }
false;private;2;4;;private AggregationDataExtractorContext createContext(long start, long end) {     return new AggregationDataExtractorContext(jobId, timeField, fields, indices, query, aggs, start, end, true, Collections.emptyMap()). }
false;private;2;9;;@SuppressWarnings("unchecked") private SearchResponse createSearchResponse(String histogramName, List<Histogram.Bucket> histogramBuckets) {     Histogram histogram = mock(Histogram.class).     when(histogram.getName()).thenReturn(histogramName).     when((List<Histogram.Bucket>) histogram.getBuckets()).thenReturn(histogramBuckets).     Aggregations searchAggs = AggregationTestUtils.createAggs(Collections.singletonList(histogram)).     return createSearchResponse(searchAggs). }
false;private;1;7;;private SearchResponse createSearchResponse(Aggregations aggregations) {     SearchResponse searchResponse = mock(SearchResponse.class).     when(searchResponse.status()).thenReturn(RestStatus.OK).     when(searchResponse.getScrollId()).thenReturn(randomAlphaOfLength(1000)).     when(searchResponse.getAggregations()).thenReturn(aggregations).     return searchResponse. }
false;private;0;5;;private SearchResponse createErrorResponse() {     SearchResponse searchResponse = mock(SearchResponse.class).     when(searchResponse.status()).thenReturn(RestStatus.INTERNAL_SERVER_ERROR).     return searchResponse. }
false;private;0;7;;private SearchResponse createResponseWithShardFailures() {     SearchResponse searchResponse = mock(SearchResponse.class).     when(searchResponse.status()).thenReturn(RestStatus.OK).     when(searchResponse.getShardFailures()).thenReturn(new ShardSearchFailure[] { new ShardSearchFailure(new RuntimeException("shard failed")) }).     return searchResponse. }
false;private;1;7;;private SearchResponse createResponseWithUnavailableShards(int unavailableShards) {     SearchResponse searchResponse = mock(SearchResponse.class).     when(searchResponse.status()).thenReturn(RestStatus.OK).     when(searchResponse.getSuccessfulShards()).thenReturn(3).     when(searchResponse.getTotalShards()).thenReturn(3 + unavailableShards).     return searchResponse. }
false;private,static;1;5;;private static String asString(InputStream inputStream) throws IOException {     try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {         return reader.lines().collect(Collectors.joining("\n")).     } }
false;private,static;2;3;;private static long countMatches(char c, String text) {     return text.chars().filter(current -> current == c).count(). }
