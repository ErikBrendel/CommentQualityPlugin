# id;timestamp;commentText;codeText;commentWords;codeWords
MlMemoryTracker -> public Long getJobMemoryRequirement(String jobId);1545155131;Get the memory requirement for a job._This method only works on the master node._@param jobId The job ID._@return The memory requirement of the job specified by {@code jobId},_or <code>null</code> if it cannot be calculated.;public Long getJobMemoryRequirement(String jobId) {__        if (isMaster == false) {_            return null__        }__        Long memoryRequirement = memoryRequirementByJob.get(jobId)__        if (memoryRequirement != null) {_            return memoryRequirement__        }__        return null__    };get,the,memory,requirement,for,a,job,this,method,only,works,on,the,master,node,param,job,id,the,job,id,return,the,memory,requirement,of,the,job,specified,by,code,job,id,or,code,null,code,if,it,cannot,be,calculated;public,long,get,job,memory,requirement,string,job,id,if,is,master,false,return,null,long,memory,requirement,memory,requirement,by,job,get,job,id,if,memory,requirement,null,return,memory,requirement,return,null
MlMemoryTracker -> public Long getJobMemoryRequirement(String jobId);1547141280;Get the memory requirement for a job._This method only works on the master node._@param jobId The job ID._@return The memory requirement of the job specified by {@code jobId},_or <code>null</code> if it cannot be calculated.;public Long getJobMemoryRequirement(String jobId) {__        if (isMaster == false) {_            return null__        }__        Long memoryRequirement = memoryRequirementByJob.get(jobId)__        if (memoryRequirement != null) {_            return memoryRequirement__        }__        return null__    };get,the,memory,requirement,for,a,job,this,method,only,works,on,the,master,node,param,job,id,the,job,id,return,the,memory,requirement,of,the,job,specified,by,code,job,id,or,code,null,code,if,it,cannot,be,calculated;public,long,get,job,memory,requirement,string,job,id,if,is,master,false,return,null,long,memory,requirement,memory,requirement,by,job,get,job,id,if,memory,requirement,null,return,memory,requirement,return,null
MlMemoryTracker -> public Long getJobMemoryRequirement(String jobId);1550589070;Get the memory requirement for a job._This method only works on the master node._@param jobId The job ID._@return The memory requirement of the job specified by {@code jobId},_or <code>null</code> if it cannot be calculated.;public Long getJobMemoryRequirement(String jobId) {__        if (isMaster == false) {_            return null__        }__        Long memoryRequirement = memoryRequirementByJob.get(jobId)__        if (memoryRequirement != null) {_            return memoryRequirement__        }__        return null__    };get,the,memory,requirement,for,a,job,this,method,only,works,on,the,master,node,param,job,id,the,job,id,return,the,memory,requirement,of,the,job,specified,by,code,job,id,or,code,null,code,if,it,cannot,be,calculated;public,long,get,job,memory,requirement,string,job,id,if,is,master,false,return,null,long,memory,requirement,memory,requirement,by,job,get,job,id,if,memory,requirement,null,return,memory,requirement,return,null
MlMemoryTracker -> public boolean asyncRefresh();1545155131;Uses a separate thread to refresh the memory requirement for every ML job that has_a corresponding persistent task.  This method only works on the master node._@return <code>true</code> if the async refresh is scheduled, and <code>false</code>_if this is not possible for some reason.;public boolean asyncRefresh() {__        if (isMaster) {_            try {_                ActionListener<Void> listener = ActionListener.wrap(_                    aVoid -> logger.trace("Job memory requirement refresh request completed successfully"),_                    e -> logger.error("Failed to refresh job memory requirements", e)_                )__                threadPool.executor(executorName()).execute(_                    () -> refresh(clusterService.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE), listener))__                return true__            } catch (EsRejectedExecutionException e) {_                logger.debug("Couldn't schedule ML memory update - node might be shutting down", e)__            }_        }__        return false__    };uses,a,separate,thread,to,refresh,the,memory,requirement,for,every,ml,job,that,has,a,corresponding,persistent,task,this,method,only,works,on,the,master,node,return,code,true,code,if,the,async,refresh,is,scheduled,and,code,false,code,if,this,is,not,possible,for,some,reason;public,boolean,async,refresh,if,is,master,try,action,listener,void,listener,action,listener,wrap,a,void,logger,trace,job,memory,requirement,refresh,request,completed,successfully,e,logger,error,failed,to,refresh,job,memory,requirements,e,thread,pool,executor,executor,name,execute,refresh,cluster,service,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,listener,return,true,catch,es,rejected,execution,exception,e,logger,debug,couldn,t,schedule,ml,memory,update,node,might,be,shutting,down,e,return,false
MlMemoryTracker -> public boolean asyncRefresh();1547141280;Uses a separate thread to refresh the memory requirement for every ML job that has_a corresponding persistent task.  This method only works on the master node._@return <code>true</code> if the async refresh is scheduled, and <code>false</code>_if this is not possible for some reason.;public boolean asyncRefresh() {__        if (isMaster) {_            try {_                ActionListener<Void> listener = ActionListener.wrap(_                    aVoid -> logger.trace("Job memory requirement refresh request completed successfully"),_                    e -> logger.error("Failed to refresh job memory requirements", e)_                )__                threadPool.executor(executorName()).execute(_                    () -> refresh(clusterService.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE), listener))__                return true__            } catch (EsRejectedExecutionException e) {_                logger.debug("Couldn't schedule ML memory update - node might be shutting down", e)__            }_        }__        return false__    };uses,a,separate,thread,to,refresh,the,memory,requirement,for,every,ml,job,that,has,a,corresponding,persistent,task,this,method,only,works,on,the,master,node,return,code,true,code,if,the,async,refresh,is,scheduled,and,code,false,code,if,this,is,not,possible,for,some,reason;public,boolean,async,refresh,if,is,master,try,action,listener,void,listener,action,listener,wrap,a,void,logger,trace,job,memory,requirement,refresh,request,completed,successfully,e,logger,error,failed,to,refresh,job,memory,requirements,e,thread,pool,executor,executor,name,execute,refresh,cluster,service,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,listener,return,true,catch,es,rejected,execution,exception,e,logger,debug,couldn,t,schedule,ml,memory,update,node,might,be,shutting,down,e,return,false
MlMemoryTracker -> public boolean asyncRefresh();1550589070;Uses a separate thread to refresh the memory requirement for every ML job that has_a corresponding persistent task.  This method only works on the master node._@return <code>true</code> if the async refresh is scheduled, and <code>false</code>_if this is not possible for some reason.;public boolean asyncRefresh() {__        if (isMaster) {_            try {_                ActionListener<Void> listener = ActionListener.wrap(_                    aVoid -> logger.trace("Job memory requirement refresh request completed successfully"),_                    e -> logger.warn("Failed to refresh job memory requirements", e)_                )__                threadPool.executor(executorName()).execute(_                    () -> refresh(clusterService.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE), listener))__                return true__            } catch (EsRejectedExecutionException e) {_                logger.warn("Couldn't schedule ML memory update - node might be shutting down", e)__            }_        }__        return false__    };uses,a,separate,thread,to,refresh,the,memory,requirement,for,every,ml,job,that,has,a,corresponding,persistent,task,this,method,only,works,on,the,master,node,return,code,true,code,if,the,async,refresh,is,scheduled,and,code,false,code,if,this,is,not,possible,for,some,reason;public,boolean,async,refresh,if,is,master,try,action,listener,void,listener,action,listener,wrap,a,void,logger,trace,job,memory,requirement,refresh,request,completed,successfully,e,logger,warn,failed,to,refresh,job,memory,requirements,e,thread,pool,executor,executor,name,execute,refresh,cluster,service,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,listener,return,true,catch,es,rejected,execution,exception,e,logger,warn,couldn,t,schedule,ml,memory,update,node,might,be,shutting,down,e,return,false
MlMemoryTracker -> public void refreshJobMemoryAndAllOthers(String jobId, ActionListener<Long> listener);1545155131;This refreshes the memory requirement for every ML job that has a corresponding_persistent task and, in addition, one job that doesn't have a persistent task._This method only works on the master node._@param jobId The job ID of the job whose memory requirement is to be refreshed_despite not having a corresponding persistent task._@param listener Receives the memory requirement of the job specified by {@code jobId},_or <code>null</code> if it cannot be calculated.;public void refreshJobMemoryAndAllOthers(String jobId, ActionListener<Long> listener) {__        if (isMaster == false) {_            listener.onResponse(null)__            return__        }__        PersistentTasksCustomMetaData persistentTasks = clusterService.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        refresh(persistentTasks, ActionListener.wrap(aVoid -> refreshJobMemory(jobId, listener), listener::onFailure))__    };this,refreshes,the,memory,requirement,for,every,ml,job,that,has,a,corresponding,persistent,task,and,in,addition,one,job,that,doesn,t,have,a,persistent,task,this,method,only,works,on,the,master,node,param,job,id,the,job,id,of,the,job,whose,memory,requirement,is,to,be,refreshed,despite,not,having,a,corresponding,persistent,task,param,listener,receives,the,memory,requirement,of,the,job,specified,by,code,job,id,or,code,null,code,if,it,cannot,be,calculated;public,void,refresh,job,memory,and,all,others,string,job,id,action,listener,long,listener,if,is,master,false,listener,on,response,null,return,persistent,tasks,custom,meta,data,persistent,tasks,cluster,service,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,refresh,persistent,tasks,action,listener,wrap,a,void,refresh,job,memory,job,id,listener,listener,on,failure
MlMemoryTracker -> public void refreshJobMemoryAndAllOthers(String jobId, ActionListener<Long> listener);1547141280;This refreshes the memory requirement for every ML job that has a corresponding_persistent task and, in addition, one job that doesn't have a persistent task._This method only works on the master node._@param jobId The job ID of the job whose memory requirement is to be refreshed_despite not having a corresponding persistent task._@param listener Receives the memory requirement of the job specified by {@code jobId},_or <code>null</code> if it cannot be calculated.;public void refreshJobMemoryAndAllOthers(String jobId, ActionListener<Long> listener) {__        if (isMaster == false) {_            listener.onResponse(null)__            return__        }__        PersistentTasksCustomMetaData persistentTasks = clusterService.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        refresh(persistentTasks, ActionListener.wrap(aVoid -> refreshJobMemory(jobId, listener), listener::onFailure))__    };this,refreshes,the,memory,requirement,for,every,ml,job,that,has,a,corresponding,persistent,task,and,in,addition,one,job,that,doesn,t,have,a,persistent,task,this,method,only,works,on,the,master,node,param,job,id,the,job,id,of,the,job,whose,memory,requirement,is,to,be,refreshed,despite,not,having,a,corresponding,persistent,task,param,listener,receives,the,memory,requirement,of,the,job,specified,by,code,job,id,or,code,null,code,if,it,cannot,be,calculated;public,void,refresh,job,memory,and,all,others,string,job,id,action,listener,long,listener,if,is,master,false,listener,on,response,null,return,persistent,tasks,custom,meta,data,persistent,tasks,cluster,service,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,refresh,persistent,tasks,action,listener,wrap,a,void,refresh,job,memory,job,id,listener,listener,on,failure
MlMemoryTracker -> public void refreshJobMemoryAndAllOthers(String jobId, ActionListener<Long> listener);1550589070;This refreshes the memory requirement for every ML job that has a corresponding_persistent task and, in addition, one job that doesn't have a persistent task._This method only works on the master node._@param jobId The job ID of the job whose memory requirement is to be refreshed_despite not having a corresponding persistent task._@param listener Receives the memory requirement of the job specified by {@code jobId},_or <code>null</code> if it cannot be calculated.;public void refreshJobMemoryAndAllOthers(String jobId, ActionListener<Long> listener) {__        if (isMaster == false) {_            listener.onResponse(null)__            return__        }__        PersistentTasksCustomMetaData persistentTasks = clusterService.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        refresh(persistentTasks, ActionListener.wrap(aVoid -> refreshJobMemory(jobId, listener), listener::onFailure))__    };this,refreshes,the,memory,requirement,for,every,ml,job,that,has,a,corresponding,persistent,task,and,in,addition,one,job,that,doesn,t,have,a,persistent,task,this,method,only,works,on,the,master,node,param,job,id,the,job,id,of,the,job,whose,memory,requirement,is,to,be,refreshed,despite,not,having,a,corresponding,persistent,task,param,listener,receives,the,memory,requirement,of,the,job,specified,by,code,job,id,or,code,null,code,if,it,cannot,be,calculated;public,void,refresh,job,memory,and,all,others,string,job,id,action,listener,long,listener,if,is,master,false,listener,on,response,null,return,persistent,tasks,custom,meta,data,persistent,tasks,cluster,service,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,refresh,persistent,tasks,action,listener,wrap,a,void,refresh,job,memory,job,id,listener,listener,on,failure
MlMemoryTracker -> public boolean isRecentlyRefreshed();1545155131;Is the information in this object sufficiently up to date_for valid task assignment decisions to be made using it?;public boolean isRecentlyRefreshed() {_        Instant localLastUpdateTime = lastUpdateTime__        return localLastUpdateTime != null &&_            localLastUpdateTime.plus(RECENT_UPDATE_THRESHOLD).plus(reassignmentRecheckInterval).isAfter(Instant.now())__    };is,the,information,in,this,object,sufficiently,up,to,date,for,valid,task,assignment,decisions,to,be,made,using,it;public,boolean,is,recently,refreshed,instant,local,last,update,time,last,update,time,return,local,last,update,time,null,local,last,update,time,plus,plus,reassignment,recheck,interval,is,after,instant,now
MlMemoryTracker -> public boolean isRecentlyRefreshed();1547141280;Is the information in this object sufficiently up to date_for valid task assignment decisions to be made using it?;public boolean isRecentlyRefreshed() {_        Instant localLastUpdateTime = lastUpdateTime__        return localLastUpdateTime != null &&_            localLastUpdateTime.plus(RECENT_UPDATE_THRESHOLD).plus(reassignmentRecheckInterval).isAfter(Instant.now())__    };is,the,information,in,this,object,sufficiently,up,to,date,for,valid,task,assignment,decisions,to,be,made,using,it;public,boolean,is,recently,refreshed,instant,local,last,update,time,last,update,time,return,local,last,update,time,null,local,last,update,time,plus,plus,reassignment,recheck,interval,is,after,instant,now
MlMemoryTracker -> public boolean isRecentlyRefreshed();1550589070;Is the information in this object sufficiently up to date_for valid task assignment decisions to be made using it?;public boolean isRecentlyRefreshed() {_        Instant localLastUpdateTime = lastUpdateTime__        return localLastUpdateTime != null &&_            localLastUpdateTime.plus(RECENT_UPDATE_THRESHOLD).plus(reassignmentRecheckInterval).isAfter(Instant.now())__    };is,the,information,in,this,object,sufficiently,up,to,date,for,valid,task,assignment,decisions,to,be,made,using,it;public,boolean,is,recently,refreshed,instant,local,last,update,time,last,update,time,return,local,last,update,time,null,local,last,update,time,plus,plus,reassignment,recheck,interval,is,after,instant,now
MlMemoryTracker -> public void removeJob(String jobId);1545155131;Remove any memory requirement that is stored for the specified job._It doesn't matter if this method is called for a job that doesn't have_a stored memory requirement.;public void removeJob(String jobId) {_        memoryRequirementByJob.remove(jobId)__    };remove,any,memory,requirement,that,is,stored,for,the,specified,job,it,doesn,t,matter,if,this,method,is,called,for,a,job,that,doesn,t,have,a,stored,memory,requirement;public,void,remove,job,string,job,id,memory,requirement,by,job,remove,job,id
MlMemoryTracker -> public void removeJob(String jobId);1547141280;Remove any memory requirement that is stored for the specified job._It doesn't matter if this method is called for a job that doesn't have_a stored memory requirement.;public void removeJob(String jobId) {_        memoryRequirementByJob.remove(jobId)__    };remove,any,memory,requirement,that,is,stored,for,the,specified,job,it,doesn,t,matter,if,this,method,is,called,for,a,job,that,doesn,t,have,a,stored,memory,requirement;public,void,remove,job,string,job,id,memory,requirement,by,job,remove,job,id
MlMemoryTracker -> public void removeJob(String jobId);1550589070;Remove any memory requirement that is stored for the specified job._It doesn't matter if this method is called for a job that doesn't have_a stored memory requirement.;public void removeJob(String jobId) {_        memoryRequirementByJob.remove(jobId)__    };remove,any,memory,requirement,that,is,stored,for,the,specified,job,it,doesn,t,matter,if,this,method,is,called,for,a,job,that,doesn,t,have,a,stored,memory,requirement;public,void,remove,job,string,job,id,memory,requirement,by,job,remove,job,id
MlMemoryTracker -> void refresh(PersistentTasksCustomMetaData persistentTasks, ActionListener<Void> onCompletion);1545155131;This refreshes the memory requirement for every ML job that has a corresponding persistent task._It does NOT remove entries for jobs that no longer have a persistent task, because that would_lead to a race where a job was opened part way through the refresh.  (Instead, entries are removed_when jobs are deleted.);void refresh(PersistentTasksCustomMetaData persistentTasks, ActionListener<Void> onCompletion) {__        synchronized (fullRefreshCompletionListeners) {_            fullRefreshCompletionListeners.add(onCompletion)__            if (fullRefreshCompletionListeners.size() > 1) {_                _                return__            }_        }__        ActionListener<Void> refreshComplete = ActionListener.wrap(aVoid -> {_            lastUpdateTime = Instant.now()__            synchronized (fullRefreshCompletionListeners) {_                assert fullRefreshCompletionListeners.isEmpty() == false__                for (ActionListener<Void> listener : fullRefreshCompletionListeners) {_                    listener.onResponse(null)__                }_                fullRefreshCompletionListeners.clear()__            }_        }, onCompletion::onFailure)___        _        if (persistentTasks == null) {_            refreshComplete.onResponse(null)__        } else {_            List<PersistentTasksCustomMetaData.PersistentTask<?>> mlJobTasks = persistentTasks.tasks().stream()_                .filter(task -> MlTasks.JOB_TASK_NAME.equals(task.getTaskName())).collect(Collectors.toList())__            iterateMlJobTasks(mlJobTasks.iterator(), refreshComplete)__        }_    };this,refreshes,the,memory,requirement,for,every,ml,job,that,has,a,corresponding,persistent,task,it,does,not,remove,entries,for,jobs,that,no,longer,have,a,persistent,task,because,that,would,lead,to,a,race,where,a,job,was,opened,part,way,through,the,refresh,instead,entries,are,removed,when,jobs,are,deleted;void,refresh,persistent,tasks,custom,meta,data,persistent,tasks,action,listener,void,on,completion,synchronized,full,refresh,completion,listeners,full,refresh,completion,listeners,add,on,completion,if,full,refresh,completion,listeners,size,1,return,action,listener,void,refresh,complete,action,listener,wrap,a,void,last,update,time,instant,now,synchronized,full,refresh,completion,listeners,assert,full,refresh,completion,listeners,is,empty,false,for,action,listener,void,listener,full,refresh,completion,listeners,listener,on,response,null,full,refresh,completion,listeners,clear,on,completion,on,failure,if,persistent,tasks,null,refresh,complete,on,response,null,else,list,persistent,tasks,custom,meta,data,persistent,task,ml,job,tasks,persistent,tasks,tasks,stream,filter,task,ml,tasks,equals,task,get,task,name,collect,collectors,to,list,iterate,ml,job,tasks,ml,job,tasks,iterator,refresh,complete
MlMemoryTracker -> void refresh(PersistentTasksCustomMetaData persistentTasks, ActionListener<Void> onCompletion);1547141280;This refreshes the memory requirement for every ML job that has a corresponding persistent task._It does NOT remove entries for jobs that no longer have a persistent task, because that would_lead to a race where a job was opened part way through the refresh.  (Instead, entries are removed_when jobs are deleted.);void refresh(PersistentTasksCustomMetaData persistentTasks, ActionListener<Void> onCompletion) {__        synchronized (fullRefreshCompletionListeners) {_            fullRefreshCompletionListeners.add(onCompletion)__            if (fullRefreshCompletionListeners.size() > 1) {_                _                return__            }_        }__        ActionListener<Void> refreshComplete = ActionListener.wrap(aVoid -> {_            lastUpdateTime = Instant.now()__            synchronized (fullRefreshCompletionListeners) {_                assert fullRefreshCompletionListeners.isEmpty() == false__                for (ActionListener<Void> listener : fullRefreshCompletionListeners) {_                    listener.onResponse(null)__                }_                fullRefreshCompletionListeners.clear()__            }_        }, onCompletion::onFailure)___        _        if (persistentTasks == null) {_            refreshComplete.onResponse(null)__        } else {_            List<PersistentTasksCustomMetaData.PersistentTask<?>> mlJobTasks = persistentTasks.tasks().stream()_                .filter(task -> MlTasks.JOB_TASK_NAME.equals(task.getTaskName())).collect(Collectors.toList())__            iterateMlJobTasks(mlJobTasks.iterator(), refreshComplete)__        }_    };this,refreshes,the,memory,requirement,for,every,ml,job,that,has,a,corresponding,persistent,task,it,does,not,remove,entries,for,jobs,that,no,longer,have,a,persistent,task,because,that,would,lead,to,a,race,where,a,job,was,opened,part,way,through,the,refresh,instead,entries,are,removed,when,jobs,are,deleted;void,refresh,persistent,tasks,custom,meta,data,persistent,tasks,action,listener,void,on,completion,synchronized,full,refresh,completion,listeners,full,refresh,completion,listeners,add,on,completion,if,full,refresh,completion,listeners,size,1,return,action,listener,void,refresh,complete,action,listener,wrap,a,void,last,update,time,instant,now,synchronized,full,refresh,completion,listeners,assert,full,refresh,completion,listeners,is,empty,false,for,action,listener,void,listener,full,refresh,completion,listeners,listener,on,response,null,full,refresh,completion,listeners,clear,on,completion,on,failure,if,persistent,tasks,null,refresh,complete,on,response,null,else,list,persistent,tasks,custom,meta,data,persistent,task,ml,job,tasks,persistent,tasks,tasks,stream,filter,task,ml,tasks,equals,task,get,task,name,collect,collectors,to,list,iterate,ml,job,tasks,ml,job,tasks,iterator,refresh,complete
MlMemoryTracker -> void refresh(PersistentTasksCustomMetaData persistentTasks, ActionListener<Void> onCompletion);1550589070;This refreshes the memory requirement for every ML job that has a corresponding persistent task._It does NOT remove entries for jobs that no longer have a persistent task, because that would_lead to a race where a job was opened part way through the refresh.  (Instead, entries are removed_when jobs are deleted.);void refresh(PersistentTasksCustomMetaData persistentTasks, ActionListener<Void> onCompletion) {__        synchronized (fullRefreshCompletionListeners) {_            fullRefreshCompletionListeners.add(onCompletion)__            if (fullRefreshCompletionListeners.size() > 1) {_                _                return__            }_        }__        ActionListener<Void> refreshComplete = ActionListener.wrap(aVoid -> {_            lastUpdateTime = Instant.now()__            synchronized (fullRefreshCompletionListeners) {_                assert fullRefreshCompletionListeners.isEmpty() == false__                for (ActionListener<Void> listener : fullRefreshCompletionListeners) {_                    listener.onResponse(null)__                }_                fullRefreshCompletionListeners.clear()__            }_        }, onCompletion::onFailure)___        _        if (persistentTasks == null) {_            refreshComplete.onResponse(null)__        } else {_            List<PersistentTasksCustomMetaData.PersistentTask<?>> mlJobTasks = persistentTasks.tasks().stream()_                .filter(task -> MlTasks.JOB_TASK_NAME.equals(task.getTaskName())).collect(Collectors.toList())__            iterateMlJobTasks(mlJobTasks.iterator(), refreshComplete)__        }_    };this,refreshes,the,memory,requirement,for,every,ml,job,that,has,a,corresponding,persistent,task,it,does,not,remove,entries,for,jobs,that,no,longer,have,a,persistent,task,because,that,would,lead,to,a,race,where,a,job,was,opened,part,way,through,the,refresh,instead,entries,are,removed,when,jobs,are,deleted;void,refresh,persistent,tasks,custom,meta,data,persistent,tasks,action,listener,void,on,completion,synchronized,full,refresh,completion,listeners,full,refresh,completion,listeners,add,on,completion,if,full,refresh,completion,listeners,size,1,return,action,listener,void,refresh,complete,action,listener,wrap,a,void,last,update,time,instant,now,synchronized,full,refresh,completion,listeners,assert,full,refresh,completion,listeners,is,empty,false,for,action,listener,void,listener,full,refresh,completion,listeners,listener,on,response,null,full,refresh,completion,listeners,clear,on,completion,on,failure,if,persistent,tasks,null,refresh,complete,on,response,null,else,list,persistent,tasks,custom,meta,data,persistent,task,ml,job,tasks,persistent,tasks,tasks,stream,filter,task,ml,tasks,equals,task,get,task,name,collect,collectors,to,list,iterate,ml,job,tasks,ml,job,tasks,iterator,refresh,complete
MlMemoryTracker -> public void refreshJobMemory(String jobId, ActionListener<Long> listener);1545155131;Refresh the memory requirement for a single job._This method only works on the master node._@param jobId    The ID of the job to refresh the memory requirement for._@param listener Receives the job's memory requirement, or <code>null</code>_if it cannot be calculated.;public void refreshJobMemory(String jobId, ActionListener<Long> listener) {_        if (isMaster == false) {_            listener.onResponse(null)__            return__        }__        try {_            jobResultsProvider.getEstablishedMemoryUsage(jobId, null, null,_                establishedModelMemoryBytes -> {_                    if (establishedModelMemoryBytes <= 0L) {_                        setJobMemoryToLimit(jobId, listener)__                    } else {_                        Long memoryRequirementBytes = establishedModelMemoryBytes + Job.PROCESS_MEMORY_OVERHEAD.getBytes()__                        memoryRequirementByJob.put(jobId, memoryRequirementBytes)__                        listener.onResponse(memoryRequirementBytes)__                    }_                },_                e -> {_                    logger.error("[" + jobId + "] failed to calculate job established model memory requirement", e)__                    setJobMemoryToLimit(jobId, listener)__                }_            )__        } catch (Exception e) {_            logger.error("[" + jobId + "] failed to calculate job established model memory requirement", e)__            setJobMemoryToLimit(jobId, listener)__        }_    };refresh,the,memory,requirement,for,a,single,job,this,method,only,works,on,the,master,node,param,job,id,the,id,of,the,job,to,refresh,the,memory,requirement,for,param,listener,receives,the,job,s,memory,requirement,or,code,null,code,if,it,cannot,be,calculated;public,void,refresh,job,memory,string,job,id,action,listener,long,listener,if,is,master,false,listener,on,response,null,return,try,job,results,provider,get,established,memory,usage,job,id,null,null,established,model,memory,bytes,if,established,model,memory,bytes,0l,set,job,memory,to,limit,job,id,listener,else,long,memory,requirement,bytes,established,model,memory,bytes,job,get,bytes,memory,requirement,by,job,put,job,id,memory,requirement,bytes,listener,on,response,memory,requirement,bytes,e,logger,error,job,id,failed,to,calculate,job,established,model,memory,requirement,e,set,job,memory,to,limit,job,id,listener,catch,exception,e,logger,error,job,id,failed,to,calculate,job,established,model,memory,requirement,e,set,job,memory,to,limit,job,id,listener
MlMemoryTracker -> public void refreshJobMemory(String jobId, ActionListener<Long> listener);1547141280;Refresh the memory requirement for a single job._This method only works on the master node._@param jobId    The ID of the job to refresh the memory requirement for._@param listener Receives the job's memory requirement, or <code>null</code>_if it cannot be calculated.;public void refreshJobMemory(String jobId, ActionListener<Long> listener) {_        if (isMaster == false) {_            listener.onResponse(null)__            return__        }__        try {_            jobResultsProvider.getEstablishedMemoryUsage(jobId, null, null,_                establishedModelMemoryBytes -> {_                    if (establishedModelMemoryBytes <= 0L) {_                        setJobMemoryToLimit(jobId, listener)__                    } else {_                        Long memoryRequirementBytes = establishedModelMemoryBytes + Job.PROCESS_MEMORY_OVERHEAD.getBytes()__                        memoryRequirementByJob.put(jobId, memoryRequirementBytes)__                        listener.onResponse(memoryRequirementBytes)__                    }_                },_                e -> {_                    logger.error("[" + jobId + "] failed to calculate job established model memory requirement", e)__                    setJobMemoryToLimit(jobId, listener)__                }_            )__        } catch (Exception e) {_            logger.error("[" + jobId + "] failed to calculate job established model memory requirement", e)__            setJobMemoryToLimit(jobId, listener)__        }_    };refresh,the,memory,requirement,for,a,single,job,this,method,only,works,on,the,master,node,param,job,id,the,id,of,the,job,to,refresh,the,memory,requirement,for,param,listener,receives,the,job,s,memory,requirement,or,code,null,code,if,it,cannot,be,calculated;public,void,refresh,job,memory,string,job,id,action,listener,long,listener,if,is,master,false,listener,on,response,null,return,try,job,results,provider,get,established,memory,usage,job,id,null,null,established,model,memory,bytes,if,established,model,memory,bytes,0l,set,job,memory,to,limit,job,id,listener,else,long,memory,requirement,bytes,established,model,memory,bytes,job,get,bytes,memory,requirement,by,job,put,job,id,memory,requirement,bytes,listener,on,response,memory,requirement,bytes,e,logger,error,job,id,failed,to,calculate,job,established,model,memory,requirement,e,set,job,memory,to,limit,job,id,listener,catch,exception,e,logger,error,job,id,failed,to,calculate,job,established,model,memory,requirement,e,set,job,memory,to,limit,job,id,listener
MlMemoryTracker -> public void refreshJobMemory(String jobId, ActionListener<Long> listener);1550589070;Refresh the memory requirement for a single job._This method only works on the master node._@param jobId    The ID of the job to refresh the memory requirement for._@param listener Receives the job's memory requirement, or <code>null</code>_if it cannot be calculated.;public void refreshJobMemory(String jobId, ActionListener<Long> listener) {_        if (isMaster == false) {_            listener.onResponse(null)__            return__        }__        _        if (stopPhaser.register() != 0) {_            _            stopPhaser.arriveAndDeregister()__            listener.onFailure(new EsRejectedExecutionException("Couldn't run ML memory update - node is shutting down"))__            return__        }_        ActionListener<Long> phaserListener = ActionListener.wrap(_            r -> {_                stopPhaser.arriveAndDeregister()__                listener.onResponse(r)__            },_            e -> {_                stopPhaser.arriveAndDeregister()__                listener.onFailure(e)__            }_        )___        try {_            jobResultsProvider.getEstablishedMemoryUsage(jobId, null, null,_                establishedModelMemoryBytes -> {_                    if (establishedModelMemoryBytes <= 0L) {_                        setJobMemoryToLimit(jobId, phaserListener)__                    } else {_                        Long memoryRequirementBytes = establishedModelMemoryBytes + Job.PROCESS_MEMORY_OVERHEAD.getBytes()__                        memoryRequirementByJob.put(jobId, memoryRequirementBytes)__                        phaserListener.onResponse(memoryRequirementBytes)__                    }_                },_                e -> {_                    logger.error("[" + jobId + "] failed to calculate job established model memory requirement", e)__                    setJobMemoryToLimit(jobId, phaserListener)__                }_            )__        } catch (Exception e) {_            logger.error("[" + jobId + "] failed to calculate job established model memory requirement", e)__            setJobMemoryToLimit(jobId, phaserListener)__        }_    };refresh,the,memory,requirement,for,a,single,job,this,method,only,works,on,the,master,node,param,job,id,the,id,of,the,job,to,refresh,the,memory,requirement,for,param,listener,receives,the,job,s,memory,requirement,or,code,null,code,if,it,cannot,be,calculated;public,void,refresh,job,memory,string,job,id,action,listener,long,listener,if,is,master,false,listener,on,response,null,return,if,stop,phaser,register,0,stop,phaser,arrive,and,deregister,listener,on,failure,new,es,rejected,execution,exception,couldn,t,run,ml,memory,update,node,is,shutting,down,return,action,listener,long,phaser,listener,action,listener,wrap,r,stop,phaser,arrive,and,deregister,listener,on,response,r,e,stop,phaser,arrive,and,deregister,listener,on,failure,e,try,job,results,provider,get,established,memory,usage,job,id,null,null,established,model,memory,bytes,if,established,model,memory,bytes,0l,set,job,memory,to,limit,job,id,phaser,listener,else,long,memory,requirement,bytes,established,model,memory,bytes,job,get,bytes,memory,requirement,by,job,put,job,id,memory,requirement,bytes,phaser,listener,on,response,memory,requirement,bytes,e,logger,error,job,id,failed,to,calculate,job,established,model,memory,requirement,e,set,job,memory,to,limit,job,id,phaser,listener,catch,exception,e,logger,error,job,id,failed,to,calculate,job,established,model,memory,requirement,e,set,job,memory,to,limit,job,id,phaser,listener
