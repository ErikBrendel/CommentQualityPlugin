commented;modifiers;parameterAmount;loc;comment;code
true;public;1;14;/**  * The default path where named pipes will be created.  On *nix they can be created elsewhere  * (subject to security manager constraints), but on Windows this is the ONLY place they can  * be created.  * @return The directory prefix as a string.  */ ;/**  * The default path where named pipes will be created.  On *nix they can be created elsewhere  * (subject to security manager constraints), but on Windows this is the ONLY place they can  * be created.  * @return The directory prefix as a string.  */ public String getDefaultPipeDirectoryPrefix(Environment env) {     // the seemingly pointless . in the path used on Windows.     if (Constants.WINDOWS) {         return WIN_PIPE_PREFIX.     }     // also need to be changed.     return env.tmpFile().toString() + PathUtils.getDefaultFileSystem().getSeparator(). }
true;public;2;4;/**  * Open a named pipe created elsewhere for input.  *  * @param path  *            Path of named pipe to open.  * @param timeout  *            How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException  *             if the named pipe cannot be opened.  */ ;/**  * Open a named pipe created elsewhere for input.  *  * @param path  *            Path of named pipe to open.  * @param timeout  *            How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException  *             if the named pipe cannot be opened.  */ @SuppressForbidden(reason = "Environment doesn't have path for Windows named pipes") public InputStream openNamedPipeInputStream(String path, Duration timeout) throws IOException {     return openNamedPipeInputStream(PathUtils.get(path), timeout). }
true;public;2;39;/**  * Open a named pipe created elsewhere for input.  * @param file The named pipe to open.  * @param timeout How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException if the named pipe cannot be opened.  */ ;/**  * Open a named pipe created elsewhere for input.  * @param file The named pipe to open.  * @param timeout How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException if the named pipe cannot be opened.  */ public InputStream openNamedPipeInputStream(Path file, Duration timeout) throws IOException {     long timeoutMillisRemaining = timeout.toMillis().     // but luckily there's an even simpler check (that's not possible on *nix)     if (Constants.WINDOWS && !file.toString().startsWith(WIN_PIPE_PREFIX)) {         throw new IOException(file + " is not a named pipe").     }     SecurityManager sm = System.getSecurityManager().     if (sm != null) {         sm.checkPermission(new SpecialPermission()).     }     // it's still not available throw the exception from FileInputStream     while (true) {         // On Windows Files.isRegularFile() will render a genuine named pipe unusable         if (!Constants.WINDOWS && Files.isRegularFile(file)) {             throw new IOException(file + " is not a named pipe").         }         try {             PrivilegedInputPipeOpener privilegedInputPipeOpener = new PrivilegedInputPipeOpener(file).             return AccessController.doPrivileged(privilegedInputPipeOpener).         } catch (RuntimeException e) {             if (timeoutMillisRemaining <= 0) {                 propagatePrivilegedException(e).             }             long thisSleep = Math.min(timeoutMillisRemaining, PAUSE_TIME_MS).             timeoutMillisRemaining -= thisSleep.             try {                 Thread.sleep(thisSleep).             } catch (InterruptedException ie) {                 Thread.currentThread().interrupt().                 propagatePrivilegedException(e).             }         }     } }
true;public;2;4;/**  * Open a named pipe created elsewhere for output.  *  * @param path  *            Path of named pipe to open.  * @param timeout  *            How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException  *             if the named pipe cannot be opened.  */ ;/**  * Open a named pipe created elsewhere for output.  *  * @param path  *            Path of named pipe to open.  * @param timeout  *            How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException  *             if the named pipe cannot be opened.  */ @SuppressForbidden(reason = "Environment doesn't have path for Windows named pipes") public OutputStream openNamedPipeOutputStream(String path, Duration timeout) throws IOException {     return openNamedPipeOutputStream(PathUtils.get(path), timeout). }
true;public;2;6;/**  * Open a named pipe created elsewhere for output.  * @param file The named pipe to open.  * @param timeout How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException if the named pipe cannot be opened.  */ ;/**  * Open a named pipe created elsewhere for output.  * @param file The named pipe to open.  * @param timeout How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException if the named pipe cannot be opened.  */ public OutputStream openNamedPipeOutputStream(Path file, Duration timeout) throws IOException {     if (Constants.WINDOWS) {         return openNamedPipeOutputStreamWindows(file, timeout).     }     return openNamedPipeOutputStreamUnix(file, timeout). }
true;private;2;34;/**  * The logic here is very similar to that of opening an input stream, because on Windows  * Java cannot create a regular file when asked to open a named pipe that doesn't exist.  * @param file The named pipe to open.  * @param timeout How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException if the named pipe cannot be opened.  */ ;/**  * The logic here is very similar to that of opening an input stream, because on Windows  * Java cannot create a regular file when asked to open a named pipe that doesn't exist.  * @param file The named pipe to open.  * @param timeout How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException if the named pipe cannot be opened.  */ private OutputStream openNamedPipeOutputStreamWindows(Path file, Duration timeout) throws IOException {     long timeoutMillisRemaining = timeout.toMillis().     // Can't use File.isFile() on Windows, but luckily there's an even simpler check (that's not possible on *nix)     if (!file.toString().startsWith(WIN_PIPE_PREFIX)) {         throw new IOException(file + " is not a named pipe").     }     SecurityManager sm = System.getSecurityManager().     if (sm != null) {         sm.checkPermission(new SpecialPermission()).     }     // it's still not available throw the exception from FileOutputStream     while (true) {         try {             PrivilegedOutputPipeOpener privilegedOutputPipeOpener = new PrivilegedOutputPipeOpener(file).             return AccessController.doPrivileged(privilegedOutputPipeOpener).         } catch (RuntimeException e) {             if (timeoutMillisRemaining <= 0) {                 propagatePrivilegedException(e).             }             long thisSleep = Math.min(timeoutMillisRemaining, PAUSE_TIME_MS).             timeoutMillisRemaining -= thisSleep.             try {                 Thread.sleep(thisSleep).             } catch (InterruptedException ie) {                 Thread.currentThread().interrupt().                 propagatePrivilegedException(e).             }         }     } }
true;private;2;30;/**  * This has to use different logic to the input pipe case to avoid the danger of creating  * a regular file when the named pipe does not exist when the method is first called.  * @param file The named pipe to open.  * @param timeout How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException if the named pipe cannot be opened.  */ ;/**  * This has to use different logic to the input pipe case to avoid the danger of creating  * a regular file when the named pipe does not exist when the method is first called.  * @param file The named pipe to open.  * @param timeout How long to wait for the named pipe to exist.  * @return A stream opened to read from the named pipe.  * @throws IOException if the named pipe cannot be opened.  */ private OutputStream openNamedPipeOutputStreamUnix(Path file, Duration timeout) throws IOException {     long timeoutMillisRemaining = timeout.toMillis().     // it's still not available throw a FileNotFoundException     while (timeoutMillisRemaining > 0 && !Files.exists(file)) {         long thisSleep = Math.min(timeoutMillisRemaining, PAUSE_TIME_MS).         timeoutMillisRemaining -= thisSleep.         try {             Thread.sleep(thisSleep).         } catch (InterruptedException ie) {             Thread.currentThread().interrupt().             break.         }     }     if (Files.isRegularFile(file)) {         throw new IOException(file + " is not a named pipe").     }     if (!Files.exists(file)) {         throw new FileNotFoundException("Cannot open " + file + " (No such file or directory)").     }     return Files.newOutputStream(file). }
true;private;1;7;/**  * To work around the limitation that privileged actions cannot throw checked exceptions the classes  * below wrap IOExceptions in RuntimeExceptions.  If such an exception needs to be propagated back  * to a user of this class then it's nice if they get the original IOException rather than having  * it wrapped in a RuntimeException.  However, the privileged calls could also possibly throw other  * RuntimeExceptions, so this method accounts for this case too.  */ ;/**  * To work around the limitation that privileged actions cannot throw checked exceptions the classes  * below wrap IOExceptions in RuntimeExceptions.  If such an exception needs to be propagated back  * to a user of this class then it's nice if they get the original IOException rather than having  * it wrapped in a RuntimeException.  However, the privileged calls could also possibly throw other  * RuntimeExceptions, so this method accounts for this case too.  */ private void propagatePrivilegedException(RuntimeException e) throws IOException {     Throwable ioe = ExceptionsHelper.unwrap(e, IOException.class).     if (ioe != null) {         throw (IOException) ioe.     }     throw e. }
false;public;0;8;;@SuppressForbidden(reason = "Files.newInputStream doesn't work with Windows named pipes") public InputStream run() {     try {         return new FileInputStream(file.toString()).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public;0;8;;@SuppressForbidden(reason = "Files.newOutputStream doesn't work with Windows named pipes") public OutputStream run() {     try {         return new FileOutputStream(file.toString()).     } catch (IOException e) {         throw new RuntimeException(e).     } }
