commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public AutodetectBuilder referencedFilters(Set<MlFilter> filters) {     referencedFilters = filters.     return this. }
true;public;1;4;/**  * Set quantiles to restore the normalizer state if any.  *  * @param quantiles the quantiles  */ ;/**  * Set quantiles to restore the normalizer state if any.  *  * @param quantiles the quantiles  */ public AutodetectBuilder quantiles(Quantiles quantiles) {     this.quantiles = quantiles.     return this. }
false;public;1;4;;public AutodetectBuilder scheduledEvents(List<ScheduledEvent> scheduledEvents) {     this.scheduledEvents = scheduledEvents.     return this. }
true;public;0;12;/**  * Requests that the controller daemon start an autodetect process.  */ ;/**  * Requests that the controller daemon start an autodetect process.  */ public void build() throws IOException {     List<String> command = buildAutodetectCommand().     buildLimits(command).     buildModelPlotConfig(command).     buildQuantiles(command).     buildFieldConfig(command).     processPipes.addArgs(command).     controller.startProcess(command). }
true;;0;51;/**  * Visible for testing  */ ;/**  * Visible for testing  */ List<String> buildAutodetectCommand() {     List<String> command = new ArrayList<>().     command.add(AUTODETECT_PATH).     command.add(JOB_ID_ARG + job.getId()).     AnalysisConfig analysisConfig = job.getAnalysisConfig().     if (analysisConfig != null) {         addIfNotNull(analysisConfig.getBucketSpan(), BUCKET_SPAN_ARG, command).         addIfNotNull(analysisConfig.getLatency(), LATENCY_ARG, command).         addIfNotNull(analysisConfig.getSummaryCountFieldName(), SUMMARY_COUNT_FIELD_ARG, command).         if (Boolean.TRUE.equals(analysisConfig.getMultivariateByFields())) {             command.add(MULTIVARIATE_BY_FIELDS_ARG).         }     }     // Input is always length encoded     command.add(LENGTH_ENCODED_INPUT_ARG).     // Limit the number of output records     command.add(maxAnomalyRecordsArg(settings)).     // always set the time field     String timeFieldArg = TIME_FIELD_ARG + getTimeFieldOrDefault(job).     command.add(timeFieldArg).     int intervalStagger = calculateStaggeringInterval(job.getId()).     logger.debug("[{}] Periodic operations staggered by {} seconds", job.getId(), intervalStagger).     // persistence has been explicitly disabled.     if (DONT_PERSIST_MODEL_STATE_SETTING.get(settings)) {         logger.info("[{}] Will not persist model state - {} setting was set", job.getId(), DONT_PERSIST_MODEL_STATE_SETTING).     } else {         // Persist model state every few hours even if the job isn't closed         long persistInterval = (job.getBackgroundPersistInterval() == null) ? (DEFAULT_BASE_PERSIST_INTERVAL + intervalStagger) : job.getBackgroundPersistInterval().getSeconds().         command.add(PERSIST_INTERVAL_ARG + persistInterval).     }     int maxQuantileInterval = BASE_MAX_QUANTILE_INTERVAL + intervalStagger.     command.add(MAX_QUANTILE_INTERVAL_ARG + maxQuantileInterval).     if (ProcessBuilderUtils.modelConfigFilePresent(env)) {         String modelConfigFile = XPackPlugin.resolveConfigFile(env, ProcessBuilderUtils.ML_MODEL_CONF).toString().         command.add(MODEL_CONFIG_ARG + modelConfigFile).     }     return command. }
false;static;1;3;;static String maxAnomalyRecordsArg(Settings settings) {     return "--maxAnomalyRecords=" + MAX_ANOMALY_RECORDS_SETTING_DYNAMIC.get(settings). }
false;private,static;1;6;;private static String getTimeFieldOrDefault(Job job) {     DataDescription dataDescription = job.getDataDescription().     boolean useDefault = dataDescription == null || Strings.isNullOrEmpty(dataDescription.getTimeField()).     return useDefault ? DataDescription.DEFAULT_TIME_FIELD : dataDescription.getTimeField(). }
true;static;1;4;/**  * This random time of up to 1 hour is added to intervals at which we  * tell the C++ process to perform periodic operations.  This means that  * when there are many jobs there is a certain amount of staggering of  * their periodic operations.  A given job will always be given the same  * staggering interval (for a given JVM implementation).  *  * @param jobId The ID of the job to calculate the staggering interval for  * @return The staggering interval  */ ;/**  * This random time of up to 1 hour is added to intervals at which we  * tell the C++ process to perform periodic operations.  This means that  * when there are many jobs there is a certain amount of staggering of  * their periodic operations.  A given job will always be given the same  * staggering interval (for a given JVM implementation).  *  * @param jobId The ID of the job to calculate the staggering interval for  * @return The staggering interval  */ static int calculateStaggeringInterval(String jobId) {     Random rng = new Random(jobId.hashCode()).     return rng.nextInt(SECONDS_IN_HOUR). }
false;private;1;9;;private void buildLimits(List<String> command) throws IOException {     if (job.getAnalysisLimits() != null) {         Path limitConfigFile = Files.createTempFile(env.tmpFile(), "limitconfig", CONF_EXTENSION).         filesToDelete.add(limitConfigFile).         writeLimits(job.getAnalysisLimits(), limitConfigFile).         String limits = LIMIT_CONFIG_ARG + limitConfigFile.toString().         command.add(limits).     } }
true;private,static;2;6;/**  * Write the Ml autodetect model options to <code>emptyConfFile</code>.  */ ;/**  * Write the Ml autodetect model options to <code>emptyConfFile</code>.  */ private static void writeLimits(AnalysisLimits options, Path emptyConfFile) throws IOException {     try (OutputStreamWriter osw = new OutputStreamWriter(Files.newOutputStream(emptyConfFile), StandardCharsets.UTF_8)) {         new AnalysisLimitsWriter(options, osw).write().     } }
false;private;1;9;;private void buildModelPlotConfig(List<String> command) throws IOException {     if (job.getModelPlotConfig() != null) {         Path modelPlotConfigFile = Files.createTempFile(env.tmpFile(), "modelplotconfig", CONF_EXTENSION).         filesToDelete.add(modelPlotConfigFile).         writeModelPlotConfig(job.getModelPlotConfig(), modelPlotConfigFile).         String modelPlotConfig = MODEL_PLOT_CONFIG_ARG + modelPlotConfigFile.toString().         command.add(modelPlotConfig).     } }
false;private,static;2;8;;private static void writeModelPlotConfig(ModelPlotConfig config, Path emptyConfFile) throws IOException {     try (OutputStreamWriter osw = new OutputStreamWriter(Files.newOutputStream(emptyConfFile), StandardCharsets.UTF_8)) {         new ModelPlotConfigWriter(config, osw).write().     } }
false;private;1;11;;private void buildQuantiles(List<String> command) throws IOException {     if (quantiles != null && !quantiles.getQuantileState().isEmpty()) {         logger.info("Restoring quantiles for job '" + job.getId() + "'").         Path normalizersStateFilePath = writeNormalizerInitState(job.getId(), quantiles.getQuantileState(), env).         String quantilesStateFileArg = QUANTILES_STATE_PATH_ARG + normalizersStateFilePath.         command.add(quantilesStateFileArg).         command.add(DELETE_STATE_FILES_ARG).     } }
true;public,static;3;14;/**  * Write the normalizer init state to file.  */ ;/**  * Write the normalizer init state to file.  */ public static Path writeNormalizerInitState(String jobId, String state, Environment env) throws IOException {     // createTempFile has a race condition where it may return the same     // temporary file name to different threads if called simultaneously     // from multiple threads, hence add the thread ID to avoid this     Path stateFile = Files.createTempFile(env.tmpFile(), jobId + "_quantiles_" + Thread.currentThread().getId(), QUANTILES_FILE_EXTENSION).     try (BufferedWriter osw = Files.newBufferedWriter(stateFile, StandardCharsets.UTF_8)) {         osw.write(state).     }     return stateFile. }
false;private;1;15;;private void buildFieldConfig(List<String> command) throws IOException {     if (job.getAnalysisConfig() != null) {         // write to a temporary field config file         Path fieldConfigFile = Files.createTempFile(env.tmpFile(), "fieldconfig", CONF_EXTENSION).         filesToDelete.add(fieldConfigFile).         try (OutputStreamWriter osw = new OutputStreamWriter(Files.newOutputStream(fieldConfigFile), StandardCharsets.UTF_8)) {             new FieldConfigWriter(job.getAnalysisConfig(), referencedFilters, scheduledEvents, osw, logger).write().         }         String fieldConfig = FIELD_CONFIG_ARG + fieldConfigFile.toString().         command.add(fieldConfig).     } }
