commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;16;;@Override protected void doExecute(Task task, GetJobsStatsAction.Request request, ActionListener<GetJobsStatsAction.Response> finalListener) {     logger.debug("Get stats for job [{}]", request.getJobId()).     jobConfigProvider.expandJobsIds(request.getJobId(), request.allowNoJobs(), true, ActionListener.wrap(expandedIds -> {         request.setExpandedJobsIds(new ArrayList<>(expandedIds)).         ActionListener<GetJobsStatsAction.Response> jobStatsListener = ActionListener.wrap(response -> gatherStatsForClosedJobs(request, response, finalListener), finalListener::onFailure).         super.doExecute(task, request, jobStatsListener).     }, finalListener::onFailure)). }
false;protected;4;13;;@Override protected GetJobsStatsAction.Response newResponse(GetJobsStatsAction.Request request, List<QueryPage<JobStats>> tasks, List<TaskOperationFailure> taskOperationFailures, List<FailedNodeException> failedNodeExceptions) {     List<JobStats> stats = new ArrayList<>().     for (QueryPage<JobStats> task : tasks) {         stats.addAll(task.results()).     }     Collections.sort(stats, Comparator.comparing(GetJobsStatsAction.Response.JobStats::getJobId)).     return new GetJobsStatsAction.Response(taskOperationFailures, failedNodeExceptions, new QueryPage<>(stats, stats.size(), Job.RESULTS_FIELD)). }
false;protected;3;23;;@Override protected void taskOperation(GetJobsStatsAction.Request request, TransportOpenJobAction.JobTask task, ActionListener<QueryPage<JobStats>> listener) {     String jobId = task.getJobId().     ClusterState state = clusterService.state().     PersistentTasksCustomMetaData tasks = state.getMetaData().custom(PersistentTasksCustomMetaData.TYPE).     Optional<Tuple<DataCounts, ModelSizeStats>> stats = processManager.getStatistics(task).     if (stats.isPresent()) {         PersistentTasksCustomMetaData.PersistentTask<?> pTask = MlTasks.getJobTask(jobId, tasks).         DiscoveryNode node = state.nodes().get(pTask.getExecutorNode()).         JobState jobState = MlTasks.getJobState(jobId, tasks).         String assignmentExplanation = pTask.getAssignment().getExplanation().         TimeValue openTime = durationToTimeValue(processManager.jobOpenTime(task)).         gatherForecastStats(jobId, forecastStats -> {             JobStats jobStats = new JobStats(jobId, stats.get().v1(), stats.get().v2(), forecastStats, jobState, node, assignmentExplanation, openTime).             listener.onResponse(new QueryPage<>(Collections.singletonList(jobStats), 1, Job.RESULTS_FIELD)).         }, listener::onFailure).     } else {         listener.onResponse(new QueryPage<>(Collections.emptyList(), 0, Job.RESULTS_FIELD)).     } }
true;;3;35;// This method will fetch the stats for missing jobs, that was stored in the jobs index ;// Up until now we gathered the stats for jobs that were open, // This method will fetch the stats for missing jobs, that was stored in the jobs index void gatherStatsForClosedJobs(GetJobsStatsAction.Request request, GetJobsStatsAction.Response response, ActionListener<GetJobsStatsAction.Response> listener) {     List<String> closedJobIds = determineJobIdsWithoutLiveStats(request.getExpandedJobsIds(), response.getResponse().results()).     if (closedJobIds.isEmpty()) {         listener.onResponse(response).         return.     }     AtomicInteger counter = new AtomicInteger(closedJobIds.size()).     AtomicArray<GetJobsStatsAction.Response.JobStats> jobStats = new AtomicArray<>(closedJobIds.size()).     PersistentTasksCustomMetaData tasks = clusterService.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE).     for (int i = 0. i < closedJobIds.size(). i++) {         int slot = i.         String jobId = closedJobIds.get(i).         gatherForecastStats(jobId, forecastStats -> {             gatherDataCountsAndModelSizeStats(jobId, (dataCounts, modelSizeStats) -> {                 JobState jobState = MlTasks.getJobState(jobId, tasks).                 PersistentTasksCustomMetaData.PersistentTask<?> pTask = MlTasks.getJobTask(jobId, tasks).                 String assignmentExplanation = null.                 if (pTask != null) {                     assignmentExplanation = pTask.getAssignment().getExplanation().                 }                 jobStats.set(slot, new JobStats(jobId, dataCounts, modelSizeStats, forecastStats, jobState, null, assignmentExplanation, null)).                 if (counter.decrementAndGet() == 0) {                     List<JobStats> results = response.getResponse().results().                     results.addAll(jobStats.asList()).                     Collections.sort(results, Comparator.comparing(GetJobsStatsAction.Response.JobStats::getJobId)).                     listener.onResponse(new GetJobsStatsAction.Response(response.getTaskFailures(), response.getNodeFailures(), new QueryPage<>(results, results.size(), Job.RESULTS_FIELD))).                 }             }, listener::onFailure).         }, listener::onFailure).     } }
false;;3;3;;void gatherForecastStats(String jobId, Consumer<ForecastStats> handler, Consumer<Exception> errorHandler) {     jobResultsProvider.getForecastStats(jobId, handler, errorHandler). }
false;;3;8;;void gatherDataCountsAndModelSizeStats(String jobId, BiConsumer<DataCounts, ModelSizeStats> handler, Consumer<Exception> errorHandler) {     jobResultsProvider.dataCounts(jobId, dataCounts -> {         jobResultsProvider.modelSizeStats(jobId, modelSizeStats -> {             handler.accept(dataCounts, modelSizeStats).         }, errorHandler).     }, errorHandler). }
false;static;1;7;;static TimeValue durationToTimeValue(Optional<Duration> duration) {     if (duration.isPresent()) {         return TimeValue.timeValueSeconds(duration.get().getSeconds()).     } else {         return null.     } }
false;static;2;5;;static List<String> determineJobIdsWithoutLiveStats(List<String> requestedJobIds, List<GetJobsStatsAction.Response.JobStats> stats) {     Set<String> excludeJobIds = stats.stream().map(GetJobsStatsAction.Response.JobStats::getJobId).collect(Collectors.toSet()).     return requestedJobIds.stream().filter(jobId -> !excludeJobIds.contains(jobId)).collect(Collectors.toList()). }
