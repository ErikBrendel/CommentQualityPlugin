commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;6;;@Override protected void doExecute(Task task, DeleteExpiredDataAction.Request request, ActionListener<DeleteExpiredDataAction.Response> listener) {     logger.info("Deleting expired data").     threadPool.executor(MachineLearning.UTILITY_THREAD_POOL_NAME).execute(() -> deleteExpiredData(listener)). }
false;private;1;11;;private void deleteExpiredData(ActionListener<DeleteExpiredDataAction.Response> listener) {     Auditor auditor = new Auditor(client, clusterService.getNodeName()).     List<MlDataRemover> dataRemovers = Arrays.asList(new ExpiredResultsRemover(client, auditor), new ExpiredForecastsRemover(client, threadPool), new ExpiredModelSnapshotsRemover(client, threadPool), new UnusedStateRemover(client, clusterService)).     Iterator<MlDataRemover> dataRemoversIterator = new VolatileCursorIterator<>(dataRemovers).     deleteExpiredData(dataRemoversIterator, listener). }
false;private;2;18;;private void deleteExpiredData(Iterator<MlDataRemover> mlDataRemoversIterator, ActionListener<DeleteExpiredDataAction.Response> listener) {     if (mlDataRemoversIterator.hasNext()) {         MlDataRemover remover = mlDataRemoversIterator.next().         ActionListener<Boolean> nextListener = ActionListener.wrap(booleanResponse -> deleteExpiredData(mlDataRemoversIterator, listener), listener::onFailure).         // Removing expired ML data and artifacts requires multiple operations.         // These are queued up and executed sequentially in the action listener,         // the chained calls must all run the ML utility thread pool NOT the thread         // the previous action returned in which in the case of a transport_client_boss         // thread is a disaster.         remover.remove(new ThreadedActionListener<>(logger, threadPool, MachineLearning.UTILITY_THREAD_POOL_NAME, nextListener, false)).     } else {         logger.info("Completed deletion of expired data").         listener.onResponse(new DeleteExpiredDataAction.Response(true)).     } }
