commented;modifiers;parameterAmount;loc;comment;code
true;public;4;22;/**  * Read the JSON inputIndex, transform to length encoded values and pipe to  * the OutputStream. No transformation is applied to the data the timestamp  * is expected in seconds from the epoch. If any of the fields in  * <code>analysisFields</code> or the <code>DataDescription</code>s  * timeField is missing from the JOSN inputIndex an exception is thrown  */ ;/**  * Read the JSON inputIndex, transform to length encoded values and pipe to  * the OutputStream. No transformation is applied to the data the timestamp  * is expected in seconds from the epoch. If any of the fields in  * <code>analysisFields</code> or the <code>DataDescription</code>s  * timeField is missing from the JOSN inputIndex an exception is thrown  */ @Override public void write(InputStream inputStream, CategorizationAnalyzer categorizationAnalyzer, XContentType xContentType, BiConsumer<DataCounts, Exception> handler) throws IOException {     dataCountsReporter.startNewIncrementalCount().     if (xContentType.equals(XContentType.JSON)) {         writeJsonXContent(categorizationAnalyzer, inputStream).     } else if (xContentType.equals(XContentType.SMILE)) {         writeSmileXContent(categorizationAnalyzer, inputStream).     } else {         throw new RuntimeException("XContentType [" + xContentType + "] is not supported by JsonDataToProcessWriter").     }     // this line can throw and will be propagated     dataCountsReporter.finishReporting(ActionListener.wrap(response -> handler.accept(dataCountsReporter.incrementalStats(), null), e -> handler.accept(null, e))). }
false;private;2;6;;private void writeJsonXContent(CategorizationAnalyzer categorizationAnalyzer, InputStream inputStream) throws IOException {     try (XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, inputStream)) {         writeJson(categorizationAnalyzer, parser).     } }
false;private;2;12;;private void writeSmileXContent(CategorizationAnalyzer categorizationAnalyzer, InputStream inputStream) throws IOException {     while (true) {         byte[] nextObject = findNextObject(XContentType.SMILE.xContent().streamSeparator(), inputStream).         if (nextObject.length == 0) {             break.         }         try (XContentParser parser = XContentFactory.xContent(XContentType.SMILE).createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, nextObject)) {             writeJson(categorizationAnalyzer, parser).         }     } }
false;private;2;25;;private byte[] findNextObject(byte marker, InputStream data) throws IOException {     // blow up immediately     assert (data.markSupported()).     data.mark(-1).     int nextByte.     int counter = 0.     do {         nextByte = data.read().         counter += 1.         // marker & 0xFF to deal with Java's lack of unsigned bytes...         if (nextByte == (marker & 0xFF)) {             data.reset().             byte[] buffer = new byte[counter].             data.read(buffer).             return buffer.         }     } while (nextByte != -1).     return new byte[0]. }
false;private;2;38;;private void writeJson(CategorizationAnalyzer categorizationAnalyzer, XContentParser parser) throws IOException {     Collection<String> inputFields = inputFields().     buildFieldIndexMapping(inputFields.toArray(new String[0])).     int numFields = outputFieldCount().     String[] input = new String[numFields].     String[] record = new String[numFields].     // We never expect to get the control field or categorization tokens field     boolean[] gotFields = new boolean[inputFields.size()].     XContentRecordReader recordReader = new XContentRecordReader(parser, inFieldIndexes, LOGGER).     Integer categorizationFieldIndex = inFieldIndexes.get(analysisConfig.getCategorizationFieldName()).     long inputFieldCount = recordReader.read(input, gotFields).     while (inputFieldCount >= 0) {         Arrays.fill(record, "").         // time field doesn't count         inputFieldCount = Math.max(inputFieldCount - 1, 0).         long missing = missingFieldCount(gotFields).         if (missing > 0) {             dataCountsReporter.reportMissingFields(missing).         }         for (InputOutputMap inOut : inputOutputMap) {             String field = input[inOut.inputIndex].             record[inOut.outputIndex] = (field == null) ? "" : field.         }         if (categorizationAnalyzer != null && categorizationFieldIndex != null) {             tokenizeForCategorization(categorizationAnalyzer, input[categorizationFieldIndex], record).         }         transformTimeAndWrite(record, inputFieldCount).         inputFieldCount = recordReader.read(input, gotFields).     } }
true;protected;3;6;/**  * Don't enforce the check that all the fields are present in JSON docs.  * Always returns true  */ ;/**  * Don't enforce the check that all the fields are present in JSON docs.  * Always returns true  */ @Override protected boolean checkForMissingFields(Collection<String> inputFields, Map<String, Integer> inputFieldIndexes, String[] header) {     return true. }
true;private,static;1;11;/**  * Return the number of missing fields  */ ;/**  * Return the number of missing fields  */ private static long missingFieldCount(boolean[] gotFieldFlags) {     long count = 0.     for (boolean gotFieldFlag : gotFieldFlags) {         if (gotFieldFlag == false) {             ++count.         }     }     return count. }
