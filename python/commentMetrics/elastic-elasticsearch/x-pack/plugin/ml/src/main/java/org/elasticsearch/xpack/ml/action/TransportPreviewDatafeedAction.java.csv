commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void onResponse(DataExtractorFactory dataExtractorFactory) {     DataExtractor dataExtractor = dataExtractorFactory.newExtractor(0, Long.MAX_VALUE).     threadPool.generic().execute(() -> previewDatafeed(dataExtractor, listener)). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;protected;3;36;;@Override protected void doExecute(Task task, PreviewDatafeedAction.Request request, ActionListener<PreviewDatafeedAction.Response> listener) {     datafeedConfigProvider.getDatafeedConfig(request.getDatafeedId(), ActionListener.wrap(datafeedConfigBuilder -> {         DatafeedConfig datafeedConfig = datafeedConfigBuilder.build().         jobConfigProvider.getJob(datafeedConfig.getJobId(), ActionListener.wrap(jobBuilder -> {             DatafeedConfig.Builder previewDatafeed = buildPreviewDatafeed(datafeedConfig).             Map<String, String> headers = threadPool.getThreadContext().getHeaders().entrySet().stream().filter(e -> ClientHelper.SECURITY_HEADER_FILTERS.contains(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).             previewDatafeed.setHeaders(headers).             // NB: this is using the client from the transport layer, NOT the internal client.             // This is important because it means the datafeed search will fail if the user             // requesting the preview doesn't have permission to search the relevant indices.             DataExtractorFactory.create(client, previewDatafeed.build(), jobBuilder.build(), new ActionListener<DataExtractorFactory>() {                  @Override                 public void onResponse(DataExtractorFactory dataExtractorFactory) {                     DataExtractor dataExtractor = dataExtractorFactory.newExtractor(0, Long.MAX_VALUE).                     threadPool.generic().execute(() -> previewDatafeed(dataExtractor, listener)).                 }                  @Override                 public void onFailure(Exception e) {                     listener.onFailure(e).                 }             }).         }, listener::onFailure)).     }, listener::onFailure)). }
true;static;1;15;/**  * Visible for testing  */ ;/**  * Visible for testing  */ static DatafeedConfig.Builder buildPreviewDatafeed(DatafeedConfig datafeed) {     // Since we only want a preview, it's worth limiting the cost     // of the search in the case of non-aggregated datafeeds.     // We do so by setting auto-chunking. This ensures to find     // a sensible time range with enough data to preview.     // When aggregations are present, it's best to comply with     // what the datafeed is set to do as it can reveal problems with     // the datafeed config (e.g. a chunking config that would hit circuit-breakers).     DatafeedConfig.Builder previewDatafeed = new DatafeedConfig.Builder(datafeed).     if (datafeed.hasAggregations() == false) {         previewDatafeed.setChunkingConfig(ChunkingConfig.newAuto()).     }     return previewDatafeed. }
true;static;2;24;/**  * Visible for testing  */ ;/**  * Visible for testing  */ static void previewDatafeed(DataExtractor dataExtractor, ActionListener<PreviewDatafeedAction.Response> listener) {     try {         Optional<InputStream> inputStream = dataExtractor.next().         // DataExtractor returns single-line JSON but without newline characters between objects.         // Instead, it has a space between objects due to how JSON XContenetBuilder works.         // In order to return a proper JSON array from preview, we surround with square brackets and         // we stick in a comma between objects.         // Also, the stream is expected to be a single line but in case it is not, we join lines         // using space to ensure the comma insertion works correctly.         StringBuilder responseBuilder = new StringBuilder("[").         if (inputStream.isPresent()) {             try (BufferedReader buffer = new BufferedReader(new InputStreamReader(inputStream.get(), StandardCharsets.UTF_8))) {                 responseBuilder.append(buffer.lines().collect(Collectors.joining(" ")).replace("} {", "},{")).             }         }         responseBuilder.append("]").         listener.onResponse(new PreviewDatafeedAction.Response(new BytesArray(responseBuilder.toString().getBytes(StandardCharsets.UTF_8)))).     } catch (Exception e) {         listener.onFailure(e).     } finally {         dataExtractor.cancel().     } }
