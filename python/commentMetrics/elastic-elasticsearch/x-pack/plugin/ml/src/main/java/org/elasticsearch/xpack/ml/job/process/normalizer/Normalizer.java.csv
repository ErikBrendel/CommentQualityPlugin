# id;timestamp;commentText;codeText;commentWords;codeWords
Normalizer -> private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,                                                   List<? extends Normalizable> results);1524684173;Updates the normalized scores on the results.;private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,_                                                  List<? extends Normalizable> results) {_        Iterator<NormalizerResult> scoresIter = normalizedScores.iterator()__        for (Normalizable result : results) {_            mergeRecursively(scoresIter, null, false, result)__        }_        if (scoresIter.hasNext()) {_            LOGGER.error("[{}] Unused normalized scores remain after updating all results: {} for {}",_                    jobId, normalizedScores.size(), results.size())__        }_    };updates,the,normalized,scores,on,the,results;private,void,merge,normalized,scores,into,results,list,normalizer,result,normalized,scores,list,extends,normalizable,results,iterator,normalizer,result,scores,iter,normalized,scores,iterator,for,normalizable,result,results,merge,recursively,scores,iter,null,false,result,if,scores,iter,has,next,logger,error,unused,normalized,scores,remain,after,updating,all,results,for,job,id,normalized,scores,size,results,size
Normalizer -> private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,                                                   List<? extends Normalizable> results);1534176840;Updates the normalized scores on the results.;private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,_                                                  List<? extends Normalizable> results) {_        Iterator<NormalizerResult> scoresIter = normalizedScores.iterator()__        for (Normalizable result : results) {_            mergeRecursively(scoresIter, null, false, result)__        }_        if (scoresIter.hasNext()) {_            LOGGER.error("[{}] Unused normalized scores remain after updating all results: {} for {}",_                    jobId, normalizedScores.size(), results.size())__        }_    };updates,the,normalized,scores,on,the,results;private,void,merge,normalized,scores,into,results,list,normalizer,result,normalized,scores,list,extends,normalizable,results,iterator,normalizer,result,scores,iter,normalized,scores,iterator,for,normalizable,result,results,merge,recursively,scores,iter,null,false,result,if,scores,iter,has,next,logger,error,unused,normalized,scores,remain,after,updating,all,results,for,job,id,normalized,scores,size,results,size
Normalizer -> private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,                                                   List<? extends Normalizable> results);1534338685;Updates the normalized scores on the results.;private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,_                                                  List<? extends Normalizable> results) {_        Iterator<NormalizerResult> scoresIter = normalizedScores.iterator()__        for (Normalizable result : results) {_            mergeRecursively(scoresIter, null, false, result)__        }_        if (scoresIter.hasNext()) {_            LOGGER.error("[{}] Unused normalized scores remain after updating all results: {} for {}",_                    jobId, normalizedScores.size(), results.size())__        }_    };updates,the,normalized,scores,on,the,results;private,void,merge,normalized,scores,into,results,list,normalizer,result,normalized,scores,list,extends,normalizable,results,iterator,normalizer,result,scores,iter,normalized,scores,iterator,for,normalizable,result,results,merge,recursively,scores,iter,null,false,result,if,scores,iter,has,next,logger,error,unused,normalized,scores,remain,after,updating,all,results,for,job,id,normalized,scores,size,results,size
Normalizer -> private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,                                                   List<? extends Normalizable> results);1538067637;Updates the normalized scores on the results.;private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,_                                                  List<? extends Normalizable> results) {_        Iterator<NormalizerResult> scoresIter = normalizedScores.iterator()__        for (Normalizable result : results) {_            mergeRecursively(scoresIter, null, false, result)__        }_        if (scoresIter.hasNext()) {_            LOGGER.error("[{}] Unused normalized scores remain after updating all results: {} for {}",_                    jobId, normalizedScores.size(), results.size())__        }_    };updates,the,normalized,scores,on,the,results;private,void,merge,normalized,scores,into,results,list,normalizer,result,normalized,scores,list,extends,normalizable,results,iterator,normalizer,result,scores,iter,normalized,scores,iterator,for,normalizable,result,results,merge,recursively,scores,iter,null,false,result,if,scores,iter,has,next,logger,error,unused,normalized,scores,remain,after,updating,all,results,for,job,id,normalized,scores,size,results,size
Normalizer -> private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,                                                   List<? extends Normalizable> results);1540847035;Updates the normalized scores on the results.;private void mergeNormalizedScoresIntoResults(List<NormalizerResult> normalizedScores,_                                                  List<? extends Normalizable> results) {_        Iterator<NormalizerResult> scoresIter = normalizedScores.iterator()__        for (Normalizable result : results) {_            mergeRecursively(scoresIter, null, false, result)__        }_        if (scoresIter.hasNext()) {_            LOGGER.error("[{}] Unused normalized scores remain after updating all results: {} for {}",_                    jobId, normalizedScores.size(), results.size())__        }_    };updates,the,normalized,scores,on,the,results;private,void,merge,normalized,scores,into,results,list,normalizer,result,normalized,scores,list,extends,normalizable,results,iterator,normalizer,result,scores,iter,normalized,scores,iterator,for,normalizable,result,results,merge,recursively,scores,iter,null,false,result,if,scores,iter,has,next,logger,error,unused,normalized,scores,remain,after,updating,all,results,for,job,id,normalized,scores,size,results,size
Normalizer -> public void normalize(Integer bucketSpan,                           List<? extends Normalizable> results, String quantilesState);1534338685;Launches a normalization process seeded with the quantiles state provided_and normalizes the given results.__@param bucketSpan                If <code>null</code> the default is used_@param results                   Will be updated with the normalized results_@param quantilesState            The state to be used to seed the system change_normalizer;public void normalize(Integer bucketSpan,_                          List<? extends Normalizable> results, String quantilesState) {_        NormalizerProcess process = processFactory.createNormalizerProcess(jobId, quantilesState, bucketSpan,_                 executorService)__        NormalizerResultHandler resultsHandler = process.createNormalizedResultsHandler()__        Future<?> resultsHandlerFuture = executorService.submit(() -> {_            try {_                resultsHandler.process()__            } catch (IOException e) {_                LOGGER.error(new ParameterizedMessage("[{}] Error reading normalizer results", new Object[] { jobId }), e)__            }_        })___        try {_            process.writeRecord(new String[] {_                    NormalizerResult.LEVEL_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_VALUE_FIELD.getPreferredName(),_                    NormalizerResult.PERSON_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PERSON_FIELD_VALUE_FIELD.getPreferredName(),_                    NormalizerResult.FUNCTION_NAME_FIELD.getPreferredName(),_                    NormalizerResult.VALUE_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PROBABILITY_FIELD.getPreferredName(),_                    NormalizerResult.NORMALIZED_SCORE_FIELD.getPreferredName()_            })___            for (Normalizable result : results) {_                writeNormalizableAndChildrenRecursively(result, process)__            }_        } catch (IOException e) {_            LOGGER.error("[" + jobId + "] Error writing to the normalizer", e)__        } finally {_            try {_                process.close()__            } catch (IOException e) {_                LOGGER.error("[" + jobId + "] Error closing normalizer", e)__            }_        }__        _        try {_            resultsHandlerFuture.get()__            mergeNormalizedScoresIntoResults(resultsHandler.getNormalizedResults(), results)__        } catch (ExecutionException e) {_            LOGGER.error(new ParameterizedMessage("[{}] Error processing normalizer results", new Object[] { jobId }), e)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        }_    };launches,a,normalization,process,seeded,with,the,quantiles,state,provided,and,normalizes,the,given,results,param,bucket,span,if,code,null,code,the,default,is,used,param,results,will,be,updated,with,the,normalized,results,param,quantiles,state,the,state,to,be,used,to,seed,the,system,change,normalizer;public,void,normalize,integer,bucket,span,list,extends,normalizable,results,string,quantiles,state,normalizer,process,process,process,factory,create,normalizer,process,job,id,quantiles,state,bucket,span,executor,service,normalizer,result,handler,results,handler,process,create,normalized,results,handler,future,results,handler,future,executor,service,submit,try,results,handler,process,catch,ioexception,e,logger,error,new,parameterized,message,error,reading,normalizer,results,new,object,job,id,e,try,process,write,record,new,string,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,for,normalizable,result,results,write,normalizable,and,children,recursively,result,process,catch,ioexception,e,logger,error,job,id,error,writing,to,the,normalizer,e,finally,try,process,close,catch,ioexception,e,logger,error,job,id,error,closing,normalizer,e,try,results,handler,future,get,merge,normalized,scores,into,results,results,handler,get,normalized,results,results,catch,execution,exception,e,logger,error,new,parameterized,message,error,processing,normalizer,results,new,object,job,id,e,catch,interrupted,exception,e,thread,current,thread,interrupt
Normalizer -> public void normalize(Integer bucketSpan,                           List<? extends Normalizable> results, String quantilesState);1538067637;Launches a normalization process seeded with the quantiles state provided_and normalizes the given results.__@param bucketSpan                If <code>null</code> the default is used_@param results                   Will be updated with the normalized results_@param quantilesState            The state to be used to seed the system change_normalizer;public void normalize(Integer bucketSpan,_                          List<? extends Normalizable> results, String quantilesState) {_        NormalizerProcess process = processFactory.createNormalizerProcess(jobId, quantilesState, bucketSpan,_                 executorService)__        NormalizerResultHandler resultsHandler = process.createNormalizedResultsHandler()__        Future<?> resultsHandlerFuture = executorService.submit(() -> {_            try {_                resultsHandler.process()__            } catch (IOException e) {_                LOGGER.error(new ParameterizedMessage("[{}] Error reading normalizer results", new Object[] { jobId }), e)__            }_        })___        try {_            process.writeRecord(new String[] {_                    NormalizerResult.LEVEL_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_VALUE_FIELD.getPreferredName(),_                    NormalizerResult.PERSON_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PERSON_FIELD_VALUE_FIELD.getPreferredName(),_                    NormalizerResult.FUNCTION_NAME_FIELD.getPreferredName(),_                    NormalizerResult.VALUE_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PROBABILITY_FIELD.getPreferredName(),_                    NormalizerResult.NORMALIZED_SCORE_FIELD.getPreferredName()_            })___            for (Normalizable result : results) {_                writeNormalizableAndChildrenRecursively(result, process)__            }_        } catch (IOException e) {_            LOGGER.error("[" + jobId + "] Error writing to the normalizer", e)__        } finally {_            try {_                process.close()__            } catch (IOException e) {_                LOGGER.error("[" + jobId + "] Error closing normalizer", e)__            }_        }__        _        try {_            resultsHandlerFuture.get()__            mergeNormalizedScoresIntoResults(resultsHandler.getNormalizedResults(), results)__        } catch (ExecutionException e) {_            LOGGER.error(new ParameterizedMessage("[{}] Error processing normalizer results", new Object[] { jobId }), e)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        }_    };launches,a,normalization,process,seeded,with,the,quantiles,state,provided,and,normalizes,the,given,results,param,bucket,span,if,code,null,code,the,default,is,used,param,results,will,be,updated,with,the,normalized,results,param,quantiles,state,the,state,to,be,used,to,seed,the,system,change,normalizer;public,void,normalize,integer,bucket,span,list,extends,normalizable,results,string,quantiles,state,normalizer,process,process,process,factory,create,normalizer,process,job,id,quantiles,state,bucket,span,executor,service,normalizer,result,handler,results,handler,process,create,normalized,results,handler,future,results,handler,future,executor,service,submit,try,results,handler,process,catch,ioexception,e,logger,error,new,parameterized,message,error,reading,normalizer,results,new,object,job,id,e,try,process,write,record,new,string,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,for,normalizable,result,results,write,normalizable,and,children,recursively,result,process,catch,ioexception,e,logger,error,job,id,error,writing,to,the,normalizer,e,finally,try,process,close,catch,ioexception,e,logger,error,job,id,error,closing,normalizer,e,try,results,handler,future,get,merge,normalized,scores,into,results,results,handler,get,normalized,results,results,catch,execution,exception,e,logger,error,new,parameterized,message,error,processing,normalizer,results,new,object,job,id,e,catch,interrupted,exception,e,thread,current,thread,interrupt
Normalizer -> public void normalize(Integer bucketSpan,                           List<? extends Normalizable> results, String quantilesState);1540847035;Launches a normalization process seeded with the quantiles state provided_and normalizes the given results.__@param bucketSpan                If <code>null</code> the default is used_@param results                   Will be updated with the normalized results_@param quantilesState            The state to be used to seed the system change_normalizer;public void normalize(Integer bucketSpan,_                          List<? extends Normalizable> results, String quantilesState) {_        NormalizerProcess process = processFactory.createNormalizerProcess(jobId, quantilesState, bucketSpan,_                 executorService)__        NormalizerResultHandler resultsHandler = process.createNormalizedResultsHandler()__        Future<?> resultsHandlerFuture = executorService.submit(() -> {_            try {_                resultsHandler.process()__            } catch (IOException e) {_                LOGGER.error(new ParameterizedMessage("[{}] Error reading normalizer results", new Object[] { jobId }), e)__            }_        })___        try {_            process.writeRecord(new String[] {_                    NormalizerResult.LEVEL_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_VALUE_FIELD.getPreferredName(),_                    NormalizerResult.PERSON_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PERSON_FIELD_VALUE_FIELD.getPreferredName(),_                    NormalizerResult.FUNCTION_NAME_FIELD.getPreferredName(),_                    NormalizerResult.VALUE_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PROBABILITY_FIELD.getPreferredName(),_                    NormalizerResult.NORMALIZED_SCORE_FIELD.getPreferredName()_            })___            for (Normalizable result : results) {_                writeNormalizableAndChildrenRecursively(result, process)__            }_        } catch (IOException e) {_            LOGGER.error("[" + jobId + "] Error writing to the normalizer", e)__        } finally {_            try {_                process.close()__            } catch (IOException e) {_                LOGGER.error("[" + jobId + "] Error closing normalizer", e)__            }_        }__        _        try {_            resultsHandlerFuture.get()__            mergeNormalizedScoresIntoResults(resultsHandler.getNormalizedResults(), results)__        } catch (ExecutionException e) {_            LOGGER.error(new ParameterizedMessage("[{}] Error processing normalizer results", new Object[] { jobId }), e)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        }_    };launches,a,normalization,process,seeded,with,the,quantiles,state,provided,and,normalizes,the,given,results,param,bucket,span,if,code,null,code,the,default,is,used,param,results,will,be,updated,with,the,normalized,results,param,quantiles,state,the,state,to,be,used,to,seed,the,system,change,normalizer;public,void,normalize,integer,bucket,span,list,extends,normalizable,results,string,quantiles,state,normalizer,process,process,process,factory,create,normalizer,process,job,id,quantiles,state,bucket,span,executor,service,normalizer,result,handler,results,handler,process,create,normalized,results,handler,future,results,handler,future,executor,service,submit,try,results,handler,process,catch,ioexception,e,logger,error,new,parameterized,message,error,reading,normalizer,results,new,object,job,id,e,try,process,write,record,new,string,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,for,normalizable,result,results,write,normalizable,and,children,recursively,result,process,catch,ioexception,e,logger,error,job,id,error,writing,to,the,normalizer,e,finally,try,process,close,catch,ioexception,e,logger,error,job,id,error,closing,normalizer,e,try,results,handler,future,get,merge,normalized,scores,into,results,results,handler,get,normalized,results,results,catch,execution,exception,e,logger,error,new,parameterized,message,error,processing,normalizer,results,new,object,job,id,e,catch,interrupted,exception,e,thread,current,thread,interrupt
Normalizer -> public void normalize(Integer bucketSpan, boolean perPartitionNormalization,                           List<? extends Normalizable> results, String quantilesState);1524684173;Launches a normalization process seeded with the quantiles state provided_and normalizes the given results.__@param bucketSpan                If <code>null</code> the default is used_@param perPartitionNormalization Is normalization per partition (rather than per job)?_@param results                   Will be updated with the normalized results_@param quantilesState            The state to be used to seed the system change_normalizer;public void normalize(Integer bucketSpan, boolean perPartitionNormalization,_                          List<? extends Normalizable> results, String quantilesState) {_        NormalizerProcess process = processFactory.createNormalizerProcess(jobId, quantilesState, bucketSpan,_                perPartitionNormalization, executorService)__        NormalizerResultHandler resultsHandler = process.createNormalizedResultsHandler()__        Future<?> resultsHandlerFuture = executorService.submit(() -> {_            try {_                resultsHandler.process()__            } catch (IOException e) {_                LOGGER.error(new ParameterizedMessage("[{}] Error reading normalizer results", new Object[] { jobId }), e)__            }_        })___        try {_            process.writeRecord(new String[] {_                    NormalizerResult.LEVEL_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_VALUE_FIELD.getPreferredName(),_                    NormalizerResult.PERSON_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.FUNCTION_NAME_FIELD.getPreferredName(),_                    NormalizerResult.VALUE_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PROBABILITY_FIELD.getPreferredName(),_                    NormalizerResult.NORMALIZED_SCORE_FIELD.getPreferredName()_            })___            for (Normalizable result : results) {_                writeNormalizableAndChildrenRecursively(result, process)__            }_        } catch (IOException e) {_            LOGGER.error("[" + jobId + "] Error writing to the normalizer", e)__        } finally {_            try {_                process.close()__            } catch (IOException e) {_                LOGGER.error("[" + jobId + "] Error closing normalizer", e)__            }_        }__        _        try {_            resultsHandlerFuture.get()__            mergeNormalizedScoresIntoResults(resultsHandler.getNormalizedResults(), results)__        } catch (ExecutionException e) {_            LOGGER.error(new ParameterizedMessage("[{}] Error processing normalizer results", new Object[] { jobId }), e)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        }_    };launches,a,normalization,process,seeded,with,the,quantiles,state,provided,and,normalizes,the,given,results,param,bucket,span,if,code,null,code,the,default,is,used,param,per,partition,normalization,is,normalization,per,partition,rather,than,per,job,param,results,will,be,updated,with,the,normalized,results,param,quantiles,state,the,state,to,be,used,to,seed,the,system,change,normalizer;public,void,normalize,integer,bucket,span,boolean,per,partition,normalization,list,extends,normalizable,results,string,quantiles,state,normalizer,process,process,process,factory,create,normalizer,process,job,id,quantiles,state,bucket,span,per,partition,normalization,executor,service,normalizer,result,handler,results,handler,process,create,normalized,results,handler,future,results,handler,future,executor,service,submit,try,results,handler,process,catch,ioexception,e,logger,error,new,parameterized,message,error,reading,normalizer,results,new,object,job,id,e,try,process,write,record,new,string,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,for,normalizable,result,results,write,normalizable,and,children,recursively,result,process,catch,ioexception,e,logger,error,job,id,error,writing,to,the,normalizer,e,finally,try,process,close,catch,ioexception,e,logger,error,job,id,error,closing,normalizer,e,try,results,handler,future,get,merge,normalized,scores,into,results,results,handler,get,normalized,results,results,catch,execution,exception,e,logger,error,new,parameterized,message,error,processing,normalizer,results,new,object,job,id,e,catch,interrupted,exception,e,thread,current,thread,interrupt
Normalizer -> public void normalize(Integer bucketSpan, boolean perPartitionNormalization,                           List<? extends Normalizable> results, String quantilesState);1534176840;Launches a normalization process seeded with the quantiles state provided_and normalizes the given results.__@param bucketSpan                If <code>null</code> the default is used_@param perPartitionNormalization Is normalization per partition (rather than per job)?_@param results                   Will be updated with the normalized results_@param quantilesState            The state to be used to seed the system change_normalizer;public void normalize(Integer bucketSpan, boolean perPartitionNormalization,_                          List<? extends Normalizable> results, String quantilesState) {_        NormalizerProcess process = processFactory.createNormalizerProcess(jobId, quantilesState, bucketSpan,_                perPartitionNormalization, executorService)__        NormalizerResultHandler resultsHandler = process.createNormalizedResultsHandler()__        Future<?> resultsHandlerFuture = executorService.submit(() -> {_            try {_                resultsHandler.process()__            } catch (IOException e) {_                LOGGER.error(new ParameterizedMessage("[{}] Error reading normalizer results", new Object[] { jobId }), e)__            }_        })___        try {_            process.writeRecord(new String[] {_                    NormalizerResult.LEVEL_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PARTITION_FIELD_VALUE_FIELD.getPreferredName(),_                    NormalizerResult.PERSON_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PERSON_FIELD_VALUE_FIELD.getPreferredName(),_                    NormalizerResult.FUNCTION_NAME_FIELD.getPreferredName(),_                    NormalizerResult.VALUE_FIELD_NAME_FIELD.getPreferredName(),_                    NormalizerResult.PROBABILITY_FIELD.getPreferredName(),_                    NormalizerResult.NORMALIZED_SCORE_FIELD.getPreferredName()_            })___            for (Normalizable result : results) {_                writeNormalizableAndChildrenRecursively(result, process)__            }_        } catch (IOException e) {_            LOGGER.error("[" + jobId + "] Error writing to the normalizer", e)__        } finally {_            try {_                process.close()__            } catch (IOException e) {_                LOGGER.error("[" + jobId + "] Error closing normalizer", e)__            }_        }__        _        try {_            resultsHandlerFuture.get()__            mergeNormalizedScoresIntoResults(resultsHandler.getNormalizedResults(), results)__        } catch (ExecutionException e) {_            LOGGER.error(new ParameterizedMessage("[{}] Error processing normalizer results", new Object[] { jobId }), e)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        }_    };launches,a,normalization,process,seeded,with,the,quantiles,state,provided,and,normalizes,the,given,results,param,bucket,span,if,code,null,code,the,default,is,used,param,per,partition,normalization,is,normalization,per,partition,rather,than,per,job,param,results,will,be,updated,with,the,normalized,results,param,quantiles,state,the,state,to,be,used,to,seed,the,system,change,normalizer;public,void,normalize,integer,bucket,span,boolean,per,partition,normalization,list,extends,normalizable,results,string,quantiles,state,normalizer,process,process,process,factory,create,normalizer,process,job,id,quantiles,state,bucket,span,per,partition,normalization,executor,service,normalizer,result,handler,results,handler,process,create,normalized,results,handler,future,results,handler,future,executor,service,submit,try,results,handler,process,catch,ioexception,e,logger,error,new,parameterized,message,error,reading,normalizer,results,new,object,job,id,e,try,process,write,record,new,string,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,normalizer,result,get,preferred,name,for,normalizable,result,results,write,normalizable,and,children,recursively,result,process,catch,ioexception,e,logger,error,job,id,error,writing,to,the,normalizer,e,finally,try,process,close,catch,ioexception,e,logger,error,job,id,error,closing,normalizer,e,try,results,handler,future,get,merge,normalized,scores,into,results,results,handler,get,normalized,results,results,catch,execution,exception,e,logger,error,new,parameterized,message,error,processing,normalizer,results,new,object,job,id,e,catch,interrupted,exception,e,thread,current,thread,interrupt
Normalizer -> private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,                                     boolean parentHadBigChange, Normalizable result);1524684173;Recursively merges the scores returned by the normalization process into the results__@param scoresIter         an Iterator of the scores returned by the normalization process_@param parent             the parent result_@param parentHadBigChange whether the parent had a big change_@param result             the result to be updated_@return the effective normalized score of the given result;private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,_                                    boolean parentHadBigChange, Normalizable result) {_        boolean hasBigChange = false__        if (result.isContainerOnly() == false) {_            if (!scoresIter.hasNext()) {_                String msg = "Error iterating normalized results"__                LOGGER.error("[{}] {}", jobId, msg)__                throw new ElasticsearchException(msg)__            }__            result.resetBigChangeFlag()__            if (parent != null && parentHadBigChange) {_                result.setParentScore(parent.getNormalizedScore())__                result.raiseBigChangeFlag()__            }__            double normalizedScore = scoresIter.next().getNormalizedScore()__            hasBigChange = isBigUpdate(result.getNormalizedScore(), normalizedScore)__            if (hasBigChange) {_                result.setNormalizedScore(normalizedScore)__                result.raiseBigChangeFlag()__                if (parent != null) {_                    parent.raiseBigChangeFlag()__                }_            }_        }__        for (Normalizable.ChildType childrenType : result.getChildrenTypes()) {_            List<Normalizable> children = result.getChildren(childrenType)__            if (!children.isEmpty()) {_                double maxChildrenScore = 0.0__                for (Normalizable child : children) {_                    maxChildrenScore = Math.max(_                            mergeRecursively(scoresIter, result, hasBigChange, child),_                            maxChildrenScore)__                }_                hasBigChange |= result.setMaxChildrenScore(childrenType, maxChildrenScore)__            }_        }_        return result.getNormalizedScore()__    };recursively,merges,the,scores,returned,by,the,normalization,process,into,the,results,param,scores,iter,an,iterator,of,the,scores,returned,by,the,normalization,process,param,parent,the,parent,result,param,parent,had,big,change,whether,the,parent,had,a,big,change,param,result,the,result,to,be,updated,return,the,effective,normalized,score,of,the,given,result;private,double,merge,recursively,iterator,normalizer,result,scores,iter,normalizable,parent,boolean,parent,had,big,change,normalizable,result,boolean,has,big,change,false,if,result,is,container,only,false,if,scores,iter,has,next,string,msg,error,iterating,normalized,results,logger,error,job,id,msg,throw,new,elasticsearch,exception,msg,result,reset,big,change,flag,if,parent,null,parent,had,big,change,result,set,parent,score,parent,get,normalized,score,result,raise,big,change,flag,double,normalized,score,scores,iter,next,get,normalized,score,has,big,change,is,big,update,result,get,normalized,score,normalized,score,if,has,big,change,result,set,normalized,score,normalized,score,result,raise,big,change,flag,if,parent,null,parent,raise,big,change,flag,for,normalizable,child,type,children,type,result,get,children,types,list,normalizable,children,result,get,children,children,type,if,children,is,empty,double,max,children,score,0,0,for,normalizable,child,children,max,children,score,math,max,merge,recursively,scores,iter,result,has,big,change,child,max,children,score,has,big,change,result,set,max,children,score,children,type,max,children,score,return,result,get,normalized,score
Normalizer -> private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,                                     boolean parentHadBigChange, Normalizable result);1534176840;Recursively merges the scores returned by the normalization process into the results__@param scoresIter         an Iterator of the scores returned by the normalization process_@param parent             the parent result_@param parentHadBigChange whether the parent had a big change_@param result             the result to be updated_@return the effective normalized score of the given result;private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,_                                    boolean parentHadBigChange, Normalizable result) {_        boolean hasBigChange = false__        if (result.isContainerOnly() == false) {_            if (!scoresIter.hasNext()) {_                String msg = "Error iterating normalized results"__                LOGGER.error("[{}] {}", jobId, msg)__                throw new ElasticsearchException(msg)__            }__            result.resetBigChangeFlag()__            if (parent != null && parentHadBigChange) {_                result.setParentScore(parent.getNormalizedScore())__                result.raiseBigChangeFlag()__            }__            double normalizedScore = scoresIter.next().getNormalizedScore()__            hasBigChange = isBigUpdate(result.getNormalizedScore(), normalizedScore)__            if (hasBigChange) {_                result.setNormalizedScore(normalizedScore)__                result.raiseBigChangeFlag()__                if (parent != null) {_                    parent.raiseBigChangeFlag()__                }_            }_        }__        for (Normalizable.ChildType childrenType : result.getChildrenTypes()) {_            List<Normalizable> children = result.getChildren(childrenType)__            if (!children.isEmpty()) {_                double maxChildrenScore = 0.0__                for (Normalizable child : children) {_                    maxChildrenScore = Math.max(_                            mergeRecursively(scoresIter, result, hasBigChange, child),_                            maxChildrenScore)__                }_                hasBigChange |= result.setMaxChildrenScore(childrenType, maxChildrenScore)__            }_        }_        return result.getNormalizedScore()__    };recursively,merges,the,scores,returned,by,the,normalization,process,into,the,results,param,scores,iter,an,iterator,of,the,scores,returned,by,the,normalization,process,param,parent,the,parent,result,param,parent,had,big,change,whether,the,parent,had,a,big,change,param,result,the,result,to,be,updated,return,the,effective,normalized,score,of,the,given,result;private,double,merge,recursively,iterator,normalizer,result,scores,iter,normalizable,parent,boolean,parent,had,big,change,normalizable,result,boolean,has,big,change,false,if,result,is,container,only,false,if,scores,iter,has,next,string,msg,error,iterating,normalized,results,logger,error,job,id,msg,throw,new,elasticsearch,exception,msg,result,reset,big,change,flag,if,parent,null,parent,had,big,change,result,set,parent,score,parent,get,normalized,score,result,raise,big,change,flag,double,normalized,score,scores,iter,next,get,normalized,score,has,big,change,is,big,update,result,get,normalized,score,normalized,score,if,has,big,change,result,set,normalized,score,normalized,score,result,raise,big,change,flag,if,parent,null,parent,raise,big,change,flag,for,normalizable,child,type,children,type,result,get,children,types,list,normalizable,children,result,get,children,children,type,if,children,is,empty,double,max,children,score,0,0,for,normalizable,child,children,max,children,score,math,max,merge,recursively,scores,iter,result,has,big,change,child,max,children,score,has,big,change,result,set,max,children,score,children,type,max,children,score,return,result,get,normalized,score
Normalizer -> private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,                                     boolean parentHadBigChange, Normalizable result);1534338685;Recursively merges the scores returned by the normalization process into the results__@param scoresIter         an Iterator of the scores returned by the normalization process_@param parent             the parent result_@param parentHadBigChange whether the parent had a big change_@param result             the result to be updated_@return the effective normalized score of the given result;private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,_                                    boolean parentHadBigChange, Normalizable result) {_        boolean hasBigChange = false__        if (result.isContainerOnly() == false) {_            if (!scoresIter.hasNext()) {_                String msg = "Error iterating normalized results"__                LOGGER.error("[{}] {}", jobId, msg)__                throw new ElasticsearchException(msg)__            }__            result.resetBigChangeFlag()__            if (parent != null && parentHadBigChange) {_                result.setParentScore(parent.getNormalizedScore())__                result.raiseBigChangeFlag()__            }__            double normalizedScore = scoresIter.next().getNormalizedScore()__            hasBigChange = isBigUpdate(result.getNormalizedScore(), normalizedScore)__            if (hasBigChange) {_                result.setNormalizedScore(normalizedScore)__                result.raiseBigChangeFlag()__                if (parent != null) {_                    parent.raiseBigChangeFlag()__                }_            }_        }__        for (Normalizable.ChildType childrenType : result.getChildrenTypes()) {_            List<Normalizable> children = result.getChildren(childrenType)__            if (!children.isEmpty()) {_                double maxChildrenScore = 0.0__                for (Normalizable child : children) {_                    maxChildrenScore = Math.max(_                            mergeRecursively(scoresIter, result, hasBigChange, child),_                            maxChildrenScore)__                }_                hasBigChange |= result.setMaxChildrenScore(childrenType, maxChildrenScore)__            }_        }_        return result.getNormalizedScore()__    };recursively,merges,the,scores,returned,by,the,normalization,process,into,the,results,param,scores,iter,an,iterator,of,the,scores,returned,by,the,normalization,process,param,parent,the,parent,result,param,parent,had,big,change,whether,the,parent,had,a,big,change,param,result,the,result,to,be,updated,return,the,effective,normalized,score,of,the,given,result;private,double,merge,recursively,iterator,normalizer,result,scores,iter,normalizable,parent,boolean,parent,had,big,change,normalizable,result,boolean,has,big,change,false,if,result,is,container,only,false,if,scores,iter,has,next,string,msg,error,iterating,normalized,results,logger,error,job,id,msg,throw,new,elasticsearch,exception,msg,result,reset,big,change,flag,if,parent,null,parent,had,big,change,result,set,parent,score,parent,get,normalized,score,result,raise,big,change,flag,double,normalized,score,scores,iter,next,get,normalized,score,has,big,change,is,big,update,result,get,normalized,score,normalized,score,if,has,big,change,result,set,normalized,score,normalized,score,result,raise,big,change,flag,if,parent,null,parent,raise,big,change,flag,for,normalizable,child,type,children,type,result,get,children,types,list,normalizable,children,result,get,children,children,type,if,children,is,empty,double,max,children,score,0,0,for,normalizable,child,children,max,children,score,math,max,merge,recursively,scores,iter,result,has,big,change,child,max,children,score,has,big,change,result,set,max,children,score,children,type,max,children,score,return,result,get,normalized,score
Normalizer -> private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,                                     boolean parentHadBigChange, Normalizable result);1538067637;Recursively merges the scores returned by the normalization process into the results__@param scoresIter         an Iterator of the scores returned by the normalization process_@param parent             the parent result_@param parentHadBigChange whether the parent had a big change_@param result             the result to be updated_@return the effective normalized score of the given result;private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,_                                    boolean parentHadBigChange, Normalizable result) {_        boolean hasBigChange = false__        if (result.isContainerOnly() == false) {_            if (!scoresIter.hasNext()) {_                String msg = "Error iterating normalized results"__                LOGGER.error("[{}] {}", jobId, msg)__                throw new ElasticsearchException(msg)__            }__            result.resetBigChangeFlag()__            if (parent != null && parentHadBigChange) {_                result.setParentScore(parent.getNormalizedScore())__                result.raiseBigChangeFlag()__            }__            double normalizedScore = scoresIter.next().getNormalizedScore()__            hasBigChange = isBigUpdate(result.getNormalizedScore(), normalizedScore)__            if (hasBigChange) {_                result.setNormalizedScore(normalizedScore)__                result.raiseBigChangeFlag()__                if (parent != null) {_                    parent.raiseBigChangeFlag()__                }_            }_        }__        for (Normalizable.ChildType childrenType : result.getChildrenTypes()) {_            List<Normalizable> children = result.getChildren(childrenType)__            if (!children.isEmpty()) {_                double maxChildrenScore = 0.0__                for (Normalizable child : children) {_                    maxChildrenScore = Math.max(_                            mergeRecursively(scoresIter, result, hasBigChange, child),_                            maxChildrenScore)__                }_                hasBigChange |= result.setMaxChildrenScore(childrenType, maxChildrenScore)__            }_        }_        return result.getNormalizedScore()__    };recursively,merges,the,scores,returned,by,the,normalization,process,into,the,results,param,scores,iter,an,iterator,of,the,scores,returned,by,the,normalization,process,param,parent,the,parent,result,param,parent,had,big,change,whether,the,parent,had,a,big,change,param,result,the,result,to,be,updated,return,the,effective,normalized,score,of,the,given,result;private,double,merge,recursively,iterator,normalizer,result,scores,iter,normalizable,parent,boolean,parent,had,big,change,normalizable,result,boolean,has,big,change,false,if,result,is,container,only,false,if,scores,iter,has,next,string,msg,error,iterating,normalized,results,logger,error,job,id,msg,throw,new,elasticsearch,exception,msg,result,reset,big,change,flag,if,parent,null,parent,had,big,change,result,set,parent,score,parent,get,normalized,score,result,raise,big,change,flag,double,normalized,score,scores,iter,next,get,normalized,score,has,big,change,is,big,update,result,get,normalized,score,normalized,score,if,has,big,change,result,set,normalized,score,normalized,score,result,raise,big,change,flag,if,parent,null,parent,raise,big,change,flag,for,normalizable,child,type,children,type,result,get,children,types,list,normalizable,children,result,get,children,children,type,if,children,is,empty,double,max,children,score,0,0,for,normalizable,child,children,max,children,score,math,max,merge,recursively,scores,iter,result,has,big,change,child,max,children,score,has,big,change,result,set,max,children,score,children,type,max,children,score,return,result,get,normalized,score
Normalizer -> private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,                                     boolean parentHadBigChange, Normalizable result);1540847035;Recursively merges the scores returned by the normalization process into the results__@param scoresIter         an Iterator of the scores returned by the normalization process_@param parent             the parent result_@param parentHadBigChange whether the parent had a big change_@param result             the result to be updated_@return the effective normalized score of the given result;private double mergeRecursively(Iterator<NormalizerResult> scoresIter, Normalizable parent,_                                    boolean parentHadBigChange, Normalizable result) {_        boolean hasBigChange = false__        if (result.isContainerOnly() == false) {_            if (!scoresIter.hasNext()) {_                String msg = "Error iterating normalized results"__                LOGGER.error("[{}] {}", jobId, msg)__                throw new ElasticsearchException(msg)__            }__            result.resetBigChangeFlag()__            if (parent != null && parentHadBigChange) {_                result.setParentScore(parent.getNormalizedScore())__                result.raiseBigChangeFlag()__            }__            double normalizedScore = scoresIter.next().getNormalizedScore()__            hasBigChange = isBigUpdate(result.getNormalizedScore(), normalizedScore)__            if (hasBigChange) {_                result.setNormalizedScore(normalizedScore)__                result.raiseBigChangeFlag()__                if (parent != null) {_                    parent.raiseBigChangeFlag()__                }_            }_        }__        for (Normalizable.ChildType childrenType : result.getChildrenTypes()) {_            List<Normalizable> children = result.getChildren(childrenType)__            if (!children.isEmpty()) {_                double maxChildrenScore = 0.0__                for (Normalizable child : children) {_                    maxChildrenScore = Math.max(_                            mergeRecursively(scoresIter, result, hasBigChange, child),_                            maxChildrenScore)__                }_                hasBigChange |= result.setMaxChildrenScore(childrenType, maxChildrenScore)__            }_        }_        return result.getNormalizedScore()__    };recursively,merges,the,scores,returned,by,the,normalization,process,into,the,results,param,scores,iter,an,iterator,of,the,scores,returned,by,the,normalization,process,param,parent,the,parent,result,param,parent,had,big,change,whether,the,parent,had,a,big,change,param,result,the,result,to,be,updated,return,the,effective,normalized,score,of,the,given,result;private,double,merge,recursively,iterator,normalizer,result,scores,iter,normalizable,parent,boolean,parent,had,big,change,normalizable,result,boolean,has,big,change,false,if,result,is,container,only,false,if,scores,iter,has,next,string,msg,error,iterating,normalized,results,logger,error,job,id,msg,throw,new,elasticsearch,exception,msg,result,reset,big,change,flag,if,parent,null,parent,had,big,change,result,set,parent,score,parent,get,normalized,score,result,raise,big,change,flag,double,normalized,score,scores,iter,next,get,normalized,score,has,big,change,is,big,update,result,get,normalized,score,normalized,score,if,has,big,change,result,set,normalized,score,normalized,score,result,raise,big,change,flag,if,parent,null,parent,raise,big,change,flag,for,normalizable,child,type,children,type,result,get,children,types,list,normalizable,children,result,get,children,children,type,if,children,is,empty,double,max,children,score,0,0,for,normalizable,child,children,max,children,score,math,max,merge,recursively,scores,iter,result,has,big,change,child,max,children,score,has,big,change,result,set,max,children,score,children,type,max,children,score,return,result,get,normalized,score
Normalizer -> private static boolean isBigUpdate(double oldVal, double newVal);1524684173;Encapsulate the logic for deciding whether a change to a normalized score_is "big"._<p>_Current logic is that a big change is a change of at least 1 or more than_than 50% of the higher of the two values.__@param oldVal The old value of the normalized score_@param newVal The new value of the normalized score_@return true if the update is considered "big";private static boolean isBigUpdate(double oldVal, double newVal) {_        if (Math.abs(oldVal - newVal) >= 1.0) {_            return true__        }_        if (oldVal > newVal) {_            if (oldVal * 0.5 > newVal) {_                return true__            }_        } else {_            if (newVal * 0.5 > oldVal) {_                return true__            }_        }__        return false__    };encapsulate,the,logic,for,deciding,whether,a,change,to,a,normalized,score,is,big,p,current,logic,is,that,a,big,change,is,a,change,of,at,least,1,or,more,than,than,50,of,the,higher,of,the,two,values,param,old,val,the,old,value,of,the,normalized,score,param,new,val,the,new,value,of,the,normalized,score,return,true,if,the,update,is,considered,big;private,static,boolean,is,big,update,double,old,val,double,new,val,if,math,abs,old,val,new,val,1,0,return,true,if,old,val,new,val,if,old,val,0,5,new,val,return,true,else,if,new,val,0,5,old,val,return,true,return,false
Normalizer -> private static boolean isBigUpdate(double oldVal, double newVal);1534176840;Encapsulate the logic for deciding whether a change to a normalized score_is "big"._<p>_Current logic is that a big change is a change of at least 1 or more than_than 50% of the higher of the two values.__@param oldVal The old value of the normalized score_@param newVal The new value of the normalized score_@return true if the update is considered "big";private static boolean isBigUpdate(double oldVal, double newVal) {_        if (Math.abs(oldVal - newVal) >= 1.0) {_            return true__        }_        if (oldVal > newVal) {_            if (oldVal * 0.5 > newVal) {_                return true__            }_        } else {_            if (newVal * 0.5 > oldVal) {_                return true__            }_        }__        return false__    };encapsulate,the,logic,for,deciding,whether,a,change,to,a,normalized,score,is,big,p,current,logic,is,that,a,big,change,is,a,change,of,at,least,1,or,more,than,than,50,of,the,higher,of,the,two,values,param,old,val,the,old,value,of,the,normalized,score,param,new,val,the,new,value,of,the,normalized,score,return,true,if,the,update,is,considered,big;private,static,boolean,is,big,update,double,old,val,double,new,val,if,math,abs,old,val,new,val,1,0,return,true,if,old,val,new,val,if,old,val,0,5,new,val,return,true,else,if,new,val,0,5,old,val,return,true,return,false
Normalizer -> private static boolean isBigUpdate(double oldVal, double newVal);1534338685;Encapsulate the logic for deciding whether a change to a normalized score_is "big"._<p>_Current logic is that a big change is a change of at least 1 or more than_than 50% of the higher of the two values.__@param oldVal The old value of the normalized score_@param newVal The new value of the normalized score_@return true if the update is considered "big";private static boolean isBigUpdate(double oldVal, double newVal) {_        if (Math.abs(oldVal - newVal) >= 1.0) {_            return true__        }_        if (oldVal > newVal) {_            if (oldVal * 0.5 > newVal) {_                return true__            }_        } else {_            if (newVal * 0.5 > oldVal) {_                return true__            }_        }__        return false__    };encapsulate,the,logic,for,deciding,whether,a,change,to,a,normalized,score,is,big,p,current,logic,is,that,a,big,change,is,a,change,of,at,least,1,or,more,than,than,50,of,the,higher,of,the,two,values,param,old,val,the,old,value,of,the,normalized,score,param,new,val,the,new,value,of,the,normalized,score,return,true,if,the,update,is,considered,big;private,static,boolean,is,big,update,double,old,val,double,new,val,if,math,abs,old,val,new,val,1,0,return,true,if,old,val,new,val,if,old,val,0,5,new,val,return,true,else,if,new,val,0,5,old,val,return,true,return,false
Normalizer -> private static boolean isBigUpdate(double oldVal, double newVal);1538067637;Encapsulate the logic for deciding whether a change to a normalized score_is "big"._<p>_Current logic is that a change is considered big if any of the following criteria are met:_<ul>_<li>the change  would result in a change of colour in the UI_(e.g. severity would be changed from WARNING to MINOR)</li>_<li>the change is at least 1.5</li>_<li>the change in values is greater than 67% of the higher of the two values.</li>_</ul>_These values have been chosen through a process of experimentation, in particular it was desired to reduce_the number of updates written to the results index due to renormalization events for performance reasons_while not changing the normalized scores greatly__@param oldVal The old value of the normalized score_@param newVal The new value of the normalized score_@return true if the update is considered "big";private static boolean isBigUpdate(double oldVal, double newVal) {_        if ((int) (oldVal / 25.0) != (int) (newVal / 25.0)) {_            return true__        }_        if (Math.abs(oldVal - newVal) >= 1.5) {_            return true__        }_        if (oldVal > newVal) {_            if (oldVal * 0.33 > newVal) {_                return true__            }_        } else {_            if (newVal * 0.33 > oldVal) {_                return true__            }_        }__        return false__    };encapsulate,the,logic,for,deciding,whether,a,change,to,a,normalized,score,is,big,p,current,logic,is,that,a,change,is,considered,big,if,any,of,the,following,criteria,are,met,ul,li,the,change,would,result,in,a,change,of,colour,in,the,ui,e,g,severity,would,be,changed,from,warning,to,minor,li,li,the,change,is,at,least,1,5,li,li,the,change,in,values,is,greater,than,67,of,the,higher,of,the,two,values,li,ul,these,values,have,been,chosen,through,a,process,of,experimentation,in,particular,it,was,desired,to,reduce,the,number,of,updates,written,to,the,results,index,due,to,renormalization,events,for,performance,reasons,while,not,changing,the,normalized,scores,greatly,param,old,val,the,old,value,of,the,normalized,score,param,new,val,the,new,value,of,the,normalized,score,return,true,if,the,update,is,considered,big;private,static,boolean,is,big,update,double,old,val,double,new,val,if,int,old,val,25,0,int,new,val,25,0,return,true,if,math,abs,old,val,new,val,1,5,return,true,if,old,val,new,val,if,old,val,0,33,new,val,return,true,else,if,new,val,0,33,old,val,return,true,return,false
Normalizer -> private static boolean isBigUpdate(double oldVal, double newVal);1540847035;Encapsulate the logic for deciding whether a change to a normalized score_is "big"._<p>_Current logic is that a change is considered big if any of the following criteria are met:_<ul>_<li>the change  would result in a change of colour in the UI_(e.g. severity would be changed from WARNING to MINOR)</li>_<li>the change is at least 1.5</li>_<li>the change in values is greater than 67% of the higher of the two values.</li>_</ul>_These values have been chosen through a process of experimentation, in particular it was desired to reduce_the number of updates written to the results index due to renormalization events for performance reasons_while not changing the normalized scores greatly__@param oldVal The old value of the normalized score_@param newVal The new value of the normalized score_@return true if the update is considered "big";private static boolean isBigUpdate(double oldVal, double newVal) {_        if ((int) (oldVal / 25.0) != (int) (newVal / 25.0)) {_            return true__        }_        if (Math.abs(oldVal - newVal) >= 1.5) {_            return true__        }_        if (oldVal > newVal) {_            if (oldVal * 0.33 > newVal) {_                return true__            }_        } else {_            if (newVal * 0.33 > oldVal) {_                return true__            }_        }__        return false__    };encapsulate,the,logic,for,deciding,whether,a,change,to,a,normalized,score,is,big,p,current,logic,is,that,a,change,is,considered,big,if,any,of,the,following,criteria,are,met,ul,li,the,change,would,result,in,a,change,of,colour,in,the,ui,e,g,severity,would,be,changed,from,warning,to,minor,li,li,the,change,is,at,least,1,5,li,li,the,change,in,values,is,greater,than,67,of,the,higher,of,the,two,values,li,ul,these,values,have,been,chosen,through,a,process,of,experimentation,in,particular,it,was,desired,to,reduce,the,number,of,updates,written,to,the,results,index,due,to,renormalization,events,for,performance,reasons,while,not,changing,the,normalized,scores,greatly,param,old,val,the,old,value,of,the,normalized,score,param,new,val,the,new,value,of,the,normalized,score,return,true,if,the,update,is,considered,big;private,static,boolean,is,big,update,double,old,val,double,new,val,if,int,old,val,25,0,int,new,val,25,0,return,true,if,math,abs,old,val,new,val,1,5,return,true,if,old,val,new,val,if,old,val,0,33,new,val,return,true,else,if,new,val,0,33,old,val,return,true,return,false
