# id;timestamp;commentText;codeText;commentWords;codeWords
DelimitedFileStructureFinder -> static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow);1536314350;Sum of the Levenshtein distances between corresponding elements_in the two supplied lists _excluding_ the biggest difference._The reason the biggest difference is excluded is that sometimes_there's a "message" field that is much longer than any of the other_fields, varies enormously between rows, and skews the comparison.;static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow) {__        int largestSize = Math.max(firstRow.size(), secondRow.size())__        if (largestSize <= 1) {_            return 0__        }__        int[] distances = new int[largestSize]___        for (int index = 0_ index < largestSize_ ++index) {_            distances[index] = levenshteinDistance((index < firstRow.size()) ? firstRow.get(index) : "",_                (index < secondRow.size()) ? secondRow.get(index) : "")__        }__        Arrays.sort(distances)___        return IntStream.of(distances).limit(distances.length - 1).sum()__    };sum,of,the,levenshtein,distances,between,corresponding,elements,in,the,two,supplied,lists,the,biggest,difference,the,reason,the,biggest,difference,is,excluded,is,that,sometimes,there,s,a,message,field,that,is,much,longer,than,any,of,the,other,fields,varies,enormously,between,rows,and,skews,the,comparison;static,int,levenshtein,fieldwise,compare,rows,list,string,first,row,list,string,second,row,int,largest,size,math,max,first,row,size,second,row,size,if,largest,size,1,return,0,int,distances,new,int,largest,size,for,int,index,0,index,largest,size,index,distances,index,levenshtein,distance,index,first,row,size,first,row,get,index,index,second,row,size,second,row,get,index,arrays,sort,distances,return,int,stream,of,distances,limit,distances,length,1,sum
DelimitedFileStructureFinder -> static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow);1536828374;Sum of the Levenshtein distances between corresponding elements_in the two supplied lists _excluding_ the biggest difference._The reason the biggest difference is excluded is that sometimes_there's a "message" field that is much longer than any of the other_fields, varies enormously between rows, and skews the comparison.;static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow) {__        int largestSize = Math.max(firstRow.size(), secondRow.size())__        if (largestSize <= 1) {_            return 0__        }__        int[] distances = new int[largestSize]___        for (int index = 0_ index < largestSize_ ++index) {_            distances[index] = levenshteinDistance((index < firstRow.size()) ? firstRow.get(index) : "",_                (index < secondRow.size()) ? secondRow.get(index) : "")__        }__        Arrays.sort(distances)___        return IntStream.of(distances).limit(distances.length - 1).sum()__    };sum,of,the,levenshtein,distances,between,corresponding,elements,in,the,two,supplied,lists,the,biggest,difference,the,reason,the,biggest,difference,is,excluded,is,that,sometimes,there,s,a,message,field,that,is,much,longer,than,any,of,the,other,fields,varies,enormously,between,rows,and,skews,the,comparison;static,int,levenshtein,fieldwise,compare,rows,list,string,first,row,list,string,second,row,int,largest,size,math,max,first,row,size,second,row,size,if,largest,size,1,return,0,int,distances,new,int,largest,size,for,int,index,0,index,largest,size,index,distances,index,levenshtein,distance,index,first,row,size,first,row,get,index,index,second,row,size,second,row,get,index,arrays,sort,distances,return,int,stream,of,distances,limit,distances,length,1,sum
DelimitedFileStructureFinder -> static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow);1536964057;Sum of the Levenshtein distances between corresponding elements_in the two supplied lists _excluding_ the biggest difference._The reason the biggest difference is excluded is that sometimes_there's a "message" field that is much longer than any of the other_fields, varies enormously between rows, and skews the comparison.;static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow) {__        int largestSize = Math.max(firstRow.size(), secondRow.size())__        if (largestSize <= 1) {_            return 0__        }__        int[] distances = new int[largestSize]___        for (int index = 0_ index < largestSize_ ++index) {_            distances[index] = levenshteinDistance((index < firstRow.size()) ? firstRow.get(index) : "",_                (index < secondRow.size()) ? secondRow.get(index) : "")__        }__        Arrays.sort(distances)___        return IntStream.of(distances).limit(distances.length - 1).sum()__    };sum,of,the,levenshtein,distances,between,corresponding,elements,in,the,two,supplied,lists,the,biggest,difference,the,reason,the,biggest,difference,is,excluded,is,that,sometimes,there,s,a,message,field,that,is,much,longer,than,any,of,the,other,fields,varies,enormously,between,rows,and,skews,the,comparison;static,int,levenshtein,fieldwise,compare,rows,list,string,first,row,list,string,second,row,int,largest,size,math,max,first,row,size,second,row,size,if,largest,size,1,return,0,int,distances,new,int,largest,size,for,int,index,0,index,largest,size,index,distances,index,levenshtein,distance,index,first,row,size,first,row,get,index,index,second,row,size,second,row,get,index,arrays,sort,distances,return,int,stream,of,distances,limit,distances,length,1,sum
DelimitedFileStructureFinder -> static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow);1538067637;Sum of the Levenshtein distances between corresponding elements_in the two supplied lists _excluding_ the biggest difference._The reason the biggest difference is excluded is that sometimes_there's a "message" field that is much longer than any of the other_fields, varies enormously between rows, and skews the comparison.;static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow) {__        int largestSize = Math.max(firstRow.size(), secondRow.size())__        if (largestSize <= 1) {_            return 0__        }__        int[] distances = new int[largestSize]___        for (int index = 0_ index < largestSize_ ++index) {_            distances[index] = levenshteinDistance((index < firstRow.size()) ? firstRow.get(index) : "",_                (index < secondRow.size()) ? secondRow.get(index) : "")__        }__        Arrays.sort(distances)___        return IntStream.of(distances).limit(distances.length - 1).sum()__    };sum,of,the,levenshtein,distances,between,corresponding,elements,in,the,two,supplied,lists,the,biggest,difference,the,reason,the,biggest,difference,is,excluded,is,that,sometimes,there,s,a,message,field,that,is,much,longer,than,any,of,the,other,fields,varies,enormously,between,rows,and,skews,the,comparison;static,int,levenshtein,fieldwise,compare,rows,list,string,first,row,list,string,second,row,int,largest,size,math,max,first,row,size,second,row,size,if,largest,size,1,return,0,int,distances,new,int,largest,size,for,int,index,0,index,largest,size,index,distances,index,levenshtein,distance,index,first,row,size,first,row,get,index,index,second,row,size,second,row,get,index,arrays,sort,distances,return,int,stream,of,distances,limit,distances,length,1,sum
DelimitedFileStructureFinder -> static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow);1538170812;Sum of the Levenshtein distances between corresponding elements_in the two supplied lists _excluding_ the biggest difference._The reason the biggest difference is excluded is that sometimes_there's a "message" field that is much longer than any of the other_fields, varies enormously between rows, and skews the comparison.;static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow) {__        int largestSize = Math.max(firstRow.size(), secondRow.size())__        if (largestSize <= 1) {_            return 0__        }__        int[] distances = new int[largestSize]___        for (int index = 0_ index < largestSize_ ++index) {_            distances[index] = levenshteinDistance((index < firstRow.size()) ? firstRow.get(index) : "",_                (index < secondRow.size()) ? secondRow.get(index) : "")__        }__        Arrays.sort(distances)___        return IntStream.of(distances).limit(distances.length - 1).sum()__    };sum,of,the,levenshtein,distances,between,corresponding,elements,in,the,two,supplied,lists,the,biggest,difference,the,reason,the,biggest,difference,is,excluded,is,that,sometimes,there,s,a,message,field,that,is,much,longer,than,any,of,the,other,fields,varies,enormously,between,rows,and,skews,the,comparison;static,int,levenshtein,fieldwise,compare,rows,list,string,first,row,list,string,second,row,int,largest,size,math,max,first,row,size,second,row,size,if,largest,size,1,return,0,int,distances,new,int,largest,size,for,int,index,0,index,largest,size,index,distances,index,levenshtein,distance,index,first,row,size,first,row,get,index,index,second,row,size,second,row,get,index,arrays,sort,distances,return,int,stream,of,distances,limit,distances,length,1,sum
DelimitedFileStructureFinder -> static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow);1539615817;Sum of the Levenshtein distances between corresponding elements_in the two supplied lists _excluding_ the biggest difference._The reason the biggest difference is excluded is that sometimes_there's a "message" field that is much longer than any of the other_fields, varies enormously between rows, and skews the comparison.;static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow) {__        int largestSize = Math.max(firstRow.size(), secondRow.size())__        if (largestSize <= 1) {_            return 0__        }__        int[] distances = new int[largestSize]___        for (int index = 0_ index < largestSize_ ++index) {_            distances[index] = levenshteinDistance((index < firstRow.size()) ? firstRow.get(index) : "",_                (index < secondRow.size()) ? secondRow.get(index) : "")__        }__        Arrays.sort(distances)___        return IntStream.of(distances).limit(distances.length - 1).sum()__    };sum,of,the,levenshtein,distances,between,corresponding,elements,in,the,two,supplied,lists,the,biggest,difference,the,reason,the,biggest,difference,is,excluded,is,that,sometimes,there,s,a,message,field,that,is,much,longer,than,any,of,the,other,fields,varies,enormously,between,rows,and,skews,the,comparison;static,int,levenshtein,fieldwise,compare,rows,list,string,first,row,list,string,second,row,int,largest,size,math,max,first,row,size,second,row,size,if,largest,size,1,return,0,int,distances,new,int,largest,size,for,int,index,0,index,largest,size,index,distances,index,levenshtein,distance,index,first,row,size,first,row,get,index,index,second,row,size,second,row,get,index,arrays,sort,distances,return,int,stream,of,distances,limit,distances,length,1,sum
DelimitedFileStructureFinder -> static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow);1542098964;Sum of the Levenshtein distances between corresponding elements_in the two supplied lists _excluding_ the biggest difference._The reason the biggest difference is excluded is that sometimes_there's a "message" field that is much longer than any of the other_fields, varies enormously between rows, and skews the comparison.;static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow) {__        int largestSize = Math.max(firstRow.size(), secondRow.size())__        if (largestSize <= 1) {_            return 0__        }__        int[] distances = new int[largestSize]___        for (int index = 0_ index < largestSize_ ++index) {_            distances[index] = levenshteinDistance((index < firstRow.size()) ? firstRow.get(index) : "",_                (index < secondRow.size()) ? secondRow.get(index) : "")__        }__        Arrays.sort(distances)___        return IntStream.of(distances).limit(distances.length - 1).sum()__    };sum,of,the,levenshtein,distances,between,corresponding,elements,in,the,two,supplied,lists,the,biggest,difference,the,reason,the,biggest,difference,is,excluded,is,that,sometimes,there,s,a,message,field,that,is,much,longer,than,any,of,the,other,fields,varies,enormously,between,rows,and,skews,the,comparison;static,int,levenshtein,fieldwise,compare,rows,list,string,first,row,list,string,second,row,int,largest,size,math,max,first,row,size,second,row,size,if,largest,size,1,return,0,int,distances,new,int,largest,size,for,int,index,0,index,largest,size,index,distances,index,levenshtein,distance,index,first,row,size,first,row,get,index,index,second,row,size,second,row,get,index,arrays,sort,distances,return,int,stream,of,distances,limit,distances,length,1,sum
DelimitedFileStructureFinder -> static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow);1548533997;Sum of the Levenshtein distances between corresponding elements_in the two supplied lists _excluding_ the biggest difference._The reason the biggest difference is excluded is that sometimes_there's a "message" field that is much longer than any of the other_fields, varies enormously between rows, and skews the comparison.;static int levenshteinFieldwiseCompareRows(List<String> firstRow, List<String> secondRow) {__        int largestSize = Math.max(firstRow.size(), secondRow.size())__        if (largestSize <= 1) {_            return 0__        }__        int[] distances = new int[largestSize]___        for (int index = 0_ index < largestSize_ ++index) {_            distances[index] = levenshteinDistance((index < firstRow.size()) ? firstRow.get(index) : "",_                (index < secondRow.size()) ? secondRow.get(index) : "")__        }__        Arrays.sort(distances)___        return IntStream.of(distances).limit(distances.length - 1).sum()__    };sum,of,the,levenshtein,distances,between,corresponding,elements,in,the,two,supplied,lists,the,biggest,difference,the,reason,the,biggest,difference,is,excluded,is,that,sometimes,there,s,a,message,field,that,is,much,longer,than,any,of,the,other,fields,varies,enormously,between,rows,and,skews,the,comparison;static,int,levenshtein,fieldwise,compare,rows,list,string,first,row,list,string,second,row,int,largest,size,math,max,first,row,size,second,row,size,if,largest,size,1,return,0,int,distances,new,int,largest,size,for,int,index,0,index,largest,size,index,distances,index,levenshtein,distance,index,first,row,size,first,row,get,index,index,second,row,size,second,row,get,index,arrays,sort,distances,return,int,stream,of,distances,limit,distances,length,1,sum
DelimitedFileStructureFinder -> static int levenshteinDistance(String first, String second);1536314350;This method implements the simple algorithm for calculating Levenshtein distance.;static int levenshteinDistance(String first, String second) {__        _        __        int firstLen = (first == null) ? 0 : first.length()__        int secondLen = (second == null) ? 0 : second.length()__        if (firstLen == 0) {_            return secondLen__        }_        if (secondLen == 0) {_            return firstLen__        }__        int[] currentCol = new int[secondLen + 1]__        int[] prevCol = new int[secondLen + 1]___        _        for (int down = 0_ down <= secondLen_ ++down) {_            currentCol[down] = down__        }__        _        for (int across = 1_ across <= firstLen_ ++across) {_            int[] tmp = prevCol__            prevCol = currentCol__            _            currentCol = tmp___            currentCol[0] = across___            for (int down = 1_ down <= secondLen_ ++down) {__                _                if (first.charAt(across - 1) == second.charAt(down - 1)) {__                    _                    currentCol[down] = prevCol[down - 1]__                } else {_                    __                    _                    int option1 = prevCol[down]___                    _                    int option2 = currentCol[down - 1]___                    _                    int option3 = prevCol[down - 1]___                    _                    currentCol[down] = Math.min(Math.min(option1, option2), option3) + 1__                }_            }_        }__        _        return currentCol[secondLen]__    };this,method,implements,the,simple,algorithm,for,calculating,levenshtein,distance;static,int,levenshtein,distance,string,first,string,second,int,first,len,first,null,0,first,length,int,second,len,second,null,0,second,length,if,first,len,0,return,second,len,if,second,len,0,return,first,len,int,current,col,new,int,second,len,1,int,prev,col,new,int,second,len,1,for,int,down,0,down,second,len,down,current,col,down,down,for,int,across,1,across,first,len,across,int,tmp,prev,col,prev,col,current,col,current,col,tmp,current,col,0,across,for,int,down,1,down,second,len,down,if,first,char,at,across,1,second,char,at,down,1,current,col,down,prev,col,down,1,else,int,option1,prev,col,down,int,option2,current,col,down,1,int,option3,prev,col,down,1,current,col,down,math,min,math,min,option1,option2,option3,1,return,current,col,second,len
DelimitedFileStructureFinder -> static int levenshteinDistance(String first, String second);1536828374;This method implements the simple algorithm for calculating Levenshtein distance.;static int levenshteinDistance(String first, String second) {__        _        __        int firstLen = (first == null) ? 0 : first.length()__        int secondLen = (second == null) ? 0 : second.length()__        if (firstLen == 0) {_            return secondLen__        }_        if (secondLen == 0) {_            return firstLen__        }__        int[] currentCol = new int[secondLen + 1]__        int[] prevCol = new int[secondLen + 1]___        _        for (int down = 0_ down <= secondLen_ ++down) {_            currentCol[down] = down__        }__        _        for (int across = 1_ across <= firstLen_ ++across) {_            int[] tmp = prevCol__            prevCol = currentCol__            _            currentCol = tmp___            currentCol[0] = across___            for (int down = 1_ down <= secondLen_ ++down) {__                _                if (first.charAt(across - 1) == second.charAt(down - 1)) {__                    _                    currentCol[down] = prevCol[down - 1]__                } else {_                    __                    _                    int option1 = prevCol[down]___                    _                    int option2 = currentCol[down - 1]___                    _                    int option3 = prevCol[down - 1]___                    _                    currentCol[down] = Math.min(Math.min(option1, option2), option3) + 1__                }_            }_        }__        _        return currentCol[secondLen]__    };this,method,implements,the,simple,algorithm,for,calculating,levenshtein,distance;static,int,levenshtein,distance,string,first,string,second,int,first,len,first,null,0,first,length,int,second,len,second,null,0,second,length,if,first,len,0,return,second,len,if,second,len,0,return,first,len,int,current,col,new,int,second,len,1,int,prev,col,new,int,second,len,1,for,int,down,0,down,second,len,down,current,col,down,down,for,int,across,1,across,first,len,across,int,tmp,prev,col,prev,col,current,col,current,col,tmp,current,col,0,across,for,int,down,1,down,second,len,down,if,first,char,at,across,1,second,char,at,down,1,current,col,down,prev,col,down,1,else,int,option1,prev,col,down,int,option2,current,col,down,1,int,option3,prev,col,down,1,current,col,down,math,min,math,min,option1,option2,option3,1,return,current,col,second,len
DelimitedFileStructureFinder -> static int levenshteinDistance(String first, String second);1536964057;This method implements the simple algorithm for calculating Levenshtein distance.;static int levenshteinDistance(String first, String second) {__        _        __        int firstLen = (first == null) ? 0 : first.length()__        int secondLen = (second == null) ? 0 : second.length()__        if (firstLen == 0) {_            return secondLen__        }_        if (secondLen == 0) {_            return firstLen__        }__        int[] currentCol = new int[secondLen + 1]__        int[] prevCol = new int[secondLen + 1]___        _        for (int down = 0_ down <= secondLen_ ++down) {_            currentCol[down] = down__        }__        _        for (int across = 1_ across <= firstLen_ ++across) {_            int[] tmp = prevCol__            prevCol = currentCol__            _            currentCol = tmp___            currentCol[0] = across___            for (int down = 1_ down <= secondLen_ ++down) {__                _                if (first.charAt(across - 1) == second.charAt(down - 1)) {__                    _                    currentCol[down] = prevCol[down - 1]__                } else {_                    __                    _                    int option1 = prevCol[down]___                    _                    int option2 = currentCol[down - 1]___                    _                    int option3 = prevCol[down - 1]___                    _                    currentCol[down] = Math.min(Math.min(option1, option2), option3) + 1__                }_            }_        }__        _        return currentCol[secondLen]__    };this,method,implements,the,simple,algorithm,for,calculating,levenshtein,distance;static,int,levenshtein,distance,string,first,string,second,int,first,len,first,null,0,first,length,int,second,len,second,null,0,second,length,if,first,len,0,return,second,len,if,second,len,0,return,first,len,int,current,col,new,int,second,len,1,int,prev,col,new,int,second,len,1,for,int,down,0,down,second,len,down,current,col,down,down,for,int,across,1,across,first,len,across,int,tmp,prev,col,prev,col,current,col,current,col,tmp,current,col,0,across,for,int,down,1,down,second,len,down,if,first,char,at,across,1,second,char,at,down,1,current,col,down,prev,col,down,1,else,int,option1,prev,col,down,int,option2,current,col,down,1,int,option3,prev,col,down,1,current,col,down,math,min,math,min,option1,option2,option3,1,return,current,col,second,len
DelimitedFileStructureFinder -> static int levenshteinDistance(String first, String second);1538067637;This method implements the simple algorithm for calculating Levenshtein distance.;static int levenshteinDistance(String first, String second) {__        _        __        int firstLen = (first == null) ? 0 : first.length()__        int secondLen = (second == null) ? 0 : second.length()__        if (firstLen == 0) {_            return secondLen__        }_        if (secondLen == 0) {_            return firstLen__        }__        int[] currentCol = new int[secondLen + 1]__        int[] prevCol = new int[secondLen + 1]___        _        for (int down = 0_ down <= secondLen_ ++down) {_            currentCol[down] = down__        }__        _        for (int across = 1_ across <= firstLen_ ++across) {_            int[] tmp = prevCol__            prevCol = currentCol__            _            currentCol = tmp___            currentCol[0] = across___            for (int down = 1_ down <= secondLen_ ++down) {__                _                if (first.charAt(across - 1) == second.charAt(down - 1)) {__                    _                    currentCol[down] = prevCol[down - 1]__                } else {_                    __                    _                    int option1 = prevCol[down]___                    _                    int option2 = currentCol[down - 1]___                    _                    int option3 = prevCol[down - 1]___                    _                    currentCol[down] = Math.min(Math.min(option1, option2), option3) + 1__                }_            }_        }__        _        return currentCol[secondLen]__    };this,method,implements,the,simple,algorithm,for,calculating,levenshtein,distance;static,int,levenshtein,distance,string,first,string,second,int,first,len,first,null,0,first,length,int,second,len,second,null,0,second,length,if,first,len,0,return,second,len,if,second,len,0,return,first,len,int,current,col,new,int,second,len,1,int,prev,col,new,int,second,len,1,for,int,down,0,down,second,len,down,current,col,down,down,for,int,across,1,across,first,len,across,int,tmp,prev,col,prev,col,current,col,current,col,tmp,current,col,0,across,for,int,down,1,down,second,len,down,if,first,char,at,across,1,second,char,at,down,1,current,col,down,prev,col,down,1,else,int,option1,prev,col,down,int,option2,current,col,down,1,int,option3,prev,col,down,1,current,col,down,math,min,math,min,option1,option2,option3,1,return,current,col,second,len
DelimitedFileStructureFinder -> static int levenshteinDistance(String first, String second);1538170812;This method implements the simple algorithm for calculating Levenshtein distance.;static int levenshteinDistance(String first, String second) {__        _        __        int firstLen = (first == null) ? 0 : first.length()__        int secondLen = (second == null) ? 0 : second.length()__        if (firstLen == 0) {_            return secondLen__        }_        if (secondLen == 0) {_            return firstLen__        }__        int[] currentCol = new int[secondLen + 1]__        int[] prevCol = new int[secondLen + 1]___        _        for (int down = 0_ down <= secondLen_ ++down) {_            currentCol[down] = down__        }__        _        for (int across = 1_ across <= firstLen_ ++across) {_            int[] tmp = prevCol__            prevCol = currentCol__            _            currentCol = tmp___            currentCol[0] = across___            for (int down = 1_ down <= secondLen_ ++down) {__                _                if (first.charAt(across - 1) == second.charAt(down - 1)) {__                    _                    currentCol[down] = prevCol[down - 1]__                } else {_                    __                    _                    int option1 = prevCol[down]___                    _                    int option2 = currentCol[down - 1]___                    _                    int option3 = prevCol[down - 1]___                    _                    currentCol[down] = Math.min(Math.min(option1, option2), option3) + 1__                }_            }_        }__        _        return currentCol[secondLen]__    };this,method,implements,the,simple,algorithm,for,calculating,levenshtein,distance;static,int,levenshtein,distance,string,first,string,second,int,first,len,first,null,0,first,length,int,second,len,second,null,0,second,length,if,first,len,0,return,second,len,if,second,len,0,return,first,len,int,current,col,new,int,second,len,1,int,prev,col,new,int,second,len,1,for,int,down,0,down,second,len,down,current,col,down,down,for,int,across,1,across,first,len,across,int,tmp,prev,col,prev,col,current,col,current,col,tmp,current,col,0,across,for,int,down,1,down,second,len,down,if,first,char,at,across,1,second,char,at,down,1,current,col,down,prev,col,down,1,else,int,option1,prev,col,down,int,option2,current,col,down,1,int,option3,prev,col,down,1,current,col,down,math,min,math,min,option1,option2,option3,1,return,current,col,second,len
DelimitedFileStructureFinder -> static int levenshteinDistance(String first, String second);1539615817;This method implements the simple algorithm for calculating Levenshtein distance.;static int levenshteinDistance(String first, String second) {__        _        __        int firstLen = (first == null) ? 0 : first.length()__        int secondLen = (second == null) ? 0 : second.length()__        if (firstLen == 0) {_            return secondLen__        }_        if (secondLen == 0) {_            return firstLen__        }__        int[] currentCol = new int[secondLen + 1]__        int[] prevCol = new int[secondLen + 1]___        _        for (int down = 0_ down <= secondLen_ ++down) {_            currentCol[down] = down__        }__        _        for (int across = 1_ across <= firstLen_ ++across) {_            int[] tmp = prevCol__            prevCol = currentCol__            _            currentCol = tmp___            currentCol[0] = across___            for (int down = 1_ down <= secondLen_ ++down) {__                _                if (first.charAt(across - 1) == second.charAt(down - 1)) {__                    _                    currentCol[down] = prevCol[down - 1]__                } else {_                    __                    _                    int option1 = prevCol[down]___                    _                    int option2 = currentCol[down - 1]___                    _                    int option3 = prevCol[down - 1]___                    _                    currentCol[down] = Math.min(Math.min(option1, option2), option3) + 1__                }_            }_        }__        _        return currentCol[secondLen]__    };this,method,implements,the,simple,algorithm,for,calculating,levenshtein,distance;static,int,levenshtein,distance,string,first,string,second,int,first,len,first,null,0,first,length,int,second,len,second,null,0,second,length,if,first,len,0,return,second,len,if,second,len,0,return,first,len,int,current,col,new,int,second,len,1,int,prev,col,new,int,second,len,1,for,int,down,0,down,second,len,down,current,col,down,down,for,int,across,1,across,first,len,across,int,tmp,prev,col,prev,col,current,col,current,col,tmp,current,col,0,across,for,int,down,1,down,second,len,down,if,first,char,at,across,1,second,char,at,down,1,current,col,down,prev,col,down,1,else,int,option1,prev,col,down,int,option2,current,col,down,1,int,option3,prev,col,down,1,current,col,down,math,min,math,min,option1,option2,option3,1,return,current,col,second,len
DelimitedFileStructureFinder -> static int levenshteinDistance(String first, String second);1542098964;This method implements the simple algorithm for calculating Levenshtein distance.;static int levenshteinDistance(String first, String second) {__        _        __        int firstLen = (first == null) ? 0 : first.length()__        int secondLen = (second == null) ? 0 : second.length()__        if (firstLen == 0) {_            return secondLen__        }_        if (secondLen == 0) {_            return firstLen__        }__        int[] currentCol = new int[secondLen + 1]__        int[] prevCol = new int[secondLen + 1]___        _        for (int down = 0_ down <= secondLen_ ++down) {_            currentCol[down] = down__        }__        _        for (int across = 1_ across <= firstLen_ ++across) {_            int[] tmp = prevCol__            prevCol = currentCol__            _            currentCol = tmp___            currentCol[0] = across___            for (int down = 1_ down <= secondLen_ ++down) {__                _                if (first.charAt(across - 1) == second.charAt(down - 1)) {__                    _                    currentCol[down] = prevCol[down - 1]__                } else {_                    __                    _                    int option1 = prevCol[down]___                    _                    int option2 = currentCol[down - 1]___                    _                    int option3 = prevCol[down - 1]___                    _                    currentCol[down] = Math.min(Math.min(option1, option2), option3) + 1__                }_            }_        }__        _        return currentCol[secondLen]__    };this,method,implements,the,simple,algorithm,for,calculating,levenshtein,distance;static,int,levenshtein,distance,string,first,string,second,int,first,len,first,null,0,first,length,int,second,len,second,null,0,second,length,if,first,len,0,return,second,len,if,second,len,0,return,first,len,int,current,col,new,int,second,len,1,int,prev,col,new,int,second,len,1,for,int,down,0,down,second,len,down,current,col,down,down,for,int,across,1,across,first,len,across,int,tmp,prev,col,prev,col,current,col,current,col,tmp,current,col,0,across,for,int,down,1,down,second,len,down,if,first,char,at,across,1,second,char,at,down,1,current,col,down,prev,col,down,1,else,int,option1,prev,col,down,int,option2,current,col,down,1,int,option3,prev,col,down,1,current,col,down,math,min,math,min,option1,option2,option3,1,return,current,col,second,len
DelimitedFileStructureFinder -> static int levenshteinDistance(String first, String second);1548533997;This method implements the simple algorithm for calculating Levenshtein distance.;static int levenshteinDistance(String first, String second) {__        _        __        int firstLen = (first == null) ? 0 : first.length()__        int secondLen = (second == null) ? 0 : second.length()__        if (firstLen == 0) {_            return secondLen__        }_        if (secondLen == 0) {_            return firstLen__        }__        int[] currentCol = new int[secondLen + 1]__        int[] prevCol = new int[secondLen + 1]___        _        for (int down = 0_ down <= secondLen_ ++down) {_            currentCol[down] = down__        }__        _        for (int across = 1_ across <= firstLen_ ++across) {_            int[] tmp = prevCol__            prevCol = currentCol__            _            currentCol = tmp___            currentCol[0] = across___            for (int down = 1_ down <= secondLen_ ++down) {__                _                if (first.charAt(across - 1) == second.charAt(down - 1)) {__                    _                    currentCol[down] = prevCol[down - 1]__                } else {_                    __                    _                    int option1 = prevCol[down]___                    _                    int option2 = currentCol[down - 1]___                    _                    int option3 = prevCol[down - 1]___                    _                    currentCol[down] = Math.min(Math.min(option1, option2), option3) + 1__                }_            }_        }__        _        return currentCol[secondLen]__    };this,method,implements,the,simple,algorithm,for,calculating,levenshtein,distance;static,int,levenshtein,distance,string,first,string,second,int,first,len,first,null,0,first,length,int,second,len,second,null,0,second,length,if,first,len,0,return,second,len,if,second,len,0,return,first,len,int,current,col,new,int,second,len,1,int,prev,col,new,int,second,len,1,for,int,down,0,down,second,len,down,current,col,down,down,for,int,across,1,across,first,len,across,int,tmp,prev,col,prev,col,current,col,current,col,tmp,current,col,0,across,for,int,down,1,down,second,len,down,if,first,char,at,across,1,second,char,at,down,1,current,col,down,prev,col,down,1,else,int,option1,prev,col,down,int,option2,current,col,down,1,int,option3,prev,col,down,1,current,col,down,math,min,math,min,option1,option2,option3,1,return,current,col,second,len
