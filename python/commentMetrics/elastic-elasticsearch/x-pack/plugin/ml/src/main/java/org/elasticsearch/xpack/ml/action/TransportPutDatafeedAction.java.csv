commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected PutDatafeedAction.Response newResponse() {     return new PutDatafeedAction.Response(). }
false;protected;3;52;;@Override protected void masterOperation(PutDatafeedAction.Request request, ClusterState state, ActionListener<PutDatafeedAction.Response> listener) {     // permission to read the indices the datafeed is going to read from     if (licenseState.isAuthAllowed()) {         final String[] indices = request.getDatafeed().getIndices().toArray(new String[0]).         final String username = securityContext.getUser().principal().         final HasPrivilegesRequest privRequest = new HasPrivilegesRequest().         privRequest.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0]).         privRequest.username(username).         privRequest.clusterPrivileges(Strings.EMPTY_ARRAY).         final RoleDescriptor.IndicesPrivileges.Builder indicesPrivilegesBuilder = RoleDescriptor.IndicesPrivileges.builder().indices(indices).         ActionListener<HasPrivilegesResponse> privResponseListener = ActionListener.wrap(r -> handlePrivsResponse(username, request, r, listener), listener::onFailure).         ActionListener<GetRollupIndexCapsAction.Response> getRollupIndexCapsActionHandler = ActionListener.wrap(response -> {             if (response.getJobs().isEmpty()) {                 // This means no rollup indexes are in the config                 indicesPrivilegesBuilder.privileges(SearchAction.NAME).             } else {                 indicesPrivilegesBuilder.privileges(SearchAction.NAME, RollupSearchAction.NAME).             }             privRequest.indexPrivileges(indicesPrivilegesBuilder.build()).             client.execute(HasPrivilegesAction.INSTANCE, privRequest, privResponseListener).         }, e -> {             if (e instanceof IndexNotFoundException) {                 indicesPrivilegesBuilder.privileges(SearchAction.NAME).                 privRequest.indexPrivileges(indicesPrivilegesBuilder.build()).                 client.execute(HasPrivilegesAction.INSTANCE, privRequest, privResponseListener).             } else {                 listener.onFailure(e).             }         }).         executeAsyncWithOrigin(client, ML_ORIGIN, GetRollupIndexCapsAction.INSTANCE, new GetRollupIndexCapsAction.Request(indices), getRollupIndexCapsActionHandler).     } else {         putDatafeed(request, threadPool.getThreadContext().getHeaders(), listener).     } }
false;private;4;19;;private void handlePrivsResponse(String username, PutDatafeedAction.Request request, HasPrivilegesResponse response, ActionListener<PutDatafeedAction.Response> listener) throws IOException {     if (response.isCompleteMatch()) {         putDatafeed(request, threadPool.getThreadContext().getHeaders(), listener).     } else {         XContentBuilder builder = JsonXContent.contentBuilder().         builder.startObject().         for (ResourcePrivileges index : response.getIndexPrivileges()) {             builder.field(index.getResource()).             builder.map(index.getPrivileges()).         }         builder.endObject().         listener.onFailure(Exceptions.authorizationError("Cannot create datafeed [{}]" + " because user {} lacks permissions on the indices: {}", request.getDatafeed().getId(), username, Strings.toString(builder))).     } }
false;private;3;24;;private void putDatafeed(PutDatafeedAction.Request request, Map<String, String> headers, ActionListener<PutDatafeedAction.Response> listener) {     String datafeedId = request.getDatafeed().getId().     String jobId = request.getDatafeed().getJobId().     ElasticsearchException validationError = checkConfigsAreNotDefinedInClusterState(datafeedId, jobId).     if (validationError != null) {         listener.onFailure(validationError).         return.     }     DatafeedConfig.validateAggregations(request.getDatafeed().getParsedAggregations()).     CheckedConsumer<Boolean, Exception> validationOk = ok -> {         datafeedConfigProvider.putDatafeedConfig(request.getDatafeed(), headers, ActionListener.wrap(indexResponse -> listener.onResponse(new PutDatafeedAction.Response(request.getDatafeed())), listener::onFailure)).     }.     CheckedConsumer<Boolean, Exception> jobOk = ok -> jobConfigProvider.validateDatafeedJob(request.getDatafeed(), ActionListener.wrap(validationOk, listener::onFailure)).     checkJobDoesNotHaveADatafeed(jobId, ActionListener.wrap(jobOk, listener::onFailure)). }
true;private;2;16;/**  * Returns an exception if a datafeed with the same Id is defined in the  * cluster state or the job is in the cluster state and already has a datafeed  */ ;/**  * Returns an exception if a datafeed with the same Id is defined in the  * cluster state or the job is in the cluster state and already has a datafeed  */ @Nullable private ElasticsearchException checkConfigsAreNotDefinedInClusterState(String datafeedId, String jobId) {     ClusterState clusterState = clusterService.state().     MlMetadata mlMetadata = MlMetadata.getMlMetadata(clusterState).     if (mlMetadata.getDatafeed(datafeedId) != null) {         return ExceptionsHelper.datafeedAlreadyExists(datafeedId).     }     if (mlMetadata.getDatafeedByJobId(jobId).isPresent()) {         return ExceptionsHelper.conflictStatusException("Cannot create datafeed [" + datafeedId + "] as a " + "job [" + jobId + "] defined in the cluster state references a datafeed with the same Id").     }     return null. }
false;private;2;13;;private void checkJobDoesNotHaveADatafeed(String jobId, ActionListener<Boolean> listener) {     datafeedConfigProvider.findDatafeedsForJobIds(Collections.singletonList(jobId), ActionListener.wrap(datafeedIds -> {         if (datafeedIds.isEmpty()) {             listener.onResponse(Boolean.TRUE).         } else {             listener.onFailure(ExceptionsHelper.conflictStatusException("A datafeed [" + datafeedIds.iterator().next() + "] already exists for job [" + jobId + "]")).         }     }, listener::onFailure)). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(PutDatafeedAction.Request request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
false;protected;3;8;;@Override protected void doExecute(Task task, PutDatafeedAction.Request request, ActionListener<PutDatafeedAction.Response> listener) {     if (licenseState.isMachineLearningAllowed()) {         super.doExecute(task, request, listener).     } else {         listener.onFailure(LicenseUtils.newComplianceException(XPackField.MACHINE_LEARNING)).     } }
