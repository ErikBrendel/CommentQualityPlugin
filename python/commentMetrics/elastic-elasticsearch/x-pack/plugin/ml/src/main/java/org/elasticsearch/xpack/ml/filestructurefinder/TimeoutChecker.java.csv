commented;modifiers;parameterAmount;loc;comment;code
true;public;0;5;/**  * Stops the timer if running.  */ ;/**  * Stops the timer if running.  */ @Override public void close() {     FutureUtils.cancel(future).     timeoutCheckerWatchdog.remove(checkedThread). }
true;public;1;7;/**  * Check whether the operation has been running longer than the permitted time.  * @param where Which stage of the operation is currently in progress?  * @throws ElasticsearchTimeoutException If the operation is found to have taken longer than the permitted time.  */ ;/**  * Check whether the operation has been running longer than the permitted time.  * @param where Which stage of the operation is currently in progress?  * @throws ElasticsearchTimeoutException If the operation is found to have taken longer than the permitted time.  */ public void check(String where) {     if (timeoutExceeded) {         throw new ElasticsearchTimeoutException("Aborting " + operation + " during [" + where + "] as it has taken longer than the timeout of [" + timeout + "]").     } }
true;public;3;10;/**  * Wrapper around {@link Grok#captures} that translates any timeout exception  * to the style thrown by this class's {@link #check} method.  * @param grok The grok pattern from which captures are to be extracted.  * @param text The text to match and extract values from.  * @param where Which stage of the operation is currently in progress?  * @return A map containing field names and their respective coerced values that matched.  * @throws ElasticsearchTimeoutException If the operation is found to have taken longer than the permitted time.  */ ;/**  * Wrapper around {@link Grok#captures} that translates any timeout exception  * to the style thrown by this class's {@link #check} method.  * @param grok The grok pattern from which captures are to be extracted.  * @param text The text to match and extract values from.  * @param where Which stage of the operation is currently in progress?  * @return A map containing field names and their respective coerced values that matched.  * @throws ElasticsearchTimeoutException If the operation is found to have taken longer than the permitted time.  */ public Map<String, Object> grokCaptures(Grok grok, String text, String where) {     try {         return grok.captures(text).     } finally {         // If a timeout has occurred then this check will overwrite any timeout exception thrown by Grok.captures() and this         // is intentional - the exception from this class makes more sense in the context of the find file structure API         check(where).     } }
false;private;0;4;;private void setTimeoutExceeded() {     timeoutExceeded = true.     timeoutCheckerWatchdog.interruptLongRunningThreadIfRegistered(checkedThread). }
false;;2;4;;void add(Thread thread, TimeValue timeout) {     Tuple<AtomicBoolean, TimeValue> previousValue = registry.put(thread, new Tuple<>(new AtomicBoolean(false), timeout)).     assert previousValue == null. }
false;public;0;8;;@Override public void register() {     Tuple<AtomicBoolean, TimeValue> value = registry.get(Thread.currentThread()).     if (value != null) {         boolean wasFalse = value.v1().compareAndSet(false, true).         assert wasFalse.     } }
false;public;0;5;;@Override public long maxExecutionTimeInMillis() {     Tuple<AtomicBoolean, TimeValue> value = registry.get(Thread.currentThread()).     return value != null ? value.v2().getMillis() : Long.MAX_VALUE. }
false;public;0;8;;@Override public void unregister() {     Tuple<AtomicBoolean, TimeValue> value = registry.get(Thread.currentThread()).     if (value != null) {         boolean wasTrue = value.v1().compareAndSet(true, false).         assert wasTrue.     } }
false;;1;4;;void remove(Thread thread) {     Tuple<AtomicBoolean, TimeValue> previousValue = registry.remove(thread).     assert previousValue != null. }
false;;1;6;;void interruptLongRunningThreadIfRegistered(Thread thread) {     Tuple<AtomicBoolean, TimeValue> value = registry.get(thread).     if (value.v1().get()) {         thread.interrupt().     } }
