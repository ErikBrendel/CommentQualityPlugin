commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;50;/**  * Given a category definition regex and a collection of examples from the category, return  * a grok pattern that will match the category and pull out any likely fields.  The extracted  * fields are given pretty generic names, but unique within the grok pattern provided.  The  * expectation is that a user will adjust the extracted field names based on their domain  * knowledge.  */ ;/**  * Given a category definition regex and a collection of examples from the category, return  * a grok pattern that will match the category and pull out any likely fields.  The extracted  * fields are given pretty generic names, but unique within the grok pattern provided.  The  * expectation is that a user will adjust the extracted field names based on their domain  * knowledge.  */ public static String findBestGrokMatchFromExamples(String jobId, String regex, Collection<String> examples) {     // The first string in this array will end up being the empty string, and it doesn't correspond     // to an "in between" bit.  Although it could be removed for "neatness", it actually makes the     // loops below slightly neater if it's left in.     //      // E.g., ".*?cat.+?sat.+?mat.*" -> [ "", "cat", "sat", "mat" ]     String[] fixedRegexBits = regex.split("\\.[*+]\\??").     // Create a pattern that will capture the bits in between the fixed parts of the regex     //      // E.g., ".*?cat.+?sat.+?mat.*" -> Pattern (.*?)cat(.+?)sat(.+?)mat(.*)     Pattern exampleProcessor = Pattern.compile(regex.replaceAll("(\\.[*+]\\??)", "($1)"), Pattern.DOTALL).     List<Collection<String>> groupsMatchesFromExamples = new ArrayList<>(fixedRegexBits.length).     for (int i = 0. i < fixedRegexBits.length. ++i) {         groupsMatchesFromExamples.add(new ArrayList<>(examples.size())).     }     for (String example : examples) {         Matcher matcher = exampleProcessor.matcher(example).         if (matcher.matches()) {             assert matcher.groupCount() == fixedRegexBits.length.             // being added to the 4 "in between" collections in that order             for (int groupNum = 1. groupNum <= matcher.groupCount(). ++groupNum) {                 groupsMatchesFromExamples.get(groupNum - 1).add(matcher.group(groupNum)).             }         } else {             // as it's produced a regex that doesn't match the examples.             assert matcher.matches() : exampleProcessor.pattern() + " did not match " + example.             LogManager.getLogger(GrokPatternCreator.class).error("[{}] Pattern [{}] did not match example [{}]", jobId, exampleProcessor.pattern(), example).         }     }     Map<String, Integer> fieldNameCountStore = new HashMap<>().     StringBuilder overallGrokPatternBuilder = new StringBuilder().     // it into the overall Grok pattern that will match the each example in its entirety     for (int inBetweenBitNum = 0. inBetweenBitNum < groupsMatchesFromExamples.size(). ++inBetweenBitNum) {         // Remember (from the first comment in this method) that the first element in this array is         // always the empty string         overallGrokPatternBuilder.append(fixedRegexBits[inBetweenBitNum]).         appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, inBetweenBitNum == 0, inBetweenBitNum == fixedRegexBits.length - 1, groupsMatchesFromExamples.get(inBetweenBitNum)).     }     return overallGrokPatternBuilder.toString(). }
true;static;5;31;/**  * Given a collection of strings, work out which (if any) of the grok patterns we're allowed  * to use matches it best.  Then append the appropriate grok language to represent that finding  * onto the supplied string builder.  */ ;/**  * Given a collection of strings, work out which (if any) of the grok patterns we're allowed  * to use matches it best.  Then append the appropriate grok language to represent that finding  * onto the supplied string builder.  */ static void appendBestGrokMatchForStrings(Map<String, Integer> fieldNameCountStore, StringBuilder overallGrokPatternBuilder, boolean isFirst, boolean isLast, Collection<String> mustMatchStrings) {     GrokPatternCandidate bestCandidate = null.     if (mustMatchStrings.isEmpty() == false) {         for (GrokPatternCandidate candidate : ORDERED_CANDIDATE_GROK_PATTERNS) {             if (mustMatchStrings.stream().allMatch(candidate.grok::match)) {                 bestCandidate = candidate.                 break.             }         }     }     if (bestCandidate == null) {         if (isLast) {             overallGrokPatternBuilder.append(".*").         } else if (isFirst || mustMatchStrings.stream().anyMatch(String::isEmpty)) {             overallGrokPatternBuilder.append(".*?").         } else {             overallGrokPatternBuilder.append(".+?").         }     } else {         Collection<String> prefaces = new ArrayList<>().         Collection<String> epilogues = new ArrayList<>().         populatePrefacesAndEpilogues(mustMatchStrings, bestCandidate.grok, prefaces, epilogues).         appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, isFirst, false, prefaces).         overallGrokPatternBuilder.append("%{").append(bestCandidate.grokPatternName).append(':').append(buildFieldName(fieldNameCountStore, bestCandidate.fieldName)).append('}').         appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, false, isLast, epilogues).     } }
true;static;4;11;/**  * Given a collection of strings, and a grok pattern that matches some part of them all,  * return collections of the bits that come before (prefaces) and after (epilogues) the  * bit that matches.  */ ;/**  * Given a collection of strings, and a grok pattern that matches some part of them all,  * return collections of the bits that come before (prefaces) and after (epilogues) the  * bit that matches.  */ static void populatePrefacesAndEpilogues(Collection<String> matchingStrings, Grok grok, Collection<String> prefaces, Collection<String> epilogues) {     for (String s : matchingStrings) {         Map<String, Object> captures = grok.captures(s).         // method to only be called after validating that the pattern does match.         assert captures != null.         prefaces.add(captures.getOrDefault(PREFACE, "").toString()).         epilogues.add(captures.getOrDefault(EPILOGUE, "").toString()).     } }
true;static;2;8;/**  * The first time a particular field name is passed, simply return it.  * The second time return it with "2" appended.  * The third time return it with "3" appended.  * Etc.  */ ;/**  * The first time a particular field name is passed, simply return it.  * The second time return it with "2" appended.  * The third time return it with "3" appended.  * Etc.  */ static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {     Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v)).     if (numberSeen > 1) {         return fieldName + numberSeen.     } else {         return fieldName.     } }
