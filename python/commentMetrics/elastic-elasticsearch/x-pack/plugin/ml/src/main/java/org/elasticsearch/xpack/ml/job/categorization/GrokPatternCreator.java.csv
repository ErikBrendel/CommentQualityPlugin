# id;timestamp;commentText;codeText;commentWords;codeWords
GrokPatternCreator -> static void appendBestGrokMatchForStrings(Map<String, Integer> fieldNameCountStore, StringBuilder overallGrokPatternBuilder,                                               boolean isFirst, boolean isLast, Collection<String> mustMatchStrings);1526374795;Given a collection of strings, work out which (if any) of the grok patterns we're allowed_to use matches it best.  Then append the appropriate grok language to represent that finding_onto the supplied string builder.;static void appendBestGrokMatchForStrings(Map<String, Integer> fieldNameCountStore, StringBuilder overallGrokPatternBuilder,_                                              boolean isFirst, boolean isLast, Collection<String> mustMatchStrings) {__        GrokPatternCandidate bestCandidate = null__        if (mustMatchStrings.isEmpty() == false) {_            for (GrokPatternCandidate candidate : ORDERED_CANDIDATE_GROK_PATTERNS) {_                if (mustMatchStrings.stream().allMatch(candidate.grok::match)) {_                    bestCandidate = candidate__                    break__                }_            }_        }__        if (bestCandidate == null) {_            if (isLast) {_                overallGrokPatternBuilder.append(".*")__            } else if (isFirst || mustMatchStrings.stream().anyMatch(String::isEmpty)) {_                overallGrokPatternBuilder.append(".*?")__            } else {_                overallGrokPatternBuilder.append(".+?")__            }_        } else {_            Collection<String> prefaces = new ArrayList<>()__            Collection<String> epilogues = new ArrayList<>()__            populatePrefacesAndEpilogues(mustMatchStrings, bestCandidate.grok, prefaces, epilogues)__            appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, isFirst, false, prefaces)__            overallGrokPatternBuilder.append("%{").append(bestCandidate.grokPatternName).append(':')_                    .append(buildFieldName(fieldNameCountStore, bestCandidate.fieldName)).append('}')__            appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, false, isLast, epilogues)__        }_    };given,a,collection,of,strings,work,out,which,if,any,of,the,grok,patterns,we,re,allowed,to,use,matches,it,best,then,append,the,appropriate,grok,language,to,represent,that,finding,onto,the,supplied,string,builder;static,void,append,best,grok,match,for,strings,map,string,integer,field,name,count,store,string,builder,overall,grok,pattern,builder,boolean,is,first,boolean,is,last,collection,string,must,match,strings,grok,pattern,candidate,best,candidate,null,if,must,match,strings,is,empty,false,for,grok,pattern,candidate,candidate,if,must,match,strings,stream,all,match,candidate,grok,match,best,candidate,candidate,break,if,best,candidate,null,if,is,last,overall,grok,pattern,builder,append,else,if,is,first,must,match,strings,stream,any,match,string,is,empty,overall,grok,pattern,builder,append,else,overall,grok,pattern,builder,append,else,collection,string,prefaces,new,array,list,collection,string,epilogues,new,array,list,populate,prefaces,and,epilogues,must,match,strings,best,candidate,grok,prefaces,epilogues,append,best,grok,match,for,strings,field,name,count,store,overall,grok,pattern,builder,is,first,false,prefaces,overall,grok,pattern,builder,append,append,best,candidate,grok,pattern,name,append,append,build,field,name,field,name,count,store,best,candidate,field,name,append,append,best,grok,match,for,strings,field,name,count,store,overall,grok,pattern,builder,false,is,last,epilogues
GrokPatternCreator -> static void appendBestGrokMatchForStrings(Map<String, Integer> fieldNameCountStore, StringBuilder overallGrokPatternBuilder,                                               boolean isFirst, boolean isLast, Collection<String> mustMatchStrings);1536137328;Given a collection of strings, work out which (if any) of the grok patterns we're allowed_to use matches it best.  Then append the appropriate grok language to represent that finding_onto the supplied string builder.;static void appendBestGrokMatchForStrings(Map<String, Integer> fieldNameCountStore, StringBuilder overallGrokPatternBuilder,_                                              boolean isFirst, boolean isLast, Collection<String> mustMatchStrings) {__        GrokPatternCandidate bestCandidate = null__        if (mustMatchStrings.isEmpty() == false) {_            for (GrokPatternCandidate candidate : ORDERED_CANDIDATE_GROK_PATTERNS) {_                if (mustMatchStrings.stream().allMatch(candidate.grok::match)) {_                    bestCandidate = candidate__                    break__                }_            }_        }__        if (bestCandidate == null) {_            if (isLast) {_                overallGrokPatternBuilder.append(".*")__            } else if (isFirst || mustMatchStrings.stream().anyMatch(String::isEmpty)) {_                overallGrokPatternBuilder.append(".*?")__            } else {_                overallGrokPatternBuilder.append(".+?")__            }_        } else {_            Collection<String> prefaces = new ArrayList<>()__            Collection<String> epilogues = new ArrayList<>()__            populatePrefacesAndEpilogues(mustMatchStrings, bestCandidate.grok, prefaces, epilogues)__            appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, isFirst, false, prefaces)__            overallGrokPatternBuilder.append("%{").append(bestCandidate.grokPatternName).append(':')_                    .append(buildFieldName(fieldNameCountStore, bestCandidate.fieldName)).append('}')__            appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, false, isLast, epilogues)__        }_    };given,a,collection,of,strings,work,out,which,if,any,of,the,grok,patterns,we,re,allowed,to,use,matches,it,best,then,append,the,appropriate,grok,language,to,represent,that,finding,onto,the,supplied,string,builder;static,void,append,best,grok,match,for,strings,map,string,integer,field,name,count,store,string,builder,overall,grok,pattern,builder,boolean,is,first,boolean,is,last,collection,string,must,match,strings,grok,pattern,candidate,best,candidate,null,if,must,match,strings,is,empty,false,for,grok,pattern,candidate,candidate,if,must,match,strings,stream,all,match,candidate,grok,match,best,candidate,candidate,break,if,best,candidate,null,if,is,last,overall,grok,pattern,builder,append,else,if,is,first,must,match,strings,stream,any,match,string,is,empty,overall,grok,pattern,builder,append,else,overall,grok,pattern,builder,append,else,collection,string,prefaces,new,array,list,collection,string,epilogues,new,array,list,populate,prefaces,and,epilogues,must,match,strings,best,candidate,grok,prefaces,epilogues,append,best,grok,match,for,strings,field,name,count,store,overall,grok,pattern,builder,is,first,false,prefaces,overall,grok,pattern,builder,append,append,best,candidate,grok,pattern,name,append,append,build,field,name,field,name,count,store,best,candidate,field,name,append,append,best,grok,match,for,strings,field,name,count,store,overall,grok,pattern,builder,false,is,last,epilogues
GrokPatternCreator -> static void appendBestGrokMatchForStrings(Map<String, Integer> fieldNameCountStore, StringBuilder overallGrokPatternBuilder,                                               boolean isFirst, boolean isLast, Collection<String> mustMatchStrings);1540847035;Given a collection of strings, work out which (if any) of the grok patterns we're allowed_to use matches it best.  Then append the appropriate grok language to represent that finding_onto the supplied string builder.;static void appendBestGrokMatchForStrings(Map<String, Integer> fieldNameCountStore, StringBuilder overallGrokPatternBuilder,_                                              boolean isFirst, boolean isLast, Collection<String> mustMatchStrings) {__        GrokPatternCandidate bestCandidate = null__        if (mustMatchStrings.isEmpty() == false) {_            for (GrokPatternCandidate candidate : ORDERED_CANDIDATE_GROK_PATTERNS) {_                if (mustMatchStrings.stream().allMatch(candidate.grok::match)) {_                    bestCandidate = candidate__                    break__                }_            }_        }__        if (bestCandidate == null) {_            if (isLast) {_                overallGrokPatternBuilder.append(".*")__            } else if (isFirst || mustMatchStrings.stream().anyMatch(String::isEmpty)) {_                overallGrokPatternBuilder.append(".*?")__            } else {_                overallGrokPatternBuilder.append(".+?")__            }_        } else {_            Collection<String> prefaces = new ArrayList<>()__            Collection<String> epilogues = new ArrayList<>()__            populatePrefacesAndEpilogues(mustMatchStrings, bestCandidate.grok, prefaces, epilogues)__            appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, isFirst, false, prefaces)__            overallGrokPatternBuilder.append("%{").append(bestCandidate.grokPatternName).append(':')_                    .append(buildFieldName(fieldNameCountStore, bestCandidate.fieldName)).append('}')__            appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, false, isLast, epilogues)__        }_    };given,a,collection,of,strings,work,out,which,if,any,of,the,grok,patterns,we,re,allowed,to,use,matches,it,best,then,append,the,appropriate,grok,language,to,represent,that,finding,onto,the,supplied,string,builder;static,void,append,best,grok,match,for,strings,map,string,integer,field,name,count,store,string,builder,overall,grok,pattern,builder,boolean,is,first,boolean,is,last,collection,string,must,match,strings,grok,pattern,candidate,best,candidate,null,if,must,match,strings,is,empty,false,for,grok,pattern,candidate,candidate,if,must,match,strings,stream,all,match,candidate,grok,match,best,candidate,candidate,break,if,best,candidate,null,if,is,last,overall,grok,pattern,builder,append,else,if,is,first,must,match,strings,stream,any,match,string,is,empty,overall,grok,pattern,builder,append,else,overall,grok,pattern,builder,append,else,collection,string,prefaces,new,array,list,collection,string,epilogues,new,array,list,populate,prefaces,and,epilogues,must,match,strings,best,candidate,grok,prefaces,epilogues,append,best,grok,match,for,strings,field,name,count,store,overall,grok,pattern,builder,is,first,false,prefaces,overall,grok,pattern,builder,append,append,best,candidate,grok,pattern,name,append,append,build,field,name,field,name,count,store,best,candidate,field,name,append,append,best,grok,match,for,strings,field,name,count,store,overall,grok,pattern,builder,false,is,last,epilogues
GrokPatternCreator -> GrokPatternCandidate -> GrokPatternCandidate(String grokPatternName, String fieldName);1526374795;Pre/post breaks default to \b, but this may not be appropriate for Grok patterns that start or_end with a non "word" character (i.e. letter, number or underscore).  For such patterns use one_of the other constructors.__In cases where the Grok pattern defined by Logstash already includes conditions on what must_come before and after the match, use one of the other constructors and specify an empty string_for the pre and/or post breaks._@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match.;GrokPatternCandidate(String grokPatternName, String fieldName) {_            this(grokPatternName, fieldName, "\\b", "\\b")__        };pre,post,breaks,default,to,b,but,this,may,not,be,appropriate,for,grok,patterns,that,start,or,end,with,a,non,word,character,i,e,letter,number,or,underscore,for,such,patterns,use,one,of,the,other,constructors,in,cases,where,the,grok,pattern,defined,by,logstash,already,includes,conditions,on,what,must,come,before,and,after,the,match,use,one,of,the,other,constructors,and,specify,an,empty,string,for,the,pre,and,or,post,breaks,param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match;grok,pattern,candidate,string,grok,pattern,name,string,field,name,this,grok,pattern,name,field,name,b,b
GrokPatternCreator -> GrokPatternCandidate -> GrokPatternCandidate(String grokPatternName, String fieldName);1536137328;Pre/post breaks default to \b, but this may not be appropriate for Grok patterns that start or_end with a non "word" character (i.e. letter, number or underscore).  For such patterns use one_of the other constructors.__In cases where the Grok pattern defined by Logstash already includes conditions on what must_come before and after the match, use one of the other constructors and specify an empty string_for the pre and/or post breaks._@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match.;GrokPatternCandidate(String grokPatternName, String fieldName) {_            this(grokPatternName, fieldName, "\\b", "\\b")__        };pre,post,breaks,default,to,b,but,this,may,not,be,appropriate,for,grok,patterns,that,start,or,end,with,a,non,word,character,i,e,letter,number,or,underscore,for,such,patterns,use,one,of,the,other,constructors,in,cases,where,the,grok,pattern,defined,by,logstash,already,includes,conditions,on,what,must,come,before,and,after,the,match,use,one,of,the,other,constructors,and,specify,an,empty,string,for,the,pre,and,or,post,breaks,param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match;grok,pattern,candidate,string,grok,pattern,name,string,field,name,this,grok,pattern,name,field,name,b,b
GrokPatternCreator -> GrokPatternCandidate -> GrokPatternCandidate(String grokPatternName, String fieldName);1540847035;Pre/post breaks default to \b, but this may not be appropriate for Grok patterns that start or_end with a non "word" character (i.e. letter, number or underscore).  For such patterns use one_of the other constructors.__In cases where the Grok pattern defined by Logstash already includes conditions on what must_come before and after the match, use one of the other constructors and specify an empty string_for the pre and/or post breaks._@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match.;GrokPatternCandidate(String grokPatternName, String fieldName) {_            this(grokPatternName, fieldName, "\\b", "\\b")__        };pre,post,breaks,default,to,b,but,this,may,not,be,appropriate,for,grok,patterns,that,start,or,end,with,a,non,word,character,i,e,letter,number,or,underscore,for,such,patterns,use,one,of,the,other,constructors,in,cases,where,the,grok,pattern,defined,by,logstash,already,includes,conditions,on,what,must,come,before,and,after,the,match,use,one,of,the,other,constructors,and,specify,an,empty,string,for,the,pre,and,or,post,breaks,param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match;grok,pattern,candidate,string,grok,pattern,name,string,field,name,this,grok,pattern,name,field,name,b,b
GrokPatternCreator -> GrokPatternCandidate -> GrokPatternCandidate(String grokPatternName, String fieldName, String preBreak, String postBreak);1526374795;@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match._@param preBreak        Only consider the match if it's broken from the previous text by this._@param postBreak       Only consider the match if it's broken from the following text by this.;GrokPatternCandidate(String grokPatternName, String fieldName, String preBreak, String postBreak) {_            this.grokPatternName = grokPatternName__            this.fieldName = fieldName__            this.grok = new Grok(Grok.getBuiltinPatterns(), "%{DATA:" + PREFACE + "}" + preBreak + "%{" + grokPatternName + ":this}" +_                    postBreak + "%{GREEDYDATA:" + EPILOGUE + "}")__        };param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match,param,pre,break,only,consider,the,match,if,it,s,broken,from,the,previous,text,by,this,param,post,break,only,consider,the,match,if,it,s,broken,from,the,following,text,by,this;grok,pattern,candidate,string,grok,pattern,name,string,field,name,string,pre,break,string,post,break,this,grok,pattern,name,grok,pattern,name,this,field,name,field,name,this,grok,new,grok,grok,get,builtin,patterns,data,preface,pre,break,grok,pattern,name,this,post,break,greedydata,epilogue
GrokPatternCreator -> GrokPatternCandidate -> GrokPatternCandidate(String grokPatternName, String fieldName, String preBreak, String postBreak);1536137328;@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match._@param preBreak        Only consider the match if it's broken from the previous text by this._@param postBreak       Only consider the match if it's broken from the following text by this.;GrokPatternCandidate(String grokPatternName, String fieldName, String preBreak, String postBreak) {_            this.grokPatternName = grokPatternName__            this.fieldName = fieldName__            this.grok = new Grok(Grok.getBuiltinPatterns(), "%{DATA:" + PREFACE + "}" + preBreak + "%{" + grokPatternName + ":this}" +_                    postBreak + "%{GREEDYDATA:" + EPILOGUE + "}")__        };param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match,param,pre,break,only,consider,the,match,if,it,s,broken,from,the,previous,text,by,this,param,post,break,only,consider,the,match,if,it,s,broken,from,the,following,text,by,this;grok,pattern,candidate,string,grok,pattern,name,string,field,name,string,pre,break,string,post,break,this,grok,pattern,name,grok,pattern,name,this,field,name,field,name,this,grok,new,grok,grok,get,builtin,patterns,data,preface,pre,break,grok,pattern,name,this,post,break,greedydata,epilogue
GrokPatternCreator -> GrokPatternCandidate -> GrokPatternCandidate(String grokPatternName, String fieldName, String preBreak, String postBreak);1540847035;@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match._@param preBreak        Only consider the match if it's broken from the previous text by this._@param postBreak       Only consider the match if it's broken from the following text by this.;GrokPatternCandidate(String grokPatternName, String fieldName, String preBreak, String postBreak) {_            this.grokPatternName = grokPatternName__            this.fieldName = fieldName__            this.grok = new Grok(Grok.getBuiltinPatterns(), "%{DATA:" + PREFACE + "}" + preBreak + "%{" + grokPatternName + ":this}" +_                    postBreak + "%{GREEDYDATA:" + EPILOGUE + "}")__        };param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match,param,pre,break,only,consider,the,match,if,it,s,broken,from,the,previous,text,by,this,param,post,break,only,consider,the,match,if,it,s,broken,from,the,following,text,by,this;grok,pattern,candidate,string,grok,pattern,name,string,field,name,string,pre,break,string,post,break,this,grok,pattern,name,grok,pattern,name,this,field,name,field,name,this,grok,new,grok,grok,get,builtin,patterns,data,preface,pre,break,grok,pattern,name,this,post,break,greedydata,epilogue
GrokPatternCreator -> static void populatePrefacesAndEpilogues(Collection<String> matchingStrings, Grok grok, Collection<String> prefaces,                                              Collection<String> epilogues);1526374795;Given a collection of strings, and a grok pattern that matches some part of them all,_return collections of the bits that come before (prefaces) and after (epilogues) the_bit that matches.;static void populatePrefacesAndEpilogues(Collection<String> matchingStrings, Grok grok, Collection<String> prefaces,_                                             Collection<String> epilogues) {_        for (String s : matchingStrings) {_            Map<String, Object> captures = grok.captures(s)__            _            _            assert captures != null__            prefaces.add(captures.getOrDefault(PREFACE, "").toString())__            epilogues.add(captures.getOrDefault(EPILOGUE, "").toString())__        }_    };given,a,collection,of,strings,and,a,grok,pattern,that,matches,some,part,of,them,all,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches;static,void,populate,prefaces,and,epilogues,collection,string,matching,strings,grok,grok,collection,string,prefaces,collection,string,epilogues,for,string,s,matching,strings,map,string,object,captures,grok,captures,s,assert,captures,null,prefaces,add,captures,get,or,default,preface,to,string,epilogues,add,captures,get,or,default,epilogue,to,string
GrokPatternCreator -> static void populatePrefacesAndEpilogues(Collection<String> matchingStrings, Grok grok, Collection<String> prefaces,                                              Collection<String> epilogues);1536137328;Given a collection of strings, and a grok pattern that matches some part of them all,_return collections of the bits that come before (prefaces) and after (epilogues) the_bit that matches.;static void populatePrefacesAndEpilogues(Collection<String> matchingStrings, Grok grok, Collection<String> prefaces,_                                             Collection<String> epilogues) {_        for (String s : matchingStrings) {_            Map<String, Object> captures = grok.captures(s)__            _            _            assert captures != null__            prefaces.add(captures.getOrDefault(PREFACE, "").toString())__            epilogues.add(captures.getOrDefault(EPILOGUE, "").toString())__        }_    };given,a,collection,of,strings,and,a,grok,pattern,that,matches,some,part,of,them,all,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches;static,void,populate,prefaces,and,epilogues,collection,string,matching,strings,grok,grok,collection,string,prefaces,collection,string,epilogues,for,string,s,matching,strings,map,string,object,captures,grok,captures,s,assert,captures,null,prefaces,add,captures,get,or,default,preface,to,string,epilogues,add,captures,get,or,default,epilogue,to,string
GrokPatternCreator -> static void populatePrefacesAndEpilogues(Collection<String> matchingStrings, Grok grok, Collection<String> prefaces,                                              Collection<String> epilogues);1540847035;Given a collection of strings, and a grok pattern that matches some part of them all,_return collections of the bits that come before (prefaces) and after (epilogues) the_bit that matches.;static void populatePrefacesAndEpilogues(Collection<String> matchingStrings, Grok grok, Collection<String> prefaces,_                                             Collection<String> epilogues) {_        for (String s : matchingStrings) {_            Map<String, Object> captures = grok.captures(s)__            _            _            assert captures != null__            prefaces.add(captures.getOrDefault(PREFACE, "").toString())__            epilogues.add(captures.getOrDefault(EPILOGUE, "").toString())__        }_    };given,a,collection,of,strings,and,a,grok,pattern,that,matches,some,part,of,them,all,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches;static,void,populate,prefaces,and,epilogues,collection,string,matching,strings,grok,grok,collection,string,prefaces,collection,string,epilogues,for,string,s,matching,strings,map,string,object,captures,grok,captures,s,assert,captures,null,prefaces,add,captures,get,or,default,preface,to,string,epilogues,add,captures,get,or,default,epilogue,to,string
GrokPatternCreator -> static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName);1526374795;The first time a particular field name is passed, simply return it._The second time return it with "2" appended._The third time return it with "3" appended._Etc.;static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {_        Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v))__        if (numberSeen > 1) {_            return fieldName + numberSeen__        } else {_            return fieldName__        }_    };the,first,time,a,particular,field,name,is,passed,simply,return,it,the,second,time,return,it,with,2,appended,the,third,time,return,it,with,3,appended,etc;static,string,build,field,name,map,string,integer,field,name,count,store,string,field,name,integer,number,seen,field,name,count,store,compute,field,name,k,v,1,v,null,0,v,if,number,seen,1,return,field,name,number,seen,else,return,field,name
GrokPatternCreator -> static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName);1536137328;The first time a particular field name is passed, simply return it._The second time return it with "2" appended._The third time return it with "3" appended._Etc.;static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {_        Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v))__        if (numberSeen > 1) {_            return fieldName + numberSeen__        } else {_            return fieldName__        }_    };the,first,time,a,particular,field,name,is,passed,simply,return,it,the,second,time,return,it,with,2,appended,the,third,time,return,it,with,3,appended,etc;static,string,build,field,name,map,string,integer,field,name,count,store,string,field,name,integer,number,seen,field,name,count,store,compute,field,name,k,v,1,v,null,0,v,if,number,seen,1,return,field,name,number,seen,else,return,field,name
GrokPatternCreator -> static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName);1540847035;The first time a particular field name is passed, simply return it._The second time return it with "2" appended._The third time return it with "3" appended._Etc.;static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {_        Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v))__        if (numberSeen > 1) {_            return fieldName + numberSeen__        } else {_            return fieldName__        }_    };the,first,time,a,particular,field,name,is,passed,simply,return,it,the,second,time,return,it,with,2,appended,the,third,time,return,it,with,3,appended,etc;static,string,build,field,name,map,string,integer,field,name,count,store,string,field,name,integer,number,seen,field,name,count,store,compute,field,name,k,v,1,v,null,0,v,if,number,seen,1,return,field,name,number,seen,else,return,field,name
GrokPatternCreator -> public static String findBestGrokMatchFromExamples(String jobId, String regex, Collection<String> examples);1526374795;Given a category definition regex and a collection of examples from the category, return_a grok pattern that will match the category and pull out any likely fields.  The extracted_fields are given pretty generic names, but unique within the grok pattern provided.  The_expectation is that a user will adjust the extracted field names based on their domain_knowledge.;public static String findBestGrokMatchFromExamples(String jobId, String regex, Collection<String> examples) {__        _        _        _        _        _        String[] fixedRegexBits = regex.split("\\.[*+]\\??")___        _        _        _        Pattern exampleProcessor = Pattern.compile(regex.replaceAll("(\\.[*+]\\??)", "($1)"), Pattern.DOTALL)___        List<Collection<String>> groupsMatchesFromExamples = new ArrayList<>(fixedRegexBits.length)__        for (int i = 0_ i < fixedRegexBits.length_ ++i) {_            groupsMatchesFromExamples.add(new ArrayList<>(examples.size()))__        }_        for (String example : examples) {_            Matcher matcher = exampleProcessor.matcher(example)__            if (matcher.matches()) {_                assert matcher.groupCount() == fixedRegexBits.length__                _                _                _                for (int groupNum = 1_ groupNum <= matcher.groupCount()_ ++groupNum) {_                    groupsMatchesFromExamples.get(groupNum - 1).add(matcher.group(groupNum))__                }_            } else {_                _                _                assert matcher.matches() : exampleProcessor.pattern() + " did not match " + example__                Loggers.getLogger(GrokPatternCreator.class).error("[{}] Pattern [{}] did not match example [{}]", jobId,_                        exampleProcessor.pattern(), example)__            }_        }__        Map<String, Integer> fieldNameCountStore = new HashMap<>()__        StringBuilder overallGrokPatternBuilder = new StringBuilder()__        _        _        for (int inBetweenBitNum = 0_ inBetweenBitNum < groupsMatchesFromExamples.size()_ ++inBetweenBitNum) {_            _            _            overallGrokPatternBuilder.append(fixedRegexBits[inBetweenBitNum])__            appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, inBetweenBitNum == 0,_                    inBetweenBitNum == fixedRegexBits.length - 1, groupsMatchesFromExamples.get(inBetweenBitNum))__        }_        return overallGrokPatternBuilder.toString()__    };given,a,category,definition,regex,and,a,collection,of,examples,from,the,category,return,a,grok,pattern,that,will,match,the,category,and,pull,out,any,likely,fields,the,extracted,fields,are,given,pretty,generic,names,but,unique,within,the,grok,pattern,provided,the,expectation,is,that,a,user,will,adjust,the,extracted,field,names,based,on,their,domain,knowledge;public,static,string,find,best,grok,match,from,examples,string,job,id,string,regex,collection,string,examples,string,fixed,regex,bits,regex,split,pattern,example,processor,pattern,compile,regex,replace,all,1,pattern,dotall,list,collection,string,groups,matches,from,examples,new,array,list,fixed,regex,bits,length,for,int,i,0,i,fixed,regex,bits,length,i,groups,matches,from,examples,add,new,array,list,examples,size,for,string,example,examples,matcher,matcher,example,processor,matcher,example,if,matcher,matches,assert,matcher,group,count,fixed,regex,bits,length,for,int,group,num,1,group,num,matcher,group,count,group,num,groups,matches,from,examples,get,group,num,1,add,matcher,group,group,num,else,assert,matcher,matches,example,processor,pattern,did,not,match,example,loggers,get,logger,grok,pattern,creator,class,error,pattern,did,not,match,example,job,id,example,processor,pattern,example,map,string,integer,field,name,count,store,new,hash,map,string,builder,overall,grok,pattern,builder,new,string,builder,for,int,in,between,bit,num,0,in,between,bit,num,groups,matches,from,examples,size,in,between,bit,num,overall,grok,pattern,builder,append,fixed,regex,bits,in,between,bit,num,append,best,grok,match,for,strings,field,name,count,store,overall,grok,pattern,builder,in,between,bit,num,0,in,between,bit,num,fixed,regex,bits,length,1,groups,matches,from,examples,get,in,between,bit,num,return,overall,grok,pattern,builder,to,string
GrokPatternCreator -> public static String findBestGrokMatchFromExamples(String jobId, String regex, Collection<String> examples);1536137328;Given a category definition regex and a collection of examples from the category, return_a grok pattern that will match the category and pull out any likely fields.  The extracted_fields are given pretty generic names, but unique within the grok pattern provided.  The_expectation is that a user will adjust the extracted field names based on their domain_knowledge.;public static String findBestGrokMatchFromExamples(String jobId, String regex, Collection<String> examples) {__        _        _        _        _        _        String[] fixedRegexBits = regex.split("\\.[*+]\\??")___        _        _        _        Pattern exampleProcessor = Pattern.compile(regex.replaceAll("(\\.[*+]\\??)", "($1)"), Pattern.DOTALL)___        List<Collection<String>> groupsMatchesFromExamples = new ArrayList<>(fixedRegexBits.length)__        for (int i = 0_ i < fixedRegexBits.length_ ++i) {_            groupsMatchesFromExamples.add(new ArrayList<>(examples.size()))__        }_        for (String example : examples) {_            Matcher matcher = exampleProcessor.matcher(example)__            if (matcher.matches()) {_                assert matcher.groupCount() == fixedRegexBits.length__                _                _                _                for (int groupNum = 1_ groupNum <= matcher.groupCount()_ ++groupNum) {_                    groupsMatchesFromExamples.get(groupNum - 1).add(matcher.group(groupNum))__                }_            } else {_                _                _                assert matcher.matches() : exampleProcessor.pattern() + " did not match " + example__                Loggers.getLogger(GrokPatternCreator.class).error("[{}] Pattern [{}] did not match example [{}]", jobId,_                        exampleProcessor.pattern(), example)__            }_        }__        Map<String, Integer> fieldNameCountStore = new HashMap<>()__        StringBuilder overallGrokPatternBuilder = new StringBuilder()__        _        _        for (int inBetweenBitNum = 0_ inBetweenBitNum < groupsMatchesFromExamples.size()_ ++inBetweenBitNum) {_            _            _            overallGrokPatternBuilder.append(fixedRegexBits[inBetweenBitNum])__            appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, inBetweenBitNum == 0,_                    inBetweenBitNum == fixedRegexBits.length - 1, groupsMatchesFromExamples.get(inBetweenBitNum))__        }_        return overallGrokPatternBuilder.toString()__    };given,a,category,definition,regex,and,a,collection,of,examples,from,the,category,return,a,grok,pattern,that,will,match,the,category,and,pull,out,any,likely,fields,the,extracted,fields,are,given,pretty,generic,names,but,unique,within,the,grok,pattern,provided,the,expectation,is,that,a,user,will,adjust,the,extracted,field,names,based,on,their,domain,knowledge;public,static,string,find,best,grok,match,from,examples,string,job,id,string,regex,collection,string,examples,string,fixed,regex,bits,regex,split,pattern,example,processor,pattern,compile,regex,replace,all,1,pattern,dotall,list,collection,string,groups,matches,from,examples,new,array,list,fixed,regex,bits,length,for,int,i,0,i,fixed,regex,bits,length,i,groups,matches,from,examples,add,new,array,list,examples,size,for,string,example,examples,matcher,matcher,example,processor,matcher,example,if,matcher,matches,assert,matcher,group,count,fixed,regex,bits,length,for,int,group,num,1,group,num,matcher,group,count,group,num,groups,matches,from,examples,get,group,num,1,add,matcher,group,group,num,else,assert,matcher,matches,example,processor,pattern,did,not,match,example,loggers,get,logger,grok,pattern,creator,class,error,pattern,did,not,match,example,job,id,example,processor,pattern,example,map,string,integer,field,name,count,store,new,hash,map,string,builder,overall,grok,pattern,builder,new,string,builder,for,int,in,between,bit,num,0,in,between,bit,num,groups,matches,from,examples,size,in,between,bit,num,overall,grok,pattern,builder,append,fixed,regex,bits,in,between,bit,num,append,best,grok,match,for,strings,field,name,count,store,overall,grok,pattern,builder,in,between,bit,num,0,in,between,bit,num,fixed,regex,bits,length,1,groups,matches,from,examples,get,in,between,bit,num,return,overall,grok,pattern,builder,to,string
GrokPatternCreator -> public static String findBestGrokMatchFromExamples(String jobId, String regex, Collection<String> examples);1540847035;Given a category definition regex and a collection of examples from the category, return_a grok pattern that will match the category and pull out any likely fields.  The extracted_fields are given pretty generic names, but unique within the grok pattern provided.  The_expectation is that a user will adjust the extracted field names based on their domain_knowledge.;public static String findBestGrokMatchFromExamples(String jobId, String regex, Collection<String> examples) {__        _        _        _        _        _        String[] fixedRegexBits = regex.split("\\.[*+]\\??")___        _        _        _        Pattern exampleProcessor = Pattern.compile(regex.replaceAll("(\\.[*+]\\??)", "($1)"), Pattern.DOTALL)___        List<Collection<String>> groupsMatchesFromExamples = new ArrayList<>(fixedRegexBits.length)__        for (int i = 0_ i < fixedRegexBits.length_ ++i) {_            groupsMatchesFromExamples.add(new ArrayList<>(examples.size()))__        }_        for (String example : examples) {_            Matcher matcher = exampleProcessor.matcher(example)__            if (matcher.matches()) {_                assert matcher.groupCount() == fixedRegexBits.length__                _                _                _                for (int groupNum = 1_ groupNum <= matcher.groupCount()_ ++groupNum) {_                    groupsMatchesFromExamples.get(groupNum - 1).add(matcher.group(groupNum))__                }_            } else {_                _                _                assert matcher.matches() : exampleProcessor.pattern() + " did not match " + example__                LogManager.getLogger(GrokPatternCreator.class).error("[{}] Pattern [{}] did not match example [{}]", jobId,_                        exampleProcessor.pattern(), example)__            }_        }__        Map<String, Integer> fieldNameCountStore = new HashMap<>()__        StringBuilder overallGrokPatternBuilder = new StringBuilder()__        _        _        for (int inBetweenBitNum = 0_ inBetweenBitNum < groupsMatchesFromExamples.size()_ ++inBetweenBitNum) {_            _            _            overallGrokPatternBuilder.append(fixedRegexBits[inBetweenBitNum])__            appendBestGrokMatchForStrings(fieldNameCountStore, overallGrokPatternBuilder, inBetweenBitNum == 0,_                    inBetweenBitNum == fixedRegexBits.length - 1, groupsMatchesFromExamples.get(inBetweenBitNum))__        }_        return overallGrokPatternBuilder.toString()__    };given,a,category,definition,regex,and,a,collection,of,examples,from,the,category,return,a,grok,pattern,that,will,match,the,category,and,pull,out,any,likely,fields,the,extracted,fields,are,given,pretty,generic,names,but,unique,within,the,grok,pattern,provided,the,expectation,is,that,a,user,will,adjust,the,extracted,field,names,based,on,their,domain,knowledge;public,static,string,find,best,grok,match,from,examples,string,job,id,string,regex,collection,string,examples,string,fixed,regex,bits,regex,split,pattern,example,processor,pattern,compile,regex,replace,all,1,pattern,dotall,list,collection,string,groups,matches,from,examples,new,array,list,fixed,regex,bits,length,for,int,i,0,i,fixed,regex,bits,length,i,groups,matches,from,examples,add,new,array,list,examples,size,for,string,example,examples,matcher,matcher,example,processor,matcher,example,if,matcher,matches,assert,matcher,group,count,fixed,regex,bits,length,for,int,group,num,1,group,num,matcher,group,count,group,num,groups,matches,from,examples,get,group,num,1,add,matcher,group,group,num,else,assert,matcher,matches,example,processor,pattern,did,not,match,example,log,manager,get,logger,grok,pattern,creator,class,error,pattern,did,not,match,example,job,id,example,processor,pattern,example,map,string,integer,field,name,count,store,new,hash,map,string,builder,overall,grok,pattern,builder,new,string,builder,for,int,in,between,bit,num,0,in,between,bit,num,groups,matches,from,examples,size,in,between,bit,num,overall,grok,pattern,builder,append,fixed,regex,bits,in,between,bit,num,append,best,grok,match,for,strings,field,name,count,store,overall,grok,pattern,builder,in,between,bit,num,0,in,between,bit,num,fixed,regex,bits,length,1,groups,matches,from,examples,get,in,between,bit,num,return,overall,grok,pattern,builder,to,string
