commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void remove(ActionListener<Boolean> listener) {     removeData(newJobIterator(), listener). }
false;private;2;20;;private void removeData(WrappedBatchedJobsIterator jobIterator, ActionListener<Boolean> listener) {     if (jobIterator.hasNext() == false) {         listener.onResponse(true).         return.     }     Job job = jobIterator.next().     if (job == null) {         // maybe null if the batched iterator search return no results         listener.onResponse(true).         return.     }     Long retentionDays = getRetentionDays(job).     if (retentionDays == null) {         removeData(jobIterator, listener).         return.     }     long cutoffEpochMs = calcCutoffEpochMs(retentionDays).     removeDataBefore(job, cutoffEpochMs, ActionListener.wrap(response -> removeData(jobIterator, listener), listener::onFailure)). }
false;private;0;4;;private WrappedBatchedJobsIterator newJobIterator() {     BatchedJobsIterator jobsIterator = new BatchedJobsIterator(client, AnomalyDetectorsIndex.configIndexName()).     return new WrappedBatchedJobsIterator(jobsIterator). }
false;private;1;4;;private long calcCutoffEpochMs(long retentionDays) {     long nowEpochMs = Instant.now(Clock.systemDefaultZone()).toEpochMilli().     return nowEpochMs - new TimeValue(retentionDays, TimeUnit.DAYS).getMillis(). }
false;protected,abstract;1;1;;protected abstract Long getRetentionDays(Job job).
true;protected,abstract;3;1;/**  * Template method to allow implementation details of various types of data (e.g. results, model snapshots).  * Implementors need to call {@code listener.onResponse} when they are done in order to continue to the next job.  */ ;/**  * Template method to allow implementation details of various types of data (e.g. results, model snapshots).  * Implementors need to call {@code listener.onResponse} when they are done in order to continue to the next job.  */ protected abstract void removeDataBefore(Job job, long cutoffEpochMs, ActionListener<Boolean> listener).
false;protected,static;2;5;;protected static BoolQueryBuilder createQuery(String jobId, long cutoffEpochMs) {     return QueryBuilders.boolQuery().filter(QueryBuilders.termQuery(Job.ID.getPreferredName(), jobId)).filter(QueryBuilders.rangeQuery(Result.TIMESTAMP.getPreferredName()).lt(cutoffEpochMs).format("epoch_millis")). }
false;public;0;4;;@Override public boolean hasNext() {     return (currentBatch != null && currentBatch.hasNext()) || batchedIterator.hasNext(). }
true;public;0;14;/**  * Before BatchedJobsIterator has run a search it reports hasNext == true  * but the first search may return no results. In that case null is return  * and clients have to handle null.  */ ;/**  * Before BatchedJobsIterator has run a search it reports hasNext == true  * but the first search may return no results. In that case null is return  * and clients have to handle null.  */ @Override public Job next() {     if (currentBatch != null && currentBatch.hasNext()) {         return currentBatch.next().     }     // currentBatch is either null or all its elements have been iterated.     // get the next currentBatch     currentBatch = createBatchIteratorFromBatch(batchedIterator.next()).     // but no results are returned.     return currentBatch.hasNext() ? currentBatch.next() : null. }
false;private;1;4;;private VolatileCursorIterator<Job> createBatchIteratorFromBatch(Deque<Job.Builder> builders) {     List<Job> jobs = builders.stream().map(Job.Builder::build).collect(Collectors.toList()).     return new VolatileCursorIterator<>(jobs). }
