# id;timestamp;commentText;codeText;commentWords;codeWords
TransportSetUpgradeModeAction -> private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,                                          ActionListener<List<PersistentTask<?>>> listener);1548688050;Unassigns all Job and Datafeed tasks._<p>_The reason for unassigning both types is that we want the Datafeed to attempt re-assignment once `upgrade_mode` is_disabled._<p>_If we do not force an allocation change for the Datafeed tasks, they will never start again, since they were isolated._<p>_Datafeed tasks keep the state as `started` and Jobs stay `opened`__@param tasksCustomMetaData Current state of persistent tasks_@param listener            Alerted when tasks are unassignd;private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,_                                         ActionListener<List<PersistentTask<?>>> listener) {_        List<PersistentTask<?>> datafeedAndJobTasks = tasksCustomMetaData_            .tasks()_            .stream()_            .filter(persistentTask -> (persistentTask.getTaskName().equals(MlTasks.JOB_TASK_NAME) ||_                persistentTask.getTaskName().equals(MlTasks.DATAFEED_TASK_NAME)))_            .collect(Collectors.toList())___        TypedChainTaskExecutor<PersistentTask<?>> chainTaskExecutor =_            new TypedChainTaskExecutor<>(client.threadPool().executor(executor()), r -> true, ex -> true)___        for (PersistentTask<?> task : datafeedAndJobTasks) {_            chainTaskExecutor.add(_                chainedTask -> persistentTasksClusterService.unassignPersistentTask(task.getId(),_                    task.getAllocationId(),_                    AWAITING_UPGRADE.getExplanation(),_                    chainedTask)_            )__        }_        chainTaskExecutor.execute(listener)__    };unassigns,all,job,and,datafeed,tasks,p,the,reason,for,unassigning,both,types,is,that,we,want,the,datafeed,to,attempt,re,assignment,once,is,disabled,p,if,we,do,not,force,an,allocation,change,for,the,datafeed,tasks,they,will,never,start,again,since,they,were,isolated,p,datafeed,tasks,keep,the,state,as,started,and,jobs,stay,opened,param,tasks,custom,meta,data,current,state,of,persistent,tasks,param,listener,alerted,when,tasks,are,unassignd;private,void,unassign,persistent,tasks,persistent,tasks,custom,meta,data,tasks,custom,meta,data,action,listener,list,persistent,task,listener,list,persistent,task,datafeed,and,job,tasks,tasks,custom,meta,data,tasks,stream,filter,persistent,task,persistent,task,get,task,name,equals,ml,tasks,persistent,task,get,task,name,equals,ml,tasks,collect,collectors,to,list,typed,chain,task,executor,persistent,task,chain,task,executor,new,typed,chain,task,executor,client,thread,pool,executor,executor,r,true,ex,true,for,persistent,task,task,datafeed,and,job,tasks,chain,task,executor,add,chained,task,persistent,tasks,cluster,service,unassign,persistent,task,task,get,id,task,get,allocation,id,get,explanation,chained,task,chain,task,executor,execute,listener
TransportSetUpgradeModeAction -> private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,                                          ActionListener<List<PersistentTask<?>>> listener);1548852671;Unassigns all Job and Datafeed tasks._<p>_The reason for unassigning both types is that we want the Datafeed to attempt re-assignment once `upgrade_mode` is_disabled._<p>_If we do not force an allocation change for the Datafeed tasks, they will never start again, since they were isolated._<p>_Datafeed tasks keep the state as `started` and Jobs stay `opened`__@param tasksCustomMetaData Current state of persistent tasks_@param listener            Alerted when tasks are unassignd;private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,_                                         ActionListener<List<PersistentTask<?>>> listener) {_        List<PersistentTask<?>> datafeedAndJobTasks = tasksCustomMetaData_            .tasks()_            .stream()_            .filter(persistentTask -> (persistentTask.getTaskName().equals(MlTasks.JOB_TASK_NAME) ||_                persistentTask.getTaskName().equals(MlTasks.DATAFEED_TASK_NAME)))_            .collect(Collectors.toList())___        TypedChainTaskExecutor<PersistentTask<?>> chainTaskExecutor =_            new TypedChainTaskExecutor<>(client.threadPool().executor(executor()), r -> true, ex -> true)___        for (PersistentTask<?> task : datafeedAndJobTasks) {_            chainTaskExecutor.add(_                chainedTask -> persistentTasksClusterService.unassignPersistentTask(task.getId(),_                    task.getAllocationId(),_                    AWAITING_UPGRADE.getExplanation(),_                    chainedTask)_            )__        }_        chainTaskExecutor.execute(listener)__    };unassigns,all,job,and,datafeed,tasks,p,the,reason,for,unassigning,both,types,is,that,we,want,the,datafeed,to,attempt,re,assignment,once,is,disabled,p,if,we,do,not,force,an,allocation,change,for,the,datafeed,tasks,they,will,never,start,again,since,they,were,isolated,p,datafeed,tasks,keep,the,state,as,started,and,jobs,stay,opened,param,tasks,custom,meta,data,current,state,of,persistent,tasks,param,listener,alerted,when,tasks,are,unassignd;private,void,unassign,persistent,tasks,persistent,tasks,custom,meta,data,tasks,custom,meta,data,action,listener,list,persistent,task,listener,list,persistent,task,datafeed,and,job,tasks,tasks,custom,meta,data,tasks,stream,filter,persistent,task,persistent,task,get,task,name,equals,ml,tasks,persistent,task,get,task,name,equals,ml,tasks,collect,collectors,to,list,typed,chain,task,executor,persistent,task,chain,task,executor,new,typed,chain,task,executor,client,thread,pool,executor,executor,r,true,ex,true,for,persistent,task,task,datafeed,and,job,tasks,chain,task,executor,add,chained,task,persistent,tasks,cluster,service,unassign,persistent,task,task,get,id,task,get,allocation,id,get,explanation,chained,task,chain,task,executor,execute,listener
TransportSetUpgradeModeAction -> private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,                                          ActionListener<List<PersistentTask<?>>> listener);1548954474;Unassigns all Job and Datafeed tasks._<p>_The reason for unassigning both types is that we want the Datafeed to attempt re-assignment once `upgrade_mode` is_disabled._<p>_If we do not force an allocation change for the Datafeed tasks, they will never start again, since they were isolated._<p>_Datafeed tasks keep the state as `started` and Jobs stay `opened`__@param tasksCustomMetaData Current state of persistent tasks_@param listener            Alerted when tasks are unassignd;private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,_                                         ActionListener<List<PersistentTask<?>>> listener) {_        List<PersistentTask<?>> datafeedAndJobTasks = tasksCustomMetaData_            .tasks()_            .stream()_            .filter(persistentTask -> (persistentTask.getTaskName().equals(MlTasks.JOB_TASK_NAME) ||_                persistentTask.getTaskName().equals(MlTasks.DATAFEED_TASK_NAME)))_            _            _            .sorted(Comparator.comparing(PersistentTask::getTaskName))_            .collect(Collectors.toList())___        TypedChainTaskExecutor<PersistentTask<?>> chainTaskExecutor =_            new TypedChainTaskExecutor<>(client.threadPool().executor(executor()),_                r -> true,_                _                _                _                _                ex -> ex instanceof ResourceNotFoundException == false)___        for (PersistentTask<?> task : datafeedAndJobTasks) {_            chainTaskExecutor.add(_                chainedTask -> persistentTasksClusterService.unassignPersistentTask(task.getId(),_                    task.getAllocationId(),_                    AWAITING_UPGRADE.getExplanation(),_                    chainedTask)_            )__        }_        chainTaskExecutor.execute(listener)__    };unassigns,all,job,and,datafeed,tasks,p,the,reason,for,unassigning,both,types,is,that,we,want,the,datafeed,to,attempt,re,assignment,once,is,disabled,p,if,we,do,not,force,an,allocation,change,for,the,datafeed,tasks,they,will,never,start,again,since,they,were,isolated,p,datafeed,tasks,keep,the,state,as,started,and,jobs,stay,opened,param,tasks,custom,meta,data,current,state,of,persistent,tasks,param,listener,alerted,when,tasks,are,unassignd;private,void,unassign,persistent,tasks,persistent,tasks,custom,meta,data,tasks,custom,meta,data,action,listener,list,persistent,task,listener,list,persistent,task,datafeed,and,job,tasks,tasks,custom,meta,data,tasks,stream,filter,persistent,task,persistent,task,get,task,name,equals,ml,tasks,persistent,task,get,task,name,equals,ml,tasks,sorted,comparator,comparing,persistent,task,get,task,name,collect,collectors,to,list,typed,chain,task,executor,persistent,task,chain,task,executor,new,typed,chain,task,executor,client,thread,pool,executor,executor,r,true,ex,ex,instanceof,resource,not,found,exception,false,for,persistent,task,task,datafeed,and,job,tasks,chain,task,executor,add,chained,task,persistent,tasks,cluster,service,unassign,persistent,task,task,get,id,task,get,allocation,id,get,explanation,chained,task,chain,task,executor,execute,listener
TransportSetUpgradeModeAction -> private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,                                          ActionListener<List<PersistentTask<?>>> listener);1549485564;Unassigns all Job and Datafeed tasks._<p>_The reason for unassigning both types is that we want the Datafeed to attempt re-assignment once `upgrade_mode` is_disabled._<p>_If we do not force an allocation change for the Datafeed tasks, they will never start again, since they were isolated._<p>_Datafeed tasks keep the state as `started` and Jobs stay `opened`__@param tasksCustomMetaData Current state of persistent tasks_@param listener            Alerted when tasks are unassignd;private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,_                                         ActionListener<List<PersistentTask<?>>> listener) {_        List<PersistentTask<?>> datafeedAndJobTasks = tasksCustomMetaData_            .tasks()_            .stream()_            .filter(persistentTask -> (persistentTask.getTaskName().equals(MlTasks.JOB_TASK_NAME) ||_                persistentTask.getTaskName().equals(MlTasks.DATAFEED_TASK_NAME)))_            _            _            .sorted(Comparator.comparing(PersistentTask::getTaskName))_            .collect(Collectors.toList())___        logger.info("Un-assigning persistent tasks : " +_            datafeedAndJobTasks.stream().map(PersistentTask::getId).collect(Collectors.joining(", ", "[ ", " ]")))___        TypedChainTaskExecutor<PersistentTask<?>> chainTaskExecutor =_            new TypedChainTaskExecutor<>(client.threadPool().executor(executor()),_                r -> true,_                _                _                _                _                ex -> ex instanceof ResourceNotFoundException == false)___        for (PersistentTask<?> task : datafeedAndJobTasks) {_            chainTaskExecutor.add(_                chainedTask -> persistentTasksClusterService.unassignPersistentTask(task.getId(),_                    task.getAllocationId(),_                    AWAITING_UPGRADE.getExplanation(),_                    chainedTask)_            )__        }_        chainTaskExecutor.execute(listener)__    };unassigns,all,job,and,datafeed,tasks,p,the,reason,for,unassigning,both,types,is,that,we,want,the,datafeed,to,attempt,re,assignment,once,is,disabled,p,if,we,do,not,force,an,allocation,change,for,the,datafeed,tasks,they,will,never,start,again,since,they,were,isolated,p,datafeed,tasks,keep,the,state,as,started,and,jobs,stay,opened,param,tasks,custom,meta,data,current,state,of,persistent,tasks,param,listener,alerted,when,tasks,are,unassignd;private,void,unassign,persistent,tasks,persistent,tasks,custom,meta,data,tasks,custom,meta,data,action,listener,list,persistent,task,listener,list,persistent,task,datafeed,and,job,tasks,tasks,custom,meta,data,tasks,stream,filter,persistent,task,persistent,task,get,task,name,equals,ml,tasks,persistent,task,get,task,name,equals,ml,tasks,sorted,comparator,comparing,persistent,task,get,task,name,collect,collectors,to,list,logger,info,un,assigning,persistent,tasks,datafeed,and,job,tasks,stream,map,persistent,task,get,id,collect,collectors,joining,typed,chain,task,executor,persistent,task,chain,task,executor,new,typed,chain,task,executor,client,thread,pool,executor,executor,r,true,ex,ex,instanceof,resource,not,found,exception,false,for,persistent,task,task,datafeed,and,job,tasks,chain,task,executor,add,chained,task,persistent,tasks,cluster,service,unassign,persistent,task,task,get,id,task,get,allocation,id,get,explanation,chained,task,chain,task,executor,execute,listener
TransportSetUpgradeModeAction -> private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,                                          ActionListener<List<PersistentTask<?>>> listener);1550584067;Unassigns all Job and Datafeed tasks._<p>_The reason for unassigning both types is that we want the Datafeed to attempt re-assignment once `upgrade_mode` is_disabled._<p>_If we do not force an allocation change for the Datafeed tasks, they will never start again, since they were isolated._<p>_Datafeed tasks keep the state as `started` and Jobs stay `opened`__@param tasksCustomMetaData Current state of persistent tasks_@param listener            Alerted when tasks are unassignd;private void unassignPersistentTasks(PersistentTasksCustomMetaData tasksCustomMetaData,_                                         ActionListener<List<PersistentTask<?>>> listener) {_        List<PersistentTask<?>> datafeedAndJobTasks = tasksCustomMetaData_            .tasks()_            .stream()_            .filter(persistentTask -> (persistentTask.getTaskName().equals(MlTasks.JOB_TASK_NAME) ||_                persistentTask.getTaskName().equals(MlTasks.DATAFEED_TASK_NAME)))_            _            _            .sorted(Comparator.comparing(PersistentTask::getTaskName))_            .collect(Collectors.toList())___        logger.info("Un-assigning persistent tasks : " +_            datafeedAndJobTasks.stream().map(PersistentTask::getId).collect(Collectors.joining(", ", "[ ", " ]")))___        TypedChainTaskExecutor<PersistentTask<?>> chainTaskExecutor =_            new TypedChainTaskExecutor<>(client.threadPool().executor(executor()),_                r -> true,_                _                _                _                _                ex -> ex instanceof ResourceNotFoundException == false)___        for (PersistentTask<?> task : datafeedAndJobTasks) {_            chainTaskExecutor.add(_                chainedTask -> persistentTasksClusterService.unassignPersistentTask(task.getId(),_                    task.getAllocationId(),_                    AWAITING_UPGRADE.getExplanation(),_                    chainedTask)_            )__        }_        chainTaskExecutor.execute(listener)__    };unassigns,all,job,and,datafeed,tasks,p,the,reason,for,unassigning,both,types,is,that,we,want,the,datafeed,to,attempt,re,assignment,once,is,disabled,p,if,we,do,not,force,an,allocation,change,for,the,datafeed,tasks,they,will,never,start,again,since,they,were,isolated,p,datafeed,tasks,keep,the,state,as,started,and,jobs,stay,opened,param,tasks,custom,meta,data,current,state,of,persistent,tasks,param,listener,alerted,when,tasks,are,unassignd;private,void,unassign,persistent,tasks,persistent,tasks,custom,meta,data,tasks,custom,meta,data,action,listener,list,persistent,task,listener,list,persistent,task,datafeed,and,job,tasks,tasks,custom,meta,data,tasks,stream,filter,persistent,task,persistent,task,get,task,name,equals,ml,tasks,persistent,task,get,task,name,equals,ml,tasks,sorted,comparator,comparing,persistent,task,get,task,name,collect,collectors,to,list,logger,info,un,assigning,persistent,tasks,datafeed,and,job,tasks,stream,map,persistent,task,get,id,collect,collectors,joining,typed,chain,task,executor,persistent,task,chain,task,executor,new,typed,chain,task,executor,client,thread,pool,executor,executor,r,true,ex,ex,instanceof,resource,not,found,exception,false,for,persistent,task,task,datafeed,and,job,tasks,chain,task,executor,add,chained,task,persistent,tasks,cluster,service,unassign,persistent,task,task,get,id,task,get,allocation,id,get,explanation,chained,task,chain,task,executor,execute,listener
