commented;modifiers;parameterAmount;loc;comment;code
true;public;1;12;/**  * This method attempts to find a Grok pattern that will match all of the sample messages in their entirety.  * It will also update mappings and field stats if they are non-<code>null</code>.  * @param timestampField If not <code>null</code> then the chosen Grok pattern must use this timestamp field.  * @return A tuple of (time field name, Grok string), or <code>null</code> if no suitable Grok pattern was found.  */ ;/**  * This method attempts to find a Grok pattern that will match all of the sample messages in their entirety.  * It will also update mappings and field stats if they are non-<code>null</code>.  * @param timestampField If not <code>null</code> then the chosen Grok pattern must use this timestamp field.  * @return A tuple of (time field name, Grok string), or <code>null</code> if no suitable Grok pattern was found.  */ public Tuple<String, String> findFullLineGrokPattern(String timestampField) {     for (FullMatchGrokPatternCandidate candidate : FULL_MATCH_GROK_PATTERNS) {         if (timestampField == null || timestampField.equals(candidate.getTimeField())) {             if (candidate.matchesAll(sampleMessages, timeoutChecker)) {                 return candidate.processMatch(explanation, sampleMessages, mappings, fieldStats, timeoutChecker).             }         }     }     return null. }
true;public;2;9;/**  * This method processes a user-supplied Grok pattern that will match all of the sample messages in their entirety.  * It will also update mappings and field stats if they are non-<code>null</code>.  * @param grokPattern The user supplied Grok pattern.  * @param timestampField The name of the timestamp field within the Grok pattern.  * @throws IllegalArgumentException If the supplied Grok pattern does not match the sample messages.  */ ;/**  * This method processes a user-supplied Grok pattern that will match all of the sample messages in their entirety.  * It will also update mappings and field stats if they are non-<code>null</code>.  * @param grokPattern The user supplied Grok pattern.  * @param timestampField The name of the timestamp field within the Grok pattern.  * @throws IllegalArgumentException If the supplied Grok pattern does not match the sample messages.  */ public void validateFullLineGrokPattern(String grokPattern, String timestampField) {     FullMatchGrokPatternCandidate candidate = FullMatchGrokPatternCandidate.fromGrokPattern(grokPattern, timestampField).     if (candidate.matchesAll(sampleMessages, timeoutChecker)) {         candidate.processMatch(explanation, sampleMessages, mappings, fieldStats, timeoutChecker).     } else {         throw new IllegalArgumentException("Supplied Grok pattern [" + grokPattern + "] does not match sample messages").     } }
true;public;2;10;/**  * Build a Grok pattern that will match all of the sample messages in their entirety.  * @param seedPatternName A pattern that has already been determined to match some portion of every sample message.  * @param seedFieldName The field name to be used for the portion of every sample message that the seed pattern matches.  * @return The built Grok pattern.  */ ;/**  * Build a Grok pattern that will match all of the sample messages in their entirety.  * @param seedPatternName A pattern that has already been determined to match some portion of every sample message.  * @param seedFieldName The field name to be used for the portion of every sample message that the seed pattern matches.  * @return The built Grok pattern.  */ public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName) {     overallGrokPatternBuilder.setLength(0).     GrokPatternCandidate seedCandidate = new NoMappingGrokPatternCandidate(seedPatternName, seedFieldName).     processCandidateAndSplit(seedCandidate, true, sampleMessages, false, 0, false, 0).     return overallGrokPatternBuilder.toString().replace("\t", "\\t").replace("\n", "\\n"). }
true;;0;3;/**  * This is purely to allow unit tests to inspect the partial Grok pattern after testing implementation details.  * It should not be used in production code.  */ ;/**  * This is purely to allow unit tests to inspect the partial Grok pattern after testing implementation details.  * It should not be used in production code.  */ StringBuilder getOverallGrokPatternBuilder() {     return overallGrokPatternBuilder. }
true;private;7;12;/**  * Given a chosen Grok pattern and a collection of message snippets, split the snippets into the  * matched section and the pieces before and after it.  Recurse to find more matches in the pieces  * before and after and update the supplied string builder.  */ ;/**  * Given a chosen Grok pattern and a collection of message snippets, split the snippets into the  * matched section and the pieces before and after it.  Recurse to find more matches in the pieces  * before and after and update the supplied string builder.  */ private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets, boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft, boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight) {     Collection<String> prefaces = new ArrayList<>().     Collection<String> epilogues = new ArrayList<>().     String patternBuilderContent = chosenPattern.processCaptures(fieldNameCountStore, snippets, prefaces, epilogues, mappings, fieldStats, timeoutChecker).     appendBestGrokMatchForStrings(false, prefaces, ignoreKeyValueCandidateLeft, ignoreValueOnlyCandidatesLeft).     overallGrokPatternBuilder.append(patternBuilderContent).     appendBestGrokMatchForStrings(isLast, epilogues, ignoreKeyValueCandidateRight, ignoreValueOnlyCandidatesRight). }
true;;4;34;/**  * Given a collection of message snippets, work out which (if any) of the Grok patterns we're allowed  * to use matches it best.  Then append the appropriate Grok language to represent that finding onto  * the supplied string builder.  */ ;/**  * Given a collection of message snippets, work out which (if any) of the Grok patterns we're allowed  * to use matches it best.  Then append the appropriate Grok language to represent that finding onto  * the supplied string builder.  */ void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets, boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates) {     snippets = adjustForPunctuation(snippets).     GrokPatternCandidate bestCandidate = null.     if (snippets.isEmpty() == false) {         GrokPatternCandidate kvCandidate = new KeyValueGrokPatternCandidate(explanation).         if (ignoreKeyValueCandidate == false && kvCandidate.matchesAll(snippets)) {             bestCandidate = kvCandidate.         } else {             ignoreKeyValueCandidate = true.             for (GrokPatternCandidate candidate : ORDERED_CANDIDATE_GROK_PATTERNS.subList(ignoreValueOnlyCandidates, ORDERED_CANDIDATE_GROK_PATTERNS.size())) {                 if (candidate.matchesAll(snippets)) {                     bestCandidate = candidate.                     break.                 }                 ++ignoreValueOnlyCandidates.             }         }     }     if (bestCandidate == null) {         if (isLast) {             finalizeGrokPattern(snippets).         } else {             addIntermediateRegex(snippets).         }     } else {         processCandidateAndSplit(bestCandidate, isLast, snippets, true, ignoreValueOnlyCandidates + (ignoreKeyValueCandidate ? 1 : 0), ignoreKeyValueCandidate, ignoreValueOnlyCandidates).     } }
true;;1;47;/**  * If the snippets supplied begin with more than 1 character of common punctuation or whitespace  * then add all but the last of these characters to the overall pattern and remove them from the  * snippets.  * @param snippets Input snippets - not modified.  * @return Output snippets, which will be a copy of the input snippets but with whatever characters  *         were added to <code>overallPatternBuilder</code> removed from the beginning.  */ ;/**  * If the snippets supplied begin with more than 1 character of common punctuation or whitespace  * then add all but the last of these characters to the overall pattern and remove them from the  * snippets.  * @param snippets Input snippets - not modified.  * @return Output snippets, which will be a copy of the input snippets but with whatever characters  *         were added to <code>overallPatternBuilder</code> removed from the beginning.  */ Collection<String> adjustForPunctuation(Collection<String> snippets) {     assert snippets.isEmpty() == false.     StringBuilder commonInitialPunctuation = new StringBuilder().     for (String snippet : snippets) {         if (commonInitialPunctuation.length() == 0) {             for (int index = 0. index < snippet.length(). ++index) {                 char ch = snippet.charAt(index).                 if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.get(ch) != null) {                     commonInitialPunctuation.append(ch).                 } else {                     break.                 }             }         } else {             if (commonInitialPunctuation.length() > snippet.length()) {                 commonInitialPunctuation.delete(snippet.length(), commonInitialPunctuation.length()).             }             for (int index = 0. index < commonInitialPunctuation.length(). ++index) {                 char ch = snippet.charAt(index).                 if (ch != commonInitialPunctuation.charAt(index)) {                     commonInitialPunctuation.delete(index, commonInitialPunctuation.length()).                     break.                 }             }         }         if (commonInitialPunctuation.length() <= 1) {             return snippets.         }     }     int numLiteralCharacters = commonInitialPunctuation.length() - 1.     for (int index = 0. index < numLiteralCharacters. ++index) {         char ch = commonInitialPunctuation.charAt(index).         if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.getOrDefault(ch, false)) {             overallGrokPatternBuilder.append('\\').         }         overallGrokPatternBuilder.append(ch).     }     return snippets.stream().map(snippet -> snippet.substring(numLiteralCharacters)).collect(Collectors.toList()). }
true;static;2;4;/**  * The first time a particular field name is passed, simply return it.  * The second time return it with "2" appended.  * The third time return it with "3" appended.  * Etc.  */ ;/**  * The first time a particular field name is passed, simply return it.  * The second time return it with "2" appended.  * The third time return it with "3" appended.  * Etc.  */ static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {     Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v)).     return (numberSeen > 1) ? fieldName + numberSeen : fieldName. }
false;private;1;3;;private void addIntermediateRegex(Collection<String> snippets) {     addIntermediateRegex(overallGrokPatternBuilder, snippets). }
false;public,static;2;32;;public static void addIntermediateRegex(StringBuilder patternBuilder, Collection<String> snippets) {     if (snippets.isEmpty()) {         return.     }     List<String> others = new ArrayList<>(snippets).     String driver = others.remove(others.size() - 1).     boolean wildcardRequiredIfNonMatchFound = true.     for (int i = 0. i < driver.length(). ++i) {         char ch = driver.charAt(i).         Boolean punctuationOrSpaceNeedsEscaping = PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.get(ch).         if (punctuationOrSpaceNeedsEscaping != null && others.stream().allMatch(other -> other.indexOf(ch) >= 0)) {             if (wildcardRequiredIfNonMatchFound && others.stream().anyMatch(other -> other.indexOf(ch) > 0)) {                 patternBuilder.append(".*?").             }             if (punctuationOrSpaceNeedsEscaping) {                 patternBuilder.append('\\').             }             patternBuilder.append(ch).             wildcardRequiredIfNonMatchFound = true.             others = others.stream().map(other -> other.substring(other.indexOf(ch) + 1)).collect(Collectors.toList()).         } else if (wildcardRequiredIfNonMatchFound) {             patternBuilder.append(".*?").             wildcardRequiredIfNonMatchFound = false.         }     }     if (wildcardRequiredIfNonMatchFound && others.stream().anyMatch(s -> s.isEmpty() == false)) {         patternBuilder.append(".*?").     } }
false;private;1;28;;private void finalizeGrokPattern(Collection<String> snippets) {     if (snippets.stream().allMatch(String::isEmpty)) {         return.     }     List<String> others = new ArrayList<>(snippets).     String driver = others.remove(others.size() - 1).     for (int i = 0. i < driver.length(). ++i) {         char ch = driver.charAt(i).         int driverIndex = i.         Boolean punctuationOrSpaceNeedsEscaping = PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.get(ch).         if (punctuationOrSpaceNeedsEscaping != null && others.stream().allMatch(other -> other.length() > driverIndex && other.charAt(driverIndex) == ch)) {             if (punctuationOrSpaceNeedsEscaping) {                 overallGrokPatternBuilder.append('\\').             }             overallGrokPatternBuilder.append(ch).             if (i == driver.length() - 1 && others.stream().allMatch(driver::equals)) {                 return.             }         } else {             break.         }     }     overallGrokPatternBuilder.append(".*"). }
true;;1;1;/**  * @return Does this Grok pattern candidate match all the snippets?  */ ;/**  * @return Does this Grok pattern candidate match all the snippets?  */ boolean matchesAll(Collection<String> snippets).
true;;7;3;/**  * After it has been determined that this Grok pattern candidate matches a collection of strings,  * return collections of the bits that come before (prefaces) and after (epilogues) the bit  * that matches.  Also update mappings with the most appropriate field name and type, and  * calculate field stats.  * @return The string that needs to be incorporated into the overall Grok pattern for the line.  */ ;/**  * After it has been determined that this Grok pattern candidate matches a collection of strings,  * return collections of the bits that come before (prefaces) and after (epilogues) the bit  * that matches.  Also update mappings with the most appropriate field name and type, and  * calculate field stats.  * @return The string that needs to be incorporated into the overall Grok pattern for the line.  */ String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces, Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker).
false;public;1;4;;@Override public boolean matchesAll(Collection<String> snippets) {     return snippets.stream().allMatch(grok::match). }
true;public;7;33;/**  * Given a collection of strings, and a Grok pattern that matches some part of them all,  * return collections of the bits that come before (prefaces) and after (epilogues) the  * bit that matches.  */ ;/**  * Given a collection of strings, and a Grok pattern that matches some part of them all,  * return collections of the bits that come before (prefaces) and after (epilogues) the  * bit that matches.  */ @Override public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces, Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker) {     Collection<String> values = new ArrayList<>().     for (String snippet : snippets) {         Map<String, Object> captures = timeoutChecker.grokCaptures(grok, snippet, "full message Grok pattern field extraction").         // If the pattern doesn't match then captures will be null         if (captures == null) {             throw new IllegalStateException("[%{" + grokPatternName + "}] does not match snippet [" + snippet + "]").         }         prefaces.add(captures.getOrDefault(PREFACE, "").toString()).         values.add(captures.getOrDefault(VALUE, "").toString()).         epilogues.add(captures.getOrDefault(EPILOGUE, "").toString()).     }     String adjustedFieldName = buildFieldName(fieldNameCountStore, fieldName).     if (mappings != null) {         Map<String, String> fullMappingType = Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, mappingType).         if ("date".equals(mappingType)) {             assert values.isEmpty() == false.             TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(values.iterator().next(), timeoutChecker).             if (timestampMatch != null) {                 fullMappingType = timestampMatch.getEsDateMappingTypeWithFormat().             }             timeoutChecker.check("mapping determination").         }         mappings.put(adjustedFieldName, fullMappingType).     }     if (fieldStats != null) {         fieldStats.put(adjustedFieldName, FileStructureUtils.calculateFieldStats(values, timeoutChecker)).     }     return "%{" + grokPatternName + ":" + adjustedFieldName + "}". }
false;public;1;21;;@Override public boolean matchesAll(Collection<String> snippets) {     Set<String> candidateNames = new LinkedHashSet<>().     boolean isFirst = true.     for (String snippet : snippets) {         if (isFirst) {             Matcher matcher = kvFinder.matcher(snippet).             while (matcher.find()) {                 candidateNames.add(matcher.group(1)).             }             isFirst = false.         } else {             candidateNames.removeIf(candidateName -> Pattern.compile("\\b" + candidateName + "=[\\w.-]+").matcher(snippet).find() == false).         }         if (candidateNames.isEmpty()) {             break.         }     }     return (fieldName = candidateNames.stream().findFirst().orElse(null)) != null. }
false;public;7;32;;@Override public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces, Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker) {     if (fieldName == null) {         throw new IllegalStateException("Cannot process KV matches until a field name has been determined").     }     Grok grok = new Grok(Grok.getBuiltinPatterns(), "(?m)%{DATA:" + PREFACE + "}\\b" + fieldName + "=%{USER:" + VALUE + "}%{GREEDYDATA:" + EPILOGUE + "}", TimeoutChecker.watchdog).     Collection<String> values = new ArrayList<>().     for (String snippet : snippets) {         Map<String, Object> captures = grok.captures(snippet).         // If the pattern doesn't match then captures will be null         if (captures == null) {             throw new IllegalStateException("[\\b" + fieldName + "=%{USER}] does not match snippet [" + snippet + "]").         }         prefaces.add(captures.getOrDefault(PREFACE, "").toString()).         values.add(captures.getOrDefault(VALUE, "").toString()).         epilogues.add(captures.getOrDefault(EPILOGUE, "").toString()).         timeoutChecker.check("full message Grok pattern field extraction").     }     String adjustedFieldName = buildFieldName(fieldNameCountStore, fieldName).     if (mappings != null) {         mappings.put(adjustedFieldName, FileStructureUtils.guessScalarMapping(explanation, adjustedFieldName, values, timeoutChecker)).         timeoutChecker.check("mapping determination").     }     if (fieldStats != null) {         fieldStats.put(adjustedFieldName, FileStructureUtils.calculateFieldStats(values, timeoutChecker)).     }     return "\\b" + fieldName + "=%{USER:" + adjustedFieldName + "}". }
false;public;7;6;;@Override public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces, Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker) {     return super.processCaptures(fieldNameCountStore, snippets, prefaces, epilogues, null, fieldStats, timeoutChecker). }
false;static;2;3;;static FullMatchGrokPatternCandidate fromGrokPatternName(String grokPatternName, String timeField) {     return new FullMatchGrokPatternCandidate("%{" + grokPatternName + "}", timeField). }
false;static;2;3;;static FullMatchGrokPatternCandidate fromGrokPattern(String grokPattern, String timeField) {     return new FullMatchGrokPatternCandidate(grokPattern, timeField). }
false;public;0;3;;public String getTimeField() {     return timeField. }
false;public;2;9;;public boolean matchesAll(Collection<String> sampleMessages, TimeoutChecker timeoutChecker) {     for (String sampleMessage : sampleMessages) {         if (grok.match(sampleMessage) == false) {             return false.         }         timeoutChecker.check("full message Grok pattern matching").     }     return true. }
true;public;5;48;/**  * This must only be called if {@link #matchesAll} returns <code>true</code>.  * @return A tuple of (time field name, Grok string).  */ ;/**  * This must only be called if {@link #matchesAll} returns <code>true</code>.  * @return A tuple of (time field name, Grok string).  */ public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings, Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker) {     explanation.add("A full message Grok pattern [" + grokPattern.substring(2, grokPattern.length() - 1) + "] looks appropriate").     if (mappings != null || fieldStats != null) {         Map<String, Collection<String>> valuesPerField = new HashMap<>().         for (String sampleMessage : sampleMessages) {             Map<String, Object> captures = timeoutChecker.grokCaptures(grok, sampleMessage, "full message Grok pattern field extraction").             // If the pattern doesn't match then captures will be null             if (captures == null) {                 throw new IllegalStateException("[" + grokPattern + "] does not match snippet [" + sampleMessage + "]").             }             for (Map.Entry<String, Object> capture : captures.entrySet()) {                 String fieldName = capture.getKey().                 String fieldValue = capture.getValue().toString().                 valuesPerField.compute(fieldName, (k, v) -> {                     if (v == null) {                         return new ArrayList<>(Collections.singletonList(fieldValue)).                     } else {                         v.add(fieldValue).                         return v.                     }                 }).             }         }         for (Map.Entry<String, Collection<String>> valuesForField : valuesPerField.entrySet()) {             String fieldName = valuesForField.getKey().             if (mappings != null) {                 // Exclude the time field because that will be dropped and replaced with @timestamp                 if (fieldName.equals(timeField) == false) {                     mappings.put(fieldName, FileStructureUtils.guessScalarMapping(explanation, fieldName, valuesForField.getValue(), timeoutChecker)).                     timeoutChecker.check("mapping determination").                 }             }             if (fieldStats != null) {                 fieldStats.put(fieldName, FileStructureUtils.calculateFieldStats(valuesForField.getValue(), timeoutChecker)).             }         }     }     return new Tuple<>(timeField, grokPattern). }
