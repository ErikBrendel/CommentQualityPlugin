# id;timestamp;commentText;codeText;commentWords;codeWords
GrokPatternCreator -> Collection<String> adjustForPunctuation(Collection<String> snippets);1536314350;If the snippets supplied begin with more than 1 character of common punctuation or whitespace_then add all but the last of these characters to the overall pattern and remove them from the_snippets._@param snippets Input snippets - not modified._@return Output snippets, which will be a copy of the input snippets but with whatever characters_were added to <code>overallPatternBuilder</code> removed from the beginning.;Collection<String> adjustForPunctuation(Collection<String> snippets) {__        assert snippets.isEmpty() == false___        StringBuilder commonInitialPunctuation = new StringBuilder()___        for (String snippet : snippets) {__            if (commonInitialPunctuation.length() == 0) {_                for (int index = 0_ index < snippet.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.get(ch) != null) {_                        commonInitialPunctuation.append(ch)__                    } else {_                        break__                    }_                }_            } else {_                if (commonInitialPunctuation.length() > snippet.length()) {_                    commonInitialPunctuation.delete(snippet.length(), commonInitialPunctuation.length())__                }_                for (int index = 0_ index < commonInitialPunctuation.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (ch != commonInitialPunctuation.charAt(index)) {_                        commonInitialPunctuation.delete(index, commonInitialPunctuation.length())__                        break__                    }_                }_            }__            if (commonInitialPunctuation.length() <= 1) {_                return snippets__            }_        }__        int numLiteralCharacters = commonInitialPunctuation.length() - 1___        for (int index = 0_ index < numLiteralCharacters_ ++index) {_            char ch = commonInitialPunctuation.charAt(index)__            if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.getOrDefault(ch, false)) {_                overallGrokPatternBuilder.append('\\')__            }_            overallGrokPatternBuilder.append(ch)__        }__        return snippets.stream().map(snippet -> snippet.substring(numLiteralCharacters)).collect(Collectors.toList())__    };if,the,snippets,supplied,begin,with,more,than,1,character,of,common,punctuation,or,whitespace,then,add,all,but,the,last,of,these,characters,to,the,overall,pattern,and,remove,them,from,the,snippets,param,snippets,input,snippets,not,modified,return,output,snippets,which,will,be,a,copy,of,the,input,snippets,but,with,whatever,characters,were,added,to,code,overall,pattern,builder,code,removed,from,the,beginning;collection,string,adjust,for,punctuation,collection,string,snippets,assert,snippets,is,empty,false,string,builder,common,initial,punctuation,new,string,builder,for,string,snippet,snippets,if,common,initial,punctuation,length,0,for,int,index,0,index,snippet,length,index,char,ch,snippet,char,at,index,if,get,ch,null,common,initial,punctuation,append,ch,else,break,else,if,common,initial,punctuation,length,snippet,length,common,initial,punctuation,delete,snippet,length,common,initial,punctuation,length,for,int,index,0,index,common,initial,punctuation,length,index,char,ch,snippet,char,at,index,if,ch,common,initial,punctuation,char,at,index,common,initial,punctuation,delete,index,common,initial,punctuation,length,break,if,common,initial,punctuation,length,1,return,snippets,int,num,literal,characters,common,initial,punctuation,length,1,for,int,index,0,index,num,literal,characters,index,char,ch,common,initial,punctuation,char,at,index,if,get,or,default,ch,false,overall,grok,pattern,builder,append,overall,grok,pattern,builder,append,ch,return,snippets,stream,map,snippet,snippet,substring,num,literal,characters,collect,collectors,to,list
GrokPatternCreator -> Collection<String> adjustForPunctuation(Collection<String> snippets);1536611444;If the snippets supplied begin with more than 1 character of common punctuation or whitespace_then add all but the last of these characters to the overall pattern and remove them from the_snippets._@param snippets Input snippets - not modified._@return Output snippets, which will be a copy of the input snippets but with whatever characters_were added to <code>overallPatternBuilder</code> removed from the beginning.;Collection<String> adjustForPunctuation(Collection<String> snippets) {__        assert snippets.isEmpty() == false___        StringBuilder commonInitialPunctuation = new StringBuilder()___        for (String snippet : snippets) {__            if (commonInitialPunctuation.length() == 0) {_                for (int index = 0_ index < snippet.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.get(ch) != null) {_                        commonInitialPunctuation.append(ch)__                    } else {_                        break__                    }_                }_            } else {_                if (commonInitialPunctuation.length() > snippet.length()) {_                    commonInitialPunctuation.delete(snippet.length(), commonInitialPunctuation.length())__                }_                for (int index = 0_ index < commonInitialPunctuation.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (ch != commonInitialPunctuation.charAt(index)) {_                        commonInitialPunctuation.delete(index, commonInitialPunctuation.length())__                        break__                    }_                }_            }__            if (commonInitialPunctuation.length() <= 1) {_                return snippets__            }_        }__        int numLiteralCharacters = commonInitialPunctuation.length() - 1___        for (int index = 0_ index < numLiteralCharacters_ ++index) {_            char ch = commonInitialPunctuation.charAt(index)__            if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.getOrDefault(ch, false)) {_                overallGrokPatternBuilder.append('\\')__            }_            overallGrokPatternBuilder.append(ch)__        }__        return snippets.stream().map(snippet -> snippet.substring(numLiteralCharacters)).collect(Collectors.toList())__    };if,the,snippets,supplied,begin,with,more,than,1,character,of,common,punctuation,or,whitespace,then,add,all,but,the,last,of,these,characters,to,the,overall,pattern,and,remove,them,from,the,snippets,param,snippets,input,snippets,not,modified,return,output,snippets,which,will,be,a,copy,of,the,input,snippets,but,with,whatever,characters,were,added,to,code,overall,pattern,builder,code,removed,from,the,beginning;collection,string,adjust,for,punctuation,collection,string,snippets,assert,snippets,is,empty,false,string,builder,common,initial,punctuation,new,string,builder,for,string,snippet,snippets,if,common,initial,punctuation,length,0,for,int,index,0,index,snippet,length,index,char,ch,snippet,char,at,index,if,get,ch,null,common,initial,punctuation,append,ch,else,break,else,if,common,initial,punctuation,length,snippet,length,common,initial,punctuation,delete,snippet,length,common,initial,punctuation,length,for,int,index,0,index,common,initial,punctuation,length,index,char,ch,snippet,char,at,index,if,ch,common,initial,punctuation,char,at,index,common,initial,punctuation,delete,index,common,initial,punctuation,length,break,if,common,initial,punctuation,length,1,return,snippets,int,num,literal,characters,common,initial,punctuation,length,1,for,int,index,0,index,num,literal,characters,index,char,ch,common,initial,punctuation,char,at,index,if,get,or,default,ch,false,overall,grok,pattern,builder,append,overall,grok,pattern,builder,append,ch,return,snippets,stream,map,snippet,snippet,substring,num,literal,characters,collect,collectors,to,list
GrokPatternCreator -> Collection<String> adjustForPunctuation(Collection<String> snippets);1536964057;If the snippets supplied begin with more than 1 character of common punctuation or whitespace_then add all but the last of these characters to the overall pattern and remove them from the_snippets._@param snippets Input snippets - not modified._@return Output snippets, which will be a copy of the input snippets but with whatever characters_were added to <code>overallPatternBuilder</code> removed from the beginning.;Collection<String> adjustForPunctuation(Collection<String> snippets) {__        assert snippets.isEmpty() == false___        StringBuilder commonInitialPunctuation = new StringBuilder()___        for (String snippet : snippets) {__            if (commonInitialPunctuation.length() == 0) {_                for (int index = 0_ index < snippet.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.get(ch) != null) {_                        commonInitialPunctuation.append(ch)__                    } else {_                        break__                    }_                }_            } else {_                if (commonInitialPunctuation.length() > snippet.length()) {_                    commonInitialPunctuation.delete(snippet.length(), commonInitialPunctuation.length())__                }_                for (int index = 0_ index < commonInitialPunctuation.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (ch != commonInitialPunctuation.charAt(index)) {_                        commonInitialPunctuation.delete(index, commonInitialPunctuation.length())__                        break__                    }_                }_            }__            if (commonInitialPunctuation.length() <= 1) {_                return snippets__            }_        }__        int numLiteralCharacters = commonInitialPunctuation.length() - 1___        for (int index = 0_ index < numLiteralCharacters_ ++index) {_            char ch = commonInitialPunctuation.charAt(index)__            if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.getOrDefault(ch, false)) {_                overallGrokPatternBuilder.append('\\')__            }_            overallGrokPatternBuilder.append(ch)__        }__        return snippets.stream().map(snippet -> snippet.substring(numLiteralCharacters)).collect(Collectors.toList())__    };if,the,snippets,supplied,begin,with,more,than,1,character,of,common,punctuation,or,whitespace,then,add,all,but,the,last,of,these,characters,to,the,overall,pattern,and,remove,them,from,the,snippets,param,snippets,input,snippets,not,modified,return,output,snippets,which,will,be,a,copy,of,the,input,snippets,but,with,whatever,characters,were,added,to,code,overall,pattern,builder,code,removed,from,the,beginning;collection,string,adjust,for,punctuation,collection,string,snippets,assert,snippets,is,empty,false,string,builder,common,initial,punctuation,new,string,builder,for,string,snippet,snippets,if,common,initial,punctuation,length,0,for,int,index,0,index,snippet,length,index,char,ch,snippet,char,at,index,if,get,ch,null,common,initial,punctuation,append,ch,else,break,else,if,common,initial,punctuation,length,snippet,length,common,initial,punctuation,delete,snippet,length,common,initial,punctuation,length,for,int,index,0,index,common,initial,punctuation,length,index,char,ch,snippet,char,at,index,if,ch,common,initial,punctuation,char,at,index,common,initial,punctuation,delete,index,common,initial,punctuation,length,break,if,common,initial,punctuation,length,1,return,snippets,int,num,literal,characters,common,initial,punctuation,length,1,for,int,index,0,index,num,literal,characters,index,char,ch,common,initial,punctuation,char,at,index,if,get,or,default,ch,false,overall,grok,pattern,builder,append,overall,grok,pattern,builder,append,ch,return,snippets,stream,map,snippet,snippet,substring,num,literal,characters,collect,collectors,to,list
GrokPatternCreator -> Collection<String> adjustForPunctuation(Collection<String> snippets);1538170812;If the snippets supplied begin with more than 1 character of common punctuation or whitespace_then add all but the last of these characters to the overall pattern and remove them from the_snippets._@param snippets Input snippets - not modified._@return Output snippets, which will be a copy of the input snippets but with whatever characters_were added to <code>overallPatternBuilder</code> removed from the beginning.;Collection<String> adjustForPunctuation(Collection<String> snippets) {__        assert snippets.isEmpty() == false___        StringBuilder commonInitialPunctuation = new StringBuilder()___        for (String snippet : snippets) {__            if (commonInitialPunctuation.length() == 0) {_                for (int index = 0_ index < snippet.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.get(ch) != null) {_                        commonInitialPunctuation.append(ch)__                    } else {_                        break__                    }_                }_            } else {_                if (commonInitialPunctuation.length() > snippet.length()) {_                    commonInitialPunctuation.delete(snippet.length(), commonInitialPunctuation.length())__                }_                for (int index = 0_ index < commonInitialPunctuation.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (ch != commonInitialPunctuation.charAt(index)) {_                        commonInitialPunctuation.delete(index, commonInitialPunctuation.length())__                        break__                    }_                }_            }__            if (commonInitialPunctuation.length() <= 1) {_                return snippets__            }_        }__        int numLiteralCharacters = commonInitialPunctuation.length() - 1___        for (int index = 0_ index < numLiteralCharacters_ ++index) {_            char ch = commonInitialPunctuation.charAt(index)__            if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.getOrDefault(ch, false)) {_                overallGrokPatternBuilder.append('\\')__            }_            overallGrokPatternBuilder.append(ch)__        }__        return snippets.stream().map(snippet -> snippet.substring(numLiteralCharacters)).collect(Collectors.toList())__    };if,the,snippets,supplied,begin,with,more,than,1,character,of,common,punctuation,or,whitespace,then,add,all,but,the,last,of,these,characters,to,the,overall,pattern,and,remove,them,from,the,snippets,param,snippets,input,snippets,not,modified,return,output,snippets,which,will,be,a,copy,of,the,input,snippets,but,with,whatever,characters,were,added,to,code,overall,pattern,builder,code,removed,from,the,beginning;collection,string,adjust,for,punctuation,collection,string,snippets,assert,snippets,is,empty,false,string,builder,common,initial,punctuation,new,string,builder,for,string,snippet,snippets,if,common,initial,punctuation,length,0,for,int,index,0,index,snippet,length,index,char,ch,snippet,char,at,index,if,get,ch,null,common,initial,punctuation,append,ch,else,break,else,if,common,initial,punctuation,length,snippet,length,common,initial,punctuation,delete,snippet,length,common,initial,punctuation,length,for,int,index,0,index,common,initial,punctuation,length,index,char,ch,snippet,char,at,index,if,ch,common,initial,punctuation,char,at,index,common,initial,punctuation,delete,index,common,initial,punctuation,length,break,if,common,initial,punctuation,length,1,return,snippets,int,num,literal,characters,common,initial,punctuation,length,1,for,int,index,0,index,num,literal,characters,index,char,ch,common,initial,punctuation,char,at,index,if,get,or,default,ch,false,overall,grok,pattern,builder,append,overall,grok,pattern,builder,append,ch,return,snippets,stream,map,snippet,snippet,substring,num,literal,characters,collect,collectors,to,list
GrokPatternCreator -> Collection<String> adjustForPunctuation(Collection<String> snippets);1544771889;If the snippets supplied begin with more than 1 character of common punctuation or whitespace_then add all but the last of these characters to the overall pattern and remove them from the_snippets._@param snippets Input snippets - not modified._@return Output snippets, which will be a copy of the input snippets but with whatever characters_were added to <code>overallPatternBuilder</code> removed from the beginning.;Collection<String> adjustForPunctuation(Collection<String> snippets) {__        assert snippets.isEmpty() == false___        StringBuilder commonInitialPunctuation = new StringBuilder()___        for (String snippet : snippets) {__            if (commonInitialPunctuation.length() == 0) {_                for (int index = 0_ index < snippet.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.get(ch) != null) {_                        commonInitialPunctuation.append(ch)__                    } else {_                        break__                    }_                }_            } else {_                if (commonInitialPunctuation.length() > snippet.length()) {_                    commonInitialPunctuation.delete(snippet.length(), commonInitialPunctuation.length())__                }_                for (int index = 0_ index < commonInitialPunctuation.length()_ ++index) {_                    char ch = snippet.charAt(index)__                    if (ch != commonInitialPunctuation.charAt(index)) {_                        commonInitialPunctuation.delete(index, commonInitialPunctuation.length())__                        break__                    }_                }_            }__            if (commonInitialPunctuation.length() <= 1) {_                return snippets__            }_        }__        int numLiteralCharacters = commonInitialPunctuation.length() - 1___        for (int index = 0_ index < numLiteralCharacters_ ++index) {_            char ch = commonInitialPunctuation.charAt(index)__            if (PUNCTUATION_OR_SPACE_NEEDS_ESCAPING.getOrDefault(ch, false)) {_                overallGrokPatternBuilder.append('\\')__            }_            overallGrokPatternBuilder.append(ch)__        }__        return snippets.stream().map(snippet -> snippet.substring(numLiteralCharacters)).collect(Collectors.toList())__    };if,the,snippets,supplied,begin,with,more,than,1,character,of,common,punctuation,or,whitespace,then,add,all,but,the,last,of,these,characters,to,the,overall,pattern,and,remove,them,from,the,snippets,param,snippets,input,snippets,not,modified,return,output,snippets,which,will,be,a,copy,of,the,input,snippets,but,with,whatever,characters,were,added,to,code,overall,pattern,builder,code,removed,from,the,beginning;collection,string,adjust,for,punctuation,collection,string,snippets,assert,snippets,is,empty,false,string,builder,common,initial,punctuation,new,string,builder,for,string,snippet,snippets,if,common,initial,punctuation,length,0,for,int,index,0,index,snippet,length,index,char,ch,snippet,char,at,index,if,get,ch,null,common,initial,punctuation,append,ch,else,break,else,if,common,initial,punctuation,length,snippet,length,common,initial,punctuation,delete,snippet,length,common,initial,punctuation,length,for,int,index,0,index,common,initial,punctuation,length,index,char,ch,snippet,char,at,index,if,ch,common,initial,punctuation,char,at,index,common,initial,punctuation,delete,index,common,initial,punctuation,length,break,if,common,initial,punctuation,length,1,return,snippets,int,num,literal,characters,common,initial,punctuation,length,1,for,int,index,0,index,num,literal,characters,index,char,ch,common,initial,punctuation,char,at,index,if,get,or,default,ch,false,overall,grok,pattern,builder,append,overall,grok,pattern,builder,append,ch,return,snippets,stream,map,snippet,snippet,substring,num,literal,characters,collect,collectors,to,list
GrokPatternCreator -> public void validateFullLineGrokPattern(String grokPattern, String timestampField);1536964057;This method processes a user-supplied Grok pattern that will match all of the sample messages in their entirety._It will also update mappings and field stats if they are non-<code>null</code>._@param grokPattern The user supplied Grok pattern._@param timestampField The name of the timestamp field within the Grok pattern._@throws IllegalArgumentException If the supplied Grok pattern does not match the sample messages.;public void validateFullLineGrokPattern(String grokPattern, String timestampField) {__        FullMatchGrokPatternCandidate candidate = FullMatchGrokPatternCandidate.fromGrokPattern(grokPattern, timestampField)__        if (candidate.matchesAll(sampleMessages)) {_            candidate.processMatch(explanation, sampleMessages, mappings, fieldStats)__        } else {_            throw new IllegalArgumentException("Supplied Grok pattern [" + grokPattern + "] does not match sample messages")__        }_    };this,method,processes,a,user,supplied,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,it,will,also,update,mappings,and,field,stats,if,they,are,non,code,null,code,param,grok,pattern,the,user,supplied,grok,pattern,param,timestamp,field,the,name,of,the,timestamp,field,within,the,grok,pattern,throws,illegal,argument,exception,if,the,supplied,grok,pattern,does,not,match,the,sample,messages;public,void,validate,full,line,grok,pattern,string,grok,pattern,string,timestamp,field,full,match,grok,pattern,candidate,candidate,full,match,grok,pattern,candidate,from,grok,pattern,grok,pattern,timestamp,field,if,candidate,matches,all,sample,messages,candidate,process,match,explanation,sample,messages,mappings,field,stats,else,throw,new,illegal,argument,exception,supplied,grok,pattern,grok,pattern,does,not,match,sample,messages
GrokPatternCreator -> public void validateFullLineGrokPattern(String grokPattern, String timestampField);1538170812;This method processes a user-supplied Grok pattern that will match all of the sample messages in their entirety._It will also update mappings and field stats if they are non-<code>null</code>._@param grokPattern The user supplied Grok pattern._@param timestampField The name of the timestamp field within the Grok pattern._@throws IllegalArgumentException If the supplied Grok pattern does not match the sample messages.;public void validateFullLineGrokPattern(String grokPattern, String timestampField) {__        FullMatchGrokPatternCandidate candidate = FullMatchGrokPatternCandidate.fromGrokPattern(grokPattern, timestampField)__        if (candidate.matchesAll(sampleMessages, timeoutChecker)) {_            candidate.processMatch(explanation, sampleMessages, mappings, fieldStats, timeoutChecker)__        } else {_            throw new IllegalArgumentException("Supplied Grok pattern [" + grokPattern + "] does not match sample messages")__        }_    };this,method,processes,a,user,supplied,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,it,will,also,update,mappings,and,field,stats,if,they,are,non,code,null,code,param,grok,pattern,the,user,supplied,grok,pattern,param,timestamp,field,the,name,of,the,timestamp,field,within,the,grok,pattern,throws,illegal,argument,exception,if,the,supplied,grok,pattern,does,not,match,the,sample,messages;public,void,validate,full,line,grok,pattern,string,grok,pattern,string,timestamp,field,full,match,grok,pattern,candidate,candidate,full,match,grok,pattern,candidate,from,grok,pattern,grok,pattern,timestamp,field,if,candidate,matches,all,sample,messages,timeout,checker,candidate,process,match,explanation,sample,messages,mappings,field,stats,timeout,checker,else,throw,new,illegal,argument,exception,supplied,grok,pattern,grok,pattern,does,not,match,sample,messages
GrokPatternCreator -> public void validateFullLineGrokPattern(String grokPattern, String timestampField);1544771889;This method processes a user-supplied Grok pattern that will match all of the sample messages in their entirety._It will also update mappings and field stats if they are non-<code>null</code>._@param grokPattern The user supplied Grok pattern._@param timestampField The name of the timestamp field within the Grok pattern._@throws IllegalArgumentException If the supplied Grok pattern does not match the sample messages.;public void validateFullLineGrokPattern(String grokPattern, String timestampField) {__        FullMatchGrokPatternCandidate candidate = FullMatchGrokPatternCandidate.fromGrokPattern(grokPattern, timestampField)__        if (candidate.matchesAll(sampleMessages, timeoutChecker)) {_            candidate.processMatch(explanation, sampleMessages, mappings, fieldStats, timeoutChecker)__        } else {_            throw new IllegalArgumentException("Supplied Grok pattern [" + grokPattern + "] does not match sample messages")__        }_    };this,method,processes,a,user,supplied,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,it,will,also,update,mappings,and,field,stats,if,they,are,non,code,null,code,param,grok,pattern,the,user,supplied,grok,pattern,param,timestamp,field,the,name,of,the,timestamp,field,within,the,grok,pattern,throws,illegal,argument,exception,if,the,supplied,grok,pattern,does,not,match,the,sample,messages;public,void,validate,full,line,grok,pattern,string,grok,pattern,string,timestamp,field,full,match,grok,pattern,candidate,candidate,full,match,grok,pattern,candidate,from,grok,pattern,grok,pattern,timestamp,field,if,candidate,matches,all,sample,messages,timeout,checker,candidate,process,match,explanation,sample,messages,mappings,field,stats,timeout,checker,else,throw,new,illegal,argument,exception,supplied,grok,pattern,grok,pattern,does,not,match,sample,messages
GrokPatternCreator -> GrokPatternCandidate -> String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats,                                TimeoutChecker timeoutChecker)_;1538170812;After it has been determined that this Grok pattern candidate matches a collection of strings,_return collections of the bits that come before (prefaces) and after (epilogues) the bit_that matches.  Also update mappings with the most appropriate field name and type, and_calculate field stats._@return The string that needs to be incorporated into the overall Grok pattern for the line.;String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                               Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats,_                               TimeoutChecker timeoutChecker)_;after,it,has,been,determined,that,this,grok,pattern,candidate,matches,a,collection,of,strings,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches,also,update,mappings,with,the,most,appropriate,field,name,and,type,and,calculate,field,stats,return,the,string,that,needs,to,be,incorporated,into,the,overall,grok,pattern,for,the,line;string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats,timeout,checker,timeout,checker
GrokPatternCreator -> GrokPatternCandidate -> String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats,                                TimeoutChecker timeoutChecker)_;1544771889;After it has been determined that this Grok pattern candidate matches a collection of strings,_return collections of the bits that come before (prefaces) and after (epilogues) the bit_that matches.  Also update mappings with the most appropriate field name and type, and_calculate field stats._@return The string that needs to be incorporated into the overall Grok pattern for the line.;String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                               Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats,_                               TimeoutChecker timeoutChecker)_;after,it,has,been,determined,that,this,grok,pattern,candidate,matches,a,collection,of,strings,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches,also,update,mappings,with,the,most,appropriate,field,name,and,type,and,calculate,field,stats,return,the,string,that,needs,to,be,incorporated,into,the,overall,grok,pattern,for,the,line;string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats,timeout,checker,timeout,checker
GrokPatternCreator -> GrokPatternCandidate -> String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats)_;1536314350;After it has been determined that this Grok pattern candidate matches a collection of strings,_return collections of the bits that come before (prefaces) and after (epilogues) the bit_that matches.  Also update mappings with the most appropriate field name and type, and_calculate field stats._@return The string that needs to be incorporated into the overall Grok pattern for the line.;String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                               Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats)_;after,it,has,been,determined,that,this,grok,pattern,candidate,matches,a,collection,of,strings,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches,also,update,mappings,with,the,most,appropriate,field,name,and,type,and,calculate,field,stats,return,the,string,that,needs,to,be,incorporated,into,the,overall,grok,pattern,for,the,line;string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats
GrokPatternCreator -> GrokPatternCandidate -> String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats)_;1536611444;After it has been determined that this Grok pattern candidate matches a collection of strings,_return collections of the bits that come before (prefaces) and after (epilogues) the bit_that matches.  Also update mappings with the most appropriate field name and type, and_calculate field stats._@return The string that needs to be incorporated into the overall Grok pattern for the line.;String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                               Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats)_;after,it,has,been,determined,that,this,grok,pattern,candidate,matches,a,collection,of,strings,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches,also,update,mappings,with,the,most,appropriate,field,name,and,type,and,calculate,field,stats,return,the,string,that,needs,to,be,incorporated,into,the,overall,grok,pattern,for,the,line;string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats
GrokPatternCreator -> GrokPatternCandidate -> String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats)_;1536964057;After it has been determined that this Grok pattern candidate matches a collection of strings,_return collections of the bits that come before (prefaces) and after (epilogues) the bit_that matches.  Also update mappings with the most appropriate field name and type, and_calculate field stats._@return The string that needs to be incorporated into the overall Grok pattern for the line.;String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                               Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats)_;after,it,has,been,determined,that,this,grok,pattern,candidate,matches,a,collection,of,strings,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches,also,update,mappings,with,the,most,appropriate,field,name,and,type,and,calculate,field,stats,return,the,string,that,needs,to,be,incorporated,into,the,overall,grok,pattern,for,the,line;string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats
GrokPatternCreator -> static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName);1536314350;The first time a particular field name is passed, simply return it._The second time return it with "2" appended._The third time return it with "3" appended._Etc.;static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {_        Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v))__        return (numberSeen > 1) ? fieldName + numberSeen : fieldName__    };the,first,time,a,particular,field,name,is,passed,simply,return,it,the,second,time,return,it,with,2,appended,the,third,time,return,it,with,3,appended,etc;static,string,build,field,name,map,string,integer,field,name,count,store,string,field,name,integer,number,seen,field,name,count,store,compute,field,name,k,v,1,v,null,0,v,return,number,seen,1,field,name,number,seen,field,name
GrokPatternCreator -> static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName);1536611444;The first time a particular field name is passed, simply return it._The second time return it with "2" appended._The third time return it with "3" appended._Etc.;static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {_        Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v))__        return (numberSeen > 1) ? fieldName + numberSeen : fieldName__    };the,first,time,a,particular,field,name,is,passed,simply,return,it,the,second,time,return,it,with,2,appended,the,third,time,return,it,with,3,appended,etc;static,string,build,field,name,map,string,integer,field,name,count,store,string,field,name,integer,number,seen,field,name,count,store,compute,field,name,k,v,1,v,null,0,v,return,number,seen,1,field,name,number,seen,field,name
GrokPatternCreator -> static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName);1536964057;The first time a particular field name is passed, simply return it._The second time return it with "2" appended._The third time return it with "3" appended._Etc.;static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {_        Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v))__        return (numberSeen > 1) ? fieldName + numberSeen : fieldName__    };the,first,time,a,particular,field,name,is,passed,simply,return,it,the,second,time,return,it,with,2,appended,the,third,time,return,it,with,3,appended,etc;static,string,build,field,name,map,string,integer,field,name,count,store,string,field,name,integer,number,seen,field,name,count,store,compute,field,name,k,v,1,v,null,0,v,return,number,seen,1,field,name,number,seen,field,name
GrokPatternCreator -> static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName);1538170812;The first time a particular field name is passed, simply return it._The second time return it with "2" appended._The third time return it with "3" appended._Etc.;static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {_        Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v))__        return (numberSeen > 1) ? fieldName + numberSeen : fieldName__    };the,first,time,a,particular,field,name,is,passed,simply,return,it,the,second,time,return,it,with,2,appended,the,third,time,return,it,with,3,appended,etc;static,string,build,field,name,map,string,integer,field,name,count,store,string,field,name,integer,number,seen,field,name,count,store,compute,field,name,k,v,1,v,null,0,v,return,number,seen,1,field,name,number,seen,field,name
GrokPatternCreator -> static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName);1544771889;The first time a particular field name is passed, simply return it._The second time return it with "2" appended._The third time return it with "3" appended._Etc.;static String buildFieldName(Map<String, Integer> fieldNameCountStore, String fieldName) {_        Integer numberSeen = fieldNameCountStore.compute(fieldName, (k, v) -> 1 + ((v == null) ? 0 : v))__        return (numberSeen > 1) ? fieldName + numberSeen : fieldName__    };the,first,time,a,particular,field,name,is,passed,simply,return,it,the,second,time,return,it,with,2,appended,the,third,time,return,it,with,3,appended,etc;static,string,build,field,name,map,string,integer,field,name,count,store,string,field,name,integer,number,seen,field,name,count,store,compute,field,name,k,v,1,v,null,0,v,return,number,seen,1,field,name,number,seen,field,name
GrokPatternCreator -> StringBuilder getOverallGrokPatternBuilder();1536314350;This is purely to allow unit tests to inspect the partial Grok pattern after testing implementation details._It should not be used in production code.;StringBuilder getOverallGrokPatternBuilder() {_        return overallGrokPatternBuilder__    };this,is,purely,to,allow,unit,tests,to,inspect,the,partial,grok,pattern,after,testing,implementation,details,it,should,not,be,used,in,production,code;string,builder,get,overall,grok,pattern,builder,return,overall,grok,pattern,builder
GrokPatternCreator -> StringBuilder getOverallGrokPatternBuilder();1536611444;This is purely to allow unit tests to inspect the partial Grok pattern after testing implementation details._It should not be used in production code.;StringBuilder getOverallGrokPatternBuilder() {_        return overallGrokPatternBuilder__    };this,is,purely,to,allow,unit,tests,to,inspect,the,partial,grok,pattern,after,testing,implementation,details,it,should,not,be,used,in,production,code;string,builder,get,overall,grok,pattern,builder,return,overall,grok,pattern,builder
GrokPatternCreator -> StringBuilder getOverallGrokPatternBuilder();1536964057;This is purely to allow unit tests to inspect the partial Grok pattern after testing implementation details._It should not be used in production code.;StringBuilder getOverallGrokPatternBuilder() {_        return overallGrokPatternBuilder__    };this,is,purely,to,allow,unit,tests,to,inspect,the,partial,grok,pattern,after,testing,implementation,details,it,should,not,be,used,in,production,code;string,builder,get,overall,grok,pattern,builder,return,overall,grok,pattern,builder
GrokPatternCreator -> StringBuilder getOverallGrokPatternBuilder();1538170812;This is purely to allow unit tests to inspect the partial Grok pattern after testing implementation details._It should not be used in production code.;StringBuilder getOverallGrokPatternBuilder() {_        return overallGrokPatternBuilder__    };this,is,purely,to,allow,unit,tests,to,inspect,the,partial,grok,pattern,after,testing,implementation,details,it,should,not,be,used,in,production,code;string,builder,get,overall,grok,pattern,builder,return,overall,grok,pattern,builder
GrokPatternCreator -> StringBuilder getOverallGrokPatternBuilder();1544771889;This is purely to allow unit tests to inspect the partial Grok pattern after testing implementation details._It should not be used in production code.;StringBuilder getOverallGrokPatternBuilder() {_        return overallGrokPatternBuilder__    };this,is,purely,to,allow,unit,tests,to,inspect,the,partial,grok,pattern,after,testing,implementation,details,it,should,not,be,used,in,production,code;string,builder,get,overall,grok,pattern,builder,return,overall,grok,pattern,builder
GrokPatternCreator -> GrokPatternCandidate -> boolean matchesAll(Collection<String> snippets)_;1536314350;@return Does this Grok pattern candidate match all the snippets?;boolean matchesAll(Collection<String> snippets)_;return,does,this,grok,pattern,candidate,match,all,the,snippets;boolean,matches,all,collection,string,snippets
GrokPatternCreator -> GrokPatternCandidate -> boolean matchesAll(Collection<String> snippets)_;1536611444;@return Does this Grok pattern candidate match all the snippets?;boolean matchesAll(Collection<String> snippets)_;return,does,this,grok,pattern,candidate,match,all,the,snippets;boolean,matches,all,collection,string,snippets
GrokPatternCreator -> GrokPatternCandidate -> boolean matchesAll(Collection<String> snippets)_;1536964057;@return Does this Grok pattern candidate match all the snippets?;boolean matchesAll(Collection<String> snippets)_;return,does,this,grok,pattern,candidate,match,all,the,snippets;boolean,matches,all,collection,string,snippets
GrokPatternCreator -> GrokPatternCandidate -> boolean matchesAll(Collection<String> snippets)_;1538170812;@return Does this Grok pattern candidate match all the snippets?;boolean matchesAll(Collection<String> snippets)_;return,does,this,grok,pattern,candidate,match,all,the,snippets;boolean,matches,all,collection,string,snippets
GrokPatternCreator -> GrokPatternCandidate -> boolean matchesAll(Collection<String> snippets)_;1544771889;@return Does this Grok pattern candidate match all the snippets?;boolean matchesAll(Collection<String> snippets)_;return,does,this,grok,pattern,candidate,match,all,the,snippets;boolean,matches,all,collection,string,snippets
GrokPatternCreator -> public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName);1536314350;Build a Grok pattern that will match all of the sample messages in their entirety._@param seedPatternName A pattern that has already been determined to match some portion of every sample message._@param seedFieldName The field name to be used for the portion of every sample message that the seed pattern matches._@return The built Grok pattern.;public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName) {__        overallGrokPatternBuilder.setLength(0)___        GrokPatternCandidate seedCandidate = new NoMappingGrokPatternCandidate(seedPatternName, seedFieldName)___        processCandidateAndSplit(seedCandidate, true, sampleMessages, false, 0, false, 0)___        return overallGrokPatternBuilder.toString().replace("\t", "\\t").replace("\n", "\\n")__    };build,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,param,seed,pattern,name,a,pattern,that,has,already,been,determined,to,match,some,portion,of,every,sample,message,param,seed,field,name,the,field,name,to,be,used,for,the,portion,of,every,sample,message,that,the,seed,pattern,matches,return,the,built,grok,pattern;public,string,create,grok,pattern,from,examples,string,seed,pattern,name,string,seed,field,name,overall,grok,pattern,builder,set,length,0,grok,pattern,candidate,seed,candidate,new,no,mapping,grok,pattern,candidate,seed,pattern,name,seed,field,name,process,candidate,and,split,seed,candidate,true,sample,messages,false,0,false,0,return,overall,grok,pattern,builder,to,string,replace,t,t,replace,n,n
GrokPatternCreator -> public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName);1536611444;Build a Grok pattern that will match all of the sample messages in their entirety._@param seedPatternName A pattern that has already been determined to match some portion of every sample message._@param seedFieldName The field name to be used for the portion of every sample message that the seed pattern matches._@return The built Grok pattern.;public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName) {__        overallGrokPatternBuilder.setLength(0)___        GrokPatternCandidate seedCandidate = new NoMappingGrokPatternCandidate(seedPatternName, seedFieldName)___        processCandidateAndSplit(seedCandidate, true, sampleMessages, false, 0, false, 0)___        return overallGrokPatternBuilder.toString().replace("\t", "\\t").replace("\n", "\\n")__    };build,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,param,seed,pattern,name,a,pattern,that,has,already,been,determined,to,match,some,portion,of,every,sample,message,param,seed,field,name,the,field,name,to,be,used,for,the,portion,of,every,sample,message,that,the,seed,pattern,matches,return,the,built,grok,pattern;public,string,create,grok,pattern,from,examples,string,seed,pattern,name,string,seed,field,name,overall,grok,pattern,builder,set,length,0,grok,pattern,candidate,seed,candidate,new,no,mapping,grok,pattern,candidate,seed,pattern,name,seed,field,name,process,candidate,and,split,seed,candidate,true,sample,messages,false,0,false,0,return,overall,grok,pattern,builder,to,string,replace,t,t,replace,n,n
GrokPatternCreator -> public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName);1536964057;Build a Grok pattern that will match all of the sample messages in their entirety._@param seedPatternName A pattern that has already been determined to match some portion of every sample message._@param seedFieldName The field name to be used for the portion of every sample message that the seed pattern matches._@return The built Grok pattern.;public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName) {__        overallGrokPatternBuilder.setLength(0)___        GrokPatternCandidate seedCandidate = new NoMappingGrokPatternCandidate(seedPatternName, seedFieldName)___        processCandidateAndSplit(seedCandidate, true, sampleMessages, false, 0, false, 0)___        return overallGrokPatternBuilder.toString().replace("\t", "\\t").replace("\n", "\\n")__    };build,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,param,seed,pattern,name,a,pattern,that,has,already,been,determined,to,match,some,portion,of,every,sample,message,param,seed,field,name,the,field,name,to,be,used,for,the,portion,of,every,sample,message,that,the,seed,pattern,matches,return,the,built,grok,pattern;public,string,create,grok,pattern,from,examples,string,seed,pattern,name,string,seed,field,name,overall,grok,pattern,builder,set,length,0,grok,pattern,candidate,seed,candidate,new,no,mapping,grok,pattern,candidate,seed,pattern,name,seed,field,name,process,candidate,and,split,seed,candidate,true,sample,messages,false,0,false,0,return,overall,grok,pattern,builder,to,string,replace,t,t,replace,n,n
GrokPatternCreator -> public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName);1538170812;Build a Grok pattern that will match all of the sample messages in their entirety._@param seedPatternName A pattern that has already been determined to match some portion of every sample message._@param seedFieldName The field name to be used for the portion of every sample message that the seed pattern matches._@return The built Grok pattern.;public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName) {__        overallGrokPatternBuilder.setLength(0)___        GrokPatternCandidate seedCandidate = new NoMappingGrokPatternCandidate(seedPatternName, seedFieldName)___        processCandidateAndSplit(seedCandidate, true, sampleMessages, false, 0, false, 0)___        return overallGrokPatternBuilder.toString().replace("\t", "\\t").replace("\n", "\\n")__    };build,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,param,seed,pattern,name,a,pattern,that,has,already,been,determined,to,match,some,portion,of,every,sample,message,param,seed,field,name,the,field,name,to,be,used,for,the,portion,of,every,sample,message,that,the,seed,pattern,matches,return,the,built,grok,pattern;public,string,create,grok,pattern,from,examples,string,seed,pattern,name,string,seed,field,name,overall,grok,pattern,builder,set,length,0,grok,pattern,candidate,seed,candidate,new,no,mapping,grok,pattern,candidate,seed,pattern,name,seed,field,name,process,candidate,and,split,seed,candidate,true,sample,messages,false,0,false,0,return,overall,grok,pattern,builder,to,string,replace,t,t,replace,n,n
GrokPatternCreator -> public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName);1544771889;Build a Grok pattern that will match all of the sample messages in their entirety._@param seedPatternName A pattern that has already been determined to match some portion of every sample message._@param seedFieldName The field name to be used for the portion of every sample message that the seed pattern matches._@return The built Grok pattern.;public String createGrokPatternFromExamples(String seedPatternName, String seedFieldName) {__        overallGrokPatternBuilder.setLength(0)___        GrokPatternCandidate seedCandidate = new NoMappingGrokPatternCandidate(seedPatternName, seedFieldName)___        processCandidateAndSplit(seedCandidate, true, sampleMessages, false, 0, false, 0)___        return overallGrokPatternBuilder.toString().replace("\t", "\\t").replace("\n", "\\n")__    };build,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,param,seed,pattern,name,a,pattern,that,has,already,been,determined,to,match,some,portion,of,every,sample,message,param,seed,field,name,the,field,name,to,be,used,for,the,portion,of,every,sample,message,that,the,seed,pattern,matches,return,the,built,grok,pattern;public,string,create,grok,pattern,from,examples,string,seed,pattern,name,string,seed,field,name,overall,grok,pattern,builder,set,length,0,grok,pattern,candidate,seed,candidate,new,no,mapping,grok,pattern,candidate,seed,pattern,name,seed,field,name,process,candidate,and,split,seed,candidate,true,sample,messages,false,0,false,0,return,overall,grok,pattern,builder,to,string,replace,t,t,replace,n,n
GrokPatternCreator -> public Tuple<String, String> findFullLineGrokPattern(String timestampField);1536964057;This method attempts to find a Grok pattern that will match all of the sample messages in their entirety._It will also update mappings and field stats if they are non-<code>null</code>._@param timestampField If not <code>null</code> then the chosen Grok pattern must use this timestamp field._@return A tuple of (time field name, Grok string), or <code>null</code> if no suitable Grok pattern was found.;public Tuple<String, String> findFullLineGrokPattern(String timestampField) {__        for (FullMatchGrokPatternCandidate candidate : FULL_MATCH_GROK_PATTERNS) {_            if (timestampField == null || timestampField.equals(candidate.getTimeField())) {_                if (candidate.matchesAll(sampleMessages)) {_                    return candidate.processMatch(explanation, sampleMessages, mappings, fieldStats)__                }_            }_        }__        return null__    };this,method,attempts,to,find,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,it,will,also,update,mappings,and,field,stats,if,they,are,non,code,null,code,param,timestamp,field,if,not,code,null,code,then,the,chosen,grok,pattern,must,use,this,timestamp,field,return,a,tuple,of,time,field,name,grok,string,or,code,null,code,if,no,suitable,grok,pattern,was,found;public,tuple,string,string,find,full,line,grok,pattern,string,timestamp,field,for,full,match,grok,pattern,candidate,candidate,if,timestamp,field,null,timestamp,field,equals,candidate,get,time,field,if,candidate,matches,all,sample,messages,return,candidate,process,match,explanation,sample,messages,mappings,field,stats,return,null
GrokPatternCreator -> public Tuple<String, String> findFullLineGrokPattern(String timestampField);1538170812;This method attempts to find a Grok pattern that will match all of the sample messages in their entirety._It will also update mappings and field stats if they are non-<code>null</code>._@param timestampField If not <code>null</code> then the chosen Grok pattern must use this timestamp field._@return A tuple of (time field name, Grok string), or <code>null</code> if no suitable Grok pattern was found.;public Tuple<String, String> findFullLineGrokPattern(String timestampField) {__        for (FullMatchGrokPatternCandidate candidate : FULL_MATCH_GROK_PATTERNS) {_            if (timestampField == null || timestampField.equals(candidate.getTimeField())) {_                if (candidate.matchesAll(sampleMessages, timeoutChecker)) {_                    return candidate.processMatch(explanation, sampleMessages, mappings, fieldStats, timeoutChecker)__                }_            }_        }__        return null__    };this,method,attempts,to,find,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,it,will,also,update,mappings,and,field,stats,if,they,are,non,code,null,code,param,timestamp,field,if,not,code,null,code,then,the,chosen,grok,pattern,must,use,this,timestamp,field,return,a,tuple,of,time,field,name,grok,string,or,code,null,code,if,no,suitable,grok,pattern,was,found;public,tuple,string,string,find,full,line,grok,pattern,string,timestamp,field,for,full,match,grok,pattern,candidate,candidate,if,timestamp,field,null,timestamp,field,equals,candidate,get,time,field,if,candidate,matches,all,sample,messages,timeout,checker,return,candidate,process,match,explanation,sample,messages,mappings,field,stats,timeout,checker,return,null
GrokPatternCreator -> public Tuple<String, String> findFullLineGrokPattern(String timestampField);1544771889;This method attempts to find a Grok pattern that will match all of the sample messages in their entirety._It will also update mappings and field stats if they are non-<code>null</code>._@param timestampField If not <code>null</code> then the chosen Grok pattern must use this timestamp field._@return A tuple of (time field name, Grok string), or <code>null</code> if no suitable Grok pattern was found.;public Tuple<String, String> findFullLineGrokPattern(String timestampField) {__        for (FullMatchGrokPatternCandidate candidate : FULL_MATCH_GROK_PATTERNS) {_            if (timestampField == null || timestampField.equals(candidate.getTimeField())) {_                if (candidate.matchesAll(sampleMessages, timeoutChecker)) {_                    return candidate.processMatch(explanation, sampleMessages, mappings, fieldStats, timeoutChecker)__                }_            }_        }__        return null__    };this,method,attempts,to,find,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,it,will,also,update,mappings,and,field,stats,if,they,are,non,code,null,code,param,timestamp,field,if,not,code,null,code,then,the,chosen,grok,pattern,must,use,this,timestamp,field,return,a,tuple,of,time,field,name,grok,string,or,code,null,code,if,no,suitable,grok,pattern,was,found;public,tuple,string,string,find,full,line,grok,pattern,string,timestamp,field,for,full,match,grok,pattern,candidate,candidate,if,timestamp,field,null,timestamp,field,equals,candidate,get,time,field,if,candidate,matches,all,sample,messages,timeout,checker,return,candidate,process,match,explanation,sample,messages,mappings,field,stats,timeout,checker,return,null
GrokPatternCreator -> public Tuple<String, String> findFullLineGrokPattern();1536314350;This method attempts to find a Grok pattern that will match all of the sample messages in their entirety._It will also update mappings and field stats if they are non-<code>null</code>._@return A tuple of (time field name, Grok string), or <code>null</code> if no suitable Grok pattern was found.;public Tuple<String, String> findFullLineGrokPattern() {__        for (FullMatchGrokPatternCandidate candidate : FULL_MATCH_GROK_PATTERNS) {_            if (candidate.matchesAll(sampleMessages)) {_                return candidate.processMatch(explanation, sampleMessages, mappings, fieldStats)__            }_        }__        return null__    };this,method,attempts,to,find,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,it,will,also,update,mappings,and,field,stats,if,they,are,non,code,null,code,return,a,tuple,of,time,field,name,grok,string,or,code,null,code,if,no,suitable,grok,pattern,was,found;public,tuple,string,string,find,full,line,grok,pattern,for,full,match,grok,pattern,candidate,candidate,if,candidate,matches,all,sample,messages,return,candidate,process,match,explanation,sample,messages,mappings,field,stats,return,null
GrokPatternCreator -> public Tuple<String, String> findFullLineGrokPattern();1536611444;This method attempts to find a Grok pattern that will match all of the sample messages in their entirety._It will also update mappings and field stats if they are non-<code>null</code>._@return A tuple of (time field name, Grok string), or <code>null</code> if no suitable Grok pattern was found.;public Tuple<String, String> findFullLineGrokPattern() {__        for (FullMatchGrokPatternCandidate candidate : FULL_MATCH_GROK_PATTERNS) {_            if (candidate.matchesAll(sampleMessages)) {_                return candidate.processMatch(explanation, sampleMessages, mappings, fieldStats)__            }_        }__        return null__    };this,method,attempts,to,find,a,grok,pattern,that,will,match,all,of,the,sample,messages,in,their,entirety,it,will,also,update,mappings,and,field,stats,if,they,are,non,code,null,code,return,a,tuple,of,time,field,name,grok,string,or,code,null,code,if,no,suitable,grok,pattern,was,found;public,tuple,string,string,find,full,line,grok,pattern,for,full,match,grok,pattern,candidate,candidate,if,candidate,matches,all,sample,messages,return,candidate,process,match,explanation,sample,messages,mappings,field,stats,return,null
GrokPatternCreator -> FullMatchGrokPatternCandidate -> public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages,                                                   Map<String, Object> mappings, Map<String, FieldStats> fieldStats);1536314350;This must only be called if {@link #matchesAll} returns <code>true</code>._@return A tuple of (time field name, Grok string).;public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages,_                                                  Map<String, Object> mappings, Map<String, FieldStats> fieldStats) {__            explanation.add("A full message Grok pattern [" + grokString.substring(2, grokString.length() - 1) + "] looks appropriate")___            if (mappings != null || fieldStats != null) {_                Map<String, Collection<String>> valuesPerField = new HashMap<>()___                for (String sampleMessage : sampleMessages) {_                    Map<String, Object> captures = grok.captures(sampleMessage)__                    _                    if (captures == null) {_                        throw new IllegalStateException("[" + grokString + "] does not match snippet [" + sampleMessage + "]")__                    }_                    for (Map.Entry<String, Object> capture : captures.entrySet()) {__                        String fieldName = capture.getKey()__                        String fieldValue = capture.getValue().toString()___                        _                        if (fieldName.equals(timeField) == false) {_                            valuesPerField.compute(fieldName, (k, v) -> {_                                if (v == null) {_                                    return new ArrayList<>(Collections.singletonList(fieldValue))__                                } else {_                                    v.add(fieldValue)__                                    return v__                                }_                            })__                        }_                    }_                }__                for (Map.Entry<String, Collection<String>> valuesForField : valuesPerField.entrySet()) {_                    String fieldName = valuesForField.getKey()__                    if (mappings != null) {_                        mappings.put(fieldName,_                            FileStructureUtils.guessScalarMapping(explanation, fieldName, valuesForField.getValue()))__                    }_                    if (fieldStats != null) {_                        fieldStats.put(fieldName,_                            FileStructureUtils.calculateFieldStats(valuesForField.getValue()))__                    }_                }_            }__            return new Tuple<>(timeField, grokString)__        };this,must,only,be,called,if,link,matches,all,returns,code,true,code,return,a,tuple,of,time,field,name,grok,string;public,tuple,string,string,process,match,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,explanation,add,a,full,message,grok,pattern,grok,string,substring,2,grok,string,length,1,looks,appropriate,if,mappings,null,field,stats,null,map,string,collection,string,values,per,field,new,hash,map,for,string,sample,message,sample,messages,map,string,object,captures,grok,captures,sample,message,if,captures,null,throw,new,illegal,state,exception,grok,string,does,not,match,snippet,sample,message,for,map,entry,string,object,capture,captures,entry,set,string,field,name,capture,get,key,string,field,value,capture,get,value,to,string,if,field,name,equals,time,field,false,values,per,field,compute,field,name,k,v,if,v,null,return,new,array,list,collections,singleton,list,field,value,else,v,add,field,value,return,v,for,map,entry,string,collection,string,values,for,field,values,per,field,entry,set,string,field,name,values,for,field,get,key,if,mappings,null,mappings,put,field,name,file,structure,utils,guess,scalar,mapping,explanation,field,name,values,for,field,get,value,if,field,stats,null,field,stats,put,field,name,file,structure,utils,calculate,field,stats,values,for,field,get,value,return,new,tuple,time,field,grok,string
GrokPatternCreator -> FullMatchGrokPatternCandidate -> public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages,                                                   Map<String, Object> mappings, Map<String, FieldStats> fieldStats);1536611444;This must only be called if {@link #matchesAll} returns <code>true</code>._@return A tuple of (time field name, Grok string).;public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages,_                                                  Map<String, Object> mappings, Map<String, FieldStats> fieldStats) {__            explanation.add("A full message Grok pattern [" + grokString.substring(2, grokString.length() - 1) + "] looks appropriate")___            if (mappings != null || fieldStats != null) {_                Map<String, Collection<String>> valuesPerField = new HashMap<>()___                for (String sampleMessage : sampleMessages) {_                    Map<String, Object> captures = grok.captures(sampleMessage)__                    _                    if (captures == null) {_                        throw new IllegalStateException("[" + grokString + "] does not match snippet [" + sampleMessage + "]")__                    }_                    for (Map.Entry<String, Object> capture : captures.entrySet()) {__                        String fieldName = capture.getKey()__                        String fieldValue = capture.getValue().toString()___                        _                        if (fieldName.equals(timeField) == false) {_                            valuesPerField.compute(fieldName, (k, v) -> {_                                if (v == null) {_                                    return new ArrayList<>(Collections.singletonList(fieldValue))__                                } else {_                                    v.add(fieldValue)__                                    return v__                                }_                            })__                        }_                    }_                }__                for (Map.Entry<String, Collection<String>> valuesForField : valuesPerField.entrySet()) {_                    String fieldName = valuesForField.getKey()__                    if (mappings != null) {_                        mappings.put(fieldName,_                            FileStructureUtils.guessScalarMapping(explanation, fieldName, valuesForField.getValue()))__                    }_                    if (fieldStats != null) {_                        fieldStats.put(fieldName,_                            FileStructureUtils.calculateFieldStats(valuesForField.getValue()))__                    }_                }_            }__            return new Tuple<>(timeField, grokString)__        };this,must,only,be,called,if,link,matches,all,returns,code,true,code,return,a,tuple,of,time,field,name,grok,string;public,tuple,string,string,process,match,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,explanation,add,a,full,message,grok,pattern,grok,string,substring,2,grok,string,length,1,looks,appropriate,if,mappings,null,field,stats,null,map,string,collection,string,values,per,field,new,hash,map,for,string,sample,message,sample,messages,map,string,object,captures,grok,captures,sample,message,if,captures,null,throw,new,illegal,state,exception,grok,string,does,not,match,snippet,sample,message,for,map,entry,string,object,capture,captures,entry,set,string,field,name,capture,get,key,string,field,value,capture,get,value,to,string,if,field,name,equals,time,field,false,values,per,field,compute,field,name,k,v,if,v,null,return,new,array,list,collections,singleton,list,field,value,else,v,add,field,value,return,v,for,map,entry,string,collection,string,values,for,field,values,per,field,entry,set,string,field,name,values,for,field,get,key,if,mappings,null,mappings,put,field,name,file,structure,utils,guess,scalar,mapping,explanation,field,name,values,for,field,get,value,if,field,stats,null,field,stats,put,field,name,file,structure,utils,calculate,field,stats,values,for,field,get,value,return,new,tuple,time,field,grok,string
GrokPatternCreator -> FullMatchGrokPatternCandidate -> public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages,                                                   Map<String, Object> mappings, Map<String, FieldStats> fieldStats);1536964057;This must only be called if {@link #matchesAll} returns <code>true</code>._@return A tuple of (time field name, Grok string).;public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages,_                                                  Map<String, Object> mappings, Map<String, FieldStats> fieldStats) {__            explanation.add("A full message Grok pattern [" + grokPattern.substring(2, grokPattern.length() - 1) + "] looks appropriate")___            if (mappings != null || fieldStats != null) {_                Map<String, Collection<String>> valuesPerField = new HashMap<>()___                for (String sampleMessage : sampleMessages) {_                    Map<String, Object> captures = grok.captures(sampleMessage)__                    _                    if (captures == null) {_                        throw new IllegalStateException("[" + grokPattern + "] does not match snippet [" + sampleMessage + "]")__                    }_                    for (Map.Entry<String, Object> capture : captures.entrySet()) {__                        String fieldName = capture.getKey()__                        String fieldValue = capture.getValue().toString()__                        valuesPerField.compute(fieldName, (k, v) -> {_                            if (v == null) {_                                return new ArrayList<>(Collections.singletonList(fieldValue))__                            } else {_                                v.add(fieldValue)__                                return v__                            }_                        })__                    }_                }__                for (Map.Entry<String, Collection<String>> valuesForField : valuesPerField.entrySet()) {_                    String fieldName = valuesForField.getKey()__                    if (mappings != null) {_                        _                        if (fieldName.equals(timeField) == false) {_                            mappings.put(fieldName,_                                FileStructureUtils.guessScalarMapping(explanation, fieldName, valuesForField.getValue()))__                        }_                    }_                    if (fieldStats != null) {_                        fieldStats.put(fieldName, FileStructureUtils.calculateFieldStats(valuesForField.getValue()))__                    }_                }_            }__            return new Tuple<>(timeField, grokPattern)__        };this,must,only,be,called,if,link,matches,all,returns,code,true,code,return,a,tuple,of,time,field,name,grok,string;public,tuple,string,string,process,match,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,explanation,add,a,full,message,grok,pattern,grok,pattern,substring,2,grok,pattern,length,1,looks,appropriate,if,mappings,null,field,stats,null,map,string,collection,string,values,per,field,new,hash,map,for,string,sample,message,sample,messages,map,string,object,captures,grok,captures,sample,message,if,captures,null,throw,new,illegal,state,exception,grok,pattern,does,not,match,snippet,sample,message,for,map,entry,string,object,capture,captures,entry,set,string,field,name,capture,get,key,string,field,value,capture,get,value,to,string,values,per,field,compute,field,name,k,v,if,v,null,return,new,array,list,collections,singleton,list,field,value,else,v,add,field,value,return,v,for,map,entry,string,collection,string,values,for,field,values,per,field,entry,set,string,field,name,values,for,field,get,key,if,mappings,null,if,field,name,equals,time,field,false,mappings,put,field,name,file,structure,utils,guess,scalar,mapping,explanation,field,name,values,for,field,get,value,if,field,stats,null,field,stats,put,field,name,file,structure,utils,calculate,field,stats,values,for,field,get,value,return,new,tuple,time,field,grok,pattern
GrokPatternCreator -> public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,                               Map<String, FieldStats> fieldStats);1536314350;@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by the methods of this class._@param sampleMessages Sample messages that any Grok pattern found must match._@param mappings Will be updated with mappings appropriate for the returned pattern, if non-<code>null</code>._@param fieldStats Will be updated with field stats for the fields in the returned pattern, if non-<code>null</code>.;public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,_                              Map<String, FieldStats> fieldStats) {_        this.explanation = explanation__        this.sampleMessages = Collections.unmodifiableCollection(sampleMessages)__        this.mappings = mappings__        this.fieldStats = fieldStats__    };param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,the,methods,of,this,class,param,sample,messages,sample,messages,that,any,grok,pattern,found,must,match,param,mappings,will,be,updated,with,mappings,appropriate,for,the,returned,pattern,if,non,code,null,code,param,field,stats,will,be,updated,with,field,stats,for,the,fields,in,the,returned,pattern,if,non,code,null,code;public,grok,pattern,creator,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,this,explanation,explanation,this,sample,messages,collections,unmodifiable,collection,sample,messages,this,mappings,mappings,this,field,stats,field,stats
GrokPatternCreator -> public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,                               Map<String, FieldStats> fieldStats);1536611444;@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by the methods of this class._@param sampleMessages Sample messages that any Grok pattern found must match._@param mappings Will be updated with mappings appropriate for the returned pattern, if non-<code>null</code>._@param fieldStats Will be updated with field stats for the fields in the returned pattern, if non-<code>null</code>.;public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,_                              Map<String, FieldStats> fieldStats) {_        this.explanation = explanation__        this.sampleMessages = Collections.unmodifiableCollection(sampleMessages)__        this.mappings = mappings__        this.fieldStats = fieldStats__    };param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,the,methods,of,this,class,param,sample,messages,sample,messages,that,any,grok,pattern,found,must,match,param,mappings,will,be,updated,with,mappings,appropriate,for,the,returned,pattern,if,non,code,null,code,param,field,stats,will,be,updated,with,field,stats,for,the,fields,in,the,returned,pattern,if,non,code,null,code;public,grok,pattern,creator,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,this,explanation,explanation,this,sample,messages,collections,unmodifiable,collection,sample,messages,this,mappings,mappings,this,field,stats,field,stats
GrokPatternCreator -> public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,                               Map<String, FieldStats> fieldStats);1536964057;@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by the methods of this class._@param sampleMessages Sample messages that any Grok pattern found must match._@param mappings Will be updated with mappings appropriate for the returned pattern, if non-<code>null</code>._@param fieldStats Will be updated with field stats for the fields in the returned pattern, if non-<code>null</code>.;public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,_                              Map<String, FieldStats> fieldStats) {_        this.explanation = explanation__        this.sampleMessages = Collections.unmodifiableCollection(sampleMessages)__        this.mappings = mappings__        this.fieldStats = fieldStats__    };param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,the,methods,of,this,class,param,sample,messages,sample,messages,that,any,grok,pattern,found,must,match,param,mappings,will,be,updated,with,mappings,appropriate,for,the,returned,pattern,if,non,code,null,code,param,field,stats,will,be,updated,with,field,stats,for,the,fields,in,the,returned,pattern,if,non,code,null,code;public,grok,pattern,creator,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,this,explanation,explanation,this,sample,messages,collections,unmodifiable,collection,sample,messages,this,mappings,mappings,this,field,stats,field,stats
GrokPatternCreator -> FullMatchGrokPatternCandidate -> public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,                                                   Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker);1538170812;This must only be called if {@link #matchesAll} returns <code>true</code>._@return A tuple of (time field name, Grok string).;public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,_                                                  Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker) {__            explanation.add("A full message Grok pattern [" + grokPattern.substring(2, grokPattern.length() - 1) + "] looks appropriate")___            if (mappings != null || fieldStats != null) {_                Map<String, Collection<String>> valuesPerField = new HashMap<>()___                for (String sampleMessage : sampleMessages) {_                    Map<String, Object> captures = grok.captures(sampleMessage)__                    _                    if (captures == null) {_                        throw new IllegalStateException("[" + grokPattern + "] does not match snippet [" + sampleMessage + "]")__                    }_                    for (Map.Entry<String, Object> capture : captures.entrySet()) {__                        String fieldName = capture.getKey()__                        String fieldValue = capture.getValue().toString()__                        valuesPerField.compute(fieldName, (k, v) -> {_                            if (v == null) {_                                return new ArrayList<>(Collections.singletonList(fieldValue))__                            } else {_                                v.add(fieldValue)__                                return v__                            }_                        })__                    }_                    timeoutChecker.check("full message Grok pattern field extraction")__                }__                for (Map.Entry<String, Collection<String>> valuesForField : valuesPerField.entrySet()) {_                    String fieldName = valuesForField.getKey()__                    if (mappings != null) {_                        _                        if (fieldName.equals(timeField) == false) {_                            mappings.put(fieldName,_                                FileStructureUtils.guessScalarMapping(explanation, fieldName, valuesForField.getValue()))__                            timeoutChecker.check("mapping determination")__                        }_                    }_                    if (fieldStats != null) {_                        fieldStats.put(fieldName, FileStructureUtils.calculateFieldStats(valuesForField.getValue(), timeoutChecker))__                    }_                }_            }__            return new Tuple<>(timeField, grokPattern)__        };this,must,only,be,called,if,link,matches,all,returns,code,true,code,return,a,tuple,of,time,field,name,grok,string;public,tuple,string,string,process,match,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,timeout,checker,timeout,checker,explanation,add,a,full,message,grok,pattern,grok,pattern,substring,2,grok,pattern,length,1,looks,appropriate,if,mappings,null,field,stats,null,map,string,collection,string,values,per,field,new,hash,map,for,string,sample,message,sample,messages,map,string,object,captures,grok,captures,sample,message,if,captures,null,throw,new,illegal,state,exception,grok,pattern,does,not,match,snippet,sample,message,for,map,entry,string,object,capture,captures,entry,set,string,field,name,capture,get,key,string,field,value,capture,get,value,to,string,values,per,field,compute,field,name,k,v,if,v,null,return,new,array,list,collections,singleton,list,field,value,else,v,add,field,value,return,v,timeout,checker,check,full,message,grok,pattern,field,extraction,for,map,entry,string,collection,string,values,for,field,values,per,field,entry,set,string,field,name,values,for,field,get,key,if,mappings,null,if,field,name,equals,time,field,false,mappings,put,field,name,file,structure,utils,guess,scalar,mapping,explanation,field,name,values,for,field,get,value,timeout,checker,check,mapping,determination,if,field,stats,null,field,stats,put,field,name,file,structure,utils,calculate,field,stats,values,for,field,get,value,timeout,checker,return,new,tuple,time,field,grok,pattern
GrokPatternCreator -> FullMatchGrokPatternCandidate -> public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,                                                   Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker);1544771889;This must only be called if {@link #matchesAll} returns <code>true</code>._@return A tuple of (time field name, Grok string).;public Tuple<String, String> processMatch(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,_                                                  Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker) {__            explanation.add("A full message Grok pattern [" + grokPattern.substring(2, grokPattern.length() - 1) + "] looks appropriate")___            if (mappings != null || fieldStats != null) {_                Map<String, Collection<String>> valuesPerField = new HashMap<>()___                for (String sampleMessage : sampleMessages) {_                    Map<String, Object> captures = timeoutChecker.grokCaptures(grok, sampleMessage,_                        "full message Grok pattern field extraction")__                    _                    if (captures == null) {_                        throw new IllegalStateException("[" + grokPattern + "] does not match snippet [" + sampleMessage + "]")__                    }_                    for (Map.Entry<String, Object> capture : captures.entrySet()) {__                        String fieldName = capture.getKey()__                        String fieldValue = capture.getValue().toString()__                        valuesPerField.compute(fieldName, (k, v) -> {_                            if (v == null) {_                                return new ArrayList<>(Collections.singletonList(fieldValue))__                            } else {_                                v.add(fieldValue)__                                return v__                            }_                        })__                    }_                }__                for (Map.Entry<String, Collection<String>> valuesForField : valuesPerField.entrySet()) {_                    String fieldName = valuesForField.getKey()__                    if (mappings != null) {_                        _                        if (fieldName.equals(timeField) == false) {_                            mappings.put(fieldName,_                                FileStructureUtils.guessScalarMapping(explanation, fieldName, valuesForField.getValue(), timeoutChecker))__                            timeoutChecker.check("mapping determination")__                        }_                    }_                    if (fieldStats != null) {_                        fieldStats.put(fieldName, FileStructureUtils.calculateFieldStats(valuesForField.getValue(), timeoutChecker))__                    }_                }_            }__            return new Tuple<>(timeField, grokPattern)__        };this,must,only,be,called,if,link,matches,all,returns,code,true,code,return,a,tuple,of,time,field,name,grok,string;public,tuple,string,string,process,match,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,timeout,checker,timeout,checker,explanation,add,a,full,message,grok,pattern,grok,pattern,substring,2,grok,pattern,length,1,looks,appropriate,if,mappings,null,field,stats,null,map,string,collection,string,values,per,field,new,hash,map,for,string,sample,message,sample,messages,map,string,object,captures,timeout,checker,grok,captures,grok,sample,message,full,message,grok,pattern,field,extraction,if,captures,null,throw,new,illegal,state,exception,grok,pattern,does,not,match,snippet,sample,message,for,map,entry,string,object,capture,captures,entry,set,string,field,name,capture,get,key,string,field,value,capture,get,value,to,string,values,per,field,compute,field,name,k,v,if,v,null,return,new,array,list,collections,singleton,list,field,value,else,v,add,field,value,return,v,for,map,entry,string,collection,string,values,for,field,values,per,field,entry,set,string,field,name,values,for,field,get,key,if,mappings,null,if,field,name,equals,time,field,false,mappings,put,field,name,file,structure,utils,guess,scalar,mapping,explanation,field,name,values,for,field,get,value,timeout,checker,timeout,checker,check,mapping,determination,if,field,stats,null,field,stats,put,field,name,file,structure,utils,calculate,field,stats,values,for,field,get,value,timeout,checker,return,new,tuple,time,field,grok,pattern
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak);1536314350;@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param mappingType     Data type for field in Elasticsearch mappings._@param fieldName       Name of the field to extract from the match._@param preBreak        Only consider the match if it's broken from the previous text by this._@param postBreak       Only consider the match if it's broken from the following text by this.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak) {_            this.grokPatternName = grokPatternName__            this.mappingType = mappingType__            this.fieldName = fieldName__            _            grok = new Grok(Grok.getBuiltinPatterns(), "(?m)%{DATA:" + PREFACE + "}" + preBreak +_                "%{" + grokPatternName + ":" + VALUE + "}" + postBreak + "%{GREEDYDATA:" + EPILOGUE + "}")__        };param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,mapping,type,data,type,for,field,in,elasticsearch,mappings,param,field,name,name,of,the,field,to,extract,from,the,match,param,pre,break,only,consider,the,match,if,it,s,broken,from,the,previous,text,by,this,param,post,break,only,consider,the,match,if,it,s,broken,from,the,following,text,by,this;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,string,pre,break,string,post,break,this,grok,pattern,name,grok,pattern,name,this,mapping,type,mapping,type,this,field,name,field,name,grok,new,grok,grok,get,builtin,patterns,m,data,preface,pre,break,grok,pattern,name,value,post,break,greedydata,epilogue
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak);1536611444;@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param mappingType     Data type for field in Elasticsearch mappings._@param fieldName       Name of the field to extract from the match._@param preBreak        Only consider the match if it's broken from the previous text by this._@param postBreak       Only consider the match if it's broken from the following text by this.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak) {_            this.grokPatternName = grokPatternName__            this.mappingType = mappingType__            this.fieldName = fieldName__            _            grok = new Grok(Grok.getBuiltinPatterns(), "(?m)%{DATA:" + PREFACE + "}" + preBreak +_                "%{" + grokPatternName + ":" + VALUE + "}" + postBreak + "%{GREEDYDATA:" + EPILOGUE + "}")__        };param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,mapping,type,data,type,for,field,in,elasticsearch,mappings,param,field,name,name,of,the,field,to,extract,from,the,match,param,pre,break,only,consider,the,match,if,it,s,broken,from,the,previous,text,by,this,param,post,break,only,consider,the,match,if,it,s,broken,from,the,following,text,by,this;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,string,pre,break,string,post,break,this,grok,pattern,name,grok,pattern,name,this,mapping,type,mapping,type,this,field,name,field,name,grok,new,grok,grok,get,builtin,patterns,m,data,preface,pre,break,grok,pattern,name,value,post,break,greedydata,epilogue
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak);1536964057;@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param mappingType     Data type for field in Elasticsearch mappings._@param fieldName       Name of the field to extract from the match._@param preBreak        Only consider the match if it's broken from the previous text by this._@param postBreak       Only consider the match if it's broken from the following text by this.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak) {_            this.grokPatternName = grokPatternName__            this.mappingType = mappingType__            this.fieldName = fieldName__            _            grok = new Grok(Grok.getBuiltinPatterns(), "(?m)%{DATA:" + PREFACE + "}" + preBreak +_                "%{" + grokPatternName + ":" + VALUE + "}" + postBreak + "%{GREEDYDATA:" + EPILOGUE + "}")__        };param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,mapping,type,data,type,for,field,in,elasticsearch,mappings,param,field,name,name,of,the,field,to,extract,from,the,match,param,pre,break,only,consider,the,match,if,it,s,broken,from,the,previous,text,by,this,param,post,break,only,consider,the,match,if,it,s,broken,from,the,following,text,by,this;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,string,pre,break,string,post,break,this,grok,pattern,name,grok,pattern,name,this,mapping,type,mapping,type,this,field,name,field,name,grok,new,grok,grok,get,builtin,patterns,m,data,preface,pre,break,grok,pattern,name,value,post,break,greedydata,epilogue
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak);1538170812;@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param mappingType     Data type for field in Elasticsearch mappings._@param fieldName       Name of the field to extract from the match._@param preBreak        Only consider the match if it's broken from the previous text by this._@param postBreak       Only consider the match if it's broken from the following text by this.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak) {_            this.grokPatternName = grokPatternName__            this.mappingType = mappingType__            this.fieldName = fieldName__            _            grok = new Grok(Grok.getBuiltinPatterns(), "(?m)%{DATA:" + PREFACE + "}" + preBreak +_                "%{" + grokPatternName + ":" + VALUE + "}" + postBreak + "%{GREEDYDATA:" + EPILOGUE + "}")__        };param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,mapping,type,data,type,for,field,in,elasticsearch,mappings,param,field,name,name,of,the,field,to,extract,from,the,match,param,pre,break,only,consider,the,match,if,it,s,broken,from,the,previous,text,by,this,param,post,break,only,consider,the,match,if,it,s,broken,from,the,following,text,by,this;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,string,pre,break,string,post,break,this,grok,pattern,name,grok,pattern,name,this,mapping,type,mapping,type,this,field,name,field,name,grok,new,grok,grok,get,builtin,patterns,m,data,preface,pre,break,grok,pattern,name,value,post,break,greedydata,epilogue
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak);1544771889;@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param mappingType     Data type for field in Elasticsearch mappings._@param fieldName       Name of the field to extract from the match._@param preBreak        Only consider the match if it's broken from the previous text by this._@param postBreak       Only consider the match if it's broken from the following text by this.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName, String preBreak, String postBreak) {_            this.grokPatternName = grokPatternName__            this.mappingType = mappingType__            this.fieldName = fieldName__            _            grok = new Grok(Grok.getBuiltinPatterns(), "(?m)%{DATA:" + PREFACE + "}" + preBreak +_                "%{" + grokPatternName + ":" + VALUE + "}" + postBreak + "%{GREEDYDATA:" + EPILOGUE + "}", TimeoutChecker.watchdog)__        };param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,mapping,type,data,type,for,field,in,elasticsearch,mappings,param,field,name,name,of,the,field,to,extract,from,the,match,param,pre,break,only,consider,the,match,if,it,s,broken,from,the,previous,text,by,this,param,post,break,only,consider,the,match,if,it,s,broken,from,the,following,text,by,this;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,string,pre,break,string,post,break,this,grok,pattern,name,grok,pattern,name,this,mapping,type,mapping,type,this,field,name,field,name,grok,new,grok,grok,get,builtin,patterns,m,data,preface,pre,break,grok,pattern,name,value,post,break,greedydata,epilogue,timeout,checker,watchdog
GrokPatternCreator -> public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,                               Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker);1538170812;@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by the methods of this class._@param sampleMessages Sample messages that any Grok pattern found must match._@param mappings Will be updated with mappings appropriate for the returned pattern, if non-<code>null</code>._@param timeoutChecker Will abort the operation if its timeout is exceeded._@param fieldStats Will be updated with field stats for the fields in the returned pattern, if non-<code>null</code>.;public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,_                              Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker) {_        this.explanation = explanation__        this.sampleMessages = Collections.unmodifiableCollection(sampleMessages)__        this.mappings = mappings__        this.fieldStats = fieldStats__        this.timeoutChecker = timeoutChecker__    };param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,the,methods,of,this,class,param,sample,messages,sample,messages,that,any,grok,pattern,found,must,match,param,mappings,will,be,updated,with,mappings,appropriate,for,the,returned,pattern,if,non,code,null,code,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,param,field,stats,will,be,updated,with,field,stats,for,the,fields,in,the,returned,pattern,if,non,code,null,code;public,grok,pattern,creator,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,timeout,checker,timeout,checker,this,explanation,explanation,this,sample,messages,collections,unmodifiable,collection,sample,messages,this,mappings,mappings,this,field,stats,field,stats,this,timeout,checker,timeout,checker
GrokPatternCreator -> public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,                               Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker);1544771889;@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by the methods of this class._@param sampleMessages Sample messages that any Grok pattern found must match._@param mappings Will be updated with mappings appropriate for the returned pattern, if non-<code>null</code>._@param timeoutChecker Will abort the operation if its timeout is exceeded._@param fieldStats Will be updated with field stats for the fields in the returned pattern, if non-<code>null</code>.;public GrokPatternCreator(List<String> explanation, Collection<String> sampleMessages, Map<String, Object> mappings,_                              Map<String, FieldStats> fieldStats, TimeoutChecker timeoutChecker) {_        this.explanation = explanation__        this.sampleMessages = Collections.unmodifiableCollection(sampleMessages)__        this.mappings = mappings__        this.fieldStats = fieldStats__        this.timeoutChecker = timeoutChecker__    };param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,the,methods,of,this,class,param,sample,messages,sample,messages,that,any,grok,pattern,found,must,match,param,mappings,will,be,updated,with,mappings,appropriate,for,the,returned,pattern,if,non,code,null,code,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,param,field,stats,will,be,updated,with,field,stats,for,the,fields,in,the,returned,pattern,if,non,code,null,code;public,grok,pattern,creator,list,string,explanation,collection,string,sample,messages,map,string,object,mappings,map,string,field,stats,field,stats,timeout,checker,timeout,checker,this,explanation,explanation,this,sample,messages,collections,unmodifiable,collection,sample,messages,this,mappings,mappings,this,field,stats,field,stats,this,timeout,checker,timeout,checker
GrokPatternCreator -> private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,                                           boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,                                           boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight);1536314350;Given a chosen Grok pattern and a collection of message snippets, split the snippets into the_matched section and the pieces before and after it.  Recurse to find more matches in the pieces_before and after and update the supplied string builder.;private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,_                                          boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,_                                          boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight) {__        Collection<String> prefaces = new ArrayList<>()__        Collection<String> epilogues = new ArrayList<>()__        String patternBuilderContent =_            chosenPattern.processCaptures(fieldNameCountStore, snippets, prefaces, epilogues, mappings, fieldStats)__        appendBestGrokMatchForStrings(false, prefaces, ignoreKeyValueCandidateLeft, ignoreValueOnlyCandidatesLeft)__        overallGrokPatternBuilder.append(patternBuilderContent)__        appendBestGrokMatchForStrings(isLast, epilogues, ignoreKeyValueCandidateRight, ignoreValueOnlyCandidatesRight)__    };given,a,chosen,grok,pattern,and,a,collection,of,message,snippets,split,the,snippets,into,the,matched,section,and,the,pieces,before,and,after,it,recurse,to,find,more,matches,in,the,pieces,before,and,after,and,update,the,supplied,string,builder;private,void,process,candidate,and,split,grok,pattern,candidate,chosen,pattern,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,left,int,ignore,value,only,candidates,left,boolean,ignore,key,value,candidate,right,int,ignore,value,only,candidates,right,collection,string,prefaces,new,array,list,collection,string,epilogues,new,array,list,string,pattern,builder,content,chosen,pattern,process,captures,field,name,count,store,snippets,prefaces,epilogues,mappings,field,stats,append,best,grok,match,for,strings,false,prefaces,ignore,key,value,candidate,left,ignore,value,only,candidates,left,overall,grok,pattern,builder,append,pattern,builder,content,append,best,grok,match,for,strings,is,last,epilogues,ignore,key,value,candidate,right,ignore,value,only,candidates,right
GrokPatternCreator -> private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,                                           boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,                                           boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight);1536611444;Given a chosen Grok pattern and a collection of message snippets, split the snippets into the_matched section and the pieces before and after it.  Recurse to find more matches in the pieces_before and after and update the supplied string builder.;private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,_                                          boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,_                                          boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight) {__        Collection<String> prefaces = new ArrayList<>()__        Collection<String> epilogues = new ArrayList<>()__        String patternBuilderContent =_            chosenPattern.processCaptures(fieldNameCountStore, snippets, prefaces, epilogues, mappings, fieldStats)__        appendBestGrokMatchForStrings(false, prefaces, ignoreKeyValueCandidateLeft, ignoreValueOnlyCandidatesLeft)__        overallGrokPatternBuilder.append(patternBuilderContent)__        appendBestGrokMatchForStrings(isLast, epilogues, ignoreKeyValueCandidateRight, ignoreValueOnlyCandidatesRight)__    };given,a,chosen,grok,pattern,and,a,collection,of,message,snippets,split,the,snippets,into,the,matched,section,and,the,pieces,before,and,after,it,recurse,to,find,more,matches,in,the,pieces,before,and,after,and,update,the,supplied,string,builder;private,void,process,candidate,and,split,grok,pattern,candidate,chosen,pattern,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,left,int,ignore,value,only,candidates,left,boolean,ignore,key,value,candidate,right,int,ignore,value,only,candidates,right,collection,string,prefaces,new,array,list,collection,string,epilogues,new,array,list,string,pattern,builder,content,chosen,pattern,process,captures,field,name,count,store,snippets,prefaces,epilogues,mappings,field,stats,append,best,grok,match,for,strings,false,prefaces,ignore,key,value,candidate,left,ignore,value,only,candidates,left,overall,grok,pattern,builder,append,pattern,builder,content,append,best,grok,match,for,strings,is,last,epilogues,ignore,key,value,candidate,right,ignore,value,only,candidates,right
GrokPatternCreator -> private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,                                           boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,                                           boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight);1536964057;Given a chosen Grok pattern and a collection of message snippets, split the snippets into the_matched section and the pieces before and after it.  Recurse to find more matches in the pieces_before and after and update the supplied string builder.;private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,_                                          boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,_                                          boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight) {__        Collection<String> prefaces = new ArrayList<>()__        Collection<String> epilogues = new ArrayList<>()__        String patternBuilderContent =_            chosenPattern.processCaptures(fieldNameCountStore, snippets, prefaces, epilogues, mappings, fieldStats)__        appendBestGrokMatchForStrings(false, prefaces, ignoreKeyValueCandidateLeft, ignoreValueOnlyCandidatesLeft)__        overallGrokPatternBuilder.append(patternBuilderContent)__        appendBestGrokMatchForStrings(isLast, epilogues, ignoreKeyValueCandidateRight, ignoreValueOnlyCandidatesRight)__    };given,a,chosen,grok,pattern,and,a,collection,of,message,snippets,split,the,snippets,into,the,matched,section,and,the,pieces,before,and,after,it,recurse,to,find,more,matches,in,the,pieces,before,and,after,and,update,the,supplied,string,builder;private,void,process,candidate,and,split,grok,pattern,candidate,chosen,pattern,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,left,int,ignore,value,only,candidates,left,boolean,ignore,key,value,candidate,right,int,ignore,value,only,candidates,right,collection,string,prefaces,new,array,list,collection,string,epilogues,new,array,list,string,pattern,builder,content,chosen,pattern,process,captures,field,name,count,store,snippets,prefaces,epilogues,mappings,field,stats,append,best,grok,match,for,strings,false,prefaces,ignore,key,value,candidate,left,ignore,value,only,candidates,left,overall,grok,pattern,builder,append,pattern,builder,content,append,best,grok,match,for,strings,is,last,epilogues,ignore,key,value,candidate,right,ignore,value,only,candidates,right
GrokPatternCreator -> private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,                                           boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,                                           boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight);1538170812;Given a chosen Grok pattern and a collection of message snippets, split the snippets into the_matched section and the pieces before and after it.  Recurse to find more matches in the pieces_before and after and update the supplied string builder.;private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,_                                          boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,_                                          boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight) {__        Collection<String> prefaces = new ArrayList<>()__        Collection<String> epilogues = new ArrayList<>()__        String patternBuilderContent =_            chosenPattern.processCaptures(fieldNameCountStore, snippets, prefaces, epilogues, mappings, fieldStats, timeoutChecker)__        appendBestGrokMatchForStrings(false, prefaces, ignoreKeyValueCandidateLeft, ignoreValueOnlyCandidatesLeft)__        overallGrokPatternBuilder.append(patternBuilderContent)__        appendBestGrokMatchForStrings(isLast, epilogues, ignoreKeyValueCandidateRight, ignoreValueOnlyCandidatesRight)__    };given,a,chosen,grok,pattern,and,a,collection,of,message,snippets,split,the,snippets,into,the,matched,section,and,the,pieces,before,and,after,it,recurse,to,find,more,matches,in,the,pieces,before,and,after,and,update,the,supplied,string,builder;private,void,process,candidate,and,split,grok,pattern,candidate,chosen,pattern,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,left,int,ignore,value,only,candidates,left,boolean,ignore,key,value,candidate,right,int,ignore,value,only,candidates,right,collection,string,prefaces,new,array,list,collection,string,epilogues,new,array,list,string,pattern,builder,content,chosen,pattern,process,captures,field,name,count,store,snippets,prefaces,epilogues,mappings,field,stats,timeout,checker,append,best,grok,match,for,strings,false,prefaces,ignore,key,value,candidate,left,ignore,value,only,candidates,left,overall,grok,pattern,builder,append,pattern,builder,content,append,best,grok,match,for,strings,is,last,epilogues,ignore,key,value,candidate,right,ignore,value,only,candidates,right
GrokPatternCreator -> private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,                                           boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,                                           boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight);1544771889;Given a chosen Grok pattern and a collection of message snippets, split the snippets into the_matched section and the pieces before and after it.  Recurse to find more matches in the pieces_before and after and update the supplied string builder.;private void processCandidateAndSplit(GrokPatternCandidate chosenPattern, boolean isLast, Collection<String> snippets,_                                          boolean ignoreKeyValueCandidateLeft, int ignoreValueOnlyCandidatesLeft,_                                          boolean ignoreKeyValueCandidateRight, int ignoreValueOnlyCandidatesRight) {__        Collection<String> prefaces = new ArrayList<>()__        Collection<String> epilogues = new ArrayList<>()__        String patternBuilderContent =_            chosenPattern.processCaptures(fieldNameCountStore, snippets, prefaces, epilogues, mappings, fieldStats, timeoutChecker)__        appendBestGrokMatchForStrings(false, prefaces, ignoreKeyValueCandidateLeft, ignoreValueOnlyCandidatesLeft)__        overallGrokPatternBuilder.append(patternBuilderContent)__        appendBestGrokMatchForStrings(isLast, epilogues, ignoreKeyValueCandidateRight, ignoreValueOnlyCandidatesRight)__    };given,a,chosen,grok,pattern,and,a,collection,of,message,snippets,split,the,snippets,into,the,matched,section,and,the,pieces,before,and,after,it,recurse,to,find,more,matches,in,the,pieces,before,and,after,and,update,the,supplied,string,builder;private,void,process,candidate,and,split,grok,pattern,candidate,chosen,pattern,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,left,int,ignore,value,only,candidates,left,boolean,ignore,key,value,candidate,right,int,ignore,value,only,candidates,right,collection,string,prefaces,new,array,list,collection,string,epilogues,new,array,list,string,pattern,builder,content,chosen,pattern,process,captures,field,name,count,store,snippets,prefaces,epilogues,mappings,field,stats,timeout,checker,append,best,grok,match,for,strings,false,prefaces,ignore,key,value,candidate,left,ignore,value,only,candidates,left,overall,grok,pattern,builder,append,pattern,builder,content,append,best,grok,match,for,strings,is,last,epilogues,ignore,key,value,candidate,right,ignore,value,only,candidates,right
GrokPatternCreator -> void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,                                        boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates);1536314350;Given a collection of message snippets, work out which (if any) of the Grok patterns we're allowed_to use matches it best.  Then append the appropriate Grok language to represent that finding onto_the supplied string builder.;void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,_                                       boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates) {__        snippets = adjustForPunctuation(snippets)___        GrokPatternCandidate bestCandidate = null__        if (snippets.isEmpty() == false) {_            GrokPatternCandidate kvCandidate = new KeyValueGrokPatternCandidate(explanation)__            if (ignoreKeyValueCandidate == false && kvCandidate.matchesAll(snippets)) {_                bestCandidate = kvCandidate__            } else {_                ignoreKeyValueCandidate = true__                for (GrokPatternCandidate candidate :_                    ORDERED_CANDIDATE_GROK_PATTERNS.subList(ignoreValueOnlyCandidates, ORDERED_CANDIDATE_GROK_PATTERNS.size())) {_                    if (candidate.matchesAll(snippets)) {_                        bestCandidate = candidate__                        break__                    }_                    ++ignoreValueOnlyCandidates__                }_            }_        }__        if (bestCandidate == null) {_            if (isLast) {_                finalizeGrokPattern(snippets)__            } else {_                addIntermediateRegex(snippets)__            }_        } else {_            processCandidateAndSplit(bestCandidate, isLast, snippets, true, ignoreValueOnlyCandidates + (ignoreKeyValueCandidate ? 1 : 0),_                ignoreKeyValueCandidate, ignoreValueOnlyCandidates)__        }_    };given,a,collection,of,message,snippets,work,out,which,if,any,of,the,grok,patterns,we,re,allowed,to,use,matches,it,best,then,append,the,appropriate,grok,language,to,represent,that,finding,onto,the,supplied,string,builder;void,append,best,grok,match,for,strings,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,int,ignore,value,only,candidates,snippets,adjust,for,punctuation,snippets,grok,pattern,candidate,best,candidate,null,if,snippets,is,empty,false,grok,pattern,candidate,kv,candidate,new,key,value,grok,pattern,candidate,explanation,if,ignore,key,value,candidate,false,kv,candidate,matches,all,snippets,best,candidate,kv,candidate,else,ignore,key,value,candidate,true,for,grok,pattern,candidate,candidate,sub,list,ignore,value,only,candidates,size,if,candidate,matches,all,snippets,best,candidate,candidate,break,ignore,value,only,candidates,if,best,candidate,null,if,is,last,finalize,grok,pattern,snippets,else,add,intermediate,regex,snippets,else,process,candidate,and,split,best,candidate,is,last,snippets,true,ignore,value,only,candidates,ignore,key,value,candidate,1,0,ignore,key,value,candidate,ignore,value,only,candidates
GrokPatternCreator -> void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,                                        boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates);1536611444;Given a collection of message snippets, work out which (if any) of the Grok patterns we're allowed_to use matches it best.  Then append the appropriate Grok language to represent that finding onto_the supplied string builder.;void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,_                                       boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates) {__        snippets = adjustForPunctuation(snippets)___        GrokPatternCandidate bestCandidate = null__        if (snippets.isEmpty() == false) {_            GrokPatternCandidate kvCandidate = new KeyValueGrokPatternCandidate(explanation)__            if (ignoreKeyValueCandidate == false && kvCandidate.matchesAll(snippets)) {_                bestCandidate = kvCandidate__            } else {_                ignoreKeyValueCandidate = true__                for (GrokPatternCandidate candidate :_                    ORDERED_CANDIDATE_GROK_PATTERNS.subList(ignoreValueOnlyCandidates, ORDERED_CANDIDATE_GROK_PATTERNS.size())) {_                    if (candidate.matchesAll(snippets)) {_                        bestCandidate = candidate__                        break__                    }_                    ++ignoreValueOnlyCandidates__                }_            }_        }__        if (bestCandidate == null) {_            if (isLast) {_                finalizeGrokPattern(snippets)__            } else {_                addIntermediateRegex(snippets)__            }_        } else {_            processCandidateAndSplit(bestCandidate, isLast, snippets, true, ignoreValueOnlyCandidates + (ignoreKeyValueCandidate ? 1 : 0),_                ignoreKeyValueCandidate, ignoreValueOnlyCandidates)__        }_    };given,a,collection,of,message,snippets,work,out,which,if,any,of,the,grok,patterns,we,re,allowed,to,use,matches,it,best,then,append,the,appropriate,grok,language,to,represent,that,finding,onto,the,supplied,string,builder;void,append,best,grok,match,for,strings,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,int,ignore,value,only,candidates,snippets,adjust,for,punctuation,snippets,grok,pattern,candidate,best,candidate,null,if,snippets,is,empty,false,grok,pattern,candidate,kv,candidate,new,key,value,grok,pattern,candidate,explanation,if,ignore,key,value,candidate,false,kv,candidate,matches,all,snippets,best,candidate,kv,candidate,else,ignore,key,value,candidate,true,for,grok,pattern,candidate,candidate,sub,list,ignore,value,only,candidates,size,if,candidate,matches,all,snippets,best,candidate,candidate,break,ignore,value,only,candidates,if,best,candidate,null,if,is,last,finalize,grok,pattern,snippets,else,add,intermediate,regex,snippets,else,process,candidate,and,split,best,candidate,is,last,snippets,true,ignore,value,only,candidates,ignore,key,value,candidate,1,0,ignore,key,value,candidate,ignore,value,only,candidates
GrokPatternCreator -> void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,                                        boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates);1536964057;Given a collection of message snippets, work out which (if any) of the Grok patterns we're allowed_to use matches it best.  Then append the appropriate Grok language to represent that finding onto_the supplied string builder.;void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,_                                       boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates) {__        snippets = adjustForPunctuation(snippets)___        GrokPatternCandidate bestCandidate = null__        if (snippets.isEmpty() == false) {_            GrokPatternCandidate kvCandidate = new KeyValueGrokPatternCandidate(explanation)__            if (ignoreKeyValueCandidate == false && kvCandidate.matchesAll(snippets)) {_                bestCandidate = kvCandidate__            } else {_                ignoreKeyValueCandidate = true__                for (GrokPatternCandidate candidate :_                    ORDERED_CANDIDATE_GROK_PATTERNS.subList(ignoreValueOnlyCandidates, ORDERED_CANDIDATE_GROK_PATTERNS.size())) {_                    if (candidate.matchesAll(snippets)) {_                        bestCandidate = candidate__                        break__                    }_                    ++ignoreValueOnlyCandidates__                }_            }_        }__        if (bestCandidate == null) {_            if (isLast) {_                finalizeGrokPattern(snippets)__            } else {_                addIntermediateRegex(snippets)__            }_        } else {_            processCandidateAndSplit(bestCandidate, isLast, snippets, true, ignoreValueOnlyCandidates + (ignoreKeyValueCandidate ? 1 : 0),_                ignoreKeyValueCandidate, ignoreValueOnlyCandidates)__        }_    };given,a,collection,of,message,snippets,work,out,which,if,any,of,the,grok,patterns,we,re,allowed,to,use,matches,it,best,then,append,the,appropriate,grok,language,to,represent,that,finding,onto,the,supplied,string,builder;void,append,best,grok,match,for,strings,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,int,ignore,value,only,candidates,snippets,adjust,for,punctuation,snippets,grok,pattern,candidate,best,candidate,null,if,snippets,is,empty,false,grok,pattern,candidate,kv,candidate,new,key,value,grok,pattern,candidate,explanation,if,ignore,key,value,candidate,false,kv,candidate,matches,all,snippets,best,candidate,kv,candidate,else,ignore,key,value,candidate,true,for,grok,pattern,candidate,candidate,sub,list,ignore,value,only,candidates,size,if,candidate,matches,all,snippets,best,candidate,candidate,break,ignore,value,only,candidates,if,best,candidate,null,if,is,last,finalize,grok,pattern,snippets,else,add,intermediate,regex,snippets,else,process,candidate,and,split,best,candidate,is,last,snippets,true,ignore,value,only,candidates,ignore,key,value,candidate,1,0,ignore,key,value,candidate,ignore,value,only,candidates
GrokPatternCreator -> void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,                                        boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates);1538170812;Given a collection of message snippets, work out which (if any) of the Grok patterns we're allowed_to use matches it best.  Then append the appropriate Grok language to represent that finding onto_the supplied string builder.;void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,_                                       boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates) {__        snippets = adjustForPunctuation(snippets)___        GrokPatternCandidate bestCandidate = null__        if (snippets.isEmpty() == false) {_            GrokPatternCandidate kvCandidate = new KeyValueGrokPatternCandidate(explanation)__            if (ignoreKeyValueCandidate == false && kvCandidate.matchesAll(snippets)) {_                bestCandidate = kvCandidate__            } else {_                ignoreKeyValueCandidate = true__                for (GrokPatternCandidate candidate :_                    ORDERED_CANDIDATE_GROK_PATTERNS.subList(ignoreValueOnlyCandidates, ORDERED_CANDIDATE_GROK_PATTERNS.size())) {_                    if (candidate.matchesAll(snippets)) {_                        bestCandidate = candidate__                        break__                    }_                    ++ignoreValueOnlyCandidates__                }_            }_        }__        if (bestCandidate == null) {_            if (isLast) {_                finalizeGrokPattern(snippets)__            } else {_                addIntermediateRegex(snippets)__            }_        } else {_            processCandidateAndSplit(bestCandidate, isLast, snippets, true, ignoreValueOnlyCandidates + (ignoreKeyValueCandidate ? 1 : 0),_                ignoreKeyValueCandidate, ignoreValueOnlyCandidates)__        }_    };given,a,collection,of,message,snippets,work,out,which,if,any,of,the,grok,patterns,we,re,allowed,to,use,matches,it,best,then,append,the,appropriate,grok,language,to,represent,that,finding,onto,the,supplied,string,builder;void,append,best,grok,match,for,strings,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,int,ignore,value,only,candidates,snippets,adjust,for,punctuation,snippets,grok,pattern,candidate,best,candidate,null,if,snippets,is,empty,false,grok,pattern,candidate,kv,candidate,new,key,value,grok,pattern,candidate,explanation,if,ignore,key,value,candidate,false,kv,candidate,matches,all,snippets,best,candidate,kv,candidate,else,ignore,key,value,candidate,true,for,grok,pattern,candidate,candidate,sub,list,ignore,value,only,candidates,size,if,candidate,matches,all,snippets,best,candidate,candidate,break,ignore,value,only,candidates,if,best,candidate,null,if,is,last,finalize,grok,pattern,snippets,else,add,intermediate,regex,snippets,else,process,candidate,and,split,best,candidate,is,last,snippets,true,ignore,value,only,candidates,ignore,key,value,candidate,1,0,ignore,key,value,candidate,ignore,value,only,candidates
GrokPatternCreator -> void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,                                        boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates);1544771889;Given a collection of message snippets, work out which (if any) of the Grok patterns we're allowed_to use matches it best.  Then append the appropriate Grok language to represent that finding onto_the supplied string builder.;void appendBestGrokMatchForStrings(boolean isLast, Collection<String> snippets,_                                       boolean ignoreKeyValueCandidate, int ignoreValueOnlyCandidates) {__        snippets = adjustForPunctuation(snippets)___        GrokPatternCandidate bestCandidate = null__        if (snippets.isEmpty() == false) {_            GrokPatternCandidate kvCandidate = new KeyValueGrokPatternCandidate(explanation)__            if (ignoreKeyValueCandidate == false && kvCandidate.matchesAll(snippets)) {_                bestCandidate = kvCandidate__            } else {_                ignoreKeyValueCandidate = true__                for (GrokPatternCandidate candidate :_                    ORDERED_CANDIDATE_GROK_PATTERNS.subList(ignoreValueOnlyCandidates, ORDERED_CANDIDATE_GROK_PATTERNS.size())) {_                    if (candidate.matchesAll(snippets)) {_                        bestCandidate = candidate__                        break__                    }_                    ++ignoreValueOnlyCandidates__                }_            }_        }__        if (bestCandidate == null) {_            if (isLast) {_                finalizeGrokPattern(snippets)__            } else {_                addIntermediateRegex(snippets)__            }_        } else {_            processCandidateAndSplit(bestCandidate, isLast, snippets, true, ignoreValueOnlyCandidates + (ignoreKeyValueCandidate ? 1 : 0),_                ignoreKeyValueCandidate, ignoreValueOnlyCandidates)__        }_    };given,a,collection,of,message,snippets,work,out,which,if,any,of,the,grok,patterns,we,re,allowed,to,use,matches,it,best,then,append,the,appropriate,grok,language,to,represent,that,finding,onto,the,supplied,string,builder;void,append,best,grok,match,for,strings,boolean,is,last,collection,string,snippets,boolean,ignore,key,value,candidate,int,ignore,value,only,candidates,snippets,adjust,for,punctuation,snippets,grok,pattern,candidate,best,candidate,null,if,snippets,is,empty,false,grok,pattern,candidate,kv,candidate,new,key,value,grok,pattern,candidate,explanation,if,ignore,key,value,candidate,false,kv,candidate,matches,all,snippets,best,candidate,kv,candidate,else,ignore,key,value,candidate,true,for,grok,pattern,candidate,candidate,sub,list,ignore,value,only,candidates,size,if,candidate,matches,all,snippets,best,candidate,candidate,break,ignore,value,only,candidates,if,best,candidate,null,if,is,last,finalize,grok,pattern,snippets,else,add,intermediate,regex,snippets,else,process,candidate,and,split,best,candidate,is,last,snippets,true,ignore,value,only,candidates,ignore,key,value,candidate,1,0,ignore,key,value,candidate,ignore,value,only,candidates
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> @Override         public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                       Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats);1536314350;Given a collection of strings, and a Grok pattern that matches some part of them all,_return collections of the bits that come before (prefaces) and after (epilogues) the_bit that matches.;@Override_        public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                                      Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats) {_            String sampleValue = null__            for (String snippet : snippets) {_                Map<String, Object> captures = grok.captures(snippet)__                _                if (captures == null) {_                    throw new IllegalStateException("[%{" + grokPatternName + "}] does not match snippet [" + snippet + "]")__                }_                prefaces.add(captures.getOrDefault(PREFACE, "").toString())__                if (sampleValue == null) {_                    sampleValue = captures.get(VALUE).toString()__                }_                epilogues.add(captures.getOrDefault(EPILOGUE, "").toString())__            }_            String adjustedFieldName = buildFieldName(fieldNameCountStore, fieldName)__            if (mappings != null) {_                Map<String, String> fullMappingType = Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, mappingType)__                if ("date".equals(mappingType)) {_                    TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(sampleValue)__                    if (timestampMatch != null) {_                        fullMappingType = timestampMatch.getEsDateMappingTypeWithFormat()__                    }_                }_                mappings.put(adjustedFieldName, fullMappingType)__            }_            return "%{" + grokPatternName + ":" + adjustedFieldName + "}"__        };given,a,collection,of,strings,and,a,grok,pattern,that,matches,some,part,of,them,all,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches;override,public,string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats,string,sample,value,null,for,string,snippet,snippets,map,string,object,captures,grok,captures,snippet,if,captures,null,throw,new,illegal,state,exception,grok,pattern,name,does,not,match,snippet,snippet,prefaces,add,captures,get,or,default,preface,to,string,if,sample,value,null,sample,value,captures,get,value,to,string,epilogues,add,captures,get,or,default,epilogue,to,string,string,adjusted,field,name,build,field,name,field,name,count,store,field,name,if,mappings,null,map,string,string,full,mapping,type,collections,singleton,map,file,structure,utils,mapping,type,if,date,equals,mapping,type,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,sample,value,if,timestamp,match,null,full,mapping,type,timestamp,match,get,es,date,mapping,type,with,format,mappings,put,adjusted,field,name,full,mapping,type,return,grok,pattern,name,adjusted,field,name
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> @Override         public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                       Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats);1536611444;Given a collection of strings, and a Grok pattern that matches some part of them all,_return collections of the bits that come before (prefaces) and after (epilogues) the_bit that matches.;@Override_        public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                                      Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats) {_            Collection<String> values = new ArrayList<>()__            for (String snippet : snippets) {_                Map<String, Object> captures = grok.captures(snippet)__                _                if (captures == null) {_                    throw new IllegalStateException("[%{" + grokPatternName + "}] does not match snippet [" + snippet + "]")__                }_                prefaces.add(captures.getOrDefault(PREFACE, "").toString())__                values.add(captures.getOrDefault(VALUE, "").toString())__                epilogues.add(captures.getOrDefault(EPILOGUE, "").toString())__            }_            String adjustedFieldName = buildFieldName(fieldNameCountStore, fieldName)__            if (mappings != null) {_                Map<String, String> fullMappingType = Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, mappingType)__                if ("date".equals(mappingType)) {_                    assert values.isEmpty() == false__                    TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(values.iterator().next())__                    if (timestampMatch != null) {_                        fullMappingType = timestampMatch.getEsDateMappingTypeWithFormat()__                    }_                }_                mappings.put(adjustedFieldName, fullMappingType)__            }_            if (fieldStats != null) {_                fieldStats.put(adjustedFieldName, FileStructureUtils.calculateFieldStats(values))__            }_            return "%{" + grokPatternName + ":" + adjustedFieldName + "}"__        };given,a,collection,of,strings,and,a,grok,pattern,that,matches,some,part,of,them,all,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches;override,public,string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats,collection,string,values,new,array,list,for,string,snippet,snippets,map,string,object,captures,grok,captures,snippet,if,captures,null,throw,new,illegal,state,exception,grok,pattern,name,does,not,match,snippet,snippet,prefaces,add,captures,get,or,default,preface,to,string,values,add,captures,get,or,default,value,to,string,epilogues,add,captures,get,or,default,epilogue,to,string,string,adjusted,field,name,build,field,name,field,name,count,store,field,name,if,mappings,null,map,string,string,full,mapping,type,collections,singleton,map,file,structure,utils,mapping,type,if,date,equals,mapping,type,assert,values,is,empty,false,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,values,iterator,next,if,timestamp,match,null,full,mapping,type,timestamp,match,get,es,date,mapping,type,with,format,mappings,put,adjusted,field,name,full,mapping,type,if,field,stats,null,field,stats,put,adjusted,field,name,file,structure,utils,calculate,field,stats,values,return,grok,pattern,name,adjusted,field,name
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> @Override         public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                       Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats);1536964057;Given a collection of strings, and a Grok pattern that matches some part of them all,_return collections of the bits that come before (prefaces) and after (epilogues) the_bit that matches.;@Override_        public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                                      Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats) {_            Collection<String> values = new ArrayList<>()__            for (String snippet : snippets) {_                Map<String, Object> captures = grok.captures(snippet)__                _                if (captures == null) {_                    throw new IllegalStateException("[%{" + grokPatternName + "}] does not match snippet [" + snippet + "]")__                }_                prefaces.add(captures.getOrDefault(PREFACE, "").toString())__                values.add(captures.getOrDefault(VALUE, "").toString())__                epilogues.add(captures.getOrDefault(EPILOGUE, "").toString())__            }_            String adjustedFieldName = buildFieldName(fieldNameCountStore, fieldName)__            if (mappings != null) {_                Map<String, String> fullMappingType = Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, mappingType)__                if ("date".equals(mappingType)) {_                    assert values.isEmpty() == false__                    TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(values.iterator().next())__                    if (timestampMatch != null) {_                        fullMappingType = timestampMatch.getEsDateMappingTypeWithFormat()__                    }_                }_                mappings.put(adjustedFieldName, fullMappingType)__            }_            if (fieldStats != null) {_                fieldStats.put(adjustedFieldName, FileStructureUtils.calculateFieldStats(values))__            }_            return "%{" + grokPatternName + ":" + adjustedFieldName + "}"__        };given,a,collection,of,strings,and,a,grok,pattern,that,matches,some,part,of,them,all,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches;override,public,string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats,collection,string,values,new,array,list,for,string,snippet,snippets,map,string,object,captures,grok,captures,snippet,if,captures,null,throw,new,illegal,state,exception,grok,pattern,name,does,not,match,snippet,snippet,prefaces,add,captures,get,or,default,preface,to,string,values,add,captures,get,or,default,value,to,string,epilogues,add,captures,get,or,default,epilogue,to,string,string,adjusted,field,name,build,field,name,field,name,count,store,field,name,if,mappings,null,map,string,string,full,mapping,type,collections,singleton,map,file,structure,utils,mapping,type,if,date,equals,mapping,type,assert,values,is,empty,false,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,values,iterator,next,if,timestamp,match,null,full,mapping,type,timestamp,match,get,es,date,mapping,type,with,format,mappings,put,adjusted,field,name,full,mapping,type,if,field,stats,null,field,stats,put,adjusted,field,name,file,structure,utils,calculate,field,stats,values,return,grok,pattern,name,adjusted,field,name
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> @Override         public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                       Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats,                                       TimeoutChecker timeoutChecker);1538170812;Given a collection of strings, and a Grok pattern that matches some part of them all,_return collections of the bits that come before (prefaces) and after (epilogues) the_bit that matches.;@Override_        public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                                      Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats,_                                      TimeoutChecker timeoutChecker) {_            Collection<String> values = new ArrayList<>()__            for (String snippet : snippets) {_                Map<String, Object> captures = grok.captures(snippet)__                _                if (captures == null) {_                    throw new IllegalStateException("[%{" + grokPatternName + "}] does not match snippet [" + snippet + "]")__                }_                prefaces.add(captures.getOrDefault(PREFACE, "").toString())__                values.add(captures.getOrDefault(VALUE, "").toString())__                epilogues.add(captures.getOrDefault(EPILOGUE, "").toString())__                timeoutChecker.check("full message Grok pattern field extraction")__            }_            String adjustedFieldName = buildFieldName(fieldNameCountStore, fieldName)__            if (mappings != null) {_                Map<String, String> fullMappingType = Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, mappingType)__                if ("date".equals(mappingType)) {_                    assert values.isEmpty() == false__                    TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(values.iterator().next())__                    if (timestampMatch != null) {_                        fullMappingType = timestampMatch.getEsDateMappingTypeWithFormat()__                    }_                    timeoutChecker.check("mapping determination")__                }_                mappings.put(adjustedFieldName, fullMappingType)__            }_            if (fieldStats != null) {_                fieldStats.put(adjustedFieldName, FileStructureUtils.calculateFieldStats(values, timeoutChecker))__            }_            return "%{" + grokPatternName + ":" + adjustedFieldName + "}"__        };given,a,collection,of,strings,and,a,grok,pattern,that,matches,some,part,of,them,all,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches;override,public,string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats,timeout,checker,timeout,checker,collection,string,values,new,array,list,for,string,snippet,snippets,map,string,object,captures,grok,captures,snippet,if,captures,null,throw,new,illegal,state,exception,grok,pattern,name,does,not,match,snippet,snippet,prefaces,add,captures,get,or,default,preface,to,string,values,add,captures,get,or,default,value,to,string,epilogues,add,captures,get,or,default,epilogue,to,string,timeout,checker,check,full,message,grok,pattern,field,extraction,string,adjusted,field,name,build,field,name,field,name,count,store,field,name,if,mappings,null,map,string,string,full,mapping,type,collections,singleton,map,file,structure,utils,mapping,type,if,date,equals,mapping,type,assert,values,is,empty,false,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,values,iterator,next,if,timestamp,match,null,full,mapping,type,timestamp,match,get,es,date,mapping,type,with,format,timeout,checker,check,mapping,determination,mappings,put,adjusted,field,name,full,mapping,type,if,field,stats,null,field,stats,put,adjusted,field,name,file,structure,utils,calculate,field,stats,values,timeout,checker,return,grok,pattern,name,adjusted,field,name
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> @Override         public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,                                       Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats,                                       TimeoutChecker timeoutChecker);1544771889;Given a collection of strings, and a Grok pattern that matches some part of them all,_return collections of the bits that come before (prefaces) and after (epilogues) the_bit that matches.;@Override_        public String processCaptures(Map<String, Integer> fieldNameCountStore, Collection<String> snippets, Collection<String> prefaces,_                                      Collection<String> epilogues, Map<String, Object> mappings, Map<String, FieldStats> fieldStats,_                                      TimeoutChecker timeoutChecker) {_            Collection<String> values = new ArrayList<>()__            for (String snippet : snippets) {_                Map<String, Object> captures = timeoutChecker.grokCaptures(grok, snippet, "full message Grok pattern field extraction")__                _                if (captures == null) {_                    throw new IllegalStateException("[%{" + grokPatternName + "}] does not match snippet [" + snippet + "]")__                }_                prefaces.add(captures.getOrDefault(PREFACE, "").toString())__                values.add(captures.getOrDefault(VALUE, "").toString())__                epilogues.add(captures.getOrDefault(EPILOGUE, "").toString())__            }_            String adjustedFieldName = buildFieldName(fieldNameCountStore, fieldName)__            if (mappings != null) {_                Map<String, String> fullMappingType = Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, mappingType)__                if ("date".equals(mappingType)) {_                    assert values.isEmpty() == false__                    TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(values.iterator().next(), timeoutChecker)__                    if (timestampMatch != null) {_                        fullMappingType = timestampMatch.getEsDateMappingTypeWithFormat()__                    }_                    timeoutChecker.check("mapping determination")__                }_                mappings.put(adjustedFieldName, fullMappingType)__            }_            if (fieldStats != null) {_                fieldStats.put(adjustedFieldName, FileStructureUtils.calculateFieldStats(values, timeoutChecker))__            }_            return "%{" + grokPatternName + ":" + adjustedFieldName + "}"__        };given,a,collection,of,strings,and,a,grok,pattern,that,matches,some,part,of,them,all,return,collections,of,the,bits,that,come,before,prefaces,and,after,epilogues,the,bit,that,matches;override,public,string,process,captures,map,string,integer,field,name,count,store,collection,string,snippets,collection,string,prefaces,collection,string,epilogues,map,string,object,mappings,map,string,field,stats,field,stats,timeout,checker,timeout,checker,collection,string,values,new,array,list,for,string,snippet,snippets,map,string,object,captures,timeout,checker,grok,captures,grok,snippet,full,message,grok,pattern,field,extraction,if,captures,null,throw,new,illegal,state,exception,grok,pattern,name,does,not,match,snippet,snippet,prefaces,add,captures,get,or,default,preface,to,string,values,add,captures,get,or,default,value,to,string,epilogues,add,captures,get,or,default,epilogue,to,string,string,adjusted,field,name,build,field,name,field,name,count,store,field,name,if,mappings,null,map,string,string,full,mapping,type,collections,singleton,map,file,structure,utils,mapping,type,if,date,equals,mapping,type,assert,values,is,empty,false,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,values,iterator,next,timeout,checker,if,timestamp,match,null,full,mapping,type,timestamp,match,get,es,date,mapping,type,with,format,timeout,checker,check,mapping,determination,mappings,put,adjusted,field,name,full,mapping,type,if,field,stats,null,field,stats,put,adjusted,field,name,file,structure,utils,calculate,field,stats,values,timeout,checker,return,grok,pattern,name,adjusted,field,name
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName);1536314350;Pre/post breaks default to \b, but this may not be appropriate for Grok patterns that start or_end with a non "word" character (i.e. letter, number or underscore).  For such patterns use one_of the other constructors._<p>_In cases where the Grok pattern defined by Logstash already includes conditions on what must_come before and after the match, use one of the other constructors and specify an empty string_for the pre and/or post breaks.__@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName) {_            this(grokPatternName, mappingType, fieldName, "\\b", "\\b")__        };pre,post,breaks,default,to,b,but,this,may,not,be,appropriate,for,grok,patterns,that,start,or,end,with,a,non,word,character,i,e,letter,number,or,underscore,for,such,patterns,use,one,of,the,other,constructors,p,in,cases,where,the,grok,pattern,defined,by,logstash,already,includes,conditions,on,what,must,come,before,and,after,the,match,use,one,of,the,other,constructors,and,specify,an,empty,string,for,the,pre,and,or,post,breaks,param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,this,grok,pattern,name,mapping,type,field,name,b,b
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName);1536611444;Pre/post breaks default to \b, but this may not be appropriate for Grok patterns that start or_end with a non "word" character (i.e. letter, number or underscore).  For such patterns use one_of the other constructors._<p>_In cases where the Grok pattern defined by Logstash already includes conditions on what must_come before and after the match, use one of the other constructors and specify an empty string_for the pre and/or post breaks.__@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName) {_            this(grokPatternName, mappingType, fieldName, "\\b", "\\b")__        };pre,post,breaks,default,to,b,but,this,may,not,be,appropriate,for,grok,patterns,that,start,or,end,with,a,non,word,character,i,e,letter,number,or,underscore,for,such,patterns,use,one,of,the,other,constructors,p,in,cases,where,the,grok,pattern,defined,by,logstash,already,includes,conditions,on,what,must,come,before,and,after,the,match,use,one,of,the,other,constructors,and,specify,an,empty,string,for,the,pre,and,or,post,breaks,param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,this,grok,pattern,name,mapping,type,field,name,b,b
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName);1536964057;Pre/post breaks default to \b, but this may not be appropriate for Grok patterns that start or_end with a non "word" character (i.e. letter, number or underscore).  For such patterns use one_of the other constructors._<p>_In cases where the Grok pattern defined by Logstash already includes conditions on what must_come before and after the match, use one of the other constructors and specify an empty string_for the pre and/or post breaks.__@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName) {_            this(grokPatternName, mappingType, fieldName, "\\b", "\\b")__        };pre,post,breaks,default,to,b,but,this,may,not,be,appropriate,for,grok,patterns,that,start,or,end,with,a,non,word,character,i,e,letter,number,or,underscore,for,such,patterns,use,one,of,the,other,constructors,p,in,cases,where,the,grok,pattern,defined,by,logstash,already,includes,conditions,on,what,must,come,before,and,after,the,match,use,one,of,the,other,constructors,and,specify,an,empty,string,for,the,pre,and,or,post,breaks,param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,this,grok,pattern,name,mapping,type,field,name,b,b
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName);1538170812;Pre/post breaks default to \b, but this may not be appropriate for Grok patterns that start or_end with a non "word" character (i.e. letter, number or underscore).  For such patterns use one_of the other constructors._<p>_In cases where the Grok pattern defined by Logstash already includes conditions on what must_come before and after the match, use one of the other constructors and specify an empty string_for the pre and/or post breaks.__@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName) {_            this(grokPatternName, mappingType, fieldName, "\\b", "\\b")__        };pre,post,breaks,default,to,b,but,this,may,not,be,appropriate,for,grok,patterns,that,start,or,end,with,a,non,word,character,i,e,letter,number,or,underscore,for,such,patterns,use,one,of,the,other,constructors,p,in,cases,where,the,grok,pattern,defined,by,logstash,already,includes,conditions,on,what,must,come,before,and,after,the,match,use,one,of,the,other,constructors,and,specify,an,empty,string,for,the,pre,and,or,post,breaks,param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,this,grok,pattern,name,mapping,type,field,name,b,b
GrokPatternCreator -> ValueOnlyGrokPatternCandidate -> ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName);1544771889;Pre/post breaks default to \b, but this may not be appropriate for Grok patterns that start or_end with a non "word" character (i.e. letter, number or underscore).  For such patterns use one_of the other constructors._<p>_In cases where the Grok pattern defined by Logstash already includes conditions on what must_come before and after the match, use one of the other constructors and specify an empty string_for the pre and/or post breaks.__@param grokPatternName Name of the Grok pattern to try to match - must match one defined in Logstash._@param fieldName       Name of the field to extract from the match.;ValueOnlyGrokPatternCandidate(String grokPatternName, String mappingType, String fieldName) {_            this(grokPatternName, mappingType, fieldName, "\\b", "\\b")__        };pre,post,breaks,default,to,b,but,this,may,not,be,appropriate,for,grok,patterns,that,start,or,end,with,a,non,word,character,i,e,letter,number,or,underscore,for,such,patterns,use,one,of,the,other,constructors,p,in,cases,where,the,grok,pattern,defined,by,logstash,already,includes,conditions,on,what,must,come,before,and,after,the,match,use,one,of,the,other,constructors,and,specify,an,empty,string,for,the,pre,and,or,post,breaks,param,grok,pattern,name,name,of,the,grok,pattern,to,try,to,match,must,match,one,defined,in,logstash,param,field,name,name,of,the,field,to,extract,from,the,match;value,only,grok,pattern,candidate,string,grok,pattern,name,string,mapping,type,string,field,name,this,grok,pattern,name,mapping,type,field,name,b,b
