commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;1;;protected XPackLicenseState getLicenseState() {     return XPackPlugin.getSharedLicenseState(). }
false;public,static;1;8;;public static boolean isMlNode(DiscoveryNode node) {     Map<String, String> nodeAttributes = node.getAttributes().     try {         return Integer.parseInt(nodeAttributes.get(MAX_OPEN_JOBS_NODE_ATTR)) > 0.     } catch (NumberFormatException e) {         return false.     } }
false;public;0;14;;public List<Setting<?>> getSettings() {     return Collections.unmodifiableList(Arrays.asList(MachineLearningField.AUTODETECT_PROCESS, ML_ENABLED, CONCURRENT_JOB_ALLOCATIONS, MachineLearningField.MAX_MODEL_MEMORY_LIMIT, MAX_LAZY_ML_NODES, MAX_MACHINE_MEMORY_PERCENT, AutodetectBuilder.DONT_PERSIST_MODEL_STATE_SETTING, AutodetectBuilder.MAX_ANOMALY_RECORDS_SETTING_DYNAMIC, AutodetectProcessManager.MAX_OPEN_JOBS_PER_NODE, AutodetectProcessManager.MIN_DISK_SPACE_OFF_HEAP, MlConfigMigrationEligibilityCheck.ENABLE_CONFIG_MIGRATION)). }
false;public;0;24;;public Settings additionalSettings() {     String mlEnabledNodeAttrName = "node.attr." + PRE_V7_ML_ENABLED_NODE_ATTR.     String maxOpenJobsPerNodeNodeAttrName = "node.attr." + MAX_OPEN_JOBS_NODE_ATTR.     String machineMemoryAttrName = "node.attr." + MACHINE_MEMORY_NODE_ATTR.     if (enabled == false || transportClientMode) {         disallowMlNodeAttributes(mlEnabledNodeAttrName, maxOpenJobsPerNodeNodeAttrName, machineMemoryAttrName).         return Settings.EMPTY.     }     Settings.Builder additionalSettings = Settings.builder().     Boolean allocationEnabled = ML_ENABLED.get(settings).     if (allocationEnabled != null && allocationEnabled) {         addMlNodeAttribute(additionalSettings, maxOpenJobsPerNodeNodeAttrName, String.valueOf(AutodetectProcessManager.MAX_OPEN_JOBS_PER_NODE.get(settings))).         addMlNodeAttribute(additionalSettings, machineMemoryAttrName, Long.toString(machineMemoryFromStats(OsProbe.getInstance().osStats()))).         // This is not used in v7 and higher, but users are still prevented from setting it directly to avoid confusion         disallowMlNodeAttributes(mlEnabledNodeAttrName).     } else {         disallowMlNodeAttributes(mlEnabledNodeAttrName, maxOpenJobsPerNodeNodeAttrName, machineMemoryAttrName).     }     return additionalSettings.build(). }
false;private;3;8;;private void addMlNodeAttribute(Settings.Builder additionalSettings, String attrName, String value) {     String oldValue = settings.get(attrName).     if (oldValue == null) {         additionalSettings.put(attrName, value).     } else {         reportClashingNodeAttribute(attrName).     } }
false;private;1;7;;private void disallowMlNodeAttributes(String... mlNodeAttributes) {     for (String attrName : mlNodeAttributes) {         if (settings.get(attrName) != null) {             reportClashingNodeAttribute(attrName).         }     } }
false;private;1;5;;private void reportClashingNodeAttribute(String attrName) {     throw new IllegalArgumentException("Directly setting [" + attrName + "] is not permitted - " + "it is reserved for machine learning. If your intention was to customize machine learning, set the [" + attrName.replace("node.attr.", "xpack.") + "] setting instead."). }
true;protected;0;3;// overridable by tests ;// overridable by tests protected Clock getClock() {     return Clock.systemUTC(). }
false;public;9;88;;@Override public Collection<Object> createComponents(Client client, ClusterService clusterService, ThreadPool threadPool, ResourceWatcherService resourceWatcherService, ScriptService scriptService, NamedXContentRegistry xContentRegistry, Environment environment, NodeEnvironment nodeEnvironment, NamedWriteableRegistry namedWriteableRegistry) {     if (enabled == false || transportClientMode) {         // special holder for @link(MachineLearningFeatureSetUsage) which needs access to job manager, empty if ML is disabled         return Collections.singletonList(new JobManagerHolder()).     }     Auditor auditor = new Auditor(client, clusterService.getNodeName()).     JobResultsProvider jobResultsProvider = new JobResultsProvider(client, settings).     JobConfigProvider jobConfigProvider = new JobConfigProvider(client).     DatafeedConfigProvider datafeedConfigProvider = new DatafeedConfigProvider(client, xContentRegistry).     UpdateJobProcessNotifier notifier = new UpdateJobProcessNotifier(client, clusterService, threadPool).     JobManager jobManager = new JobManager(env, settings, jobResultsProvider, clusterService, auditor, threadPool, client, notifier).     // special holder for @link(MachineLearningFeatureSetUsage) which needs access to job manager if ML is enabled     JobManagerHolder jobManagerHolder = new JobManagerHolder(jobManager).     JobDataCountsPersister jobDataCountsPersister = new JobDataCountsPersister(client).     JobResultsPersister jobResultsPersister = new JobResultsPersister(client).     AutodetectProcessFactory autodetectProcessFactory.     NormalizerProcessFactory normalizerProcessFactory.     if (MachineLearningField.AUTODETECT_PROCESS.get(settings) && MachineLearningFeatureSet.isRunningOnMlPlatform(true)) {         try {             NativeController nativeController = NativeControllerHolder.getNativeController(environment).             if (nativeController == null) {                 // This will only only happen when path.home is not set, which is disallowed in production                 throw new ElasticsearchException("Failed to create native process controller for Machine Learning").             }             autodetectProcessFactory = new NativeAutodetectProcessFactory(environment, settings, nativeController, client, clusterService).             normalizerProcessFactory = new NativeNormalizerProcessFactory(environment, nativeController).         } catch (IOException e) {             // hit the same error first and brought down the node with a friendlier error message             throw new ElasticsearchException("Failed to create native process factories for Machine Learning", e).         }     } else {         autodetectProcessFactory = (job, autodetectParams, executorService, onProcessCrash) -> new BlackHoleAutodetectProcess(job.getId()).         // factor of 1.0 makes renormalization a no-op         normalizerProcessFactory = (jobId, quantilesState, bucketSpan, executorService) -> new MultiplyingNormalizerProcess(1.0).     }     NormalizerFactory normalizerFactory = new NormalizerFactory(normalizerProcessFactory, threadPool.executor(MachineLearning.UTILITY_THREAD_POOL_NAME)).     AutodetectProcessManager autodetectProcessManager = new AutodetectProcessManager(env, settings, client, threadPool, jobManager, jobResultsProvider, jobResultsPersister, jobDataCountsPersister, autodetectProcessFactory, normalizerFactory, xContentRegistry, auditor, clusterService).     this.autodetectProcessManager.set(autodetectProcessManager).     DatafeedJobBuilder datafeedJobBuilder = new DatafeedJobBuilder(client, settings, xContentRegistry, auditor, System::currentTimeMillis).     DatafeedManager datafeedManager = new DatafeedManager(threadPool, client, clusterService, datafeedJobBuilder, System::currentTimeMillis, auditor, autodetectProcessManager).     this.datafeedManager.set(datafeedManager).     MlMemoryTracker memoryTracker = new MlMemoryTracker(settings, clusterService, threadPool, jobManager, jobResultsProvider).     this.memoryTracker.set(memoryTracker).     MlLifeCycleService mlLifeCycleService = new MlLifeCycleService(environment, clusterService, datafeedManager, autodetectProcessManager, memoryTracker).     // This object's constructor attaches to the license state, so there's no need to retain another reference to it     new InvalidLicenseEnforcer(getLicenseState(), threadPool, datafeedManager, autodetectProcessManager).     // run node startup tasks     autodetectProcessManager.onNodeStartup().     return Arrays.asList(mlLifeCycleService, jobResultsProvider, jobConfigProvider, datafeedConfigProvider, jobManager, jobManagerHolder, autodetectProcessManager, new MlInitializationService(settings, threadPool, clusterService, client), jobDataCountsPersister, datafeedManager, auditor, new MlAssignmentNotifier(settings, auditor, threadPool, client, clusterService), memoryTracker). }
false;public;4;14;;public List<PersistentTasksExecutor<?>> getPersistentTasksExecutor(ClusterService clusterService, ThreadPool threadPool, Client client, SettingsModule settingsModule) {     if (enabled == false || transportClientMode) {         return emptyList().     }     return Arrays.asList(new TransportOpenJobAction.OpenJobPersistentTasksExecutor(settings, clusterService, autodetectProcessManager.get(), memoryTracker.get(), client), new TransportStartDatafeedAction.StartDatafeedPersistentTasksExecutor(datafeedManager.get())). }
false;public;0;13;;public Collection<Module> createGuiceModules() {     List<Module> modules = new ArrayList<>().     if (transportClientMode) {         return modules.     }     modules.add(b -> {         XPackPlugin.bindFeatureSet(b, MachineLearningFeatureSet.class).     }).     return modules. }
false;public;7;57;;@Override public List<RestHandler> getRestHandlers(Settings settings, RestController restController, ClusterSettings clusterSettings, IndexScopedSettings indexScopedSettings, SettingsFilter settingsFilter, IndexNameExpressionResolver indexNameExpressionResolver, Supplier<DiscoveryNodes> nodesInCluster) {     if (false == enabled) {         return emptyList().     }     return Arrays.asList(new RestGetJobsAction(settings, restController), new RestGetJobStatsAction(settings, restController), new RestMlInfoAction(settings, restController), new RestPutJobAction(settings, restController), new RestPostJobUpdateAction(settings, restController), new RestDeleteJobAction(settings, restController), new RestOpenJobAction(settings, restController), new RestGetFiltersAction(settings, restController), new RestPutFilterAction(settings, restController), new RestUpdateFilterAction(settings, restController), new RestDeleteFilterAction(settings, restController), new RestGetInfluencersAction(settings, restController), new RestGetRecordsAction(settings, restController), new RestGetBucketsAction(settings, restController), new RestGetOverallBucketsAction(settings, restController), new RestPostDataAction(settings, restController), new RestCloseJobAction(settings, restController), new RestFlushJobAction(settings, restController), new RestValidateDetectorAction(settings, restController), new RestValidateJobConfigAction(settings, restController), new RestGetCategoriesAction(settings, restController), new RestGetModelSnapshotsAction(settings, restController), new RestRevertModelSnapshotAction(settings, restController), new RestUpdateModelSnapshotAction(settings, restController), new RestGetDatafeedsAction(settings, restController), new RestGetDatafeedStatsAction(settings, restController), new RestPutDatafeedAction(settings, restController), new RestUpdateDatafeedAction(settings, restController), new RestDeleteDatafeedAction(settings, restController), new RestPreviewDatafeedAction(settings, restController), new RestStartDatafeedAction(settings, restController), new RestStopDatafeedAction(settings, restController), new RestDeleteModelSnapshotAction(settings, restController), new RestDeleteExpiredDataAction(settings, restController), new RestForecastJobAction(settings, restController), new RestDeleteForecastAction(settings, restController), new RestGetCalendarsAction(settings, restController), new RestPutCalendarAction(settings, restController), new RestDeleteCalendarAction(settings, restController), new RestDeleteCalendarEventAction(settings, restController), new RestDeleteCalendarJobAction(settings, restController), new RestPutCalendarJobAction(settings, restController), new RestGetCalendarEventsAction(settings, restController), new RestPostCalendarEventAction(settings, restController), new RestFindFileStructureAction(settings, restController), new RestSetUpgradeModeAction(settings, restController)). }
false;public;0;58;;@Override public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {     if (false == enabled) {         return emptyList().     }     return Arrays.asList(new ActionHandler<>(GetJobsAction.INSTANCE, TransportGetJobsAction.class), new ActionHandler<>(GetJobsStatsAction.INSTANCE, TransportGetJobsStatsAction.class), new ActionHandler<>(MlInfoAction.INSTANCE, TransportMlInfoAction.class), new ActionHandler<>(PutJobAction.INSTANCE, TransportPutJobAction.class), new ActionHandler<>(UpdateJobAction.INSTANCE, TransportUpdateJobAction.class), new ActionHandler<>(DeleteJobAction.INSTANCE, TransportDeleteJobAction.class), new ActionHandler<>(OpenJobAction.INSTANCE, TransportOpenJobAction.class), new ActionHandler<>(GetFiltersAction.INSTANCE, TransportGetFiltersAction.class), new ActionHandler<>(PutFilterAction.INSTANCE, TransportPutFilterAction.class), new ActionHandler<>(UpdateFilterAction.INSTANCE, TransportUpdateFilterAction.class), new ActionHandler<>(DeleteFilterAction.INSTANCE, TransportDeleteFilterAction.class), new ActionHandler<>(KillProcessAction.INSTANCE, TransportKillProcessAction.class), new ActionHandler<>(GetBucketsAction.INSTANCE, TransportGetBucketsAction.class), new ActionHandler<>(GetInfluencersAction.INSTANCE, TransportGetInfluencersAction.class), new ActionHandler<>(GetOverallBucketsAction.INSTANCE, TransportGetOverallBucketsAction.class), new ActionHandler<>(GetRecordsAction.INSTANCE, TransportGetRecordsAction.class), new ActionHandler<>(PostDataAction.INSTANCE, TransportPostDataAction.class), new ActionHandler<>(CloseJobAction.INSTANCE, TransportCloseJobAction.class), new ActionHandler<>(FinalizeJobExecutionAction.INSTANCE, TransportFinalizeJobExecutionAction.class), new ActionHandler<>(FlushJobAction.INSTANCE, TransportFlushJobAction.class), new ActionHandler<>(ValidateDetectorAction.INSTANCE, TransportValidateDetectorAction.class), new ActionHandler<>(ValidateJobConfigAction.INSTANCE, TransportValidateJobConfigAction.class), new ActionHandler<>(GetCategoriesAction.INSTANCE, TransportGetCategoriesAction.class), new ActionHandler<>(GetModelSnapshotsAction.INSTANCE, TransportGetModelSnapshotsAction.class), new ActionHandler<>(RevertModelSnapshotAction.INSTANCE, TransportRevertModelSnapshotAction.class), new ActionHandler<>(UpdateModelSnapshotAction.INSTANCE, TransportUpdateModelSnapshotAction.class), new ActionHandler<>(GetDatafeedsAction.INSTANCE, TransportGetDatafeedsAction.class), new ActionHandler<>(GetDatafeedsStatsAction.INSTANCE, TransportGetDatafeedsStatsAction.class), new ActionHandler<>(PutDatafeedAction.INSTANCE, TransportPutDatafeedAction.class), new ActionHandler<>(UpdateDatafeedAction.INSTANCE, TransportUpdateDatafeedAction.class), new ActionHandler<>(DeleteDatafeedAction.INSTANCE, TransportDeleteDatafeedAction.class), new ActionHandler<>(PreviewDatafeedAction.INSTANCE, TransportPreviewDatafeedAction.class), new ActionHandler<>(StartDatafeedAction.INSTANCE, TransportStartDatafeedAction.class), new ActionHandler<>(StopDatafeedAction.INSTANCE, TransportStopDatafeedAction.class), new ActionHandler<>(IsolateDatafeedAction.INSTANCE, TransportIsolateDatafeedAction.class), new ActionHandler<>(DeleteModelSnapshotAction.INSTANCE, TransportDeleteModelSnapshotAction.class), new ActionHandler<>(UpdateProcessAction.INSTANCE, TransportUpdateProcessAction.class), new ActionHandler<>(DeleteExpiredDataAction.INSTANCE, TransportDeleteExpiredDataAction.class), new ActionHandler<>(ForecastJobAction.INSTANCE, TransportForecastJobAction.class), new ActionHandler<>(DeleteForecastAction.INSTANCE, TransportDeleteForecastAction.class), new ActionHandler<>(GetCalendarsAction.INSTANCE, TransportGetCalendarsAction.class), new ActionHandler<>(PutCalendarAction.INSTANCE, TransportPutCalendarAction.class), new ActionHandler<>(DeleteCalendarAction.INSTANCE, TransportDeleteCalendarAction.class), new ActionHandler<>(DeleteCalendarEventAction.INSTANCE, TransportDeleteCalendarEventAction.class), new ActionHandler<>(UpdateCalendarJobAction.INSTANCE, TransportUpdateCalendarJobAction.class), new ActionHandler<>(GetCalendarEventsAction.INSTANCE, TransportGetCalendarEventsAction.class), new ActionHandler<>(PostCalendarEventsAction.INSTANCE, TransportPostCalendarEventsAction.class), new ActionHandler<>(PersistJobAction.INSTANCE, TransportPersistJobAction.class), new ActionHandler<>(FindFileStructureAction.INSTANCE, TransportFindFileStructureAction.class), new ActionHandler<>(SetUpgradeModeAction.INSTANCE, TransportSetUpgradeModeAction.class)). }
false;public;1;24;;@Override public List<ExecutorBuilder<?>> getExecutorBuilders(Settings settings) {     if (false == enabled || transportClientMode) {         return emptyList().     }     int maxNumberOfJobs = AutodetectProcessManager.MAX_OPEN_JOBS_PER_NODE.get(settings).     // 4 threads per job: for cpp logging, result processing, state processing and     // AutodetectProcessManager worker thread:     FixedExecutorBuilder autoDetect = new FixedExecutorBuilder(settings, AUTODETECT_THREAD_POOL_NAME, maxNumberOfJobs * 4, maxNumberOfJobs * 4, "xpack.ml.autodetect_thread_pool").     // 4 threads per job: processing logging, result and state of the renormalization process.     // Renormalization does't run for the entire lifetime of a job, so additionally autodetect process     // based operation (open, close, flush, post data), datafeed based operations (start and stop)     // and deleting expired data use this threadpool too and queue up if all threads are busy.     FixedExecutorBuilder renormalizer = new FixedExecutorBuilder(settings, UTILITY_THREAD_POOL_NAME, maxNumberOfJobs * 4, 500, "xpack.ml.utility_thread_pool").     // TODO: if datafeed and non datafeed jobs are considered more equal and the datafeed and     // autodetect process are created at the same time then these two different TPs can merge.     FixedExecutorBuilder datafeed = new FixedExecutorBuilder(settings, DATAFEED_THREAD_POOL_NAME, maxNumberOfJobs, 200, "xpack.ml.datafeed_thread_pool").     return Arrays.asList(autoDetect, renormalizer, datafeed). }
false;public;0;4;;@Override public Map<String, AnalysisProvider<TokenizerFactory>> getTokenizers() {     return Collections.singletonMap(MlClassicTokenizer.NAME, MlClassicTokenizerFactory::new). }
false;public;0;103;;@Override public UnaryOperator<Map<String, IndexTemplateMetaData>> getIndexTemplateMetaDataUpgrader() {     return templates -> {         final TimeValue delayedNodeTimeOutSetting.         // Whether we are using native process is a good way to detect whether we are in dev / test mode:         if (MachineLearningField.AUTODETECT_PROCESS.get(settings)) {             delayedNodeTimeOutSetting = UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings).         } else {             delayedNodeTimeOutSetting = TimeValue.timeValueNanos(0).         }         try (XContentBuilder auditMapping = ElasticsearchMappings.auditMessageMapping()) {             IndexTemplateMetaData notificationMessageTemplate = IndexTemplateMetaData.builder(AuditorField.NOTIFICATIONS_INDEX).putMapping(SINGLE_MAPPING_NAME, Strings.toString(auditMapping)).patterns(Collections.singletonList(AuditorField.NOTIFICATIONS_INDEX)).version(Version.CURRENT.id).settings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, "0-1").put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), delayedNodeTimeOutSetting)).build().             templates.put(AuditorField.NOTIFICATIONS_INDEX, notificationMessageTemplate).         } catch (IOException e) {             logger.warn("Error loading the template for the notification message index", e).         }         try (XContentBuilder docMapping = MlMetaIndex.docMapping()) {             IndexTemplateMetaData metaTemplate = IndexTemplateMetaData.builder(MlMetaIndex.INDEX_NAME).patterns(Collections.singletonList(MlMetaIndex.INDEX_NAME)).settings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, "0-1").put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), delayedNodeTimeOutSetting)).version(Version.CURRENT.id).putMapping(SINGLE_MAPPING_NAME, Strings.toString(docMapping)).build().             templates.put(MlMetaIndex.INDEX_NAME, metaTemplate).         } catch (IOException e) {             logger.warn("Error loading the template for the " + MlMetaIndex.INDEX_NAME + " index", e).         }         try (XContentBuilder configMapping = ElasticsearchMappings.configMapping()) {             IndexTemplateMetaData configTemplate = IndexTemplateMetaData.builder(AnomalyDetectorsIndex.configIndexName()).patterns(Collections.singletonList(AnomalyDetectorsIndex.configIndexName())).settings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, "0-1").put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), delayedNodeTimeOutSetting).put(IndexSettings.MAX_RESULT_WINDOW_SETTING.getKey(), AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)).version(Version.CURRENT.id).putMapping(SINGLE_MAPPING_NAME, Strings.toString(configMapping)).build().             templates.put(AnomalyDetectorsIndex.configIndexName(), configTemplate).         } catch (IOException e) {             logger.warn("Error loading the template for the " + AnomalyDetectorsIndex.configIndexName() + " index", e).         }         try (XContentBuilder stateMapping = ElasticsearchMappings.stateMapping()) {             IndexTemplateMetaData stateTemplate = IndexTemplateMetaData.builder(AnomalyDetectorsIndexFields.STATE_INDEX_PREFIX).patterns(Collections.singletonList(AnomalyDetectorsIndex.jobStateIndexPattern())).settings(Settings.builder().put(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, "0-1").put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), delayedNodeTimeOutSetting)).putMapping(SINGLE_MAPPING_NAME, Strings.toString(stateMapping)).version(Version.CURRENT.id).build().             templates.put(AnomalyDetectorsIndexFields.STATE_INDEX_PREFIX, stateTemplate).         } catch (IOException e) {             logger.error("Error loading the template for the " + AnomalyDetectorsIndexFields.STATE_INDEX_PREFIX + " index", e).         }         try (XContentBuilder docMapping = ElasticsearchMappings.resultsMapping(SINGLE_MAPPING_NAME)) {             IndexTemplateMetaData jobResultsTemplate = IndexTemplateMetaData.builder(AnomalyDetectorsIndex.jobResultsIndexPrefix()).patterns(Collections.singletonList(AnomalyDetectorsIndex.jobResultsIndexPrefix() + "*")).settings(Settings.builder().put(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, "0-1").put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), delayedNodeTimeOutSetting).put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), "async").put(IndexSettings.DEFAULT_FIELD_SETTING.getKey(), ElasticsearchMappings.ALL_FIELD_VALUES)).putMapping(SINGLE_MAPPING_NAME, Strings.toString(docMapping)).version(Version.CURRENT.id).build().             templates.put(AnomalyDetectorsIndex.jobResultsIndexPrefix(), jobResultsTemplate).         } catch (IOException e) {             logger.error("Error loading the template for the " + AnomalyDetectorsIndex.jobResultsIndexPrefix() + " indices", e).         }         return templates.     }. }
false;public,static;1;10;;public static boolean allTemplatesInstalled(ClusterState clusterState) {     boolean allPresent = true.     List<String> templateNames = Arrays.asList(AuditorField.NOTIFICATIONS_INDEX, MlMetaIndex.INDEX_NAME, AnomalyDetectorsIndexFields.STATE_INDEX_PREFIX, AnomalyDetectorsIndex.jobResultsIndexPrefix()).     for (String templateName : templateNames) {         allPresent = allPresent && TemplateUtils.checkTemplateExistsAndVersionIsGTECurrentVersion(templateName, clusterState).     }     return allPresent. }
true;static;1;16;/**  * Find the memory size (in bytes) of the machine this node is running on.  * Takes container limits (as used by Docker for example) into account.  */ ;/**  * Find the memory size (in bytes) of the machine this node is running on.  * Takes container limits (as used by Docker for example) into account.  */ static long machineMemoryFromStats(OsStats stats) {     long mem = stats.getMem().getTotal().getBytes().     OsStats.Cgroup cgroup = stats.getCgroup().     if (cgroup != null) {         String containerLimitStr = cgroup.getMemoryLimitInBytes().         if (containerLimitStr != null) {             BigInteger containerLimit = new BigInteger(containerLimitStr).             if ((containerLimit.compareTo(BigInteger.valueOf(mem)) < 0 && containerLimit.compareTo(BigInteger.ZERO) > 0) || // mem < 0 means the value couldn't be obtained for some reason             (mem < 0 && containerLimit.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0)) {                 mem = containerLimit.longValue().             }         }     }     return mem. }
