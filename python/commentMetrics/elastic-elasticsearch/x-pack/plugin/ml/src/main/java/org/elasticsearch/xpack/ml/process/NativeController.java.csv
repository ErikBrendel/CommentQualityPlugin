commented;modifiers;parameterAmount;loc;comment;code
false;;0;19;;void tailLogsInThread() {     final Thread logTailThread = new Thread(() -> {         try {             cppLogHandler.tailStream().             cppLogHandler.close().         } catch (IOException e) {             LOGGER.error("Error tailing C++ controller logs", e).         }         LOGGER.info("Native controller process has stopped - no new native processes can be started").     }, "ml-cpp-log-tail-thread").     /*          * This thread is created on the main thread so would default to being a user thread which could prevent the JVM from exiting if          * this thread were to still be running during shutdown. As such, we mark it as a daemon thread.          */     logTailThread.setDaemon(true).     logTailThread.start(). }
false;public;0;3;;public long getPid() throws TimeoutException {     return cppLogHandler.getPid(CONTROLLER_CONNECT_TIMEOUT). }
false;public;0;3;;public Map<String, Object> getNativeCodeInfo() throws TimeoutException {     return cppLogHandler.getNativeCodeInfo(CONTROLLER_CONNECT_TIMEOUT). }
false;public;1;32;;public void startProcess(List<String> command) throws IOException {     if (command.isEmpty()) {         throw new IllegalArgumentException("Cannot start process: no command supplied").     }     // Sanity check to avoid hard-to-debug errors - tabs and newlines will confuse the controller process     for (String arg : command) {         if (arg.contains("\t")) {             throw new IllegalArgumentException("argument contains a tab character: " + arg + " in " + command).         }         if (arg.contains("\n")) {             throw new IllegalArgumentException("argument contains a newline character: " + arg + " in " + command).         }     }     if (cppLogHandler.hasLogStreamEnded()) {         String msg = "Cannot start process [" + command.get(0) + "]: native controller process has stopped".         LOGGER.error(msg).         throw new ElasticsearchException(msg).     }     synchronized (commandStream) {         LOGGER.debug("Starting process with command: " + command).         commandStream.write(START_COMMAND.getBytes(StandardCharsets.UTF_8)).         for (String arg : command) {             commandStream.write('\t').             commandStream.write(arg.getBytes(StandardCharsets.UTF_8)).         }         commandStream.write('\n').         commandStream.flush().     } }
false;public;1;23;;public void killProcess(long pid) throws TimeoutException, IOException {     if (pid <= 0) {         throw new IllegalArgumentException("invalid PID to kill: " + pid).     }     if (pid == getPid()) {         throw new IllegalArgumentException("native controller will not kill self: " + pid).     }     if (cppLogHandler.hasLogStreamEnded()) {         String msg = "Cannot kill process with PID [" + pid + "]: native controller process has stopped".         LOGGER.error(msg).         throw new ElasticsearchException(msg).     }     synchronized (commandStream) {         LOGGER.debug("Killing process with PID: " + pid).         commandStream.write(KILL_COMMAND.getBytes(StandardCharsets.UTF_8)).         commandStream.write('\t').         commandStream.write(Long.toString(pid).getBytes(StandardCharsets.UTF_8)).         commandStream.write('\n').         commandStream.flush().     } }
false;public;0;4;;public void stop() throws IOException {     // The C++ process will exit when it gets EOF on the command stream     commandStream.close(). }
