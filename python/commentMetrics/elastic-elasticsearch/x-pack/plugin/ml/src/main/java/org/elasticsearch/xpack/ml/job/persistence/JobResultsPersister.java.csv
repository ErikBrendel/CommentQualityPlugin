commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public Builder bulkPersisterBuilder(String jobId) {     return new Builder(jobId). }
true;public;1;16;/**  * Persist the result bucket and its bucket influencers  * Buckets are persisted with a consistent ID  *  * @param bucket The bucket to persist  * @return this  */ ;/**  * Persist the result bucket and its bucket influencers  * Buckets are persisted with a consistent ID  *  * @param bucket The bucket to persist  * @return this  */ public Builder persistBucket(Bucket bucket) {     // If the supplied bucket has records then create a copy with records     // removed, because we never persist nested records in buckets     Bucket bucketWithoutRecords = bucket.     if (!bucketWithoutRecords.getRecords().isEmpty()) {         bucketWithoutRecords = new Bucket(bucket).         bucketWithoutRecords.setRecords(Collections.emptyList()).     }     String id = bucketWithoutRecords.getId().     logger.trace("[{}] ES API CALL: index bucket to index [{}] with ID [{}]", jobId, indexName, id).     indexResult(id, bucketWithoutRecords, "bucket").     persistBucketInfluencersStandalone(jobId, bucketWithoutRecords.getBucketInfluencers()).     return this. }
false;private;2;9;;private void persistBucketInfluencersStandalone(String jobId, List<BucketInfluencer> bucketInfluencers) {     if (bucketInfluencers != null && bucketInfluencers.isEmpty() == false) {         for (BucketInfluencer bucketInfluencer : bucketInfluencers) {             String id = bucketInfluencer.getId().             logger.trace("[{}] ES BULK ACTION: index bucket influencer to index [{}] with ID [{}]", jobId, indexName, id).             indexResult(id, bucketInfluencer, "bucket influencer").         }     } }
true;public;1;8;/**  * Persist a list of anomaly records  *  * @param records the records to persist  * @return this  */ ;/**  * Persist a list of anomaly records  *  * @param records the records to persist  * @return this  */ public Builder persistRecords(List<AnomalyRecord> records) {     for (AnomalyRecord record : records) {         logger.trace("[{}] ES BULK ACTION: index record to index [{}] with ID [{}]", jobId, indexName, record.getId()).         indexResult(record.getId(), record, "record").     }     return this. }
true;public;1;8;/**  * Persist a list of influencers optionally using each influencer's ID or  * an auto generated ID  *  * @param influencers the influencers to persist  * @return this  */ ;/**  * Persist a list of influencers optionally using each influencer's ID or  * an auto generated ID  *  * @param influencers the influencers to persist  * @return this  */ public Builder persistInfluencers(List<Influencer> influencers) {     for (Influencer influencer : influencers) {         logger.trace("[{}] ES BULK ACTION: index influencer to index [{}] with ID [{}]", jobId, indexName, influencer.getId()).         indexResult(influencer.getId(), influencer, "influencer").     }     return this. }
false;public;1;5;;public Builder persistModelPlot(ModelPlot modelPlot) {     logger.trace("[{}] ES BULK ACTION: index model plot to index [{}] with ID [{}]", jobId, indexName, modelPlot.getId()).     indexResult(modelPlot.getId(), modelPlot, "model plot").     return this. }
false;public;1;5;;public Builder persistForecast(Forecast forecast) {     logger.trace("[{}] ES BULK ACTION: index forecast to index [{}] with ID [{}]", jobId, indexName, forecast.getId()).     indexResult(forecast.getId(), forecast, Forecast.RESULT_TYPE_VALUE).     return this. }
false;public;1;6;;public Builder persistForecastRequestStats(ForecastRequestStats forecastRequestStats) {     logger.trace("[{}] ES BULK ACTION: index forecast request stats to index [{}] with ID [{}]", jobId, indexName, forecastRequestStats.getId()).     indexResult(forecastRequestStats.getId(), forecastRequestStats, Forecast.RESULT_TYPE_VALUE).     return this. }
false;private;3;11;;private void indexResult(String id, ToXContent resultDoc, String resultType) {     try (XContentBuilder content = toXContentBuilder(resultDoc)) {         bulkRequest.add(new IndexRequest(indexName).id(id).source(content)).     } catch (IOException e) {         logger.error(new ParameterizedMessage("[{}] Error serialising {}", jobId, resultType), e).     }     if (bulkRequest.numberOfActions() >= JobRenormalizedResultsPersister.BULK_LIMIT) {         executeRequest().     } }
true;public;0;15;/**  * Execute the bulk action  */ ;/**  * Execute the bulk action  */ public void executeRequest() {     if (bulkRequest.numberOfActions() == 0) {         return.     }     logger.trace("[{}] ES API CALL: bulk request with {} actions", jobId, bulkRequest.numberOfActions()).     try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN)) {         BulkResponse addRecordsResponse = client.bulk(bulkRequest).actionGet().         if (addRecordsResponse.hasFailures()) {             logger.error("[{}] Bulk index of results has errors: {}", jobId, addRecordsResponse.buildFailureMessage()).         }     }     bulkRequest = new BulkRequest(). }
true;;0;3;// for testing ;// for testing BulkRequest getBulkRequest() {     return bulkRequest. }
true;public;1;7;/**  * Persist the category definition  *  * @param category The category to be persisted  */ ;/**  * Persist the category definition  *  * @param category The category to be persisted  */ public void persistCategoryDefinition(CategoryDefinition category) {     Persistable persistable = new Persistable(category.getJobId(), category, category.getId()).     persistable.persist(AnomalyDetectorsIndex.resultsWriteAlias(category.getJobId())).actionGet(). // Don't commit as we expect masses of these updates and they're not // read again by this process }
true;public;1;4;/**  * Persist the quantiles (blocking)  */ ;/**  * Persist the quantiles (blocking)  */ public void persistQuantiles(Quantiles quantiles) {     Persistable persistable = new Persistable(quantiles.getJobId(), quantiles, Quantiles.documentId(quantiles.getJobId())).     persistable.persist(AnomalyDetectorsIndex.jobStateIndexWriteAlias()).actionGet(). }
true;public;3;5;/**  * Persist the quantiles (async)  */ ;/**  * Persist the quantiles (async)  */ public void persistQuantiles(Quantiles quantiles, WriteRequest.RefreshPolicy refreshPolicy, ActionListener<IndexResponse> listener) {     Persistable persistable = new Persistable(quantiles.getJobId(), quantiles, Quantiles.documentId(quantiles.getJobId())).     persistable.setRefreshPolicy(refreshPolicy).     persistable.persist(AnomalyDetectorsIndex.jobStateIndexWriteAlias(), listener). }
true;public;2;5;/**  * Persist a model snapshot description  */ ;/**  * Persist a model snapshot description  */ public IndexResponse persistModelSnapshot(ModelSnapshot modelSnapshot, WriteRequest.RefreshPolicy refreshPolicy) {     Persistable persistable = new Persistable(modelSnapshot.getJobId(), modelSnapshot, ModelSnapshot.documentId(modelSnapshot)).     persistable.setRefreshPolicy(refreshPolicy).     return persistable.persist(AnomalyDetectorsIndex.resultsWriteAlias(modelSnapshot.getJobId())).actionGet(). }
true;public;1;6;/**  * Persist the memory usage data (blocking)  */ ;/**  * Persist the memory usage data (blocking)  */ public void persistModelSizeStats(ModelSizeStats modelSizeStats) {     String jobId = modelSizeStats.getJobId().     logger.trace("[{}] Persisting model size stats, for size {}", jobId, modelSizeStats.getModelBytes()).     Persistable persistable = new Persistable(jobId, modelSizeStats, modelSizeStats.getId()).     persistable.persist(AnomalyDetectorsIndex.resultsWriteAlias(jobId)).actionGet(). }
true;public;3;8;/**  * Persist the memory usage data  */ ;/**  * Persist the memory usage data  */ public void persistModelSizeStats(ModelSizeStats modelSizeStats, WriteRequest.RefreshPolicy refreshPolicy, ActionListener<IndexResponse> listener) {     String jobId = modelSizeStats.getJobId().     logger.trace("[{}] Persisting model size stats, for size {}", jobId, modelSizeStats.getModelBytes()).     Persistable persistable = new Persistable(jobId, modelSizeStats, modelSizeStats.getId()).     persistable.setRefreshPolicy(refreshPolicy).     persistable.persist(AnomalyDetectorsIndex.resultsWriteAlias(jobId), listener). }
true;public;1;3;/**  * Delete any existing interim results synchronously  */ ;/**  * Delete any existing interim results synchronously  */ public void deleteInterimResults(String jobId) {     new JobDataDeleter(client, jobId).deleteInterimResults(). }
true;public;1;13;/**  * Once all the job data has been written this function will be  * called to commit the writes to the datastore.  *  * @param jobId The job Id  */ ;/**  * Once all the job data has been written this function will be  * called to commit the writes to the datastore.  *  * @param jobId The job Id  */ public void commitResultWrites(String jobId) {     // We refresh using the read alias in order to ensure all indices will     // be refreshed even if a rollover occurs in between.     String indexName = AnomalyDetectorsIndex.jobResultsAliasedName(jobId).     // Refresh should wait for Lucene to make the data searchable     logger.trace("[{}] ES API CALL: refresh index {}", jobId, indexName).     RefreshRequest refreshRequest = new RefreshRequest(indexName).     refreshRequest.indicesOptions(IndicesOptions.lenientExpandOpen()).     try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN)) {         client.admin().indices().refresh(refreshRequest).actionGet().     } }
true;public;1;10;/**  * Once the job state has been written calling this function makes it  * immediately searchable.  *  * @param jobId The job Id  */ ;/**  * Once the job state has been written calling this function makes it  * immediately searchable.  *  * @param jobId The job Id  */ public void commitStateWrites(String jobId) {     String indexName = AnomalyDetectorsIndex.jobStateIndexPattern().     // Refresh should wait for Lucene to make the data searchable     logger.trace("[{}] ES API CALL: refresh index {}", jobId, indexName).     RefreshRequest refreshRequest = new RefreshRequest(indexName).     refreshRequest.indicesOptions(IndicesOptions.lenientExpandOpen()).     try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN)) {         client.admin().indices().refresh(refreshRequest).actionGet().     } }
false;private;1;5;;private XContentBuilder toXContentBuilder(ToXContent obj) throws IOException {     XContentBuilder builder = jsonBuilder().     obj.toXContent(builder, ToXContent.EMPTY_PARAMS).     return builder. }
false;;1;3;;void setRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy) {     this.refreshPolicy = refreshPolicy. }
false;;1;5;;ActionFuture<IndexResponse> persist(String indexName) {     PlainActionFuture<IndexResponse> actionFuture = PlainActionFuture.newFuture().     persist(indexName, actionFuture).     return actionFuture. }
false;;2;13;;void persist(String indexName, ActionListener<IndexResponse> listener) {     logCall(indexName).     try (XContentBuilder content = toXContentBuilder(object)) {         IndexRequest indexRequest = new IndexRequest(indexName).id(id).source(content).setRefreshPolicy(refreshPolicy).         executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, indexRequest, listener, client::index).     } catch (IOException e) {         logger.error(new ParameterizedMessage("[{}] Error writing [{}]", jobId, (id == null) ? "auto-generated ID" : id), e).         IndexResponse.Builder notCreatedResponse = new IndexResponse.Builder().         notCreatedResponse.setResult(Result.NOOP).         listener.onResponse(notCreatedResponse.build()).     } }
false;private;1;7;;private void logCall(String indexName) {     if (id != null) {         logger.trace("[{}] ES API CALL: to index {} with ID [{}]", jobId, indexName, id).     } else {         logger.trace("[{}] ES API CALL: to index {} with auto-generated ID", jobId, indexName).     } }
