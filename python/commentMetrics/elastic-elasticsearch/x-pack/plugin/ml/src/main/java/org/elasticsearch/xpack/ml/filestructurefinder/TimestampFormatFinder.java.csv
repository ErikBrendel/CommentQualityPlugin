# id;timestamp;commentText;codeText;commentWords;codeWords
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat, TimeoutChecker timeoutChecker);1544771889;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text             The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat, TimeoutChecker timeoutChecker) {_        if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {_            return null__        }_        Boolean[] quickRuleoutMatches = new Boolean[QUICK_RULE_OUT_PATTERNS.size()]__        int index = ignoreCandidates__        String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat)__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) ||_                candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {_                boolean quicklyRuledOut = false__                for (Integer quickRuleOutIndex : candidate.quickRuleOutIndices) {_                    if (quickRuleoutMatches[quickRuleOutIndex] == null) {_                        quickRuleoutMatches[quickRuleOutIndex] = QUICK_RULE_OUT_PATTERNS.get(quickRuleOutIndex).matcher(text).find()__                    }_                    if (quickRuleoutMatches[quickRuleOutIndex] == false) {_                        quicklyRuledOut = true__                        break__                    }_                }_                if (quicklyRuledOut == false) {_                    Map<String, Object> captures = timeoutChecker.grokCaptures(candidate.strictSearchGrok, text,_                        "timestamp format determination")__                    if (captures != null) {_                        String preface = captures.getOrDefault(PREFACE, "").toString()__                        String epilogue = captures.getOrDefault(EPILOGUE, "").toString()__                        return makeTimestampMatch(candidate, index, preface, text.substring(preface.length(),_                            text.length() - epilogue.length()), epilogue)__                    }_                }_            }_            ++index__        }_        return null__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,string,required,format,timeout,checker,timeout,checker,if,ignore,candidates,size,return,null,boolean,quick,ruleout,matches,new,boolean,size,int,index,ignore,candidates,string,adjusted,required,format,adjust,required,format,required,format,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,adjusted,required,format,null,candidate,joda,timestamp,formats,contains,adjusted,required,format,candidate,java,timestamp,formats,contains,adjusted,required,format,boolean,quickly,ruled,out,false,for,integer,quick,rule,out,index,candidate,quick,rule,out,indices,if,quick,ruleout,matches,quick,rule,out,index,null,quick,ruleout,matches,quick,rule,out,index,get,quick,rule,out,index,matcher,text,find,if,quick,ruleout,matches,quick,rule,out,index,false,quickly,ruled,out,true,break,if,quickly,ruled,out,false,map,string,object,captures,timeout,checker,grok,captures,candidate,strict,search,grok,text,timestamp,format,determination,if,captures,null,string,preface,captures,get,or,default,preface,to,string,string,epilogue,captures,get,or,default,epilogue,to,string,return,make,timestamp,match,candidate,index,preface,text,substring,preface,length,text,length,epilogue,length,epilogue,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat, TimeoutChecker timeoutChecker);1548533997;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text             The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat, TimeoutChecker timeoutChecker) {_        if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {_            return null__        }_        Boolean[] quickRuleoutMatches = new Boolean[QUICK_RULE_OUT_PATTERNS.size()]__        int index = ignoreCandidates__        String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat)__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) ||_                candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {_                boolean quicklyRuledOut = false__                for (Integer quickRuleOutIndex : candidate.quickRuleOutIndices) {_                    if (quickRuleoutMatches[quickRuleOutIndex] == null) {_                        quickRuleoutMatches[quickRuleOutIndex] = QUICK_RULE_OUT_PATTERNS.get(quickRuleOutIndex).matcher(text).find()__                    }_                    if (quickRuleoutMatches[quickRuleOutIndex] == false) {_                        quicklyRuledOut = true__                        break__                    }_                }_                if (quicklyRuledOut == false) {_                    Map<String, Object> captures = timeoutChecker.grokCaptures(candidate.strictSearchGrok, text,_                        "timestamp format determination")__                    if (captures != null) {_                        String preface = captures.getOrDefault(PREFACE, "").toString()__                        String epilogue = captures.getOrDefault(EPILOGUE, "").toString()__                        return makeTimestampMatch(candidate, index, preface, text.substring(preface.length(),_                            text.length() - epilogue.length()), epilogue)__                    }_                }_            }_            ++index__        }_        return null__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,string,required,format,timeout,checker,timeout,checker,if,ignore,candidates,size,return,null,boolean,quick,ruleout,matches,new,boolean,size,int,index,ignore,candidates,string,adjusted,required,format,adjust,required,format,required,format,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,adjusted,required,format,null,candidate,joda,timestamp,formats,contains,adjusted,required,format,candidate,java,timestamp,formats,contains,adjusted,required,format,boolean,quickly,ruled,out,false,for,integer,quick,rule,out,index,candidate,quick,rule,out,indices,if,quick,ruleout,matches,quick,rule,out,index,null,quick,ruleout,matches,quick,rule,out,index,get,quick,rule,out,index,matcher,text,find,if,quick,ruleout,matches,quick,rule,out,index,false,quickly,ruled,out,true,break,if,quickly,ruled,out,false,map,string,object,captures,timeout,checker,grok,captures,candidate,strict,search,grok,text,timestamp,format,determination,if,captures,null,string,preface,captures,get,or,default,preface,to,string,string,epilogue,captures,get,or,default,epilogue,to,string,return,make,timestamp,match,candidate,index,preface,text,substring,preface,length,text,length,epilogue,length,epilogue,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat, TimeoutChecker timeoutChecker);1549035364;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text             The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat, TimeoutChecker timeoutChecker) {_        if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {_            return null__        }_        Boolean[] quickRuleoutMatches = new Boolean[QUICK_RULE_OUT_PATTERNS.size()]__        int index = ignoreCandidates__        String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat)__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) ||_                candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {_                boolean quicklyRuledOut = false__                for (Integer quickRuleOutIndex : candidate.quickRuleOutIndices) {_                    if (quickRuleoutMatches[quickRuleOutIndex] == null) {_                        quickRuleoutMatches[quickRuleOutIndex] = QUICK_RULE_OUT_PATTERNS.get(quickRuleOutIndex).matcher(text).find()__                    }_                    if (quickRuleoutMatches[quickRuleOutIndex] == false) {_                        quicklyRuledOut = true__                        break__                    }_                }_                if (quicklyRuledOut == false) {_                    Map<String, Object> captures = timeoutChecker.grokCaptures(candidate.strictSearchGrok, text,_                        "timestamp format determination")__                    if (captures != null) {_                        String preface = captures.getOrDefault(PREFACE, "").toString()__                        String epilogue = captures.getOrDefault(EPILOGUE, "").toString()__                        return makeTimestampMatch(candidate, index, preface, text.substring(preface.length(),_                            text.length() - epilogue.length()), epilogue)__                    }_                }_            }_            ++index__        }_        return null__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,string,required,format,timeout,checker,timeout,checker,if,ignore,candidates,size,return,null,boolean,quick,ruleout,matches,new,boolean,size,int,index,ignore,candidates,string,adjusted,required,format,adjust,required,format,required,format,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,adjusted,required,format,null,candidate,joda,timestamp,formats,contains,adjusted,required,format,candidate,java,timestamp,formats,contains,adjusted,required,format,boolean,quickly,ruled,out,false,for,integer,quick,rule,out,index,candidate,quick,rule,out,indices,if,quick,ruleout,matches,quick,rule,out,index,null,quick,ruleout,matches,quick,rule,out,index,get,quick,rule,out,index,matcher,text,find,if,quick,ruleout,matches,quick,rule,out,index,false,quickly,ruled,out,true,break,if,quickly,ruled,out,false,map,string,object,captures,timeout,checker,grok,captures,candidate,strict,search,grok,text,timestamp,format,determination,if,captures,null,string,preface,captures,get,or,default,preface,to,string,string,epilogue,captures,get,or,default,epilogue,to,string,return,make,timestamp,match,candidate,index,preface,text,substring,preface,length,text,length,epilogue,length,epilogue,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker);1544771889;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker) {_        return findFirstFullMatch(text, 0, requiredFormat, timeoutChecker)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,string,required,format,timeout,checker,timeout,checker,return,find,first,full,match,text,0,required,format,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker);1548533997;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker) {_        return findFirstFullMatch(text, 0, requiredFormat, timeoutChecker)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,string,required,format,timeout,checker,timeout,checker,return,find,first,full,match,text,0,required,format,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker);1549035364;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker) {_        return findFirstFullMatch(text, 0, requiredFormat, timeoutChecker)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,string,required,format,timeout,checker,timeout,checker,return,find,first,full,match,text,0,required,format,timeout,checker
TimestampFormatFinder -> TimestampMatch -> public boolean hasTimezoneDependentParsing();1536314350;Does the parsing the timestamp produce different results depending on the timezone of the parser?_I.e., does the textual representation NOT define the timezone?;public boolean hasTimezoneDependentParsing() {_            return dateFormats.stream()_                .anyMatch(dateFormat -> dateFormat.contains("HH") && dateFormat.toLowerCase(Locale.ROOT).indexOf('z') == -1)__        };does,the,parsing,the,timestamp,produce,different,results,depending,on,the,timezone,of,the,parser,i,e,does,the,textual,representation,not,define,the,timezone;public,boolean,has,timezone,dependent,parsing,return,date,formats,stream,any,match,date,format,date,format,contains,hh,date,format,to,lower,case,locale,root,index,of,z,1
TimestampFormatFinder -> TimestampMatch -> public boolean hasTimezoneDependentParsing();1536964057;Does the parsing the timestamp produce different results depending on the timezone of the parser?_I.e., does the textual representation NOT define the timezone?;public boolean hasTimezoneDependentParsing() {_            return dateFormats.stream()_                .anyMatch(dateFormat -> dateFormat.contains("HH") && dateFormat.toLowerCase(Locale.ROOT).indexOf('z') == -1)__        };does,the,parsing,the,timestamp,produce,different,results,depending,on,the,timezone,of,the,parser,i,e,does,the,textual,representation,not,define,the,timezone;public,boolean,has,timezone,dependent,parsing,return,date,formats,stream,any,match,date,format,date,format,contains,hh,date,format,to,lower,case,locale,root,index,of,z,1
TimestampFormatFinder -> TimestampMatch -> public boolean hasTimezoneDependentParsing();1538067637;Does the parsing the timestamp produce different results depending on the timezone of the parser?_I.e., does the textual representation NOT define the timezone?;public boolean hasTimezoneDependentParsing() {_            return javaTimestampFormats.stream().anyMatch(javaTimestampFormat ->_                javaTimestampFormat.indexOf('X') == -1 && javaTimestampFormat.indexOf('z') == -1 && javaTimestampFormat.contains("mm"))__        };does,the,parsing,the,timestamp,produce,different,results,depending,on,the,timezone,of,the,parser,i,e,does,the,textual,representation,not,define,the,timezone;public,boolean,has,timezone,dependent,parsing,return,java,timestamp,formats,stream,any,match,java,timestamp,format,java,timestamp,format,index,of,x,1,java,timestamp,format,index,of,z,1,java,timestamp,format,contains,mm
TimestampFormatFinder -> TimestampMatch -> public boolean hasTimezoneDependentParsing();1544771889;Does the parsing the timestamp produce different results depending on the timezone of the parser?_I.e., does the textual representation NOT define the timezone?;public boolean hasTimezoneDependentParsing() {_            return javaTimestampFormats.stream().anyMatch(javaTimestampFormat ->_                javaTimestampFormat.indexOf('X') == -1 && javaTimestampFormat.indexOf('z') == -1 && javaTimestampFormat.contains("mm"))__        };does,the,parsing,the,timestamp,produce,different,results,depending,on,the,timezone,of,the,parser,i,e,does,the,textual,representation,not,define,the,timezone;public,boolean,has,timezone,dependent,parsing,return,java,timestamp,formats,stream,any,match,java,timestamp,format,java,timestamp,format,index,of,x,1,java,timestamp,format,index,of,z,1,java,timestamp,format,contains,mm
TimestampFormatFinder -> TimestampMatch -> public boolean hasTimezoneDependentParsing();1548533997;Does the parsing the timestamp produce different results depending on the timezone of the parser?_I.e., does the textual representation NOT define the timezone?;public boolean hasTimezoneDependentParsing() {_            return javaTimestampFormats.stream().anyMatch(javaTimestampFormat ->_                javaTimestampFormat.indexOf('X') == -1 && javaTimestampFormat.indexOf('z') == -1 && javaTimestampFormat.contains("mm"))__        };does,the,parsing,the,timestamp,produce,different,results,depending,on,the,timezone,of,the,parser,i,e,does,the,textual,representation,not,define,the,timezone;public,boolean,has,timezone,dependent,parsing,return,java,timestamp,formats,stream,any,match,java,timestamp,format,java,timestamp,format,index,of,x,1,java,timestamp,format,index,of,z,1,java,timestamp,format,contains,mm
TimestampFormatFinder -> TimestampMatch -> public boolean hasTimezoneDependentParsing();1549035364;Does the parsing the timestamp produce different results depending on the timezone of the parser?_I.e., does the textual representation NOT define the timezone?;public boolean hasTimezoneDependentParsing() {_            return javaTimestampFormats.stream().anyMatch(javaTimestampFormat ->_                javaTimestampFormat.indexOf('X') == -1 && javaTimestampFormat.indexOf('z') == -1 && javaTimestampFormat.contains("mm"))__        };does,the,parsing,the,timestamp,produce,different,results,depending,on,the,timezone,of,the,parser,i,e,does,the,textual,representation,not,define,the,timezone;public,boolean,has,timezone,dependent,parsing,return,java,timestamp,formats,stream,any,match,java,timestamp,format,java,timestamp,format,index,of,x,1,java,timestamp,format,index,of,z,1,java,timestamp,format,contains,mm
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text);1536314350;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text) {_        return findFirstFullMatch(text, 0)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,return,find,first,full,match,text,0
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text);1536964057;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text) {_        return findFirstFullMatch(text, 0)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,return,find,first,full,match,text,0
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text);1538067637;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text) {_        return findFirstFullMatch(text, 0)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,return,find,first,full,match,text,0
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text);1536314350;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text) {_        return findFirstMatch(text, 0)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,return,find,first,match,text,0
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text);1536964057;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text) {_        return findFirstMatch(text, 0)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,return,find,first,match,text,0
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text);1538067637;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text) {_        return findFirstMatch(text, 0)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,return,find,first,match,text,0
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker);1544771889;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker) {_        return findFirstMatch(text, 0, requiredFormat, timeoutChecker)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,string,required,format,timeout,checker,timeout,checker,return,find,first,match,text,0,required,format,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker);1548533997;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker) {_        return findFirstMatch(text, 0, requiredFormat, timeoutChecker)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,string,required,format,timeout,checker,timeout,checker,return,find,first,match,text,0,required,format,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker);1549035364;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker) {_        return findFirstMatch(text, 0, requiredFormat, timeoutChecker)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,string,required,format,timeout,checker,timeout,checker,return,find,first,match,text,0,required,format,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, String requiredFormat);1536964057;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@param requiredFormat A date format that any returned match must support._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, String requiredFormat) {_        return findFirstFullMatch(text, 0, requiredFormat)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,required,format,a,date,format,that,any,returned,match,must,support,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,string,required,format,return,find,first,full,match,text,0,required,format
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, String requiredFormat);1538067637;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@param requiredFormat A timestamp format that any returned match must support._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, String requiredFormat) {_        return findFirstFullMatch(text, 0, requiredFormat)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,required,format,a,timestamp,format,that,any,returned,match,must,support,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,string,required,format,return,find,first,full,match,text,0,required,format
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, String requiredFormat);1536964057;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@param requiredFormat A date format that any returned match must support._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, String requiredFormat) {_        return findFirstMatch(text, 0, requiredFormat)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,required,format,a,date,format,that,any,returned,match,must,support,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,string,required,format,return,find,first,match,text,0,required,format
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, String requiredFormat);1538067637;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@param requiredFormat A timestamp format that any returned match must support._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, String requiredFormat) {_        return findFirstMatch(text, 0, requiredFormat)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,required,format,a,timestamp,format,that,any,returned,match,must,support,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,string,required,format,return,find,first,match,text,0,required,format
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates);1536314350;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates) {_        Boolean[] quickRuleoutMatches = new Boolean[QUICK_RULE_OUT_PATTERNS.size()]__        int index = ignoreCandidates__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            boolean quicklyRuledOut = false__            for (Integer quickRuleOutIndex : candidate.quickRuleOutIndices) {_                if (quickRuleoutMatches[quickRuleOutIndex] == null) {_                    quickRuleoutMatches[quickRuleOutIndex] = QUICK_RULE_OUT_PATTERNS.get(quickRuleOutIndex).matcher(text).find()__                }_                if (quickRuleoutMatches[quickRuleOutIndex] == false) {_                    quicklyRuledOut = true__                    break__                }_            }_            if (quicklyRuledOut == false) {_                Map<String, Object> captures = candidate.strictSearchGrok.captures(text)__                if (captures != null) {_                    String preface = captures.getOrDefault(PREFACE, "").toString()__                    String epilogue = captures.getOrDefault(EPILOGUE, "").toString()__                    return makeTimestampMatch(candidate, index, preface, text.substring(preface.length(),_                        text.length() - epilogue.length()), epilogue)__                }_            }_            ++index__        }_        return null__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,boolean,quick,ruleout,matches,new,boolean,size,int,index,ignore,candidates,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,boolean,quickly,ruled,out,false,for,integer,quick,rule,out,index,candidate,quick,rule,out,indices,if,quick,ruleout,matches,quick,rule,out,index,null,quick,ruleout,matches,quick,rule,out,index,get,quick,rule,out,index,matcher,text,find,if,quick,ruleout,matches,quick,rule,out,index,false,quickly,ruled,out,true,break,if,quickly,ruled,out,false,map,string,object,captures,candidate,strict,search,grok,captures,text,if,captures,null,string,preface,captures,get,or,default,preface,to,string,string,epilogue,captures,get,or,default,epilogue,to,string,return,make,timestamp,match,candidate,index,preface,text,substring,preface,length,text,length,epilogue,length,epilogue,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates);1536964057;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates) {_        return findFirstMatch(text, ignoreCandidates, null)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,return,find,first,match,text,ignore,candidates,null
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates);1538067637;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates) {_        return findFirstMatch(text, ignoreCandidates, null)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,return,find,first,match,text,ignore,candidates,null
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker);1544771889;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker) {_        return findFirstMatch(text, ignoreCandidates, null, timeoutChecker)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,timeout,checker,timeout,checker,return,find,first,match,text,ignore,candidates,null,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker);1548533997;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker) {_        return findFirstMatch(text, ignoreCandidates, null, timeoutChecker)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,timeout,checker,timeout,checker,return,find,first,match,text,ignore,candidates,null,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker);1549035364;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker) {_        return findFirstMatch(text, ignoreCandidates, null, timeoutChecker)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,timeout,checker,timeout,checker,return,find,first,match,text,ignore,candidates,null,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, TimeoutChecker timeoutChecker);1544771889;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, TimeoutChecker timeoutChecker) {_        return findFirstMatch(text, 0, timeoutChecker)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,timeout,checker,timeout,checker,return,find,first,match,text,0,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, TimeoutChecker timeoutChecker);1548533997;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, TimeoutChecker timeoutChecker) {_        return findFirstMatch(text, 0, timeoutChecker)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,timeout,checker,timeout,checker,return,find,first,match,text,0,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, TimeoutChecker timeoutChecker);1549035364;Find the first timestamp format that matches part of the supplied value._@param text The value that the returned timestamp format must exist within._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, TimeoutChecker timeoutChecker) {_        return findFirstMatch(text, 0, timeoutChecker)__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,timeout,checker,timeout,checker,return,find,first,match,text,0,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, TimeoutChecker timeoutChecker);1544771889;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, TimeoutChecker timeoutChecker) {_        return findFirstFullMatch(text, 0, timeoutChecker)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,timeout,checker,timeout,checker,return,find,first,full,match,text,0,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, TimeoutChecker timeoutChecker);1548533997;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, TimeoutChecker timeoutChecker) {_        return findFirstFullMatch(text, 0, timeoutChecker)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,timeout,checker,timeout,checker,return,find,first,full,match,text,0,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, TimeoutChecker timeoutChecker);1549035364;Find the best timestamp format for matching an entire field value._@param text The value that the returned timestamp format must match in its entirety._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, TimeoutChecker timeoutChecker) {_        return findFirstFullMatch(text, 0, timeoutChecker)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,timeout,checker,timeout,checker,return,find,first,full,match,text,0,timeout,checker
TimestampFormatFinder -> static String adjustRequiredFormat(String requiredFormat);1538067637;If a required timestamp format contains a fractional seconds component, adjust it to the_fractional seconds format that's in the candidate timestamp formats, i.e. ",SSS".  So, for_example, "YYYY-MM-dd HH:mm:ss.SSSSSSSSS Z" would get adjusted to "YYYY-MM-dd HH:mm:ss,SSS Z".;static String adjustRequiredFormat(String requiredFormat) {__        return (requiredFormat == null) ? null :_            FRACTIONAL_SECOND_TIMESTAMP_FORMAT_PATTERN.matcher(requiredFormat).replaceFirst(DEFAULT_FRACTIONAL_SECOND_FORMAT)__    };if,a,required,timestamp,format,contains,a,fractional,seconds,component,adjust,it,to,the,fractional,seconds,format,that,s,in,the,candidate,timestamp,formats,i,e,sss,so,for,example,yyyy,mm,dd,hh,mm,ss,sssssssss,z,would,get,adjusted,to,yyyy,mm,dd,hh,mm,ss,sss,z;static,string,adjust,required,format,string,required,format,return,required,format,null,null,matcher,required,format,replace,first
TimestampFormatFinder -> static String adjustRequiredFormat(String requiredFormat);1544771889;If a required timestamp format contains a fractional seconds component, adjust it to the_fractional seconds format that's in the candidate timestamp formats, i.e. ",SSS".  So, for_example, "YYYY-MM-dd HH:mm:ss.SSSSSSSSS Z" would get adjusted to "YYYY-MM-dd HH:mm:ss,SSS Z".;static String adjustRequiredFormat(String requiredFormat) {__        return (requiredFormat == null) ? null :_            FRACTIONAL_SECOND_TIMESTAMP_FORMAT_PATTERN.matcher(requiredFormat).replaceFirst(DEFAULT_FRACTIONAL_SECOND_FORMAT)__    };if,a,required,timestamp,format,contains,a,fractional,seconds,component,adjust,it,to,the,fractional,seconds,format,that,s,in,the,candidate,timestamp,formats,i,e,sss,so,for,example,yyyy,mm,dd,hh,mm,ss,sssssssss,z,would,get,adjusted,to,yyyy,mm,dd,hh,mm,ss,sss,z;static,string,adjust,required,format,string,required,format,return,required,format,null,null,matcher,required,format,replace,first
TimestampFormatFinder -> static String adjustRequiredFormat(String requiredFormat);1548533997;If a required timestamp format contains a fractional seconds component, adjust it to the_fractional seconds format that's in the candidate timestamp formats, i.e. ",SSS".  So, for_example, "YYYY-MM-dd HH:mm:ss.SSSSSSSSS Z" would get adjusted to "YYYY-MM-dd HH:mm:ss,SSS Z".;static String adjustRequiredFormat(String requiredFormat) {__        return (requiredFormat == null) ? null :_            FRACTIONAL_SECOND_TIMESTAMP_FORMAT_PATTERN.matcher(requiredFormat).replaceFirst(DEFAULT_FRACTIONAL_SECOND_FORMAT)__    };if,a,required,timestamp,format,contains,a,fractional,seconds,component,adjust,it,to,the,fractional,seconds,format,that,s,in,the,candidate,timestamp,formats,i,e,sss,so,for,example,yyyy,mm,dd,hh,mm,ss,sssssssss,z,would,get,adjusted,to,yyyy,mm,dd,hh,mm,ss,sss,z;static,string,adjust,required,format,string,required,format,return,required,format,null,null,matcher,required,format,replace,first
TimestampFormatFinder -> static String adjustRequiredFormat(String requiredFormat);1549035364;If a required timestamp format contains a fractional seconds component, adjust it to the_fractional seconds format that's in the candidate timestamp formats, i.e. ",SSS".  So, for_example, "YYYY-MM-dd HH:mm:ss.SSSSSSSSS Z" would get adjusted to "YYYY-MM-dd HH:mm:ss,SSS Z".;static String adjustRequiredFormat(String requiredFormat) {__        return (requiredFormat == null) ? null :_            FRACTIONAL_SECOND_TIMESTAMP_FORMAT_PATTERN.matcher(requiredFormat).replaceFirst(DEFAULT_FRACTIONAL_SECOND_FORMAT)__    };if,a,required,timestamp,format,contains,a,fractional,seconds,component,adjust,it,to,the,fractional,seconds,format,that,s,in,the,candidate,timestamp,formats,i,e,sss,so,for,example,yyyy,mm,dd,hh,mm,ss,sssssssss,z,would,get,adjusted,to,yyyy,mm,dd,hh,mm,ss,sss,z;static,string,adjust,required,format,string,required,format,return,required,format,null,null,matcher,required,format,replace,first
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates);1536314350;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates) {_        int index = ignoreCandidates__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            Map<String, Object> captures = candidate.strictFullMatchGrok.captures(text)__            if (captures != null) {_                return makeTimestampMatch(candidate, index, "", text, "")__            }_            ++index__        }_        return null__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,int,index,ignore,candidates,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,map,string,object,captures,candidate,strict,full,match,grok,captures,text,if,captures,null,return,make,timestamp,match,candidate,index,text,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates);1536964057;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates) {_        return findFirstFullMatch(text, ignoreCandidates, null)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,return,find,first,full,match,text,ignore,candidates,null
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates);1538067637;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates) {_        return findFirstFullMatch(text, ignoreCandidates, null)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,return,find,first,full,match,text,ignore,candidates,null
TimestampFormatFinder -> static Tuple<Character, Integer> interpretFractionalSeconds(String date);1536314350;Interpret the fractional seconds component of a date to determine two things:_1. The separator character - one of colon, comma and dot._2. The number of digits in the fractional component._@param date The textual representation of the date for which fractional seconds are to be interpreted._@return A tuple of (fractional second separator character, number of digits in fractional component).;static Tuple<Character, Integer> interpretFractionalSeconds(String date) {__        Matcher matcher = FRACTIONAL_SECOND_INTERPRETER.matcher(date)__        if (matcher.find()) {_            return new Tuple<>(matcher.group(1).charAt(0), matcher.group(2).length())__        }__        return new Tuple<>(DEFAULT_FRACTIONAL_SECOND_SEPARATOR, 0)__    };interpret,the,fractional,seconds,component,of,a,date,to,determine,two,things,1,the,separator,character,one,of,colon,comma,and,dot,2,the,number,of,digits,in,the,fractional,component,param,date,the,textual,representation,of,the,date,for,which,fractional,seconds,are,to,be,interpreted,return,a,tuple,of,fractional,second,separator,character,number,of,digits,in,fractional,component;static,tuple,character,integer,interpret,fractional,seconds,string,date,matcher,matcher,matcher,date,if,matcher,find,return,new,tuple,matcher,group,1,char,at,0,matcher,group,2,length,return,new,tuple,0
TimestampFormatFinder -> static Tuple<Character, Integer> interpretFractionalSeconds(String date);1536964057;Interpret the fractional seconds component of a date to determine two things:_1. The separator character - one of colon, comma and dot._2. The number of digits in the fractional component._@param date The textual representation of the date for which fractional seconds are to be interpreted._@return A tuple of (fractional second separator character, number of digits in fractional component).;static Tuple<Character, Integer> interpretFractionalSeconds(String date) {__        Matcher matcher = FRACTIONAL_SECOND_INTERPRETER.matcher(date)__        if (matcher.find()) {_            return new Tuple<>(matcher.group(1).charAt(0), matcher.group(2).length())__        }__        return new Tuple<>(DEFAULT_FRACTIONAL_SECOND_SEPARATOR, 0)__    };interpret,the,fractional,seconds,component,of,a,date,to,determine,two,things,1,the,separator,character,one,of,colon,comma,and,dot,2,the,number,of,digits,in,the,fractional,component,param,date,the,textual,representation,of,the,date,for,which,fractional,seconds,are,to,be,interpreted,return,a,tuple,of,fractional,second,separator,character,number,of,digits,in,fractional,component;static,tuple,character,integer,interpret,fractional,seconds,string,date,matcher,matcher,matcher,date,if,matcher,find,return,new,tuple,matcher,group,1,char,at,0,matcher,group,2,length,return,new,tuple,0
TimestampFormatFinder -> static Tuple<Character, Integer> interpretFractionalSeconds(String date);1538067637;Interpret the fractional seconds component of a date to determine two things:_1. The separator character - one of colon, comma and dot._2. The number of digits in the fractional component._@param date The textual representation of the date for which fractional seconds are to be interpreted._@return A tuple of (fractional second separator character, number of digits in fractional component).;static Tuple<Character, Integer> interpretFractionalSeconds(String date) {__        Matcher matcher = FRACTIONAL_SECOND_INTERPRETER.matcher(date)__        if (matcher.find()) {_            return new Tuple<>(matcher.group(1).charAt(0), matcher.group(2).length())__        }__        return new Tuple<>(DEFAULT_FRACTIONAL_SECOND_SEPARATOR, 0)__    };interpret,the,fractional,seconds,component,of,a,date,to,determine,two,things,1,the,separator,character,one,of,colon,comma,and,dot,2,the,number,of,digits,in,the,fractional,component,param,date,the,textual,representation,of,the,date,for,which,fractional,seconds,are,to,be,interpreted,return,a,tuple,of,fractional,second,separator,character,number,of,digits,in,fractional,component;static,tuple,character,integer,interpret,fractional,seconds,string,date,matcher,matcher,matcher,date,if,matcher,find,return,new,tuple,matcher,group,1,char,at,0,matcher,group,2,length,return,new,tuple,0
TimestampFormatFinder -> static Tuple<Character, Integer> interpretFractionalSeconds(String date);1544771889;Interpret the fractional seconds component of a date to determine two things:_1. The separator character - one of colon, comma and dot._2. The number of digits in the fractional component._@param date The textual representation of the date for which fractional seconds are to be interpreted._@return A tuple of (fractional second separator character, number of digits in fractional component).;static Tuple<Character, Integer> interpretFractionalSeconds(String date) {__        Matcher matcher = FRACTIONAL_SECOND_INTERPRETER.matcher(date)__        if (matcher.find()) {_            return new Tuple<>(matcher.group(1).charAt(0), matcher.group(2).length())__        }__        return new Tuple<>(DEFAULT_FRACTIONAL_SECOND_SEPARATOR, 0)__    };interpret,the,fractional,seconds,component,of,a,date,to,determine,two,things,1,the,separator,character,one,of,colon,comma,and,dot,2,the,number,of,digits,in,the,fractional,component,param,date,the,textual,representation,of,the,date,for,which,fractional,seconds,are,to,be,interpreted,return,a,tuple,of,fractional,second,separator,character,number,of,digits,in,fractional,component;static,tuple,character,integer,interpret,fractional,seconds,string,date,matcher,matcher,matcher,date,if,matcher,find,return,new,tuple,matcher,group,1,char,at,0,matcher,group,2,length,return,new,tuple,0
TimestampFormatFinder -> static Tuple<Character, Integer> interpretFractionalSeconds(String date);1548533997;Interpret the fractional seconds component of a date to determine two things:_1. The separator character - one of colon, comma and dot._2. The number of digits in the fractional component._@param date The textual representation of the date for which fractional seconds are to be interpreted._@return A tuple of (fractional second separator character, number of digits in fractional component).;static Tuple<Character, Integer> interpretFractionalSeconds(String date) {__        Matcher matcher = FRACTIONAL_SECOND_INTERPRETER.matcher(date)__        if (matcher.find()) {_            return new Tuple<>(matcher.group(1).charAt(0), matcher.group(2).length())__        }__        return new Tuple<>(DEFAULT_FRACTIONAL_SECOND_SEPARATOR, 0)__    };interpret,the,fractional,seconds,component,of,a,date,to,determine,two,things,1,the,separator,character,one,of,colon,comma,and,dot,2,the,number,of,digits,in,the,fractional,component,param,date,the,textual,representation,of,the,date,for,which,fractional,seconds,are,to,be,interpreted,return,a,tuple,of,fractional,second,separator,character,number,of,digits,in,fractional,component;static,tuple,character,integer,interpret,fractional,seconds,string,date,matcher,matcher,matcher,date,if,matcher,find,return,new,tuple,matcher,group,1,char,at,0,matcher,group,2,length,return,new,tuple,0
TimestampFormatFinder -> static Tuple<Character, Integer> interpretFractionalSeconds(String date);1549035364;Interpret the fractional seconds component of a date to determine two things:_1. The separator character - one of colon, comma and dot._2. The number of digits in the fractional component._@param date The textual representation of the date for which fractional seconds are to be interpreted._@return A tuple of (fractional second separator character, number of digits in fractional component).;static Tuple<Character, Integer> interpretFractionalSeconds(String date) {__        Matcher matcher = FRACTIONAL_SECOND_INTERPRETER.matcher(date)__        if (matcher.find()) {_            return new Tuple<>(matcher.group(1).charAt(0), matcher.group(2).length())__        }__        return new Tuple<>(DEFAULT_FRACTIONAL_SECOND_SEPARATOR, 0)__    };interpret,the,fractional,seconds,component,of,a,date,to,determine,two,things,1,the,separator,character,one,of,colon,comma,and,dot,2,the,number,of,digits,in,the,fractional,component,param,date,the,textual,representation,of,the,date,for,which,fractional,seconds,are,to,be,interpreted,return,a,tuple,of,fractional,second,separator,character,number,of,digits,in,fractional,component;static,tuple,character,integer,interpret,fractional,seconds,string,date,matcher,matcher,matcher,date,if,matcher,find,return,new,tuple,matcher,group,1,char,at,0,matcher,group,2,length,return,new,tuple,0
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker);1544771889;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker) {_        return findFirstFullMatch(text, ignoreCandidates, null, timeoutChecker)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,timeout,checker,timeout,checker,return,find,first,full,match,text,ignore,candidates,null,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker);1548533997;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker) {_        return findFirstFullMatch(text, ignoreCandidates, null, timeoutChecker)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,timeout,checker,timeout,checker,return,find,first,full,match,text,ignore,candidates,null,timeout,checker
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker);1549035364;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker) {_        return findFirstFullMatch(text, ignoreCandidates, null, timeoutChecker)__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,timeout,checker,timeout,checker,return,find,first,full,match,text,ignore,candidates,null,timeout,checker
TimestampFormatFinder -> TimestampMatch -> public Map<String, String> getEsDateMappingTypeWithFormat();1536314350;Sometimes Elasticsearch mappings for dates need to include the format._This method returns appropriate mappings settings: at minimum "type"="date",_and possibly also a "format" setting.;public Map<String, String> getEsDateMappingTypeWithFormat() {_            if (dateFormats.contains("TAI64N")) {_                _                return Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, "keyword")__            }_            Map<String, String> mapping = new LinkedHashMap<>()__            mapping.put(FileStructureUtils.MAPPING_TYPE_SETTING, "date")__            String formats = dateFormats.stream().flatMap(format -> {_                switch (format) {_                    case "ISO8601":_                        return Stream.empty()__                    case "UNIX_MS":_                        return Stream.of("epoch_millis")__                    case "UNIX":_                        return Stream.of("epoch_second")__                    default:_                        return Stream.of(format)__                }_            }).collect(Collectors.joining("||"))__            if (formats.isEmpty() == false) {_                mapping.put(FileStructureUtils.MAPPING_FORMAT_SETTING, formats)__            }_            return mapping__        };sometimes,elasticsearch,mappings,for,dates,need,to,include,the,format,this,method,returns,appropriate,mappings,settings,at,minimum,type,date,and,possibly,also,a,format,setting;public,map,string,string,get,es,date,mapping,type,with,format,if,date,formats,contains,tai64n,return,collections,singleton,map,file,structure,utils,keyword,map,string,string,mapping,new,linked,hash,map,mapping,put,file,structure,utils,date,string,formats,date,formats,stream,flat,map,format,switch,format,case,iso8601,return,stream,empty,case,return,stream,of,case,unix,return,stream,of,default,return,stream,of,format,collect,collectors,joining,if,formats,is,empty,false,mapping,put,file,structure,utils,formats,return,mapping
TimestampFormatFinder -> TimestampMatch -> public Map<String, String> getEsDateMappingTypeWithFormat();1536964057;Sometimes Elasticsearch mappings for dates need to include the format._This method returns appropriate mappings settings: at minimum "type"="date",_and possibly also a "format" setting.;public Map<String, String> getEsDateMappingTypeWithFormat() {_            if (dateFormats.contains("TAI64N")) {_                _                return Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, "keyword")__            }_            Map<String, String> mapping = new LinkedHashMap<>()__            mapping.put(FileStructureUtils.MAPPING_TYPE_SETTING, "date")__            String formats = dateFormats.stream().flatMap(format -> {_                switch (format) {_                    case "ISO8601":_                        return Stream.empty()__                    case "UNIX_MS":_                        return Stream.of("epoch_millis")__                    case "UNIX":_                        return Stream.of("epoch_second")__                    default:_                        return Stream.of(format)__                }_            }).collect(Collectors.joining("||"))__            if (formats.isEmpty() == false) {_                mapping.put(FileStructureUtils.MAPPING_FORMAT_SETTING, formats)__            }_            return mapping__        };sometimes,elasticsearch,mappings,for,dates,need,to,include,the,format,this,method,returns,appropriate,mappings,settings,at,minimum,type,date,and,possibly,also,a,format,setting;public,map,string,string,get,es,date,mapping,type,with,format,if,date,formats,contains,tai64n,return,collections,singleton,map,file,structure,utils,keyword,map,string,string,mapping,new,linked,hash,map,mapping,put,file,structure,utils,date,string,formats,date,formats,stream,flat,map,format,switch,format,case,iso8601,return,stream,empty,case,return,stream,of,case,unix,return,stream,of,default,return,stream,of,format,collect,collectors,joining,if,formats,is,empty,false,mapping,put,file,structure,utils,formats,return,mapping
TimestampFormatFinder -> TimestampMatch -> public Map<String, String> getEsDateMappingTypeWithFormat();1538067637;Sometimes Elasticsearch mappings for dates need to include the format._This method returns appropriate mappings settings: at minimum "type"="date",_and possibly also a "format" setting.;public Map<String, String> getEsDateMappingTypeWithFormat() {_            if (jodaTimestampFormats.contains("TAI64N")) {_                _                return Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, "keyword")__            }_            Map<String, String> mapping = new LinkedHashMap<>()__            mapping.put(FileStructureUtils.MAPPING_TYPE_SETTING, "date")__            String formats = jodaTimestampFormats.stream().flatMap(format -> {_                switch (format) {_                    case "ISO8601":_                        return Stream.empty()__                    case "UNIX_MS":_                        return Stream.of("epoch_millis")__                    case "UNIX":_                        return Stream.of("epoch_second")__                    default:_                        return Stream.of(format)__                }_            }).collect(Collectors.joining("||"))__            if (formats.isEmpty() == false) {_                mapping.put(FileStructureUtils.MAPPING_FORMAT_SETTING, formats)__            }_            return mapping__        };sometimes,elasticsearch,mappings,for,dates,need,to,include,the,format,this,method,returns,appropriate,mappings,settings,at,minimum,type,date,and,possibly,also,a,format,setting;public,map,string,string,get,es,date,mapping,type,with,format,if,joda,timestamp,formats,contains,tai64n,return,collections,singleton,map,file,structure,utils,keyword,map,string,string,mapping,new,linked,hash,map,mapping,put,file,structure,utils,date,string,formats,joda,timestamp,formats,stream,flat,map,format,switch,format,case,iso8601,return,stream,empty,case,return,stream,of,case,unix,return,stream,of,default,return,stream,of,format,collect,collectors,joining,if,formats,is,empty,false,mapping,put,file,structure,utils,formats,return,mapping
TimestampFormatFinder -> TimestampMatch -> public Map<String, String> getEsDateMappingTypeWithFormat();1544771889;Sometimes Elasticsearch mappings for dates need to include the format._This method returns appropriate mappings settings: at minimum "type"="date",_and possibly also a "format" setting.;public Map<String, String> getEsDateMappingTypeWithFormat() {_            if (jodaTimestampFormats.contains("TAI64N")) {_                _                return Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, "keyword")__            }_            Map<String, String> mapping = new LinkedHashMap<>()__            mapping.put(FileStructureUtils.MAPPING_TYPE_SETTING, "date")__            String formats = jodaTimestampFormats.stream().flatMap(format -> {_                switch (format) {_                    case "ISO8601":_                        return Stream.empty()__                    case "UNIX_MS":_                        return Stream.of("epoch_millis")__                    case "UNIX":_                        return Stream.of("epoch_second")__                    default:_                        return Stream.of(format)__                }_            }).collect(Collectors.joining("||"))__            if (formats.isEmpty() == false) {_                mapping.put(FileStructureUtils.MAPPING_FORMAT_SETTING, formats)__            }_            return mapping__        };sometimes,elasticsearch,mappings,for,dates,need,to,include,the,format,this,method,returns,appropriate,mappings,settings,at,minimum,type,date,and,possibly,also,a,format,setting;public,map,string,string,get,es,date,mapping,type,with,format,if,joda,timestamp,formats,contains,tai64n,return,collections,singleton,map,file,structure,utils,keyword,map,string,string,mapping,new,linked,hash,map,mapping,put,file,structure,utils,date,string,formats,joda,timestamp,formats,stream,flat,map,format,switch,format,case,iso8601,return,stream,empty,case,return,stream,of,case,unix,return,stream,of,default,return,stream,of,format,collect,collectors,joining,if,formats,is,empty,false,mapping,put,file,structure,utils,formats,return,mapping
TimestampFormatFinder -> TimestampMatch -> public Map<String, String> getEsDateMappingTypeWithFormat();1548533997;Sometimes Elasticsearch mappings for dates need to include the format._This method returns appropriate mappings settings: at minimum "type"="date",_and possibly also a "format" setting.;public Map<String, String> getEsDateMappingTypeWithFormat() {_            if (javaTimestampFormats.contains("TAI64N")) {_                _                return Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, "keyword")__            }_            Map<String, String> mapping = new LinkedHashMap<>()__            mapping.put(FileStructureUtils.MAPPING_TYPE_SETTING, "date")__            String formats = javaTimestampFormats.stream().flatMap(format -> {_                switch (format) {_                    case "ISO8601":_                        return Stream.empty()__                    case "UNIX_MS":_                        return Stream.of("epoch_millis")__                    case "UNIX":_                        return Stream.of("epoch_second")__                    default:_                        _                        return Stream.of("8" + format)__                }_            }).collect(Collectors.joining("||"))__            if (formats.isEmpty() == false) {_                mapping.put(FileStructureUtils.MAPPING_FORMAT_SETTING, formats)__            }_            return mapping__        };sometimes,elasticsearch,mappings,for,dates,need,to,include,the,format,this,method,returns,appropriate,mappings,settings,at,minimum,type,date,and,possibly,also,a,format,setting;public,map,string,string,get,es,date,mapping,type,with,format,if,java,timestamp,formats,contains,tai64n,return,collections,singleton,map,file,structure,utils,keyword,map,string,string,mapping,new,linked,hash,map,mapping,put,file,structure,utils,date,string,formats,java,timestamp,formats,stream,flat,map,format,switch,format,case,iso8601,return,stream,empty,case,return,stream,of,case,unix,return,stream,of,default,return,stream,of,8,format,collect,collectors,joining,if,formats,is,empty,false,mapping,put,file,structure,utils,formats,return,mapping
TimestampFormatFinder -> TimestampMatch -> public Map<String, String> getEsDateMappingTypeWithFormat();1549035364;Sometimes Elasticsearch mappings for dates need to include the format._This method returns appropriate mappings settings: at minimum "type"="date",_and possibly also a "format" setting.;public Map<String, String> getEsDateMappingTypeWithFormat() {_            if (javaTimestampFormats.contains("TAI64N")) {_                _                return Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, "keyword")__            }_            Map<String, String> mapping = new LinkedHashMap<>()__            mapping.put(FileStructureUtils.MAPPING_TYPE_SETTING, "date")__            String formats = javaTimestampFormats.stream().flatMap(format -> {_                switch (format) {_                    case "ISO8601":_                        return Stream.empty()__                    case "UNIX_MS":_                        return Stream.of("epoch_millis")__                    case "UNIX":_                        return Stream.of("epoch_second")__                    default:_                        return Stream.of(format)__                }_            }).collect(Collectors.joining("||"))__            if (formats.isEmpty() == false) {_                mapping.put(FileStructureUtils.MAPPING_FORMAT_SETTING, formats)__            }_            return mapping__        };sometimes,elasticsearch,mappings,for,dates,need,to,include,the,format,this,method,returns,appropriate,mappings,settings,at,minimum,type,date,and,possibly,also,a,format,setting;public,map,string,string,get,es,date,mapping,type,with,format,if,java,timestamp,formats,contains,tai64n,return,collections,singleton,map,file,structure,utils,keyword,map,string,string,mapping,new,linked,hash,map,mapping,put,file,structure,utils,date,string,formats,java,timestamp,formats,stream,flat,map,format,switch,format,case,iso8601,return,stream,empty,case,return,stream,of,case,unix,return,stream,of,default,return,stream,of,format,collect,collectors,joining,if,formats,is,empty,false,mapping,put,file,structure,utils,formats,return,mapping
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat);1536964057;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text             The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A date format that any returned match must support._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat) {_        Boolean[] quickRuleoutMatches = new Boolean[QUICK_RULE_OUT_PATTERNS.size()]__        int index = ignoreCandidates__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (requiredFormat == null || candidate.dateFormats.contains(requiredFormat)) {_                boolean quicklyRuledOut = false__                for (Integer quickRuleOutIndex : candidate.quickRuleOutIndices) {_                    if (quickRuleoutMatches[quickRuleOutIndex] == null) {_                        quickRuleoutMatches[quickRuleOutIndex] = QUICK_RULE_OUT_PATTERNS.get(quickRuleOutIndex).matcher(text).find()__                    }_                    if (quickRuleoutMatches[quickRuleOutIndex] == false) {_                        quicklyRuledOut = true__                        break__                    }_                }_                if (quicklyRuledOut == false) {_                    Map<String, Object> captures = candidate.strictSearchGrok.captures(text)__                    if (captures != null) {_                        String preface = captures.getOrDefault(PREFACE, "").toString()__                        String epilogue = captures.getOrDefault(EPILOGUE, "").toString()__                        return makeTimestampMatch(candidate, index, preface, text.substring(preface.length(),_                            text.length() - epilogue.length()), epilogue)__                    }_                }_            }_            ++index__        }_        return null__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,date,format,that,any,returned,match,must,support,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,string,required,format,boolean,quick,ruleout,matches,new,boolean,size,int,index,ignore,candidates,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,required,format,null,candidate,date,formats,contains,required,format,boolean,quickly,ruled,out,false,for,integer,quick,rule,out,index,candidate,quick,rule,out,indices,if,quick,ruleout,matches,quick,rule,out,index,null,quick,ruleout,matches,quick,rule,out,index,get,quick,rule,out,index,matcher,text,find,if,quick,ruleout,matches,quick,rule,out,index,false,quickly,ruled,out,true,break,if,quickly,ruled,out,false,map,string,object,captures,candidate,strict,search,grok,captures,text,if,captures,null,string,preface,captures,get,or,default,preface,to,string,string,epilogue,captures,get,or,default,epilogue,to,string,return,make,timestamp,match,candidate,index,preface,text,substring,preface,length,text,length,epilogue,length,epilogue,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat);1538067637;Find the first timestamp format that matches part of the supplied value,_excluding a specified number of candidate formats._@param text             The value that the returned timestamp format must exist within._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A timestamp format that any returned match must support._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat) {_        if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {_            return null__        }_        Boolean[] quickRuleoutMatches = new Boolean[QUICK_RULE_OUT_PATTERNS.size()]__        int index = ignoreCandidates__        String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat)__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) ||_                candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {_                boolean quicklyRuledOut = false__                for (Integer quickRuleOutIndex : candidate.quickRuleOutIndices) {_                    if (quickRuleoutMatches[quickRuleOutIndex] == null) {_                        quickRuleoutMatches[quickRuleOutIndex] = QUICK_RULE_OUT_PATTERNS.get(quickRuleOutIndex).matcher(text).find()__                    }_                    if (quickRuleoutMatches[quickRuleOutIndex] == false) {_                        quicklyRuledOut = true__                        break__                    }_                }_                if (quicklyRuledOut == false) {_                    Map<String, Object> captures = candidate.strictSearchGrok.captures(text)__                    if (captures != null) {_                        String preface = captures.getOrDefault(PREFACE, "").toString()__                        String epilogue = captures.getOrDefault(EPILOGUE, "").toString()__                        return makeTimestampMatch(candidate, index, preface, text.substring(preface.length(),_                            text.length() - epilogue.length()), epilogue)__                    }_                }_            }_            ++index__        }_        return null__    };find,the,first,timestamp,format,that,matches,part,of,the,supplied,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,exist,within,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,timestamp,format,that,any,returned,match,must,support,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,match,string,text,int,ignore,candidates,string,required,format,if,ignore,candidates,size,return,null,boolean,quick,ruleout,matches,new,boolean,size,int,index,ignore,candidates,string,adjusted,required,format,adjust,required,format,required,format,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,adjusted,required,format,null,candidate,joda,timestamp,formats,contains,adjusted,required,format,candidate,java,timestamp,formats,contains,adjusted,required,format,boolean,quickly,ruled,out,false,for,integer,quick,rule,out,index,candidate,quick,rule,out,indices,if,quick,ruleout,matches,quick,rule,out,index,null,quick,ruleout,matches,quick,rule,out,index,get,quick,rule,out,index,matcher,text,find,if,quick,ruleout,matches,quick,rule,out,index,false,quickly,ruled,out,true,break,if,quickly,ruled,out,false,map,string,object,captures,candidate,strict,search,grok,captures,text,if,captures,null,string,preface,captures,get,or,default,preface,to,string,string,epilogue,captures,get,or,default,epilogue,to,string,return,make,timestamp,match,candidate,index,preface,text,substring,preface,length,text,length,epilogue,length,epilogue,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat,                                                     TimeoutChecker timeoutChecker);1544771889;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat,_                                                    TimeoutChecker timeoutChecker) {_        if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {_            return null__        }_        int index = ignoreCandidates__        String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat)__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) ||_                candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {_                Map<String, Object> captures = timeoutChecker.grokCaptures(candidate.strictFullMatchGrok, text,_                    "timestamp format determination")__                if (captures != null) {_                    return makeTimestampMatch(candidate, index, "", text, "")__                }_            }_            ++index__        }_        return null__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,string,required,format,timeout,checker,timeout,checker,if,ignore,candidates,size,return,null,int,index,ignore,candidates,string,adjusted,required,format,adjust,required,format,required,format,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,adjusted,required,format,null,candidate,joda,timestamp,formats,contains,adjusted,required,format,candidate,java,timestamp,formats,contains,adjusted,required,format,map,string,object,captures,timeout,checker,grok,captures,candidate,strict,full,match,grok,text,timestamp,format,determination,if,captures,null,return,make,timestamp,match,candidate,index,text,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat,                                                     TimeoutChecker timeoutChecker);1548533997;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat,_                                                    TimeoutChecker timeoutChecker) {_        if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {_            return null__        }_        int index = ignoreCandidates__        String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat)__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) ||_                candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {_                Map<String, Object> captures = timeoutChecker.grokCaptures(candidate.strictFullMatchGrok, text,_                    "timestamp format determination")__                if (captures != null) {_                    return makeTimestampMatch(candidate, index, "", text, "")__                }_            }_            ++index__        }_        return null__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,string,required,format,timeout,checker,timeout,checker,if,ignore,candidates,size,return,null,int,index,ignore,candidates,string,adjusted,required,format,adjust,required,format,required,format,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,adjusted,required,format,null,candidate,joda,timestamp,formats,contains,adjusted,required,format,candidate,java,timestamp,formats,contains,adjusted,required,format,map,string,object,captures,timeout,checker,grok,captures,candidate,strict,full,match,grok,text,timestamp,format,determination,if,captures,null,return,make,timestamp,match,candidate,index,text,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat,                                                     TimeoutChecker timeoutChecker);1549035364;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A timestamp format that any returned match must support._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat,_                                                    TimeoutChecker timeoutChecker) {_        if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {_            return null__        }_        int index = ignoreCandidates__        String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat)__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) ||_                candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {_                Map<String, Object> captures = timeoutChecker.grokCaptures(candidate.strictFullMatchGrok, text,_                    "timestamp format determination")__                if (captures != null) {_                    return makeTimestampMatch(candidate, index, "", text, "")__                }_            }_            ++index__        }_        return null__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,timestamp,format,that,any,returned,match,must,support,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,string,required,format,timeout,checker,timeout,checker,if,ignore,candidates,size,return,null,int,index,ignore,candidates,string,adjusted,required,format,adjust,required,format,required,format,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,adjusted,required,format,null,candidate,joda,timestamp,formats,contains,adjusted,required,format,candidate,java,timestamp,formats,contains,adjusted,required,format,map,string,object,captures,timeout,checker,grok,captures,candidate,strict,full,match,grok,text,timestamp,format,determination,if,captures,null,return,make,timestamp,match,candidate,index,text,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat);1536964057;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A date format that any returned match must support._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat) {_        int index = ignoreCandidates__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (requiredFormat == null || candidate.dateFormats.contains(requiredFormat)) {_                Map<String, Object> captures = candidate.strictFullMatchGrok.captures(text)__                if (captures != null) {_                    return makeTimestampMatch(candidate, index, "", text, "")__                }_            }_            ++index__        }_        return null__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,date,format,that,any,returned,match,must,support,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,string,required,format,int,index,ignore,candidates,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,required,format,null,candidate,date,formats,contains,required,format,map,string,object,captures,candidate,strict,full,match,grok,captures,text,if,captures,null,return,make,timestamp,match,candidate,index,text,index,return,null
TimestampFormatFinder -> public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat);1538067637;Find the best timestamp format for matching an entire field value,_excluding a specified number of candidate formats._@param text The value that the returned timestamp format must match in its entirety._@param ignoreCandidates The number of candidate formats to exclude from the search._@param requiredFormat A timestamp format that any returned match must support._@return The timestamp format, or <code>null</code> if none matches.;public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat) {_        if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {_            return null__        }_        int index = ignoreCandidates__        String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat)__        for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {_            if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) ||_                candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {_                Map<String, Object> captures = candidate.strictFullMatchGrok.captures(text)__                if (captures != null) {_                    return makeTimestampMatch(candidate, index, "", text, "")__                }_            }_            ++index__        }_        return null__    };find,the,best,timestamp,format,for,matching,an,entire,field,value,excluding,a,specified,number,of,candidate,formats,param,text,the,value,that,the,returned,timestamp,format,must,match,in,its,entirety,param,ignore,candidates,the,number,of,candidate,formats,to,exclude,from,the,search,param,required,format,a,timestamp,format,that,any,returned,match,must,support,return,the,timestamp,format,or,code,null,code,if,none,matches;public,static,timestamp,match,find,first,full,match,string,text,int,ignore,candidates,string,required,format,if,ignore,candidates,size,return,null,int,index,ignore,candidates,string,adjusted,required,format,adjust,required,format,required,format,for,candidate,timestamp,format,candidate,sub,list,ignore,candidates,size,if,adjusted,required,format,null,candidate,joda,timestamp,formats,contains,adjusted,required,format,candidate,java,timestamp,formats,contains,adjusted,required,format,map,string,object,captures,candidate,strict,full,match,grok,captures,text,if,captures,null,return,make,timestamp,match,candidate,index,text,index,return,null
