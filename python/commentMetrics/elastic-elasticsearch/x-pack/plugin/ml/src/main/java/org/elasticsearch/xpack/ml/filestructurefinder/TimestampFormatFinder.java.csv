commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Find the first timestamp format that matches part of the supplied value.  * @param text The value that the returned timestamp format must exist within.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ ;/**  * Find the first timestamp format that matches part of the supplied value.  * @param text The value that the returned timestamp format must exist within.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ public static TimestampMatch findFirstMatch(String text, TimeoutChecker timeoutChecker) {     return findFirstMatch(text, 0, timeoutChecker). }
true;public,static;3;3;/**  * Find the first timestamp format that matches part of the supplied value.  * @param text The value that the returned timestamp format must exist within.  * @param requiredFormat A timestamp format that any returned match must support.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ ;/**  * Find the first timestamp format that matches part of the supplied value.  * @param text The value that the returned timestamp format must exist within.  * @param requiredFormat A timestamp format that any returned match must support.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ public static TimestampMatch findFirstMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker) {     return findFirstMatch(text, 0, requiredFormat, timeoutChecker). }
true;public,static;3;3;/**  * Find the first timestamp format that matches part of the supplied value,  * excluding a specified number of candidate formats.  * @param text The value that the returned timestamp format must exist within.  * @param ignoreCandidates The number of candidate formats to exclude from the search.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ ;/**  * Find the first timestamp format that matches part of the supplied value,  * excluding a specified number of candidate formats.  * @param text The value that the returned timestamp format must exist within.  * @param ignoreCandidates The number of candidate formats to exclude from the search.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker) {     return findFirstMatch(text, ignoreCandidates, null, timeoutChecker). }
true;public,static;4;35;/**  * Find the first timestamp format that matches part of the supplied value,  * excluding a specified number of candidate formats.  * @param text             The value that the returned timestamp format must exist within.  * @param ignoreCandidates The number of candidate formats to exclude from the search.  * @param requiredFormat A timestamp format that any returned match must support.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ ;/**  * Find the first timestamp format that matches part of the supplied value,  * excluding a specified number of candidate formats.  * @param text             The value that the returned timestamp format must exist within.  * @param ignoreCandidates The number of candidate formats to exclude from the search.  * @param requiredFormat A timestamp format that any returned match must support.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ public static TimestampMatch findFirstMatch(String text, int ignoreCandidates, String requiredFormat, TimeoutChecker timeoutChecker) {     if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {         return null.     }     Boolean[] quickRuleoutMatches = new Boolean[QUICK_RULE_OUT_PATTERNS.size()].     int index = ignoreCandidates.     String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat).     for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {         if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) || candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {             boolean quicklyRuledOut = false.             for (Integer quickRuleOutIndex : candidate.quickRuleOutIndices) {                 if (quickRuleoutMatches[quickRuleOutIndex] == null) {                     quickRuleoutMatches[quickRuleOutIndex] = QUICK_RULE_OUT_PATTERNS.get(quickRuleOutIndex).matcher(text).find().                 }                 if (quickRuleoutMatches[quickRuleOutIndex] == false) {                     quicklyRuledOut = true.                     break.                 }             }             if (quicklyRuledOut == false) {                 Map<String, Object> captures = timeoutChecker.grokCaptures(candidate.strictSearchGrok, text, "timestamp format determination").                 if (captures != null) {                     String preface = captures.getOrDefault(PREFACE, "").toString().                     String epilogue = captures.getOrDefault(EPILOGUE, "").toString().                     return makeTimestampMatch(candidate, index, preface, text.substring(preface.length(), text.length() - epilogue.length()), epilogue).                 }             }         }         ++index.     }     return null. }
true;public,static;2;3;/**  * Find the best timestamp format for matching an entire field value.  * @param text The value that the returned timestamp format must match in its entirety.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ ;/**  * Find the best timestamp format for matching an entire field value.  * @param text The value that the returned timestamp format must match in its entirety.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ public static TimestampMatch findFirstFullMatch(String text, TimeoutChecker timeoutChecker) {     return findFirstFullMatch(text, 0, timeoutChecker). }
true;public,static;3;3;/**  * Find the best timestamp format for matching an entire field value.  * @param text The value that the returned timestamp format must match in its entirety.  * @param requiredFormat A timestamp format that any returned match must support.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ ;/**  * Find the best timestamp format for matching an entire field value.  * @param text The value that the returned timestamp format must match in its entirety.  * @param requiredFormat A timestamp format that any returned match must support.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ public static TimestampMatch findFirstFullMatch(String text, String requiredFormat, TimeoutChecker timeoutChecker) {     return findFirstFullMatch(text, 0, requiredFormat, timeoutChecker). }
true;public,static;3;3;/**  * Find the best timestamp format for matching an entire field value,  * excluding a specified number of candidate formats.  * @param text The value that the returned timestamp format must match in its entirety.  * @param ignoreCandidates The number of candidate formats to exclude from the search.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ ;/**  * Find the best timestamp format for matching an entire field value,  * excluding a specified number of candidate formats.  * @param text The value that the returned timestamp format must match in its entirety.  * @param ignoreCandidates The number of candidate formats to exclude from the search.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, TimeoutChecker timeoutChecker) {     return findFirstFullMatch(text, ignoreCandidates, null, timeoutChecker). }
true;public,static;4;20;/**  * Find the best timestamp format for matching an entire field value,  * excluding a specified number of candidate formats.  * @param text The value that the returned timestamp format must match in its entirety.  * @param ignoreCandidates The number of candidate formats to exclude from the search.  * @param requiredFormat A timestamp format that any returned match must support.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ ;/**  * Find the best timestamp format for matching an entire field value,  * excluding a specified number of candidate formats.  * @param text The value that the returned timestamp format must match in its entirety.  * @param ignoreCandidates The number of candidate formats to exclude from the search.  * @param requiredFormat A timestamp format that any returned match must support.  * @param timeoutChecker Will abort the operation if its timeout is exceeded.  * @return The timestamp format, or <code>null</code> if none matches.  */ public static TimestampMatch findFirstFullMatch(String text, int ignoreCandidates, String requiredFormat, TimeoutChecker timeoutChecker) {     if (ignoreCandidates >= ORDERED_CANDIDATE_FORMATS.size()) {         return null.     }     int index = ignoreCandidates.     String adjustedRequiredFormat = adjustRequiredFormat(requiredFormat).     for (CandidateTimestampFormat candidate : ORDERED_CANDIDATE_FORMATS.subList(ignoreCandidates, ORDERED_CANDIDATE_FORMATS.size())) {         if (adjustedRequiredFormat == null || candidate.jodaTimestampFormats.contains(adjustedRequiredFormat) || candidate.javaTimestampFormats.contains(adjustedRequiredFormat)) {             Map<String, Object> captures = timeoutChecker.grokCaptures(candidate.strictFullMatchGrok, text, "timestamp format determination").             if (captures != null) {                 return makeTimestampMatch(candidate, index, "", text, "").             }         }         ++index.     }     return null. }
true;static;1;5;/**  * If a required timestamp format contains a fractional seconds component, adjust it to the  * fractional seconds format that's in the candidate timestamp formats, i.e. ",SSS".  So, for  * example, "YYYY-MM-dd HH:mm:ss.SSSSSSSSS Z" would get adjusted to "YYYY-MM-dd HH:mm:ss,SSS Z".  */ ;/**  * If a required timestamp format contains a fractional seconds component, adjust it to the  * fractional seconds format that's in the candidate timestamp formats, i.e. ",SSS".  So, for  * example, "YYYY-MM-dd HH:mm:ss.SSSSSSSSS Z" would get adjusted to "YYYY-MM-dd HH:mm:ss,SSS Z".  */ static String adjustRequiredFormat(String requiredFormat) {     return (requiredFormat == null) ? null : FRACTIONAL_SECOND_TIMESTAMP_FORMAT_PATTERN.matcher(requiredFormat).replaceFirst(DEFAULT_FRACTIONAL_SECOND_FORMAT). }
false;private,static;5;37;;private static TimestampMatch makeTimestampMatch(CandidateTimestampFormat chosenTimestampFormat, int chosenIndex, String preface, String matchedDate, String epilogue) {     Tuple<Character, Integer> fractionalSecondsInterpretation = interpretFractionalSeconds(matchedDate).     List<String> jodaTimestampFormats = chosenTimestampFormat.jodaTimestampFormats.     List<String> javaTimestampFormats = chosenTimestampFormat.javaTimestampFormats.     Pattern simplePattern = chosenTimestampFormat.simplePattern.     char separator = fractionalSecondsInterpretation.v1().     if (separator != DEFAULT_FRACTIONAL_SECOND_SEPARATOR) {         jodaTimestampFormats = jodaTimestampFormats.stream().map(jodaTimestampFormat -> jodaTimestampFormat.replace(DEFAULT_FRACTIONAL_SECOND_SEPARATOR, separator)).collect(Collectors.toList()).         javaTimestampFormats = javaTimestampFormats.stream().map(javaTimestampFormat -> javaTimestampFormat.replace(DEFAULT_FRACTIONAL_SECOND_SEPARATOR, separator)).collect(Collectors.toList()).         if (jodaTimestampFormats.stream().noneMatch(jodaTimestampFormat -> jodaTimestampFormat.startsWith("UNIX"))) {             String patternStr = simplePattern.pattern().             int separatorPos = patternStr.lastIndexOf(DEFAULT_FRACTIONAL_SECOND_SEPARATOR).             if (separatorPos >= 0) {                 StringBuilder newPatternStr = new StringBuilder(patternStr).                 newPatternStr.replace(separatorPos, separatorPos + 1, ((separator == '.') ? "\\" : "") + separator).                 simplePattern = Pattern.compile(newPatternStr.toString()).             }         }     }     int numberOfDigitsInFractionalComponent = fractionalSecondsInterpretation.v2().     if (numberOfDigitsInFractionalComponent > 3) {         String fractionalSecondsFormat = "SSSSSSSSS".substring(0, numberOfDigitsInFractionalComponent).         jodaTimestampFormats = jodaTimestampFormats.stream().map(jodaTimestampFormat -> jodaTimestampFormat.replace("SSS", fractionalSecondsFormat)).collect(Collectors.toList()).         javaTimestampFormats = javaTimestampFormats.stream().map(javaTimestampFormat -> javaTimestampFormat.replace("SSS", fractionalSecondsFormat)).collect(Collectors.toList()).     }     return new TimestampMatch(chosenIndex, preface, jodaTimestampFormats, javaTimestampFormats, simplePattern, chosenTimestampFormat.standardGrokPatternName, epilogue). }
true;static;1;9;/**  * Interpret the fractional seconds component of a date to determine two things:  * 1. The separator character - one of colon, comma and dot.  * 2. The number of digits in the fractional component.  * @param date The textual representation of the date for which fractional seconds are to be interpreted.  * @return A tuple of (fractional second separator character, number of digits in fractional component).  */ ;/**  * Interpret the fractional seconds component of a date to determine two things:  * 1. The separator character - one of colon, comma and dot.  * 2. The number of digits in the fractional component.  * @param date The textual representation of the date for which fractional seconds are to be interpreted.  * @return A tuple of (fractional second separator character, number of digits in fractional component).  */ static Tuple<Character, Integer> interpretFractionalSeconds(String date) {     Matcher matcher = FRACTIONAL_SECOND_INTERPRETER.matcher(date).     if (matcher.find()) {         return new Tuple<>(matcher.group(1).charAt(0), matcher.group(2).length()).     }     return new Tuple<>(DEFAULT_FRACTIONAL_SECOND_SEPARATOR, 0). }
true;public;0;4;/**  * Does the parsing the timestamp produce different results depending on the timezone of the parser?  * I.e., does the textual representation NOT define the timezone?  */ ;/**  * Does the parsing the timestamp produce different results depending on the timezone of the parser?  * I.e., does the textual representation NOT define the timezone?  */ public boolean hasTimezoneDependentParsing() {     return javaTimestampFormats.stream().anyMatch(javaTimestampFormat -> javaTimestampFormat.indexOf('X') == -1 && javaTimestampFormat.indexOf('z') == -1 && javaTimestampFormat.contains("mm")). }
true;public;0;24;/**  * Sometimes Elasticsearch mappings for dates need to include the format.  * This method returns appropriate mappings settings: at minimum "type"="date",  * and possibly also a "format" setting.  */ ;/**  * Sometimes Elasticsearch mappings for dates need to include the format.  * This method returns appropriate mappings settings: at minimum "type"="date",  * and possibly also a "format" setting.  */ public Map<String, String> getEsDateMappingTypeWithFormat() {     if (javaTimestampFormats.contains("TAI64N")) {         // There's no format for TAI64N in the timestamp formats used in mappings         return Collections.singletonMap(FileStructureUtils.MAPPING_TYPE_SETTING, "keyword").     }     Map<String, String> mapping = new LinkedHashMap<>().     mapping.put(FileStructureUtils.MAPPING_TYPE_SETTING, "date").     String formats = javaTimestampFormats.stream().flatMap(format -> {         switch(format) {             case "ISO8601":                 return Stream.empty().             case "UNIX_MS":                 return Stream.of("epoch_millis").             case "UNIX":                 return Stream.of("epoch_second").             default:                 return Stream.of(format).         }     }).collect(Collectors.joining("||")).     if (formats.isEmpty() == false) {         mapping.put(FileStructureUtils.MAPPING_FORMAT_SETTING, formats).     }     return mapping. }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(candidateIndex, preface, jodaTimestampFormats, javaTimestampFormats, simplePattern.pattern(), grokPatternName, epilogue). }
false;public;1;18;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     TimestampMatch that = (TimestampMatch) other.     return this.candidateIndex == that.candidateIndex && Objects.equals(this.preface, that.preface) && Objects.equals(this.jodaTimestampFormats, that.jodaTimestampFormats) && Objects.equals(this.javaTimestampFormats, that.javaTimestampFormats) && Objects.equals(this.simplePattern.pattern(), that.simplePattern.pattern()) && Objects.equals(this.grokPatternName, that.grokPatternName) && Objects.equals(this.epilogue, that.epilogue). }
false;public;0;8;;@Override public String toString() {     return "index = " + candidateIndex + (preface.isEmpty() ? "" : ", preface = '" + preface + "'") + ", Joda timestamp formats = " + jodaTimestampFormats.stream().collect(Collectors.joining("', '", "[ '", "' ]")) + ", Java timestamp formats = " + javaTimestampFormats.stream().collect(Collectors.joining("', '", "[ '", "' ]")) + ", simple pattern = '" + simplePattern.pattern() + "', grok pattern = '" + grokPatternName + "'" + (epilogue.isEmpty() ? "" : ", epilogue = '" + epilogue + "'"). }
