commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public List<ExtractedField> getAllFields() {     return allFields. }
false;public;0;3;;public String[] getSourceFields() {     return sourceFields. }
false;public;0;3;;public List<ExtractedField> getDocValueFields() {     return docValueFields. }
false;private,static;2;3;;private static List<ExtractedField> filterFields(ExtractedField.ExtractionMethod method, List<ExtractedField> fields) {     return fields.stream().filter(field -> field.getExtractionMethod() == method).collect(Collectors.toList()). }
false;public,static;3;5;;public static ExtractedFields build(Collection<String> allFields, Set<String> scriptFields, FieldCapabilitiesResponse fieldsCapabilities) {     ExtractionMethodDetector extractionMethodDetector = new ExtractionMethodDetector(scriptFields, fieldsCapabilities).     return new ExtractedFields(allFields.stream().map(field -> extractionMethodDetector.detect(field)).collect(Collectors.toList())). }
false;protected;1;22;;protected ExtractedField detect(String field) {     String internalField = field.     ExtractedField.ExtractionMethod method = ExtractedField.ExtractionMethod.SOURCE.     if (scriptFields.contains(field)) {         method = ExtractedField.ExtractionMethod.SCRIPT_FIELD.     } else if (isAggregatable(field)) {         method = ExtractedField.ExtractionMethod.DOC_VALUE.         if (isFieldOfType(field, "date")) {             return ExtractedField.newTimeField(field, method).         }     } else if (isFieldOfType(field, TEXT)) {         String parentField = MlStrings.getParentField(field).         // Field is text so check if it is a multi-field         if (Objects.equals(parentField, field) == false && fieldsCapabilities.getField(parentField) != null) {             // Field is a multi-field which means it won't be available in source. Let's take the parent instead.             internalField = parentField.             method = isAggregatable(parentField) ? ExtractedField.ExtractionMethod.DOC_VALUE : ExtractedField.ExtractionMethod.SOURCE.         }     }     return ExtractedField.newField(field, internalField, method). }
false;protected;1;12;;protected boolean isAggregatable(String field) {     Map<String, FieldCapabilities> fieldCaps = fieldsCapabilities.getField(field).     if (fieldCaps == null || fieldCaps.isEmpty()) {         throw new IllegalArgumentException("cannot retrieve field [" + field + "] because it has no mappings").     }     for (FieldCapabilities capsPerIndex : fieldCaps.values()) {         if (!capsPerIndex.isAggregatable()) {             return false.         }     }     return true. }
false;private;2;7;;private boolean isFieldOfType(String field, String type) {     Map<String, FieldCapabilities> fieldCaps = fieldsCapabilities.getField(field).     if (fieldCaps != null && fieldCaps.size() == 1) {         return fieldCaps.containsKey(type).     }     return false. }
