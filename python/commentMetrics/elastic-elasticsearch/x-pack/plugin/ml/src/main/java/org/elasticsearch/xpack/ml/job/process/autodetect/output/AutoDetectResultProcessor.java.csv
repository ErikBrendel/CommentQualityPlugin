# id;timestamp;commentText;codeText;commentWords;codeWords
AutoDetectResultProcessor -> @Nullable     public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout);1524684173;Blocks until a flush is acknowledged or the timeout expires, whichever happens first.__@param flushId the id of the flush request to wait for_@param timeout the timeout_@return The {@link FlushAcknowledgement} if the flush has completed or the parsing finished_ {@code null} if the timeout expired;@Nullable_    public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) {_        return failed ? null : flushListener.waitForFlush(flushId, timeout)__    };blocks,until,a,flush,is,acknowledged,or,the,timeout,expires,whichever,happens,first,param,flush,id,the,id,of,the,flush,request,to,wait,for,param,timeout,the,timeout,return,the,link,flush,acknowledgement,if,the,flush,has,completed,or,the,parsing,finished,code,null,if,the,timeout,expired;nullable,public,flush,acknowledgement,wait,for,flush,acknowledgement,string,flush,id,duration,timeout,return,failed,null,flush,listener,wait,for,flush,flush,id,timeout
AutoDetectResultProcessor -> @Nullable     public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout);1531179852;Blocks until a flush is acknowledged or the timeout expires, whichever happens first.__@param flushId the id of the flush request to wait for_@param timeout the timeout_@return The {@link FlushAcknowledgement} if the flush has completed or the parsing finished_ {@code null} if the timeout expired;@Nullable_    public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) {_        return failed ? null : flushListener.waitForFlush(flushId, timeout)__    };blocks,until,a,flush,is,acknowledged,or,the,timeout,expires,whichever,happens,first,param,flush,id,the,id,of,the,flush,request,to,wait,for,param,timeout,the,timeout,return,the,link,flush,acknowledgement,if,the,flush,has,completed,or,the,parsing,finished,code,null,if,the,timeout,expired;nullable,public,flush,acknowledgement,wait,for,flush,acknowledgement,string,flush,id,duration,timeout,return,failed,null,flush,listener,wait,for,flush,flush,id,timeout
AutoDetectResultProcessor -> synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay);1531179852;The purpose of this method is to avoid saturating the cluster state update thread_when a lookback job is churning through buckets very fast and the memory usage of_the job is changing regularly.  The idea is to only update the established model_memory associated with the job a few seconds after the new value has been received._If more updates are received during the delay period then they simply replace the_value that originally caused the update to be scheduled.  This rate limits cluster_state updates due to established model memory changing to one per job per delay period._(In reality updates will only occur this rapidly during lookback.  During real-time_operation the limit of one model size stats document per bucket will mean there is a_maximum of one cluster state update per job per bucket, and usually the bucket span_is 5 minutes or more.)_@param delay The delay before updating established model memory.;synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay) {__        if (scheduledEstablishedModelMemoryUpdate == null) {_            try {_                scheduledEstablishedModelMemoryUpdate = client.threadPool().schedule(delay, MachineLearning.UTILITY_THREAD_POOL_NAME,_                    () -> runEstablishedModelMemoryUpdate(false))__                LOGGER.trace("[{}] Scheduled established model memory update to run in [{}]", jobId, delay)__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    LOGGER.debug("failed to schedule established model memory update_ shutting down", e)__                } else {_                    throw e__                }_            }_        }_    };the,purpose,of,this,method,is,to,avoid,saturating,the,cluster,state,update,thread,when,a,lookback,job,is,churning,through,buckets,very,fast,and,the,memory,usage,of,the,job,is,changing,regularly,the,idea,is,to,only,update,the,established,model,memory,associated,with,the,job,a,few,seconds,after,the,new,value,has,been,received,if,more,updates,are,received,during,the,delay,period,then,they,simply,replace,the,value,that,originally,caused,the,update,to,be,scheduled,this,rate,limits,cluster,state,updates,due,to,established,model,memory,changing,to,one,per,job,per,delay,period,in,reality,updates,will,only,occur,this,rapidly,during,lookback,during,real,time,operation,the,limit,of,one,model,size,stats,document,per,bucket,will,mean,there,is,a,maximum,of,one,cluster,state,update,per,job,per,bucket,and,usually,the,bucket,span,is,5,minutes,or,more,param,delay,the,delay,before,updating,established,model,memory;synchronized,void,schedule,established,model,memory,update,time,value,delay,if,scheduled,established,model,memory,update,null,try,scheduled,established,model,memory,update,client,thread,pool,schedule,delay,machine,learning,run,established,model,memory,update,false,logger,trace,scheduled,established,model,memory,update,to,run,in,job,id,delay,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,failed,to,schedule,established,model,memory,update,shutting,down,e,else,throw,e
AutoDetectResultProcessor -> synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay);1533143718;The purpose of this method is to avoid saturating the cluster state update thread_when a lookback job is churning through buckets very fast and the memory usage of_the job is changing regularly.  The idea is to only update the established model_memory associated with the job a few seconds after the new value has been received._If more updates are received during the delay period then they simply replace the_value that originally caused the update to be scheduled.  This rate limits cluster_state updates due to established model memory changing to one per job per delay period._(In reality updates will only occur this rapidly during lookback.  During real-time_operation the limit of one model size stats document per bucket will mean there is a_maximum of one cluster state update per job per bucket, and usually the bucket span_is 5 minutes or more.)_@param delay The delay before updating established model memory.;synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay) {__        if (scheduledEstablishedModelMemoryUpdate == null) {_            try {_                scheduledEstablishedModelMemoryUpdate = client.threadPool().schedule(delay, MachineLearning.UTILITY_THREAD_POOL_NAME,_                    () -> runEstablishedModelMemoryUpdate(false))__                LOGGER.trace("[{}] Scheduled established model memory update to run in [{}]", jobId, delay)__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    LOGGER.debug("failed to schedule established model memory update_ shutting down", e)__                } else {_                    throw e__                }_            }_        }_    };the,purpose,of,this,method,is,to,avoid,saturating,the,cluster,state,update,thread,when,a,lookback,job,is,churning,through,buckets,very,fast,and,the,memory,usage,of,the,job,is,changing,regularly,the,idea,is,to,only,update,the,established,model,memory,associated,with,the,job,a,few,seconds,after,the,new,value,has,been,received,if,more,updates,are,received,during,the,delay,period,then,they,simply,replace,the,value,that,originally,caused,the,update,to,be,scheduled,this,rate,limits,cluster,state,updates,due,to,established,model,memory,changing,to,one,per,job,per,delay,period,in,reality,updates,will,only,occur,this,rapidly,during,lookback,during,real,time,operation,the,limit,of,one,model,size,stats,document,per,bucket,will,mean,there,is,a,maximum,of,one,cluster,state,update,per,job,per,bucket,and,usually,the,bucket,span,is,5,minutes,or,more,param,delay,the,delay,before,updating,established,model,memory;synchronized,void,schedule,established,model,memory,update,time,value,delay,if,scheduled,established,model,memory,update,null,try,scheduled,established,model,memory,update,client,thread,pool,schedule,delay,machine,learning,run,established,model,memory,update,false,logger,trace,scheduled,established,model,memory,update,to,run,in,job,id,delay,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,failed,to,schedule,established,model,memory,update,shutting,down,e,else,throw,e
AutoDetectResultProcessor -> synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay);1533230566;The purpose of this method is to avoid saturating the cluster state update thread_when a lookback job is churning through buckets very fast and the memory usage of_the job is changing regularly.  The idea is to only update the established model_memory associated with the job a few seconds after the new value has been received._If more updates are received during the delay period then they simply replace the_value that originally caused the update to be scheduled.  This rate limits cluster_state updates due to established model memory changing to one per job per delay period._(In reality updates will only occur this rapidly during lookback.  During real-time_operation the limit of one model size stats document per bucket will mean there is a_maximum of one cluster state update per job per bucket, and usually the bucket span_is 5 minutes or more.)_@param delay The delay before updating established model memory.;synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay) {__        if (scheduledEstablishedModelMemoryUpdate == null) {_            try {_                scheduledEstablishedModelMemoryUpdate = client.threadPool().schedule(delay, MachineLearning.UTILITY_THREAD_POOL_NAME,_                    () -> runEstablishedModelMemoryUpdate(false))__                LOGGER.trace("[{}] Scheduled established model memory update to run in [{}]", jobId, delay)__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    LOGGER.debug("failed to schedule established model memory update_ shutting down", e)__                } else {_                    throw e__                }_            }_        }_    };the,purpose,of,this,method,is,to,avoid,saturating,the,cluster,state,update,thread,when,a,lookback,job,is,churning,through,buckets,very,fast,and,the,memory,usage,of,the,job,is,changing,regularly,the,idea,is,to,only,update,the,established,model,memory,associated,with,the,job,a,few,seconds,after,the,new,value,has,been,received,if,more,updates,are,received,during,the,delay,period,then,they,simply,replace,the,value,that,originally,caused,the,update,to,be,scheduled,this,rate,limits,cluster,state,updates,due,to,established,model,memory,changing,to,one,per,job,per,delay,period,in,reality,updates,will,only,occur,this,rapidly,during,lookback,during,real,time,operation,the,limit,of,one,model,size,stats,document,per,bucket,will,mean,there,is,a,maximum,of,one,cluster,state,update,per,job,per,bucket,and,usually,the,bucket,span,is,5,minutes,or,more,param,delay,the,delay,before,updating,established,model,memory;synchronized,void,schedule,established,model,memory,update,time,value,delay,if,scheduled,established,model,memory,update,null,try,scheduled,established,model,memory,update,client,thread,pool,schedule,delay,machine,learning,run,established,model,memory,update,false,logger,trace,scheduled,established,model,memory,update,to,run,in,job,id,delay,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,failed,to,schedule,established,model,memory,update,shutting,down,e,else,throw,e
AutoDetectResultProcessor -> synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay);1540847035;The purpose of this method is to avoid saturating the cluster state update thread_when a lookback job is churning through buckets very fast and the memory usage of_the job is changing regularly.  The idea is to only update the established model_memory associated with the job a few seconds after the new value has been received._If more updates are received during the delay period then they simply replace the_value that originally caused the update to be scheduled.  This rate limits cluster_state updates due to established model memory changing to one per job per delay period._(In reality updates will only occur this rapidly during lookback.  During real-time_operation the limit of one model size stats document per bucket will mean there is a_maximum of one cluster state update per job per bucket, and usually the bucket span_is 5 minutes or more.)_@param delay The delay before updating established model memory.;synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay) {__        if (scheduledEstablishedModelMemoryUpdate == null) {_            try {_                scheduledEstablishedModelMemoryUpdate = client.threadPool().schedule(delay, MachineLearning.UTILITY_THREAD_POOL_NAME,_                    () -> runEstablishedModelMemoryUpdate(false))__                LOGGER.trace("[{}] Scheduled established model memory update to run in [{}]", jobId, delay)__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    LOGGER.debug("failed to schedule established model memory update_ shutting down", e)__                } else {_                    throw e__                }_            }_        }_    };the,purpose,of,this,method,is,to,avoid,saturating,the,cluster,state,update,thread,when,a,lookback,job,is,churning,through,buckets,very,fast,and,the,memory,usage,of,the,job,is,changing,regularly,the,idea,is,to,only,update,the,established,model,memory,associated,with,the,job,a,few,seconds,after,the,new,value,has,been,received,if,more,updates,are,received,during,the,delay,period,then,they,simply,replace,the,value,that,originally,caused,the,update,to,be,scheduled,this,rate,limits,cluster,state,updates,due,to,established,model,memory,changing,to,one,per,job,per,delay,period,in,reality,updates,will,only,occur,this,rapidly,during,lookback,during,real,time,operation,the,limit,of,one,model,size,stats,document,per,bucket,will,mean,there,is,a,maximum,of,one,cluster,state,update,per,job,per,bucket,and,usually,the,bucket,span,is,5,minutes,or,more,param,delay,the,delay,before,updating,established,model,memory;synchronized,void,schedule,established,model,memory,update,time,value,delay,if,scheduled,established,model,memory,update,null,try,scheduled,established,model,memory,update,client,thread,pool,schedule,delay,machine,learning,run,established,model,memory,update,false,logger,trace,scheduled,established,model,memory,update,to,run,in,job,id,delay,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,failed,to,schedule,established,model,memory,update,shutting,down,e,else,throw,e
AutoDetectResultProcessor -> synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay);1544175231;The purpose of this method is to avoid saturating the cluster state update thread_when a lookback job is churning through buckets very fast and the memory usage of_the job is changing regularly.  The idea is to only update the established model_memory associated with the job a few seconds after the new value has been received._If more updates are received during the delay period then they simply replace the_value that originally caused the update to be scheduled.  This rate limits cluster_state updates due to established model memory changing to one per job per delay period._(In reality updates will only occur this rapidly during lookback.  During real-time_operation the limit of one model size stats document per bucket will mean there is a_maximum of one cluster state update per job per bucket, and usually the bucket span_is 5 minutes or more.)_@param delay The delay before updating established model memory.;synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay) {__        if (scheduledEstablishedModelMemoryUpdate == null) {_            try {_                scheduledEstablishedModelMemoryUpdate = client.threadPool().schedule(delay, MachineLearning.UTILITY_THREAD_POOL_NAME,_                    () -> runEstablishedModelMemoryUpdate(false))__                LOGGER.trace("[{}] Scheduled established model memory update to run in [{}]", jobId, delay)__            } catch (EsRejectedExecutionException e) {_                if (e.isExecutorShutdown()) {_                    LOGGER.debug("failed to schedule established model memory update_ shutting down", e)__                } else {_                    throw e__                }_            }_        }_    };the,purpose,of,this,method,is,to,avoid,saturating,the,cluster,state,update,thread,when,a,lookback,job,is,churning,through,buckets,very,fast,and,the,memory,usage,of,the,job,is,changing,regularly,the,idea,is,to,only,update,the,established,model,memory,associated,with,the,job,a,few,seconds,after,the,new,value,has,been,received,if,more,updates,are,received,during,the,delay,period,then,they,simply,replace,the,value,that,originally,caused,the,update,to,be,scheduled,this,rate,limits,cluster,state,updates,due,to,established,model,memory,changing,to,one,per,job,per,delay,period,in,reality,updates,will,only,occur,this,rapidly,during,lookback,during,real,time,operation,the,limit,of,one,model,size,stats,document,per,bucket,will,mean,there,is,a,maximum,of,one,cluster,state,update,per,job,per,bucket,and,usually,the,bucket,span,is,5,minutes,or,more,param,delay,the,delay,before,updating,established,model,memory;synchronized,void,schedule,established,model,memory,update,time,value,delay,if,scheduled,established,model,memory,update,null,try,scheduled,established,model,memory,update,client,thread,pool,schedule,delay,machine,learning,run,established,model,memory,update,false,logger,trace,scheduled,established,model,memory,update,to,run,in,job,id,delay,catch,es,rejected,execution,exception,e,if,e,is,executor,shutdown,logger,debug,failed,to,schedule,established,model,memory,update,shutting,down,e,else,throw,e
AutoDetectResultProcessor -> private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting);1531179852;This method is called from two places:_- From the {@link Future} used for delayed updates_- When shutting down this result processor_When shutting down the result processor it's only necessary to do anything_if an update has been scheduled, but we want to do the update immediately._Despite cancelling the scheduled update in this case, it's possible that_it's already started running, in which case this method will get called_twice in quick succession.  But the second call will do nothing, as_<code>scheduledEstablishedModelMemoryUpdate</code> will have been reset_to <code>null</code> by the first call.;private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting) {__        if (scheduledEstablishedModelMemoryUpdate != null) {_            if (cancelExisting) {_                LOGGER.debug("[{}] Bringing forward previously scheduled established model memory update", jobId)__                FutureUtils.cancel(scheduledEstablishedModelMemoryUpdate)__            }_            scheduledEstablishedModelMemoryUpdate = null__            updateEstablishedModelMemoryOnJob()__        }_    };this,method,is,called,from,two,places,from,the,link,future,used,for,delayed,updates,when,shutting,down,this,result,processor,when,shutting,down,the,result,processor,it,s,only,necessary,to,do,anything,if,an,update,has,been,scheduled,but,we,want,to,do,the,update,immediately,despite,cancelling,the,scheduled,update,in,this,case,it,s,possible,that,it,s,already,started,running,in,which,case,this,method,will,get,called,twice,in,quick,succession,but,the,second,call,will,do,nothing,as,code,scheduled,established,model,memory,update,code,will,have,been,reset,to,code,null,code,by,the,first,call;private,synchronized,void,run,established,model,memory,update,boolean,cancel,existing,if,scheduled,established,model,memory,update,null,if,cancel,existing,logger,debug,bringing,forward,previously,scheduled,established,model,memory,update,job,id,future,utils,cancel,scheduled,established,model,memory,update,scheduled,established,model,memory,update,null,update,established,model,memory,on,job
AutoDetectResultProcessor -> private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting);1533143718;This method is called from two places:_- From the {@link Future} used for delayed updates_- When shutting down this result processor_When shutting down the result processor it's only necessary to do anything_if an update has been scheduled, but we want to do the update immediately._Despite cancelling the scheduled update in this case, it's possible that_it's already started running, in which case this method will get called_twice in quick succession.  But the second call will do nothing, as_<code>scheduledEstablishedModelMemoryUpdate</code> will have been reset_to <code>null</code> by the first call.;private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting) {__        if (scheduledEstablishedModelMemoryUpdate != null) {_            if (cancelExisting) {_                LOGGER.debug("[{}] Bringing forward previously scheduled established model memory update", jobId)__                FutureUtils.cancel(scheduledEstablishedModelMemoryUpdate)__            }_            scheduledEstablishedModelMemoryUpdate = null__            updateEstablishedModelMemoryOnJob()__        }_    };this,method,is,called,from,two,places,from,the,link,future,used,for,delayed,updates,when,shutting,down,this,result,processor,when,shutting,down,the,result,processor,it,s,only,necessary,to,do,anything,if,an,update,has,been,scheduled,but,we,want,to,do,the,update,immediately,despite,cancelling,the,scheduled,update,in,this,case,it,s,possible,that,it,s,already,started,running,in,which,case,this,method,will,get,called,twice,in,quick,succession,but,the,second,call,will,do,nothing,as,code,scheduled,established,model,memory,update,code,will,have,been,reset,to,code,null,code,by,the,first,call;private,synchronized,void,run,established,model,memory,update,boolean,cancel,existing,if,scheduled,established,model,memory,update,null,if,cancel,existing,logger,debug,bringing,forward,previously,scheduled,established,model,memory,update,job,id,future,utils,cancel,scheduled,established,model,memory,update,scheduled,established,model,memory,update,null,update,established,model,memory,on,job
AutoDetectResultProcessor -> private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting);1533230566;This method is called from two places:_- From the {@link Future} used for delayed updates_- When shutting down this result processor_When shutting down the result processor it's only necessary to do anything_if an update has been scheduled, but we want to do the update immediately._Despite cancelling the scheduled update in this case, it's possible that_it's already started running, in which case this method will get called_twice in quick succession.  But the second call will do nothing, as_<code>scheduledEstablishedModelMemoryUpdate</code> will have been reset_to <code>null</code> by the first call.;private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting) {__        if (scheduledEstablishedModelMemoryUpdate != null) {_            if (cancelExisting) {_                LOGGER.debug("[{}] Bringing forward previously scheduled established model memory update", jobId)__                FutureUtils.cancel(scheduledEstablishedModelMemoryUpdate)__            }_            scheduledEstablishedModelMemoryUpdate = null__            updateEstablishedModelMemoryOnJob()__        }_    };this,method,is,called,from,two,places,from,the,link,future,used,for,delayed,updates,when,shutting,down,this,result,processor,when,shutting,down,the,result,processor,it,s,only,necessary,to,do,anything,if,an,update,has,been,scheduled,but,we,want,to,do,the,update,immediately,despite,cancelling,the,scheduled,update,in,this,case,it,s,possible,that,it,s,already,started,running,in,which,case,this,method,will,get,called,twice,in,quick,succession,but,the,second,call,will,do,nothing,as,code,scheduled,established,model,memory,update,code,will,have,been,reset,to,code,null,code,by,the,first,call;private,synchronized,void,run,established,model,memory,update,boolean,cancel,existing,if,scheduled,established,model,memory,update,null,if,cancel,existing,logger,debug,bringing,forward,previously,scheduled,established,model,memory,update,job,id,future,utils,cancel,scheduled,established,model,memory,update,scheduled,established,model,memory,update,null,update,established,model,memory,on,job
AutoDetectResultProcessor -> private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting);1540847035;This method is called from two places:_- From the {@link Future} used for delayed updates_- When shutting down this result processor_When shutting down the result processor it's only necessary to do anything_if an update has been scheduled, but we want to do the update immediately._Despite cancelling the scheduled update in this case, it's possible that_it's already started running, in which case this method will get called_twice in quick succession.  But the second call will do nothing, as_<code>scheduledEstablishedModelMemoryUpdate</code> will have been reset_to <code>null</code> by the first call.;private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting) {__        if (scheduledEstablishedModelMemoryUpdate != null) {_            if (cancelExisting) {_                LOGGER.debug("[{}] Bringing forward previously scheduled established model memory update", jobId)__                FutureUtils.cancel(scheduledEstablishedModelMemoryUpdate)__            }_            scheduledEstablishedModelMemoryUpdate = null__            updateEstablishedModelMemoryOnJob()__        }_    };this,method,is,called,from,two,places,from,the,link,future,used,for,delayed,updates,when,shutting,down,this,result,processor,when,shutting,down,the,result,processor,it,s,only,necessary,to,do,anything,if,an,update,has,been,scheduled,but,we,want,to,do,the,update,immediately,despite,cancelling,the,scheduled,update,in,this,case,it,s,possible,that,it,s,already,started,running,in,which,case,this,method,will,get,called,twice,in,quick,succession,but,the,second,call,will,do,nothing,as,code,scheduled,established,model,memory,update,code,will,have,been,reset,to,code,null,code,by,the,first,call;private,synchronized,void,run,established,model,memory,update,boolean,cancel,existing,if,scheduled,established,model,memory,update,null,if,cancel,existing,logger,debug,bringing,forward,previously,scheduled,established,model,memory,update,job,id,future,utils,cancel,scheduled,established,model,memory,update,scheduled,established,model,memory,update,null,update,established,model,memory,on,job
AutoDetectResultProcessor -> private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting);1544175231;This method is called from two places:_- From the {@link Future} used for delayed updates_- When shutting down this result processor_When shutting down the result processor it's only necessary to do anything_if an update has been scheduled, but we want to do the update immediately._Despite cancelling the scheduled update in this case, it's possible that_it's already started running, in which case this method will get called_twice in quick succession.  But the second call will do nothing, as_<code>scheduledEstablishedModelMemoryUpdate</code> will have been reset_to <code>null</code> by the first call.;private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting) {__        if (scheduledEstablishedModelMemoryUpdate != null) {_            if (cancelExisting) {_                LOGGER.debug("[{}] Bringing forward previously scheduled established model memory update", jobId)__                FutureUtils.cancel(scheduledEstablishedModelMemoryUpdate)__            }_            scheduledEstablishedModelMemoryUpdate = null__            updateEstablishedModelMemoryOnJob()__        }_    };this,method,is,called,from,two,places,from,the,link,future,used,for,delayed,updates,when,shutting,down,this,result,processor,when,shutting,down,the,result,processor,it,s,only,necessary,to,do,anything,if,an,update,has,been,scheduled,but,we,want,to,do,the,update,immediately,despite,cancelling,the,scheduled,update,in,this,case,it,s,possible,that,it,s,already,started,running,in,which,case,this,method,will,get,called,twice,in,quick,succession,but,the,second,call,will,do,nothing,as,code,scheduled,established,model,memory,update,code,will,have,been,reset,to,code,null,code,by,the,first,call;private,synchronized,void,run,established,model,memory,update,boolean,cancel,existing,if,scheduled,established,model,memory,update,null,if,cancel,existing,logger,debug,bringing,forward,previously,scheduled,established,model,memory,update,job,id,future,utils,cancel,scheduled,established,model,memory,update,scheduled,established,model,memory,update,null,update,established,model,memory,on,job
AutoDetectResultProcessor -> @Nullable     public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException;1533143718;Blocks until a flush is acknowledged or the timeout expires, whichever happens first.__@param flushId the id of the flush request to wait for_@param timeout the timeout_@return The {@link FlushAcknowledgement} if the flush has completed or the parsing finished_ {@code null} if the timeout expired;@Nullable_    public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException {_        return failed ? null : flushListener.waitForFlush(flushId, timeout)__    };blocks,until,a,flush,is,acknowledged,or,the,timeout,expires,whichever,happens,first,param,flush,id,the,id,of,the,flush,request,to,wait,for,param,timeout,the,timeout,return,the,link,flush,acknowledgement,if,the,flush,has,completed,or,the,parsing,finished,code,null,if,the,timeout,expired;nullable,public,flush,acknowledgement,wait,for,flush,acknowledgement,string,flush,id,duration,timeout,throws,interrupted,exception,return,failed,null,flush,listener,wait,for,flush,flush,id,timeout
AutoDetectResultProcessor -> @Nullable     public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException;1533230566;Blocks until a flush is acknowledged or the timeout expires, whichever happens first.__@param flushId the id of the flush request to wait for_@param timeout the timeout_@return The {@link FlushAcknowledgement} if the flush has completed or the parsing finished_ {@code null} if the timeout expired;@Nullable_    public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException {_        return failed ? null : flushListener.waitForFlush(flushId, timeout)__    };blocks,until,a,flush,is,acknowledged,or,the,timeout,expires,whichever,happens,first,param,flush,id,the,id,of,the,flush,request,to,wait,for,param,timeout,the,timeout,return,the,link,flush,acknowledgement,if,the,flush,has,completed,or,the,parsing,finished,code,null,if,the,timeout,expired;nullable,public,flush,acknowledgement,wait,for,flush,acknowledgement,string,flush,id,duration,timeout,throws,interrupted,exception,return,failed,null,flush,listener,wait,for,flush,flush,id,timeout
AutoDetectResultProcessor -> @Nullable     public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException;1540847035;Blocks until a flush is acknowledged or the timeout expires, whichever happens first.__@param flushId the id of the flush request to wait for_@param timeout the timeout_@return The {@link FlushAcknowledgement} if the flush has completed or the parsing finished_ {@code null} if the timeout expired;@Nullable_    public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException {_        return failed ? null : flushListener.waitForFlush(flushId, timeout)__    };blocks,until,a,flush,is,acknowledged,or,the,timeout,expires,whichever,happens,first,param,flush,id,the,id,of,the,flush,request,to,wait,for,param,timeout,the,timeout,return,the,link,flush,acknowledgement,if,the,flush,has,completed,or,the,parsing,finished,code,null,if,the,timeout,expired;nullable,public,flush,acknowledgement,wait,for,flush,acknowledgement,string,flush,id,duration,timeout,throws,interrupted,exception,return,failed,null,flush,listener,wait,for,flush,flush,id,timeout
AutoDetectResultProcessor -> @Nullable     public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException;1544175231;Blocks until a flush is acknowledged or the timeout expires, whichever happens first.__@param flushId the id of the flush request to wait for_@param timeout the timeout_@return The {@link FlushAcknowledgement} if the flush has completed or the parsing finished_ {@code null} if the timeout expired;@Nullable_    public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException {_        return failed ? null : flushListener.waitForFlush(flushId, timeout)__    };blocks,until,a,flush,is,acknowledged,or,the,timeout,expires,whichever,happens,first,param,flush,id,the,id,of,the,flush,request,to,wait,for,param,timeout,the,timeout,return,the,link,flush,acknowledgement,if,the,flush,has,completed,or,the,parsing,finished,code,null,if,the,timeout,expired;nullable,public,flush,acknowledgement,wait,for,flush,acknowledgement,string,flush,id,duration,timeout,throws,interrupted,exception,return,failed,null,flush,listener,wait,for,flush,flush,id,timeout
AutoDetectResultProcessor -> @Nullable     public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException;1545155131;Blocks until a flush is acknowledged or the timeout expires, whichever happens first.__@param flushId the id of the flush request to wait for_@param timeout the timeout_@return The {@link FlushAcknowledgement} if the flush has completed or the parsing finished_ {@code null} if the timeout expired;@Nullable_    public FlushAcknowledgement waitForFlushAcknowledgement(String flushId, Duration timeout) throws InterruptedException {_        return failed ? null : flushListener.waitForFlush(flushId, timeout)__    };blocks,until,a,flush,is,acknowledged,or,the,timeout,expires,whichever,happens,first,param,flush,id,the,id,of,the,flush,request,to,wait,for,param,timeout,the,timeout,return,the,link,flush,acknowledgement,if,the,flush,has,completed,or,the,parsing,finished,code,null,if,the,timeout,expired;nullable,public,flush,acknowledgement,wait,for,flush,acknowledgement,string,flush,id,duration,timeout,throws,interrupted,exception,return,failed,null,flush,listener,wait,for,flush,flush,id,timeout
AutoDetectResultProcessor -> public boolean isFailed();1524684173;If failed then there was an error parsing the results that cannot be recovered from_@return true if failed;public boolean isFailed() {_        return failed__    };if,failed,then,there,was,an,error,parsing,the,results,that,cannot,be,recovered,from,return,true,if,failed;public,boolean,is,failed,return,failed
AutoDetectResultProcessor -> public boolean isFailed();1531179852;If failed then there was an error parsing the results that cannot be recovered from_@return true if failed;public boolean isFailed() {_        return failed__    };if,failed,then,there,was,an,error,parsing,the,results,that,cannot,be,recovered,from,return,true,if,failed;public,boolean,is,failed,return,failed
AutoDetectResultProcessor -> public boolean isFailed();1533143718;If failed then there was an error parsing the results that cannot be recovered from_@return true if failed;public boolean isFailed() {_        return failed__    };if,failed,then,there,was,an,error,parsing,the,results,that,cannot,be,recovered,from,return,true,if,failed;public,boolean,is,failed,return,failed
AutoDetectResultProcessor -> public boolean isFailed();1533230566;If failed then there was an error parsing the results that cannot be recovered from_@return true if failed;public boolean isFailed() {_        return failed__    };if,failed,then,there,was,an,error,parsing,the,results,that,cannot,be,recovered,from,return,true,if,failed;public,boolean,is,failed,return,failed
AutoDetectResultProcessor -> public boolean isFailed();1540847035;If failed then there was an error parsing the results that cannot be recovered from_@return true if failed;public boolean isFailed() {_        return failed__    };if,failed,then,there,was,an,error,parsing,the,results,that,cannot,be,recovered,from,return,true,if,failed;public,boolean,is,failed,return,failed
AutoDetectResultProcessor -> public boolean isFailed();1544175231;If failed then there was an error parsing the results that cannot be recovered from_@return true if failed;public boolean isFailed() {_        return failed__    };if,failed,then,there,was,an,error,parsing,the,results,that,cannot,be,recovered,from,return,true,if,failed;public,boolean,is,failed,return,failed
AutoDetectResultProcessor -> public boolean isFailed();1545155131;If failed then there was an error parsing the results that cannot be recovered from_@return true if failed;public boolean isFailed() {_        return failed__    };if,failed,then,there,was,an,error,parsing,the,results,that,cannot,be,recovered,from,return,true,if,failed;public,boolean,is,failed,return,failed
