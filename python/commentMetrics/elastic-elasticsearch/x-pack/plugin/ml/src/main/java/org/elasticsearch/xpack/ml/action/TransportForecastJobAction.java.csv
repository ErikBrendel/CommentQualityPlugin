commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;36;;@Override protected void taskOperation(ForecastJobAction.Request request, TransportOpenJobAction.JobTask task, ActionListener<ForecastJobAction.Response> listener) {     jobManager.getJob(task.getJobId(), ActionListener.wrap(job -> {         validate(job, request).         ForecastParams.Builder paramsBuilder = ForecastParams.builder().         if (request.getDuration() != null) {             paramsBuilder.duration(request.getDuration()).         }         if (request.getExpiresIn() != null) {             paramsBuilder.expiresIn(request.getExpiresIn()).         }         // tmp storage might be null, we do not log here, because it might not be         // required         Path tmpStorage = processManager.tryGetTmpStorage(task, FORECAST_LOCAL_STORAGE_LIMIT).         if (tmpStorage != null) {             paramsBuilder.tmpStorage(tmpStorage.toString()).         }         ForecastParams params = paramsBuilder.build().         processManager.forecastJob(task, params, e -> {             if (e == null) {                 getForecastRequestStats(request.getJobId(), params.getForecastId(), listener).             } else {                 listener.onFailure(e).             }         }).     }, listener::onFailure)). }
false;private;3;31;;private void getForecastRequestStats(String jobId, String forecastId, ActionListener<ForecastJobAction.Response> listener) {     Consumer<ForecastRequestStats> forecastRequestStatsHandler = forecastRequestStats -> {         if (forecastRequestStats == null) {             // paranoia case, it should not happen that we do not retrieve a result             listener.onFailure(new ElasticsearchException("Cannot run forecast: internal error, please check the logs")).         } else if (forecastRequestStats.getStatus() == ForecastRequestStats.ForecastRequestStatus.FAILED) {             List<String> messages = forecastRequestStats.getMessages().             if (messages.size() > 0) {                 String message = messages.get(0).                 // special case: if forecast failed due to insufficient disk space, log the setting                 if (message.contains("disk space is insufficient")) {                     message += " Minimum disk space required: [" + processManager.getMinLocalStorageAvailable() + "]".                 }                 listener.onFailure(ExceptionsHelper.badRequestException("Cannot run forecast: " + message)).             } else {                 // paranoia case, it should not be possible to have an empty message list                 listener.onFailure(new ElasticsearchException("Cannot run forecast: internal error, please check the logs")).             }         } else {             listener.onResponse(new ForecastJobAction.Response(true, forecastId)).         }     }.     jobResultsProvider.getForecastRequestStats(jobId, forecastId, forecastRequestStatsHandler, listener::onFailure). }
false;static;2;17;;static void validate(Job job, ForecastJobAction.Request request) {     if (job.getJobVersion() == null || job.getJobVersion().before(Version.V_6_1_0)) {         throw ExceptionsHelper.badRequestException("Cannot run forecast because jobs created prior to version 6.1 are not supported").     }     if (request.getDuration() != null) {         TimeValue duration = request.getDuration().         TimeValue bucketSpan = job.getAnalysisConfig().getBucketSpan().         if (duration.compareTo(bucketSpan) < 0) {             throw ExceptionsHelper.badRequestException("[" + DURATION.getPreferredName() + "] must be greater or equal to the bucket span: [" + duration.getStringRep() + "/" + bucketSpan.getStringRep() + "]").         }     } }
