# id;timestamp;commentText;codeText;commentWords;codeWords
FileStructureUtils -> static boolean isMoreLikelyTextThanKeyword(String str);1536314350;The thinking is that the longer the field value and the more spaces it contains,_the more likely it is that it should be indexed as text rather than keyword.;static boolean isMoreLikelyTextThanKeyword(String str) {_        int length = str.length()__        return length > KEYWORD_MAX_LEN || length - str.replaceAll("\\s", "").length() > KEYWORD_MAX_SPACES__    };the,thinking,is,that,the,longer,the,field,value,and,the,more,spaces,it,contains,the,more,likely,it,is,that,it,should,be,indexed,as,text,rather,than,keyword;static,boolean,is,more,likely,text,than,keyword,string,str,int,length,str,length,return,length,length,str,replace,all,s,length
FileStructureUtils -> static boolean isMoreLikelyTextThanKeyword(String str);1536964057;The thinking is that the longer the field value and the more spaces it contains,_the more likely it is that it should be indexed as text rather than keyword.;static boolean isMoreLikelyTextThanKeyword(String str) {_        int length = str.length()__        return length > KEYWORD_MAX_LEN || length - str.replaceAll("\\s", "").length() > KEYWORD_MAX_SPACES__    };the,thinking,is,that,the,longer,the,field,value,and,the,more,spaces,it,contains,the,more,likely,it,is,that,it,should,be,indexed,as,text,rather,than,keyword;static,boolean,is,more,likely,text,than,keyword,string,str,int,length,str,length,return,length,length,str,replace,all,s,length
FileStructureUtils -> static boolean isMoreLikelyTextThanKeyword(String str);1538067637;The thinking is that the longer the field value and the more spaces it contains,_the more likely it is that it should be indexed as text rather than keyword.;static boolean isMoreLikelyTextThanKeyword(String str) {_        int length = str.length()__        return length > KEYWORD_MAX_LEN || length - str.replaceAll("\\s", "").length() > KEYWORD_MAX_SPACES__    };the,thinking,is,that,the,longer,the,field,value,and,the,more,spaces,it,contains,the,more,likely,it,is,that,it,should,be,indexed,as,text,rather,than,keyword;static,boolean,is,more,likely,text,than,keyword,string,str,int,length,str,length,return,length,length,str,replace,all,s,length
FileStructureUtils -> static boolean isMoreLikelyTextThanKeyword(String str);1538170812;The thinking is that the longer the field value and the more spaces it contains,_the more likely it is that it should be indexed as text rather than keyword.;static boolean isMoreLikelyTextThanKeyword(String str) {_        int length = str.length()__        return length > KEYWORD_MAX_LEN || length - str.replaceAll("\\s", "").length() > KEYWORD_MAX_SPACES__    };the,thinking,is,that,the,longer,the,field,value,and,the,more,spaces,it,contains,the,more,likely,it,is,that,it,should,be,indexed,as,text,rather,than,keyword;static,boolean,is,more,likely,text,than,keyword,string,str,int,length,str,length,return,length,length,str,replace,all,s,length
FileStructureUtils -> static boolean isMoreLikelyTextThanKeyword(String str);1539615817;The thinking is that the longer the field value and the more spaces it contains,_the more likely it is that it should be indexed as text rather than keyword.;static boolean isMoreLikelyTextThanKeyword(String str) {_        int length = str.length()__        return length > KEYWORD_MAX_LEN || length - str.replaceAll("\\s", "").length() > KEYWORD_MAX_SPACES__    };the,thinking,is,that,the,longer,the,field,value,and,the,more,spaces,it,contains,the,more,likely,it,is,that,it,should,be,indexed,as,text,rather,than,keyword;static,boolean,is,more,likely,text,than,keyword,string,str,int,length,str,length,return,length,length,str,replace,all,s,length
FileStructureUtils -> static boolean isMoreLikelyTextThanKeyword(String str);1544771889;The thinking is that the longer the field value and the more spaces it contains,_the more likely it is that it should be indexed as text rather than keyword.;static boolean isMoreLikelyTextThanKeyword(String str) {_        int length = str.length()__        return length > KEYWORD_MAX_LEN || length - str.replaceAll("\\s", "").length() > KEYWORD_MAX_SPACES__    };the,thinking,is,that,the,longer,the,field,value,and,the,more,spaces,it,contains,the,more,likely,it,is,that,it,should,be,indexed,as,text,rather,than,keyword;static,boolean,is,more,likely,text,than,keyword,string,str,int,length,str,length,return,length,length,str,replace,all,s,length
FileStructureUtils -> static boolean isMoreLikelyTextThanKeyword(String str);1548533997;The thinking is that the longer the field value and the more spaces it contains,_the more likely it is that it should be indexed as text rather than keyword.;static boolean isMoreLikelyTextThanKeyword(String str) {_        int length = str.length()__        return length > KEYWORD_MAX_LEN || length - str.replaceAll("\\s", "").length() > KEYWORD_MAX_SPACES__    };the,thinking,is,that,the,longer,the,field,value,and,the,more,spaces,it,contains,the,more,likely,it,is,that,it,should,be,indexed,as,text,rather,than,keyword;static,boolean,is,more,likely,text,than,keyword,string,str,int,length,str,length,return,length,length,str,replace,all,s,length
FileStructureUtils -> static boolean isMoreLikelyTextThanKeyword(String str);1549035364;The thinking is that the longer the field value and the more spaces it contains,_the more likely it is that it should be indexed as text rather than keyword.;static boolean isMoreLikelyTextThanKeyword(String str) {_        int length = str.length()__        return length > KEYWORD_MAX_LEN || length - str.replaceAll("\\s", "").length() > KEYWORD_MAX_SPACES__    };the,thinking,is,that,the,longer,the,field,value,and,the,more,spaces,it,contains,the,more,likely,it,is,that,it,should,be,indexed,as,text,rather,than,keyword;static,boolean,is,more,likely,text,than,keyword,string,str,int,length,str,length,return,length,length,str,replace,all,s,length
FileStructureUtils -> public static Map<String, Object> makeIngestPipelineDefinition(String grokPattern, String timestampField, List<String> timestampFormats,                                                                    boolean needClientTimezone);1539615817;Create an ingest pipeline definition appropriate for the file structure._@param grokPattern The Grok pattern used for parsing semi-structured text formats.  <code>null</code> for_fully structured formats._@param timestampField The input field containing the timestamp to be parsed into <code>@timestamp</code>._<code>null</code> if there is no timestamp._@param timestampFormats Timestamp formats to be used for parsing {@code timestampField}._May be <code>null</code> if {@code timestampField} is also <code>null</code>._@param needClientTimezone Is the timezone of the client supplying data to ingest required to uniquely parse the timestamp?_@return The ingest pipeline definition, or <code>null</code> if none is required.;public static Map<String, Object> makeIngestPipelineDefinition(String grokPattern, String timestampField, List<String> timestampFormats,_                                                                   boolean needClientTimezone) {__        if (grokPattern == null && timestampField == null) {_            return null__        }__        Map<String, Object> pipeline = new LinkedHashMap<>()__        pipeline.put(Pipeline.DESCRIPTION_KEY, "Ingest pipeline created by file structure finder")___        List<Map<String, Object>> processors = new ArrayList<>()___        if (grokPattern != null) {_            Map<String, Object> grokProcessorSettings = new LinkedHashMap<>()__            grokProcessorSettings.put("field", "message")__            grokProcessorSettings.put("patterns", Collections.singletonList(grokPattern))__            processors.add(Collections.singletonMap("grok", grokProcessorSettings))__        }__        if (timestampField != null) {_            Map<String, Object> dateProcessorSettings = new LinkedHashMap<>()__            dateProcessorSettings.put("field", timestampField)__            if (needClientTimezone) {_                dateProcessorSettings.put("timezone", "{{ " + BEAT_TIMEZONE_FIELD + " }}")__            }_            dateProcessorSettings.put("formats", timestampFormats)__            processors.add(Collections.singletonMap("date", dateProcessorSettings))__        }__        _        if (grokPattern != null && timestampField != null) {_            processors.add(Collections.singletonMap("remove", Collections.singletonMap("field", timestampField)))__        }__        pipeline.put(Pipeline.PROCESSORS_KEY, processors)__        return pipeline__    };create,an,ingest,pipeline,definition,appropriate,for,the,file,structure,param,grok,pattern,the,grok,pattern,used,for,parsing,semi,structured,text,formats,code,null,code,for,fully,structured,formats,param,timestamp,field,the,input,field,containing,the,timestamp,to,be,parsed,into,code,timestamp,code,code,null,code,if,there,is,no,timestamp,param,timestamp,formats,timestamp,formats,to,be,used,for,parsing,code,timestamp,field,may,be,code,null,code,if,code,timestamp,field,is,also,code,null,code,param,need,client,timezone,is,the,timezone,of,the,client,supplying,data,to,ingest,required,to,uniquely,parse,the,timestamp,return,the,ingest,pipeline,definition,or,code,null,code,if,none,is,required;public,static,map,string,object,make,ingest,pipeline,definition,string,grok,pattern,string,timestamp,field,list,string,timestamp,formats,boolean,need,client,timezone,if,grok,pattern,null,timestamp,field,null,return,null,map,string,object,pipeline,new,linked,hash,map,pipeline,put,pipeline,ingest,pipeline,created,by,file,structure,finder,list,map,string,object,processors,new,array,list,if,grok,pattern,null,map,string,object,grok,processor,settings,new,linked,hash,map,grok,processor,settings,put,field,message,grok,processor,settings,put,patterns,collections,singleton,list,grok,pattern,processors,add,collections,singleton,map,grok,grok,processor,settings,if,timestamp,field,null,map,string,object,date,processor,settings,new,linked,hash,map,date,processor,settings,put,field,timestamp,field,if,need,client,timezone,date,processor,settings,put,timezone,date,processor,settings,put,formats,timestamp,formats,processors,add,collections,singleton,map,date,date,processor,settings,if,grok,pattern,null,timestamp,field,null,processors,add,collections,singleton,map,remove,collections,singleton,map,field,timestamp,field,pipeline,put,pipeline,processors,return,pipeline
FileStructureUtils -> public static Map<String, Object> makeIngestPipelineDefinition(String grokPattern, String timestampField, List<String> timestampFormats,                                                                    boolean needClientTimezone);1544771889;Create an ingest pipeline definition appropriate for the file structure._@param grokPattern The Grok pattern used for parsing semi-structured text formats.  <code>null</code> for_fully structured formats._@param timestampField The input field containing the timestamp to be parsed into <code>@timestamp</code>._<code>null</code> if there is no timestamp._@param timestampFormats Timestamp formats to be used for parsing {@code timestampField}._May be <code>null</code> if {@code timestampField} is also <code>null</code>._@param needClientTimezone Is the timezone of the client supplying data to ingest required to uniquely parse the timestamp?_@return The ingest pipeline definition, or <code>null</code> if none is required.;public static Map<String, Object> makeIngestPipelineDefinition(String grokPattern, String timestampField, List<String> timestampFormats,_                                                                   boolean needClientTimezone) {__        if (grokPattern == null && timestampField == null) {_            return null__        }__        Map<String, Object> pipeline = new LinkedHashMap<>()__        pipeline.put(Pipeline.DESCRIPTION_KEY, "Ingest pipeline created by file structure finder")___        List<Map<String, Object>> processors = new ArrayList<>()___        if (grokPattern != null) {_            Map<String, Object> grokProcessorSettings = new LinkedHashMap<>()__            grokProcessorSettings.put("field", "message")__            grokProcessorSettings.put("patterns", Collections.singletonList(grokPattern))__            processors.add(Collections.singletonMap("grok", grokProcessorSettings))__        }__        if (timestampField != null) {_            Map<String, Object> dateProcessorSettings = new LinkedHashMap<>()__            dateProcessorSettings.put("field", timestampField)__            if (needClientTimezone) {_                dateProcessorSettings.put("timezone", "{{ " + BEAT_TIMEZONE_FIELD + " }}")__            }_            dateProcessorSettings.put("formats", timestampFormats)__            processors.add(Collections.singletonMap("date", dateProcessorSettings))__        }__        _        if (grokPattern != null && timestampField != null) {_            processors.add(Collections.singletonMap("remove", Collections.singletonMap("field", timestampField)))__        }__        pipeline.put(Pipeline.PROCESSORS_KEY, processors)__        return pipeline__    };create,an,ingest,pipeline,definition,appropriate,for,the,file,structure,param,grok,pattern,the,grok,pattern,used,for,parsing,semi,structured,text,formats,code,null,code,for,fully,structured,formats,param,timestamp,field,the,input,field,containing,the,timestamp,to,be,parsed,into,code,timestamp,code,code,null,code,if,there,is,no,timestamp,param,timestamp,formats,timestamp,formats,to,be,used,for,parsing,code,timestamp,field,may,be,code,null,code,if,code,timestamp,field,is,also,code,null,code,param,need,client,timezone,is,the,timezone,of,the,client,supplying,data,to,ingest,required,to,uniquely,parse,the,timestamp,return,the,ingest,pipeline,definition,or,code,null,code,if,none,is,required;public,static,map,string,object,make,ingest,pipeline,definition,string,grok,pattern,string,timestamp,field,list,string,timestamp,formats,boolean,need,client,timezone,if,grok,pattern,null,timestamp,field,null,return,null,map,string,object,pipeline,new,linked,hash,map,pipeline,put,pipeline,ingest,pipeline,created,by,file,structure,finder,list,map,string,object,processors,new,array,list,if,grok,pattern,null,map,string,object,grok,processor,settings,new,linked,hash,map,grok,processor,settings,put,field,message,grok,processor,settings,put,patterns,collections,singleton,list,grok,pattern,processors,add,collections,singleton,map,grok,grok,processor,settings,if,timestamp,field,null,map,string,object,date,processor,settings,new,linked,hash,map,date,processor,settings,put,field,timestamp,field,if,need,client,timezone,date,processor,settings,put,timezone,date,processor,settings,put,formats,timestamp,formats,processors,add,collections,singleton,map,date,date,processor,settings,if,grok,pattern,null,timestamp,field,null,processors,add,collections,singleton,map,remove,collections,singleton,map,field,timestamp,field,pipeline,put,pipeline,processors,return,pipeline
FileStructureUtils -> public static Map<String, Object> makeIngestPipelineDefinition(String grokPattern, String timestampField, List<String> timestampFormats,                                                                    boolean needClientTimezone);1548533997;Create an ingest pipeline definition appropriate for the file structure._@param grokPattern The Grok pattern used for parsing semi-structured text formats.  <code>null</code> for_fully structured formats._@param timestampField The input field containing the timestamp to be parsed into <code>@timestamp</code>._<code>null</code> if there is no timestamp._@param timestampFormats Timestamp formats to be used for parsing {@code timestampField}._May be <code>null</code> if {@code timestampField} is also <code>null</code>._@param needClientTimezone Is the timezone of the client supplying data to ingest required to uniquely parse the timestamp?_@return The ingest pipeline definition, or <code>null</code> if none is required.;public static Map<String, Object> makeIngestPipelineDefinition(String grokPattern, String timestampField, List<String> timestampFormats,_                                                                   boolean needClientTimezone) {__        if (grokPattern == null && timestampField == null) {_            return null__        }__        Map<String, Object> pipeline = new LinkedHashMap<>()__        pipeline.put(Pipeline.DESCRIPTION_KEY, "Ingest pipeline created by file structure finder")___        List<Map<String, Object>> processors = new ArrayList<>()___        if (grokPattern != null) {_            Map<String, Object> grokProcessorSettings = new LinkedHashMap<>()__            grokProcessorSettings.put("field", "message")__            grokProcessorSettings.put("patterns", Collections.singletonList(grokPattern))__            processors.add(Collections.singletonMap("grok", grokProcessorSettings))__        }__        if (timestampField != null) {_            Map<String, Object> dateProcessorSettings = new LinkedHashMap<>()__            dateProcessorSettings.put("field", timestampField)__            if (needClientTimezone) {_                dateProcessorSettings.put("timezone", "{{ " + BEAT_TIMEZONE_FIELD + " }}")__            }_            dateProcessorSettings.put("formats", jodaBwcJavaTimestampFormatsForIngestPipeline(timestampFormats))__            processors.add(Collections.singletonMap("date", dateProcessorSettings))__        }__        _        if (grokPattern != null && timestampField != null) {_            processors.add(Collections.singletonMap("remove", Collections.singletonMap("field", timestampField)))__        }__        pipeline.put(Pipeline.PROCESSORS_KEY, processors)__        return pipeline__    };create,an,ingest,pipeline,definition,appropriate,for,the,file,structure,param,grok,pattern,the,grok,pattern,used,for,parsing,semi,structured,text,formats,code,null,code,for,fully,structured,formats,param,timestamp,field,the,input,field,containing,the,timestamp,to,be,parsed,into,code,timestamp,code,code,null,code,if,there,is,no,timestamp,param,timestamp,formats,timestamp,formats,to,be,used,for,parsing,code,timestamp,field,may,be,code,null,code,if,code,timestamp,field,is,also,code,null,code,param,need,client,timezone,is,the,timezone,of,the,client,supplying,data,to,ingest,required,to,uniquely,parse,the,timestamp,return,the,ingest,pipeline,definition,or,code,null,code,if,none,is,required;public,static,map,string,object,make,ingest,pipeline,definition,string,grok,pattern,string,timestamp,field,list,string,timestamp,formats,boolean,need,client,timezone,if,grok,pattern,null,timestamp,field,null,return,null,map,string,object,pipeline,new,linked,hash,map,pipeline,put,pipeline,ingest,pipeline,created,by,file,structure,finder,list,map,string,object,processors,new,array,list,if,grok,pattern,null,map,string,object,grok,processor,settings,new,linked,hash,map,grok,processor,settings,put,field,message,grok,processor,settings,put,patterns,collections,singleton,list,grok,pattern,processors,add,collections,singleton,map,grok,grok,processor,settings,if,timestamp,field,null,map,string,object,date,processor,settings,new,linked,hash,map,date,processor,settings,put,field,timestamp,field,if,need,client,timezone,date,processor,settings,put,timezone,date,processor,settings,put,formats,joda,bwc,java,timestamp,formats,for,ingest,pipeline,timestamp,formats,processors,add,collections,singleton,map,date,date,processor,settings,if,grok,pattern,null,timestamp,field,null,processors,add,collections,singleton,map,remove,collections,singleton,map,field,timestamp,field,pipeline,put,pipeline,processors,return,pipeline
FileStructureUtils -> public static Map<String, Object> makeIngestPipelineDefinition(String grokPattern, String timestampField, List<String> timestampFormats,                                                                    boolean needClientTimezone);1549035364;Create an ingest pipeline definition appropriate for the file structure._@param grokPattern The Grok pattern used for parsing semi-structured text formats.  <code>null</code> for_fully structured formats._@param timestampField The input field containing the timestamp to be parsed into <code>@timestamp</code>._<code>null</code> if there is no timestamp._@param timestampFormats Timestamp formats to be used for parsing {@code timestampField}._May be <code>null</code> if {@code timestampField} is also <code>null</code>._@param needClientTimezone Is the timezone of the client supplying data to ingest required to uniquely parse the timestamp?_@return The ingest pipeline definition, or <code>null</code> if none is required.;public static Map<String, Object> makeIngestPipelineDefinition(String grokPattern, String timestampField, List<String> timestampFormats,_                                                                   boolean needClientTimezone) {__        if (grokPattern == null && timestampField == null) {_            return null__        }__        Map<String, Object> pipeline = new LinkedHashMap<>()__        pipeline.put(Pipeline.DESCRIPTION_KEY, "Ingest pipeline created by file structure finder")___        List<Map<String, Object>> processors = new ArrayList<>()___        if (grokPattern != null) {_            Map<String, Object> grokProcessorSettings = new LinkedHashMap<>()__            grokProcessorSettings.put("field", "message")__            grokProcessorSettings.put("patterns", Collections.singletonList(grokPattern))__            processors.add(Collections.singletonMap("grok", grokProcessorSettings))__        }__        if (timestampField != null) {_            Map<String, Object> dateProcessorSettings = new LinkedHashMap<>()__            dateProcessorSettings.put("field", timestampField)__            if (needClientTimezone) {_                dateProcessorSettings.put("timezone", "{{ " + BEAT_TIMEZONE_FIELD + " }}")__            }_            dateProcessorSettings.put("formats", timestampFormats)__            processors.add(Collections.singletonMap("date", dateProcessorSettings))__        }__        _        if (grokPattern != null && timestampField != null) {_            processors.add(Collections.singletonMap("remove", Collections.singletonMap("field", timestampField)))__        }__        pipeline.put(Pipeline.PROCESSORS_KEY, processors)__        return pipeline__    };create,an,ingest,pipeline,definition,appropriate,for,the,file,structure,param,grok,pattern,the,grok,pattern,used,for,parsing,semi,structured,text,formats,code,null,code,for,fully,structured,formats,param,timestamp,field,the,input,field,containing,the,timestamp,to,be,parsed,into,code,timestamp,code,code,null,code,if,there,is,no,timestamp,param,timestamp,formats,timestamp,formats,to,be,used,for,parsing,code,timestamp,field,may,be,code,null,code,if,code,timestamp,field,is,also,code,null,code,param,need,client,timezone,is,the,timezone,of,the,client,supplying,data,to,ingest,required,to,uniquely,parse,the,timestamp,return,the,ingest,pipeline,definition,or,code,null,code,if,none,is,required;public,static,map,string,object,make,ingest,pipeline,definition,string,grok,pattern,string,timestamp,field,list,string,timestamp,formats,boolean,need,client,timezone,if,grok,pattern,null,timestamp,field,null,return,null,map,string,object,pipeline,new,linked,hash,map,pipeline,put,pipeline,ingest,pipeline,created,by,file,structure,finder,list,map,string,object,processors,new,array,list,if,grok,pattern,null,map,string,object,grok,processor,settings,new,linked,hash,map,grok,processor,settings,put,field,message,grok,processor,settings,put,patterns,collections,singleton,list,grok,pattern,processors,add,collections,singleton,map,grok,grok,processor,settings,if,timestamp,field,null,map,string,object,date,processor,settings,new,linked,hash,map,date,processor,settings,put,field,timestamp,field,if,need,client,timezone,date,processor,settings,put,timezone,date,processor,settings,put,formats,timestamp,formats,processors,add,collections,singleton,map,date,date,processor,settings,if,grok,pattern,null,timestamp,field,null,processors,add,collections,singleton,map,remove,collections,singleton,map,field,timestamp,field,pipeline,put,pipeline,processors,return,pipeline
FileStructureUtils -> static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,                                                              FileStructureOverrides overrides);1536964057;Given one or more sample records, find a timestamp field that is consistently present in them all._To be returned the timestamp field:_- Must exist in every record_- Must have the same timestamp format in every record_If multiple fields meet these criteria then the one that occurred first in the first sample record_is chosen._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param sampleRecords List of records derived from the provided sample._@param overrides Aspects of the file structure that are known in advance.  These take precedence over_values determined by structure analysis.  An exception will be thrown if the file structure_is incompatible with an overridden value._@return A tuple of (field name, timestamp format) if one can be found, or <code>null</code> if_there is no consistent timestamp.;static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,_                                                             FileStructureOverrides overrides) {_        if (sampleRecords.isEmpty()) {_            return null__        }__        _        for (Tuple<String, TimestampMatch> candidate : findCandidates(explanation, sampleRecords, overrides)) {__            boolean allGood = true__            for (Map<String, ?> sampleRecord : sampleRecords.subList(1, sampleRecords.size())) {_                Object fieldValue = sampleRecord.get(candidate.v1())__                if (fieldValue == null) {_                    if (overrides.getTimestampField() != null) {_                        throw new IllegalArgumentException("Specified timestamp field [" + overrides.getTimestampField() +_                            "] is not present in record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] doesn't have field")__                    allGood = false__                    break__                }__                TimestampMatch match = TimestampFormatFinder.findFirstFullMatch(fieldValue.toString(), overrides.getTimestampFormat())__                if (match == null || match.candidateIndex != candidate.v2().candidateIndex) {_                    if (overrides.getTimestampFormat() != null) {_                        throw new IllegalArgumentException("Specified timestamp format [" + overrides.getTimestampFormat() +_                            "] does not match for record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] matches differently: [" + match + "]")__                    allGood = false__                    break__                }_            }__            if (allGood) {_                explanation.add(((overrides.getTimestampField() == null) ? "Guessing timestamp" : "Timestamp") +_                    " field is [" + candidate.v1() + "] with format [" + candidate.v2() + "]")__                return candidate__            }_        }__        return null__    };given,one,or,more,sample,records,find,a,timestamp,field,that,is,consistently,present,in,them,all,to,be,returned,the,timestamp,field,must,exist,in,every,record,must,have,the,same,timestamp,format,in,every,record,if,multiple,fields,meet,these,criteria,then,the,one,that,occurred,first,in,the,first,sample,record,is,chosen,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,sample,records,list,of,records,derived,from,the,provided,sample,param,overrides,aspects,of,the,file,structure,that,are,known,in,advance,these,take,precedence,over,values,determined,by,structure,analysis,an,exception,will,be,thrown,if,the,file,structure,is,incompatible,with,an,overridden,value,return,a,tuple,of,field,name,timestamp,format,if,one,can,be,found,or,code,null,code,if,there,is,no,consistent,timestamp;static,tuple,string,timestamp,match,guess,timestamp,field,list,string,explanation,list,map,string,sample,records,file,structure,overrides,overrides,if,sample,records,is,empty,return,null,for,tuple,string,timestamp,match,candidate,find,candidates,explanation,sample,records,overrides,boolean,all,good,true,for,map,string,sample,record,sample,records,sub,list,1,sample,records,size,object,field,value,sample,record,get,candidate,v1,if,field,value,null,if,overrides,get,timestamp,field,null,throw,new,illegal,argument,exception,specified,timestamp,field,overrides,get,timestamp,field,is,not,present,in,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,doesn,t,have,field,all,good,false,break,timestamp,match,match,timestamp,format,finder,find,first,full,match,field,value,to,string,overrides,get,timestamp,format,if,match,null,match,candidate,index,candidate,v2,candidate,index,if,overrides,get,timestamp,format,null,throw,new,illegal,argument,exception,specified,timestamp,format,overrides,get,timestamp,format,does,not,match,for,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,matches,differently,match,all,good,false,break,if,all,good,explanation,add,overrides,get,timestamp,field,null,guessing,timestamp,timestamp,field,is,candidate,v1,with,format,candidate,v2,return,candidate,return,null
FileStructureUtils -> static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,                                                              FileStructureOverrides overrides);1538067637;Given one or more sample records, find a timestamp field that is consistently present in them all._To be returned the timestamp field:_- Must exist in every record_- Must have the same timestamp format in every record_If multiple fields meet these criteria then the one that occurred first in the first sample record_is chosen._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param sampleRecords List of records derived from the provided sample._@param overrides Aspects of the file structure that are known in advance.  These take precedence over_values determined by structure analysis.  An exception will be thrown if the file structure_is incompatible with an overridden value._@return A tuple of (field name, timestamp format) if one can be found, or <code>null</code> if_there is no consistent timestamp.;static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,_                                                             FileStructureOverrides overrides) {_        if (sampleRecords.isEmpty()) {_            return null__        }__        _        for (Tuple<String, TimestampMatch> candidate : findCandidates(explanation, sampleRecords, overrides)) {__            boolean allGood = true__            for (Map<String, ?> sampleRecord : sampleRecords.subList(1, sampleRecords.size())) {_                Object fieldValue = sampleRecord.get(candidate.v1())__                if (fieldValue == null) {_                    if (overrides.getTimestampField() != null) {_                        throw new IllegalArgumentException("Specified timestamp field [" + overrides.getTimestampField() +_                            "] is not present in record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] doesn't have field")__                    allGood = false__                    break__                }__                TimestampMatch match = TimestampFormatFinder.findFirstFullMatch(fieldValue.toString(), overrides.getTimestampFormat())__                if (match == null || match.candidateIndex != candidate.v2().candidateIndex) {_                    if (overrides.getTimestampFormat() != null) {_                        throw new IllegalArgumentException("Specified timestamp format [" + overrides.getTimestampFormat() +_                            "] does not match for record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] matches differently: [" + match + "]")__                    allGood = false__                    break__                }_            }__            if (allGood) {_                explanation.add(((overrides.getTimestampField() == null) ? "Guessing timestamp" : "Timestamp") +_                    " field is [" + candidate.v1() + "] with format [" + candidate.v2() + "]")__                return candidate__            }_        }__        return null__    };given,one,or,more,sample,records,find,a,timestamp,field,that,is,consistently,present,in,them,all,to,be,returned,the,timestamp,field,must,exist,in,every,record,must,have,the,same,timestamp,format,in,every,record,if,multiple,fields,meet,these,criteria,then,the,one,that,occurred,first,in,the,first,sample,record,is,chosen,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,sample,records,list,of,records,derived,from,the,provided,sample,param,overrides,aspects,of,the,file,structure,that,are,known,in,advance,these,take,precedence,over,values,determined,by,structure,analysis,an,exception,will,be,thrown,if,the,file,structure,is,incompatible,with,an,overridden,value,return,a,tuple,of,field,name,timestamp,format,if,one,can,be,found,or,code,null,code,if,there,is,no,consistent,timestamp;static,tuple,string,timestamp,match,guess,timestamp,field,list,string,explanation,list,map,string,sample,records,file,structure,overrides,overrides,if,sample,records,is,empty,return,null,for,tuple,string,timestamp,match,candidate,find,candidates,explanation,sample,records,overrides,boolean,all,good,true,for,map,string,sample,record,sample,records,sub,list,1,sample,records,size,object,field,value,sample,record,get,candidate,v1,if,field,value,null,if,overrides,get,timestamp,field,null,throw,new,illegal,argument,exception,specified,timestamp,field,overrides,get,timestamp,field,is,not,present,in,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,doesn,t,have,field,all,good,false,break,timestamp,match,match,timestamp,format,finder,find,first,full,match,field,value,to,string,overrides,get,timestamp,format,if,match,null,match,candidate,index,candidate,v2,candidate,index,if,overrides,get,timestamp,format,null,throw,new,illegal,argument,exception,specified,timestamp,format,overrides,get,timestamp,format,does,not,match,for,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,matches,differently,match,all,good,false,break,if,all,good,explanation,add,overrides,get,timestamp,field,null,guessing,timestamp,timestamp,field,is,candidate,v1,with,format,candidate,v2,return,candidate,return,null
FileStructureUtils -> static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues,                                                   TimeoutChecker timeoutChecker);1544771889;Given some sample values for a field, guess the most appropriate index mapping for the_field._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param fieldName Name of the field for which mappings are to be guessed._@param fieldValues Values of the field for which mappings are to be guessed.  The guessed_mapping will be compatible with all the provided values.  Must not be_empty._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The sub-section of the index mappings most appropriate for the field,_for example <code>{ "type" : "keyword" }</code>.;static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues,_                                                  TimeoutChecker timeoutChecker) {__        assert fieldValues.isEmpty() == false___        if (fieldValues.stream().allMatch(value -> "true".equals(value) || "false".equals(value))) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "boolean")__        }__        _        Iterator<String> iter = fieldValues.iterator()__        TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(iter.next(), timeoutChecker)__        while (timestampMatch != null && iter.hasNext()) {_            _            _            if (timestampMatch.equals(TimestampFormatFinder.findFirstFullMatch(iter.next(), timestampMatch.candidateIndex,_                timeoutChecker)) == false) {_                timestampMatch = null__            }_        }_        if (timestampMatch != null) {_            return timestampMatch.getEsDateMappingTypeWithFormat()__        }__        if (fieldValues.stream().allMatch(NUMBER_GROK::match)) {_            try {_                fieldValues.forEach(Long::parseLong)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "long")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'long' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_            try {_                fieldValues.forEach(Double::parseDouble)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "double")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'double' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_        }_        else if (fieldValues.stream().allMatch(IP_GROK::match)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "ip")__        }__        if (fieldValues.stream().anyMatch(FileStructureUtils::isMoreLikelyTextThanKeyword)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "text")__        }__        return Collections.singletonMap(MAPPING_TYPE_SETTING, "keyword")__    };given,some,sample,values,for,a,field,guess,the,most,appropriate,index,mapping,for,the,field,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,field,name,name,of,the,field,for,which,mappings,are,to,be,guessed,param,field,values,values,of,the,field,for,which,mappings,are,to,be,guessed,the,guessed,mapping,will,be,compatible,with,all,the,provided,values,must,not,be,empty,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,sub,section,of,the,index,mappings,most,appropriate,for,the,field,for,example,code,type,keyword,code;static,map,string,string,guess,scalar,mapping,list,string,explanation,string,field,name,collection,string,field,values,timeout,checker,timeout,checker,assert,field,values,is,empty,false,if,field,values,stream,all,match,value,true,equals,value,false,equals,value,return,collections,singleton,map,boolean,iterator,string,iter,field,values,iterator,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,iter,next,timeout,checker,while,timestamp,match,null,iter,has,next,if,timestamp,match,equals,timestamp,format,finder,find,first,full,match,iter,next,timestamp,match,candidate,index,timeout,checker,false,timestamp,match,null,if,timestamp,match,null,return,timestamp,match,get,es,date,mapping,type,with,format,if,field,values,stream,all,match,match,try,field,values,for,each,long,parse,long,return,collections,singleton,map,long,catch,number,format,exception,e,explanation,add,rejecting,type,long,for,field,field,name,due,to,parse,failure,e,get,message,try,field,values,for,each,double,parse,double,return,collections,singleton,map,double,catch,number,format,exception,e,explanation,add,rejecting,type,double,for,field,field,name,due,to,parse,failure,e,get,message,else,if,field,values,stream,all,match,match,return,collections,singleton,map,ip,if,field,values,stream,any,match,file,structure,utils,is,more,likely,text,than,keyword,return,collections,singleton,map,text,return,collections,singleton,map,keyword
FileStructureUtils -> static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues,                                                   TimeoutChecker timeoutChecker);1548533997;Given some sample values for a field, guess the most appropriate index mapping for the_field._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param fieldName Name of the field for which mappings are to be guessed._@param fieldValues Values of the field for which mappings are to be guessed.  The guessed_mapping will be compatible with all the provided values.  Must not be_empty._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The sub-section of the index mappings most appropriate for the field,_for example <code>{ "type" : "keyword" }</code>.;static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues,_                                                  TimeoutChecker timeoutChecker) {__        assert fieldValues.isEmpty() == false___        if (fieldValues.stream().allMatch(value -> "true".equals(value) || "false".equals(value))) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "boolean")__        }__        _        Iterator<String> iter = fieldValues.iterator()__        TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(iter.next(), timeoutChecker)__        while (timestampMatch != null && iter.hasNext()) {_            _            _            if (timestampMatch.equals(TimestampFormatFinder.findFirstFullMatch(iter.next(), timestampMatch.candidateIndex,_                timeoutChecker)) == false) {_                timestampMatch = null__            }_        }_        if (timestampMatch != null) {_            return timestampMatch.getEsDateMappingTypeWithFormat()__        }__        if (fieldValues.stream().allMatch(NUMBER_GROK::match)) {_            try {_                fieldValues.forEach(Long::parseLong)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "long")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'long' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_            try {_                fieldValues.forEach(Double::parseDouble)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "double")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'double' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_        }_        else if (fieldValues.stream().allMatch(IP_GROK::match)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "ip")__        }__        if (fieldValues.stream().anyMatch(FileStructureUtils::isMoreLikelyTextThanKeyword)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "text")__        }__        return Collections.singletonMap(MAPPING_TYPE_SETTING, "keyword")__    };given,some,sample,values,for,a,field,guess,the,most,appropriate,index,mapping,for,the,field,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,field,name,name,of,the,field,for,which,mappings,are,to,be,guessed,param,field,values,values,of,the,field,for,which,mappings,are,to,be,guessed,the,guessed,mapping,will,be,compatible,with,all,the,provided,values,must,not,be,empty,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,sub,section,of,the,index,mappings,most,appropriate,for,the,field,for,example,code,type,keyword,code;static,map,string,string,guess,scalar,mapping,list,string,explanation,string,field,name,collection,string,field,values,timeout,checker,timeout,checker,assert,field,values,is,empty,false,if,field,values,stream,all,match,value,true,equals,value,false,equals,value,return,collections,singleton,map,boolean,iterator,string,iter,field,values,iterator,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,iter,next,timeout,checker,while,timestamp,match,null,iter,has,next,if,timestamp,match,equals,timestamp,format,finder,find,first,full,match,iter,next,timestamp,match,candidate,index,timeout,checker,false,timestamp,match,null,if,timestamp,match,null,return,timestamp,match,get,es,date,mapping,type,with,format,if,field,values,stream,all,match,match,try,field,values,for,each,long,parse,long,return,collections,singleton,map,long,catch,number,format,exception,e,explanation,add,rejecting,type,long,for,field,field,name,due,to,parse,failure,e,get,message,try,field,values,for,each,double,parse,double,return,collections,singleton,map,double,catch,number,format,exception,e,explanation,add,rejecting,type,double,for,field,field,name,due,to,parse,failure,e,get,message,else,if,field,values,stream,all,match,match,return,collections,singleton,map,ip,if,field,values,stream,any,match,file,structure,utils,is,more,likely,text,than,keyword,return,collections,singleton,map,text,return,collections,singleton,map,keyword
FileStructureUtils -> static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues,                                                   TimeoutChecker timeoutChecker);1549035364;Given some sample values for a field, guess the most appropriate index mapping for the_field._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param fieldName Name of the field for which mappings are to be guessed._@param fieldValues Values of the field for which mappings are to be guessed.  The guessed_mapping will be compatible with all the provided values.  Must not be_empty._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The sub-section of the index mappings most appropriate for the field,_for example <code>{ "type" : "keyword" }</code>.;static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues,_                                                  TimeoutChecker timeoutChecker) {__        assert fieldValues.isEmpty() == false___        if (fieldValues.stream().allMatch(value -> "true".equals(value) || "false".equals(value))) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "boolean")__        }__        _        Iterator<String> iter = fieldValues.iterator()__        TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(iter.next(), timeoutChecker)__        while (timestampMatch != null && iter.hasNext()) {_            _            _            if (timestampMatch.equals(TimestampFormatFinder.findFirstFullMatch(iter.next(), timestampMatch.candidateIndex,_                timeoutChecker)) == false) {_                timestampMatch = null__            }_        }_        if (timestampMatch != null) {_            return timestampMatch.getEsDateMappingTypeWithFormat()__        }__        if (fieldValues.stream().allMatch(NUMBER_GROK::match)) {_            try {_                fieldValues.forEach(Long::parseLong)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "long")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'long' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_            try {_                fieldValues.forEach(Double::parseDouble)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "double")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'double' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_        }_        else if (fieldValues.stream().allMatch(IP_GROK::match)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "ip")__        }__        if (fieldValues.stream().anyMatch(FileStructureUtils::isMoreLikelyTextThanKeyword)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "text")__        }__        return Collections.singletonMap(MAPPING_TYPE_SETTING, "keyword")__    };given,some,sample,values,for,a,field,guess,the,most,appropriate,index,mapping,for,the,field,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,field,name,name,of,the,field,for,which,mappings,are,to,be,guessed,param,field,values,values,of,the,field,for,which,mappings,are,to,be,guessed,the,guessed,mapping,will,be,compatible,with,all,the,provided,values,must,not,be,empty,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,sub,section,of,the,index,mappings,most,appropriate,for,the,field,for,example,code,type,keyword,code;static,map,string,string,guess,scalar,mapping,list,string,explanation,string,field,name,collection,string,field,values,timeout,checker,timeout,checker,assert,field,values,is,empty,false,if,field,values,stream,all,match,value,true,equals,value,false,equals,value,return,collections,singleton,map,boolean,iterator,string,iter,field,values,iterator,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,iter,next,timeout,checker,while,timestamp,match,null,iter,has,next,if,timestamp,match,equals,timestamp,format,finder,find,first,full,match,iter,next,timestamp,match,candidate,index,timeout,checker,false,timestamp,match,null,if,timestamp,match,null,return,timestamp,match,get,es,date,mapping,type,with,format,if,field,values,stream,all,match,match,try,field,values,for,each,long,parse,long,return,collections,singleton,map,long,catch,number,format,exception,e,explanation,add,rejecting,type,long,for,field,field,name,due,to,parse,failure,e,get,message,try,field,values,for,each,double,parse,double,return,collections,singleton,map,double,catch,number,format,exception,e,explanation,add,rejecting,type,double,for,field,field,name,due,to,parse,failure,e,get,message,else,if,field,values,stream,all,match,match,return,collections,singleton,map,ip,if,field,values,stream,any,match,file,structure,utils,is,more,likely,text,than,keyword,return,collections,singleton,map,text,return,collections,singleton,map,keyword
FileStructureUtils -> static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues);1536314350;Given some sample values for a field, guess the most appropriate index mapping for the_field._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param fieldName Name of the field for which mappings are to be guessed._@param fieldValues Values of the field for which mappings are to be guessed.  The guessed_mapping will be compatible with all the provided values.  Must not be_empty._@return The sub-section of the index mappings most appropriate for the field,_for example <code>{ "type" : "keyword" }</code>.;static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues) {__        assert fieldValues.isEmpty() == false___        if (fieldValues.stream().allMatch(value -> "true".equals(value) || "false".equals(value))) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "boolean")__        }__        _        Iterator<String> iter = fieldValues.iterator()__        TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(iter.next())__        while (timestampMatch != null && iter.hasNext()) {_            _            _            if (timestampMatch.equals(TimestampFormatFinder.findFirstFullMatch(iter.next(), timestampMatch.candidateIndex)) == false) {_                timestampMatch = null__            }_        }_        if (timestampMatch != null) {_            return timestampMatch.getEsDateMappingTypeWithFormat()__        }__        if (fieldValues.stream().allMatch(NUMBER_GROK::match)) {_            try {_                fieldValues.forEach(Long::parseLong)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "long")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'long' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_            try {_                fieldValues.forEach(Double::parseDouble)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "double")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'double' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_        }_        else if (fieldValues.stream().allMatch(IP_GROK::match)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "ip")__        }__        if (fieldValues.stream().anyMatch(FileStructureUtils::isMoreLikelyTextThanKeyword)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "text")__        }__        return Collections.singletonMap(MAPPING_TYPE_SETTING, "keyword")__    };given,some,sample,values,for,a,field,guess,the,most,appropriate,index,mapping,for,the,field,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,field,name,name,of,the,field,for,which,mappings,are,to,be,guessed,param,field,values,values,of,the,field,for,which,mappings,are,to,be,guessed,the,guessed,mapping,will,be,compatible,with,all,the,provided,values,must,not,be,empty,return,the,sub,section,of,the,index,mappings,most,appropriate,for,the,field,for,example,code,type,keyword,code;static,map,string,string,guess,scalar,mapping,list,string,explanation,string,field,name,collection,string,field,values,assert,field,values,is,empty,false,if,field,values,stream,all,match,value,true,equals,value,false,equals,value,return,collections,singleton,map,boolean,iterator,string,iter,field,values,iterator,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,iter,next,while,timestamp,match,null,iter,has,next,if,timestamp,match,equals,timestamp,format,finder,find,first,full,match,iter,next,timestamp,match,candidate,index,false,timestamp,match,null,if,timestamp,match,null,return,timestamp,match,get,es,date,mapping,type,with,format,if,field,values,stream,all,match,match,try,field,values,for,each,long,parse,long,return,collections,singleton,map,long,catch,number,format,exception,e,explanation,add,rejecting,type,long,for,field,field,name,due,to,parse,failure,e,get,message,try,field,values,for,each,double,parse,double,return,collections,singleton,map,double,catch,number,format,exception,e,explanation,add,rejecting,type,double,for,field,field,name,due,to,parse,failure,e,get,message,else,if,field,values,stream,all,match,match,return,collections,singleton,map,ip,if,field,values,stream,any,match,file,structure,utils,is,more,likely,text,than,keyword,return,collections,singleton,map,text,return,collections,singleton,map,keyword
FileStructureUtils -> static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues);1536964057;Given some sample values for a field, guess the most appropriate index mapping for the_field._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param fieldName Name of the field for which mappings are to be guessed._@param fieldValues Values of the field for which mappings are to be guessed.  The guessed_mapping will be compatible with all the provided values.  Must not be_empty._@return The sub-section of the index mappings most appropriate for the field,_for example <code>{ "type" : "keyword" }</code>.;static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues) {__        assert fieldValues.isEmpty() == false___        if (fieldValues.stream().allMatch(value -> "true".equals(value) || "false".equals(value))) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "boolean")__        }__        _        Iterator<String> iter = fieldValues.iterator()__        TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(iter.next())__        while (timestampMatch != null && iter.hasNext()) {_            _            _            if (timestampMatch.equals(TimestampFormatFinder.findFirstFullMatch(iter.next(), timestampMatch.candidateIndex)) == false) {_                timestampMatch = null__            }_        }_        if (timestampMatch != null) {_            return timestampMatch.getEsDateMappingTypeWithFormat()__        }__        if (fieldValues.stream().allMatch(NUMBER_GROK::match)) {_            try {_                fieldValues.forEach(Long::parseLong)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "long")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'long' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_            try {_                fieldValues.forEach(Double::parseDouble)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "double")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'double' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_        }_        else if (fieldValues.stream().allMatch(IP_GROK::match)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "ip")__        }__        if (fieldValues.stream().anyMatch(FileStructureUtils::isMoreLikelyTextThanKeyword)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "text")__        }__        return Collections.singletonMap(MAPPING_TYPE_SETTING, "keyword")__    };given,some,sample,values,for,a,field,guess,the,most,appropriate,index,mapping,for,the,field,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,field,name,name,of,the,field,for,which,mappings,are,to,be,guessed,param,field,values,values,of,the,field,for,which,mappings,are,to,be,guessed,the,guessed,mapping,will,be,compatible,with,all,the,provided,values,must,not,be,empty,return,the,sub,section,of,the,index,mappings,most,appropriate,for,the,field,for,example,code,type,keyword,code;static,map,string,string,guess,scalar,mapping,list,string,explanation,string,field,name,collection,string,field,values,assert,field,values,is,empty,false,if,field,values,stream,all,match,value,true,equals,value,false,equals,value,return,collections,singleton,map,boolean,iterator,string,iter,field,values,iterator,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,iter,next,while,timestamp,match,null,iter,has,next,if,timestamp,match,equals,timestamp,format,finder,find,first,full,match,iter,next,timestamp,match,candidate,index,false,timestamp,match,null,if,timestamp,match,null,return,timestamp,match,get,es,date,mapping,type,with,format,if,field,values,stream,all,match,match,try,field,values,for,each,long,parse,long,return,collections,singleton,map,long,catch,number,format,exception,e,explanation,add,rejecting,type,long,for,field,field,name,due,to,parse,failure,e,get,message,try,field,values,for,each,double,parse,double,return,collections,singleton,map,double,catch,number,format,exception,e,explanation,add,rejecting,type,double,for,field,field,name,due,to,parse,failure,e,get,message,else,if,field,values,stream,all,match,match,return,collections,singleton,map,ip,if,field,values,stream,any,match,file,structure,utils,is,more,likely,text,than,keyword,return,collections,singleton,map,text,return,collections,singleton,map,keyword
FileStructureUtils -> static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues);1538067637;Given some sample values for a field, guess the most appropriate index mapping for the_field._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param fieldName Name of the field for which mappings are to be guessed._@param fieldValues Values of the field for which mappings are to be guessed.  The guessed_mapping will be compatible with all the provided values.  Must not be_empty._@return The sub-section of the index mappings most appropriate for the field,_for example <code>{ "type" : "keyword" }</code>.;static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues) {__        assert fieldValues.isEmpty() == false___        if (fieldValues.stream().allMatch(value -> "true".equals(value) || "false".equals(value))) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "boolean")__        }__        _        Iterator<String> iter = fieldValues.iterator()__        TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(iter.next())__        while (timestampMatch != null && iter.hasNext()) {_            _            _            if (timestampMatch.equals(TimestampFormatFinder.findFirstFullMatch(iter.next(), timestampMatch.candidateIndex)) == false) {_                timestampMatch = null__            }_        }_        if (timestampMatch != null) {_            return timestampMatch.getEsDateMappingTypeWithFormat()__        }__        if (fieldValues.stream().allMatch(NUMBER_GROK::match)) {_            try {_                fieldValues.forEach(Long::parseLong)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "long")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'long' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_            try {_                fieldValues.forEach(Double::parseDouble)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "double")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'double' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_        }_        else if (fieldValues.stream().allMatch(IP_GROK::match)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "ip")__        }__        if (fieldValues.stream().anyMatch(FileStructureUtils::isMoreLikelyTextThanKeyword)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "text")__        }__        return Collections.singletonMap(MAPPING_TYPE_SETTING, "keyword")__    };given,some,sample,values,for,a,field,guess,the,most,appropriate,index,mapping,for,the,field,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,field,name,name,of,the,field,for,which,mappings,are,to,be,guessed,param,field,values,values,of,the,field,for,which,mappings,are,to,be,guessed,the,guessed,mapping,will,be,compatible,with,all,the,provided,values,must,not,be,empty,return,the,sub,section,of,the,index,mappings,most,appropriate,for,the,field,for,example,code,type,keyword,code;static,map,string,string,guess,scalar,mapping,list,string,explanation,string,field,name,collection,string,field,values,assert,field,values,is,empty,false,if,field,values,stream,all,match,value,true,equals,value,false,equals,value,return,collections,singleton,map,boolean,iterator,string,iter,field,values,iterator,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,iter,next,while,timestamp,match,null,iter,has,next,if,timestamp,match,equals,timestamp,format,finder,find,first,full,match,iter,next,timestamp,match,candidate,index,false,timestamp,match,null,if,timestamp,match,null,return,timestamp,match,get,es,date,mapping,type,with,format,if,field,values,stream,all,match,match,try,field,values,for,each,long,parse,long,return,collections,singleton,map,long,catch,number,format,exception,e,explanation,add,rejecting,type,long,for,field,field,name,due,to,parse,failure,e,get,message,try,field,values,for,each,double,parse,double,return,collections,singleton,map,double,catch,number,format,exception,e,explanation,add,rejecting,type,double,for,field,field,name,due,to,parse,failure,e,get,message,else,if,field,values,stream,all,match,match,return,collections,singleton,map,ip,if,field,values,stream,any,match,file,structure,utils,is,more,likely,text,than,keyword,return,collections,singleton,map,text,return,collections,singleton,map,keyword
FileStructureUtils -> static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues);1538170812;Given some sample values for a field, guess the most appropriate index mapping for the_field._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param fieldName Name of the field for which mappings are to be guessed._@param fieldValues Values of the field for which mappings are to be guessed.  The guessed_mapping will be compatible with all the provided values.  Must not be_empty._@return The sub-section of the index mappings most appropriate for the field,_for example <code>{ "type" : "keyword" }</code>.;static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues) {__        assert fieldValues.isEmpty() == false___        if (fieldValues.stream().allMatch(value -> "true".equals(value) || "false".equals(value))) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "boolean")__        }__        _        Iterator<String> iter = fieldValues.iterator()__        TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(iter.next())__        while (timestampMatch != null && iter.hasNext()) {_            _            _            if (timestampMatch.equals(TimestampFormatFinder.findFirstFullMatch(iter.next(), timestampMatch.candidateIndex)) == false) {_                timestampMatch = null__            }_        }_        if (timestampMatch != null) {_            return timestampMatch.getEsDateMappingTypeWithFormat()__        }__        if (fieldValues.stream().allMatch(NUMBER_GROK::match)) {_            try {_                fieldValues.forEach(Long::parseLong)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "long")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'long' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_            try {_                fieldValues.forEach(Double::parseDouble)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "double")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'double' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_        }_        else if (fieldValues.stream().allMatch(IP_GROK::match)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "ip")__        }__        if (fieldValues.stream().anyMatch(FileStructureUtils::isMoreLikelyTextThanKeyword)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "text")__        }__        return Collections.singletonMap(MAPPING_TYPE_SETTING, "keyword")__    };given,some,sample,values,for,a,field,guess,the,most,appropriate,index,mapping,for,the,field,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,field,name,name,of,the,field,for,which,mappings,are,to,be,guessed,param,field,values,values,of,the,field,for,which,mappings,are,to,be,guessed,the,guessed,mapping,will,be,compatible,with,all,the,provided,values,must,not,be,empty,return,the,sub,section,of,the,index,mappings,most,appropriate,for,the,field,for,example,code,type,keyword,code;static,map,string,string,guess,scalar,mapping,list,string,explanation,string,field,name,collection,string,field,values,assert,field,values,is,empty,false,if,field,values,stream,all,match,value,true,equals,value,false,equals,value,return,collections,singleton,map,boolean,iterator,string,iter,field,values,iterator,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,iter,next,while,timestamp,match,null,iter,has,next,if,timestamp,match,equals,timestamp,format,finder,find,first,full,match,iter,next,timestamp,match,candidate,index,false,timestamp,match,null,if,timestamp,match,null,return,timestamp,match,get,es,date,mapping,type,with,format,if,field,values,stream,all,match,match,try,field,values,for,each,long,parse,long,return,collections,singleton,map,long,catch,number,format,exception,e,explanation,add,rejecting,type,long,for,field,field,name,due,to,parse,failure,e,get,message,try,field,values,for,each,double,parse,double,return,collections,singleton,map,double,catch,number,format,exception,e,explanation,add,rejecting,type,double,for,field,field,name,due,to,parse,failure,e,get,message,else,if,field,values,stream,all,match,match,return,collections,singleton,map,ip,if,field,values,stream,any,match,file,structure,utils,is,more,likely,text,than,keyword,return,collections,singleton,map,text,return,collections,singleton,map,keyword
FileStructureUtils -> static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues);1539615817;Given some sample values for a field, guess the most appropriate index mapping for the_field._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param fieldName Name of the field for which mappings are to be guessed._@param fieldValues Values of the field for which mappings are to be guessed.  The guessed_mapping will be compatible with all the provided values.  Must not be_empty._@return The sub-section of the index mappings most appropriate for the field,_for example <code>{ "type" : "keyword" }</code>.;static Map<String, String> guessScalarMapping(List<String> explanation, String fieldName, Collection<String> fieldValues) {__        assert fieldValues.isEmpty() == false___        if (fieldValues.stream().allMatch(value -> "true".equals(value) || "false".equals(value))) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "boolean")__        }__        _        Iterator<String> iter = fieldValues.iterator()__        TimestampMatch timestampMatch = TimestampFormatFinder.findFirstFullMatch(iter.next())__        while (timestampMatch != null && iter.hasNext()) {_            _            _            if (timestampMatch.equals(TimestampFormatFinder.findFirstFullMatch(iter.next(), timestampMatch.candidateIndex)) == false) {_                timestampMatch = null__            }_        }_        if (timestampMatch != null) {_            return timestampMatch.getEsDateMappingTypeWithFormat()__        }__        if (fieldValues.stream().allMatch(NUMBER_GROK::match)) {_            try {_                fieldValues.forEach(Long::parseLong)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "long")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'long' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_            try {_                fieldValues.forEach(Double::parseDouble)__                return Collections.singletonMap(MAPPING_TYPE_SETTING, "double")__            } catch (NumberFormatException e) {_                explanation.add("Rejecting type 'double' for field [" + fieldName + "] due to parse failure: [" + e.getMessage() + "]")__            }_        }_        else if (fieldValues.stream().allMatch(IP_GROK::match)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "ip")__        }__        if (fieldValues.stream().anyMatch(FileStructureUtils::isMoreLikelyTextThanKeyword)) {_            return Collections.singletonMap(MAPPING_TYPE_SETTING, "text")__        }__        return Collections.singletonMap(MAPPING_TYPE_SETTING, "keyword")__    };given,some,sample,values,for,a,field,guess,the,most,appropriate,index,mapping,for,the,field,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,field,name,name,of,the,field,for,which,mappings,are,to,be,guessed,param,field,values,values,of,the,field,for,which,mappings,are,to,be,guessed,the,guessed,mapping,will,be,compatible,with,all,the,provided,values,must,not,be,empty,return,the,sub,section,of,the,index,mappings,most,appropriate,for,the,field,for,example,code,type,keyword,code;static,map,string,string,guess,scalar,mapping,list,string,explanation,string,field,name,collection,string,field,values,assert,field,values,is,empty,false,if,field,values,stream,all,match,value,true,equals,value,false,equals,value,return,collections,singleton,map,boolean,iterator,string,iter,field,values,iterator,timestamp,match,timestamp,match,timestamp,format,finder,find,first,full,match,iter,next,while,timestamp,match,null,iter,has,next,if,timestamp,match,equals,timestamp,format,finder,find,first,full,match,iter,next,timestamp,match,candidate,index,false,timestamp,match,null,if,timestamp,match,null,return,timestamp,match,get,es,date,mapping,type,with,format,if,field,values,stream,all,match,match,try,field,values,for,each,long,parse,long,return,collections,singleton,map,long,catch,number,format,exception,e,explanation,add,rejecting,type,long,for,field,field,name,due,to,parse,failure,e,get,message,try,field,values,for,each,double,parse,double,return,collections,singleton,map,double,catch,number,format,exception,e,explanation,add,rejecting,type,double,for,field,field,name,due,to,parse,failure,e,get,message,else,if,field,values,stream,all,match,match,return,collections,singleton,map,ip,if,field,values,stream,any,match,file,structure,utils,is,more,likely,text,than,keyword,return,collections,singleton,map,text,return,collections,singleton,map,keyword
FileStructureUtils -> static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker);1538170812;Calculate stats for a set of field values._@param fieldValues Values of the field for which field stats are to be calculated._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The stats calculated from the field values.;static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker) {__        FieldStatsCalculator calculator = new FieldStatsCalculator()__        calculator.accept(fieldValues)__        timeoutChecker.check("field stats calculation")__        return calculator.calculate(NUM_TOP_HITS)__    };calculate,stats,for,a,set,of,field,values,param,field,values,values,of,the,field,for,which,field,stats,are,to,be,calculated,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,stats,calculated,from,the,field,values;static,field,stats,calculate,field,stats,collection,string,field,values,timeout,checker,timeout,checker,field,stats,calculator,calculator,new,field,stats,calculator,calculator,accept,field,values,timeout,checker,check,field,stats,calculation,return,calculator,calculate
FileStructureUtils -> static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker);1539615817;Calculate stats for a set of field values._@param fieldValues Values of the field for which field stats are to be calculated._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The stats calculated from the field values.;static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker) {__        FieldStatsCalculator calculator = new FieldStatsCalculator()__        calculator.accept(fieldValues)__        timeoutChecker.check("field stats calculation")__        return calculator.calculate(NUM_TOP_HITS)__    };calculate,stats,for,a,set,of,field,values,param,field,values,values,of,the,field,for,which,field,stats,are,to,be,calculated,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,stats,calculated,from,the,field,values;static,field,stats,calculate,field,stats,collection,string,field,values,timeout,checker,timeout,checker,field,stats,calculator,calculator,new,field,stats,calculator,calculator,accept,field,values,timeout,checker,check,field,stats,calculation,return,calculator,calculate
FileStructureUtils -> static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker);1544771889;Calculate stats for a set of field values._@param fieldValues Values of the field for which field stats are to be calculated._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The stats calculated from the field values.;static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker) {__        FieldStatsCalculator calculator = new FieldStatsCalculator()__        calculator.accept(fieldValues)__        timeoutChecker.check("field stats calculation")__        return calculator.calculate(NUM_TOP_HITS)__    };calculate,stats,for,a,set,of,field,values,param,field,values,values,of,the,field,for,which,field,stats,are,to,be,calculated,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,stats,calculated,from,the,field,values;static,field,stats,calculate,field,stats,collection,string,field,values,timeout,checker,timeout,checker,field,stats,calculator,calculator,new,field,stats,calculator,calculator,accept,field,values,timeout,checker,check,field,stats,calculation,return,calculator,calculate
FileStructureUtils -> static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker);1548533997;Calculate stats for a set of field values._@param fieldValues Values of the field for which field stats are to be calculated._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The stats calculated from the field values.;static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker) {__        FieldStatsCalculator calculator = new FieldStatsCalculator()__        calculator.accept(fieldValues)__        timeoutChecker.check("field stats calculation")__        return calculator.calculate(NUM_TOP_HITS)__    };calculate,stats,for,a,set,of,field,values,param,field,values,values,of,the,field,for,which,field,stats,are,to,be,calculated,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,stats,calculated,from,the,field,values;static,field,stats,calculate,field,stats,collection,string,field,values,timeout,checker,timeout,checker,field,stats,calculator,calculator,new,field,stats,calculator,calculator,accept,field,values,timeout,checker,check,field,stats,calculation,return,calculator,calculate
FileStructureUtils -> static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker);1549035364;Calculate stats for a set of field values._@param fieldValues Values of the field for which field stats are to be calculated._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return The stats calculated from the field values.;static FieldStats calculateFieldStats(Collection<String> fieldValues, TimeoutChecker timeoutChecker) {__        FieldStatsCalculator calculator = new FieldStatsCalculator()__        calculator.accept(fieldValues)__        timeoutChecker.check("field stats calculation")__        return calculator.calculate(NUM_TOP_HITS)__    };calculate,stats,for,a,set,of,field,values,param,field,values,values,of,the,field,for,which,field,stats,are,to,be,calculated,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,the,stats,calculated,from,the,field,values;static,field,stats,calculate,field,stats,collection,string,field,values,timeout,checker,timeout,checker,field,stats,calculator,calculator,new,field,stats,calculator,calculator,accept,field,values,timeout,checker,check,field,stats,calculation,return,calculator,calculate
FileStructureUtils -> static FieldStats calculateFieldStats(Collection<String> fieldValues);1536314350;Calculate stats for a set of field values._@param fieldValues Values of the field for which field stats are to be calculated._@return The stats calculated from the field values.;static FieldStats calculateFieldStats(Collection<String> fieldValues) {__        FieldStatsCalculator calculator = new FieldStatsCalculator()__        calculator.accept(fieldValues)__        return calculator.calculate(NUM_TOP_HITS)__    };calculate,stats,for,a,set,of,field,values,param,field,values,values,of,the,field,for,which,field,stats,are,to,be,calculated,return,the,stats,calculated,from,the,field,values;static,field,stats,calculate,field,stats,collection,string,field,values,field,stats,calculator,calculator,new,field,stats,calculator,calculator,accept,field,values,return,calculator,calculate
FileStructureUtils -> static FieldStats calculateFieldStats(Collection<String> fieldValues);1536964057;Calculate stats for a set of field values._@param fieldValues Values of the field for which field stats are to be calculated._@return The stats calculated from the field values.;static FieldStats calculateFieldStats(Collection<String> fieldValues) {__        FieldStatsCalculator calculator = new FieldStatsCalculator()__        calculator.accept(fieldValues)__        return calculator.calculate(NUM_TOP_HITS)__    };calculate,stats,for,a,set,of,field,values,param,field,values,values,of,the,field,for,which,field,stats,are,to,be,calculated,return,the,stats,calculated,from,the,field,values;static,field,stats,calculate,field,stats,collection,string,field,values,field,stats,calculator,calculator,new,field,stats,calculator,calculator,accept,field,values,return,calculator,calculate
FileStructureUtils -> static FieldStats calculateFieldStats(Collection<String> fieldValues);1538067637;Calculate stats for a set of field values._@param fieldValues Values of the field for which field stats are to be calculated._@return The stats calculated from the field values.;static FieldStats calculateFieldStats(Collection<String> fieldValues) {__        FieldStatsCalculator calculator = new FieldStatsCalculator()__        calculator.accept(fieldValues)__        return calculator.calculate(NUM_TOP_HITS)__    };calculate,stats,for,a,set,of,field,values,param,field,values,values,of,the,field,for,which,field,stats,are,to,be,calculated,return,the,stats,calculated,from,the,field,values;static,field,stats,calculate,field,stats,collection,string,field,values,field,stats,calculator,calculator,new,field,stats,calculator,calculator,accept,field,values,return,calculator,calculate
FileStructureUtils -> static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(         List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker);1538170812;Given the sampled records, guess appropriate Elasticsearch mappings._@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by this method._@param sampleRecords The sampled records._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A map of field name to mapping settings.;static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(_        List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker) {__        SortedMap<String, Object> mappings = new TreeMap<>()__        SortedMap<String, FieldStats> fieldStats = new TreeMap<>()___        Set<String> uniqueFieldNames = sampleRecords.stream().flatMap(record -> record.keySet().stream()).collect(Collectors.toSet())___        for (String fieldName : uniqueFieldNames) {__            List<Object> fieldValues = sampleRecords.stream().flatMap(record -> {_                    Object fieldValue = record.get(fieldName)__                    return (fieldValue == null) ? Stream.empty() : Stream.of(fieldValue)__                }_            ).collect(Collectors.toList())___            Tuple<Map<String, String>, FieldStats> mappingAndFieldStats =_                guessMappingAndCalculateFieldStats(explanation, fieldName, fieldValues, timeoutChecker)__            if (mappingAndFieldStats != null) {_                if (mappingAndFieldStats.v1() != null) {_                    mappings.put(fieldName, mappingAndFieldStats.v1())__                }_                if (mappingAndFieldStats.v2() != null) {_                    fieldStats.put(fieldName, mappingAndFieldStats.v2())__                }_            }_        }__        return new Tuple<>(mappings, fieldStats)__    };given,the,sampled,records,guess,appropriate,elasticsearch,mappings,param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,this,method,param,sample,records,the,sampled,records,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,map,of,field,name,to,mapping,settings;static,tuple,sorted,map,string,object,sorted,map,string,field,stats,guess,mappings,and,calculate,field,stats,list,string,explanation,list,map,string,sample,records,timeout,checker,timeout,checker,sorted,map,string,object,mappings,new,tree,map,sorted,map,string,field,stats,field,stats,new,tree,map,set,string,unique,field,names,sample,records,stream,flat,map,record,record,key,set,stream,collect,collectors,to,set,for,string,field,name,unique,field,names,list,object,field,values,sample,records,stream,flat,map,record,object,field,value,record,get,field,name,return,field,value,null,stream,empty,stream,of,field,value,collect,collectors,to,list,tuple,map,string,string,field,stats,mapping,and,field,stats,guess,mapping,and,calculate,field,stats,explanation,field,name,field,values,timeout,checker,if,mapping,and,field,stats,null,if,mapping,and,field,stats,v1,null,mappings,put,field,name,mapping,and,field,stats,v1,if,mapping,and,field,stats,v2,null,field,stats,put,field,name,mapping,and,field,stats,v2,return,new,tuple,mappings,field,stats
FileStructureUtils -> static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(         List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker);1539615817;Given the sampled records, guess appropriate Elasticsearch mappings._@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by this method._@param sampleRecords The sampled records._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A map of field name to mapping settings.;static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(_        List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker) {__        SortedMap<String, Object> mappings = new TreeMap<>()__        SortedMap<String, FieldStats> fieldStats = new TreeMap<>()___        Set<String> uniqueFieldNames = sampleRecords.stream().flatMap(record -> record.keySet().stream()).collect(Collectors.toSet())___        for (String fieldName : uniqueFieldNames) {__            List<Object> fieldValues = sampleRecords.stream().flatMap(record -> {_                    Object fieldValue = record.get(fieldName)__                    return (fieldValue == null) ? Stream.empty() : Stream.of(fieldValue)__                }_            ).collect(Collectors.toList())___            Tuple<Map<String, String>, FieldStats> mappingAndFieldStats =_                guessMappingAndCalculateFieldStats(explanation, fieldName, fieldValues, timeoutChecker)__            if (mappingAndFieldStats != null) {_                if (mappingAndFieldStats.v1() != null) {_                    mappings.put(fieldName, mappingAndFieldStats.v1())__                }_                if (mappingAndFieldStats.v2() != null) {_                    fieldStats.put(fieldName, mappingAndFieldStats.v2())__                }_            }_        }__        return new Tuple<>(mappings, fieldStats)__    };given,the,sampled,records,guess,appropriate,elasticsearch,mappings,param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,this,method,param,sample,records,the,sampled,records,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,map,of,field,name,to,mapping,settings;static,tuple,sorted,map,string,object,sorted,map,string,field,stats,guess,mappings,and,calculate,field,stats,list,string,explanation,list,map,string,sample,records,timeout,checker,timeout,checker,sorted,map,string,object,mappings,new,tree,map,sorted,map,string,field,stats,field,stats,new,tree,map,set,string,unique,field,names,sample,records,stream,flat,map,record,record,key,set,stream,collect,collectors,to,set,for,string,field,name,unique,field,names,list,object,field,values,sample,records,stream,flat,map,record,object,field,value,record,get,field,name,return,field,value,null,stream,empty,stream,of,field,value,collect,collectors,to,list,tuple,map,string,string,field,stats,mapping,and,field,stats,guess,mapping,and,calculate,field,stats,explanation,field,name,field,values,timeout,checker,if,mapping,and,field,stats,null,if,mapping,and,field,stats,v1,null,mappings,put,field,name,mapping,and,field,stats,v1,if,mapping,and,field,stats,v2,null,field,stats,put,field,name,mapping,and,field,stats,v2,return,new,tuple,mappings,field,stats
FileStructureUtils -> static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(         List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker);1544771889;Given the sampled records, guess appropriate Elasticsearch mappings._@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by this method._@param sampleRecords The sampled records._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A map of field name to mapping settings.;static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(_        List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker) {__        SortedMap<String, Object> mappings = new TreeMap<>()__        SortedMap<String, FieldStats> fieldStats = new TreeMap<>()___        Set<String> uniqueFieldNames = sampleRecords.stream().flatMap(record -> record.keySet().stream()).collect(Collectors.toSet())___        for (String fieldName : uniqueFieldNames) {__            List<Object> fieldValues = sampleRecords.stream().flatMap(record -> {_                    Object fieldValue = record.get(fieldName)__                    return (fieldValue == null) ? Stream.empty() : Stream.of(fieldValue)__                }_            ).collect(Collectors.toList())___            Tuple<Map<String, String>, FieldStats> mappingAndFieldStats =_                guessMappingAndCalculateFieldStats(explanation, fieldName, fieldValues, timeoutChecker)__            if (mappingAndFieldStats != null) {_                if (mappingAndFieldStats.v1() != null) {_                    mappings.put(fieldName, mappingAndFieldStats.v1())__                }_                if (mappingAndFieldStats.v2() != null) {_                    fieldStats.put(fieldName, mappingAndFieldStats.v2())__                }_            }_        }__        return new Tuple<>(mappings, fieldStats)__    };given,the,sampled,records,guess,appropriate,elasticsearch,mappings,param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,this,method,param,sample,records,the,sampled,records,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,map,of,field,name,to,mapping,settings;static,tuple,sorted,map,string,object,sorted,map,string,field,stats,guess,mappings,and,calculate,field,stats,list,string,explanation,list,map,string,sample,records,timeout,checker,timeout,checker,sorted,map,string,object,mappings,new,tree,map,sorted,map,string,field,stats,field,stats,new,tree,map,set,string,unique,field,names,sample,records,stream,flat,map,record,record,key,set,stream,collect,collectors,to,set,for,string,field,name,unique,field,names,list,object,field,values,sample,records,stream,flat,map,record,object,field,value,record,get,field,name,return,field,value,null,stream,empty,stream,of,field,value,collect,collectors,to,list,tuple,map,string,string,field,stats,mapping,and,field,stats,guess,mapping,and,calculate,field,stats,explanation,field,name,field,values,timeout,checker,if,mapping,and,field,stats,null,if,mapping,and,field,stats,v1,null,mappings,put,field,name,mapping,and,field,stats,v1,if,mapping,and,field,stats,v2,null,field,stats,put,field,name,mapping,and,field,stats,v2,return,new,tuple,mappings,field,stats
FileStructureUtils -> static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(         List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker);1548533997;Given the sampled records, guess appropriate Elasticsearch mappings._@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by this method._@param sampleRecords The sampled records._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A map of field name to mapping settings.;static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(_        List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker) {__        SortedMap<String, Object> mappings = new TreeMap<>()__        SortedMap<String, FieldStats> fieldStats = new TreeMap<>()___        Set<String> uniqueFieldNames = sampleRecords.stream().flatMap(record -> record.keySet().stream()).collect(Collectors.toSet())___        for (String fieldName : uniqueFieldNames) {__            List<Object> fieldValues = sampleRecords.stream().flatMap(record -> {_                    Object fieldValue = record.get(fieldName)__                    return (fieldValue == null) ? Stream.empty() : Stream.of(fieldValue)__                }_            ).collect(Collectors.toList())___            Tuple<Map<String, String>, FieldStats> mappingAndFieldStats =_                guessMappingAndCalculateFieldStats(explanation, fieldName, fieldValues, timeoutChecker)__            if (mappingAndFieldStats != null) {_                if (mappingAndFieldStats.v1() != null) {_                    mappings.put(fieldName, mappingAndFieldStats.v1())__                }_                if (mappingAndFieldStats.v2() != null) {_                    fieldStats.put(fieldName, mappingAndFieldStats.v2())__                }_            }_        }__        return new Tuple<>(mappings, fieldStats)__    };given,the,sampled,records,guess,appropriate,elasticsearch,mappings,param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,this,method,param,sample,records,the,sampled,records,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,map,of,field,name,to,mapping,settings;static,tuple,sorted,map,string,object,sorted,map,string,field,stats,guess,mappings,and,calculate,field,stats,list,string,explanation,list,map,string,sample,records,timeout,checker,timeout,checker,sorted,map,string,object,mappings,new,tree,map,sorted,map,string,field,stats,field,stats,new,tree,map,set,string,unique,field,names,sample,records,stream,flat,map,record,record,key,set,stream,collect,collectors,to,set,for,string,field,name,unique,field,names,list,object,field,values,sample,records,stream,flat,map,record,object,field,value,record,get,field,name,return,field,value,null,stream,empty,stream,of,field,value,collect,collectors,to,list,tuple,map,string,string,field,stats,mapping,and,field,stats,guess,mapping,and,calculate,field,stats,explanation,field,name,field,values,timeout,checker,if,mapping,and,field,stats,null,if,mapping,and,field,stats,v1,null,mappings,put,field,name,mapping,and,field,stats,v1,if,mapping,and,field,stats,v2,null,field,stats,put,field,name,mapping,and,field,stats,v2,return,new,tuple,mappings,field,stats
FileStructureUtils -> static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(         List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker);1549035364;Given the sampled records, guess appropriate Elasticsearch mappings._@param explanation List of reasons for making decisions.  May contain items when passed and new reasons_can be appended by this method._@param sampleRecords The sampled records._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A map of field name to mapping settings.;static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>> guessMappingsAndCalculateFieldStats(_        List<String> explanation, List<Map<String, ?>> sampleRecords, TimeoutChecker timeoutChecker) {__        SortedMap<String, Object> mappings = new TreeMap<>()__        SortedMap<String, FieldStats> fieldStats = new TreeMap<>()___        Set<String> uniqueFieldNames = sampleRecords.stream().flatMap(record -> record.keySet().stream()).collect(Collectors.toSet())___        for (String fieldName : uniqueFieldNames) {__            List<Object> fieldValues = sampleRecords.stream().flatMap(record -> {_                    Object fieldValue = record.get(fieldName)__                    return (fieldValue == null) ? Stream.empty() : Stream.of(fieldValue)__                }_            ).collect(Collectors.toList())___            Tuple<Map<String, String>, FieldStats> mappingAndFieldStats =_                guessMappingAndCalculateFieldStats(explanation, fieldName, fieldValues, timeoutChecker)__            if (mappingAndFieldStats != null) {_                if (mappingAndFieldStats.v1() != null) {_                    mappings.put(fieldName, mappingAndFieldStats.v1())__                }_                if (mappingAndFieldStats.v2() != null) {_                    fieldStats.put(fieldName, mappingAndFieldStats.v2())__                }_            }_        }__        return new Tuple<>(mappings, fieldStats)__    };given,the,sampled,records,guess,appropriate,elasticsearch,mappings,param,explanation,list,of,reasons,for,making,decisions,may,contain,items,when,passed,and,new,reasons,can,be,appended,by,this,method,param,sample,records,the,sampled,records,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,map,of,field,name,to,mapping,settings;static,tuple,sorted,map,string,object,sorted,map,string,field,stats,guess,mappings,and,calculate,field,stats,list,string,explanation,list,map,string,sample,records,timeout,checker,timeout,checker,sorted,map,string,object,mappings,new,tree,map,sorted,map,string,field,stats,field,stats,new,tree,map,set,string,unique,field,names,sample,records,stream,flat,map,record,record,key,set,stream,collect,collectors,to,set,for,string,field,name,unique,field,names,list,object,field,values,sample,records,stream,flat,map,record,object,field,value,record,get,field,name,return,field,value,null,stream,empty,stream,of,field,value,collect,collectors,to,list,tuple,map,string,string,field,stats,mapping,and,field,stats,guess,mapping,and,calculate,field,stats,explanation,field,name,field,values,timeout,checker,if,mapping,and,field,stats,null,if,mapping,and,field,stats,v1,null,mappings,put,field,name,mapping,and,field,stats,v1,if,mapping,and,field,stats,v2,null,field,stats,put,field,name,mapping,and,field,stats,v2,return,new,tuple,mappings,field,stats
FileStructureUtils -> static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,                                                              FileStructureOverrides overrides, TimeoutChecker timeoutChecker);1538170812;Given one or more sample records, find a timestamp field that is consistently present in them all._To be returned the timestamp field:_- Must exist in every record_- Must have the same timestamp format in every record_If multiple fields meet these criteria then the one that occurred first in the first sample record_is chosen._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param sampleRecords List of records derived from the provided sample._@param overrides Aspects of the file structure that are known in advance.  These take precedence over_values determined by structure analysis.  An exception will be thrown if the file structure_is incompatible with an overridden value._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A tuple of (field name, timestamp format) if one can be found, or <code>null</code> if_there is no consistent timestamp.;static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,_                                                             FileStructureOverrides overrides, TimeoutChecker timeoutChecker) {_        if (sampleRecords.isEmpty()) {_            return null__        }__        _        for (Tuple<String, TimestampMatch> candidate : findCandidates(explanation, sampleRecords, overrides)) {__            boolean allGood = true__            for (Map<String, ?> sampleRecord : sampleRecords.subList(1, sampleRecords.size())) {_                Object fieldValue = sampleRecord.get(candidate.v1())__                if (fieldValue == null) {_                    if (overrides.getTimestampField() != null) {_                        throw new IllegalArgumentException("Specified timestamp field [" + overrides.getTimestampField() +_                            "] is not present in record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] doesn't have field")__                    allGood = false__                    break__                }__                timeoutChecker.check("timestamp field determination")___                TimestampMatch match = TimestampFormatFinder.findFirstFullMatch(fieldValue.toString(), overrides.getTimestampFormat())__                if (match == null || match.candidateIndex != candidate.v2().candidateIndex) {_                    if (overrides.getTimestampFormat() != null) {_                        throw new IllegalArgumentException("Specified timestamp format [" + overrides.getTimestampFormat() +_                            "] does not match for record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] matches differently: [" + match + "]")__                    allGood = false__                    break__                }_            }__            if (allGood) {_                explanation.add(((overrides.getTimestampField() == null) ? "Guessing timestamp" : "Timestamp") +_                    " field is [" + candidate.v1() + "] with format [" + candidate.v2() + "]")__                return candidate__            }_        }__        return null__    };given,one,or,more,sample,records,find,a,timestamp,field,that,is,consistently,present,in,them,all,to,be,returned,the,timestamp,field,must,exist,in,every,record,must,have,the,same,timestamp,format,in,every,record,if,multiple,fields,meet,these,criteria,then,the,one,that,occurred,first,in,the,first,sample,record,is,chosen,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,sample,records,list,of,records,derived,from,the,provided,sample,param,overrides,aspects,of,the,file,structure,that,are,known,in,advance,these,take,precedence,over,values,determined,by,structure,analysis,an,exception,will,be,thrown,if,the,file,structure,is,incompatible,with,an,overridden,value,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,tuple,of,field,name,timestamp,format,if,one,can,be,found,or,code,null,code,if,there,is,no,consistent,timestamp;static,tuple,string,timestamp,match,guess,timestamp,field,list,string,explanation,list,map,string,sample,records,file,structure,overrides,overrides,timeout,checker,timeout,checker,if,sample,records,is,empty,return,null,for,tuple,string,timestamp,match,candidate,find,candidates,explanation,sample,records,overrides,boolean,all,good,true,for,map,string,sample,record,sample,records,sub,list,1,sample,records,size,object,field,value,sample,record,get,candidate,v1,if,field,value,null,if,overrides,get,timestamp,field,null,throw,new,illegal,argument,exception,specified,timestamp,field,overrides,get,timestamp,field,is,not,present,in,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,doesn,t,have,field,all,good,false,break,timeout,checker,check,timestamp,field,determination,timestamp,match,match,timestamp,format,finder,find,first,full,match,field,value,to,string,overrides,get,timestamp,format,if,match,null,match,candidate,index,candidate,v2,candidate,index,if,overrides,get,timestamp,format,null,throw,new,illegal,argument,exception,specified,timestamp,format,overrides,get,timestamp,format,does,not,match,for,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,matches,differently,match,all,good,false,break,if,all,good,explanation,add,overrides,get,timestamp,field,null,guessing,timestamp,timestamp,field,is,candidate,v1,with,format,candidate,v2,return,candidate,return,null
FileStructureUtils -> static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,                                                              FileStructureOverrides overrides, TimeoutChecker timeoutChecker);1539615817;Given one or more sample records, find a timestamp field that is consistently present in them all._To be returned the timestamp field:_- Must exist in every record_- Must have the same timestamp format in every record_If multiple fields meet these criteria then the one that occurred first in the first sample record_is chosen._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param sampleRecords List of records derived from the provided sample._@param overrides Aspects of the file structure that are known in advance.  These take precedence over_values determined by structure analysis.  An exception will be thrown if the file structure_is incompatible with an overridden value._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A tuple of (field name, timestamp format) if one can be found, or <code>null</code> if_there is no consistent timestamp.;static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,_                                                             FileStructureOverrides overrides, TimeoutChecker timeoutChecker) {_        if (sampleRecords.isEmpty()) {_            return null__        }__        _        for (Tuple<String, TimestampMatch> candidate : findCandidates(explanation, sampleRecords, overrides)) {__            boolean allGood = true__            for (Map<String, ?> sampleRecord : sampleRecords.subList(1, sampleRecords.size())) {_                Object fieldValue = sampleRecord.get(candidate.v1())__                if (fieldValue == null) {_                    if (overrides.getTimestampField() != null) {_                        throw new IllegalArgumentException("Specified timestamp field [" + overrides.getTimestampField() +_                            "] is not present in record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] doesn't have field")__                    allGood = false__                    break__                }__                timeoutChecker.check("timestamp field determination")___                TimestampMatch match = TimestampFormatFinder.findFirstFullMatch(fieldValue.toString(), overrides.getTimestampFormat())__                if (match == null || match.candidateIndex != candidate.v2().candidateIndex) {_                    if (overrides.getTimestampFormat() != null) {_                        throw new IllegalArgumentException("Specified timestamp format [" + overrides.getTimestampFormat() +_                            "] does not match for record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] matches differently: [" + match + "]")__                    allGood = false__                    break__                }_            }__            if (allGood) {_                explanation.add(((overrides.getTimestampField() == null) ? "Guessing timestamp" : "Timestamp") +_                    " field is [" + candidate.v1() + "] with format [" + candidate.v2() + "]")__                return candidate__            }_        }__        return null__    };given,one,or,more,sample,records,find,a,timestamp,field,that,is,consistently,present,in,them,all,to,be,returned,the,timestamp,field,must,exist,in,every,record,must,have,the,same,timestamp,format,in,every,record,if,multiple,fields,meet,these,criteria,then,the,one,that,occurred,first,in,the,first,sample,record,is,chosen,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,sample,records,list,of,records,derived,from,the,provided,sample,param,overrides,aspects,of,the,file,structure,that,are,known,in,advance,these,take,precedence,over,values,determined,by,structure,analysis,an,exception,will,be,thrown,if,the,file,structure,is,incompatible,with,an,overridden,value,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,tuple,of,field,name,timestamp,format,if,one,can,be,found,or,code,null,code,if,there,is,no,consistent,timestamp;static,tuple,string,timestamp,match,guess,timestamp,field,list,string,explanation,list,map,string,sample,records,file,structure,overrides,overrides,timeout,checker,timeout,checker,if,sample,records,is,empty,return,null,for,tuple,string,timestamp,match,candidate,find,candidates,explanation,sample,records,overrides,boolean,all,good,true,for,map,string,sample,record,sample,records,sub,list,1,sample,records,size,object,field,value,sample,record,get,candidate,v1,if,field,value,null,if,overrides,get,timestamp,field,null,throw,new,illegal,argument,exception,specified,timestamp,field,overrides,get,timestamp,field,is,not,present,in,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,doesn,t,have,field,all,good,false,break,timeout,checker,check,timestamp,field,determination,timestamp,match,match,timestamp,format,finder,find,first,full,match,field,value,to,string,overrides,get,timestamp,format,if,match,null,match,candidate,index,candidate,v2,candidate,index,if,overrides,get,timestamp,format,null,throw,new,illegal,argument,exception,specified,timestamp,format,overrides,get,timestamp,format,does,not,match,for,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,matches,differently,match,all,good,false,break,if,all,good,explanation,add,overrides,get,timestamp,field,null,guessing,timestamp,timestamp,field,is,candidate,v1,with,format,candidate,v2,return,candidate,return,null
FileStructureUtils -> static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,                                                              FileStructureOverrides overrides, TimeoutChecker timeoutChecker);1544771889;Given one or more sample records, find a timestamp field that is consistently present in them all._To be returned the timestamp field:_- Must exist in every record_- Must have the same timestamp format in every record_If multiple fields meet these criteria then the one that occurred first in the first sample record_is chosen._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param sampleRecords List of records derived from the provided sample._@param overrides Aspects of the file structure that are known in advance.  These take precedence over_values determined by structure analysis.  An exception will be thrown if the file structure_is incompatible with an overridden value._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A tuple of (field name, timestamp format) if one can be found, or <code>null</code> if_there is no consistent timestamp.;static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,_                                                             FileStructureOverrides overrides, TimeoutChecker timeoutChecker) {_        if (sampleRecords.isEmpty()) {_            return null__        }__        _        for (Tuple<String, TimestampMatch> candidate : findCandidates(explanation, sampleRecords, overrides, timeoutChecker)) {__            boolean allGood = true__            for (Map<String, ?> sampleRecord : sampleRecords.subList(1, sampleRecords.size())) {_                Object fieldValue = sampleRecord.get(candidate.v1())__                if (fieldValue == null) {_                    if (overrides.getTimestampField() != null) {_                        throw new IllegalArgumentException("Specified timestamp field [" + overrides.getTimestampField() +_                            "] is not present in record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] doesn't have field")__                    allGood = false__                    break__                }__                timeoutChecker.check("timestamp field determination")___                TimestampMatch match = TimestampFormatFinder.findFirstFullMatch(fieldValue.toString(), overrides.getTimestampFormat(),_                    timeoutChecker)__                if (match == null || match.candidateIndex != candidate.v2().candidateIndex) {_                    if (overrides.getTimestampFormat() != null) {_                        throw new IllegalArgumentException("Specified timestamp format [" + overrides.getTimestampFormat() +_                            "] does not match for record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] matches differently: [" + match + "]")__                    allGood = false__                    break__                }_            }__            if (allGood) {_                explanation.add(((overrides.getTimestampField() == null) ? "Guessing timestamp" : "Timestamp") +_                    " field is [" + candidate.v1() + "] with format [" + candidate.v2() + "]")__                return candidate__            }_        }__        return null__    };given,one,or,more,sample,records,find,a,timestamp,field,that,is,consistently,present,in,them,all,to,be,returned,the,timestamp,field,must,exist,in,every,record,must,have,the,same,timestamp,format,in,every,record,if,multiple,fields,meet,these,criteria,then,the,one,that,occurred,first,in,the,first,sample,record,is,chosen,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,sample,records,list,of,records,derived,from,the,provided,sample,param,overrides,aspects,of,the,file,structure,that,are,known,in,advance,these,take,precedence,over,values,determined,by,structure,analysis,an,exception,will,be,thrown,if,the,file,structure,is,incompatible,with,an,overridden,value,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,tuple,of,field,name,timestamp,format,if,one,can,be,found,or,code,null,code,if,there,is,no,consistent,timestamp;static,tuple,string,timestamp,match,guess,timestamp,field,list,string,explanation,list,map,string,sample,records,file,structure,overrides,overrides,timeout,checker,timeout,checker,if,sample,records,is,empty,return,null,for,tuple,string,timestamp,match,candidate,find,candidates,explanation,sample,records,overrides,timeout,checker,boolean,all,good,true,for,map,string,sample,record,sample,records,sub,list,1,sample,records,size,object,field,value,sample,record,get,candidate,v1,if,field,value,null,if,overrides,get,timestamp,field,null,throw,new,illegal,argument,exception,specified,timestamp,field,overrides,get,timestamp,field,is,not,present,in,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,doesn,t,have,field,all,good,false,break,timeout,checker,check,timestamp,field,determination,timestamp,match,match,timestamp,format,finder,find,first,full,match,field,value,to,string,overrides,get,timestamp,format,timeout,checker,if,match,null,match,candidate,index,candidate,v2,candidate,index,if,overrides,get,timestamp,format,null,throw,new,illegal,argument,exception,specified,timestamp,format,overrides,get,timestamp,format,does,not,match,for,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,matches,differently,match,all,good,false,break,if,all,good,explanation,add,overrides,get,timestamp,field,null,guessing,timestamp,timestamp,field,is,candidate,v1,with,format,candidate,v2,return,candidate,return,null
FileStructureUtils -> static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,                                                              FileStructureOverrides overrides, TimeoutChecker timeoutChecker);1548533997;Given one or more sample records, find a timestamp field that is consistently present in them all._To be returned the timestamp field:_- Must exist in every record_- Must have the same timestamp format in every record_If multiple fields meet these criteria then the one that occurred first in the first sample record_is chosen._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param sampleRecords List of records derived from the provided sample._@param overrides Aspects of the file structure that are known in advance.  These take precedence over_values determined by structure analysis.  An exception will be thrown if the file structure_is incompatible with an overridden value._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A tuple of (field name, timestamp format) if one can be found, or <code>null</code> if_there is no consistent timestamp.;static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,_                                                             FileStructureOverrides overrides, TimeoutChecker timeoutChecker) {_        if (sampleRecords.isEmpty()) {_            return null__        }__        _        for (Tuple<String, TimestampMatch> candidate : findCandidates(explanation, sampleRecords, overrides, timeoutChecker)) {__            boolean allGood = true__            for (Map<String, ?> sampleRecord : sampleRecords.subList(1, sampleRecords.size())) {_                Object fieldValue = sampleRecord.get(candidate.v1())__                if (fieldValue == null) {_                    if (overrides.getTimestampField() != null) {_                        throw new IllegalArgumentException("Specified timestamp field [" + overrides.getTimestampField() +_                            "] is not present in record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] doesn't have field")__                    allGood = false__                    break__                }__                timeoutChecker.check("timestamp field determination")___                TimestampMatch match = TimestampFormatFinder.findFirstFullMatch(fieldValue.toString(), overrides.getTimestampFormat(),_                    timeoutChecker)__                if (match == null || match.candidateIndex != candidate.v2().candidateIndex) {_                    if (overrides.getTimestampFormat() != null) {_                        throw new IllegalArgumentException("Specified timestamp format [" + overrides.getTimestampFormat() +_                            "] does not match for record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] matches differently: [" + match + "]")__                    allGood = false__                    break__                }_            }__            if (allGood) {_                explanation.add(((overrides.getTimestampField() == null) ? "Guessing timestamp" : "Timestamp") +_                    " field is [" + candidate.v1() + "] with format [" + candidate.v2() + "]")__                return candidate__            }_        }__        return null__    };given,one,or,more,sample,records,find,a,timestamp,field,that,is,consistently,present,in,them,all,to,be,returned,the,timestamp,field,must,exist,in,every,record,must,have,the,same,timestamp,format,in,every,record,if,multiple,fields,meet,these,criteria,then,the,one,that,occurred,first,in,the,first,sample,record,is,chosen,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,sample,records,list,of,records,derived,from,the,provided,sample,param,overrides,aspects,of,the,file,structure,that,are,known,in,advance,these,take,precedence,over,values,determined,by,structure,analysis,an,exception,will,be,thrown,if,the,file,structure,is,incompatible,with,an,overridden,value,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,tuple,of,field,name,timestamp,format,if,one,can,be,found,or,code,null,code,if,there,is,no,consistent,timestamp;static,tuple,string,timestamp,match,guess,timestamp,field,list,string,explanation,list,map,string,sample,records,file,structure,overrides,overrides,timeout,checker,timeout,checker,if,sample,records,is,empty,return,null,for,tuple,string,timestamp,match,candidate,find,candidates,explanation,sample,records,overrides,timeout,checker,boolean,all,good,true,for,map,string,sample,record,sample,records,sub,list,1,sample,records,size,object,field,value,sample,record,get,candidate,v1,if,field,value,null,if,overrides,get,timestamp,field,null,throw,new,illegal,argument,exception,specified,timestamp,field,overrides,get,timestamp,field,is,not,present,in,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,doesn,t,have,field,all,good,false,break,timeout,checker,check,timestamp,field,determination,timestamp,match,match,timestamp,format,finder,find,first,full,match,field,value,to,string,overrides,get,timestamp,format,timeout,checker,if,match,null,match,candidate,index,candidate,v2,candidate,index,if,overrides,get,timestamp,format,null,throw,new,illegal,argument,exception,specified,timestamp,format,overrides,get,timestamp,format,does,not,match,for,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,matches,differently,match,all,good,false,break,if,all,good,explanation,add,overrides,get,timestamp,field,null,guessing,timestamp,timestamp,field,is,candidate,v1,with,format,candidate,v2,return,candidate,return,null
FileStructureUtils -> static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,                                                              FileStructureOverrides overrides, TimeoutChecker timeoutChecker);1549035364;Given one or more sample records, find a timestamp field that is consistently present in them all._To be returned the timestamp field:_- Must exist in every record_- Must have the same timestamp format in every record_If multiple fields meet these criteria then the one that occurred first in the first sample record_is chosen._@param explanation List of reasons for choosing the overall file structure.  This list_may be non-empty when the method is called, and this method may_append to it._@param sampleRecords List of records derived from the provided sample._@param overrides Aspects of the file structure that are known in advance.  These take precedence over_values determined by structure analysis.  An exception will be thrown if the file structure_is incompatible with an overridden value._@param timeoutChecker Will abort the operation if its timeout is exceeded._@return A tuple of (field name, timestamp format) if one can be found, or <code>null</code> if_there is no consistent timestamp.;static Tuple<String, TimestampMatch> guessTimestampField(List<String> explanation, List<Map<String, ?>> sampleRecords,_                                                             FileStructureOverrides overrides, TimeoutChecker timeoutChecker) {_        if (sampleRecords.isEmpty()) {_            return null__        }__        _        for (Tuple<String, TimestampMatch> candidate : findCandidates(explanation, sampleRecords, overrides, timeoutChecker)) {__            boolean allGood = true__            for (Map<String, ?> sampleRecord : sampleRecords.subList(1, sampleRecords.size())) {_                Object fieldValue = sampleRecord.get(candidate.v1())__                if (fieldValue == null) {_                    if (overrides.getTimestampField() != null) {_                        throw new IllegalArgumentException("Specified timestamp field [" + overrides.getTimestampField() +_                            "] is not present in record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] doesn't have field")__                    allGood = false__                    break__                }__                timeoutChecker.check("timestamp field determination")___                TimestampMatch match = TimestampFormatFinder.findFirstFullMatch(fieldValue.toString(), overrides.getTimestampFormat(),_                    timeoutChecker)__                if (match == null || match.candidateIndex != candidate.v2().candidateIndex) {_                    if (overrides.getTimestampFormat() != null) {_                        throw new IllegalArgumentException("Specified timestamp format [" + overrides.getTimestampFormat() +_                            "] does not match for record [" + sampleRecord + "]")__                    }_                    explanation.add("First sample match [" + candidate.v1() + "] ruled out because record [" + sampleRecord +_                        "] matches differently: [" + match + "]")__                    allGood = false__                    break__                }_            }__            if (allGood) {_                explanation.add(((overrides.getTimestampField() == null) ? "Guessing timestamp" : "Timestamp") +_                    " field is [" + candidate.v1() + "] with format [" + candidate.v2() + "]")__                return candidate__            }_        }__        return null__    };given,one,or,more,sample,records,find,a,timestamp,field,that,is,consistently,present,in,them,all,to,be,returned,the,timestamp,field,must,exist,in,every,record,must,have,the,same,timestamp,format,in,every,record,if,multiple,fields,meet,these,criteria,then,the,one,that,occurred,first,in,the,first,sample,record,is,chosen,param,explanation,list,of,reasons,for,choosing,the,overall,file,structure,this,list,may,be,non,empty,when,the,method,is,called,and,this,method,may,append,to,it,param,sample,records,list,of,records,derived,from,the,provided,sample,param,overrides,aspects,of,the,file,structure,that,are,known,in,advance,these,take,precedence,over,values,determined,by,structure,analysis,an,exception,will,be,thrown,if,the,file,structure,is,incompatible,with,an,overridden,value,param,timeout,checker,will,abort,the,operation,if,its,timeout,is,exceeded,return,a,tuple,of,field,name,timestamp,format,if,one,can,be,found,or,code,null,code,if,there,is,no,consistent,timestamp;static,tuple,string,timestamp,match,guess,timestamp,field,list,string,explanation,list,map,string,sample,records,file,structure,overrides,overrides,timeout,checker,timeout,checker,if,sample,records,is,empty,return,null,for,tuple,string,timestamp,match,candidate,find,candidates,explanation,sample,records,overrides,timeout,checker,boolean,all,good,true,for,map,string,sample,record,sample,records,sub,list,1,sample,records,size,object,field,value,sample,record,get,candidate,v1,if,field,value,null,if,overrides,get,timestamp,field,null,throw,new,illegal,argument,exception,specified,timestamp,field,overrides,get,timestamp,field,is,not,present,in,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,doesn,t,have,field,all,good,false,break,timeout,checker,check,timestamp,field,determination,timestamp,match,match,timestamp,format,finder,find,first,full,match,field,value,to,string,overrides,get,timestamp,format,timeout,checker,if,match,null,match,candidate,index,candidate,v2,candidate,index,if,overrides,get,timestamp,format,null,throw,new,illegal,argument,exception,specified,timestamp,format,overrides,get,timestamp,format,does,not,match,for,record,sample,record,explanation,add,first,sample,match,candidate,v1,ruled,out,because,record,sample,record,matches,differently,match,all,good,false,break,if,all,good,explanation,add,overrides,get,timestamp,field,null,guessing,timestamp,timestamp,field,is,candidate,v1,with,format,candidate,v2,return,candidate,return,null
FileStructureUtils -> static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>>         guessMappingsAndCalculateFieldStats(List<String> explanation, List<Map<String, ?>> sampleRecords);1536314350;Given the sampled records, guess appropriate Elasticsearch mappings._@param sampleRecords The sampled records._@return A map of field name to mapping settings.;static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>>_        guessMappingsAndCalculateFieldStats(List<String> explanation, List<Map<String, ?>> sampleRecords) {__        SortedMap<String, Object> mappings = new TreeMap<>()__        SortedMap<String, FieldStats> fieldStats = new TreeMap<>()___        Set<String> uniqueFieldNames = sampleRecords.stream().flatMap(record -> record.keySet().stream()).collect(Collectors.toSet())___        for (String fieldName : uniqueFieldNames) {__            List<Object> fieldValues = sampleRecords.stream().flatMap(record -> {_                    Object fieldValue = record.get(fieldName)__                    return (fieldValue == null) ? Stream.empty() : Stream.of(fieldValue)__                }_            ).collect(Collectors.toList())___            Tuple<Map<String, String>, FieldStats> mappingAndFieldStats =_                guessMappingAndCalculateFieldStats(explanation, fieldName, fieldValues)__            if (mappingAndFieldStats != null) {_                if (mappingAndFieldStats.v1() != null) {_                    mappings.put(fieldName, mappingAndFieldStats.v1())__                }_                if (mappingAndFieldStats.v2() != null) {_                    fieldStats.put(fieldName, mappingAndFieldStats.v2())__                }_            }_        }__        return new Tuple<>(mappings, fieldStats)__    };given,the,sampled,records,guess,appropriate,elasticsearch,mappings,param,sample,records,the,sampled,records,return,a,map,of,field,name,to,mapping,settings;static,tuple,sorted,map,string,object,sorted,map,string,field,stats,guess,mappings,and,calculate,field,stats,list,string,explanation,list,map,string,sample,records,sorted,map,string,object,mappings,new,tree,map,sorted,map,string,field,stats,field,stats,new,tree,map,set,string,unique,field,names,sample,records,stream,flat,map,record,record,key,set,stream,collect,collectors,to,set,for,string,field,name,unique,field,names,list,object,field,values,sample,records,stream,flat,map,record,object,field,value,record,get,field,name,return,field,value,null,stream,empty,stream,of,field,value,collect,collectors,to,list,tuple,map,string,string,field,stats,mapping,and,field,stats,guess,mapping,and,calculate,field,stats,explanation,field,name,field,values,if,mapping,and,field,stats,null,if,mapping,and,field,stats,v1,null,mappings,put,field,name,mapping,and,field,stats,v1,if,mapping,and,field,stats,v2,null,field,stats,put,field,name,mapping,and,field,stats,v2,return,new,tuple,mappings,field,stats
FileStructureUtils -> static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>>         guessMappingsAndCalculateFieldStats(List<String> explanation, List<Map<String, ?>> sampleRecords);1536964057;Given the sampled records, guess appropriate Elasticsearch mappings._@param sampleRecords The sampled records._@return A map of field name to mapping settings.;static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>>_        guessMappingsAndCalculateFieldStats(List<String> explanation, List<Map<String, ?>> sampleRecords) {__        SortedMap<String, Object> mappings = new TreeMap<>()__        SortedMap<String, FieldStats> fieldStats = new TreeMap<>()___        Set<String> uniqueFieldNames = sampleRecords.stream().flatMap(record -> record.keySet().stream()).collect(Collectors.toSet())___        for (String fieldName : uniqueFieldNames) {__            List<Object> fieldValues = sampleRecords.stream().flatMap(record -> {_                    Object fieldValue = record.get(fieldName)__                    return (fieldValue == null) ? Stream.empty() : Stream.of(fieldValue)__                }_            ).collect(Collectors.toList())___            Tuple<Map<String, String>, FieldStats> mappingAndFieldStats =_                guessMappingAndCalculateFieldStats(explanation, fieldName, fieldValues)__            if (mappingAndFieldStats != null) {_                if (mappingAndFieldStats.v1() != null) {_                    mappings.put(fieldName, mappingAndFieldStats.v1())__                }_                if (mappingAndFieldStats.v2() != null) {_                    fieldStats.put(fieldName, mappingAndFieldStats.v2())__                }_            }_        }__        return new Tuple<>(mappings, fieldStats)__    };given,the,sampled,records,guess,appropriate,elasticsearch,mappings,param,sample,records,the,sampled,records,return,a,map,of,field,name,to,mapping,settings;static,tuple,sorted,map,string,object,sorted,map,string,field,stats,guess,mappings,and,calculate,field,stats,list,string,explanation,list,map,string,sample,records,sorted,map,string,object,mappings,new,tree,map,sorted,map,string,field,stats,field,stats,new,tree,map,set,string,unique,field,names,sample,records,stream,flat,map,record,record,key,set,stream,collect,collectors,to,set,for,string,field,name,unique,field,names,list,object,field,values,sample,records,stream,flat,map,record,object,field,value,record,get,field,name,return,field,value,null,stream,empty,stream,of,field,value,collect,collectors,to,list,tuple,map,string,string,field,stats,mapping,and,field,stats,guess,mapping,and,calculate,field,stats,explanation,field,name,field,values,if,mapping,and,field,stats,null,if,mapping,and,field,stats,v1,null,mappings,put,field,name,mapping,and,field,stats,v1,if,mapping,and,field,stats,v2,null,field,stats,put,field,name,mapping,and,field,stats,v2,return,new,tuple,mappings,field,stats
FileStructureUtils -> static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>>         guessMappingsAndCalculateFieldStats(List<String> explanation, List<Map<String, ?>> sampleRecords);1538067637;Given the sampled records, guess appropriate Elasticsearch mappings._@param sampleRecords The sampled records._@return A map of field name to mapping settings.;static Tuple<SortedMap<String, Object>, SortedMap<String, FieldStats>>_        guessMappingsAndCalculateFieldStats(List<String> explanation, List<Map<String, ?>> sampleRecords) {__        SortedMap<String, Object> mappings = new TreeMap<>()__        SortedMap<String, FieldStats> fieldStats = new TreeMap<>()___        Set<String> uniqueFieldNames = sampleRecords.stream().flatMap(record -> record.keySet().stream()).collect(Collectors.toSet())___        for (String fieldName : uniqueFieldNames) {__            List<Object> fieldValues = sampleRecords.stream().flatMap(record -> {_                    Object fieldValue = record.get(fieldName)__                    return (fieldValue == null) ? Stream.empty() : Stream.of(fieldValue)__                }_            ).collect(Collectors.toList())___            Tuple<Map<String, String>, FieldStats> mappingAndFieldStats =_                guessMappingAndCalculateFieldStats(explanation, fieldName, fieldValues)__            if (mappingAndFieldStats != null) {_                if (mappingAndFieldStats.v1() != null) {_                    mappings.put(fieldName, mappingAndFieldStats.v1())__                }_                if (mappingAndFieldStats.v2() != null) {_                    fieldStats.put(fieldName, mappingAndFieldStats.v2())__                }_            }_        }__        return new Tuple<>(mappings, fieldStats)__    };given,the,sampled,records,guess,appropriate,elasticsearch,mappings,param,sample,records,the,sampled,records,return,a,map,of,field,name,to,mapping,settings;static,tuple,sorted,map,string,object,sorted,map,string,field,stats,guess,mappings,and,calculate,field,stats,list,string,explanation,list,map,string,sample,records,sorted,map,string,object,mappings,new,tree,map,sorted,map,string,field,stats,field,stats,new,tree,map,set,string,unique,field,names,sample,records,stream,flat,map,record,record,key,set,stream,collect,collectors,to,set,for,string,field,name,unique,field,names,list,object,field,values,sample,records,stream,flat,map,record,object,field,value,record,get,field,name,return,field,value,null,stream,empty,stream,of,field,value,collect,collectors,to,list,tuple,map,string,string,field,stats,mapping,and,field,stats,guess,mapping,and,calculate,field,stats,explanation,field,name,field,values,if,mapping,and,field,stats,null,if,mapping,and,field,stats,v1,null,mappings,put,field,name,mapping,and,field,stats,v1,if,mapping,and,field,stats,v2,null,field,stats,put,field,name,mapping,and,field,stats,v2,return,new,tuple,mappings,field,stats
