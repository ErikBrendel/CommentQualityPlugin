commented;modifiers;parameterAmount;loc;comment;code
true;private,static;1;12;/**  * Calculates the delay until the next time the maintenance should be triggered.  * The next time is 30 minutes past midnight of the following day plus a random  * offset. The random offset is added in order to avoid multiple clusters  * running the maintenance tasks at the same time. A cluster with a given name  * shall have the same offset throughout its life.  *  * @param clusterName the cluster name is used to seed the random offset  * @return the delay to the next time the maintenance should be triggered  */ ;/**  * Calculates the delay until the next time the maintenance should be triggered.  * The next time is 30 minutes past midnight of the following day plus a random  * offset. The random offset is added in order to avoid multiple clusters  * running the maintenance tasks at the same time. A cluster with a given name  * shall have the same offset throughout its life.  *  * @param clusterName the cluster name is used to seed the random offset  * @return the delay to the next time the maintenance should be triggered  */ private static TimeValue delayToNextTime(ClusterName clusterName) {     Random random = new Random(clusterName.hashCode()).     int minutesOffset = random.ints(0, MAX_TIME_OFFSET_MINUTES).findFirst().getAsInt().     ZonedDateTime now = ZonedDateTime.now(Clock.systemDefaultZone()).     ZonedDateTime next = now.plusDays(1).toLocalDate().atStartOfDay(now.getZone()).plusMinutes(30).plusMinutes(minutesOffset).     return TimeValue.timeValueMillis(next.toInstant().toEpochMilli() - now.toInstant().toEpochMilli()). }
false;public;0;4;;public void start() {     LOGGER.debug("Starting ML daily maintenance service").     scheduleNext(). }
false;public;0;6;;public void stop() {     LOGGER.debug("Stopping ML daily maintenance service").     if (cancellable != null && cancellable.isCancelled() == false) {         cancellable.cancel().     } }
false;public;0;3;;public boolean isStarted() {     return cancellable != null. }
false;public;0;4;;@Override public void close() {     stop(). }
false;private;0;11;;private void scheduleNext() {     try {         cancellable = threadPool.schedule(this::triggerTasks, schedulerProvider.get(), ThreadPool.Names.GENERIC).     } catch (EsRejectedExecutionException e) {         if (e.isExecutorShutdown()) {             LOGGER.debug("failed to schedule next maintenance task. shutting down", e).         } else {             throw e.         }     } }
false;private;0;8;;private void triggerTasks() {     LOGGER.info("triggering scheduled [ML] maintenance tasks").     executeAsyncWithOrigin(client, ML_ORIGIN, DeleteExpiredDataAction.INSTANCE, new DeleteExpiredDataAction.Request(), ActionListener.wrap(response -> LOGGER.info("Successfully completed [ML] maintenance tasks"), e -> LOGGER.error("An error occurred during maintenance tasks execution", e))).     scheduleNext(). }
