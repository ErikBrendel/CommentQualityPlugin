commented;modifiers;parameterAmount;loc;comment;code
false;;2;5;;DelimitedFileStructureFinderFactory makeSimilar(Character quote, Boolean trimFields) {     return new DelimitedFileStructureFinderFactory((char) csvPreference.getDelimiterChar(), (quote == null) ? csvPreference.getQuoteChar() : quote, minFieldsPerRow, (trimFields == null) ? this.trimFields : trimFields). }
false;public;1;4;;@Override public boolean canFindFormat(FileStructure.Format format) {     return format == null || format == FileStructure.Format.DELIMITED. }
true;public;2;16;/**  * Rules are:  * - It must contain at least two complete records  * - There must be a minimum number of fields per record (otherwise files with no commas could be treated as CSV!)  * - Every record except the last must have the same number of fields  * The reason the last record is allowed to have fewer fields than the others is that  * it could have been truncated when the file was sampled.  */ ;/**  * Rules are:  * - It must contain at least two complete records  * - There must be a minimum number of fields per record (otherwise files with no commas could be treated as CSV!)  * - Every record except the last must have the same number of fields  * The reason the last record is allowed to have fewer fields than the others is that  * it could have been truncated when the file was sampled.  */ @Override public boolean canCreateFromSample(List<String> explanation, String sample) {     String formatName.     switch((char) csvPreference.getDelimiterChar()) {         case ',':             formatName = "CSV".             break.         case '\t':             formatName = "TSV".             break.         default:             formatName = Character.getName(csvPreference.getDelimiterChar()).toLowerCase(Locale.ROOT) + " delimited values".             break.     }     return DelimitedFileStructureFinder.canCreateFromSample(explanation, sample, minFieldsPerRow, csvPreference, formatName). }
false;public;6;6;;@Override public FileStructureFinder createFromSample(List<String> explanation, String sample, String charsetName, Boolean hasByteOrderMarker, FileStructureOverrides overrides, TimeoutChecker timeoutChecker) throws IOException {     return DelimitedFileStructureFinder.makeDelimitedFileStructureFinder(explanation, sample, charsetName, hasByteOrderMarker, csvPreference, trimFields, overrides, timeoutChecker). }
