commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;26;;@Override protected void doExecute(Task task, DeleteForecastAction.Request request, ActionListener<AcknowledgedResponse> listener) {     final String jobId = request.getJobId().     final String forecastsExpression = request.getForecastId().     ActionListener<SearchResponse> forecastStatsHandler = ActionListener.wrap(searchResponse -> deleteForecasts(searchResponse, request, listener), e -> listener.onFailure(new ElasticsearchException("An error occurred while searching forecasts to delete", e))).     SearchSourceBuilder source = new SearchSourceBuilder().     BoolQueryBuilder builder = QueryBuilders.boolQuery().     BoolQueryBuilder innerBool = QueryBuilders.boolQuery().must(QueryBuilders.termQuery(Result.RESULT_TYPE.getPreferredName(), ForecastRequestStats.RESULT_TYPE_VALUE)).     if (MetaData.ALL.equals(request.getForecastId()) == false) {         Set<String> forcastIds = new HashSet<>(Arrays.asList(Strings.tokenizeToStringArray(forecastsExpression, ","))).         innerBool.must(QueryBuilders.termsQuery(Forecast.FORECAST_ID.getPreferredName(), forcastIds)).     }     source.query(builder.filter(innerBool)).     SearchRequest searchRequest = new SearchRequest(AnomalyDetectorsIndex.jobResultsAliasedName(jobId)).     searchRequest.source(source).     executeAsyncWithOrigin(client, ML_ORIGIN, SearchAction.INSTANCE, searchRequest, forecastStatsHandler). }
false;private;3;54;;private void deleteForecasts(SearchResponse searchResponse, DeleteForecastAction.Request request, ActionListener<AcknowledgedResponse> listener) {     final String jobId = request.getJobId().     Set<ForecastRequestStats> forecastsToDelete.     try {         forecastsToDelete = parseForecastsFromSearch(searchResponse).     } catch (IOException e) {         listener.onFailure(e).         return.     }     if (forecastsToDelete.isEmpty()) {         if (MetaData.ALL.equals(request.getForecastId()) && request.isAllowNoForecasts()) {             listener.onResponse(new AcknowledgedResponse(true)).         } else {             listener.onFailure(new ResourceNotFoundException(Messages.getMessage(Messages.REST_NO_SUCH_FORECAST, request.getForecastId(), jobId))).         }         return.     }     List<String> badStatusForecasts = forecastsToDelete.stream().filter((f) -> !DELETABLE_STATUSES.contains(f.getStatus())).map(ForecastRequestStats::getForecastId).collect(Collectors.toList()).     if (badStatusForecasts.size() > 0) {         listener.onFailure(ExceptionsHelper.conflictStatusException(Messages.getMessage(Messages.REST_CANNOT_DELETE_FORECAST_IN_CURRENT_STATE, badStatusForecasts, jobId))).         return.     }     final List<String> forecastIds = forecastsToDelete.stream().map(ForecastRequestStats::getForecastId).collect(Collectors.toList()).     DeleteByQueryRequest deleteByQueryRequest = buildDeleteByQuery(jobId, forecastIds).     executeAsyncWithOrigin(client, ML_ORIGIN, DeleteByQueryAction.INSTANCE, deleteByQueryRequest, ActionListener.wrap(response -> {         if (response.isTimedOut()) {             listener.onFailure(new TimeoutException("Delete request timed out. Successfully deleted " + response.getDeleted() + " forecast documents from job [" + jobId + "]")).             return.         }         if ((response.getBulkFailures().isEmpty() && response.getSearchFailures().isEmpty()) == false) {             Tuple<RestStatus, Throwable> statusAndReason = getStatusAndReason(response).             listener.onFailure(new ElasticsearchStatusException(statusAndReason.v2().getMessage(), statusAndReason.v1(), statusAndReason.v2())).             return.         }         logger.info("Deleted forecast(s) [{}] from job [{}]", forecastIds, jobId).         listener.onResponse(new AcknowledgedResponse(true)).     }, listener::onFailure)). }
false;private,static;1;21;;private static Tuple<RestStatus, Throwable> getStatusAndReason(final BulkByScrollResponse response) {     RestStatus status = RestStatus.OK.     Throwable reason = new Exception("Unknown error").     // Unsure of a better way to return an appropriate and possibly actionable cause to the user.     for (BulkItemResponse.Failure failure : response.getBulkFailures()) {         if (failure.getStatus().getStatus() > status.getStatus()) {             status = failure.getStatus().             reason = failure.getCause().         }     }     for (ScrollableHitSource.SearchFailure failure : response.getSearchFailures()) {         RestStatus failureStatus = org.elasticsearch.ExceptionsHelper.status(failure.getReason()).         if (failureStatus.getStatus() > status.getStatus()) {             status = failureStatus.             reason = failure.getReason().         }     }     return new Tuple<>(status, reason). }
false;private,static;1;12;;private static Set<ForecastRequestStats> parseForecastsFromSearch(SearchResponse searchResponse) throws IOException {     SearchHits hits = searchResponse.getHits().     List<ForecastRequestStats> allStats = new ArrayList<>(hits.getHits().length).     for (SearchHit hit : hits) {         try (InputStream stream = hit.getSourceRef().streamInput().             XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, stream)) {             allStats.add(ForecastRequestStats.STRICT_PARSER.apply(parser, null)).         }     }     return new HashSet<>(allStats). }
false;private;2;19;;private DeleteByQueryRequest buildDeleteByQuery(String jobId, List<String> forecastsToDelete) {     DeleteByQueryRequest request = new DeleteByQueryRequest().setAbortOnVersionConflict(// since these documents are not updated, a conflict just means it was deleted previously     false).setSize(MAX_FORECAST_TO_SEARCH).setSlices(5).     request.indices(AnomalyDetectorsIndex.jobResultsAliasedName(jobId)).     BoolQueryBuilder innerBoolQuery = QueryBuilders.boolQuery().     innerBoolQuery.must(QueryBuilders.termsQuery(Result.RESULT_TYPE.getPreferredName(), ForecastRequestStats.RESULT_TYPE_VALUE, Forecast.RESULT_TYPE_VALUE)).must(QueryBuilders.termsQuery(Forecast.FORECAST_ID.getPreferredName(), forecastsToDelete)).     QueryBuilder query = QueryBuilders.boolQuery().filter(innerBoolQuery).     request.setQuery(query).     request.setRefresh(true).     return request. }
