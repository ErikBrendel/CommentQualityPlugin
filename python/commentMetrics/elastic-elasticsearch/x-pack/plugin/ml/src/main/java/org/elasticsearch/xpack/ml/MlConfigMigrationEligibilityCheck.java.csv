commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private void setConfigMigrationEnabled(boolean configMigrationEnabled) {     this.isConfigMigrationEnabled = configMigrationEnabled. }
true;public;1;12;/**  * Can migration start? Returns:  *     False if config migration is disabled via the setting {@link #ENABLE_CONFIG_MIGRATION}  *     False if the min node version of the cluster is before {@link #MIN_NODE_VERSION}  *     False if the .ml-config index shards are not active  *     True otherwise  * @param clusterState The cluster state  * @return A boolean that dictates if config migration can start  */ ;/**  * Can migration start? Returns:  *     False if config migration is disabled via the setting {@link #ENABLE_CONFIG_MIGRATION}  *     False if the min node version of the cluster is before {@link #MIN_NODE_VERSION}  *     False if the .ml-config index shards are not active  *     True otherwise  * @param clusterState The cluster state  * @return A boolean that dictates if config migration can start  */ public boolean canStartMigration(ClusterState clusterState) {     if (isConfigMigrationEnabled == false) {         return false.     }     Version minNodeVersion = clusterState.nodes().getMinNodeVersion().     if (minNodeVersion.before(MIN_NODE_VERSION)) {         return false.     }     return mlConfigIndexIsAllocated(clusterState). }
false;static;1;11;;static boolean mlConfigIndexIsAllocated(ClusterState clusterState) {     if (clusterState.metaData().hasIndex(AnomalyDetectorsIndex.configIndexName()) == false) {         return false.     }     IndexRoutingTable routingTable = clusterState.getRoutingTable().index(AnomalyDetectorsIndex.configIndexName()).     if (routingTable == null || routingTable.allPrimaryShardsActive() == false) {         return false.     }     return true. }
true;public;2;16;/**  * Is the job a eligible for migration? Returns:  *     False if {@link #canStartMigration(ClusterState)} returns {@code false}  *     False if the job is not in the cluster state  *     False if the {@link Job#isDeleting()}  *     False if the job has an allocated persistent task  *     True otherwise i.e. the job is present, not deleting  *     and does not have a persistent task or its persistent  *     task is un-allocated  *  * @param jobId         The job Id  * @param clusterState  The cluster state  * @return A boolean depending on the conditions listed above  */ ;/**  * Is the job a eligible for migration? Returns:  *     False if {@link #canStartMigration(ClusterState)} returns {@code false}  *     False if the job is not in the cluster state  *     False if the {@link Job#isDeleting()}  *     False if the job has an allocated persistent task  *     True otherwise i.e. the job is present, not deleting  *     and does not have a persistent task or its persistent  *     task is un-allocated  *  * @param jobId         The job Id  * @param clusterState  The cluster state  * @return A boolean depending on the conditions listed above  */ public boolean jobIsEligibleForMigration(String jobId, ClusterState clusterState) {     if (canStartMigration(clusterState) == false) {         return false.     }     MlMetadata mlMetadata = MlMetadata.getMlMetadata(clusterState).     Job job = mlMetadata.getJobs().get(jobId).     if (job == null || job.isDeleting()) {         return false.     }     PersistentTasksCustomMetaData persistentTasks = clusterState.metaData().custom(PersistentTasksCustomMetaData.TYPE).     return MlTasks.openJobIds(persistentTasks).contains(jobId) == false || MlTasks.unallocatedJobIds(persistentTasks, clusterState.nodes()).contains(jobId). }
true;public;2;14;/**  * Is the datafeed a eligible for migration? Returns:  *     False if {@link #canStartMigration(ClusterState)} returns {@code false}  *     False if the datafeed is not in the cluster state  *     False if the datafeed has an allocated persistent task  *     True otherwise i.e. the datafeed is present and does not have a persistent  *     task or its persistent task is un-allocated  *  * @param datafeedId   The datafeed Id  * @param clusterState  The cluster state  * @return A boolean depending on the conditions listed above  */ ;/**  * Is the datafeed a eligible for migration? Returns:  *     False if {@link #canStartMigration(ClusterState)} returns {@code false}  *     False if the datafeed is not in the cluster state  *     False if the datafeed has an allocated persistent task  *     True otherwise i.e. the datafeed is present and does not have a persistent  *     task or its persistent task is un-allocated  *  * @param datafeedId   The datafeed Id  * @param clusterState  The cluster state  * @return A boolean depending on the conditions listed above  */ public boolean datafeedIsEligibleForMigration(String datafeedId, ClusterState clusterState) {     if (canStartMigration(clusterState) == false) {         return false.     }     MlMetadata mlMetadata = MlMetadata.getMlMetadata(clusterState).     if (mlMetadata.getDatafeeds().containsKey(datafeedId) == false) {         return false.     }     PersistentTasksCustomMetaData persistentTasks = clusterState.metaData().custom(PersistentTasksCustomMetaData.TYPE).     return MlTasks.startedDatafeedIds(persistentTasks).contains(datafeedId) == false || MlTasks.unallocatedDatafeedIds(persistentTasks, clusterState.nodes()).contains(datafeedId). }
