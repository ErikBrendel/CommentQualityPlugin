commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Create the control message writer with a OutputStream. A  * LengthEncodedWriter is created on the OutputStream parameter  *  * @param os             The output stream  * @param numberOfFields The number of fields the process expects in each record  */ ;/**  * Create the control message writer with a OutputStream. A  * LengthEncodedWriter is created on the OutputStream parameter  *  * @param os             The output stream  * @param numberOfFields The number of fields the process expects in each record  */ public static AutodetectControlMsgWriter create(OutputStream os, int numberOfFields) {     return new AutodetectControlMsgWriter(new LengthEncodedWriter(os), numberOfFields). }
true;public;1;11;/**  * Writes the control messages that are requested when flushing a job.  * Those control messages need to be followed by a flush message in order  * for them to reach the C++ process immediately. List of supported controls:  *  * <ul>  *   <li>advance time</li>  *   <li>calculate interim results</li>  * </ul>  *  * @param params Parameters describing the controls that will accompany the flushing  *               (e.g. calculating interim results, time control, etc.)  */ ;/**  * Writes the control messages that are requested when flushing a job.  * Those control messages need to be followed by a flush message in order  * for them to reach the C++ process immediately. List of supported controls:  *  * <ul>  *   <li>advance time</li>  *   <li>calculate interim results</li>  * </ul>  *  * @param params Parameters describing the controls that will accompany the flushing  *               (e.g. calculating interim results, time control, etc.)  */ public void writeFlushControlMessage(FlushJobParams params) throws IOException {     if (params.shouldSkipTime()) {         writeMessage(SKIP_TIME_MESSAGE_CODE + params.getSkipTime()).     }     if (params.shouldAdvanceTime()) {         writeMessage(ADVANCE_TIME_MESSAGE_CODE + params.getAdvanceTime()).     }     if (params.shouldCalculateInterim()) {         writeControlCodeFollowedByTimeRange(INTERIM_MESSAGE_CODE, params.getStart(), params.getEnd()).     } }
true;public;0;9;/**  * Send a flush message to the C++ autodetect process.  * This actually consists of two messages: one to carry the flush ID and the  * other (which might not be processed until much later) to fill the buffers  * and force prior messages through.  *  * @return an ID for this flush that will be echoed back by the C++  * autodetect process once it is complete.  */ ;/**  * Send a flush message to the C++ autodetect process.  * This actually consists of two messages: one to carry the flush ID and the  * other (which might not be processed until much later) to fill the buffers  * and force prior messages through.  *  * @return an ID for this flush that will be echoed back by the C++  * autodetect process once it is complete.  */ public String writeFlushMessage() throws IOException {     String flushId = Long.toString(ms_FlushNumber.getAndIncrement()).     writeMessage(FLUSH_MESSAGE_CODE + flushId).     fillCommandBuffer().     lengthEncodedWriter.flush().     return flushId. }
false;public;1;20;;public void writeForecastMessage(ForecastParams params) throws IOException {     XContentBuilder builder = XContentFactory.jsonBuilder().startObject().     builder.field("forecast_id", params.getForecastId()).     builder.field("create_time", params.getCreateTime()).     if (params.getDuration() != 0) {         builder.field("duration", params.getDuration()).     }     if (params.getExpiresIn() != -1) {         builder.field("expires_in", params.getExpiresIn()).     }     if (params.getTmpStorage() != null) {         builder.field("tmp_storage", params.getTmpStorage()).     }     builder.endObject().     writeMessage(FORECAST_MESSAGE_CODE + Strings.toString(builder)).     fillCommandBuffer().     lengthEncodedWriter.flush(). }
false;public;1;3;;public void writeResetBucketsMessage(DataLoadParams params) throws IOException {     writeControlCodeFollowedByTimeRange(RESET_BUCKETS_MESSAGE_CODE, params.getStart(), params.getEnd()). }
false;private;3;10;;private void writeControlCodeFollowedByTimeRange(String code, String start, String end) throws IOException {     StringBuilder message = new StringBuilder(code).     if (start.isEmpty() == false) {         message.append(start).         message.append(' ').         message.append(end).     }     writeMessage(message.toString()). }
false;public;1;6;;public void writeUpdateModelPlotMessage(ModelPlotConfig modelPlotConfig) throws IOException {     StringWriter configWriter = new StringWriter().     configWriter.append(UPDATE_MESSAGE_CODE).append("[modelPlotConfig]\n").     new ModelPlotConfigWriter(modelPlotConfig, configWriter).write().     writeMessage(configWriter.toString()). }
false;public;2;18;;public void writeUpdateDetectorRulesMessage(int detectorIndex, List<DetectionRule> rules) throws IOException {     StringBuilder stringBuilder = new StringBuilder().     stringBuilder.append(UPDATE_MESSAGE_CODE).append("[detectorRules]\n").     stringBuilder.append("detectorIndex=").append(Integer.toString(detectorIndex)).append("\n").     stringBuilder.append("rulesJson=").     try (XContentBuilder builder = JsonXContent.contentBuilder()) {         builder.startArray().         for (DetectionRule rule : rules) {             rule.toXContent(builder, ToXContent.EMPTY_PARAMS).         }         builder.endArray().         stringBuilder.append(Strings.toString(builder)).     }     writeMessage(stringBuilder.toString()). }
false;public;1;6;;public void writeUpdateFiltersMessage(List<MlFilter> filters) throws IOException {     StringBuilder stringBuilder = new StringBuilder().     stringBuilder.append(UPDATE_MESSAGE_CODE).append("[filters]\n").     new MlFilterWriter(filters, stringBuilder).write().     writeMessage(stringBuilder.toString()). }
false;public;2;10;;public void writeUpdateScheduledEventsMessage(List<ScheduledEvent> events, TimeValue bucketSpan) throws IOException {     StringBuilder stringBuilder = new StringBuilder().     stringBuilder.append(UPDATE_MESSAGE_CODE).append("[scheduledEvents]\n").     if (events.isEmpty()) {         stringBuilder.append("clear = true\n").     } else {         new ScheduledEventsWriter(events, bucketSpan, stringBuilder).write().     }     writeMessage(stringBuilder.toString()). }
false;public;0;5;;public void writeStartBackgroundPersistMessage() throws IOException {     writeMessage(BACKGROUND_PERSIST_MESSAGE_CODE).     fillCommandBuffer().     lengthEncodedWriter.flush(). }
