# id;timestamp;commentText;codeText;commentWords;codeWords
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1524684173;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1526900724;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1529076503;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1531179852;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1533230566;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1534338685;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1538067637;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1538424609;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1540583181;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1541008027;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1541092382;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1543343306;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1545155131;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1545227023;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1545310197;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1547212955;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1547224315;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1547622613;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1547743595;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1547843554;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1548236257;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1548688050;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1548774580;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler);1548870984;Flush the running job, ensuring that the native process has had the_opportunity to process all data previously sent to it with none left_sitting in buffers.__@param jobTask   The job task_@param params Parameters describing the controls that will accompany the flushing_(e.g. calculating interim results, time control, etc.);public void flushJob(JobTask jobTask, FlushJobParams params, ActionListener<FlushAcknowledgement> handler) {_        logger.debug("Flushing job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot flush because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.onFailure(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.flushJob(params, (flushAcknowledgement, e) -> {_            if (e != null) {_                String msg = String.format(Locale.ROOT, "[%s] exception while flushing job", jobTask.getJobId())__                logger.error(msg)__                handler.onFailure(ExceptionsHelper.serverError(msg, e))__            } else {_                handler.onResponse(flushAcknowledgement)__            }_        })__    };flush,the,running,job,ensuring,that,the,native,process,has,had,the,opportunity,to,process,all,data,previously,sent,to,it,with,none,left,sitting,in,buffers,param,job,task,the,job,task,param,params,parameters,describing,the,controls,that,will,accompany,the,flushing,e,g,calculating,interim,results,time,control,etc;public,void,flush,job,job,task,job,task,flush,job,params,params,action,listener,flush,acknowledgement,handler,logger,debug,flushing,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,flush,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,on,failure,exceptions,helper,conflict,status,exception,message,return,communicator,flush,job,params,flush,acknowledgement,e,if,e,null,string,msg,string,format,locale,root,s,exception,while,flushing,job,job,task,get,job,id,logger,error,msg,handler,on,failure,exceptions,helper,server,error,msg,e,else,handler,on,response,flush,acknowledgement
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1524684173;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1526900724;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1529076503;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1531179852;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1533230566;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1534338685;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1538067637;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1538424609;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1540583181;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1541008027;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1541092382;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1543343306;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1545155131;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1545227023;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1545310197;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() + "] is not open")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,is,not,open,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1547212955;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() +_                "] does not have a corresponding autodetect process")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,does,not,have,a,corresponding,autodetect,process,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1547224315;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() +_                "] does not have a corresponding autodetect process")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,does,not,have,a,corresponding,autodetect,process,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1547622613;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() +_                "] does not have a corresponding autodetect process")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,does,not,have,a,corresponding,autodetect,process,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1547743595;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() +_                "] does not have a corresponding autodetect process")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,does,not,have,a,corresponding,autodetect,process,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1547843554;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() +_                "] does not have a corresponding autodetect process")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,does,not,have,a,corresponding,autodetect,process,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1548236257;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() +_                "] does not have a corresponding autodetect process")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,does,not,have,a,corresponding,autodetect,process,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1548688050;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() +_                "] does not have a corresponding autodetect process")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,does,not,have,a,corresponding,autodetect,process,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1548774580;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() +_                "] does not have a corresponding autodetect process")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,does,not,have,a,corresponding,autodetect,process,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,                             XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler);1548870984;Passes data to the native process._This is a blocking call that won't return until all the data has been_written to the process._<p>_An ElasticsearchStatusException will be thrown is any of these error conditions occur:_<ol>_<li>If a configured field is missing from the CSV header</li>_<li>If JSON data is malformed and we cannot recover parsing</li>_<li>If a high proportion of the records the timestamp field that cannot be parsed</li>_<li>If a high proportion of the records chronologically out of order</li>_</ol>__@param jobTask          The job task_@param analysisRegistry Registry of analyzer components - this is used to build a categorization analyzer if necessary_@param input            Data input stream_@param xContentType     the {@link XContentType} of the input_@param params           Data processing parameters_@param handler          Delegate error or datacount results (Count of records, fields, bytes, etc written);public void processData(JobTask jobTask, AnalysisRegistry analysisRegistry, InputStream input,_                            XContentType xContentType, DataLoadParams params, BiConsumer<DataCounts, Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            throw ExceptionsHelper.conflictStatusException("Cannot process data because job [" + jobTask.getJobId() +_                "] does not have a corresponding autodetect process")__        }_        communicator.writeToJob(input, analysisRegistry, xContentType, params, handler)__    };passes,data,to,the,native,process,this,is,a,blocking,call,that,won,t,return,until,all,the,data,has,been,written,to,the,process,p,an,elasticsearch,status,exception,will,be,thrown,is,any,of,these,error,conditions,occur,ol,li,if,a,configured,field,is,missing,from,the,csv,header,li,li,if,json,data,is,malformed,and,we,cannot,recover,parsing,li,li,if,a,high,proportion,of,the,records,the,timestamp,field,that,cannot,be,parsed,li,li,if,a,high,proportion,of,the,records,chronologically,out,of,order,li,ol,param,job,task,the,job,task,param,analysis,registry,registry,of,analyzer,components,this,is,used,to,build,a,categorization,analyzer,if,necessary,param,input,data,input,stream,param,x,content,type,the,link,xcontent,type,of,the,input,param,params,data,processing,parameters,param,handler,delegate,error,or,datacount,results,count,of,records,fields,bytes,etc,written;public,void,process,data,job,task,job,task,analysis,registry,analysis,registry,input,stream,input,xcontent,type,x,content,type,data,load,params,params,bi,consumer,data,counts,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,throw,exceptions,helper,conflict,status,exception,cannot,process,data,because,job,job,task,get,job,id,does,not,have,a,corresponding,autodetect,process,communicator,write,to,job,input,analysis,registry,x,content,type,params,handler
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1524684173;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1526900724;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1529076503;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1531179852;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1533230566;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1534338685;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1538067637;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1538424609;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1540583181;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1541008027;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1541092382;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1543343306;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1545155131;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1545227023;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1545310197;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1547212955;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1547224315;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1547622613;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1547743595;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1547843554;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1548236257;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1548688050;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1548774580;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED)__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void closeJob(JobTask jobTask, boolean restart, String reason);1548870984;Stop the running job and mark it as finished.__@param jobTask The job to stop_@param restart Whether the job should be restarted by persistent tasks_@param reason  The reason for closing the job;public void closeJob(JobTask jobTask, boolean restart, String reason) {_        String jobId = jobTask.getJobId()__        long allocationId = jobTask.getAllocationId()__        logger.debug("Attempting to close job [{}], because [{}]", jobId, reason)__        _        _        ProcessContext processContext = processByAllocation.get(allocationId)__        if (processContext == null) {_            logger.debug("Cannot close job [{}] as it has already been closed", jobId)__            return__        }__        processContext.tryLock()__        try {_            if (processContext.setDying() == false) {_                logger.debug("Cannot close job [{}] as it has already been closed", jobId)__                return__            }__            if (reason == null) {_                logger.info("Closing job [{}]", jobId)__            } else {_                logger.info("Closing job [{}], because [{}]", jobId, reason)__            }__            AutodetectCommunicator communicator = processContext.getAutodetectCommunicator()__            if (communicator == null) {_                logger.debug("Job [{}] is being closed before its process is started", jobId)__                jobTask.markAsCompleted()__                return__            }__            communicator.close(restart, reason)__            processByAllocation.remove(allocationId)__        } catch (Exception e) {_            _            if (e instanceof ElasticsearchStatusException && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT) {_                throw e__            }_            logger.warn("[" + jobId + "] Exception closing autodetect process", e)__            setJobState(jobTask, JobState.FAILED, e.getMessage())__            throw ExceptionsHelper.serverError("Exception closing autodetect process", e)__        } finally {_            _            _            _            processContext.unlock()__        }_        _        try {_            removeTmpStorage(jobId)__        } catch (IOException e) {_            logger.error(new ParameterizedMessage("[{}]Failed to delete temporary files", jobId), e)__        }_    };stop,the,running,job,and,mark,it,as,finished,param,job,task,the,job,to,stop,param,restart,whether,the,job,should,be,restarted,by,persistent,tasks,param,reason,the,reason,for,closing,the,job;public,void,close,job,job,task,job,task,boolean,restart,string,reason,string,job,id,job,task,get,job,id,long,allocation,id,job,task,get,allocation,id,logger,debug,attempting,to,close,job,because,job,id,reason,process,context,process,context,process,by,allocation,get,allocation,id,if,process,context,null,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,process,context,try,lock,try,if,process,context,set,dying,false,logger,debug,cannot,close,job,as,it,has,already,been,closed,job,id,return,if,reason,null,logger,info,closing,job,job,id,else,logger,info,closing,job,because,job,id,reason,autodetect,communicator,communicator,process,context,get,autodetect,communicator,if,communicator,null,logger,debug,job,is,being,closed,before,its,process,is,started,job,id,job,task,mark,as,completed,return,communicator,close,restart,reason,process,by,allocation,remove,allocation,id,catch,exception,e,if,e,instanceof,elasticsearch,status,exception,elasticsearch,status,exception,e,status,rest,status,conflict,throw,e,logger,warn,job,id,exception,closing,autodetect,process,e,set,job,state,job,task,job,state,failed,e,get,message,throw,exceptions,helper,server,error,exception,closing,autodetect,process,e,finally,process,context,unlock,try,remove,tmp,storage,job,id,catch,ioexception,e,logger,error,new,parameterized,message,failed,to,delete,temporary,files,job,id,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1524684173;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        logger.debug("Forecasting job {}", jobTask.getJobId())__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobTask.getJobId())__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,logger,debug,forecasting,job,job,task,get,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,task,get,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1526900724;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1529076503;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1531179852;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1533230566;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1534338685;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1538067637;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1538424609;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1540583181;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1541008027;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1541092382;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1543343306;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1545155131;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1545227023;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1545310197;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot forecast because job [%s] is not open", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,is,not,open,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1547212955;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT,_                "Cannot forecast because job [%s] does not have a corresponding autodetect process", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,does,not,have,a,corresponding,autodetect,process,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1547224315;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT,_                "Cannot forecast because job [%s] does not have a corresponding autodetect process", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,does,not,have,a,corresponding,autodetect,process,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1547622613;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT,_                "Cannot forecast because job [%s] does not have a corresponding autodetect process", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,does,not,have,a,corresponding,autodetect,process,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1547743595;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT,_                "Cannot forecast because job [%s] does not have a corresponding autodetect process", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,does,not,have,a,corresponding,autodetect,process,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1547843554;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT,_                "Cannot forecast because job [%s] does not have a corresponding autodetect process", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,does,not,have,a,corresponding,autodetect,process,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1548236257;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT,_                "Cannot forecast because job [%s] does not have a corresponding autodetect process", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,does,not,have,a,corresponding,autodetect,process,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1548688050;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT,_                "Cannot forecast because job [%s] does not have a corresponding autodetect process", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,does,not,have,a,corresponding,autodetect,process,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1548774580;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT,_                "Cannot forecast because job [%s] does not have a corresponding autodetect process", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,does,not,have,a,corresponding,autodetect,process,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler);1548870984;Do a forecast for the running job.__@param jobTask   The job task_@param params    Forecast parameters;public void forecastJob(JobTask jobTask, ForecastParams params, Consumer<Exception> handler) {_        String jobId = jobTask.getJobId()__        logger.debug("Forecasting job {}", jobId)__        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT,_                "Cannot forecast because job [%s] does not have a corresponding autodetect process", jobId)__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }__        communicator.forecastJob(params, (aVoid, e) -> {_            if (e == null) {_                handler.accept(null)__            } else {_                String msg = String.format(Locale.ROOT, "[%s] exception while forecasting job", jobId)__                logger.error(msg, e)__                handler.accept(ExceptionsHelper.serverError(msg, e))__            }_        })__    };do,a,forecast,for,the,running,job,param,job,task,the,job,task,param,params,forecast,parameters;public,void,forecast,job,job,task,job,task,forecast,params,params,consumer,exception,handler,string,job,id,job,task,get,job,id,logger,debug,forecasting,job,job,id,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,forecast,because,job,s,does,not,have,a,corresponding,autodetect,process,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,forecast,job,params,a,void,e,if,e,null,handler,accept,null,else,string,msg,string,format,locale,root,s,exception,while,forecasting,job,job,id,logger,error,msg,e,handler,accept,exceptions,helper,server,error,msg,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1524684173;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1526900724;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1529076503;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1531179852;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1533230566;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1534338685;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1538067637;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1538424609;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1540583181;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1541008027;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1541092382;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1543343306;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1545155131;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1545227023;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1545310197;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1547212955;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot persist because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }_        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,persist,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1547224315;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot persist because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }_        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,persist,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1547622613;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot persist because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }_        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,persist,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1547743595;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot persist because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }_        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,persist,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1547843554;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot persist because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }_        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,persist,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1548236257;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot persist because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }_        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,persist,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1548688050;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot persist because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }_        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,persist,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1548774580;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot persist because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }_        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,persist,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public void persistJob(JobTask jobTask, Consumer<Exception> handler);1548870984;Initiate background persistence of the job_@param jobTask The job task_@param handler Listener;public void persistJob(JobTask jobTask, Consumer<Exception> handler) {_        AutodetectCommunicator communicator = getOpenAutodetectCommunicator(jobTask)__        if (communicator == null) {_            String message = String.format(Locale.ROOT, "Cannot persist because job [%s] does not have a corresponding autodetect process",_                jobTask.getJobId())__            logger.debug(message)__            handler.accept(ExceptionsHelper.conflictStatusException(message))__            return__        }_        communicator.persistJob((aVoid, e) -> handler.accept(e))__    };initiate,background,persistence,of,the,job,param,job,task,the,job,task,param,handler,listener;public,void,persist,job,job,task,job,task,consumer,exception,handler,autodetect,communicator,communicator,get,open,autodetect,communicator,job,task,if,communicator,null,string,message,string,format,locale,root,cannot,persist,because,job,s,does,not,have,a,corresponding,autodetect,process,job,task,get,job,id,logger,debug,message,handler,accept,exceptions,helper,conflict,status,exception,message,return,communicator,persist,job,a,void,e,handler,accept,e
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1526900724;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1529076503;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1531179852;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1533230566;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1534338685;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1538067637;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1538424609;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1540583181;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1541008027;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1541092382;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1543343306;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1545155131;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1545227023;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1545310197;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1547212955;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1547224315;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1547622613;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1547743595;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1547843554;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1548236257;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1548688050;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1548774580;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
AutodetectProcessManager -> public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize);1548870984;Request temporary storage to be used for the job__@param jobTask The job task_@param requestedSize requested size_@return a Path to local storage or null if storage is not available;public Path tryGetTmpStorage(JobTask jobTask, ByteSizeValue requestedSize) {_        String jobId = jobTask.getJobId()__        Path path = nativeTmpStorage.get(jobId)__        if (path == null) {_            path = nativeStorageProvider.tryGetLocalTmpStorage(jobId, requestedSize)__            if (path != null) {_                nativeTmpStorage.put(jobId, path)__            }_        } else if (!nativeStorageProvider.localTmpStorageHasEnoughSpace(path, requestedSize)) {_            _            return null__        }_        return path__    };request,temporary,storage,to,be,used,for,the,job,param,job,task,the,job,task,param,requested,size,requested,size,return,a,path,to,local,storage,or,null,if,storage,is,not,available;public,path,try,get,tmp,storage,job,task,job,task,byte,size,value,requested,size,string,job,id,job,task,get,job,id,path,path,native,tmp,storage,get,job,id,if,path,null,path,native,storage,provider,try,get,local,tmp,storage,job,id,requested,size,if,path,null,native,tmp,storage,put,job,id,path,else,if,native,storage,provider,local,tmp,storage,has,enough,space,path,requested,size,return,null,return,path
