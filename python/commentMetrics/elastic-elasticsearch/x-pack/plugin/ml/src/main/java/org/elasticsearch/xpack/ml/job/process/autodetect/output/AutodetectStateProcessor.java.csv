commented;modifiers;parameterAmount;loc;comment;code
false;public;1;26;;@Override public void process(InputStream in) throws IOException {     BytesReference bytesToDate = null.     List<BytesReference> newBlocks = new ArrayList<>().     byte[] readBuf = new byte[READ_BUF_SIZE].     int searchFrom = 0.     // eventually gets created.     for (int bytesRead = in.read(readBuf). bytesRead != -1. bytesRead = in.read(readBuf)) {         BytesArray newBlock = new BytesArray(readBuf, 0, bytesRead).         newBlocks.add(newBlock).         if (findNextZeroByte(newBlock, 0, 0) == -1) {             searchFrom += bytesRead.         } else {             BytesReference newBytes = new CompositeBytesReference(newBlocks.toArray(new BytesReference[0])).             bytesToDate = (bytesToDate == null) ? newBytes : new CompositeBytesReference(bytesToDate, newBytes).             bytesToDate = splitAndPersist(bytesToDate, searchFrom).             searchFrom = (bytesToDate == null) ? 0 : bytesToDate.length().             newBlocks.clear().         }         readBuf = new byte[READ_BUF_SIZE].     } }
true;private;2;20;/**  * Splits bulk data streamed from the C++ process on '\0' characters.  The  * data is expected to be a series of Elasticsearch bulk requests in UTF-8 JSON  * (as would be uploaded to the public REST API) separated by zero bytes ('\0').  */ ;/**  * Splits bulk data streamed from the C++ process on '\0' characters.  The  * data is expected to be a series of Elasticsearch bulk requests in UTF-8 JSON  * (as would be uploaded to the public REST API) separated by zero bytes ('\0').  */ private BytesReference splitAndPersist(BytesReference bytesRef, int searchFrom) throws IOException {     int splitFrom = 0.     while (true) {         int nextZeroByte = findNextZeroByte(bytesRef, searchFrom, splitFrom).         if (nextZeroByte == -1) {             // No more zero bytes in this block             break.         }         // Ignore completely empty chunks         if (nextZeroByte > splitFrom) {             // No validation - assume the native process has formatted the state correctly             persist(bytesRef.slice(splitFrom, nextZeroByte - splitFrom)).         }         splitFrom = nextZeroByte + 1.     }     if (splitFrom >= bytesRef.length()) {         return null.     }     return bytesRef.slice(splitFrom, bytesRef.length() - splitFrom). }
false;;1;10;;void persist(BytesReference bytes) throws IOException {     BulkRequest bulkRequest = new BulkRequest().     bulkRequest.add(bytes, AnomalyDetectorsIndex.jobStateIndexWriteAlias(), XContentType.JSON).     if (bulkRequest.numberOfActions() > 0) {         LOGGER.trace("[{}] Persisting job state document", jobId).         try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN)) {             client.bulk(bulkRequest).actionGet().         }     } }
false;private,static;3;8;;private static int findNextZeroByte(BytesReference bytesRef, int searchFrom, int splitFrom) {     for (int i = Math.max(searchFrom, splitFrom). i < bytesRef.length(). ++i) {         if (bytesRef.get(i) == 0) {             return i.         }     }     return -1. }
