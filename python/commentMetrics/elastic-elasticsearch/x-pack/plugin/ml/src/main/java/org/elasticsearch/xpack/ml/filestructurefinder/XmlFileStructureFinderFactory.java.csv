# id;timestamp;commentText;codeText;commentWords;codeWords
XmlFileStructureFinderFactory -> @Override     public boolean canCreateFromSample(List<String> explanation, String sample);1536314350;This format matches if the sample consists of one or more XML documents,_all with the same root element name.  If there is more than one document,_only whitespace is allowed in between them.  The last one does not_necessarily have to be complete (as the sample could have truncated it).;@Override_    public boolean canCreateFromSample(List<String> explanation, String sample) {__        int completeDocCount = 0__        String commonRootElementName = null__        String remainder = sample.trim()__        boolean mightBeAnotherDocument = !remainder.isEmpty()___        _        _        _        _        _        while (mightBeAnotherDocument) {__            try (Reader reader = new StringReader(remainder)) {__                XMLStreamReader xmlReader = xmlFactory.createXMLStreamReader(reader)__                try {_                    int nestingLevel = 0__                    while ((mightBeAnotherDocument = xmlReader.hasNext())) {_                        switch (xmlReader.next()) {_                            case XMLStreamReader.START_ELEMENT:_                                if (nestingLevel++ == 0) {_                                    String rootElementName = xmlReader.getLocalName()__                                    if (commonRootElementName == null) {_                                        commonRootElementName = rootElementName__                                    } else if (commonRootElementName.equals(rootElementName) == false) {_                                        explanation.add("Not XML because different documents have different root " +_                                            "element names: [" + commonRootElementName + "] and [" + rootElementName + "]")__                                        return false__                                    }_                                }_                                break__                            case XMLStreamReader.END_ELEMENT:_                                if (--nestingLevel < 0) {_                                    explanation.add("Not XML because an end element occurs before a start element")__                                    return false__                                }_                                break__                        }_                        if (nestingLevel == 0) {_                            ++completeDocCount__                            _                            _                            _                            Location location = xmlReader.getLocation()__                            int endPos = 0__                            _                            for (int wholeLines = location.getLineNumber() - 1_ wholeLines > 0_ --wholeLines) {_                                endPos = remainder.indexOf('\n', endPos) + 1__                                if (endPos == 0) {_                                    explanation.add("Not XML because XML parser location is inconsistent: line [" +_                                        location.getLineNumber() + "], column [" + location.getColumnNumber() + "] in [" + remainder + "]")__                                    return false__                                }_                            }_                            endPos += location.getColumnNumber() - 1__                            remainder = remainder.substring(endPos).trim()__                            mightBeAnotherDocument = !remainder.isEmpty()__                            break__                        }_                    }_                } finally {_                    xmlReader.close()__                }_            } catch (IOException | XMLStreamException e) {_                explanation.add("Not XML because there was a parsing exception: [" + e.getMessage().replaceAll("\\s?\r?\n\\s?", " ") + "]")__                return false__            }_        }__        if (completeDocCount == 0) {_            explanation.add("Not XML because sample didn't contain a complete document")__            return false__        }__        explanation.add("Deciding sample is XML")__        return true__    };this,format,matches,if,the,sample,consists,of,one,or,more,xml,documents,all,with,the,same,root,element,name,if,there,is,more,than,one,document,only,whitespace,is,allowed,in,between,them,the,last,one,does,not,necessarily,have,to,be,complete,as,the,sample,could,have,truncated,it;override,public,boolean,can,create,from,sample,list,string,explanation,string,sample,int,complete,doc,count,0,string,common,root,element,name,null,string,remainder,sample,trim,boolean,might,be,another,document,remainder,is,empty,while,might,be,another,document,try,reader,reader,new,string,reader,remainder,xmlstream,reader,xml,reader,xml,factory,create,xmlstream,reader,reader,try,int,nesting,level,0,while,might,be,another,document,xml,reader,has,next,switch,xml,reader,next,case,xmlstream,reader,if,nesting,level,0,string,root,element,name,xml,reader,get,local,name,if,common,root,element,name,null,common,root,element,name,root,element,name,else,if,common,root,element,name,equals,root,element,name,false,explanation,add,not,xml,because,different,documents,have,different,root,element,names,common,root,element,name,and,root,element,name,return,false,break,case,xmlstream,reader,if,nesting,level,0,explanation,add,not,xml,because,an,end,element,occurs,before,a,start,element,return,false,break,if,nesting,level,0,complete,doc,count,location,location,xml,reader,get,location,int,end,pos,0,for,int,whole,lines,location,get,line,number,1,whole,lines,0,whole,lines,end,pos,remainder,index,of,n,end,pos,1,if,end,pos,0,explanation,add,not,xml,because,xml,parser,location,is,inconsistent,line,location,get,line,number,column,location,get,column,number,in,remainder,return,false,end,pos,location,get,column,number,1,remainder,remainder,substring,end,pos,trim,might,be,another,document,remainder,is,empty,break,finally,xml,reader,close,catch,ioexception,xmlstream,exception,e,explanation,add,not,xml,because,there,was,a,parsing,exception,e,get,message,replace,all,s,r,n,s,return,false,if,complete,doc,count,0,explanation,add,not,xml,because,sample,didn,t,contain,a,complete,document,return,false,explanation,add,deciding,sample,is,xml,return,true
XmlFileStructureFinderFactory -> @Override     public boolean canCreateFromSample(List<String> explanation, String sample);1536964057;This format matches if the sample consists of one or more XML documents,_all with the same root element name.  If there is more than one document,_only whitespace is allowed in between them.  The last one does not_necessarily have to be complete (as the sample could have truncated it).;@Override_    public boolean canCreateFromSample(List<String> explanation, String sample) {__        int completeDocCount = 0__        String commonRootElementName = null__        String remainder = sample.trim()__        boolean mightBeAnotherDocument = !remainder.isEmpty()___        _        _        _        _        _        while (mightBeAnotherDocument) {__            try (Reader reader = new StringReader(remainder)) {__                XMLStreamReader xmlReader = xmlFactory.createXMLStreamReader(reader)__                try {_                    int nestingLevel = 0__                    while ((mightBeAnotherDocument = xmlReader.hasNext())) {_                        switch (xmlReader.next()) {_                            case XMLStreamReader.START_ELEMENT:_                                if (nestingLevel++ == 0) {_                                    String rootElementName = xmlReader.getLocalName()__                                    if (commonRootElementName == null) {_                                        commonRootElementName = rootElementName__                                    } else if (commonRootElementName.equals(rootElementName) == false) {_                                        explanation.add("Not XML because different documents have different root " +_                                            "element names: [" + commonRootElementName + "] and [" + rootElementName + "]")__                                        return false__                                    }_                                }_                                break__                            case XMLStreamReader.END_ELEMENT:_                                if (--nestingLevel < 0) {_                                    explanation.add("Not XML because an end element occurs before a start element")__                                    return false__                                }_                                break__                        }_                        if (nestingLevel == 0) {_                            ++completeDocCount__                            _                            _                            _                            Location location = xmlReader.getLocation()__                            int endPos = 0__                            _                            for (int wholeLines = location.getLineNumber() - 1_ wholeLines > 0_ --wholeLines) {_                                endPos = remainder.indexOf('\n', endPos) + 1__                                if (endPos == 0) {_                                    explanation.add("Not XML because XML parser location is inconsistent: line [" +_                                        location.getLineNumber() + "], column [" + location.getColumnNumber() + "] in [" + remainder + "]")__                                    return false__                                }_                            }_                            endPos += location.getColumnNumber() - 1__                            remainder = remainder.substring(endPos).trim()__                            mightBeAnotherDocument = !remainder.isEmpty()__                            break__                        }_                    }_                } finally {_                    xmlReader.close()__                }_            } catch (IOException | XMLStreamException e) {_                explanation.add("Not XML because there was a parsing exception: [" + e.getMessage().replaceAll("\\s?\r?\n\\s?", " ") + "]")__                return false__            }_        }__        if (completeDocCount == 0) {_            explanation.add("Not XML because sample didn't contain a complete document")__            return false__        }__        explanation.add("Deciding sample is XML")__        return true__    };this,format,matches,if,the,sample,consists,of,one,or,more,xml,documents,all,with,the,same,root,element,name,if,there,is,more,than,one,document,only,whitespace,is,allowed,in,between,them,the,last,one,does,not,necessarily,have,to,be,complete,as,the,sample,could,have,truncated,it;override,public,boolean,can,create,from,sample,list,string,explanation,string,sample,int,complete,doc,count,0,string,common,root,element,name,null,string,remainder,sample,trim,boolean,might,be,another,document,remainder,is,empty,while,might,be,another,document,try,reader,reader,new,string,reader,remainder,xmlstream,reader,xml,reader,xml,factory,create,xmlstream,reader,reader,try,int,nesting,level,0,while,might,be,another,document,xml,reader,has,next,switch,xml,reader,next,case,xmlstream,reader,if,nesting,level,0,string,root,element,name,xml,reader,get,local,name,if,common,root,element,name,null,common,root,element,name,root,element,name,else,if,common,root,element,name,equals,root,element,name,false,explanation,add,not,xml,because,different,documents,have,different,root,element,names,common,root,element,name,and,root,element,name,return,false,break,case,xmlstream,reader,if,nesting,level,0,explanation,add,not,xml,because,an,end,element,occurs,before,a,start,element,return,false,break,if,nesting,level,0,complete,doc,count,location,location,xml,reader,get,location,int,end,pos,0,for,int,whole,lines,location,get,line,number,1,whole,lines,0,whole,lines,end,pos,remainder,index,of,n,end,pos,1,if,end,pos,0,explanation,add,not,xml,because,xml,parser,location,is,inconsistent,line,location,get,line,number,column,location,get,column,number,in,remainder,return,false,end,pos,location,get,column,number,1,remainder,remainder,substring,end,pos,trim,might,be,another,document,remainder,is,empty,break,finally,xml,reader,close,catch,ioexception,xmlstream,exception,e,explanation,add,not,xml,because,there,was,a,parsing,exception,e,get,message,replace,all,s,r,n,s,return,false,if,complete,doc,count,0,explanation,add,not,xml,because,sample,didn,t,contain,a,complete,document,return,false,explanation,add,deciding,sample,is,xml,return,true
XmlFileStructureFinderFactory -> @Override     public boolean canCreateFromSample(List<String> explanation, String sample);1538170812;This format matches if the sample consists of one or more XML documents,_all with the same root element name.  If there is more than one document,_only whitespace is allowed in between them.  The last one does not_necessarily have to be complete (as the sample could have truncated it).;@Override_    public boolean canCreateFromSample(List<String> explanation, String sample) {__        int completeDocCount = 0__        String commonRootElementName = null__        String remainder = sample.trim()__        boolean mightBeAnotherDocument = !remainder.isEmpty()___        _        _        _        _        _        while (mightBeAnotherDocument) {__            try (Reader reader = new StringReader(remainder)) {__                XMLStreamReader xmlReader = xmlFactory.createXMLStreamReader(reader)__                try {_                    int nestingLevel = 0__                    while ((mightBeAnotherDocument = xmlReader.hasNext())) {_                        switch (xmlReader.next()) {_                            case XMLStreamReader.START_ELEMENT:_                                if (nestingLevel++ == 0) {_                                    String rootElementName = xmlReader.getLocalName()__                                    if (commonRootElementName == null) {_                                        commonRootElementName = rootElementName__                                    } else if (commonRootElementName.equals(rootElementName) == false) {_                                        explanation.add("Not XML because different documents have different root " +_                                            "element names: [" + commonRootElementName + "] and [" + rootElementName + "]")__                                        return false__                                    }_                                }_                                break__                            case XMLStreamReader.END_ELEMENT:_                                if (--nestingLevel < 0) {_                                    explanation.add("Not XML because an end element occurs before a start element")__                                    return false__                                }_                                break__                        }_                        if (nestingLevel == 0) {_                            ++completeDocCount__                            _                            _                            _                            Location location = xmlReader.getLocation()__                            int endPos = 0__                            _                            for (int wholeLines = location.getLineNumber() - 1_ wholeLines > 0_ --wholeLines) {_                                endPos = remainder.indexOf('\n', endPos) + 1__                                if (endPos == 0) {_                                    explanation.add("Not XML because XML parser location is inconsistent: line [" +_                                        location.getLineNumber() + "], column [" + location.getColumnNumber() + "] in [" + remainder + "]")__                                    return false__                                }_                            }_                            endPos += location.getColumnNumber() - 1__                            remainder = remainder.substring(endPos).trim()__                            mightBeAnotherDocument = !remainder.isEmpty()__                            break__                        }_                    }_                } finally {_                    xmlReader.close()__                }_            } catch (IOException | XMLStreamException e) {_                explanation.add("Not XML because there was a parsing exception: [" + e.getMessage().replaceAll("\\s?\r?\n\\s?", " ") + "]")__                return false__            }_        }__        if (completeDocCount == 0) {_            explanation.add("Not XML because sample didn't contain a complete document")__            return false__        }__        explanation.add("Deciding sample is XML")__        return true__    };this,format,matches,if,the,sample,consists,of,one,or,more,xml,documents,all,with,the,same,root,element,name,if,there,is,more,than,one,document,only,whitespace,is,allowed,in,between,them,the,last,one,does,not,necessarily,have,to,be,complete,as,the,sample,could,have,truncated,it;override,public,boolean,can,create,from,sample,list,string,explanation,string,sample,int,complete,doc,count,0,string,common,root,element,name,null,string,remainder,sample,trim,boolean,might,be,another,document,remainder,is,empty,while,might,be,another,document,try,reader,reader,new,string,reader,remainder,xmlstream,reader,xml,reader,xml,factory,create,xmlstream,reader,reader,try,int,nesting,level,0,while,might,be,another,document,xml,reader,has,next,switch,xml,reader,next,case,xmlstream,reader,if,nesting,level,0,string,root,element,name,xml,reader,get,local,name,if,common,root,element,name,null,common,root,element,name,root,element,name,else,if,common,root,element,name,equals,root,element,name,false,explanation,add,not,xml,because,different,documents,have,different,root,element,names,common,root,element,name,and,root,element,name,return,false,break,case,xmlstream,reader,if,nesting,level,0,explanation,add,not,xml,because,an,end,element,occurs,before,a,start,element,return,false,break,if,nesting,level,0,complete,doc,count,location,location,xml,reader,get,location,int,end,pos,0,for,int,whole,lines,location,get,line,number,1,whole,lines,0,whole,lines,end,pos,remainder,index,of,n,end,pos,1,if,end,pos,0,explanation,add,not,xml,because,xml,parser,location,is,inconsistent,line,location,get,line,number,column,location,get,column,number,in,remainder,return,false,end,pos,location,get,column,number,1,remainder,remainder,substring,end,pos,trim,might,be,another,document,remainder,is,empty,break,finally,xml,reader,close,catch,ioexception,xmlstream,exception,e,explanation,add,not,xml,because,there,was,a,parsing,exception,e,get,message,replace,all,s,r,n,s,return,false,if,complete,doc,count,0,explanation,add,not,xml,because,sample,didn,t,contain,a,complete,document,return,false,explanation,add,deciding,sample,is,xml,return,true
XmlFileStructureFinderFactory -> @Override     public boolean canCreateFromSample(List<String> explanation, String sample);1543323172;This format matches if the sample consists of one or more XML documents,_all with the same root element name.  If there is more than one document,_only whitespace is allowed in between them.  The last one does not_necessarily have to be complete (as the sample could have truncated it).;@Override_    public boolean canCreateFromSample(List<String> explanation, String sample) {__        int completeDocCount = 0__        String commonRootElementName = null__        String remainder = sample.trim()__        boolean mightBeAnotherDocument = !remainder.isEmpty()___        _        _        _        _        _        while (mightBeAnotherDocument) {__            try (Reader reader = new StringReader(remainder)) {__                XMLStreamReader xmlReader = xmlFactory.createXMLStreamReader(reader)__                try {_                    int nestingLevel = 0__                    while ((mightBeAnotherDocument = xmlReader.hasNext())) {_                        switch (xmlReader.next()) {_                            case XMLStreamReader.START_ELEMENT:_                                if (nestingLevel++ == 0) {_                                    String rootElementName = xmlReader.getLocalName()__                                    if (commonRootElementName == null) {_                                        commonRootElementName = rootElementName__                                    } else if (commonRootElementName.equals(rootElementName) == false) {_                                        explanation.add("Not XML because different documents have different root " +_                                            "element names: [" + commonRootElementName + "] and [" + rootElementName + "]")__                                        return false__                                    }_                                }_                                break__                            case XMLStreamReader.END_ELEMENT:_                                if (--nestingLevel < 0) {_                                    explanation.add("Not XML because an end element occurs before a start element")__                                    return false__                                }_                                break__                        }_                        if (nestingLevel == 0) {_                            ++completeDocCount__                            _                            _                            _                            Location location = xmlReader.getLocation()__                            int endPos = 0__                            _                            for (int wholeLines = location.getLineNumber() - 1_ wholeLines > 0_ --wholeLines) {_                                endPos = remainder.indexOf('\n', endPos) + 1__                                if (endPos == 0) {_                                    explanation.add("Not XML because XML parser location is inconsistent: line [" +_                                        location.getLineNumber() + "], column [" + location.getColumnNumber() + "] in [" + remainder + "]")__                                    return false__                                }_                            }_                            endPos += location.getColumnNumber() - 1__                            remainder = remainder.substring(endPos).trim()__                            mightBeAnotherDocument = !remainder.isEmpty()__                            break__                        }_                    }_                } finally {_                    xmlReader.close()__                }_            } catch (IOException | XMLStreamException e) {_                explanation.add("Not XML because there was a parsing exception: [" + e.getMessage().replaceAll("\\s?\r?\n\\s?", " ") + "]")__                return false__            }_        }__        if (completeDocCount == 0) {_            explanation.add("Not XML because sample didn't contain a complete document")__            return false__        }__        explanation.add("Deciding sample is XML")__        return true__    };this,format,matches,if,the,sample,consists,of,one,or,more,xml,documents,all,with,the,same,root,element,name,if,there,is,more,than,one,document,only,whitespace,is,allowed,in,between,them,the,last,one,does,not,necessarily,have,to,be,complete,as,the,sample,could,have,truncated,it;override,public,boolean,can,create,from,sample,list,string,explanation,string,sample,int,complete,doc,count,0,string,common,root,element,name,null,string,remainder,sample,trim,boolean,might,be,another,document,remainder,is,empty,while,might,be,another,document,try,reader,reader,new,string,reader,remainder,xmlstream,reader,xml,reader,xml,factory,create,xmlstream,reader,reader,try,int,nesting,level,0,while,might,be,another,document,xml,reader,has,next,switch,xml,reader,next,case,xmlstream,reader,if,nesting,level,0,string,root,element,name,xml,reader,get,local,name,if,common,root,element,name,null,common,root,element,name,root,element,name,else,if,common,root,element,name,equals,root,element,name,false,explanation,add,not,xml,because,different,documents,have,different,root,element,names,common,root,element,name,and,root,element,name,return,false,break,case,xmlstream,reader,if,nesting,level,0,explanation,add,not,xml,because,an,end,element,occurs,before,a,start,element,return,false,break,if,nesting,level,0,complete,doc,count,location,location,xml,reader,get,location,int,end,pos,0,for,int,whole,lines,location,get,line,number,1,whole,lines,0,whole,lines,end,pos,remainder,index,of,n,end,pos,1,if,end,pos,0,explanation,add,not,xml,because,xml,parser,location,is,inconsistent,line,location,get,line,number,column,location,get,column,number,in,remainder,return,false,end,pos,location,get,column,number,1,remainder,remainder,substring,end,pos,trim,might,be,another,document,remainder,is,empty,break,finally,xml,reader,close,catch,ioexception,xmlstream,exception,e,explanation,add,not,xml,because,there,was,a,parsing,exception,e,get,message,replace,all,s,r,n,s,return,false,if,complete,doc,count,0,explanation,add,not,xml,because,sample,didn,t,contain,a,complete,document,return,false,explanation,add,deciding,sample,is,xml,return,true
