commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected AcknowledgedResponse newResponse() {     return new AcknowledgedResponse(). }
false;protected;3;33;;@Override protected void masterOperation(FinalizeJobExecutionAction.Request request, ClusterState state, ActionListener<AcknowledgedResponse> listener) {     String jobIdString = String.join(",", request.getJobIds()).     logger.debug("finalizing jobs [{}]", jobIdString).     VoidChainTaskExecutor voidChainTaskExecutor = new VoidChainTaskExecutor(threadPool.executor(MachineLearning.UTILITY_THREAD_POOL_NAME), true).     Map<String, Object> update = Collections.singletonMap(Job.FINISHED_TIME.getPreferredName(), new Date()).     for (String jobId : request.getJobIds()) {         UpdateRequest updateRequest = new UpdateRequest(AnomalyDetectorsIndex.configIndexName(), Job.documentId(jobId)).         updateRequest.retryOnConflict(3).         updateRequest.doc(update).         updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).         voidChainTaskExecutor.add(chainedListener -> {             executeAsyncWithOrigin(client, ML_ORIGIN, UpdateAction.INSTANCE, updateRequest, ActionListener.wrap(updateResponse -> chainedListener.onResponse(null), chainedListener::onFailure)).         }).     }     voidChainTaskExecutor.execute(ActionListener.wrap(aVoids -> {         logger.debug("finalized job [{}]", jobIdString).         listener.onResponse(new AcknowledgedResponse(true)).     }, listener::onFailure)). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(FinalizeJobExecutionAction.Request request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
