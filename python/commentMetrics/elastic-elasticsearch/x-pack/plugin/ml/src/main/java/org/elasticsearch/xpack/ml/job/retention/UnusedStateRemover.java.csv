commented;modifiers;parameterAmount;loc;comment;code
false;public;1;13;;@Override public void remove(ActionListener<Boolean> listener) {     try {         List<String> unusedStateDocIds = findUnusedStateDocIds().         if (unusedStateDocIds.size() > 0) {             executeDeleteUnusedStateDocs(unusedStateDocIds, listener).         } else {             listener.onResponse(true).         }     } catch (Exception e) {         listener.onFailure(e).     } }
false;private;0;20;;private List<String> findUnusedStateDocIds() {     Set<String> jobIds = getJobIds().     List<String> stateDocIdsToDelete = new ArrayList<>().     BatchedStateDocIdsIterator stateDocIdsIterator = new BatchedStateDocIdsIterator(client, AnomalyDetectorsIndex.jobStateIndexPattern()).     while (stateDocIdsIterator.hasNext()) {         Deque<String> stateDocIds = stateDocIdsIterator.next().         for (String stateDocId : stateDocIds) {             String jobId = JobIdExtractor.extractJobId(stateDocId).             if (jobId == null) {                 // not a managed state document id                 continue.             }             if (jobIds.contains(jobId) == false) {                 stateDocIdsToDelete.add(stateDocId).             }         }     }     return stateDocIdsToDelete. }
false;private;0;14;;private Set<String> getJobIds() {     Set<String> jobIds = new HashSet<>().     // TODO Once at 8.0, we can stop searching for jobs in cluster state     // and remove cluster service as a member all together.     jobIds.addAll(MlMetadata.getMlMetadata(clusterService.state()).getJobs().keySet()).     BatchedJobsIterator jobsIterator = new BatchedJobsIterator(client, AnomalyDetectorsIndex.configIndexName()).     while (jobsIterator.hasNext()) {         Deque<Job.Builder> jobs = jobsIterator.next().         jobs.stream().map(Job.Builder::getId).forEach(jobIds::add).     }     return jobIds. }
false;private;2;23;;private void executeDeleteUnusedStateDocs(List<String> unusedDocIds, ActionListener<Boolean> listener) {     LOGGER.info("Found [{}] unused state documents. attempting to delete", unusedDocIds.size()).     DeleteByQueryRequest deleteByQueryRequest = new DeleteByQueryRequest(AnomalyDetectorsIndex.jobStateIndexPattern()).setIndicesOptions(IndicesOptions.lenientExpandOpen()).setQuery(QueryBuilders.idsQuery().addIds(unusedDocIds.toArray(new String[0]))).     client.execute(DeleteByQueryAction.INSTANCE, deleteByQueryRequest, ActionListener.wrap(response -> {         if (response.getBulkFailures().size() > 0 || response.getSearchFailures().size() > 0) {             LOGGER.error("Some unused state documents could not be deleted due to failures: {}", Strings.collectionToCommaDelimitedString(response.getBulkFailures()) + "," + Strings.collectionToCommaDelimitedString(response.getSearchFailures())).         } else {             LOGGER.info("Successfully deleted all unused state documents").         }         listener.onResponse(true).     }, e -> {         LOGGER.error("Error deleting unused model state documents: ", e).         listener.onFailure(e).     })). }
false;private,static;1;10;;private static String extractJobId(String docId) {     String jobId.     for (Function<String, String> extractor : extractors) {         jobId = extractor.apply(docId).         if (jobId != null) {             return jobId.         }     }     return null. }
