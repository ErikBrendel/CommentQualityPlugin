commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;public void checkDatafeedTaskCanBeCreated() {     if (MlMetadata.getMlMetadata(clusterState).isUpgradeMode()) {         String msg = "Unable to start datafeed [" + datafeedId + "] explanation [" + AWAITING_UPGRADE.getExplanation() + "]".         LOGGER.debug(msg).         Exception detail = new IllegalStateException(msg).         throw new ElasticsearchStatusException("Could not start datafeed [" + datafeedId + "] as indices are being upgraded", RestStatus.TOO_MANY_REQUESTS, detail).     }     AssignmentFailure assignmentFailure = checkAssignment().     if (assignmentFailure != null && assignmentFailure.isCriticalForTaskCreation) {         String msg = "No node found to start datafeed [" + datafeedId + "], " + "allocation explanation [" + assignmentFailure.reason + "]".         LOGGER.debug(msg).         throw ExceptionsHelper.conflictStatusException(msg).     } }
false;public;0;12;;public PersistentTasksCustomMetaData.Assignment selectNode() {     if (MlMetadata.getMlMetadata(clusterState).isUpgradeMode()) {         return AWAITING_UPGRADE.     }     AssignmentFailure assignmentFailure = checkAssignment().     if (assignmentFailure == null) {         return new PersistentTasksCustomMetaData.Assignment(jobTask.getExecutorNode(), "").     }     LOGGER.debug(assignmentFailure.reason).     return new PersistentTasksCustomMetaData.Assignment(null, assignmentFailure.reason). }
false;private;0;27;;@Nullable private AssignmentFailure checkAssignment() {     PriorityFailureCollector priorityFailureCollector = new PriorityFailureCollector().     priorityFailureCollector.add(verifyIndicesActive()).     JobTaskState jobTaskState = null.     JobState jobState = JobState.CLOSED.     if (jobTask != null) {         jobTaskState = (JobTaskState) jobTask.getState().         jobState = jobTaskState == null ? JobState.OPENING : jobTaskState.getState().     }     if (jobState.isAnyOf(JobState.OPENING, JobState.OPENED) == false) {         // lets try again later when the job has been opened:         String reason = "cannot start datafeed [" + datafeedId + "], because the job's [" + jobId + "] state is [" + jobState + "] while state [" + JobState.OPENED + "] is required".         priorityFailureCollector.add(new AssignmentFailure(reason, true)).     }     if (jobTaskState != null && jobTaskState.isStatusStale(jobTask)) {         String reason = "cannot start datafeed [" + datafeedId + "], because the job's [" + jobId + "] state is stale".         priorityFailureCollector.add(new AssignmentFailure(reason, true)).     }     return priorityFailureCollector.get(). }
false;private;0;34;;@Nullable private AssignmentFailure verifyIndicesActive() {     for (String index : datafeedIndices) {         if (RemoteClusterLicenseChecker.isRemoteIndex(index)) {             // We cannot verify remote indices             continue.         }         String[] concreteIndices.         String reason = "cannot start datafeed [" + datafeedId + "] because index [" + index + "] does not exist, is closed, or is still initializing.".         try {             concreteIndices = resolver.concreteIndexNames(clusterState, IndicesOptions.lenientExpandOpen(), index).             if (concreteIndices.length == 0) {                 return new AssignmentFailure(reason, true).             }         } catch (Exception e) {             LOGGER.debug(reason, e).             return new AssignmentFailure(reason, true).         }         for (String concreteIndex : concreteIndices) {             IndexRoutingTable routingTable = clusterState.getRoutingTable().index(concreteIndex).             if (routingTable == null || !routingTable.allPrimaryShardsActive()) {                 reason = "cannot start datafeed [" + datafeedId + "] because index [" + concreteIndex + "] does not have all primary shards active yet.".                 return new AssignmentFailure(reason, false).             }         }     }     return null. }
false;private;1;8;;private void add(@Nullable AssignmentFailure newFailure) {     if (newFailure == null) {         return.     }     if (failure == null || (failure.isCriticalForTaskCreation == false && newFailure.isCriticalForTaskCreation)) {         failure = newFailure.     } }
false;private;0;4;;@Nullable private AssignmentFailure get() {     return failure. }
