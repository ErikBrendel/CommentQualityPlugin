commented;modifiers;parameterAmount;loc;comment;code
true;public;3;39;/**  * Persist the datafeed configuration to the config index.  * It is an error if a datafeed with the same Id already exists -  * the config will not be overwritten.  *  * @param config The datafeed configuration  * @param listener Index response listener  */ ;/**  * Persist the datafeed configuration to the config index.  * It is an error if a datafeed with the same Id already exists -  * the config will not be overwritten.  *  * @param config The datafeed configuration  * @param listener Index response listener  */ public void putDatafeedConfig(DatafeedConfig config, Map<String, String> headers, ActionListener<IndexResponse> listener) {     if (headers.isEmpty() == false) {         // Filter any values in headers that aren't security fields         DatafeedConfig.Builder builder = new DatafeedConfig.Builder(config).         Map<String, String> securityHeaders = headers.entrySet().stream().filter(e -> ClientHelper.SECURITY_HEADER_FILTERS.contains(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).         builder.setHeaders(securityHeaders).         config = builder.build().     }     final String datafeedId = config.getId().     try (XContentBuilder builder = XContentFactory.jsonBuilder()) {         XContentBuilder source = config.toXContent(builder, new ToXContent.MapParams(TO_XCONTENT_PARAMS)).         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorsIndex.configIndexName()).id(DatafeedConfig.documentId(datafeedId)).source(source).opType(DocWriteRequest.OpType.CREATE).setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).         executeAsyncWithOrigin(client, ML_ORIGIN, IndexAction.INSTANCE, indexRequest, ActionListener.wrap(listener::onResponse, e -> {             if (e instanceof VersionConflictEngineException) {                 // the dafafeed already exists                 listener.onFailure(ExceptionsHelper.datafeedAlreadyExists(datafeedId)).             } else {                 listener.onFailure(e).             }         })).     } catch (IOException e) {         listener.onFailure(new ElasticsearchParseException("Failed to serialise datafeed config with id [" + config.getId() + "]", e)).     } }
false;public;1;9;;@Override public void onResponse(GetResponse getResponse) {     if (getResponse.isExists() == false) {         datafeedConfigListener.onFailure(ExceptionsHelper.missingDatafeedException(datafeedId)).         return.     }     BytesReference source = getResponse.getSourceAsBytesRef().     parseLenientlyFromSource(source, datafeedConfigListener). }
false;public;1;8;;@Override public void onFailure(Exception e) {     if (e.getClass() == IndexNotFoundException.class) {         datafeedConfigListener.onFailure(ExceptionsHelper.missingDatafeedException(datafeedId)).     } else {         datafeedConfigListener.onFailure(e).     } }
true;public;2;22;/**  * Get the datafeed config specified by {@code datafeedId}.  * If the datafeed document is missing a {@code ResourceNotFoundException}  * is returned via the listener.  *  * If the .ml-config index does not exist it is treated as a missing datafeed  * error.  *  * @param datafeedId The datafeed ID  * @param datafeedConfigListener The config listener  */ ;/**  * Get the datafeed config specified by {@code datafeedId}.  * If the datafeed document is missing a {@code ResourceNotFoundException}  * is returned via the listener.  *  * If the .ml-config index does not exist it is treated as a missing datafeed  * error.  *  * @param datafeedId The datafeed ID  * @param datafeedConfigListener The config listener  */ public void getDatafeedConfig(String datafeedId, ActionListener<DatafeedConfig.Builder> datafeedConfigListener) {     GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(), DatafeedConfig.documentId(datafeedId)).     executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {          @Override         public void onResponse(GetResponse getResponse) {             if (getResponse.isExists() == false) {                 datafeedConfigListener.onFailure(ExceptionsHelper.missingDatafeedException(datafeedId)).                 return.             }             BytesReference source = getResponse.getSourceAsBytesRef().             parseLenientlyFromSource(source, datafeedConfigListener).         }          @Override         public void onFailure(Exception e) {             if (e.getClass() == IndexNotFoundException.class) {                 datafeedConfigListener.onFailure(ExceptionsHelper.missingDatafeedException(datafeedId)).             } else {                 datafeedConfigListener.onFailure(e).             }         }     }). }
true;public;2;27;/**  * Find any datafeeds that are used by jobs {@code jobIds} i.e. the  * datafeeds that references any of the jobs in {@code jobIds}.  *  * In theory there should never be more than one datafeed referencing a  * particular job.  *  * @param jobIds    The jobs to find the datafeeds of  * @param listener  Datafeed Id listener  */ ;/**  * Find any datafeeds that are used by jobs {@code jobIds} i.e. the  * datafeeds that references any of the jobs in {@code jobIds}.  *  * In theory there should never be more than one datafeed referencing a  * particular job.  *  * @param jobIds    The jobs to find the datafeeds of  * @param listener  Datafeed Id listener  */ public void findDatafeedsForJobIds(Collection<String> jobIds, ActionListener<Set<String>> listener) {     SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildDatafeedJobIdsQuery(jobIds)).     sourceBuilder.fetchSource(false).     sourceBuilder.docValueField(DatafeedConfig.ID.getPreferredName(), null).     SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName()).setIndicesOptions(IndicesOptions.lenientExpandOpen()).setSize(jobIds.size()).setSource(sourceBuilder).request().     executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest, ActionListener.<SearchResponse>wrap(response -> {         Set<String> datafeedIds = new HashSet<>().         // There cannot be more than one datafeed per job         assert response.getHits().getTotalHits().value <= jobIds.size().         SearchHit[] hits = response.getHits().getHits().         for (SearchHit hit : hits) {             datafeedIds.add(hit.field(DatafeedConfig.ID.getPreferredName()).getValue()).         }         listener.onResponse(datafeedIds).     }, listener::onFailure), client::search). }
false;public;1;9;;@Override public void onResponse(DeleteResponse deleteResponse) {     if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {         actionListener.onFailure(ExceptionsHelper.missingDatafeedException(datafeedId)).         return.     }     assert deleteResponse.getResult() == DocWriteResponse.Result.DELETED.     actionListener.onResponse(deleteResponse). }
false;public;1;4;;@Override public void onFailure(Exception e) {     actionListener.onFailure(e). }
true;public;2;19;/**  * Delete the datafeed config document  *  * @param datafeedId The datafeed id  * @param actionListener Deleted datafeed listener  */ ;/**  * Delete the datafeed config document  *  * @param datafeedId The datafeed id  * @param actionListener Deleted datafeed listener  */ public void deleteDatafeedConfig(String datafeedId, ActionListener<DeleteResponse> actionListener) {     DeleteRequest request = new DeleteRequest(AnomalyDetectorsIndex.configIndexName(), DatafeedConfig.documentId(datafeedId)).     request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     executeAsyncWithOrigin(client, ML_ORIGIN, DeleteAction.INSTANCE, request, new ActionListener<DeleteResponse>() {          @Override         public void onResponse(DeleteResponse deleteResponse) {             if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {                 actionListener.onFailure(ExceptionsHelper.missingDatafeedException(datafeedId)).                 return.             }             assert deleteResponse.getResult() == DocWriteResponse.Result.DELETED.             actionListener.onResponse(deleteResponse).         }          @Override         public void onFailure(Exception e) {             actionListener.onFailure(e).         }     }). }
false;public;1;41;;@Override public void onResponse(GetResponse getResponse) {     if (getResponse.isExists() == false) {         updatedConfigListener.onFailure(ExceptionsHelper.missingDatafeedException(datafeedId)).         return.     }     final long version = getResponse.getVersion().     final long seqNo = getResponse.getSeqNo().     final long primaryTerm = getResponse.getPrimaryTerm().     BytesReference source = getResponse.getSourceAsBytesRef().     DatafeedConfig.Builder configBuilder.     try {         configBuilder = parseLenientlyFromSource(source).     } catch (IOException e) {         updatedConfigListener.onFailure(new ElasticsearchParseException("Failed to parse datafeed config [" + datafeedId + "]", e)).         return.     }     DatafeedConfig updatedConfig.     try {         updatedConfig = update.apply(configBuilder.build(), headers).     } catch (Exception e) {         updatedConfigListener.onFailure(e).         return.     }     ActionListener<Boolean> validatedListener = ActionListener.wrap(ok -> {         indexUpdatedConfig(updatedConfig, seqNo, primaryTerm, ActionListener.wrap(indexResponse -> {             assert indexResponse.getResult() == DocWriteResponse.Result.UPDATED.             updatedConfigListener.onResponse(updatedConfig).         }, updatedConfigListener::onFailure)).     }, updatedConfigListener::onFailure).     validator.accept(updatedConfig, validatedListener). }
false;public;1;4;;@Override public void onFailure(Exception e) {     updatedConfigListener.onFailure(e). }
true;public;5;54;/**  * Get the datafeed config and apply the {@code update}  * then index the modified config setting the version in the request.  *  * The {@code validator} consumer can be used to perform extra validation  * but it must call the passed ActionListener. For example a no-op validator  * would be {@code (updatedConfig, listener) -> listener.onResponse(Boolean.TRUE)}  *  * @param datafeedId The Id of the datafeed to update  * @param update The update  * @param headers Datafeed headers applied with the update  * @param validator BiConsumer that accepts the updated config and can perform  *                  extra validations. {@code validator} must call the passed listener  * @param updatedConfigListener Updated datafeed config listener  */ ;/**  * Get the datafeed config and apply the {@code update}  * then index the modified config setting the version in the request.  *  * The {@code validator} consumer can be used to perform extra validation  * but it must call the passed ActionListener. For example a no-op validator  * would be {@code (updatedConfig, listener) -> listener.onResponse(Boolean.TRUE)}  *  * @param datafeedId The Id of the datafeed to update  * @param update The update  * @param headers Datafeed headers applied with the update  * @param validator BiConsumer that accepts the updated config and can perform  *                  extra validations. {@code validator} must call the passed listener  * @param updatedConfigListener Updated datafeed config listener  */ public void updateDatefeedConfig(String datafeedId, DatafeedUpdate update, Map<String, String> headers, BiConsumer<DatafeedConfig, ActionListener<Boolean>> validator, ActionListener<DatafeedConfig> updatedConfigListener) {     GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(), DatafeedConfig.documentId(datafeedId)).     executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {          @Override         public void onResponse(GetResponse getResponse) {             if (getResponse.isExists() == false) {                 updatedConfigListener.onFailure(ExceptionsHelper.missingDatafeedException(datafeedId)).                 return.             }             final long version = getResponse.getVersion().             final long seqNo = getResponse.getSeqNo().             final long primaryTerm = getResponse.getPrimaryTerm().             BytesReference source = getResponse.getSourceAsBytesRef().             DatafeedConfig.Builder configBuilder.             try {                 configBuilder = parseLenientlyFromSource(source).             } catch (IOException e) {                 updatedConfigListener.onFailure(new ElasticsearchParseException("Failed to parse datafeed config [" + datafeedId + "]", e)).                 return.             }             DatafeedConfig updatedConfig.             try {                 updatedConfig = update.apply(configBuilder.build(), headers).             } catch (Exception e) {                 updatedConfigListener.onFailure(e).                 return.             }             ActionListener<Boolean> validatedListener = ActionListener.wrap(ok -> {                 indexUpdatedConfig(updatedConfig, seqNo, primaryTerm, ActionListener.wrap(indexResponse -> {                     assert indexResponse.getResult() == DocWriteResponse.Result.UPDATED.                     updatedConfigListener.onResponse(updatedConfig).                 }, updatedConfigListener::onFailure)).             }, updatedConfigListener::onFailure).             validator.accept(updatedConfig, validatedListener).         }          @Override         public void onFailure(Exception e) {             updatedConfigListener.onFailure(e).         }     }). }
false;private;4;19;;private void indexUpdatedConfig(DatafeedConfig updatedConfig, long seqNo, long primaryTerm, ActionListener<IndexResponse> listener) {     try (XContentBuilder builder = XContentFactory.jsonBuilder()) {         XContentBuilder updatedSource = updatedConfig.toXContent(builder, new ToXContent.MapParams(TO_XCONTENT_PARAMS)).         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorsIndex.configIndexName()).id(DatafeedConfig.documentId(updatedConfig.getId())).source(updatedSource).setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).         indexRequest.setIfSeqNo(seqNo).         indexRequest.setIfPrimaryTerm(primaryTerm).         executeAsyncWithOrigin(client, ML_ORIGIN, IndexAction.INSTANCE, indexRequest, listener).     } catch (IOException e) {         listener.onFailure(new ElasticsearchParseException("Failed to serialise datafeed config with id [" + updatedConfig.getId() + "]", e)).     } }
true;public;3;37;/**  * Expands an expression into the set of matching names. {@code expresssion}  * may be a wildcard, a datafeed ID or a list of those.  * If {@code expression} == 'ALL', '*' or the empty string then all  * datafeed IDs are returned.  *  * For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],  * expressions resolve follows:  * <ul>  *     <li>"foo-1" : ["foo-1"]</li>  *     <li>"bar-1" : ["bar-1"]</li>  *     <li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>  *     <li>"foo-*" : ["foo-1", "foo-2"]</li>  *     <li>"*-1" : ["bar-1", "foo-1"]</li>  *     <li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>  *     <li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>  * </ul>  *  * @param expression the expression to resolve  * @param allowNoDatafeeds if {@code false}, an error is thrown when no name matches the {@code expression}.  *                     This only applies to wild card expressions, if {@code expression} is not a  *                     wildcard then setting this true will not suppress the exception  * @param listener The expanded datafeed IDs listener  */ ;/**  * Expands an expression into the set of matching names. {@code expresssion}  * may be a wildcard, a datafeed ID or a list of those.  * If {@code expression} == 'ALL', '*' or the empty string then all  * datafeed IDs are returned.  *  * For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],  * expressions resolve follows:  * <ul>  *     <li>"foo-1" : ["foo-1"]</li>  *     <li>"bar-1" : ["bar-1"]</li>  *     <li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>  *     <li>"foo-*" : ["foo-1", "foo-2"]</li>  *     <li>"*-1" : ["bar-1", "foo-1"]</li>  *     <li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>  *     <li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>  * </ul>  *  * @param expression the expression to resolve  * @param allowNoDatafeeds if {@code false}, an error is thrown when no name matches the {@code expression}.  *                     This only applies to wild card expressions, if {@code expression} is not a  *                     wildcard then setting this true will not suppress the exception  * @param listener The expanded datafeed IDs listener  */ public void expandDatafeedIds(String expression, boolean allowNoDatafeeds, ActionListener<SortedSet<String>> listener) {     String[] tokens = ExpandedIdsMatcher.tokenizeExpression(expression).     SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildDatafeedIdQuery(tokens)).     sourceBuilder.sort(DatafeedConfig.ID.getPreferredName()).     sourceBuilder.fetchSource(false).     sourceBuilder.docValueField(DatafeedConfig.ID.getPreferredName(), null).     SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName()).setIndicesOptions(IndicesOptions.lenientExpandOpen()).setSource(sourceBuilder).setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW).request().     ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoDatafeeds).     executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest, ActionListener.<SearchResponse>wrap(response -> {         SortedSet<String> datafeedIds = new TreeSet<>().         SearchHit[] hits = response.getHits().getHits().         for (SearchHit hit : hits) {             datafeedIds.add(hit.field(DatafeedConfig.ID.getPreferredName()).getValue()).         }         requiredMatches.filterMatchedIds(datafeedIds).         if (requiredMatches.hasUnmatchedIds()) {             // some required datafeeds were not found             listener.onFailure(ExceptionsHelper.missingDatafeedException(requiredMatches.unmatchedIdsString())).             return.         }         listener.onResponse(datafeedIds).     }, listener::onFailure), client::search). }
true;public;3;44;/**  * The same logic as {@link #expandDatafeedIds(String, boolean, ActionListener)} but  * the full datafeed configuration is returned.  *  * See {@link #expandDatafeedIds(String, boolean, ActionListener)}  *  * @param expression the expression to resolve  * @param allowNoDatafeeds if {@code false}, an error is thrown when no name matches the {@code expression}.  *                     This only applies to wild card expressions, if {@code expression} is not a  *                     wildcard then setting this true will not suppress the exception  * @param listener The expanded datafeed config listener  */ ;/**  * The same logic as {@link #expandDatafeedIds(String, boolean, ActionListener)} but  * the full datafeed configuration is returned.  *  * See {@link #expandDatafeedIds(String, boolean, ActionListener)}  *  * @param expression the expression to resolve  * @param allowNoDatafeeds if {@code false}, an error is thrown when no name matches the {@code expression}.  *                     This only applies to wild card expressions, if {@code expression} is not a  *                     wildcard then setting this true will not suppress the exception  * @param listener The expanded datafeed config listener  */ public void expandDatafeedConfigs(String expression, boolean allowNoDatafeeds, ActionListener<List<DatafeedConfig.Builder>> listener) {     String[] tokens = ExpandedIdsMatcher.tokenizeExpression(expression).     SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildDatafeedIdQuery(tokens)).     sourceBuilder.sort(DatafeedConfig.ID.getPreferredName()).     SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName()).setIndicesOptions(IndicesOptions.lenientExpandOpen()).setSource(sourceBuilder).setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW).request().     ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoDatafeeds).     executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest, ActionListener.<SearchResponse>wrap(response -> {         List<DatafeedConfig.Builder> datafeeds = new ArrayList<>().         Set<String> datafeedIds = new HashSet<>().         SearchHit[] hits = response.getHits().getHits().         for (SearchHit hit : hits) {             try {                 BytesReference source = hit.getSourceRef().                 DatafeedConfig.Builder datafeed = parseLenientlyFromSource(source).                 datafeeds.add(datafeed).                 datafeedIds.add(datafeed.getId()).             } catch (IOException e) {                 // TODO A better way to handle this rather than just ignoring the error?                 logger.error("Error parsing datafeed configuration [" + hit.getId() + "]", e).             }         }         requiredMatches.filterMatchedIds(datafeedIds).         if (requiredMatches.hasUnmatchedIds()) {             // some required datafeeds were not found             listener.onFailure(ExceptionsHelper.missingDatafeedException(requiredMatches.unmatchedIdsString())).             return.         }         listener.onResponse(datafeeds).     }, listener::onFailure), client::search). }
false;private;1;30;;private QueryBuilder buildDatafeedIdQuery(String[] tokens) {     QueryBuilder datafeedQuery = new TermQueryBuilder(DatafeedConfig.CONFIG_TYPE.getPreferredName(), DatafeedConfig.TYPE).     if (Strings.isAllOrWildcard(tokens)) {         // match all         return datafeedQuery.     }     BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder().     boolQueryBuilder.filter(datafeedQuery).     BoolQueryBuilder shouldQueries = new BoolQueryBuilder().     List<String> terms = new ArrayList<>().     for (String token : tokens) {         if (Regex.isSimpleMatchPattern(token)) {             shouldQueries.should(new WildcardQueryBuilder(DatafeedConfig.ID.getPreferredName(), token)).         } else {             terms.add(token).         }     }     if (terms.isEmpty() == false) {         shouldQueries.should(new TermsQueryBuilder(DatafeedConfig.ID.getPreferredName(), terms)).     }     if (shouldQueries.should().isEmpty() == false) {         boolQueryBuilder.filter(shouldQueries).     }     return boolQueryBuilder. }
false;private;1;6;;private QueryBuilder buildDatafeedJobIdsQuery(Collection<String> jobIds) {     BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder().     boolQueryBuilder.filter(new TermQueryBuilder(DatafeedConfig.CONFIG_TYPE.getPreferredName(), DatafeedConfig.TYPE)).     boolQueryBuilder.filter(new TermsQueryBuilder(Job.ID.getPreferredName(), jobIds)).     return boolQueryBuilder. }
false;private;2;9;;private void parseLenientlyFromSource(BytesReference source, ActionListener<DatafeedConfig.Builder> datafeedConfigListener) {     try (InputStream stream = source.streamInput().         XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, stream)) {         datafeedConfigListener.onResponse(DatafeedConfig.LENIENT_PARSER.apply(parser, null)).     } catch (Exception e) {         datafeedConfigListener.onFailure(e).     } }
false;private;1;7;;private DatafeedConfig.Builder parseLenientlyFromSource(BytesReference source) throws IOException {     try (InputStream stream = source.streamInput().         XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, stream)) {         return DatafeedConfig.LENIENT_PARSER.apply(parser, null).     } }
