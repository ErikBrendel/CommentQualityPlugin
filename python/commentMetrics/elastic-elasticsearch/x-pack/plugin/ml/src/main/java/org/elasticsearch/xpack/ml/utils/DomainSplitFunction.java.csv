commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;13;;private static String replaceDots(String input) {     String output = input.     if (output.indexOf('。') >= 0) {         output = output.replace('。', '.').     }     if (output.indexOf('．') >= 0) {         output = output.replace('．', '.').     }     if (output.indexOf('｡') >= 0) {         output = output.replace('｡', '.').     }     return output. }
false;private,static;1;4;;private static List<String> splitDomain(String domain) {     String dotDomain = replaceDots(domain).     return Arrays.asList(dotDomain.split("\\.")). }
false;private,static;1;24;;private static int findPublicSuffix(List<String> parts) {     int partsSize = parts.size().     for (int i = 0. i < partsSize. i++) {         StringJoiner joiner = new StringJoiner(".").         for (String s : parts.subList(i, partsSize)) {             joiner.add(s).         }         /* parts.subList(i, partsSize).each(joiner::add). */         String ancestorName = joiner.toString().         if (exact.containsKey(ancestorName)) {             return i.         }         /* Excluded domains (e.g. !nhs.uk) use the next highest                domain as the effective public suffix (e.g. uk). */         if (excluded.containsKey(ancestorName)) {             return i + 1.         }         String[] pieces = ancestorName.split("\\.").         if (pieces.length >= 2 && under.containsKey(pieces[1])) {             return i.         }     }     return -1. }
false;private,static;2;11;;private static String ancestor(List<String> parts, int levels) {     StringJoiner joiner = new StringJoiner(".").     for (String s : parts.subList(levels, parts.size())) {         joiner.add(s).     }     String name = joiner.toString().     if (name.endsWith(".")) {         name = name.substring(0, name.length() - 1).     }     return name. }
false;private,static;3;9;;private static String topPrivateDomain(String name, List<String> parts, int publicSuffixIndex) {     if (publicSuffixIndex == 1) {         return name.     }     if (!(publicSuffixIndex > 0)) {         throw new IllegalArgumentException("Not under a public suffix: " + name).     }     return ancestor(parts, publicSuffixIndex - 1). }
false;public,static;2;9;;public static List<String> domainSplit(String host, Map<String, Object> params) {     // NOTE: we don't check SpecialPermission because this will be called (indirectly) from scripts     AccessController.doPrivileged((PrivilegedAction<Void>) () -> {         deprecationLogger.deprecatedAndMaybeLog("domainSplit", "Method [domainSplit] taking params is deprecated. Remove the params argument.").         return null.     }).     return domainSplit(host). }
true;public,static;1;62;/**  * Split {@code host} into sub domain and highest registered domain.  * The result is a list containing exactly 2 items the first is the sub domain  * and the second the highest registered domain.  *  * @param host The hostname to split  * @return The sub domain and highest registered domain  */ ;/**  * Split {@code host} into sub domain and highest registered domain.  * The result is a list containing exactly 2 items the first is the sub domain  * and the second the highest registered domain.  *  * @param host The hostname to split  * @return The sub domain and highest registered domain  */ public static List<String> domainSplit(String host) {     host = host.trim().     if (host.contains(":")) {         return Arrays.asList("", host).     }     boolean tentativeIP = true.     for (int i = 0. i < host.length(). i++) {         if (!(Character.isDigit(host.charAt(i)) || host.charAt(i) == '.')) {             tentativeIP = false.             break.         }     }     if (tentativeIP) {         /* special-snowflake rules now... */         if (host.equals(".")) {             return Arrays.asList("", "").         }         return Arrays.asList("", host).     }     String normalizedHost = host.     normalizedHost = normalizedHost.toLowerCase(Locale.ROOT).     List<String> parts = splitDomain(normalizedHost).     int publicSuffixIndex = findPublicSuffix(parts).     if (publicSuffixIndex == 0) {         return Arrays.asList("", host).     }     String highestRegistered = "".     /* for the case where the host is internal like .local so is not a recognised public suffix */     if (publicSuffixIndex == -1) {         if (!parts.isEmpty()) {             if (parts.size() == 1) {                 return Arrays.asList("", host).             }             if (parts.size() > 2) {                 boolean allNumeric = true.                 String value = parts.get(parts.size() - 1).                 for (int i = 0. i < value.length(). i++) {                     if (!Character.isDigit(value.charAt(i))) {                         allNumeric = false.                         break.                     }                 }                 if (allNumeric) {                     highestRegistered = parts.get(parts.size() - 2) + '.' + parts.get(parts.size() - 1).                 } else {                     highestRegistered = parts.get(parts.size() - 1).                 }             } else {                 highestRegistered = parts.get(parts.size() - 1).             }         }     } else {         /* HRD is the top private domain */         highestRegistered = topPrivateDomain(normalizedHost, parts, publicSuffixIndex).     }     String subDomain = host.substring(0, host.length() - highestRegistered.length()).     if (subDomain.endsWith(".")) {         subDomain = subDomain.substring(0, subDomain.length() - 1).     }     return Arrays.asList(subDomain, highestRegistered). }
