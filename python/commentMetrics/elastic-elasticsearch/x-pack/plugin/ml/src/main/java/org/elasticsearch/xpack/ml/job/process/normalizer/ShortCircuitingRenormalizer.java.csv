commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isEnabled() {     return scoresUpdater.getNormalizationWindow() > 0. }
false;public;1;16;;@Override public void renormalize(Quantiles quantiles) {     if (!isEnabled()) {         return.     }     // This will throw NPE if quantiles is null, so do it first     QuantilesWithLatch quantilesWithLatch = new QuantilesWithLatch(quantiles, new CountDownLatch(1)).     // Needed to ensure work is not added while the tryFinishWork() method is running     synchronized (quantilesDeque) {         // Must add to latchDeque before quantilesDeque         latchDeque.addLast(quantilesWithLatch.getLatch()).         quantilesDeque.addLast(quantilesWithLatch).         executorService.submit(() -> doRenormalizations()).     } }
false;public;0;15;;@Override public void waitUntilIdle() {     try {         // but need a different lock to the other synchronized parts of the code         synchronized (latchDeque) {             for (CountDownLatch latchToAwait = latchDeque.pollFirst(). latchToAwait != null. latchToAwait = latchDeque.pollFirst()) {                 latchToAwait.await().             }         }     } catch (InterruptedException e) {         Thread.currentThread().interrupt().         throw new RuntimeException(e).     } }
false;public;0;9;;@Override public void shutdown() {     scoresUpdater.shutdown().     // We have to wait until idle to avoid a raft of exceptions as other parts of the     // system are stopped after this method returns.  However, shutting down the     // scoresUpdater first means it won't do all pending work. it will stop as soon     // as it can without causing further errors.     waitUntilIdle(). }
false;private;0;4;;private Quantiles getEarliestQuantiles() {     QuantilesWithLatch earliestQuantilesWithLatch = quantilesDeque.peekFirst().     return (earliestQuantilesWithLatch != null) ? earliestQuantilesWithLatch.getQuantiles() : null. }
false;private;0;13;;private QuantilesWithLatch getLatestQuantilesWithLatchAndClear() {     // We discard all but the latest quantiles     QuantilesWithLatch latestQuantilesWithLatch = null.     for (QuantilesWithLatch quantilesWithLatch = quantilesDeque.pollFirst(). quantilesWithLatch != null. quantilesWithLatch = quantilesDeque.pollFirst()) {         // Count down the latches associated with any discarded quantiles         if (latestQuantilesWithLatch != null) {             latestQuantilesWithLatch.getLatch().countDown().         }         latestQuantilesWithLatch = quantilesWithLatch.     }     return latestQuantilesWithLatch. }
false;private;0;3;;private boolean tryStartWork() {     return semaphore.tryAcquire(). }
false;private;0;10;;private boolean tryFinishWork() {     // We cannot tolerate new work being added in between the isEmpty() check and releasing the semaphore     synchronized (quantilesDeque) {         if (!quantilesDeque.isEmpty()) {             return false.         }         semaphore.release().         return true.     } }
false;private;0;3;;private void forceFinishWork() {     semaphore.release(). }
false;private;0;48;;private void doRenormalizations() {     // Exit immediately if another normalization is in progress.  This means we don't hog threads.     if (tryStartWork() == false) {         return.     }     CountDownLatch latch = null.     try {         do {             // Note that if there is only one set of quantiles in the queue then both these references will point to the same quantiles.             Quantiles earliestQuantiles = getEarliestQuantiles().             QuantilesWithLatch latestQuantilesWithLatch = getLatestQuantilesWithLatchAndClear().             // did the work and exited, and then this thread got true returned by tryStartWork().             if (latestQuantilesWithLatch != null) {                 Quantiles latestQuantiles = latestQuantilesWithLatch.getQuantiles().                 latch = latestQuantilesWithLatch.getLatch().                 // added between getting the earliest and latest quantiles.                 if (earliestQuantiles == null) {                     earliestQuantiles = latestQuantiles.                 }                 long earliestBucketTimeMs = earliestQuantiles.getTimestamp().getTime().                 long latestBucketTimeMs = latestQuantiles.getTimestamp().getTime().                 // If we're going to skip quantiles, renormalize using the latest quantiles                 // over the time ranges implied by all quantiles that were provided.                 long windowExtensionMs = latestBucketTimeMs - earliestBucketTimeMs.                 if (windowExtensionMs < 0) {                     LOGGER.warn("[{}] Quantiles not supplied in time order - {} after {}", jobId, latestBucketTimeMs, earliestBucketTimeMs).                     windowExtensionMs = 0.                 }                 scoresUpdater.update(latestQuantiles.getQuantileState(), latestBucketTimeMs, windowExtensionMs).                 latch.countDown().                 latch = null.             }         // Loop if more work has become available while we were working, because the         // tasks originally submitted to do that work will have exited early.         } while (tryFinishWork() == false).     } catch (Exception e) {         LOGGER.error("[" + jobId + "] Normalization failed", e).         if (latch != null) {             latch.countDown().         }         forceFinishWork().     } }
false;;0;3;;Quantiles getQuantiles() {     return quantiles. }
false;;0;3;;CountDownLatch getLatch() {     return latch. }
