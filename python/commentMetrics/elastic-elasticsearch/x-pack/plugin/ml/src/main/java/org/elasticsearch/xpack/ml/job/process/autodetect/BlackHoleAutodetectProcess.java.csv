commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;@Override public void restoreState(StateStreamer stateStreamer, ModelSnapshot modelSnapshot) { }
false;public;0;4;;@Override public boolean isReady() {     return true. }
false;public;1;3;;@Override public void writeRecord(String[] record) throws IOException { }
false;public;1;3;;@Override public void writeResetBucketsControlMessage(DataLoadParams params) throws IOException { }
false;public;1;3;;@Override public void writeUpdateModelPlotMessage(ModelPlotConfig modelPlotConfig) throws IOException { }
false;public;2;3;;@Override public void writeUpdateDetectorRulesMessage(int detectorIndex, List<DetectionRule> rules) throws IOException { }
false;public;1;3;;@Override public void writeUpdateFiltersMessage(List<MlFilter> filters) throws IOException { }
false;public;2;3;;@Override public void writeUpdateScheduledEventsMessage(List<ScheduledEvent> events, TimeValue bucketSpan) throws IOException { }
true;public;1;7;/**  * Accept the request do nothing with it but write the flush acknowledgement to {@link #readAutodetectResults()}  * @param params Should interim results be generated  * @return {@link #FLUSH_ID}  */ ;/**  * Accept the request do nothing with it but write the flush acknowledgement to {@link #readAutodetectResults()}  * @param params Should interim results be generated  * @return {@link #FLUSH_ID}  */ @Override public String flushJob(FlushJobParams params) throws IOException {     FlushAcknowledgement flushAcknowledgement = new FlushAcknowledgement(FLUSH_ID, null).     AutodetectResult result = new AutodetectResult(null, null, null, null, null, null, null, null, null, null, flushAcknowledgement).     results.add(result).     return FLUSH_ID. }
false;public;0;3;;@Override public void persistState() { }
false;public;0;3;;@Override public void flushStream() { }
false;public;0;9;;@Override public void close() throws IOException {     if (open) {         Quantiles quantiles = new Quantiles(jobId, new Date(), "black hole quantiles").         AutodetectResult result = new AutodetectResult(null, null, null, quantiles, null, null, null, null, null, null, null).         results.add(result).         open = false.     } }
false;public;0;4;;@Override public void kill() throws IOException {     open = false. }
false;public;0;16;;@Override public boolean hasNext() {     try {         while (open) {             result = results.poll(100, TimeUnit.MILLISECONDS).             if (result != null) {                 return true.             }         }         result = results.poll().         return result != null.     } catch (InterruptedException e) {         Thread.currentThread().interrupt().         return false.     } }
false;public;0;4;;@Override public AutodetectResult next() {     return result. }
false;public;0;30;;@Override public Iterator<AutodetectResult> readAutodetectResults() {     // Create a custom iterator here, because LinkedBlockingDeque iterator and stream are not blocking when empty:     return new Iterator<AutodetectResult>() {          AutodetectResult result.          @Override         public boolean hasNext() {             try {                 while (open) {                     result = results.poll(100, TimeUnit.MILLISECONDS).                     if (result != null) {                         return true.                     }                 }                 result = results.poll().                 return result != null.             } catch (InterruptedException e) {                 Thread.currentThread().interrupt().                 return false.             }         }          @Override         public AutodetectResult next() {             return result.         }     }. }
false;public;0;3;;@Override public void consumeAndCloseOutputStream() { }
false;public;0;4;;@Override public ZonedDateTime getProcessStartTime() {     return startTime. }
false;public;0;4;;@Override public boolean isProcessAlive() {     return open. }
false;public;0;9;;@Override public boolean isProcessAliveAfterWaiting() {     try {         Thread.sleep(45).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     }     return open. }
false;public;0;4;;@Override public String readError() {     return "". }
false;public;1;3;;@Override public void forecastJob(ForecastParams params) throws IOException { }
