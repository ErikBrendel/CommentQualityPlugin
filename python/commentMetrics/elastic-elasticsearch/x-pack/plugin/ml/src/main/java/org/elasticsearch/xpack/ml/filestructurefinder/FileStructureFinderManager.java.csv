commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;public FileStructureFinder findFileStructure(Integer idealSampleLineCount, InputStream fromFile) throws Exception {     return findFileStructure(idealSampleLineCount, fromFile, FileStructureOverrides.EMPTY_OVERRIDES, null). }
true;public;4;6;/**  * Given a stream of data from some file, determine its structure.  * @param idealSampleLineCount Ideally, how many lines from the stream will be read to determine the structure?  *                             If the stream has fewer lines then an attempt will still be made, providing at  *                             least {@link #MIN_SAMPLE_LINE_COUNT} lines can be read.  If <code>null</code>  *                             the value of {@link #DEFAULT_IDEAL_SAMPLE_LINE_COUNT} will be used.  * @param fromFile A stream from which the sample will be read.  * @param overrides Aspects of the file structure that are known in advance.  These take precedence over  *                  values determined by structure analysis.  An exception will be thrown if the file structure  *                  is incompatible with an overridden value.  * @param timeout The maximum time the analysis is permitted to take.  If it takes longer than this an  *                {@link ElasticsearchTimeoutException} may be thrown (although not necessarily immediately  *                the timeout is exceeded).  * @return A {@link FileStructureFinder} object from which the structure and messages can be queried.  * @throws Exception A variety of problems could occur at various stages of the structure finding process.  */ ;/**  * Given a stream of data from some file, determine its structure.  * @param idealSampleLineCount Ideally, how many lines from the stream will be read to determine the structure?  *                             If the stream has fewer lines then an attempt will still be made, providing at  *                             least {@link #MIN_SAMPLE_LINE_COUNT} lines can be read.  If <code>null</code>  *                             the value of {@link #DEFAULT_IDEAL_SAMPLE_LINE_COUNT} will be used.  * @param fromFile A stream from which the sample will be read.  * @param overrides Aspects of the file structure that are known in advance.  These take precedence over  *                  values determined by structure analysis.  An exception will be thrown if the file structure  *                  is incompatible with an overridden value.  * @param timeout The maximum time the analysis is permitted to take.  If it takes longer than this an  *                {@link ElasticsearchTimeoutException} may be thrown (although not necessarily immediately  *                the timeout is exceeded).  * @return A {@link FileStructureFinder} object from which the structure and messages can be queried.  * @throws Exception A variety of problems could occur at various stages of the structure finding process.  */ public FileStructureFinder findFileStructure(Integer idealSampleLineCount, InputStream fromFile, FileStructureOverrides overrides, TimeValue timeout) throws Exception {     return findFileStructure(new ArrayList<>(), (idealSampleLineCount == null) ? DEFAULT_IDEAL_SAMPLE_LINE_COUNT : idealSampleLineCount, fromFile, overrides, timeout). }
false;public;3;4;;public FileStructureFinder findFileStructure(List<String> explanation, int idealSampleLineCount, InputStream fromFile) throws Exception {     return findFileStructure(explanation, idealSampleLineCount, fromFile, FileStructureOverrides.EMPTY_OVERRIDES, null). }
false;public;5;31;;public FileStructureFinder findFileStructure(List<String> explanation, int idealSampleLineCount, InputStream fromFile, FileStructureOverrides overrides, TimeValue timeout) throws Exception {     try (TimeoutChecker timeoutChecker = new TimeoutChecker("structure analysis", timeout, scheduler)) {         String charsetName = overrides.getCharset().         Reader sampleReader.         if (charsetName != null) {             // Creating the reader will throw if the specified character set does not exist             sampleReader = new InputStreamReader(fromFile, charsetName).             explanation.add("Using specified character encoding [" + charsetName + "]").         } else {             CharsetMatch charsetMatch = findCharset(explanation, fromFile, timeoutChecker).             charsetName = charsetMatch.getName().             sampleReader = charsetMatch.getReader().         }         Tuple<String, Boolean> sampleInfo = sampleFile(sampleReader, charsetName, MIN_SAMPLE_LINE_COUNT, Math.max(MIN_SAMPLE_LINE_COUNT, idealSampleLineCount), timeoutChecker).         return makeBestStructureFinder(explanation, sampleInfo.v1(), charsetName, sampleInfo.v2(), overrides, timeoutChecker).     } catch (Exception e) {         // decisions made early on in the structure analysis can result in seemingly crazy decisions or timeouts later on         if (explanation.isEmpty() == false) {             e.addSuppressed(new ElasticsearchException(explanation.stream().collect(Collectors.joining("]\n[", "Explanation so far:\n[", "]\n")))).         }         throw e.     } }
false;;3;90;;CharsetMatch findCharset(List<String> explanation, InputStream inputStream, TimeoutChecker timeoutChecker) throws Exception {     // in a BufferedInputStream if it doesn't already support this feature     if (inputStream.markSupported() == false) {         inputStream = new BufferedInputStream(inputStream, BUFFER_SIZE).     }     // This is from ICU4J     CharsetDetector charsetDetector = new CharsetDetector().setText(inputStream).     CharsetMatch[] charsetMatches = charsetDetector.detectAll().     timeoutChecker.check("character set detection").     // Determine some extra characteristics of the input to compensate for some deficiencies of ICU4J     boolean pureAscii = true.     boolean containsZeroBytes = false.     inputStream.mark(BUFFER_SIZE).     byte[] workspace = new byte[BUFFER_SIZE].     int remainingLength = BUFFER_SIZE.     do {         int bytesRead = inputStream.read(workspace, 0, remainingLength).         if (bytesRead <= 0) {             break.         }         for (int i = 0. i < bytesRead && containsZeroBytes == false. ++i) {             if (workspace[i] == 0) {                 containsZeroBytes = true.                 pureAscii = false.             } else {                 pureAscii = pureAscii && workspace[i] > 0 && workspace[i] < 128.             }         }         remainingLength -= bytesRead.     } while (containsZeroBytes == false && remainingLength > 0).     inputStream.reset().     timeoutChecker.check("character set detection").     if (pureAscii) {         // If the input is pure ASCII then many single byte character sets will match.  We want to favour         // UTF-8 in this case, as it avoids putting a bold declaration of a dubious character set choice         // in the config files.         Optional<CharsetMatch> utf8CharsetMatch = Arrays.stream(charsetMatches).filter(charsetMatch -> StandardCharsets.UTF_8.name().equals(charsetMatch.getName())).findFirst().         if (utf8CharsetMatch.isPresent()) {             explanation.add("Using character encoding [" + StandardCharsets.UTF_8.name() + "], which matched the input with [" + utf8CharsetMatch.get().getConfidence() + "%] confidence - first [" + (BUFFER_SIZE / 1024) + "kB] of input was pure ASCII").             return utf8CharsetMatch.get().         }     }     // suggest these for binary files but then     for (CharsetMatch charsetMatch : charsetMatches) {         String name = charsetMatch.getName().         if (Charset.isSupported(name) && FILEBEAT_SUPPORTED_ENCODINGS.contains(name.toLowerCase(Locale.ROOT))) {             // This extra test is to avoid trying to read binary files as text.  Running the structure             // finding algorithms on binary files is very slow as the binary files generally appear to             // have very long lines.             boolean spaceEncodingContainsZeroByte = false.             Charset charset = Charset.forName(name).             // the side of rejecting binary data.             if (charset.canEncode()) {                 byte[] spaceBytes = " ".getBytes(charset).                 for (int i = 0. i < spaceBytes.length && spaceEncodingContainsZeroByte == false. ++i) {                     spaceEncodingContainsZeroByte = (spaceBytes[i] == 0).                 }             }             if (containsZeroBytes && spaceEncodingContainsZeroByte == false) {                 explanation.add("Character encoding [" + name + "] matched the input with [" + charsetMatch.getConfidence() + "%] confidence but was rejected as the input contains zero bytes and the [" + name + "] encoding does not").             } else {                 explanation.add("Using character encoding [" + name + "], which matched the input with [" + charsetMatch.getConfidence() + "%] confidence").                 return charsetMatch.             }         } else {             explanation.add("Character encoding [" + name + "] matched the input with [" + charsetMatch.getConfidence() + "%] confidence but was rejected as it is not supported by [" + (Charset.isSupported(name) ? "Filebeat" : "the JVM") + "]").         }     }     throw new IllegalArgumentException("Could not determine a usable character encoding for the input" + (containsZeroBytes ? " - could it be binary data?" : "")). }
false;;6;40;;FileStructureFinder makeBestStructureFinder(List<String> explanation, String sample, String charsetName, Boolean hasByteOrderMarker, FileStructureOverrides overrides, TimeoutChecker timeoutChecker) throws Exception {     Character delimiter = overrides.getDelimiter().     Character quote = overrides.getQuote().     Boolean shouldTrimFields = overrides.getShouldTrimFields().     List<FileStructureFinderFactory> factories.     if (delimiter != null) {         // If a precise delimiter is specified, we only need one structure finder         // factory, and we'll tolerate as little as one column in the input         factories = Collections.singletonList(new DelimitedFileStructureFinderFactory(delimiter, (quote == null) ? '"' : quote, 1, (shouldTrimFields == null) ? (delimiter == '|') : shouldTrimFields)).     } else if (quote != null || shouldTrimFields != null) {         // The delimiter is not specified, but some other aspect of delimited files is,         // so clone our default delimited factories altering the overridden values         factories = ORDERED_STRUCTURE_FACTORIES.stream().filter(factory -> factory instanceof DelimitedFileStructureFinderFactory).map(factory -> ((DelimitedFileStructureFinderFactory) factory).makeSimilar(quote, shouldTrimFields)).collect(Collectors.toList()).     } else {         // We can use the default factories, but possibly filtered down to a specific format         factories = ORDERED_STRUCTURE_FACTORIES.stream().filter(factory -> factory.canFindFormat(overrides.getFormat())).collect(Collectors.toList()).     }     for (FileStructureFinderFactory factory : factories) {         timeoutChecker.check("high level format detection").         if (factory.canCreateFromSample(explanation, sample)) {             return factory.createFromSample(explanation, sample, charsetName, hasByteOrderMarker, overrides, timeoutChecker).         }     }     throw new IllegalArgumentException("Input did not match " + ((overrides.getFormat() == null) ? "any known formats" : "the specified format [" + overrides.getFormat() + "]")). }
false;private;5;34;;private Tuple<String, Boolean> sampleFile(Reader reader, String charsetName, int minLines, int maxLines, TimeoutChecker timeoutChecker) throws IOException {     int lineCount = 0.     BufferedReader bufferedReader = new BufferedReader(reader).     StringBuilder sample = new StringBuilder().     // Don't include any byte-order-marker in the sample.  (The logic to skip it works for both     // UTF-8 and UTF-16 assuming the character set of the reader was correctly detected.)     Boolean hasByteOrderMarker = null.     if (charsetName.toUpperCase(Locale.ROOT).startsWith("UTF")) {         int maybeByteOrderMarker = reader.read().         hasByteOrderMarker = ((char) maybeByteOrderMarker == '\uFEFF').         if (maybeByteOrderMarker >= 0 && hasByteOrderMarker == false && (char) maybeByteOrderMarker != '\r') {             sample.appendCodePoint(maybeByteOrderMarker).             if ((char) maybeByteOrderMarker == '\n') {                 ++lineCount.             }         }     }     String line.     while ((line = bufferedReader.readLine()) != null && ++lineCount <= maxLines) {         sample.append(line).append('\n').         timeoutChecker.check("sample line splitting").     }     if (lineCount < minLines) {         throw new IllegalArgumentException("Input contained too few lines [" + lineCount + "] to obtain a meaningful sample").     }     return new Tuple<>(sample.toString(), hasByteOrderMarker). }
