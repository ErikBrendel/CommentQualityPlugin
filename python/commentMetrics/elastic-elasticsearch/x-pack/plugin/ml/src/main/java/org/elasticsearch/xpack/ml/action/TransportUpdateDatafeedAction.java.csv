commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected PutDatafeedAction.Response newResponse() {     return new PutDatafeedAction.Response(). }
false;protected;3;39;;@Override protected void masterOperation(UpdateDatafeedAction.Request request, ClusterState state, ActionListener<PutDatafeedAction.Response> listener) throws Exception {     if (migrationEligibilityCheck.datafeedIsEligibleForMigration(request.getUpdate().getId(), state)) {         listener.onFailure(ExceptionsHelper.configHasNotBeenMigrated("update datafeed", request.getUpdate().getId())).         return.     }     final Map<String, String> headers = threadPool.getThreadContext().getHeaders().     // Check datafeed is stopped     PersistentTasksCustomMetaData tasks = state.getMetaData().custom(PersistentTasksCustomMetaData.TYPE).     if (MlTasks.getDatafeedTask(request.getUpdate().getId(), tasks) != null) {         listener.onFailure(ExceptionsHelper.conflictStatusException(Messages.getMessage(Messages.DATAFEED_CANNOT_UPDATE_IN_CURRENT_STATE, request.getUpdate().getId(), DatafeedState.STARTED))).         return.     }     String datafeedId = request.getUpdate().getId().     CheckedConsumer<Boolean, Exception> updateConsumer = ok -> {         datafeedConfigProvider.updateDatefeedConfig(request.getUpdate().getId(), request.getUpdate(), headers, jobConfigProvider::validateDatafeedJob, ActionListener.wrap(updatedConfig -> listener.onResponse(new PutDatafeedAction.Response(updatedConfig)), listener::onFailure)).     }.     if (request.getUpdate().getJobId() != null) {         checkJobDoesNotHaveADifferentDatafeed(request.getUpdate().getJobId(), datafeedId, ActionListener.wrap(updateConsumer, listener::onFailure)).     } else {         updateConsumer.accept(Boolean.TRUE).     } }
true;private;3;17;/*      * This is a check against changing the datafeed's jobId and that job      * already having a datafeed.      * The job the updated datafeed refers to should have no datafeed or      * if it does have a datafeed it must be the one we are updating      */ ;/*      * This is a check against changing the datafeed's jobId and that job      * already having a datafeed.      * The job the updated datafeed refers to should have no datafeed or      * if it does have a datafeed it must be the one we are updating      */ private void checkJobDoesNotHaveADifferentDatafeed(String jobId, String datafeedId, ActionListener<Boolean> listener) {     datafeedConfigProvider.findDatafeedsForJobIds(Collections.singletonList(jobId), ActionListener.wrap(datafeedIds -> {         if (datafeedIds.isEmpty()) {             // Ok the job does not have a datafeed             listener.onResponse(Boolean.TRUE).         } else if (datafeedIds.size() == 1 && datafeedIds.contains(datafeedId)) {             // Ok the job has the datafeed being updated             listener.onResponse(Boolean.TRUE).         } else {             listener.onFailure(ExceptionsHelper.conflictStatusException("A datafeed [" + datafeedIds.iterator().next() + "] already exists for job [" + jobId + "]")).         }     }, listener::onFailure)). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(UpdateDatafeedAction.Request request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
