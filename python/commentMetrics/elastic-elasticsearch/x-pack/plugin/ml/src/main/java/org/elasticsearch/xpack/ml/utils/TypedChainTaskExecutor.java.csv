commented;modifiers;parameterAmount;loc;comment;code
false;;1;1;;void run(ActionListener<T> listener).
false;public,synchronized;1;3;;public synchronized void add(ChainTask<T> task) {     tasks.add(task). }
false;public;1;8;;@Override public void onFailure(Exception e) {     if (failureShortCircuitPredicate.test(e)) {         listener.onFailure(e).     } else {         execute(null, listener).     } }
false;protected;0;4;;@Override protected void doRun() {     task.run(ActionListener.wrap(value -> execute(value, listener), this::onFailure)). }
false;private,synchronized;2;27;;private synchronized void execute(T previousValue, ActionListener<List<T>> listener) {     collectedResponses.add(previousValue).     if (continuationPredicate.test(previousValue)) {         if (tasks.isEmpty()) {             listener.onResponse(Collections.unmodifiableList(new ArrayList<>(collectedResponses))).             return.         }         ChainTask<T> task = tasks.pop().         executorService.execute(new AbstractRunnable() {              @Override             public void onFailure(Exception e) {                 if (failureShortCircuitPredicate.test(e)) {                     listener.onFailure(e).                 } else {                     execute(null, listener).                 }             }              @Override             protected void doRun() {                 task.run(ActionListener.wrap(value -> execute(value, listener), this::onFailure)).             }         }).     } else {         listener.onResponse(Collections.unmodifiableList(new ArrayList<>(collectedResponses))).     } }
false;public;1;8;;@Override public void onFailure(Exception e) {     if (failureShortCircuitPredicate.test(e)) {         listener.onFailure(e).     } else {         execute(null, listener).     } }
false;protected;0;4;;@Override protected void doRun() {     task.run(ActionListener.wrap(value -> execute(value, listener), this::onFailure)). }
true;public,synchronized;1;23;/**  * Execute all the chained tasks serially, notify listener when completed  *  * @param listener The ActionListener to notify when all executions have been completed,  *                 or when no further tasks should be executed.  *                 The resulting list COULD contain null values depending on if execution is continued  *                 on exceptions or not.  */ ;/**  * Execute all the chained tasks serially, notify listener when completed  *  * @param listener The ActionListener to notify when all executions have been completed,  *                 or when no further tasks should be executed.  *                 The resulting list COULD contain null values depending on if execution is continued  *                 on exceptions or not.  */ public synchronized void execute(ActionListener<List<T>> listener) {     if (tasks.isEmpty()) {         listener.onResponse(Collections.emptyList()).         return.     }     collectedResponses.clear().     ChainTask<T> task = tasks.pop().     executorService.execute(new AbstractRunnable() {          @Override         public void onFailure(Exception e) {             if (failureShortCircuitPredicate.test(e)) {                 listener.onFailure(e).             } else {                 execute(null, listener).             }         }          @Override         protected void doRun() {             task.run(ActionListener.wrap(value -> execute(value, listener), this::onFailure)).         }     }). }
false;public,synchronized;0;3;;public synchronized List<T> getCollectedResponses() {     return Collections.unmodifiableList(new ArrayList<>(collectedResponses)). }
