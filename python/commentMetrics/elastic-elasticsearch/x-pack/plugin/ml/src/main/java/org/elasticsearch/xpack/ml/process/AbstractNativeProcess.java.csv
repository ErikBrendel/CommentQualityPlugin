commented;modifiers;parameterAmount;loc;comment;code
false;public,abstract;0;1;;public abstract String getName().
true;public;1;21;/**  * Starts a process that does not persist any state  * @param executorService the executor service to run on  */ ;/**  * Starts a process that does not persist any state  * @param executorService the executor service to run on  */ public void start(ExecutorService executorService) {     logTailFuture = executorService.submit(() -> {         try (CppLogMessageHandler h = cppLogHandler) {             h.tailStream().         } catch (IOException e) {             if (processKilled == false) {                 LOGGER.error(new ParameterizedMessage("[{}] Error tailing {} process logs", jobId, getName()), e).             }         } finally {             if (processCloseInitiated == false && processKilled == false) {                 // The log message doesn't say "crashed", as the process could have been killed                 // by a user or other process (e.g. the Linux OOM killer)                 String errors = cppLogHandler.getErrors().                 String fullError = String.format(Locale.ROOT, "[%s] %s process stopped unexpectedly: %s", jobId, getName(), errors).                 LOGGER.error(fullError).                 onProcessCrash.accept(fullError).             }         }     }). }
true;public;3;16;/**  * Starts a process that may persist its state  * @param executorService the executor service to run on  * @param stateProcessor the state processor  * @param persistStream the stream where the state is persisted  */ ;/**  * Starts a process that may persist its state  * @param executorService the executor service to run on  * @param stateProcessor the state processor  * @param persistStream the stream where the state is persisted  */ public void start(ExecutorService executorService, StateProcessor stateProcessor, InputStream persistStream) {     start(executorService).     stateProcessorFuture = executorService.submit(() -> {         try (InputStream in = persistStream) {             stateProcessor.process(in).             if (processKilled == false) {                 LOGGER.info("[{}] State output finished", jobId).             }         } catch (IOException e) {             if (processKilled == false) {                 LOGGER.error(new ParameterizedMessage("[{}] Error reading {} state output", jobId, getName()), e).             }         }     }). }
false;public;0;4;;@Override public boolean isReady() {     return isReady. }
false;protected;0;3;;protected void setReady() {     isReady = true. }
false;public;1;4;;@Override public void writeRecord(String[] record) throws IOException {     recordWriter.writeRecord(record). }
false;public;0;4;;@Override public void flushStream() throws IOException {     recordWriter.flush(). }
false;public;0;32;;@Override public void close() throws IOException {     try {         processCloseInitiated = true.         // closing its input causes the process to exit         processInStream.close().         // indexed         if (stateProcessorFuture != null) {             stateProcessorFuture.get(MachineLearningField.STATE_PERSIST_RESTORE_TIMEOUT.getMinutes(), TimeUnit.MINUTES).         }         // finish first)         if (logTailFuture != null) {             logTailFuture.get(5, TimeUnit.SECONDS).         }         if (cppLogHandler.seenFatalError()) {             throw ExceptionsHelper.serverError(cppLogHandler.getErrors()).         }         LOGGER.debug("[{}] {} process exited", jobId, getName()).     } catch (ExecutionException | TimeoutException e) {         LOGGER.warn(new ParameterizedMessage("[{}] Exception closing the running {} process", jobId, getName()), e).     } catch (InterruptedException e) {         LOGGER.warn(new ParameterizedMessage("[{}] Exception closing the running {} process", jobId, getName()), e).         Thread.currentThread().interrupt().     } finally {         deleteAssociatedFiles().     } }
false;public;0;27;;@Override public void kill() throws IOException {     processKilled = true.     try {         // The PID comes via the processes log stream.  We don't wait for it to arrive here,         // but if the wait times out it implies the process has only just started, in which         // case it should die very quickly when we close its input stream.         NativeControllerHolder.getNativeController().killProcess(cppLogHandler.getPid(Duration.ZERO)).         // Wait for the process to die before closing processInStream as if the process         // is still alive when processInStream is closed it may start persisting state         cppLogHandler.waitForLogStreamClose(WAIT_FOR_KILL_TIMEOUT).     } catch (TimeoutException e) {         LOGGER.warn("[{}] Failed to get PID of {} process to kill", jobId, getName()).     } finally {         try {             processInStream.close().         } catch (IOException e) {         // Ignore it - we're shutting down and the method itself has logged a warning         }         try {             deleteAssociatedFiles().         } catch (IOException e) {         // Ignore it - we're shutting down and the method itself has logged a warning         }     } }
false;private,synchronized;0;15;;private synchronized void deleteAssociatedFiles() throws IOException {     if (filesToDelete == null) {         return.     }     for (Path fileToDelete : filesToDelete) {         if (Files.deleteIfExists(fileToDelete)) {             LOGGER.debug("[{}] Deleted file {}", jobId, fileToDelete.toString()).         } else {             LOGGER.warn("[{}] Failed to delete file {}", jobId, fileToDelete.toString()).         }     }     filesToDelete.clear(). }
false;public;0;4;;@Override public ZonedDateTime getProcessStartTime() {     return startTime. }
false;public;0;5;;@Override public boolean isProcessAlive() {     // Sanity check: make sure the process hasn't terminated already     return !cppLogHandler.hasLogStreamEnded(). }
false;public;0;5;;@Override public boolean isProcessAliveAfterWaiting() {     cppLogHandler.waitForLogStreamClose(Duration.ofMillis(45)).     return isProcessAlive(). }
false;public;0;4;;@Override public String readError() {     return cppLogHandler.getErrors(). }
false;protected;0;3;;protected String jobId() {     return jobId. }
false;protected;0;3;;protected InputStream processOutStream() {     return processOutStream. }
false;protected;0;4;;@Nullable protected OutputStream processRestoreStream() {     return processRestoreStream. }
false;protected;0;3;;protected int numberOfFields() {     return numberOfFields. }
false;protected;0;3;;protected LengthEncodedWriter recordWriter() {     return recordWriter. }
false;protected;0;3;;protected boolean isProcessKilled() {     return processKilled. }
