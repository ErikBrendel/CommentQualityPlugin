commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean shouldCalculateInterim() {     return calcInterim. }
false;public;0;3;;public boolean shouldAdvanceTime() {     return advanceTimeSeconds != null. }
false;public;0;3;;public boolean shouldSkipTime() {     return skipTimeSeconds != null. }
false;public;0;3;;public String getStart() {     return timeRange.getStart(). }
false;public;0;3;;public String getEnd() {     return timeRange.getEnd(). }
false;public;0;6;;public long getAdvanceTime() {     if (!shouldAdvanceTime()) {         throw new IllegalStateException().     }     return advanceTimeSeconds. }
false;public;0;6;;public long getSkipTime() {     if (!shouldSkipTime()) {         throw new IllegalStateException().     }     return skipTimeSeconds. }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public;1;10;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     FlushJobParams that = (FlushJobParams) o.     return calcInterim == that.calcInterim && Objects.equals(timeRange, that.timeRange) && Objects.equals(advanceTimeSeconds, that.advanceTimeSeconds) && Objects.equals(skipTimeSeconds, that.skipTimeSeconds). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(calcInterim, timeRange, advanceTimeSeconds, skipTimeSeconds). }
false;public;1;4;;public Builder calcInterim(boolean value) {     calcInterim = value.     return this. }
false;public;1;4;;public Builder forTimeRange(TimeRange timeRange) {     this.timeRange = timeRange.     return this. }
false;public;1;4;;public Builder advanceTime(String timestamp) {     advanceTime = ExceptionsHelper.requireNonNull(timestamp, "advance_time").     return this. }
false;public;1;4;;public Builder skipTime(String timestamp) {     skipTime = ExceptionsHelper.requireNonNull(timestamp, "skip_time").     return this. }
false;public;0;10;;public FlushJobParams build() {     checkValidFlushArgumentsCombination().     Long advanceTimeSeconds = parseTimeParam("advance_time", advanceTime).     Long skipTimeSeconds = parseTimeParam("skip_time", skipTime).     if (skipTimeSeconds != null && advanceTimeSeconds != null && advanceTimeSeconds <= skipTimeSeconds) {         throw ExceptionsHelper.badRequestException("advance_time [" + advanceTime + "] must be later than skip_time [" + skipTime + "]").     }     return new FlushJobParams(calcInterim, timeRange, advanceTimeSeconds, skipTimeSeconds). }
false;private;0;9;;private void checkValidFlushArgumentsCombination() {     if (!calcInterim) {         checkFlushParamIsEmpty(TimeRange.START_PARAM, timeRange.getStart()).         checkFlushParamIsEmpty(TimeRange.END_PARAM, timeRange.getEnd()).     } else if (!isValidTimeRange(timeRange)) {         String msg = Messages.getMessage(Messages.REST_INVALID_FLUSH_PARAMS_MISSING, "start").         throw new IllegalArgumentException(msg).     } }
false;private;2;6;;private Long parseTimeParam(String name, String value) {     if (Strings.isNullOrEmpty(value)) {         return null.     }     return paramToEpochIfValidOrThrow(name, value) / TimeRange.MILLISECONDS_IN_SECOND. }
false;private;2;14;;private long paramToEpochIfValidOrThrow(String paramName, String date) {     if (TimeRange.NOW.equals(date)) {         return System.currentTimeMillis().     }     long epoch = 0.     if (date.isEmpty() == false) {         epoch = TimeUtils.dateStringToEpoch(date).         if (epoch < 0) {             String msg = Messages.getMessage(Messages.REST_INVALID_DATETIME_PARAMS, paramName, date).             throw new ElasticsearchParseException(msg).         }     }     return epoch. }
false;private;2;6;;private void checkFlushParamIsEmpty(String paramName, String paramValue) {     if (!paramValue.isEmpty()) {         String msg = Messages.getMessage(Messages.REST_INVALID_FLUSH_PARAMS_UNEXPECTED, paramName).         throw new IllegalArgumentException(msg).     } }
false;private;1;3;;private boolean isValidTimeRange(TimeRange timeRange) {     return !timeRange.getStart().isEmpty() || (timeRange.getStart().isEmpty() && timeRange.getEnd().isEmpty()). }
