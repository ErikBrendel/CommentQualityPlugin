commented;modifiers;parameterAmount;loc;comment;code
true;public;2;32;/**  * Delete a list of model snapshots and their corresponding state documents.  *  * @param modelSnapshots the model snapshots to delete  */ ;/**  * Delete a list of model snapshots and their corresponding state documents.  *  * @param modelSnapshots the model snapshots to delete  */ public void deleteModelSnapshots(List<ModelSnapshot> modelSnapshots, ActionListener<BulkByScrollResponse> listener) {     if (modelSnapshots.isEmpty()) {         listener.onResponse(new BulkByScrollResponse(TimeValue.ZERO, new BulkByScrollTask.Status(Collections.emptyList(), null), Collections.emptyList(), Collections.emptyList(), false)).         return.     }     String stateIndexName = AnomalyDetectorsIndex.jobStateIndexPattern().     List<String> idsToDelete = new ArrayList<>().     Set<String> indices = new HashSet<>().     indices.add(stateIndexName).     for (ModelSnapshot modelSnapshot : modelSnapshots) {         idsToDelete.addAll(modelSnapshot.stateDocumentIds()).         idsToDelete.add(ModelSnapshot.documentId(modelSnapshot)).         indices.add(AnomalyDetectorsIndex.jobResultsAliasedName(modelSnapshot.getJobId())).     }     DeleteByQueryRequest deleteByQueryRequest = new DeleteByQueryRequest(indices.toArray(new String[0])).setRefresh(true).setIndicesOptions(IndicesOptions.lenientExpandOpen()).setQuery(new IdsQueryBuilder().addIds(idsToDelete.toArray(new String[0]))).     try {         executeAsyncWithOrigin(client, ML_ORIGIN, DeleteByQueryAction.INSTANCE, deleteByQueryRequest, listener).     } catch (Exception e) {         listener.onFailure(e).     } }
true;public;2;12;/**  * Asynchronously delete all result types (Buckets, Records, Influencers) from {@code cutOffTime}  *  * @param cutoffEpochMs Results at and after this time will be deleted  * @param listener Response listener  */ ;/**  * Asynchronously delete all result types (Buckets, Records, Influencers) from {@code cutOffTime}  *  * @param cutoffEpochMs Results at and after this time will be deleted  * @param listener Response listener  */ public void deleteResultsFromTime(long cutoffEpochMs, ActionListener<Boolean> listener) {     DeleteByQueryHolder deleteByQueryHolder = new DeleteByQueryHolder(AnomalyDetectorsIndex.jobResultsAliasedName(jobId)).     deleteByQueryHolder.dbqRequest.setRefresh(true).     QueryBuilder query = QueryBuilders.boolQuery().filter(QueryBuilders.existsQuery(Result.RESULT_TYPE.getPreferredName())).filter(QueryBuilders.rangeQuery(Result.TIMESTAMP.getPreferredName()).gte(cutoffEpochMs)).     deleteByQueryHolder.dbqRequest.setIndicesOptions(IndicesOptions.lenientExpandOpen()).     deleteByQueryHolder.dbqRequest.setQuery(query).     executeAsyncWithOrigin(client, ML_ORIGIN, DeleteByQueryAction.INSTANCE, deleteByQueryHolder.dbqRequest, ActionListener.wrap(r -> listener.onResponse(true), listener::onFailure)). }
true;public;0;14;/**  * Delete all results marked as interim  */ ;/**  * Delete all results marked as interim  */ public void deleteInterimResults() {     DeleteByQueryHolder deleteByQueryHolder = new DeleteByQueryHolder(AnomalyDetectorsIndex.jobResultsAliasedName(jobId)).     deleteByQueryHolder.dbqRequest.setRefresh(false).     deleteByQueryHolder.dbqRequest.setIndicesOptions(IndicesOptions.lenientExpandOpen()).     QueryBuilder qb = QueryBuilders.termQuery(Result.IS_INTERIM.getPreferredName(), true).     deleteByQueryHolder.dbqRequest.setQuery(new ConstantScoreQueryBuilder(qb)).     try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN)) {         client.execute(DeleteByQueryAction.INSTANCE, deleteByQueryHolder.dbqRequest).get().     } catch (Exception e) {         LOGGER.error("[" + jobId + "] An error occurred while deleting interim results", e).     } }
