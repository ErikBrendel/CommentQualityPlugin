commented;modifiers;parameterAmount;loc;comment;code
false;public;1;19;;@Override public void remove(ActionListener<Boolean> listener) {     LOGGER.debug("Removing forecasts that expire before [{}]", cutoffEpochMs).     ActionListener<SearchResponse> forecastStatsHandler = ActionListener.wrap(searchResponse -> deleteForecasts(searchResponse, listener), e -> listener.onFailure(new ElasticsearchException("An error occurred while searching forecasts to delete", e))).     SearchSourceBuilder source = new SearchSourceBuilder().     source.query(QueryBuilders.boolQuery().filter(QueryBuilders.termQuery(Result.RESULT_TYPE.getPreferredName(), ForecastRequestStats.RESULT_TYPE_VALUE)).filter(QueryBuilders.existsQuery(ForecastRequestStats.EXPIRY_TIME.getPreferredName()))).     source.size(MAX_FORECASTS).     source.trackTotalHits(true).     SearchRequest searchRequest = new SearchRequest(RESULTS_INDEX_PATTERN).     searchRequest.source(source).     client.execute(SearchAction.INSTANCE, searchRequest, new ThreadedActionListener<>(LOGGER, threadPool, MachineLearning.UTILITY_THREAD_POOL_NAME, forecastStatsHandler, false)). }
false;public;1;12;;@Override public void onResponse(BulkByScrollResponse bulkByScrollResponse) {     try {         if (bulkByScrollResponse.getDeleted() > 0) {             LOGGER.info("Deleted [{}] documents corresponding to [{}] expired forecasts", bulkByScrollResponse.getDeleted(), forecastsToDelete.size()).         }         listener.onResponse(true).     } catch (Exception e) {         onFailure(e).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(new ElasticsearchException("Failed to remove expired forecasts", e)). }
false;private;2;30;;private void deleteForecasts(SearchResponse searchResponse, ActionListener<Boolean> listener) {     List<ForecastRequestStats> forecastsToDelete.     try {         forecastsToDelete = findForecastsToDelete(searchResponse).     } catch (IOException e) {         listener.onFailure(e).         return.     }     DeleteByQueryRequest request = buildDeleteByQuery(forecastsToDelete).     client.execute(DeleteByQueryAction.INSTANCE, request, new ActionListener<BulkByScrollResponse>() {          @Override         public void onResponse(BulkByScrollResponse bulkByScrollResponse) {             try {                 if (bulkByScrollResponse.getDeleted() > 0) {                     LOGGER.info("Deleted [{}] documents corresponding to [{}] expired forecasts", bulkByScrollResponse.getDeleted(), forecastsToDelete.size()).                 }                 listener.onResponse(true).             } catch (Exception e) {                 onFailure(e).             }         }          @Override         public void onFailure(Exception e) {             listener.onFailure(new ElasticsearchException("Failed to remove expired forecasts", e)).         }     }). }
false;private;1;20;;private List<ForecastRequestStats> findForecastsToDelete(SearchResponse searchResponse) throws IOException {     List<ForecastRequestStats> forecastsToDelete = new ArrayList<>().     SearchHits hits = searchResponse.getHits().     if (hits.getTotalHits().value > MAX_FORECASTS) {         LOGGER.info("More than [{}] forecasts were found. This run will only delete [{}] of them", MAX_FORECASTS, MAX_FORECASTS).     }     for (SearchHit hit : hits.getHits()) {         try (InputStream stream = hit.getSourceRef().streamInput().             XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {             ForecastRequestStats forecastRequestStats = ForecastRequestStats.LENIENT_PARSER.apply(parser, null).             if (forecastRequestStats.getExpiryTime().toEpochMilli() < cutoffEpochMs) {                 forecastsToDelete.add(forecastRequestStats).             }         }     }     return forecastsToDelete. }
false;private;1;17;;private DeleteByQueryRequest buildDeleteByQuery(List<ForecastRequestStats> forecastsToDelete) {     DeleteByQueryRequest request = new DeleteByQueryRequest().     request.setSlices(5).     request.indices(RESULTS_INDEX_PATTERN).     BoolQueryBuilder boolQuery = QueryBuilders.boolQuery().minimumShouldMatch(1).     boolQuery.must(QueryBuilders.termsQuery(Result.RESULT_TYPE.getPreferredName(), ForecastRequestStats.RESULT_TYPE_VALUE, Forecast.RESULT_TYPE_VALUE)).     for (ForecastRequestStats forecastToDelete : forecastsToDelete) {         boolQuery.should(QueryBuilders.boolQuery().must(QueryBuilders.termQuery(Job.ID.getPreferredName(), forecastToDelete.getJobId())).must(QueryBuilders.termQuery(Forecast.FORECAST_ID.getPreferredName(), forecastToDelete.getForecastId()))).     }     QueryBuilder query = QueryBuilders.boolQuery().filter(boolQuery).     request.setQuery(query).     return request. }
