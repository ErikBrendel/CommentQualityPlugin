# id;timestamp;commentText;codeText;commentWords;codeWords
JobConfigProvider -> public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener);1545155131;Sets the job's {@code deleting} field to true_@param jobId     The job to mark as deleting_@param listener  Responds with true if successful else an error;public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener) {_        UpdateRequest updateRequest = new UpdateRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        updateRequest.retryOnConflict(3)__        updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)__        updateRequest.doc(Collections.singletonMap(Job.DELETING.getPreferredName(), Boolean.TRUE))___        executeAsyncWithOrigin(client, ML_ORIGIN, UpdateAction.INSTANCE, updateRequest, ActionListener.wrap(_               response -> {_                   assert (response.getResult() == DocWriteResponse.Result.UPDATED) ||_                           (response.getResult() == DocWriteResponse.Result.NOOP)__                   listener.onResponse(Boolean.TRUE)__               },_               e -> {_                   ElasticsearchException[] causes = ElasticsearchException.guessRootCauses(e)__                   if (causes[0] instanceof DocumentMissingException) {_                       listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                   } else {_                       listener.onFailure(e)__                   }_               }_        ))__    };sets,the,job,s,code,deleting,field,to,true,param,job,id,the,job,to,mark,as,deleting,param,listener,responds,with,true,if,successful,else,an,error;public,void,mark,job,as,deleting,string,job,id,action,listener,boolean,listener,update,request,update,request,new,update,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,update,request,retry,on,conflict,3,update,request,set,refresh,policy,write,request,refresh,policy,immediate,update,request,doc,collections,singleton,map,job,deleting,get,preferred,name,boolean,true,execute,async,with,origin,client,update,action,instance,update,request,action,listener,wrap,response,assert,response,get,result,doc,write,response,result,updated,response,get,result,doc,write,response,result,noop,listener,on,response,boolean,true,e,elasticsearch,exception,causes,elasticsearch,exception,guess,root,causes,e,if,causes,0,instanceof,document,missing,exception,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,failure,e
JobConfigProvider -> public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener);1545227023;Sets the job's {@code deleting} field to true_@param jobId     The job to mark as deleting_@param listener  Responds with true if successful else an error;public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener) {_        UpdateRequest updateRequest = new UpdateRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        updateRequest.retryOnConflict(3)__        updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)__        updateRequest.doc(Collections.singletonMap(Job.DELETING.getPreferredName(), Boolean.TRUE))___        executeAsyncWithOrigin(client, ML_ORIGIN, UpdateAction.INSTANCE, updateRequest, ActionListener.wrap(_               response -> {_                   assert (response.getResult() == DocWriteResponse.Result.UPDATED) ||_                           (response.getResult() == DocWriteResponse.Result.NOOP)__                   listener.onResponse(Boolean.TRUE)__               },_               e -> {_                   ElasticsearchException[] causes = ElasticsearchException.guessRootCauses(e)__                   if (causes[0] instanceof DocumentMissingException) {_                       listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                   } else {_                       listener.onFailure(e)__                   }_               }_        ))__    };sets,the,job,s,code,deleting,field,to,true,param,job,id,the,job,to,mark,as,deleting,param,listener,responds,with,true,if,successful,else,an,error;public,void,mark,job,as,deleting,string,job,id,action,listener,boolean,listener,update,request,update,request,new,update,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,update,request,retry,on,conflict,3,update,request,set,refresh,policy,write,request,refresh,policy,immediate,update,request,doc,collections,singleton,map,job,deleting,get,preferred,name,boolean,true,execute,async,with,origin,client,update,action,instance,update,request,action,listener,wrap,response,assert,response,get,result,doc,write,response,result,updated,response,get,result,doc,write,response,result,noop,listener,on,response,boolean,true,e,elasticsearch,exception,causes,elasticsearch,exception,guess,root,causes,e,if,causes,0,instanceof,document,missing,exception,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,failure,e
JobConfigProvider -> public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener);1547572798;Sets the job's {@code deleting} field to true_@param jobId     The job to mark as deleting_@param listener  Responds with true if successful else an error;public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener) {_        UpdateRequest updateRequest = new UpdateRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        updateRequest.retryOnConflict(3)__        updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)__        updateRequest.doc(Collections.singletonMap(Job.DELETING.getPreferredName(), Boolean.TRUE))___        executeAsyncWithOrigin(client, ML_ORIGIN, UpdateAction.INSTANCE, updateRequest, ActionListener.wrap(_               response -> {_                   assert (response.getResult() == DocWriteResponse.Result.UPDATED) ||_                           (response.getResult() == DocWriteResponse.Result.NOOP)__                   listener.onResponse(Boolean.TRUE)__               },_               e -> {_                   ElasticsearchException[] causes = ElasticsearchException.guessRootCauses(e)__                   if (causes[0] instanceof DocumentMissingException) {_                       listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                   } else {_                       listener.onFailure(e)__                   }_               }_        ))__    };sets,the,job,s,code,deleting,field,to,true,param,job,id,the,job,to,mark,as,deleting,param,listener,responds,with,true,if,successful,else,an,error;public,void,mark,job,as,deleting,string,job,id,action,listener,boolean,listener,update,request,update,request,new,update,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,update,request,retry,on,conflict,3,update,request,set,refresh,policy,write,request,refresh,policy,immediate,update,request,doc,collections,singleton,map,job,deleting,get,preferred,name,boolean,true,execute,async,with,origin,client,update,action,instance,update,request,action,listener,wrap,response,assert,response,get,result,doc,write,response,result,updated,response,get,result,doc,write,response,result,noop,listener,on,response,boolean,true,e,elasticsearch,exception,causes,elasticsearch,exception,guess,root,causes,e,if,causes,0,instanceof,document,missing,exception,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,failure,e
JobConfigProvider -> public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener);1548840711;Sets the job's {@code deleting} field to true_@param jobId     The job to mark as deleting_@param listener  Responds with true if successful else an error;public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener) {_        UpdateRequest updateRequest = new UpdateRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        updateRequest.retryOnConflict(3)__        updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)__        updateRequest.doc(Collections.singletonMap(Job.DELETING.getPreferredName(), Boolean.TRUE))___        executeAsyncWithOrigin(client, ML_ORIGIN, UpdateAction.INSTANCE, updateRequest, ActionListener.wrap(_               response -> {_                   assert (response.getResult() == DocWriteResponse.Result.UPDATED) ||_                           (response.getResult() == DocWriteResponse.Result.NOOP)__                   listener.onResponse(Boolean.TRUE)__               },_               e -> {_                   ElasticsearchException[] causes = ElasticsearchException.guessRootCauses(e)__                   if (causes[0] instanceof DocumentMissingException) {_                       listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                   } else {_                       listener.onFailure(e)__                   }_               }_        ))__    };sets,the,job,s,code,deleting,field,to,true,param,job,id,the,job,to,mark,as,deleting,param,listener,responds,with,true,if,successful,else,an,error;public,void,mark,job,as,deleting,string,job,id,action,listener,boolean,listener,update,request,update,request,new,update,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,update,request,retry,on,conflict,3,update,request,set,refresh,policy,write,request,refresh,policy,immediate,update,request,doc,collections,singleton,map,job,deleting,get,preferred,name,boolean,true,execute,async,with,origin,client,update,action,instance,update,request,action,listener,wrap,response,assert,response,get,result,doc,write,response,result,updated,response,get,result,doc,write,response,result,noop,listener,on,response,boolean,true,e,elasticsearch,exception,causes,elasticsearch,exception,guess,root,causes,e,if,causes,0,instanceof,document,missing,exception,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,failure,e
JobConfigProvider -> public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener);1549273268;Sets the job's {@code deleting} field to true_@param jobId     The job to mark as deleting_@param listener  Responds with true if successful else an error;public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener) {_        UpdateRequest updateRequest = new UpdateRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        updateRequest.retryOnConflict(3)__        updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)__        updateRequest.doc(Collections.singletonMap(Job.DELETING.getPreferredName(), Boolean.TRUE))___        executeAsyncWithOrigin(client, ML_ORIGIN, UpdateAction.INSTANCE, updateRequest, ActionListener.wrap(_               response -> {_                   assert (response.getResult() == DocWriteResponse.Result.UPDATED) ||_                           (response.getResult() == DocWriteResponse.Result.NOOP)__                   listener.onResponse(Boolean.TRUE)__               },_               e -> {_                   ElasticsearchException[] causes = ElasticsearchException.guessRootCauses(e)__                   if (causes[0] instanceof DocumentMissingException) {_                       listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                   } else {_                       listener.onFailure(e)__                   }_               }_        ))__    };sets,the,job,s,code,deleting,field,to,true,param,job,id,the,job,to,mark,as,deleting,param,listener,responds,with,true,if,successful,else,an,error;public,void,mark,job,as,deleting,string,job,id,action,listener,boolean,listener,update,request,update,request,new,update,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,update,request,retry,on,conflict,3,update,request,set,refresh,policy,write,request,refresh,policy,immediate,update,request,doc,collections,singleton,map,job,deleting,get,preferred,name,boolean,true,execute,async,with,origin,client,update,action,instance,update,request,action,listener,wrap,response,assert,response,get,result,doc,write,response,result,updated,response,get,result,doc,write,response,result,noop,listener,on,response,boolean,true,e,elasticsearch,exception,causes,elasticsearch,exception,guess,root,causes,e,if,causes,0,instanceof,document,missing,exception,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,failure,e
JobConfigProvider -> public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener);1549396415;Sets the job's {@code deleting} field to true_@param jobId     The job to mark as deleting_@param listener  Responds with true if successful else an error;public void markJobAsDeleting(String jobId, ActionListener<Boolean> listener) {_        UpdateRequest updateRequest = new UpdateRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        updateRequest.retryOnConflict(3)__        updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)__        updateRequest.doc(Collections.singletonMap(Job.DELETING.getPreferredName(), Boolean.TRUE))___        executeAsyncWithOrigin(client, ML_ORIGIN, UpdateAction.INSTANCE, updateRequest, ActionListener.wrap(_               response -> {_                   assert (response.getResult() == DocWriteResponse.Result.UPDATED) ||_                           (response.getResult() == DocWriteResponse.Result.NOOP)__                   listener.onResponse(Boolean.TRUE)__               },_               e -> {_                   ElasticsearchException[] causes = ElasticsearchException.guessRootCauses(e)__                   if (causes[0] instanceof DocumentMissingException) {_                       listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                   } else {_                       listener.onFailure(e)__                   }_               }_        ))__    };sets,the,job,s,code,deleting,field,to,true,param,job,id,the,job,to,mark,as,deleting,param,listener,responds,with,true,if,successful,else,an,error;public,void,mark,job,as,deleting,string,job,id,action,listener,boolean,listener,update,request,update,request,new,update,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,update,request,retry,on,conflict,3,update,request,set,refresh,policy,write,request,refresh,policy,immediate,update,request,doc,collections,singleton,map,job,deleting,get,preferred,name,boolean,true,execute,async,with,origin,client,update,action,instance,update,request,action,listener,wrap,response,assert,response,get,result,doc,write,response,result,updated,response,get,result,doc,write,response,result,noop,listener,on,response,boolean,true,e,elasticsearch,exception,causes,elasticsearch,exception,guess,root,causes,e,if,causes,0,instanceof,document,missing,exception,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,failure,e
JobConfigProvider -> public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener);1545155131;The same logic as {@link #expandJobsIds(String, boolean, boolean, ActionListener)} but_the full anomaly detector job configuration is returned.__See {@link #expandJobsIds(String, boolean, boolean, ActionListener)}__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded jobs listener;public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(searchSize)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job.Builder> jobs = new ArrayList<>()__                            Set<String> jobAndGroupIds = new HashSet<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job.Builder job = parseJobLenientlyFromSource(source)__                                    jobs.add(job)__                                    jobAndGroupIds.add(job.getId())__                                    jobAndGroupIds.addAll(job.getGroups())__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            requiredMatches.filterMatchedIds(jobAndGroupIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)___    };the,same,logic,as,link,expand,jobs,ids,string,boolean,boolean,action,listener,but,the,full,anomaly,detector,job,configuration,is,returned,see,link,expand,jobs,ids,string,boolean,boolean,action,listener,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,jobs,listener;public,void,expand,jobs,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,list,job,builder,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,search,size,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,builder,jobs,new,array,list,set,string,job,and,group,ids,new,hash,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,builder,job,parse,job,leniently,from,source,source,jobs,add,job,job,and,group,ids,add,job,get,id,job,and,group,ids,add,all,job,get,groups,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,required,matches,filter,matched,ids,job,and,group,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener);1545227023;The same logic as {@link #expandJobsIds(String, boolean, boolean, ActionListener)} but_the full anomaly detector job configuration is returned.__See {@link #expandJobsIds(String, boolean, boolean, ActionListener)}__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded jobs listener;public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job.Builder> jobs = new ArrayList<>()__                            Set<String> jobAndGroupIds = new HashSet<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job.Builder job = parseJobLenientlyFromSource(source)__                                    jobs.add(job)__                                    jobAndGroupIds.add(job.getId())__                                    jobAndGroupIds.addAll(job.getGroups())__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            requiredMatches.filterMatchedIds(jobAndGroupIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)___    };the,same,logic,as,link,expand,jobs,ids,string,boolean,boolean,action,listener,but,the,full,anomaly,detector,job,configuration,is,returned,see,link,expand,jobs,ids,string,boolean,boolean,action,listener,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,jobs,listener;public,void,expand,jobs,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,list,job,builder,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,builder,jobs,new,array,list,set,string,job,and,group,ids,new,hash,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,builder,job,parse,job,leniently,from,source,source,jobs,add,job,job,and,group,ids,add,job,get,id,job,and,group,ids,add,all,job,get,groups,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,required,matches,filter,matched,ids,job,and,group,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener);1547572798;The same logic as {@link #expandJobsIds(String, boolean, boolean, ActionListener)} but_the full anomaly detector job configuration is returned.__See {@link #expandJobsIds(String, boolean, boolean, ActionListener)}__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded jobs listener;public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job.Builder> jobs = new ArrayList<>()__                            Set<String> jobAndGroupIds = new HashSet<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job.Builder job = parseJobLenientlyFromSource(source)__                                    jobs.add(job)__                                    jobAndGroupIds.add(job.getId())__                                    jobAndGroupIds.addAll(job.getGroups())__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            requiredMatches.filterMatchedIds(jobAndGroupIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)___    };the,same,logic,as,link,expand,jobs,ids,string,boolean,boolean,action,listener,but,the,full,anomaly,detector,job,configuration,is,returned,see,link,expand,jobs,ids,string,boolean,boolean,action,listener,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,jobs,listener;public,void,expand,jobs,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,list,job,builder,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,builder,jobs,new,array,list,set,string,job,and,group,ids,new,hash,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,builder,job,parse,job,leniently,from,source,source,jobs,add,job,job,and,group,ids,add,job,get,id,job,and,group,ids,add,all,job,get,groups,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,required,matches,filter,matched,ids,job,and,group,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener);1548840711;The same logic as {@link #expandJobsIds(String, boolean, boolean, ActionListener)} but_the full anomaly detector job configuration is returned.__See {@link #expandJobsIds(String, boolean, boolean, ActionListener)}__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded jobs listener;public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job.Builder> jobs = new ArrayList<>()__                            Set<String> jobAndGroupIds = new HashSet<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job.Builder job = parseJobLenientlyFromSource(source)__                                    jobs.add(job)__                                    jobAndGroupIds.add(job.getId())__                                    jobAndGroupIds.addAll(job.getGroups())__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            requiredMatches.filterMatchedIds(jobAndGroupIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)___    };the,same,logic,as,link,expand,jobs,ids,string,boolean,boolean,action,listener,but,the,full,anomaly,detector,job,configuration,is,returned,see,link,expand,jobs,ids,string,boolean,boolean,action,listener,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,jobs,listener;public,void,expand,jobs,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,list,job,builder,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,builder,jobs,new,array,list,set,string,job,and,group,ids,new,hash,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,builder,job,parse,job,leniently,from,source,source,jobs,add,job,job,and,group,ids,add,job,get,id,job,and,group,ids,add,all,job,get,groups,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,required,matches,filter,matched,ids,job,and,group,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener);1549273268;The same logic as {@link #expandJobsIds(String, boolean, boolean, ActionListener)} but_the full anomaly detector job configuration is returned.__See {@link #expandJobsIds(String, boolean, boolean, ActionListener)}__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded jobs listener;public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job.Builder> jobs = new ArrayList<>()__                            Set<String> jobAndGroupIds = new HashSet<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job.Builder job = parseJobLenientlyFromSource(source)__                                    jobs.add(job)__                                    jobAndGroupIds.add(job.getId())__                                    jobAndGroupIds.addAll(job.getGroups())__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            requiredMatches.filterMatchedIds(jobAndGroupIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)___    };the,same,logic,as,link,expand,jobs,ids,string,boolean,boolean,action,listener,but,the,full,anomaly,detector,job,configuration,is,returned,see,link,expand,jobs,ids,string,boolean,boolean,action,listener,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,jobs,listener;public,void,expand,jobs,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,list,job,builder,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,builder,jobs,new,array,list,set,string,job,and,group,ids,new,hash,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,builder,job,parse,job,leniently,from,source,source,jobs,add,job,job,and,group,ids,add,job,get,id,job,and,group,ids,add,all,job,get,groups,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,required,matches,filter,matched,ids,job,and,group,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener);1549396415;The same logic as {@link #expandJobsIds(String, boolean, boolean, ActionListener)} but_the full anomaly detector job configuration is returned.__See {@link #expandJobsIds(String, boolean, boolean, ActionListener)}__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded jobs listener;public void expandJobs(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<List<Job.Builder>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job.Builder> jobs = new ArrayList<>()__                            Set<String> jobAndGroupIds = new HashSet<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job.Builder job = parseJobLenientlyFromSource(source)__                                    jobs.add(job)__                                    jobAndGroupIds.add(job.getId())__                                    jobAndGroupIds.addAll(job.getGroups())__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            requiredMatches.filterMatchedIds(jobAndGroupIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)___    };the,same,logic,as,link,expand,jobs,ids,string,boolean,boolean,action,listener,but,the,full,anomaly,detector,job,configuration,is,returned,see,link,expand,jobs,ids,string,boolean,boolean,action,listener,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,jobs,listener;public,void,expand,jobs,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,list,job,builder,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,builder,jobs,new,array,list,set,string,job,and,group,ids,new,hash,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,builder,job,parse,job,leniently,from,source,source,jobs,add,job,job,and,group,ids,add,job,get,id,job,and,group,ids,add,all,job,get,groups,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,required,matches,filter,matched,ids,job,and,group,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener);1545155131;For the list of job Ids find all that match existing jobs Ids._The repsonse is all the job Ids in {@code ids} that match an existing_job Id._@param ids Job Ids to find_@param listener The matched Ids listener;public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermsQueryBuilder(Job.ID.getPreferredName(), ids))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(ids.size())_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SearchHit[] hits = response.getHits().getHits()__                            List<String> matchedIds = new ArrayList<>()__                            for (SearchHit hit : hits) {_                                matchedIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }_                            listener.onResponse(matchedIds)__                        },_                        listener::onFailure)_                , client::search)__    };for,the,list,of,job,ids,find,all,that,match,existing,jobs,ids,the,repsonse,is,all,the,job,ids,in,code,ids,that,match,an,existing,job,id,param,ids,job,ids,to,find,param,listener,the,matched,ids,listener;public,void,job,id,matches,list,string,ids,action,listener,list,string,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,terms,query,builder,job,id,get,preferred,name,ids,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,doc,value,fields,context,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,ids,size,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,search,hit,hits,response,get,hits,get,hits,list,string,matched,ids,new,array,list,for,search,hit,hit,hits,matched,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,matched,ids,listener,on,failure,client,search
JobConfigProvider -> public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener);1545227023;For the list of job Ids find all that match existing jobs Ids._The repsonse is all the job Ids in {@code ids} that match an existing_job Id._@param ids Job Ids to find_@param listener The matched Ids listener;public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermsQueryBuilder(Job.ID.getPreferredName(), ids))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(ids.size())_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SearchHit[] hits = response.getHits().getHits()__                            List<String> matchedIds = new ArrayList<>()__                            for (SearchHit hit : hits) {_                                matchedIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }_                            listener.onResponse(matchedIds)__                        },_                        listener::onFailure)_                , client::search)__    };for,the,list,of,job,ids,find,all,that,match,existing,jobs,ids,the,repsonse,is,all,the,job,ids,in,code,ids,that,match,an,existing,job,id,param,ids,job,ids,to,find,param,listener,the,matched,ids,listener;public,void,job,id,matches,list,string,ids,action,listener,list,string,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,terms,query,builder,job,id,get,preferred,name,ids,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,doc,value,fields,context,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,ids,size,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,search,hit,hits,response,get,hits,get,hits,list,string,matched,ids,new,array,list,for,search,hit,hit,hits,matched,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,matched,ids,listener,on,failure,client,search
JobConfigProvider -> public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener);1547572798;For the list of job Ids find all that match existing jobs Ids._The repsonse is all the job Ids in {@code ids} that match an existing_job Id._@param ids Job Ids to find_@param listener The matched Ids listener;public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermsQueryBuilder(Job.ID.getPreferredName(), ids))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(ids.size())_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SearchHit[] hits = response.getHits().getHits()__                            List<String> matchedIds = new ArrayList<>()__                            for (SearchHit hit : hits) {_                                matchedIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }_                            listener.onResponse(matchedIds)__                        },_                        listener::onFailure)_                , client::search)__    };for,the,list,of,job,ids,find,all,that,match,existing,jobs,ids,the,repsonse,is,all,the,job,ids,in,code,ids,that,match,an,existing,job,id,param,ids,job,ids,to,find,param,listener,the,matched,ids,listener;public,void,job,id,matches,list,string,ids,action,listener,list,string,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,terms,query,builder,job,id,get,preferred,name,ids,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,doc,value,fields,context,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,ids,size,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,search,hit,hits,response,get,hits,get,hits,list,string,matched,ids,new,array,list,for,search,hit,hit,hits,matched,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,matched,ids,listener,on,failure,client,search
JobConfigProvider -> public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener);1548840711;For the list of job Ids find all that match existing jobs Ids._The repsonse is all the job Ids in {@code ids} that match an existing_job Id._@param ids Job Ids to find_@param listener The matched Ids listener;public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermsQueryBuilder(Job.ID.getPreferredName(), ids))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), null)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(ids.size())_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SearchHit[] hits = response.getHits().getHits()__                            List<String> matchedIds = new ArrayList<>()__                            for (SearchHit hit : hits) {_                                matchedIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }_                            listener.onResponse(matchedIds)__                        },_                        listener::onFailure)_                , client::search)__    };for,the,list,of,job,ids,find,all,that,match,existing,jobs,ids,the,repsonse,is,all,the,job,ids,in,code,ids,that,match,an,existing,job,id,param,ids,job,ids,to,find,param,listener,the,matched,ids,listener;public,void,job,id,matches,list,string,ids,action,listener,list,string,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,terms,query,builder,job,id,get,preferred,name,ids,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,null,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,ids,size,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,search,hit,hits,response,get,hits,get,hits,list,string,matched,ids,new,array,list,for,search,hit,hit,hits,matched,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,matched,ids,listener,on,failure,client,search
JobConfigProvider -> public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener);1549273268;For the list of job Ids find all that match existing jobs Ids._The repsonse is all the job Ids in {@code ids} that match an existing_job Id._@param ids Job Ids to find_@param listener The matched Ids listener;public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermsQueryBuilder(Job.ID.getPreferredName(), ids))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), null)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(ids.size())_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SearchHit[] hits = response.getHits().getHits()__                            List<String> matchedIds = new ArrayList<>()__                            for (SearchHit hit : hits) {_                                matchedIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }_                            listener.onResponse(matchedIds)__                        },_                        listener::onFailure)_                , client::search)__    };for,the,list,of,job,ids,find,all,that,match,existing,jobs,ids,the,repsonse,is,all,the,job,ids,in,code,ids,that,match,an,existing,job,id,param,ids,job,ids,to,find,param,listener,the,matched,ids,listener;public,void,job,id,matches,list,string,ids,action,listener,list,string,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,terms,query,builder,job,id,get,preferred,name,ids,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,null,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,ids,size,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,search,hit,hits,response,get,hits,get,hits,list,string,matched,ids,new,array,list,for,search,hit,hit,hits,matched,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,matched,ids,listener,on,failure,client,search
JobConfigProvider -> public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener);1549396415;For the list of job Ids find all that match existing jobs Ids._The repsonse is all the job Ids in {@code ids} that match an existing_job Id._@param ids Job Ids to find_@param listener The matched Ids listener;public void jobIdMatches(List<String> ids, ActionListener<List<String>> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermsQueryBuilder(Job.ID.getPreferredName(), ids))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), null)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(ids.size())_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SearchHit[] hits = response.getHits().getHits()__                            List<String> matchedIds = new ArrayList<>()__                            for (SearchHit hit : hits) {_                                matchedIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }_                            listener.onResponse(matchedIds)__                        },_                        listener::onFailure)_                , client::search)__    };for,the,list,of,job,ids,find,all,that,match,existing,jobs,ids,the,repsonse,is,all,the,job,ids,in,code,ids,that,match,an,existing,job,id,param,ids,job,ids,to,find,param,listener,the,matched,ids,listener;public,void,job,id,matches,list,string,ids,action,listener,list,string,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,terms,query,builder,job,id,get,preferred,name,ids,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,null,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,ids,size,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,search,hit,hits,response,get,hits,get,hits,list,string,matched,ids,new,array,list,for,search,hit,hit,hits,matched,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,matched,ids,listener,on,failure,client,search
JobConfigProvider -> public void findJobsWithCustomRules(ActionListener<List<Job>> listener);1545155131;Find jobs with custom rules defined._@param listener Jobs listener;public void findJobsWithCustomRules(ActionListener<List<Job>> listener) {_        String customRulesPath = Strings.collectionToDelimitedString(Arrays.asList(Job.ANALYSIS_CONFIG.getPreferredName(),_                AnalysisConfig.DETECTORS.getPreferredName(), Detector.CUSTOM_RULES_FIELD.getPreferredName()), ".")__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(QueryBuilders.nestedQuery(customRulesPath, QueryBuilders.existsQuery(customRulesPath), ScoreMode.None))___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(searchSize)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job> jobs = new ArrayList<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job job = parseJobLenientlyFromSource(source).build()__                                    jobs.add(job)__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)__    };find,jobs,with,custom,rules,defined,param,listener,jobs,listener;public,void,find,jobs,with,custom,rules,action,listener,list,job,listener,string,custom,rules,path,strings,collection,to,delimited,string,arrays,as,list,job,get,preferred,name,analysis,config,detectors,get,preferred,name,detector,get,preferred,name,search,source,builder,source,builder,new,search,source,builder,query,query,builders,nested,query,custom,rules,path,query,builders,exists,query,custom,rules,path,score,mode,none,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,search,size,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,jobs,new,array,list,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,job,parse,job,leniently,from,source,source,build,jobs,add,job,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void findJobsWithCustomRules(ActionListener<List<Job>> listener);1545227023;Find jobs with custom rules defined._@param listener Jobs listener;public void findJobsWithCustomRules(ActionListener<List<Job>> listener) {_        String customRulesPath = Strings.collectionToDelimitedString(Arrays.asList(Job.ANALYSIS_CONFIG.getPreferredName(),_                AnalysisConfig.DETECTORS.getPreferredName(), Detector.CUSTOM_RULES_FIELD.getPreferredName()), ".")__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(QueryBuilders.nestedQuery(customRulesPath, QueryBuilders.existsQuery(customRulesPath), ScoreMode.None))___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job> jobs = new ArrayList<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job job = parseJobLenientlyFromSource(source).build()__                                    jobs.add(job)__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)__    };find,jobs,with,custom,rules,defined,param,listener,jobs,listener;public,void,find,jobs,with,custom,rules,action,listener,list,job,listener,string,custom,rules,path,strings,collection,to,delimited,string,arrays,as,list,job,get,preferred,name,analysis,config,detectors,get,preferred,name,detector,get,preferred,name,search,source,builder,source,builder,new,search,source,builder,query,query,builders,nested,query,custom,rules,path,query,builders,exists,query,custom,rules,path,score,mode,none,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,jobs,new,array,list,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,job,parse,job,leniently,from,source,source,build,jobs,add,job,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void findJobsWithCustomRules(ActionListener<List<Job>> listener);1547572798;Find jobs with custom rules defined._@param listener Jobs listener;public void findJobsWithCustomRules(ActionListener<List<Job>> listener) {_        String customRulesPath = Strings.collectionToDelimitedString(Arrays.asList(Job.ANALYSIS_CONFIG.getPreferredName(),_                AnalysisConfig.DETECTORS.getPreferredName(), Detector.CUSTOM_RULES_FIELD.getPreferredName()), ".")__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(QueryBuilders.nestedQuery(customRulesPath, QueryBuilders.existsQuery(customRulesPath), ScoreMode.None))___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job> jobs = new ArrayList<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job job = parseJobLenientlyFromSource(source).build()__                                    jobs.add(job)__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)__    };find,jobs,with,custom,rules,defined,param,listener,jobs,listener;public,void,find,jobs,with,custom,rules,action,listener,list,job,listener,string,custom,rules,path,strings,collection,to,delimited,string,arrays,as,list,job,get,preferred,name,analysis,config,detectors,get,preferred,name,detector,get,preferred,name,search,source,builder,source,builder,new,search,source,builder,query,query,builders,nested,query,custom,rules,path,query,builders,exists,query,custom,rules,path,score,mode,none,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,jobs,new,array,list,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,job,parse,job,leniently,from,source,source,build,jobs,add,job,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void findJobsWithCustomRules(ActionListener<List<Job>> listener);1548840711;Find jobs with custom rules defined._@param listener Jobs listener;public void findJobsWithCustomRules(ActionListener<List<Job>> listener) {_        String customRulesPath = Strings.collectionToDelimitedString(Arrays.asList(Job.ANALYSIS_CONFIG.getPreferredName(),_                AnalysisConfig.DETECTORS.getPreferredName(), Detector.CUSTOM_RULES_FIELD.getPreferredName()), ".")__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(QueryBuilders.nestedQuery(customRulesPath, QueryBuilders.existsQuery(customRulesPath), ScoreMode.None))___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job> jobs = new ArrayList<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job job = parseJobLenientlyFromSource(source).build()__                                    jobs.add(job)__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)__    };find,jobs,with,custom,rules,defined,param,listener,jobs,listener;public,void,find,jobs,with,custom,rules,action,listener,list,job,listener,string,custom,rules,path,strings,collection,to,delimited,string,arrays,as,list,job,get,preferred,name,analysis,config,detectors,get,preferred,name,detector,get,preferred,name,search,source,builder,source,builder,new,search,source,builder,query,query,builders,nested,query,custom,rules,path,query,builders,exists,query,custom,rules,path,score,mode,none,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,jobs,new,array,list,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,job,parse,job,leniently,from,source,source,build,jobs,add,job,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void findJobsWithCustomRules(ActionListener<List<Job>> listener);1549273268;Find jobs with custom rules defined._@param listener Jobs listener;public void findJobsWithCustomRules(ActionListener<List<Job>> listener) {_        String customRulesPath = Strings.collectionToDelimitedString(Arrays.asList(Job.ANALYSIS_CONFIG.getPreferredName(),_                AnalysisConfig.DETECTORS.getPreferredName(), Detector.CUSTOM_RULES_FIELD.getPreferredName()), ".")__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(QueryBuilders.nestedQuery(customRulesPath, QueryBuilders.existsQuery(customRulesPath), ScoreMode.None))___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job> jobs = new ArrayList<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job job = parseJobLenientlyFromSource(source).build()__                                    jobs.add(job)__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)__    };find,jobs,with,custom,rules,defined,param,listener,jobs,listener;public,void,find,jobs,with,custom,rules,action,listener,list,job,listener,string,custom,rules,path,strings,collection,to,delimited,string,arrays,as,list,job,get,preferred,name,analysis,config,detectors,get,preferred,name,detector,get,preferred,name,search,source,builder,source,builder,new,search,source,builder,query,query,builders,nested,query,custom,rules,path,query,builders,exists,query,custom,rules,path,score,mode,none,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,jobs,new,array,list,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,job,parse,job,leniently,from,source,source,build,jobs,add,job,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void findJobsWithCustomRules(ActionListener<List<Job>> listener);1549396415;Find jobs with custom rules defined._@param listener Jobs listener;public void findJobsWithCustomRules(ActionListener<List<Job>> listener) {_        String customRulesPath = Strings.collectionToDelimitedString(Arrays.asList(Job.ANALYSIS_CONFIG.getPreferredName(),_                AnalysisConfig.DETECTORS.getPreferredName(), Detector.CUSTOM_RULES_FIELD.getPreferredName()), ".")__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(QueryBuilders.nestedQuery(customRulesPath, QueryBuilders.existsQuery(customRulesPath), ScoreMode.None))___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            List<Job> jobs = new ArrayList<>()___                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                try {_                                    BytesReference source = hit.getSourceRef()__                                    Job job = parseJobLenientlyFromSource(source).build()__                                    jobs.add(job)__                                } catch (IOException e) {_                                    _                                    logger.error("Error parsing anomaly detector job configuration [" + hit.getId() + "]", e)__                                }_                            }__                            listener.onResponse(jobs)__                        },_                        listener::onFailure)_                , client::search)__    };find,jobs,with,custom,rules,defined,param,listener,jobs,listener;public,void,find,jobs,with,custom,rules,action,listener,list,job,listener,string,custom,rules,path,strings,collection,to,delimited,string,arrays,as,list,job,get,preferred,name,analysis,config,detectors,get,preferred,name,detector,get,preferred,name,search,source,builder,source,builder,new,search,source,builder,query,query,builders,nested,query,custom,rules,path,query,builders,exists,query,custom,rules,path,score,mode,none,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,list,job,jobs,new,array,list,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,try,bytes,reference,source,hit,get,source,ref,job,job,parse,job,leniently,from,source,source,build,jobs,add,job,catch,ioexception,e,logger,error,error,parsing,anomaly,detector,job,configuration,hit,get,id,e,listener,on,response,jobs,listener,on,failure,client,search
JobConfigProvider -> public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,                                         UpdateValidator validator, ActionListener<Job> updatedJobListener);1545155131;Similar to {@link #updateJob(String, JobUpdate, ByteSizeValue, ActionListener)} but_with an extra validation step which is called before the updated is applied.__@param jobId The Id of the job to update_@param update The job update_@param maxModelMemoryLimit The maximum model memory allowed_@param validator The job update validator_@param updatedJobListener Updated job listener;public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,_                                        UpdateValidator validator, ActionListener<Job> updatedJobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    updatedJobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                long version = getResponse.getVersion()__                BytesReference source = getResponse.getSourceAsBytesRef()__                Job originalJob__                try {_                    originalJob = parseJobLenientlyFromSource(source).build()__                } catch (Exception e) {_                    updatedJobListener.onFailure(_                            new ElasticsearchParseException("Failed to parse job configuration [" + jobId + "]", e))__                    return__                }__                validator.validate(originalJob, update, ActionListener.wrap(_                        validated  -> {_                            Job updatedJob__                            try {_                                _                                updatedJob = update.mergeWithJob(originalJob, maxModelMemoryLimit)__                            } catch (Exception e) {_                                updatedJobListener.onFailure(e)__                                return__                            }__                            indexUpdatedJob(updatedJob, version, updatedJobListener)__                        },_                        updatedJobListener::onFailure_                ))__            }__            @Override_            public void onFailure(Exception e) {_                updatedJobListener.onFailure(e)__            }_        })__    };similar,to,link,update,job,string,job,update,byte,size,value,action,listener,but,with,an,extra,validation,step,which,is,called,before,the,updated,is,applied,param,job,id,the,id,of,the,job,to,update,param,update,the,job,update,param,max,model,memory,limit,the,maximum,model,memory,allowed,param,validator,the,job,update,validator,param,updated,job,listener,updated,job,listener;public,void,update,job,with,validation,string,job,id,job,update,update,byte,size,value,max,model,memory,limit,update,validator,validator,action,listener,job,updated,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,updated,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,long,version,get,response,get,version,bytes,reference,source,get,response,get,source,as,bytes,ref,job,original,job,try,original,job,parse,job,leniently,from,source,source,build,catch,exception,e,updated,job,listener,on,failure,new,elasticsearch,parse,exception,failed,to,parse,job,configuration,job,id,e,return,validator,validate,original,job,update,action,listener,wrap,validated,job,updated,job,try,updated,job,update,merge,with,job,original,job,max,model,memory,limit,catch,exception,e,updated,job,listener,on,failure,e,return,index,updated,job,updated,job,version,updated,job,listener,updated,job,listener,on,failure,override,public,void,on,failure,exception,e,updated,job,listener,on,failure,e
JobConfigProvider -> public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,                                         UpdateValidator validator, ActionListener<Job> updatedJobListener);1545227023;Similar to {@link #updateJob(String, JobUpdate, ByteSizeValue, ActionListener)} but_with an extra validation step which is called before the updated is applied.__@param jobId The Id of the job to update_@param update The job update_@param maxModelMemoryLimit The maximum model memory allowed_@param validator The job update validator_@param updatedJobListener Updated job listener;public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,_                                        UpdateValidator validator, ActionListener<Job> updatedJobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    updatedJobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                long version = getResponse.getVersion()__                BytesReference source = getResponse.getSourceAsBytesRef()__                Job originalJob__                try {_                    originalJob = parseJobLenientlyFromSource(source).build()__                } catch (Exception e) {_                    updatedJobListener.onFailure(_                            new ElasticsearchParseException("Failed to parse job configuration [" + jobId + "]", e))__                    return__                }__                validator.validate(originalJob, update, ActionListener.wrap(_                        validated  -> {_                            Job updatedJob__                            try {_                                _                                updatedJob = update.mergeWithJob(originalJob, maxModelMemoryLimit)__                            } catch (Exception e) {_                                updatedJobListener.onFailure(e)__                                return__                            }__                            indexUpdatedJob(updatedJob, version, updatedJobListener)__                        },_                        updatedJobListener::onFailure_                ))__            }__            @Override_            public void onFailure(Exception e) {_                updatedJobListener.onFailure(e)__            }_        })__    };similar,to,link,update,job,string,job,update,byte,size,value,action,listener,but,with,an,extra,validation,step,which,is,called,before,the,updated,is,applied,param,job,id,the,id,of,the,job,to,update,param,update,the,job,update,param,max,model,memory,limit,the,maximum,model,memory,allowed,param,validator,the,job,update,validator,param,updated,job,listener,updated,job,listener;public,void,update,job,with,validation,string,job,id,job,update,update,byte,size,value,max,model,memory,limit,update,validator,validator,action,listener,job,updated,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,updated,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,long,version,get,response,get,version,bytes,reference,source,get,response,get,source,as,bytes,ref,job,original,job,try,original,job,parse,job,leniently,from,source,source,build,catch,exception,e,updated,job,listener,on,failure,new,elasticsearch,parse,exception,failed,to,parse,job,configuration,job,id,e,return,validator,validate,original,job,update,action,listener,wrap,validated,job,updated,job,try,updated,job,update,merge,with,job,original,job,max,model,memory,limit,catch,exception,e,updated,job,listener,on,failure,e,return,index,updated,job,updated,job,version,updated,job,listener,updated,job,listener,on,failure,override,public,void,on,failure,exception,e,updated,job,listener,on,failure,e
JobConfigProvider -> public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,                                         UpdateValidator validator, ActionListener<Job> updatedJobListener);1547572798;Similar to {@link #updateJob(String, JobUpdate, ByteSizeValue, ActionListener)} but_with an extra validation step which is called before the updated is applied.__@param jobId The Id of the job to update_@param update The job update_@param maxModelMemoryLimit The maximum model memory allowed_@param validator The job update validator_@param updatedJobListener Updated job listener;public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,_                                        UpdateValidator validator, ActionListener<Job> updatedJobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    updatedJobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                long version = getResponse.getVersion()__                BytesReference source = getResponse.getSourceAsBytesRef()__                Job originalJob__                try {_                    originalJob = parseJobLenientlyFromSource(source).build()__                } catch (Exception e) {_                    updatedJobListener.onFailure(_                            new ElasticsearchParseException("Failed to parse job configuration [" + jobId + "]", e))__                    return__                }__                validator.validate(originalJob, update, ActionListener.wrap(_                        validated  -> {_                            Job updatedJob__                            try {_                                _                                updatedJob = update.mergeWithJob(originalJob, maxModelMemoryLimit)__                            } catch (Exception e) {_                                updatedJobListener.onFailure(e)__                                return__                            }__                            indexUpdatedJob(updatedJob, version, updatedJobListener)__                        },_                        updatedJobListener::onFailure_                ))__            }__            @Override_            public void onFailure(Exception e) {_                updatedJobListener.onFailure(e)__            }_        })__    };similar,to,link,update,job,string,job,update,byte,size,value,action,listener,but,with,an,extra,validation,step,which,is,called,before,the,updated,is,applied,param,job,id,the,id,of,the,job,to,update,param,update,the,job,update,param,max,model,memory,limit,the,maximum,model,memory,allowed,param,validator,the,job,update,validator,param,updated,job,listener,updated,job,listener;public,void,update,job,with,validation,string,job,id,job,update,update,byte,size,value,max,model,memory,limit,update,validator,validator,action,listener,job,updated,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,updated,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,long,version,get,response,get,version,bytes,reference,source,get,response,get,source,as,bytes,ref,job,original,job,try,original,job,parse,job,leniently,from,source,source,build,catch,exception,e,updated,job,listener,on,failure,new,elasticsearch,parse,exception,failed,to,parse,job,configuration,job,id,e,return,validator,validate,original,job,update,action,listener,wrap,validated,job,updated,job,try,updated,job,update,merge,with,job,original,job,max,model,memory,limit,catch,exception,e,updated,job,listener,on,failure,e,return,index,updated,job,updated,job,version,updated,job,listener,updated,job,listener,on,failure,override,public,void,on,failure,exception,e,updated,job,listener,on,failure,e
JobConfigProvider -> public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,                                         UpdateValidator validator, ActionListener<Job> updatedJobListener);1548840711;Similar to {@link #updateJob(String, JobUpdate, ByteSizeValue, ActionListener)} but_with an extra validation step which is called before the updated is applied.__@param jobId The Id of the job to update_@param update The job update_@param maxModelMemoryLimit The maximum model memory allowed_@param validator The job update validator_@param updatedJobListener Updated job listener;public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,_                                        UpdateValidator validator, ActionListener<Job> updatedJobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    updatedJobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                long version = getResponse.getVersion()__                BytesReference source = getResponse.getSourceAsBytesRef()__                Job originalJob__                try {_                    originalJob = parseJobLenientlyFromSource(source).build()__                } catch (Exception e) {_                    updatedJobListener.onFailure(_                            new ElasticsearchParseException("Failed to parse job configuration [" + jobId + "]", e))__                    return__                }__                validator.validate(originalJob, update, ActionListener.wrap(_                        validated  -> {_                            Job updatedJob__                            try {_                                _                                updatedJob = update.mergeWithJob(originalJob, maxModelMemoryLimit)__                            } catch (Exception e) {_                                updatedJobListener.onFailure(e)__                                return__                            }__                            indexUpdatedJob(updatedJob, version, updatedJobListener)__                        },_                        updatedJobListener::onFailure_                ))__            }__            @Override_            public void onFailure(Exception e) {_                updatedJobListener.onFailure(e)__            }_        })__    };similar,to,link,update,job,string,job,update,byte,size,value,action,listener,but,with,an,extra,validation,step,which,is,called,before,the,updated,is,applied,param,job,id,the,id,of,the,job,to,update,param,update,the,job,update,param,max,model,memory,limit,the,maximum,model,memory,allowed,param,validator,the,job,update,validator,param,updated,job,listener,updated,job,listener;public,void,update,job,with,validation,string,job,id,job,update,update,byte,size,value,max,model,memory,limit,update,validator,validator,action,listener,job,updated,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,updated,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,long,version,get,response,get,version,bytes,reference,source,get,response,get,source,as,bytes,ref,job,original,job,try,original,job,parse,job,leniently,from,source,source,build,catch,exception,e,updated,job,listener,on,failure,new,elasticsearch,parse,exception,failed,to,parse,job,configuration,job,id,e,return,validator,validate,original,job,update,action,listener,wrap,validated,job,updated,job,try,updated,job,update,merge,with,job,original,job,max,model,memory,limit,catch,exception,e,updated,job,listener,on,failure,e,return,index,updated,job,updated,job,version,updated,job,listener,updated,job,listener,on,failure,override,public,void,on,failure,exception,e,updated,job,listener,on,failure,e
JobConfigProvider -> public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,                                         UpdateValidator validator, ActionListener<Job> updatedJobListener);1549396415;Similar to {@link #updateJob(String, JobUpdate, ByteSizeValue, ActionListener)} but_with an extra validation step which is called before the updated is applied.__@param jobId The Id of the job to update_@param update The job update_@param maxModelMemoryLimit The maximum model memory allowed_@param validator The job update validator_@param updatedJobListener Updated job listener;public void updateJobWithValidation(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit,_                                        UpdateValidator validator, ActionListener<Job> updatedJobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    updatedJobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                final long version = getResponse.getVersion()__                final long seqNo = getResponse.getSeqNo()__                final long primaryTerm = getResponse.getPrimaryTerm()__                BytesReference source = getResponse.getSourceAsBytesRef()__                Job originalJob__                try {_                    originalJob = parseJobLenientlyFromSource(source).build()__                } catch (Exception e) {_                    updatedJobListener.onFailure(_                            new ElasticsearchParseException("Failed to parse job configuration [" + jobId + "]", e))__                    return__                }__                validator.validate(originalJob, update, ActionListener.wrap(_                        validated  -> {_                            Job updatedJob__                            try {_                                _                                updatedJob = update.mergeWithJob(originalJob, maxModelMemoryLimit)__                            } catch (Exception e) {_                                updatedJobListener.onFailure(e)__                                return__                            }__                            indexUpdatedJob(updatedJob, seqNo, primaryTerm, updatedJobListener)__                        },_                        updatedJobListener::onFailure_                ))__            }__            @Override_            public void onFailure(Exception e) {_                updatedJobListener.onFailure(e)__            }_        })__    };similar,to,link,update,job,string,job,update,byte,size,value,action,listener,but,with,an,extra,validation,step,which,is,called,before,the,updated,is,applied,param,job,id,the,id,of,the,job,to,update,param,update,the,job,update,param,max,model,memory,limit,the,maximum,model,memory,allowed,param,validator,the,job,update,validator,param,updated,job,listener,updated,job,listener;public,void,update,job,with,validation,string,job,id,job,update,update,byte,size,value,max,model,memory,limit,update,validator,validator,action,listener,job,updated,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,updated,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,final,long,version,get,response,get,version,final,long,seq,no,get,response,get,seq,no,final,long,primary,term,get,response,get,primary,term,bytes,reference,source,get,response,get,source,as,bytes,ref,job,original,job,try,original,job,parse,job,leniently,from,source,source,build,catch,exception,e,updated,job,listener,on,failure,new,elasticsearch,parse,exception,failed,to,parse,job,configuration,job,id,e,return,validator,validate,original,job,update,action,listener,wrap,validated,job,updated,job,try,updated,job,update,merge,with,job,original,job,max,model,memory,limit,catch,exception,e,updated,job,listener,on,failure,e,return,index,updated,job,updated,job,seq,no,primary,term,updated,job,listener,updated,job,listener,on,failure,override,public,void,on,failure,exception,e,updated,job,listener,on,failure,e
JobConfigProvider -> public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener);1545155131;Check a job exists. A job exists if it has a configuration document._If the .ml-config index does not exist it is treated as a missing job_error.__Depending on the value of {@code errorIfMissing} if the job does not_exist a ResourceNotFoundException is returned to the listener,_otherwise false is returned in the response.__@param jobId             The jobId to check_@param errorIfMissing    If true and the job is missing the listener fails with_a ResourceNotFoundException else false is returned._@param listener          Exists listener;public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        getRequest.fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE)___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onResponse(Boolean.TRUE)__                }_            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onFailure(e)__                }_            }_        })__    };check,a,job,exists,a,job,exists,if,it,has,a,configuration,document,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,depending,on,the,value,of,code,error,if,missing,if,the,job,does,not,exist,a,resource,not,found,exception,is,returned,to,the,listener,otherwise,false,is,returned,in,the,response,param,job,id,the,job,id,to,check,param,error,if,missing,if,true,and,the,job,is,missing,the,listener,fails,with,a,resource,not,found,exception,else,false,is,returned,param,listener,exists,listener;public,void,job,exists,string,job,id,boolean,error,if,missing,action,listener,boolean,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,get,request,fetch,source,context,fetch,source,context,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,response,boolean,true,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,failure,e
JobConfigProvider -> public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener);1545227023;Check a job exists. A job exists if it has a configuration document._If the .ml-config index does not exist it is treated as a missing job_error.__Depending on the value of {@code errorIfMissing} if the job does not_exist a ResourceNotFoundException is returned to the listener,_otherwise false is returned in the response.__@param jobId             The jobId to check_@param errorIfMissing    If true and the job is missing the listener fails with_a ResourceNotFoundException else false is returned._@param listener          Exists listener;public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        getRequest.fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE)___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onResponse(Boolean.TRUE)__                }_            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onFailure(e)__                }_            }_        })__    };check,a,job,exists,a,job,exists,if,it,has,a,configuration,document,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,depending,on,the,value,of,code,error,if,missing,if,the,job,does,not,exist,a,resource,not,found,exception,is,returned,to,the,listener,otherwise,false,is,returned,in,the,response,param,job,id,the,job,id,to,check,param,error,if,missing,if,true,and,the,job,is,missing,the,listener,fails,with,a,resource,not,found,exception,else,false,is,returned,param,listener,exists,listener;public,void,job,exists,string,job,id,boolean,error,if,missing,action,listener,boolean,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,get,request,fetch,source,context,fetch,source,context,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,response,boolean,true,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,failure,e
JobConfigProvider -> public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener);1547572798;Check a job exists. A job exists if it has a configuration document._If the .ml-config index does not exist it is treated as a missing job_error.__Depending on the value of {@code errorIfMissing} if the job does not_exist a ResourceNotFoundException is returned to the listener,_otherwise false is returned in the response.__@param jobId             The jobId to check_@param errorIfMissing    If true and the job is missing the listener fails with_a ResourceNotFoundException else false is returned._@param listener          Exists listener;public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        getRequest.fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE)___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onResponse(Boolean.TRUE)__                }_            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onFailure(e)__                }_            }_        })__    };check,a,job,exists,a,job,exists,if,it,has,a,configuration,document,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,depending,on,the,value,of,code,error,if,missing,if,the,job,does,not,exist,a,resource,not,found,exception,is,returned,to,the,listener,otherwise,false,is,returned,in,the,response,param,job,id,the,job,id,to,check,param,error,if,missing,if,true,and,the,job,is,missing,the,listener,fails,with,a,resource,not,found,exception,else,false,is,returned,param,listener,exists,listener;public,void,job,exists,string,job,id,boolean,error,if,missing,action,listener,boolean,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,get,request,fetch,source,context,fetch,source,context,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,response,boolean,true,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,failure,e
JobConfigProvider -> public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener);1548840711;Check a job exists. A job exists if it has a configuration document._If the .ml-config index does not exist it is treated as a missing job_error.__Depending on the value of {@code errorIfMissing} if the job does not_exist a ResourceNotFoundException is returned to the listener,_otherwise false is returned in the response.__@param jobId             The jobId to check_@param errorIfMissing    If true and the job is missing the listener fails with_a ResourceNotFoundException else false is returned._@param listener          Exists listener;public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        getRequest.fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE)___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onResponse(Boolean.TRUE)__                }_            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onFailure(e)__                }_            }_        })__    };check,a,job,exists,a,job,exists,if,it,has,a,configuration,document,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,depending,on,the,value,of,code,error,if,missing,if,the,job,does,not,exist,a,resource,not,found,exception,is,returned,to,the,listener,otherwise,false,is,returned,in,the,response,param,job,id,the,job,id,to,check,param,error,if,missing,if,true,and,the,job,is,missing,the,listener,fails,with,a,resource,not,found,exception,else,false,is,returned,param,listener,exists,listener;public,void,job,exists,string,job,id,boolean,error,if,missing,action,listener,boolean,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,get,request,fetch,source,context,fetch,source,context,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,response,boolean,true,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,failure,e
JobConfigProvider -> public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener);1549273268;Check a job exists. A job exists if it has a configuration document._If the .ml-config index does not exist it is treated as a missing job_error.__Depending on the value of {@code errorIfMissing} if the job does not_exist a ResourceNotFoundException is returned to the listener,_otherwise false is returned in the response.__@param jobId             The jobId to check_@param errorIfMissing    If true and the job is missing the listener fails with_a ResourceNotFoundException else false is returned._@param listener          Exists listener;public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        getRequest.fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE)___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onResponse(Boolean.TRUE)__                }_            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onFailure(e)__                }_            }_        })__    };check,a,job,exists,a,job,exists,if,it,has,a,configuration,document,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,depending,on,the,value,of,code,error,if,missing,if,the,job,does,not,exist,a,resource,not,found,exception,is,returned,to,the,listener,otherwise,false,is,returned,in,the,response,param,job,id,the,job,id,to,check,param,error,if,missing,if,true,and,the,job,is,missing,the,listener,fails,with,a,resource,not,found,exception,else,false,is,returned,param,listener,exists,listener;public,void,job,exists,string,job,id,boolean,error,if,missing,action,listener,boolean,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,get,request,fetch,source,context,fetch,source,context,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,response,boolean,true,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,failure,e
JobConfigProvider -> public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener);1549396415;Check a job exists. A job exists if it has a configuration document._If the .ml-config index does not exist it is treated as a missing job_error.__Depending on the value of {@code errorIfMissing} if the job does not_exist a ResourceNotFoundException is returned to the listener,_otherwise false is returned in the response.__@param jobId             The jobId to check_@param errorIfMissing    If true and the job is missing the listener fails with_a ResourceNotFoundException else false is returned._@param listener          Exists listener;public void jobExists(String jobId, boolean errorIfMissing, ActionListener<Boolean> listener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        getRequest.fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE)___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onResponse(Boolean.TRUE)__                }_            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    if (errorIfMissing) {_                        listener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    } else {_                        listener.onResponse(Boolean.FALSE)__                    }_                } else {_                    listener.onFailure(e)__                }_            }_        })__    };check,a,job,exists,a,job,exists,if,it,has,a,configuration,document,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,depending,on,the,value,of,code,error,if,missing,if,the,job,does,not,exist,a,resource,not,found,exception,is,returned,to,the,listener,otherwise,false,is,returned,in,the,response,param,job,id,the,job,id,to,check,param,error,if,missing,if,true,and,the,job,is,missing,the,listener,fails,with,a,resource,not,found,exception,else,false,is,returned,param,listener,exists,listener;public,void,job,exists,string,job,id,boolean,error,if,missing,action,listener,boolean,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,get,request,fetch,source,context,fetch,source,context,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,response,boolean,true,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,if,error,if,missing,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,listener,on,response,boolean,false,else,listener,on,failure,e
JobConfigProvider -> public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener);1545155131;Delete the anomaly detector job config document._{@code errorIfMissing} controls whether or not an error is returned_if the document does not exist.__@param jobId The job id_@param errorIfMissing If the job document does not exist and this is true_listener fails with a ResourceNotFoundException else_the DeleteResponse is always return._@param actionListener Deleted job listener;public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener) {_        DeleteRequest request = new DeleteRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)___        executeAsyncWithOrigin(client, ML_ORIGIN, DeleteAction.INSTANCE, request, new ActionListener<DeleteResponse>() {_            @Override_            public void onResponse(DeleteResponse deleteResponse) {_                if (errorIfMissing) {_                    if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {_                        actionListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                        return__                    }_                    assert deleteResponse.getResult() == DocWriteResponse.Result.DELETED__                }_                actionListener.onResponse(deleteResponse)__            }_            @Override_            public void onFailure(Exception e) {_                actionListener.onFailure(e)__            }_        })__    };delete,the,anomaly,detector,job,config,document,code,error,if,missing,controls,whether,or,not,an,error,is,returned,if,the,document,does,not,exist,param,job,id,the,job,id,param,error,if,missing,if,the,job,document,does,not,exist,and,this,is,true,listener,fails,with,a,resource,not,found,exception,else,the,delete,response,is,always,return,param,action,listener,deleted,job,listener;public,void,delete,job,string,job,id,boolean,error,if,missing,action,listener,delete,response,action,listener,delete,request,request,new,delete,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,request,set,refresh,policy,write,request,refresh,policy,immediate,execute,async,with,origin,client,delete,action,instance,request,new,action,listener,delete,response,override,public,void,on,response,delete,response,delete,response,if,error,if,missing,if,delete,response,get,result,doc,write,response,result,action,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,assert,delete,response,get,result,doc,write,response,result,deleted,action,listener,on,response,delete,response,override,public,void,on,failure,exception,e,action,listener,on,failure,e
JobConfigProvider -> public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener);1545227023;Delete the anomaly detector job config document._{@code errorIfMissing} controls whether or not an error is returned_if the document does not exist.__@param jobId The job id_@param errorIfMissing If the job document does not exist and this is true_listener fails with a ResourceNotFoundException else_the DeleteResponse is always return._@param actionListener Deleted job listener;public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener) {_        DeleteRequest request = new DeleteRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)___        executeAsyncWithOrigin(client, ML_ORIGIN, DeleteAction.INSTANCE, request, new ActionListener<DeleteResponse>() {_            @Override_            public void onResponse(DeleteResponse deleteResponse) {_                if (errorIfMissing) {_                    if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {_                        actionListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                        return__                    }_                    assert deleteResponse.getResult() == DocWriteResponse.Result.DELETED__                }_                actionListener.onResponse(deleteResponse)__            }_            @Override_            public void onFailure(Exception e) {_                actionListener.onFailure(e)__            }_        })__    };delete,the,anomaly,detector,job,config,document,code,error,if,missing,controls,whether,or,not,an,error,is,returned,if,the,document,does,not,exist,param,job,id,the,job,id,param,error,if,missing,if,the,job,document,does,not,exist,and,this,is,true,listener,fails,with,a,resource,not,found,exception,else,the,delete,response,is,always,return,param,action,listener,deleted,job,listener;public,void,delete,job,string,job,id,boolean,error,if,missing,action,listener,delete,response,action,listener,delete,request,request,new,delete,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,request,set,refresh,policy,write,request,refresh,policy,immediate,execute,async,with,origin,client,delete,action,instance,request,new,action,listener,delete,response,override,public,void,on,response,delete,response,delete,response,if,error,if,missing,if,delete,response,get,result,doc,write,response,result,action,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,assert,delete,response,get,result,doc,write,response,result,deleted,action,listener,on,response,delete,response,override,public,void,on,failure,exception,e,action,listener,on,failure,e
JobConfigProvider -> public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener);1547572798;Delete the anomaly detector job config document._{@code errorIfMissing} controls whether or not an error is returned_if the document does not exist.__@param jobId The job id_@param errorIfMissing If the job document does not exist and this is true_listener fails with a ResourceNotFoundException else_the DeleteResponse is always return._@param actionListener Deleted job listener;public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener) {_        DeleteRequest request = new DeleteRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)___        executeAsyncWithOrigin(client, ML_ORIGIN, DeleteAction.INSTANCE, request, new ActionListener<DeleteResponse>() {_            @Override_            public void onResponse(DeleteResponse deleteResponse) {_                if (errorIfMissing) {_                    if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {_                        actionListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                        return__                    }_                    assert deleteResponse.getResult() == DocWriteResponse.Result.DELETED__                }_                actionListener.onResponse(deleteResponse)__            }_            @Override_            public void onFailure(Exception e) {_                actionListener.onFailure(e)__            }_        })__    };delete,the,anomaly,detector,job,config,document,code,error,if,missing,controls,whether,or,not,an,error,is,returned,if,the,document,does,not,exist,param,job,id,the,job,id,param,error,if,missing,if,the,job,document,does,not,exist,and,this,is,true,listener,fails,with,a,resource,not,found,exception,else,the,delete,response,is,always,return,param,action,listener,deleted,job,listener;public,void,delete,job,string,job,id,boolean,error,if,missing,action,listener,delete,response,action,listener,delete,request,request,new,delete,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,request,set,refresh,policy,write,request,refresh,policy,immediate,execute,async,with,origin,client,delete,action,instance,request,new,action,listener,delete,response,override,public,void,on,response,delete,response,delete,response,if,error,if,missing,if,delete,response,get,result,doc,write,response,result,action,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,assert,delete,response,get,result,doc,write,response,result,deleted,action,listener,on,response,delete,response,override,public,void,on,failure,exception,e,action,listener,on,failure,e
JobConfigProvider -> public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener);1548840711;Delete the anomaly detector job config document._{@code errorIfMissing} controls whether or not an error is returned_if the document does not exist.__@param jobId The job id_@param errorIfMissing If the job document does not exist and this is true_listener fails with a ResourceNotFoundException else_the DeleteResponse is always return._@param actionListener Deleted job listener;public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener) {_        DeleteRequest request = new DeleteRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)___        executeAsyncWithOrigin(client, ML_ORIGIN, DeleteAction.INSTANCE, request, new ActionListener<DeleteResponse>() {_            @Override_            public void onResponse(DeleteResponse deleteResponse) {_                if (errorIfMissing) {_                    if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {_                        actionListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                        return__                    }_                    assert deleteResponse.getResult() == DocWriteResponse.Result.DELETED__                }_                actionListener.onResponse(deleteResponse)__            }_            @Override_            public void onFailure(Exception e) {_                actionListener.onFailure(e)__            }_        })__    };delete,the,anomaly,detector,job,config,document,code,error,if,missing,controls,whether,or,not,an,error,is,returned,if,the,document,does,not,exist,param,job,id,the,job,id,param,error,if,missing,if,the,job,document,does,not,exist,and,this,is,true,listener,fails,with,a,resource,not,found,exception,else,the,delete,response,is,always,return,param,action,listener,deleted,job,listener;public,void,delete,job,string,job,id,boolean,error,if,missing,action,listener,delete,response,action,listener,delete,request,request,new,delete,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,request,set,refresh,policy,write,request,refresh,policy,immediate,execute,async,with,origin,client,delete,action,instance,request,new,action,listener,delete,response,override,public,void,on,response,delete,response,delete,response,if,error,if,missing,if,delete,response,get,result,doc,write,response,result,action,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,assert,delete,response,get,result,doc,write,response,result,deleted,action,listener,on,response,delete,response,override,public,void,on,failure,exception,e,action,listener,on,failure,e
JobConfigProvider -> public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener);1549273268;Delete the anomaly detector job config document._{@code errorIfMissing} controls whether or not an error is returned_if the document does not exist.__@param jobId The job id_@param errorIfMissing If the job document does not exist and this is true_listener fails with a ResourceNotFoundException else_the DeleteResponse is always return._@param actionListener Deleted job listener;public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener) {_        DeleteRequest request = new DeleteRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)___        executeAsyncWithOrigin(client, ML_ORIGIN, DeleteAction.INSTANCE, request, new ActionListener<DeleteResponse>() {_            @Override_            public void onResponse(DeleteResponse deleteResponse) {_                if (errorIfMissing) {_                    if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {_                        actionListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                        return__                    }_                    assert deleteResponse.getResult() == DocWriteResponse.Result.DELETED__                }_                actionListener.onResponse(deleteResponse)__            }_            @Override_            public void onFailure(Exception e) {_                actionListener.onFailure(e)__            }_        })__    };delete,the,anomaly,detector,job,config,document,code,error,if,missing,controls,whether,or,not,an,error,is,returned,if,the,document,does,not,exist,param,job,id,the,job,id,param,error,if,missing,if,the,job,document,does,not,exist,and,this,is,true,listener,fails,with,a,resource,not,found,exception,else,the,delete,response,is,always,return,param,action,listener,deleted,job,listener;public,void,delete,job,string,job,id,boolean,error,if,missing,action,listener,delete,response,action,listener,delete,request,request,new,delete,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,request,set,refresh,policy,write,request,refresh,policy,immediate,execute,async,with,origin,client,delete,action,instance,request,new,action,listener,delete,response,override,public,void,on,response,delete,response,delete,response,if,error,if,missing,if,delete,response,get,result,doc,write,response,result,action,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,assert,delete,response,get,result,doc,write,response,result,deleted,action,listener,on,response,delete,response,override,public,void,on,failure,exception,e,action,listener,on,failure,e
JobConfigProvider -> public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener);1549396415;Delete the anomaly detector job config document._{@code errorIfMissing} controls whether or not an error is returned_if the document does not exist.__@param jobId The job id_@param errorIfMissing If the job document does not exist and this is true_listener fails with a ResourceNotFoundException else_the DeleteResponse is always return._@param actionListener Deleted job listener;public void deleteJob(String jobId, boolean errorIfMissing, ActionListener<DeleteResponse> actionListener) {_        DeleteRequest request = new DeleteRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))__        request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)___        executeAsyncWithOrigin(client, ML_ORIGIN, DeleteAction.INSTANCE, request, new ActionListener<DeleteResponse>() {_            @Override_            public void onResponse(DeleteResponse deleteResponse) {_                if (errorIfMissing) {_                    if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {_                        actionListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                        return__                    }_                    assert deleteResponse.getResult() == DocWriteResponse.Result.DELETED__                }_                actionListener.onResponse(deleteResponse)__            }_            @Override_            public void onFailure(Exception e) {_                actionListener.onFailure(e)__            }_        })__    };delete,the,anomaly,detector,job,config,document,code,error,if,missing,controls,whether,or,not,an,error,is,returned,if,the,document,does,not,exist,param,job,id,the,job,id,param,error,if,missing,if,the,job,document,does,not,exist,and,this,is,true,listener,fails,with,a,resource,not,found,exception,else,the,delete,response,is,always,return,param,action,listener,deleted,job,listener;public,void,delete,job,string,job,id,boolean,error,if,missing,action,listener,delete,response,action,listener,delete,request,request,new,delete,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,request,set,refresh,policy,write,request,refresh,policy,immediate,execute,async,with,origin,client,delete,action,instance,request,new,action,listener,delete,response,override,public,void,on,response,delete,response,delete,response,if,error,if,missing,if,delete,response,get,result,doc,write,response,result,action,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,assert,delete,response,get,result,doc,write,response,result,deleted,action,listener,on,response,delete,response,override,public,void,on,failure,exception,e,action,listener,on,failure,e
JobConfigProvider -> public void getJob(String jobId, ActionListener<Job.Builder> jobListener);1545155131;Get the anomaly detector job specified by {@code jobId}._If the job is missing a {@code ResourceNotFoundException} is returned_via the listener.__If the .ml-config index does not exist it is treated as a missing job_error.__@param jobId The job ID_@param jobListener Job listener;public void getJob(String jobId, ActionListener<Job.Builder> jobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                BytesReference source = getResponse.getSourceAsBytesRef()__                parseJobLenientlyFromSource(source, jobListener)__            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                } else {_                    jobListener.onFailure(e)__                }_            }_        }, client::get)__    };get,the,anomaly,detector,job,specified,by,code,job,id,if,the,job,is,missing,a,code,resource,not,found,exception,is,returned,via,the,listener,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,param,job,id,the,job,id,param,job,listener,job,listener;public,void,get,job,string,job,id,action,listener,job,builder,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,bytes,reference,source,get,response,get,source,as,bytes,ref,parse,job,leniently,from,source,source,job,listener,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,job,listener,on,failure,e,client,get
JobConfigProvider -> public void getJob(String jobId, ActionListener<Job.Builder> jobListener);1545227023;Get the anomaly detector job specified by {@code jobId}._If the job is missing a {@code ResourceNotFoundException} is returned_via the listener.__If the .ml-config index does not exist it is treated as a missing job_error.__@param jobId The job ID_@param jobListener Job listener;public void getJob(String jobId, ActionListener<Job.Builder> jobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                BytesReference source = getResponse.getSourceAsBytesRef()__                parseJobLenientlyFromSource(source, jobListener)__            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                } else {_                    jobListener.onFailure(e)__                }_            }_        }, client::get)__    };get,the,anomaly,detector,job,specified,by,code,job,id,if,the,job,is,missing,a,code,resource,not,found,exception,is,returned,via,the,listener,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,param,job,id,the,job,id,param,job,listener,job,listener;public,void,get,job,string,job,id,action,listener,job,builder,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,bytes,reference,source,get,response,get,source,as,bytes,ref,parse,job,leniently,from,source,source,job,listener,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,job,listener,on,failure,e,client,get
JobConfigProvider -> public void getJob(String jobId, ActionListener<Job.Builder> jobListener);1547572798;Get the anomaly detector job specified by {@code jobId}._If the job is missing a {@code ResourceNotFoundException} is returned_via the listener.__If the .ml-config index does not exist it is treated as a missing job_error.__@param jobId The job ID_@param jobListener Job listener;public void getJob(String jobId, ActionListener<Job.Builder> jobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                BytesReference source = getResponse.getSourceAsBytesRef()__                parseJobLenientlyFromSource(source, jobListener)__            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                } else {_                    jobListener.onFailure(e)__                }_            }_        }, client::get)__    };get,the,anomaly,detector,job,specified,by,code,job,id,if,the,job,is,missing,a,code,resource,not,found,exception,is,returned,via,the,listener,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,param,job,id,the,job,id,param,job,listener,job,listener;public,void,get,job,string,job,id,action,listener,job,builder,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,bytes,reference,source,get,response,get,source,as,bytes,ref,parse,job,leniently,from,source,source,job,listener,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,job,listener,on,failure,e,client,get
JobConfigProvider -> public void getJob(String jobId, ActionListener<Job.Builder> jobListener);1548840711;Get the anomaly detector job specified by {@code jobId}._If the job is missing a {@code ResourceNotFoundException} is returned_via the listener.__If the .ml-config index does not exist it is treated as a missing job_error.__@param jobId The job ID_@param jobListener Job listener;public void getJob(String jobId, ActionListener<Job.Builder> jobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                BytesReference source = getResponse.getSourceAsBytesRef()__                parseJobLenientlyFromSource(source, jobListener)__            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                } else {_                    jobListener.onFailure(e)__                }_            }_        }, client::get)__    };get,the,anomaly,detector,job,specified,by,code,job,id,if,the,job,is,missing,a,code,resource,not,found,exception,is,returned,via,the,listener,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,param,job,id,the,job,id,param,job,listener,job,listener;public,void,get,job,string,job,id,action,listener,job,builder,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,bytes,reference,source,get,response,get,source,as,bytes,ref,parse,job,leniently,from,source,source,job,listener,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,job,listener,on,failure,e,client,get
JobConfigProvider -> public void getJob(String jobId, ActionListener<Job.Builder> jobListener);1549273268;Get the anomaly detector job specified by {@code jobId}._If the job is missing a {@code ResourceNotFoundException} is returned_via the listener.__If the .ml-config index does not exist it is treated as a missing job_error.__@param jobId The job ID_@param jobListener Job listener;public void getJob(String jobId, ActionListener<Job.Builder> jobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                BytesReference source = getResponse.getSourceAsBytesRef()__                parseJobLenientlyFromSource(source, jobListener)__            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                } else {_                    jobListener.onFailure(e)__                }_            }_        }, client::get)__    };get,the,anomaly,detector,job,specified,by,code,job,id,if,the,job,is,missing,a,code,resource,not,found,exception,is,returned,via,the,listener,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,param,job,id,the,job,id,param,job,listener,job,listener;public,void,get,job,string,job,id,action,listener,job,builder,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,bytes,reference,source,get,response,get,source,as,bytes,ref,parse,job,leniently,from,source,source,job,listener,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,job,listener,on,failure,e,client,get
JobConfigProvider -> public void getJob(String jobId, ActionListener<Job.Builder> jobListener);1549396415;Get the anomaly detector job specified by {@code jobId}._If the job is missing a {@code ResourceNotFoundException} is returned_via the listener.__If the .ml-config index does not exist it is treated as a missing job_error.__@param jobId The job ID_@param jobListener Job listener;public void getJob(String jobId, ActionListener<Job.Builder> jobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                BytesReference source = getResponse.getSourceAsBytesRef()__                parseJobLenientlyFromSource(source, jobListener)__            }__            @Override_            public void onFailure(Exception e) {_                if (e.getClass() == IndexNotFoundException.class) {_                    jobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                } else {_                    jobListener.onFailure(e)__                }_            }_        }, client::get)__    };get,the,anomaly,detector,job,specified,by,code,job,id,if,the,job,is,missing,a,code,resource,not,found,exception,is,returned,via,the,listener,if,the,ml,config,index,does,not,exist,it,is,treated,as,a,missing,job,error,param,job,id,the,job,id,param,job,listener,job,listener;public,void,get,job,string,job,id,action,listener,job,builder,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,bytes,reference,source,get,response,get,source,as,bytes,ref,parse,job,leniently,from,source,source,job,listener,override,public,void,on,failure,exception,e,if,e,get,class,index,not,found,exception,class,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,else,job,listener,on,failure,e,client,get
JobConfigProvider -> public void updateJob(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit, ActionListener<Job> updatedJobListener);1545155131;Get the job and update it by applying {@code update} then index the changed job_setting the version in the request. Applying the update may cause a validation error_which is returned via {@code updatedJobListener}__@param jobId The Id of the job to update_@param update The job update_@param maxModelMemoryLimit The maximum model memory allowed. This can be {@code null}_if the job's {@link org.elasticsearch.xpack.core.ml.job.config.AnalysisLimits}_are not changed._@param updatedJobListener Updated job listener;public void updateJob(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit, ActionListener<Job> updatedJobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    updatedJobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                long version = getResponse.getVersion()__                BytesReference source = getResponse.getSourceAsBytesRef()__                Job.Builder jobBuilder__                try {_                     jobBuilder = parseJobLenientlyFromSource(source)__                } catch (IOException e) {_                    updatedJobListener.onFailure(_                            new ElasticsearchParseException("Failed to parse job configuration [" + jobId + "]", e))__                    return__                }__                Job updatedJob__                try {_                    _                    updatedJob = update.mergeWithJob(jobBuilder.build(), maxModelMemoryLimit)__                } catch (Exception e) {_                    updatedJobListener.onFailure(e)__                    return__                }__                indexUpdatedJob(updatedJob, version, updatedJobListener)__            }__            @Override_            public void onFailure(Exception e) {_                updatedJobListener.onFailure(e)__            }_        })__    };get,the,job,and,update,it,by,applying,code,update,then,index,the,changed,job,setting,the,version,in,the,request,applying,the,update,may,cause,a,validation,error,which,is,returned,via,code,updated,job,listener,param,job,id,the,id,of,the,job,to,update,param,update,the,job,update,param,max,model,memory,limit,the,maximum,model,memory,allowed,this,can,be,code,null,if,the,job,s,link,org,elasticsearch,xpack,core,ml,job,config,analysis,limits,are,not,changed,param,updated,job,listener,updated,job,listener;public,void,update,job,string,job,id,job,update,update,byte,size,value,max,model,memory,limit,action,listener,job,updated,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,updated,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,long,version,get,response,get,version,bytes,reference,source,get,response,get,source,as,bytes,ref,job,builder,job,builder,try,job,builder,parse,job,leniently,from,source,source,catch,ioexception,e,updated,job,listener,on,failure,new,elasticsearch,parse,exception,failed,to,parse,job,configuration,job,id,e,return,job,updated,job,try,updated,job,update,merge,with,job,job,builder,build,max,model,memory,limit,catch,exception,e,updated,job,listener,on,failure,e,return,index,updated,job,updated,job,version,updated,job,listener,override,public,void,on,failure,exception,e,updated,job,listener,on,failure,e
JobConfigProvider -> public void updateJob(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit, ActionListener<Job> updatedJobListener);1545227023;Get the job and update it by applying {@code update} then index the changed job_setting the version in the request. Applying the update may cause a validation error_which is returned via {@code updatedJobListener}__@param jobId The Id of the job to update_@param update The job update_@param maxModelMemoryLimit The maximum model memory allowed. This can be {@code null}_if the job's {@link org.elasticsearch.xpack.core.ml.job.config.AnalysisLimits}_are not changed._@param updatedJobListener Updated job listener;public void updateJob(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit, ActionListener<Job> updatedJobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    updatedJobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                long version = getResponse.getVersion()__                BytesReference source = getResponse.getSourceAsBytesRef()__                Job.Builder jobBuilder__                try {_                     jobBuilder = parseJobLenientlyFromSource(source)__                } catch (IOException e) {_                    updatedJobListener.onFailure(_                            new ElasticsearchParseException("Failed to parse job configuration [" + jobId + "]", e))__                    return__                }__                Job updatedJob__                try {_                    _                    updatedJob = update.mergeWithJob(jobBuilder.build(), maxModelMemoryLimit)__                } catch (Exception e) {_                    updatedJobListener.onFailure(e)__                    return__                }__                indexUpdatedJob(updatedJob, version, updatedJobListener)__            }__            @Override_            public void onFailure(Exception e) {_                updatedJobListener.onFailure(e)__            }_        })__    };get,the,job,and,update,it,by,applying,code,update,then,index,the,changed,job,setting,the,version,in,the,request,applying,the,update,may,cause,a,validation,error,which,is,returned,via,code,updated,job,listener,param,job,id,the,id,of,the,job,to,update,param,update,the,job,update,param,max,model,memory,limit,the,maximum,model,memory,allowed,this,can,be,code,null,if,the,job,s,link,org,elasticsearch,xpack,core,ml,job,config,analysis,limits,are,not,changed,param,updated,job,listener,updated,job,listener;public,void,update,job,string,job,id,job,update,update,byte,size,value,max,model,memory,limit,action,listener,job,updated,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,updated,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,long,version,get,response,get,version,bytes,reference,source,get,response,get,source,as,bytes,ref,job,builder,job,builder,try,job,builder,parse,job,leniently,from,source,source,catch,ioexception,e,updated,job,listener,on,failure,new,elasticsearch,parse,exception,failed,to,parse,job,configuration,job,id,e,return,job,updated,job,try,updated,job,update,merge,with,job,job,builder,build,max,model,memory,limit,catch,exception,e,updated,job,listener,on,failure,e,return,index,updated,job,updated,job,version,updated,job,listener,override,public,void,on,failure,exception,e,updated,job,listener,on,failure,e
JobConfigProvider -> public void updateJob(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit, ActionListener<Job> updatedJobListener);1547572798;Get the job and update it by applying {@code update} then index the changed job_setting the version in the request. Applying the update may cause a validation error_which is returned via {@code updatedJobListener}__@param jobId The Id of the job to update_@param update The job update_@param maxModelMemoryLimit The maximum model memory allowed. This can be {@code null}_if the job's {@link org.elasticsearch.xpack.core.ml.job.config.AnalysisLimits}_are not changed._@param updatedJobListener Updated job listener;public void updateJob(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit, ActionListener<Job> updatedJobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    updatedJobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                long version = getResponse.getVersion()__                BytesReference source = getResponse.getSourceAsBytesRef()__                Job.Builder jobBuilder__                try {_                     jobBuilder = parseJobLenientlyFromSource(source)__                } catch (IOException e) {_                    updatedJobListener.onFailure(_                            new ElasticsearchParseException("Failed to parse job configuration [" + jobId + "]", e))__                    return__                }__                Job updatedJob__                try {_                    _                    updatedJob = update.mergeWithJob(jobBuilder.build(), maxModelMemoryLimit)__                } catch (Exception e) {_                    updatedJobListener.onFailure(e)__                    return__                }__                indexUpdatedJob(updatedJob, version, updatedJobListener)__            }__            @Override_            public void onFailure(Exception e) {_                updatedJobListener.onFailure(e)__            }_        })__    };get,the,job,and,update,it,by,applying,code,update,then,index,the,changed,job,setting,the,version,in,the,request,applying,the,update,may,cause,a,validation,error,which,is,returned,via,code,updated,job,listener,param,job,id,the,id,of,the,job,to,update,param,update,the,job,update,param,max,model,memory,limit,the,maximum,model,memory,allowed,this,can,be,code,null,if,the,job,s,link,org,elasticsearch,xpack,core,ml,job,config,analysis,limits,are,not,changed,param,updated,job,listener,updated,job,listener;public,void,update,job,string,job,id,job,update,update,byte,size,value,max,model,memory,limit,action,listener,job,updated,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,updated,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,long,version,get,response,get,version,bytes,reference,source,get,response,get,source,as,bytes,ref,job,builder,job,builder,try,job,builder,parse,job,leniently,from,source,source,catch,ioexception,e,updated,job,listener,on,failure,new,elasticsearch,parse,exception,failed,to,parse,job,configuration,job,id,e,return,job,updated,job,try,updated,job,update,merge,with,job,job,builder,build,max,model,memory,limit,catch,exception,e,updated,job,listener,on,failure,e,return,index,updated,job,updated,job,version,updated,job,listener,override,public,void,on,failure,exception,e,updated,job,listener,on,failure,e
JobConfigProvider -> public void updateJob(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit, ActionListener<Job> updatedJobListener);1548840711;Get the job and update it by applying {@code update} then index the changed job_setting the version in the request. Applying the update may cause a validation error_which is returned via {@code updatedJobListener}__@param jobId The Id of the job to update_@param update The job update_@param maxModelMemoryLimit The maximum model memory allowed. This can be {@code null}_if the job's {@link org.elasticsearch.xpack.core.ml.job.config.AnalysisLimits}_are not changed._@param updatedJobListener Updated job listener;public void updateJob(String jobId, JobUpdate update, ByteSizeValue maxModelMemoryLimit, ActionListener<Job> updatedJobListener) {_        GetRequest getRequest = new GetRequest(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId))___        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, new ActionListener<GetResponse>() {_            @Override_            public void onResponse(GetResponse getResponse) {_                if (getResponse.isExists() == false) {_                    updatedJobListener.onFailure(ExceptionsHelper.missingJobException(jobId))__                    return__                }__                long version = getResponse.getVersion()__                BytesReference source = getResponse.getSourceAsBytesRef()__                Job.Builder jobBuilder__                try {_                     jobBuilder = parseJobLenientlyFromSource(source)__                } catch (IOException e) {_                    updatedJobListener.onFailure(_                            new ElasticsearchParseException("Failed to parse job configuration [" + jobId + "]", e))__                    return__                }__                Job updatedJob__                try {_                    _                    updatedJob = update.mergeWithJob(jobBuilder.build(), maxModelMemoryLimit)__                } catch (Exception e) {_                    updatedJobListener.onFailure(e)__                    return__                }__                indexUpdatedJob(updatedJob, version, updatedJobListener)__            }__            @Override_            public void onFailure(Exception e) {_                updatedJobListener.onFailure(e)__            }_        })__    };get,the,job,and,update,it,by,applying,code,update,then,index,the,changed,job,setting,the,version,in,the,request,applying,the,update,may,cause,a,validation,error,which,is,returned,via,code,updated,job,listener,param,job,id,the,id,of,the,job,to,update,param,update,the,job,update,param,max,model,memory,limit,the,maximum,model,memory,allowed,this,can,be,code,null,if,the,job,s,link,org,elasticsearch,xpack,core,ml,job,config,analysis,limits,are,not,changed,param,updated,job,listener,updated,job,listener;public,void,update,job,string,job,id,job,update,update,byte,size,value,max,model,memory,limit,action,listener,job,updated,job,listener,get,request,get,request,new,get,request,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,execute,async,with,origin,client,get,action,instance,get,request,new,action,listener,get,response,override,public,void,on,response,get,response,get,response,if,get,response,is,exists,false,updated,job,listener,on,failure,exceptions,helper,missing,job,exception,job,id,return,long,version,get,response,get,version,bytes,reference,source,get,response,get,source,as,bytes,ref,job,builder,job,builder,try,job,builder,parse,job,leniently,from,source,source,catch,ioexception,e,updated,job,listener,on,failure,new,elasticsearch,parse,exception,failed,to,parse,job,configuration,job,id,e,return,job,updated,job,try,updated,job,update,merge,with,job,job,builder,build,max,model,memory,limit,catch,exception,e,updated,job,listener,on,failure,e,return,index,updated,job,updated,job,version,updated,job,listener,override,public,void,on,failure,exception,e,updated,job,listener,on,failure,e
JobConfigProvider -> public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener);1545155131;Expands the list of job group Ids to the set of jobs which are members of the groups._Unlike {@link #expandJobsIds(String, boolean, boolean, ActionListener)} it is not an error_if a group Id does not exist._Wildcard expansion of group Ids is not supported.__@param groupIds Group Ids to expand_@param listener Expanded job Ids listener;public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener) {_        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(new TermsQueryBuilder(Job.GROUPS.getPreferredName(), groupIds))__        sourceBuilder.sort(Job.ID.getPreferredName(), SortOrder.DESC)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(searchSize)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)__    };expands,the,list,of,job,group,ids,to,the,set,of,jobs,which,are,members,of,the,groups,unlike,link,expand,jobs,ids,string,boolean,boolean,action,listener,it,is,not,an,error,if,a,group,id,does,not,exist,wildcard,expansion,of,group,ids,is,not,supported,param,group,ids,group,ids,to,expand,param,listener,expanded,job,ids,listener;public,void,expand,group,ids,list,string,group,ids,action,listener,sorted,set,string,listener,search,source,builder,source,builder,new,search,source,builder,query,new,terms,query,builder,job,groups,get,preferred,name,group,ids,source,builder,sort,job,id,get,preferred,name,sort,order,desc,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,doc,value,fields,context,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,search,size,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener);1545227023;Expands the list of job group Ids to the set of jobs which are members of the groups._Unlike {@link #expandJobsIds(String, boolean, boolean, ActionListener)} it is not an error_if a group Id does not exist._Wildcard expansion of group Ids is not supported.__@param groupIds Group Ids to expand_@param listener Expanded job Ids listener;public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener) {_        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(new TermsQueryBuilder(Job.GROUPS.getPreferredName(), groupIds))__        sourceBuilder.sort(Job.ID.getPreferredName(), SortOrder.DESC)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)__    };expands,the,list,of,job,group,ids,to,the,set,of,jobs,which,are,members,of,the,groups,unlike,link,expand,jobs,ids,string,boolean,boolean,action,listener,it,is,not,an,error,if,a,group,id,does,not,exist,wildcard,expansion,of,group,ids,is,not,supported,param,group,ids,group,ids,to,expand,param,listener,expanded,job,ids,listener;public,void,expand,group,ids,list,string,group,ids,action,listener,sorted,set,string,listener,search,source,builder,source,builder,new,search,source,builder,query,new,terms,query,builder,job,groups,get,preferred,name,group,ids,source,builder,sort,job,id,get,preferred,name,sort,order,desc,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,doc,value,fields,context,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener);1547572798;Expands the list of job group Ids to the set of jobs which are members of the groups._Unlike {@link #expandJobsIds(String, boolean, boolean, ActionListener)} it is not an error_if a group Id does not exist._Wildcard expansion of group Ids is not supported.__@param groupIds Group Ids to expand_@param listener Expanded job Ids listener;public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener) {_        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(new TermsQueryBuilder(Job.GROUPS.getPreferredName(), groupIds))__        sourceBuilder.sort(Job.ID.getPreferredName(), SortOrder.DESC)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)__    };expands,the,list,of,job,group,ids,to,the,set,of,jobs,which,are,members,of,the,groups,unlike,link,expand,jobs,ids,string,boolean,boolean,action,listener,it,is,not,an,error,if,a,group,id,does,not,exist,wildcard,expansion,of,group,ids,is,not,supported,param,group,ids,group,ids,to,expand,param,listener,expanded,job,ids,listener;public,void,expand,group,ids,list,string,group,ids,action,listener,sorted,set,string,listener,search,source,builder,source,builder,new,search,source,builder,query,new,terms,query,builder,job,groups,get,preferred,name,group,ids,source,builder,sort,job,id,get,preferred,name,sort,order,desc,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,doc,value,fields,context,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener);1548840711;Expands the list of job group Ids to the set of jobs which are members of the groups._Unlike {@link #expandJobsIds(String, boolean, boolean, ActionListener)} it is not an error_if a group Id does not exist._Wildcard expansion of group Ids is not supported.__@param groupIds Group Ids to expand_@param listener Expanded job Ids listener;public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener) {_        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(new TermsQueryBuilder(Job.GROUPS.getPreferredName(), groupIds))__        sourceBuilder.sort(Job.ID.getPreferredName(), SortOrder.DESC)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), null)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)__    };expands,the,list,of,job,group,ids,to,the,set,of,jobs,which,are,members,of,the,groups,unlike,link,expand,jobs,ids,string,boolean,boolean,action,listener,it,is,not,an,error,if,a,group,id,does,not,exist,wildcard,expansion,of,group,ids,is,not,supported,param,group,ids,group,ids,to,expand,param,listener,expanded,job,ids,listener;public,void,expand,group,ids,list,string,group,ids,action,listener,sorted,set,string,listener,search,source,builder,source,builder,new,search,source,builder,query,new,terms,query,builder,job,groups,get,preferred,name,group,ids,source,builder,sort,job,id,get,preferred,name,sort,order,desc,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,null,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener);1549273268;Expands the list of job group Ids to the set of jobs which are members of the groups._Unlike {@link #expandJobsIds(String, boolean, boolean, ActionListener)} it is not an error_if a group Id does not exist._Wildcard expansion of group Ids is not supported.__@param groupIds Group Ids to expand_@param listener Expanded job Ids listener;public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener) {_        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(new TermsQueryBuilder(Job.GROUPS.getPreferredName(), groupIds))__        sourceBuilder.sort(Job.ID.getPreferredName(), SortOrder.DESC)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), null)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)__    };expands,the,list,of,job,group,ids,to,the,set,of,jobs,which,are,members,of,the,groups,unlike,link,expand,jobs,ids,string,boolean,boolean,action,listener,it,is,not,an,error,if,a,group,id,does,not,exist,wildcard,expansion,of,group,ids,is,not,supported,param,group,ids,group,ids,to,expand,param,listener,expanded,job,ids,listener;public,void,expand,group,ids,list,string,group,ids,action,listener,sorted,set,string,listener,search,source,builder,source,builder,new,search,source,builder,query,new,terms,query,builder,job,groups,get,preferred,name,group,ids,source,builder,sort,job,id,get,preferred,name,sort,order,desc,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,null,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener);1549396415;Expands the list of job group Ids to the set of jobs which are members of the groups._Unlike {@link #expandJobsIds(String, boolean, boolean, ActionListener)} it is not an error_if a group Id does not exist._Wildcard expansion of group Ids is not supported.__@param groupIds Group Ids to expand_@param listener Expanded job Ids listener;public void expandGroupIds(List<String> groupIds, ActionListener<SortedSet<String>> listener) {_        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(new TermsQueryBuilder(Job.GROUPS.getPreferredName(), groupIds))__        sourceBuilder.sort(Job.ID.getPreferredName(), SortOrder.DESC)__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), null)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)__    };expands,the,list,of,job,group,ids,to,the,set,of,jobs,which,are,members,of,the,groups,unlike,link,expand,jobs,ids,string,boolean,boolean,action,listener,it,is,not,an,error,if,a,group,id,does,not,exist,wildcard,expansion,of,group,ids,is,not,supported,param,group,ids,group,ids,to,expand,param,listener,expanded,job,ids,listener;public,void,expand,group,ids,list,string,group,ids,action,listener,sorted,set,string,listener,search,source,builder,source,builder,new,search,source,builder,query,new,terms,query,builder,job,groups,get,preferred,name,group,ids,source,builder,sort,job,id,get,preferred,name,sort,order,desc,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,null,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void groupExists(String groupId, ActionListener<Boolean> listener);1545155131;Check if a group exists, that is there exists a job that is a member of_the group. If there are one or more jobs that define the group then_the listener responds with true else false.__@param groupId The group Id_@param listener Returns true, false or a failure;public void groupExists(String groupId, ActionListener<Boolean> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermQueryBuilder(Job.GROUPS.getPreferredName(), groupId))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setSize(0)_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder).request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            listener.onResponse(response.getHits().getTotalHits().value > 0)__                        },_                        listener::onFailure)_                , client::search)__    };check,if,a,group,exists,that,is,there,exists,a,job,that,is,a,member,of,the,group,if,there,are,one,or,more,jobs,that,define,the,group,then,the,listener,responds,with,true,else,false,param,group,id,the,group,id,param,listener,returns,true,false,or,a,failure;public,void,group,exists,string,group,id,action,listener,boolean,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,term,query,builder,job,groups,get,preferred,name,group,id,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,size,0,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,listener,on,response,response,get,hits,get,total,hits,value,0,listener,on,failure,client,search
JobConfigProvider -> public void groupExists(String groupId, ActionListener<Boolean> listener);1545227023;Check if a group exists, that is there exists a job that is a member of_the group. If there are one or more jobs that define the group then_the listener responds with true else false.__@param groupId The group Id_@param listener Returns true, false or a failure;public void groupExists(String groupId, ActionListener<Boolean> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermQueryBuilder(Job.GROUPS.getPreferredName(), groupId))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setSize(0)_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder).request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            listener.onResponse(response.getHits().getTotalHits().value > 0)__                        },_                        listener::onFailure)_                , client::search)__    };check,if,a,group,exists,that,is,there,exists,a,job,that,is,a,member,of,the,group,if,there,are,one,or,more,jobs,that,define,the,group,then,the,listener,responds,with,true,else,false,param,group,id,the,group,id,param,listener,returns,true,false,or,a,failure;public,void,group,exists,string,group,id,action,listener,boolean,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,term,query,builder,job,groups,get,preferred,name,group,id,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,size,0,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,listener,on,response,response,get,hits,get,total,hits,value,0,listener,on,failure,client,search
JobConfigProvider -> public void groupExists(String groupId, ActionListener<Boolean> listener);1547572798;Check if a group exists, that is there exists a job that is a member of_the group. If there are one or more jobs that define the group then_the listener responds with true else false.__@param groupId The group Id_@param listener Returns true, false or a failure;public void groupExists(String groupId, ActionListener<Boolean> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermQueryBuilder(Job.GROUPS.getPreferredName(), groupId))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setSize(0)_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder).request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            listener.onResponse(response.getHits().getTotalHits().value > 0)__                        },_                        listener::onFailure)_                , client::search)__    };check,if,a,group,exists,that,is,there,exists,a,job,that,is,a,member,of,the,group,if,there,are,one,or,more,jobs,that,define,the,group,then,the,listener,responds,with,true,else,false,param,group,id,the,group,id,param,listener,returns,true,false,or,a,failure;public,void,group,exists,string,group,id,action,listener,boolean,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,term,query,builder,job,groups,get,preferred,name,group,id,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,size,0,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,listener,on,response,response,get,hits,get,total,hits,value,0,listener,on,failure,client,search
JobConfigProvider -> public void groupExists(String groupId, ActionListener<Boolean> listener);1548840711;Check if a group exists, that is there exists a job that is a member of_the group. If there are one or more jobs that define the group then_the listener responds with true else false.__@param groupId The group Id_@param listener Returns true, false or a failure;public void groupExists(String groupId, ActionListener<Boolean> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermQueryBuilder(Job.GROUPS.getPreferredName(), groupId))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setSize(0)_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder).request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            listener.onResponse(response.getHits().getTotalHits().value > 0)__                        },_                        listener::onFailure)_                , client::search)__    };check,if,a,group,exists,that,is,there,exists,a,job,that,is,a,member,of,the,group,if,there,are,one,or,more,jobs,that,define,the,group,then,the,listener,responds,with,true,else,false,param,group,id,the,group,id,param,listener,returns,true,false,or,a,failure;public,void,group,exists,string,group,id,action,listener,boolean,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,term,query,builder,job,groups,get,preferred,name,group,id,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,size,0,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,listener,on,response,response,get,hits,get,total,hits,value,0,listener,on,failure,client,search
JobConfigProvider -> public void groupExists(String groupId, ActionListener<Boolean> listener);1549273268;Check if a group exists, that is there exists a job that is a member of_the group. If there are one or more jobs that define the group then_the listener responds with true else false.__@param groupId The group Id_@param listener Returns true, false or a failure;public void groupExists(String groupId, ActionListener<Boolean> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermQueryBuilder(Job.GROUPS.getPreferredName(), groupId))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setSize(0)_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder).request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            listener.onResponse(response.getHits().getTotalHits().value > 0)__                        },_                        listener::onFailure)_                , client::search)__    };check,if,a,group,exists,that,is,there,exists,a,job,that,is,a,member,of,the,group,if,there,are,one,or,more,jobs,that,define,the,group,then,the,listener,responds,with,true,else,false,param,group,id,the,group,id,param,listener,returns,true,false,or,a,failure;public,void,group,exists,string,group,id,action,listener,boolean,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,term,query,builder,job,groups,get,preferred,name,group,id,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,size,0,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,listener,on,response,response,get,hits,get,total,hits,value,0,listener,on,failure,client,search
JobConfigProvider -> public void groupExists(String groupId, ActionListener<Boolean> listener);1549396415;Check if a group exists, that is there exists a job that is a member of_the group. If there are one or more jobs that define the group then_the listener responds with true else false.__@param groupId The group Id_@param listener Returns true, false or a failure;public void groupExists(String groupId, ActionListener<Boolean> listener) {_        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder()__        boolQueryBuilder.filter(new TermQueryBuilder(Job.JOB_TYPE.getPreferredName(), Job.ANOMALY_DETECTOR_JOB_TYPE))__        boolQueryBuilder.filter(new TermQueryBuilder(Job.GROUPS.getPreferredName(), groupId))___        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()_                .query(boolQueryBuilder)__        sourceBuilder.fetchSource(false)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setSize(0)_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder).request()___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            listener.onResponse(response.getHits().getTotalHits().value > 0)__                        },_                        listener::onFailure)_                , client::search)__    };check,if,a,group,exists,that,is,there,exists,a,job,that,is,a,member,of,the,group,if,there,are,one,or,more,jobs,that,define,the,group,then,the,listener,responds,with,true,else,false,param,group,id,the,group,id,param,listener,returns,true,false,or,a,failure;public,void,group,exists,string,group,id,action,listener,boolean,listener,bool,query,builder,bool,query,builder,new,bool,query,builder,bool,query,builder,filter,new,term,query,builder,job,get,preferred,name,job,bool,query,builder,filter,new,term,query,builder,job,groups,get,preferred,name,group,id,search,source,builder,source,builder,new,search,source,builder,query,bool,query,builder,source,builder,fetch,source,false,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,size,0,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,request,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,listener,on,response,response,get,hits,get,total,hits,value,0,listener,on,failure,client,search
JobConfigProvider -> public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener);1545155131;Get the job reference by the datafeed and validate the datafeed config against it_@param config  Datafeed config_@param listener Validation listener;public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener) {_        getJob(config.getJobId(), ActionListener.wrap(_                jobBuilder -> {_                    try {_                        DatafeedJobValidator.validate(config, jobBuilder.build())__                        listener.onResponse(Boolean.TRUE)__                    } catch (Exception e) {_                        listener.onFailure(e)__                    }_                },_                listener::onFailure_        ))__    };get,the,job,reference,by,the,datafeed,and,validate,the,datafeed,config,against,it,param,config,datafeed,config,param,listener,validation,listener;public,void,validate,datafeed,job,datafeed,config,config,action,listener,boolean,listener,get,job,config,get,job,id,action,listener,wrap,job,builder,try,datafeed,job,validator,validate,config,job,builder,build,listener,on,response,boolean,true,catch,exception,e,listener,on,failure,e,listener,on,failure
JobConfigProvider -> public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener);1545227023;Get the job reference by the datafeed and validate the datafeed config against it_@param config  Datafeed config_@param listener Validation listener;public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener) {_        getJob(config.getJobId(), ActionListener.wrap(_                jobBuilder -> {_                    try {_                        DatafeedJobValidator.validate(config, jobBuilder.build())__                        listener.onResponse(Boolean.TRUE)__                    } catch (Exception e) {_                        listener.onFailure(e)__                    }_                },_                listener::onFailure_        ))__    };get,the,job,reference,by,the,datafeed,and,validate,the,datafeed,config,against,it,param,config,datafeed,config,param,listener,validation,listener;public,void,validate,datafeed,job,datafeed,config,config,action,listener,boolean,listener,get,job,config,get,job,id,action,listener,wrap,job,builder,try,datafeed,job,validator,validate,config,job,builder,build,listener,on,response,boolean,true,catch,exception,e,listener,on,failure,e,listener,on,failure
JobConfigProvider -> public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener);1547572798;Get the job reference by the datafeed and validate the datafeed config against it_@param config  Datafeed config_@param listener Validation listener;public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener) {_        getJob(config.getJobId(), ActionListener.wrap(_                jobBuilder -> {_                    try {_                        DatafeedJobValidator.validate(config, jobBuilder.build())__                        listener.onResponse(Boolean.TRUE)__                    } catch (Exception e) {_                        listener.onFailure(e)__                    }_                },_                listener::onFailure_        ))__    };get,the,job,reference,by,the,datafeed,and,validate,the,datafeed,config,against,it,param,config,datafeed,config,param,listener,validation,listener;public,void,validate,datafeed,job,datafeed,config,config,action,listener,boolean,listener,get,job,config,get,job,id,action,listener,wrap,job,builder,try,datafeed,job,validator,validate,config,job,builder,build,listener,on,response,boolean,true,catch,exception,e,listener,on,failure,e,listener,on,failure
JobConfigProvider -> public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener);1548840711;Get the job reference by the datafeed and validate the datafeed config against it_@param config  Datafeed config_@param listener Validation listener;public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener) {_        getJob(config.getJobId(), ActionListener.wrap(_                jobBuilder -> {_                    try {_                        DatafeedJobValidator.validate(config, jobBuilder.build())__                        listener.onResponse(Boolean.TRUE)__                    } catch (Exception e) {_                        listener.onFailure(e)__                    }_                },_                listener::onFailure_        ))__    };get,the,job,reference,by,the,datafeed,and,validate,the,datafeed,config,against,it,param,config,datafeed,config,param,listener,validation,listener;public,void,validate,datafeed,job,datafeed,config,config,action,listener,boolean,listener,get,job,config,get,job,id,action,listener,wrap,job,builder,try,datafeed,job,validator,validate,config,job,builder,build,listener,on,response,boolean,true,catch,exception,e,listener,on,failure,e,listener,on,failure
JobConfigProvider -> public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener);1549273268;Get the job reference by the datafeed and validate the datafeed config against it_@param config  Datafeed config_@param listener Validation listener;public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener) {_        getJob(config.getJobId(), ActionListener.wrap(_                jobBuilder -> {_                    try {_                        DatafeedJobValidator.validate(config, jobBuilder.build())__                        listener.onResponse(Boolean.TRUE)__                    } catch (Exception e) {_                        listener.onFailure(e)__                    }_                },_                listener::onFailure_        ))__    };get,the,job,reference,by,the,datafeed,and,validate,the,datafeed,config,against,it,param,config,datafeed,config,param,listener,validation,listener;public,void,validate,datafeed,job,datafeed,config,config,action,listener,boolean,listener,get,job,config,get,job,id,action,listener,wrap,job,builder,try,datafeed,job,validator,validate,config,job,builder,build,listener,on,response,boolean,true,catch,exception,e,listener,on,failure,e,listener,on,failure
JobConfigProvider -> public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener);1549396415;Get the job reference by the datafeed and validate the datafeed config against it_@param config  Datafeed config_@param listener Validation listener;public void validateDatafeedJob(DatafeedConfig config, ActionListener<Boolean> listener) {_        getJob(config.getJobId(), ActionListener.wrap(_                jobBuilder -> {_                    try {_                        DatafeedJobValidator.validate(config, jobBuilder.build())__                        listener.onResponse(Boolean.TRUE)__                    } catch (Exception e) {_                        listener.onFailure(e)__                    }_                },_                listener::onFailure_        ))__    };get,the,job,reference,by,the,datafeed,and,validate,the,datafeed,config,against,it,param,config,datafeed,config,param,listener,validation,listener;public,void,validate,datafeed,job,datafeed,config,config,action,listener,boolean,listener,get,job,config,get,job,id,action,listener,wrap,job,builder,try,datafeed,job,validator,validate,config,job,builder,build,listener,on,response,boolean,true,catch,exception,e,listener,on,failure,e,listener,on,failure
JobConfigProvider -> public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener);1545155131;Expands an expression into the set of matching names. {@code expresssion}_may be a wildcard, a job group, a job Id or a list of those._If {@code expression} == 'ALL', '*' or the empty string then all_job Ids are returned._Job groups are expanded to all the jobs Ids in that group.__If {@code expression} contains a job Id or a Group name then it_is an error if the job or group do not exist.__For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],_expressions resolve follows:_<ul>_<li>"foo-1" : ["foo-1"]</li>_<li>"bar-1" : ["bar-1"]</li>_<li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>_<li>"foo-*" : ["foo-1", "foo-2"]</li>_<li>"*-1" : ["bar-1", "foo-1"]</li>_<li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_<li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_</ul>__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded job Ids listener;public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)__        sourceBuilder.docValueField(Job.GROUPS.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(searchSize)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SortedSet<String> groupsIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                                List<Object> groups = hit.field(Job.GROUPS.getPreferredName()).getValues()__                                if (groups != null) {_                                    groupsIds.addAll(groups.stream().map(Object::toString).collect(Collectors.toList()))__                                }_                            }__                            groupsIds.addAll(jobIds)__                            requiredMatches.filterMatchedIds(groupsIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)___    };expands,an,expression,into,the,set,of,matching,names,code,expresssion,may,be,a,wildcard,a,job,group,a,job,id,or,a,list,of,those,if,code,expression,all,or,the,empty,string,then,all,job,ids,are,returned,job,groups,are,expanded,to,all,the,jobs,ids,in,that,group,if,code,expression,contains,a,job,id,or,a,group,name,then,it,is,an,error,if,the,job,or,group,do,not,exist,for,example,given,a,set,of,names,foo,1,foo,2,bar,1,bar,2,expressions,resolve,follows,ul,li,foo,1,foo,1,li,li,bar,1,bar,1,li,li,foo,1,foo,2,foo,1,foo,2,li,li,foo,foo,1,foo,2,li,li,1,bar,1,foo,1,li,li,bar,1,bar,2,foo,1,foo,2,li,li,bar,1,bar,2,foo,1,foo,2,li,ul,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,job,ids,listener;public,void,expand,jobs,ids,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,sorted,set,string,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,doc,value,fields,context,source,builder,doc,value,field,job,groups,get,preferred,name,doc,value,fields,context,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,search,size,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,sorted,set,string,groups,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,list,object,groups,hit,field,job,groups,get,preferred,name,get,values,if,groups,null,groups,ids,add,all,groups,stream,map,object,to,string,collect,collectors,to,list,groups,ids,add,all,job,ids,required,matches,filter,matched,ids,groups,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener);1545227023;Expands an expression into the set of matching names. {@code expresssion}_may be a wildcard, a job group, a job Id or a list of those._If {@code expression} == 'ALL', '*' or the empty string then all_job Ids are returned._Job groups are expanded to all the jobs Ids in that group.__If {@code expression} contains a job Id or a Group name then it_is an error if the job or group do not exist.__For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],_expressions resolve follows:_<ul>_<li>"foo-1" : ["foo-1"]</li>_<li>"bar-1" : ["bar-1"]</li>_<li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>_<li>"foo-*" : ["foo-1", "foo-2"]</li>_<li>"*-1" : ["bar-1", "foo-1"]</li>_<li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_<li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_</ul>__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded job Ids listener;public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)__        sourceBuilder.docValueField(Job.GROUPS.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SortedSet<String> groupsIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                                List<Object> groups = hit.field(Job.GROUPS.getPreferredName()).getValues()__                                if (groups != null) {_                                    groupsIds.addAll(groups.stream().map(Object::toString).collect(Collectors.toList()))__                                }_                            }__                            groupsIds.addAll(jobIds)__                            requiredMatches.filterMatchedIds(groupsIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)___    };expands,an,expression,into,the,set,of,matching,names,code,expresssion,may,be,a,wildcard,a,job,group,a,job,id,or,a,list,of,those,if,code,expression,all,or,the,empty,string,then,all,job,ids,are,returned,job,groups,are,expanded,to,all,the,jobs,ids,in,that,group,if,code,expression,contains,a,job,id,or,a,group,name,then,it,is,an,error,if,the,job,or,group,do,not,exist,for,example,given,a,set,of,names,foo,1,foo,2,bar,1,bar,2,expressions,resolve,follows,ul,li,foo,1,foo,1,li,li,bar,1,bar,1,li,li,foo,1,foo,2,foo,1,foo,2,li,li,foo,foo,1,foo,2,li,li,1,bar,1,foo,1,li,li,bar,1,bar,2,foo,1,foo,2,li,li,bar,1,bar,2,foo,1,foo,2,li,ul,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,job,ids,listener;public,void,expand,jobs,ids,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,sorted,set,string,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,doc,value,fields,context,source,builder,doc,value,field,job,groups,get,preferred,name,doc,value,fields,context,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,sorted,set,string,groups,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,list,object,groups,hit,field,job,groups,get,preferred,name,get,values,if,groups,null,groups,ids,add,all,groups,stream,map,object,to,string,collect,collectors,to,list,groups,ids,add,all,job,ids,required,matches,filter,matched,ids,groups,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener);1547572798;Expands an expression into the set of matching names. {@code expresssion}_may be a wildcard, a job group, a job Id or a list of those._If {@code expression} == 'ALL', '*' or the empty string then all_job Ids are returned._Job groups are expanded to all the jobs Ids in that group.__If {@code expression} contains a job Id or a Group name then it_is an error if the job or group do not exist.__For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],_expressions resolve follows:_<ul>_<li>"foo-1" : ["foo-1"]</li>_<li>"bar-1" : ["bar-1"]</li>_<li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>_<li>"foo-*" : ["foo-1", "foo-2"]</li>_<li>"*-1" : ["bar-1", "foo-1"]</li>_<li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_<li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_</ul>__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded job Ids listener;public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)__        sourceBuilder.docValueField(Job.GROUPS.getPreferredName(), DocValueFieldsContext.USE_DEFAULT_FORMAT)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SortedSet<String> groupsIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                                List<Object> groups = hit.field(Job.GROUPS.getPreferredName()).getValues()__                                if (groups != null) {_                                    groupsIds.addAll(groups.stream().map(Object::toString).collect(Collectors.toList()))__                                }_                            }__                            groupsIds.addAll(jobIds)__                            requiredMatches.filterMatchedIds(groupsIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)___    };expands,an,expression,into,the,set,of,matching,names,code,expresssion,may,be,a,wildcard,a,job,group,a,job,id,or,a,list,of,those,if,code,expression,all,or,the,empty,string,then,all,job,ids,are,returned,job,groups,are,expanded,to,all,the,jobs,ids,in,that,group,if,code,expression,contains,a,job,id,or,a,group,name,then,it,is,an,error,if,the,job,or,group,do,not,exist,for,example,given,a,set,of,names,foo,1,foo,2,bar,1,bar,2,expressions,resolve,follows,ul,li,foo,1,foo,1,li,li,bar,1,bar,1,li,li,foo,1,foo,2,foo,1,foo,2,li,li,foo,foo,1,foo,2,li,li,1,bar,1,foo,1,li,li,bar,1,bar,2,foo,1,foo,2,li,li,bar,1,bar,2,foo,1,foo,2,li,ul,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,job,ids,listener;public,void,expand,jobs,ids,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,sorted,set,string,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,doc,value,fields,context,source,builder,doc,value,field,job,groups,get,preferred,name,doc,value,fields,context,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,sorted,set,string,groups,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,list,object,groups,hit,field,job,groups,get,preferred,name,get,values,if,groups,null,groups,ids,add,all,groups,stream,map,object,to,string,collect,collectors,to,list,groups,ids,add,all,job,ids,required,matches,filter,matched,ids,groups,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener);1548840711;Expands an expression into the set of matching names. {@code expresssion}_may be a wildcard, a job group, a job Id or a list of those._If {@code expression} == 'ALL', '*' or the empty string then all_job Ids are returned._Job groups are expanded to all the jobs Ids in that group.__If {@code expression} contains a job Id or a Group name then it_is an error if the job or group do not exist.__For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],_expressions resolve follows:_<ul>_<li>"foo-1" : ["foo-1"]</li>_<li>"bar-1" : ["bar-1"]</li>_<li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>_<li>"foo-*" : ["foo-1", "foo-2"]</li>_<li>"*-1" : ["bar-1", "foo-1"]</li>_<li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_<li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_</ul>__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded job Ids listener;public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), null)__        sourceBuilder.docValueField(Job.GROUPS.getPreferredName(), null)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SortedSet<String> groupsIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                                List<Object> groups = hit.field(Job.GROUPS.getPreferredName()).getValues()__                                if (groups != null) {_                                    groupsIds.addAll(groups.stream().map(Object::toString).collect(Collectors.toList()))__                                }_                            }__                            groupsIds.addAll(jobIds)__                            requiredMatches.filterMatchedIds(groupsIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)___    };expands,an,expression,into,the,set,of,matching,names,code,expresssion,may,be,a,wildcard,a,job,group,a,job,id,or,a,list,of,those,if,code,expression,all,or,the,empty,string,then,all,job,ids,are,returned,job,groups,are,expanded,to,all,the,jobs,ids,in,that,group,if,code,expression,contains,a,job,id,or,a,group,name,then,it,is,an,error,if,the,job,or,group,do,not,exist,for,example,given,a,set,of,names,foo,1,foo,2,bar,1,bar,2,expressions,resolve,follows,ul,li,foo,1,foo,1,li,li,bar,1,bar,1,li,li,foo,1,foo,2,foo,1,foo,2,li,li,foo,foo,1,foo,2,li,li,1,bar,1,foo,1,li,li,bar,1,bar,2,foo,1,foo,2,li,li,bar,1,bar,2,foo,1,foo,2,li,ul,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,job,ids,listener;public,void,expand,jobs,ids,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,sorted,set,string,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,null,source,builder,doc,value,field,job,groups,get,preferred,name,null,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,sorted,set,string,groups,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,list,object,groups,hit,field,job,groups,get,preferred,name,get,values,if,groups,null,groups,ids,add,all,groups,stream,map,object,to,string,collect,collectors,to,list,groups,ids,add,all,job,ids,required,matches,filter,matched,ids,groups,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener);1549273268;Expands an expression into the set of matching names. {@code expresssion}_may be a wildcard, a job group, a job Id or a list of those._If {@code expression} == 'ALL', '*' or the empty string then all_job Ids are returned._Job groups are expanded to all the jobs Ids in that group.__If {@code expression} contains a job Id or a Group name then it_is an error if the job or group do not exist.__For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],_expressions resolve follows:_<ul>_<li>"foo-1" : ["foo-1"]</li>_<li>"bar-1" : ["bar-1"]</li>_<li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>_<li>"foo-*" : ["foo-1", "foo-2"]</li>_<li>"*-1" : ["bar-1", "foo-1"]</li>_<li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_<li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_</ul>__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded job Ids listener;public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), null)__        sourceBuilder.docValueField(Job.GROUPS.getPreferredName(), null)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SortedSet<String> groupsIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                                List<Object> groups = hit.field(Job.GROUPS.getPreferredName()).getValues()__                                if (groups != null) {_                                    groupsIds.addAll(groups.stream().map(Object::toString).collect(Collectors.toList()))__                                }_                            }__                            groupsIds.addAll(jobIds)__                            requiredMatches.filterMatchedIds(groupsIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)___    };expands,an,expression,into,the,set,of,matching,names,code,expresssion,may,be,a,wildcard,a,job,group,a,job,id,or,a,list,of,those,if,code,expression,all,or,the,empty,string,then,all,job,ids,are,returned,job,groups,are,expanded,to,all,the,jobs,ids,in,that,group,if,code,expression,contains,a,job,id,or,a,group,name,then,it,is,an,error,if,the,job,or,group,do,not,exist,for,example,given,a,set,of,names,foo,1,foo,2,bar,1,bar,2,expressions,resolve,follows,ul,li,foo,1,foo,1,li,li,bar,1,bar,1,li,li,foo,1,foo,2,foo,1,foo,2,li,li,foo,foo,1,foo,2,li,li,1,bar,1,foo,1,li,li,bar,1,bar,2,foo,1,foo,2,li,li,bar,1,bar,2,foo,1,foo,2,li,ul,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,job,ids,listener;public,void,expand,jobs,ids,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,sorted,set,string,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,null,source,builder,doc,value,field,job,groups,get,preferred,name,null,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,sorted,set,string,groups,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,list,object,groups,hit,field,job,groups,get,preferred,name,get,values,if,groups,null,groups,ids,add,all,groups,stream,map,object,to,string,collect,collectors,to,list,groups,ids,add,all,job,ids,required,matches,filter,matched,ids,groups,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener);1549396415;Expands an expression into the set of matching names. {@code expresssion}_may be a wildcard, a job group, a job Id or a list of those._If {@code expression} == 'ALL', '*' or the empty string then all_job Ids are returned._Job groups are expanded to all the jobs Ids in that group.__If {@code expression} contains a job Id or a Group name then it_is an error if the job or group do not exist.__For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],_expressions resolve follows:_<ul>_<li>"foo-1" : ["foo-1"]</li>_<li>"bar-1" : ["bar-1"]</li>_<li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>_<li>"foo-*" : ["foo-1", "foo-2"]</li>_<li>"*-1" : ["bar-1", "foo-1"]</li>_<li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_<li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>_</ul>__@param expression the expression to resolve_@param allowNoJobs if {@code false}, an error is thrown when no name matches the {@code expression}._This only applies to wild card expressions, if {@code expression} is not a_wildcard then setting this true will not suppress the exception_@param excludeDeleting If true exclude jobs marked as deleting_@param listener The expanded job Ids listener;public void expandJobsIds(String expression, boolean allowNoJobs, boolean excludeDeleting, ActionListener<SortedSet<String>> listener) {_        String [] tokens = ExpandedIdsMatcher.tokenizeExpression(expression)__        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(buildQuery(tokens, excludeDeleting))__        sourceBuilder.sort(Job.ID.getPreferredName())__        sourceBuilder.fetchSource(false)__        sourceBuilder.docValueField(Job.ID.getPreferredName(), null)__        sourceBuilder.docValueField(Job.GROUPS.getPreferredName(), null)___        SearchRequest searchRequest = client.prepareSearch(AnomalyDetectorsIndex.configIndexName())_                .setIndicesOptions(IndicesOptions.lenientExpandOpen())_                .setSource(sourceBuilder)_                .setSize(AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)_                .request()___        ExpandedIdsMatcher requiredMatches = new ExpandedIdsMatcher(tokens, allowNoJobs)___        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, searchRequest,_                ActionListener.<SearchResponse>wrap(_                        response -> {_                            SortedSet<String> jobIds = new TreeSet<>()__                            SortedSet<String> groupsIds = new TreeSet<>()__                            SearchHit[] hits = response.getHits().getHits()__                            for (SearchHit hit : hits) {_                                jobIds.add(hit.field(Job.ID.getPreferredName()).getValue())__                                List<Object> groups = hit.field(Job.GROUPS.getPreferredName()).getValues()__                                if (groups != null) {_                                    groupsIds.addAll(groups.stream().map(Object::toString).collect(Collectors.toList()))__                                }_                            }__                            groupsIds.addAll(jobIds)__                            requiredMatches.filterMatchedIds(groupsIds)__                            if (requiredMatches.hasUnmatchedIds()) {_                                _                                listener.onFailure(ExceptionsHelper.missingJobException(requiredMatches.unmatchedIdsString()))__                                return__                            }__                            listener.onResponse(jobIds)__                        },_                        listener::onFailure)_                , client::search)___    };expands,an,expression,into,the,set,of,matching,names,code,expresssion,may,be,a,wildcard,a,job,group,a,job,id,or,a,list,of,those,if,code,expression,all,or,the,empty,string,then,all,job,ids,are,returned,job,groups,are,expanded,to,all,the,jobs,ids,in,that,group,if,code,expression,contains,a,job,id,or,a,group,name,then,it,is,an,error,if,the,job,or,group,do,not,exist,for,example,given,a,set,of,names,foo,1,foo,2,bar,1,bar,2,expressions,resolve,follows,ul,li,foo,1,foo,1,li,li,bar,1,bar,1,li,li,foo,1,foo,2,foo,1,foo,2,li,li,foo,foo,1,foo,2,li,li,1,bar,1,foo,1,li,li,bar,1,bar,2,foo,1,foo,2,li,li,bar,1,bar,2,foo,1,foo,2,li,ul,param,expression,the,expression,to,resolve,param,allow,no,jobs,if,code,false,an,error,is,thrown,when,no,name,matches,the,code,expression,this,only,applies,to,wild,card,expressions,if,code,expression,is,not,a,wildcard,then,setting,this,true,will,not,suppress,the,exception,param,exclude,deleting,if,true,exclude,jobs,marked,as,deleting,param,listener,the,expanded,job,ids,listener;public,void,expand,jobs,ids,string,expression,boolean,allow,no,jobs,boolean,exclude,deleting,action,listener,sorted,set,string,listener,string,tokens,expanded,ids,matcher,tokenize,expression,expression,search,source,builder,source,builder,new,search,source,builder,query,build,query,tokens,exclude,deleting,source,builder,sort,job,id,get,preferred,name,source,builder,fetch,source,false,source,builder,doc,value,field,job,id,get,preferred,name,null,source,builder,doc,value,field,job,groups,get,preferred,name,null,search,request,search,request,client,prepare,search,anomaly,detectors,index,config,index,name,set,indices,options,indices,options,lenient,expand,open,set,source,source,builder,set,size,anomaly,detectors,index,request,expanded,ids,matcher,required,matches,new,expanded,ids,matcher,tokens,allow,no,jobs,execute,async,with,origin,client,thread,pool,get,thread,context,search,request,action,listener,search,response,wrap,response,sorted,set,string,job,ids,new,tree,set,sorted,set,string,groups,ids,new,tree,set,search,hit,hits,response,get,hits,get,hits,for,search,hit,hit,hits,job,ids,add,hit,field,job,id,get,preferred,name,get,value,list,object,groups,hit,field,job,groups,get,preferred,name,get,values,if,groups,null,groups,ids,add,all,groups,stream,map,object,to,string,collect,collectors,to,list,groups,ids,add,all,job,ids,required,matches,filter,matched,ids,groups,ids,if,required,matches,has,unmatched,ids,listener,on,failure,exceptions,helper,missing,job,exception,required,matches,unmatched,ids,string,return,listener,on,response,job,ids,listener,on,failure,client,search
JobConfigProvider -> public void putJob(Job job, ActionListener<IndexResponse> listener);1545155131;Persist the anomaly detector job configuration to the configuration index._It is an error if an job with the same Id already exists - the config will_not be overwritten.__@param job The anomaly detector job configuration_@param listener Index response listener;public void putJob(Job job, ActionListener<IndexResponse> listener) {_        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            XContentBuilder source = job.toXContent(builder, new ToXContent.MapParams(TO_XCONTENT_PARAMS))__            IndexRequest indexRequest =  client.prepareIndex(AnomalyDetectorsIndex.configIndexName(),_                    ElasticsearchMappings.DOC_TYPE, Job.documentId(job.getId()))_                    .setSource(source)_                    .setOpType(DocWriteRequest.OpType.CREATE)_                    .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)_                    .request()___            executeAsyncWithOrigin(client, ML_ORIGIN, IndexAction.INSTANCE, indexRequest, ActionListener.wrap(_                    listener::onResponse,_                    e -> {_                        if (e instanceof VersionConflictEngineException) {_                            _                            listener.onFailure(ExceptionsHelper.jobAlreadyExists(job.getId()))__                        } else {_                            listener.onFailure(e)__                        }_                    }))___        } catch (IOException e) {_            listener.onFailure(new ElasticsearchParseException("Failed to serialise job with id [" + job.getId() + "]", e))__        }_    };persist,the,anomaly,detector,job,configuration,to,the,configuration,index,it,is,an,error,if,an,job,with,the,same,id,already,exists,the,config,will,not,be,overwritten,param,job,the,anomaly,detector,job,configuration,param,listener,index,response,listener;public,void,put,job,job,job,action,listener,index,response,listener,try,xcontent,builder,builder,xcontent,factory,json,builder,xcontent,builder,source,job,to,xcontent,builder,new,to,xcontent,map,params,index,request,index,request,client,prepare,index,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,get,id,set,source,source,set,op,type,doc,write,request,op,type,create,set,refresh,policy,write,request,refresh,policy,immediate,request,execute,async,with,origin,client,index,action,instance,index,request,action,listener,wrap,listener,on,response,e,if,e,instanceof,version,conflict,engine,exception,listener,on,failure,exceptions,helper,job,already,exists,job,get,id,else,listener,on,failure,e,catch,ioexception,e,listener,on,failure,new,elasticsearch,parse,exception,failed,to,serialise,job,with,id,job,get,id,e
JobConfigProvider -> public void putJob(Job job, ActionListener<IndexResponse> listener);1545227023;Persist the anomaly detector job configuration to the configuration index._It is an error if an job with the same Id already exists - the config will_not be overwritten.__@param job The anomaly detector job configuration_@param listener Index response listener;public void putJob(Job job, ActionListener<IndexResponse> listener) {_        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            XContentBuilder source = job.toXContent(builder, new ToXContent.MapParams(TO_XCONTENT_PARAMS))__            IndexRequest indexRequest =  client.prepareIndex(AnomalyDetectorsIndex.configIndexName(),_                    ElasticsearchMappings.DOC_TYPE, Job.documentId(job.getId()))_                    .setSource(source)_                    .setOpType(DocWriteRequest.OpType.CREATE)_                    .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)_                    .request()___            executeAsyncWithOrigin(client, ML_ORIGIN, IndexAction.INSTANCE, indexRequest, ActionListener.wrap(_                    listener::onResponse,_                    e -> {_                        if (e instanceof VersionConflictEngineException) {_                            _                            listener.onFailure(ExceptionsHelper.jobAlreadyExists(job.getId()))__                        } else {_                            listener.onFailure(e)__                        }_                    }))___        } catch (IOException e) {_            listener.onFailure(new ElasticsearchParseException("Failed to serialise job with id [" + job.getId() + "]", e))__        }_    };persist,the,anomaly,detector,job,configuration,to,the,configuration,index,it,is,an,error,if,an,job,with,the,same,id,already,exists,the,config,will,not,be,overwritten,param,job,the,anomaly,detector,job,configuration,param,listener,index,response,listener;public,void,put,job,job,job,action,listener,index,response,listener,try,xcontent,builder,builder,xcontent,factory,json,builder,xcontent,builder,source,job,to,xcontent,builder,new,to,xcontent,map,params,index,request,index,request,client,prepare,index,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,get,id,set,source,source,set,op,type,doc,write,request,op,type,create,set,refresh,policy,write,request,refresh,policy,immediate,request,execute,async,with,origin,client,index,action,instance,index,request,action,listener,wrap,listener,on,response,e,if,e,instanceof,version,conflict,engine,exception,listener,on,failure,exceptions,helper,job,already,exists,job,get,id,else,listener,on,failure,e,catch,ioexception,e,listener,on,failure,new,elasticsearch,parse,exception,failed,to,serialise,job,with,id,job,get,id,e
JobConfigProvider -> public void putJob(Job job, ActionListener<IndexResponse> listener);1547572798;Persist the anomaly detector job configuration to the configuration index._It is an error if an job with the same Id already exists - the config will_not be overwritten.__@param job The anomaly detector job configuration_@param listener Index response listener;public void putJob(Job job, ActionListener<IndexResponse> listener) {_        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            XContentBuilder source = job.toXContent(builder, new ToXContent.MapParams(TO_XCONTENT_PARAMS))__            IndexRequest indexRequest =  client.prepareIndex(AnomalyDetectorsIndex.configIndexName(),_                    ElasticsearchMappings.DOC_TYPE, Job.documentId(job.getId()))_                    .setSource(source)_                    .setOpType(DocWriteRequest.OpType.CREATE)_                    .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)_                    .request()___            executeAsyncWithOrigin(client, ML_ORIGIN, IndexAction.INSTANCE, indexRequest, ActionListener.wrap(_                    listener::onResponse,_                    e -> {_                        if (e instanceof VersionConflictEngineException) {_                            _                            listener.onFailure(ExceptionsHelper.jobAlreadyExists(job.getId()))__                        } else {_                            listener.onFailure(e)__                        }_                    }))___        } catch (IOException e) {_            listener.onFailure(new ElasticsearchParseException("Failed to serialise job with id [" + job.getId() + "]", e))__        }_    };persist,the,anomaly,detector,job,configuration,to,the,configuration,index,it,is,an,error,if,an,job,with,the,same,id,already,exists,the,config,will,not,be,overwritten,param,job,the,anomaly,detector,job,configuration,param,listener,index,response,listener;public,void,put,job,job,job,action,listener,index,response,listener,try,xcontent,builder,builder,xcontent,factory,json,builder,xcontent,builder,source,job,to,xcontent,builder,new,to,xcontent,map,params,index,request,index,request,client,prepare,index,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,get,id,set,source,source,set,op,type,doc,write,request,op,type,create,set,refresh,policy,write,request,refresh,policy,immediate,request,execute,async,with,origin,client,index,action,instance,index,request,action,listener,wrap,listener,on,response,e,if,e,instanceof,version,conflict,engine,exception,listener,on,failure,exceptions,helper,job,already,exists,job,get,id,else,listener,on,failure,e,catch,ioexception,e,listener,on,failure,new,elasticsearch,parse,exception,failed,to,serialise,job,with,id,job,get,id,e
JobConfigProvider -> public void putJob(Job job, ActionListener<IndexResponse> listener);1548840711;Persist the anomaly detector job configuration to the configuration index._It is an error if an job with the same Id already exists - the config will_not be overwritten.__@param job The anomaly detector job configuration_@param listener Index response listener;public void putJob(Job job, ActionListener<IndexResponse> listener) {_        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            XContentBuilder source = job.toXContent(builder, new ToXContent.MapParams(TO_XCONTENT_PARAMS))__            IndexRequest indexRequest =  client.prepareIndex(AnomalyDetectorsIndex.configIndexName(),_                    ElasticsearchMappings.DOC_TYPE, Job.documentId(job.getId()))_                    .setSource(source)_                    .setOpType(DocWriteRequest.OpType.CREATE)_                    .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)_                    .request()___            executeAsyncWithOrigin(client, ML_ORIGIN, IndexAction.INSTANCE, indexRequest, ActionListener.wrap(_                    listener::onResponse,_                    e -> {_                        if (e instanceof VersionConflictEngineException) {_                            _                            listener.onFailure(ExceptionsHelper.jobAlreadyExists(job.getId()))__                        } else {_                            listener.onFailure(e)__                        }_                    }))___        } catch (IOException e) {_            listener.onFailure(new ElasticsearchParseException("Failed to serialise job with id [" + job.getId() + "]", e))__        }_    };persist,the,anomaly,detector,job,configuration,to,the,configuration,index,it,is,an,error,if,an,job,with,the,same,id,already,exists,the,config,will,not,be,overwritten,param,job,the,anomaly,detector,job,configuration,param,listener,index,response,listener;public,void,put,job,job,job,action,listener,index,response,listener,try,xcontent,builder,builder,xcontent,factory,json,builder,xcontent,builder,source,job,to,xcontent,builder,new,to,xcontent,map,params,index,request,index,request,client,prepare,index,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,get,id,set,source,source,set,op,type,doc,write,request,op,type,create,set,refresh,policy,write,request,refresh,policy,immediate,request,execute,async,with,origin,client,index,action,instance,index,request,action,listener,wrap,listener,on,response,e,if,e,instanceof,version,conflict,engine,exception,listener,on,failure,exceptions,helper,job,already,exists,job,get,id,else,listener,on,failure,e,catch,ioexception,e,listener,on,failure,new,elasticsearch,parse,exception,failed,to,serialise,job,with,id,job,get,id,e
JobConfigProvider -> public void putJob(Job job, ActionListener<IndexResponse> listener);1549273268;Persist the anomaly detector job configuration to the configuration index._It is an error if an job with the same Id already exists - the config will_not be overwritten.__@param job The anomaly detector job configuration_@param listener Index response listener;public void putJob(Job job, ActionListener<IndexResponse> listener) {_        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            XContentBuilder source = job.toXContent(builder, new ToXContent.MapParams(TO_XCONTENT_PARAMS))__            IndexRequest indexRequest =  client.prepareIndex(AnomalyDetectorsIndex.configIndexName(),_                    ElasticsearchMappings.DOC_TYPE, Job.documentId(job.getId()))_                    .setSource(source)_                    .setOpType(DocWriteRequest.OpType.CREATE)_                    .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)_                    .request()___            executeAsyncWithOrigin(client, ML_ORIGIN, IndexAction.INSTANCE, indexRequest, ActionListener.wrap(_                    listener::onResponse,_                    e -> {_                        if (e instanceof VersionConflictEngineException) {_                            _                            listener.onFailure(ExceptionsHelper.jobAlreadyExists(job.getId()))__                        } else {_                            listener.onFailure(e)__                        }_                    }))___        } catch (IOException e) {_            listener.onFailure(new ElasticsearchParseException("Failed to serialise job with id [" + job.getId() + "]", e))__        }_    };persist,the,anomaly,detector,job,configuration,to,the,configuration,index,it,is,an,error,if,an,job,with,the,same,id,already,exists,the,config,will,not,be,overwritten,param,job,the,anomaly,detector,job,configuration,param,listener,index,response,listener;public,void,put,job,job,job,action,listener,index,response,listener,try,xcontent,builder,builder,xcontent,factory,json,builder,xcontent,builder,source,job,to,xcontent,builder,new,to,xcontent,map,params,index,request,index,request,client,prepare,index,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,get,id,set,source,source,set,op,type,doc,write,request,op,type,create,set,refresh,policy,write,request,refresh,policy,immediate,request,execute,async,with,origin,client,index,action,instance,index,request,action,listener,wrap,listener,on,response,e,if,e,instanceof,version,conflict,engine,exception,listener,on,failure,exceptions,helper,job,already,exists,job,get,id,else,listener,on,failure,e,catch,ioexception,e,listener,on,failure,new,elasticsearch,parse,exception,failed,to,serialise,job,with,id,job,get,id,e
JobConfigProvider -> public void putJob(Job job, ActionListener<IndexResponse> listener);1549396415;Persist the anomaly detector job configuration to the configuration index._It is an error if an job with the same Id already exists - the config will_not be overwritten.__@param job The anomaly detector job configuration_@param listener Index response listener;public void putJob(Job job, ActionListener<IndexResponse> listener) {_        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            XContentBuilder source = job.toXContent(builder, new ToXContent.MapParams(TO_XCONTENT_PARAMS))__            IndexRequest indexRequest =  client.prepareIndex(AnomalyDetectorsIndex.configIndexName(),_                    ElasticsearchMappings.DOC_TYPE, Job.documentId(job.getId()))_                    .setSource(source)_                    .setOpType(DocWriteRequest.OpType.CREATE)_                    .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)_                    .request()___            executeAsyncWithOrigin(client, ML_ORIGIN, IndexAction.INSTANCE, indexRequest, ActionListener.wrap(_                    listener::onResponse,_                    e -> {_                        if (e instanceof VersionConflictEngineException) {_                            _                            listener.onFailure(ExceptionsHelper.jobAlreadyExists(job.getId()))__                        } else {_                            listener.onFailure(e)__                        }_                    }))___        } catch (IOException e) {_            listener.onFailure(new ElasticsearchParseException("Failed to serialise job with id [" + job.getId() + "]", e))__        }_    };persist,the,anomaly,detector,job,configuration,to,the,configuration,index,it,is,an,error,if,an,job,with,the,same,id,already,exists,the,config,will,not,be,overwritten,param,job,the,anomaly,detector,job,configuration,param,listener,index,response,listener;public,void,put,job,job,job,action,listener,index,response,listener,try,xcontent,builder,builder,xcontent,factory,json,builder,xcontent,builder,source,job,to,xcontent,builder,new,to,xcontent,map,params,index,request,index,request,client,prepare,index,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,get,id,set,source,source,set,op,type,doc,write,request,op,type,create,set,refresh,policy,write,request,refresh,policy,immediate,request,execute,async,with,origin,client,index,action,instance,index,request,action,listener,wrap,listener,on,response,e,if,e,instanceof,version,conflict,engine,exception,listener,on,failure,exceptions,helper,job,already,exists,job,get,id,else,listener,on,failure,e,catch,ioexception,e,listener,on,failure,new,elasticsearch,parse,exception,failed,to,serialise,job,with,id,job,get,id,e
JobConfigProvider -> public void getJobs(List<String> jobIds, ActionListener<List<Job.Builder>> listener);1545155131;Get the list anomaly detector jobs specified by {@code jobIds}.__WARNING: errors are silently ignored, if a job is not found a_{@code ResourceNotFoundException} is not thrown. Only found_jobs are returned, this size of the returned jobs list could_be different to the size of the requested ids list.__@param jobIds    The jobs to get_@param listener  Jobs listener;public void getJobs(List<String> jobIds, ActionListener<List<Job.Builder>> listener) {_        MultiGetRequest multiGetRequest = new MultiGetRequest()__        jobIds.forEach(jobId -> multiGetRequest.add(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId)))___        List<Job.Builder> jobs = new ArrayList<>()__        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, multiGetRequest, new ActionListener<MultiGetResponse>() {_            @Override_            public void onResponse(MultiGetResponse multiGetResponse) {__                MultiGetItemResponse[] responses = multiGetResponse.getResponses()__                for (MultiGetItemResponse response : responses) {_                    GetResponse getResponse = response.getResponse()__                    if (getResponse.isExists()) {_                        BytesReference source = getResponse.getSourceAsBytesRef()__                        try {_                            Job.Builder job = parseJobLenientlyFromSource(source)__                            jobs.add(job)__                        } catch (IOException e) {_                            logger.error("Error parsing job configuration [" + response.getId() + "]")__                        }_                    }_                }__                listener.onResponse(jobs)__            }__            @Override_            public void onFailure(Exception e) {_                listener.onFailure(e)__            }_        }, client::multiGet)__    };get,the,list,anomaly,detector,jobs,specified,by,code,job,ids,warning,errors,are,silently,ignored,if,a,job,is,not,found,a,code,resource,not,found,exception,is,not,thrown,only,found,jobs,are,returned,this,size,of,the,returned,jobs,list,could,be,different,to,the,size,of,the,requested,ids,list,param,job,ids,the,jobs,to,get,param,listener,jobs,listener;public,void,get,jobs,list,string,job,ids,action,listener,list,job,builder,listener,multi,get,request,multi,get,request,new,multi,get,request,job,ids,for,each,job,id,multi,get,request,add,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,list,job,builder,jobs,new,array,list,execute,async,with,origin,client,thread,pool,get,thread,context,multi,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,multi,get,response,multi,get,item,response,responses,multi,get,response,get,responses,for,multi,get,item,response,response,responses,get,response,get,response,response,get,response,if,get,response,is,exists,bytes,reference,source,get,response,get,source,as,bytes,ref,try,job,builder,job,parse,job,leniently,from,source,source,jobs,add,job,catch,ioexception,e,logger,error,error,parsing,job,configuration,response,get,id,listener,on,response,jobs,override,public,void,on,failure,exception,e,listener,on,failure,e,client,multi,get
JobConfigProvider -> public void getJobs(List<String> jobIds, ActionListener<List<Job.Builder>> listener);1545227023;Get the list anomaly detector jobs specified by {@code jobIds}.__WARNING: errors are silently ignored, if a job is not found a_{@code ResourceNotFoundException} is not thrown. Only found_jobs are returned, this size of the returned jobs list could_be different to the size of the requested ids list.__@param jobIds    The jobs to get_@param listener  Jobs listener;public void getJobs(List<String> jobIds, ActionListener<List<Job.Builder>> listener) {_        MultiGetRequest multiGetRequest = new MultiGetRequest()__        jobIds.forEach(jobId -> multiGetRequest.add(AnomalyDetectorsIndex.configIndexName(),_                ElasticsearchMappings.DOC_TYPE, Job.documentId(jobId)))___        List<Job.Builder> jobs = new ArrayList<>()__        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, multiGetRequest, new ActionListener<MultiGetResponse>() {_            @Override_            public void onResponse(MultiGetResponse multiGetResponse) {__                MultiGetItemResponse[] responses = multiGetResponse.getResponses()__                for (MultiGetItemResponse response : responses) {_                    GetResponse getResponse = response.getResponse()__                    if (getResponse.isExists()) {_                        BytesReference source = getResponse.getSourceAsBytesRef()__                        try {_                            Job.Builder job = parseJobLenientlyFromSource(source)__                            jobs.add(job)__                        } catch (IOException e) {_                            logger.error("Error parsing job configuration [" + response.getId() + "]")__                        }_                    }_                }__                listener.onResponse(jobs)__            }__            @Override_            public void onFailure(Exception e) {_                listener.onFailure(e)__            }_        }, client::multiGet)__    };get,the,list,anomaly,detector,jobs,specified,by,code,job,ids,warning,errors,are,silently,ignored,if,a,job,is,not,found,a,code,resource,not,found,exception,is,not,thrown,only,found,jobs,are,returned,this,size,of,the,returned,jobs,list,could,be,different,to,the,size,of,the,requested,ids,list,param,job,ids,the,jobs,to,get,param,listener,jobs,listener;public,void,get,jobs,list,string,job,ids,action,listener,list,job,builder,listener,multi,get,request,multi,get,request,new,multi,get,request,job,ids,for,each,job,id,multi,get,request,add,anomaly,detectors,index,config,index,name,elasticsearch,mappings,job,document,id,job,id,list,job,builder,jobs,new,array,list,execute,async,with,origin,client,thread,pool,get,thread,context,multi,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,multi,get,response,multi,get,item,response,responses,multi,get,response,get,responses,for,multi,get,item,response,response,responses,get,response,get,response,response,get,response,if,get,response,is,exists,bytes,reference,source,get,response,get,source,as,bytes,ref,try,job,builder,job,parse,job,leniently,from,source,source,jobs,add,job,catch,ioexception,e,logger,error,error,parsing,job,configuration,response,get,id,listener,on,response,jobs,override,public,void,on,failure,exception,e,listener,on,failure,e,client,multi,get
