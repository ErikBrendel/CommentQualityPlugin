commented;modifiers;parameterAmount;loc;comment;code
true;public;0;5;/**  * Removes any temporary storage leftovers.  *  * Removes all temp files and folder which might be there as a result of an  * unclean node shutdown or broken clients.  *  * Do not call while there are running jobs.  *  * @throws IOException if cleanup fails  */ ;/**  * Removes any temporary storage leftovers.  *  * Removes all temp files and folder which might be there as a result of an  * unclean node shutdown or broken clients.  *  * Do not call while there are running jobs.  *  * @throws IOException if cleanup fails  */ public void cleanupLocalTmpStorageInCaseOfUncleanShutdown() throws IOException {     for (Path p : environment.dataFiles()) {         IOUtils.rm(p.resolve(LOCAL_STORAGE_SUBFOLDER).resolve(LOCAL_STORAGE_TMP_FOLDER)).     } }
true;public;2;16;/**  * Tries to find local storage for storing temporary data.  *  * @param uniqueIdentifier An identifier to be used as sub folder  * @param requestedSize The maximum size required  * @return Path for temporary storage if available, null otherwise  */ ;/**  * Tries to find local storage for storing temporary data.  *  * @param uniqueIdentifier An identifier to be used as sub folder  * @param requestedSize The maximum size required  * @return Path for temporary storage if available, null otherwise  */ public Path tryGetLocalTmpStorage(String uniqueIdentifier, ByteSizeValue requestedSize) {     for (Path path : environment.dataFiles()) {         try {             if (getUsableSpace(path) >= requestedSize.getBytes() + minLocalStorageAvailable.getBytes()) {                 Path tmpDirectory = path.resolve(LOCAL_STORAGE_SUBFOLDER).resolve(LOCAL_STORAGE_TMP_FOLDER).resolve(uniqueIdentifier).                 Files.createDirectories(tmpDirectory).                 return tmpDirectory.             }         } catch (IOException e) {             LOGGER.debug("Failed to obtain information about path [{}]: {}", path, e).         }     }     LOGGER.debug("Failed to find native storage for [{}], returning null", uniqueIdentifier).     return null. }
false;public;2;15;;public boolean localTmpStorageHasEnoughSpace(Path path, ByteSizeValue requestedSize) {     Path realPath = path.toAbsolutePath().     for (Path p : environment.dataFiles()) {         try {             if (realPath.startsWith(p.resolve(LOCAL_STORAGE_SUBFOLDER).resolve(LOCAL_STORAGE_TMP_FOLDER))) {                 return getUsableSpace(p) >= requestedSize.getBytes() + minLocalStorageAvailable.getBytes().             }         } catch (IOException e) {             LOGGER.debug("Failed to optain information about path [{}]: {}", path, e).         }     }     LOGGER.debug("Not enough space left for path [{}]", path).     return false. }
true;public;1;9;/**  * Delete temporary storage, previously allocated  *  * @param path  *            Path to temporary storage  * @throws IOException  *             if path can not be cleaned up  */ ;/**  * Delete temporary storage, previously allocated  *  * @param path  *            Path to temporary storage  * @throws IOException  *             if path can not be cleaned up  */ public void cleanupLocalTmpStorage(Path path) throws IOException {     // do not allow to breakout from the tmp storage provided     Path realPath = path.toAbsolutePath().     for (Path p : environment.dataFiles()) {         if (realPath.startsWith(p.resolve(LOCAL_STORAGE_SUBFOLDER).resolve(LOCAL_STORAGE_TMP_FOLDER))) {             IOUtils.rm(path).         }     } }
false;public;0;3;;public ByteSizeValue getMinLocalStorageAvailable() {     return minLocalStorageAvailable. }
false;;1;9;;long getUsableSpace(Path path) throws IOException {     long freeSpaceInBytes = Environment.getFileStore(path).getUsableSpace().     /* See: https://bugs.openjdk.java.net/browse/JDK-8162520 */     if (freeSpaceInBytes < 0) {         freeSpaceInBytes = Long.MAX_VALUE.     }     return freeSpaceInBytes. }
