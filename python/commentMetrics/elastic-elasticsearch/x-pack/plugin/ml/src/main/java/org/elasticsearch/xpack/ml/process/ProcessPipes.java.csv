commented;modifiers;parameterAmount;loc;comment;code
true;public;1;25;/**  * Augments a list of command line arguments, for example that built up by the AutodetectBuilder class.  */ ;/**  * Augments a list of command line arguments, for example that built up by the AutodetectBuilder class.  */ public void addArgs(List<String> command) {     if (logPipeName != null) {         command.add(LOG_PIPE_ARG + logPipeName).     }     if (commandPipeName != null) {         command.add(COMMAND_PIPE_ARG + commandPipeName).     }     // The following are specified using two arguments, as the C++ processes could already accept input from files on disk     if (processInPipeName != null) {         command.add(INPUT_ARG + processInPipeName).         command.add(INPUT_IS_PIPE_ARG).     }     if (processOutPipeName != null) {         command.add(OUTPUT_ARG + processOutPipeName).         command.add(OUTPUT_IS_PIPE_ARG).     }     if (restorePipeName != null) {         command.add(RESTORE_ARG + restorePipeName).         command.add(RESTORE_IS_PIPE_ARG).     }     if (persistPipeName != null) {         command.add(PERSIST_ARG + persistPipeName).         command.add(PERSIST_IS_PIPE_ARG).     } }
true;public;1;22;/**  * Connect the pipes created by the C++ process.  This must be called after the corresponding C++ process has been started.  * @param timeout Needs to be long enough for the C++ process perform all startup tasks that precede creation of named pipes.  *                There should not be very many of these, so a short timeout should be fine.  However, at least a couple of  *                seconds is recommended due to the vagaries of process scheduling and the way VMs can completely stall for  *                some hypervisor actions.  */ ;/**  * Connect the pipes created by the C++ process.  This must be called after the corresponding C++ process has been started.  * @param timeout Needs to be long enough for the C++ process perform all startup tasks that precede creation of named pipes.  *                There should not be very many of these, so a short timeout should be fine.  However, at least a couple of  *                seconds is recommended due to the vagaries of process scheduling and the way VMs can completely stall for  *                some hypervisor actions.  */ public void connectStreams(Duration timeout) throws IOException {     // a timeout is guaranteed.  Also change api::CIoManager in the C++ code if changing the order here.     if (logPipeName != null) {         logStream = namedPipeHelper.openNamedPipeInputStream(logPipeName, timeout).     }     if (commandPipeName != null) {         commandStream = namedPipeHelper.openNamedPipeOutputStream(commandPipeName, timeout).     }     if (processInPipeName != null) {         processInStream = namedPipeHelper.openNamedPipeOutputStream(processInPipeName, timeout).     }     if (processOutPipeName != null) {         processOutStream = namedPipeHelper.openNamedPipeInputStream(processOutPipeName, timeout).     }     if (restorePipeName != null) {         restoreStream = namedPipeHelper.openNamedPipeOutputStream(restorePipeName, timeout).     }     if (persistPipeName != null) {         persistStream = namedPipeHelper.openNamedPipeInputStream(persistPipeName, timeout).     } }
false;public;0;10;;public Optional<InputStream> getLogStream() {     // Distinguish between pipe not wanted and pipe wanted but not successfully connected     if (logPipeName == null) {         return Optional.empty().     }     if (logStream == null) {         throw new IllegalStateException("process streams must be connected before use").     }     return Optional.of(logStream). }
false;public;0;10;;public Optional<OutputStream> getCommandStream() {     // Distinguish between pipe not wanted and pipe wanted but not successfully connected     if (commandPipeName == null) {         return Optional.empty().     }     if (commandStream == null) {         throw new IllegalStateException("process streams must be connected before use").     }     return Optional.of(commandStream). }
false;public;0;10;;public Optional<OutputStream> getProcessInStream() {     // Distinguish between pipe not wanted and pipe wanted but not successfully connected     if (processInPipeName == null) {         return Optional.empty().     }     if (processInStream == null) {         throw new IllegalStateException("process streams must be connected before use").     }     return Optional.of(processInStream). }
false;public;0;10;;public Optional<InputStream> getProcessOutStream() {     // Distinguish between pipe not wanted and pipe wanted but not successfully connected     if (processOutPipeName == null) {         return Optional.empty().     }     if (processOutStream == null) {         throw new IllegalStateException("process streams must be connected before use").     }     return Optional.of(processOutStream). }
false;public;0;10;;public Optional<OutputStream> getRestoreStream() {     // Distinguish between pipe not wanted and pipe wanted but not successfully connected     if (restorePipeName == null) {         return Optional.empty().     }     if (restoreStream == null) {         throw new IllegalStateException("process streams must be connected before use").     }     return Optional.of(restoreStream). }
false;public;0;10;;public Optional<InputStream> getPersistStream() {     // Distinguish between pipe not wanted and pipe wanted but not successfully connected     if (persistPipeName == null) {         return Optional.empty().     }     if (persistStream == null) {         throw new IllegalStateException("process streams must be connected before use").     }     return Optional.of(persistStream). }
