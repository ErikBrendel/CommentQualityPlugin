commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;6;;private static void fieldLevelMappingIssue(IndexMetaData indexMetaData, BiConsumer<MappingMetaData, Map<String, Object>> checker) {     for (ObjectCursor<MappingMetaData> mappingMetaData : indexMetaData.getMappings().values()) {         Map<String, Object> sourceAsMap = mappingMetaData.value.sourceAsMap().         checker.accept(mappingMetaData.value, sourceAsMap).     } }
true;private,static;3;33;/**  * iterates through the "properties" field of mappings and returns any predicates that match in the  * form of issue-strings.  *  * @param type the document type  * @param parentMap the mapping to read properties from  * @param predicate the predicate to check against for issues, issue is returned if predicate evaluates to true  * @return a list of issues found in fields  */ ;/**  * iterates through the "properties" field of mappings and returns any predicates that match in the  * form of issue-strings.  *  * @param type the document type  * @param parentMap the mapping to read properties from  * @param predicate the predicate to check against for issues, issue is returned if predicate evaluates to true  * @return a list of issues found in fields  */ @SuppressWarnings("unchecked") private static List<String> findInPropertiesRecursively(String type, Map<String, Object> parentMap, Function<Map<?, ?>, Boolean> predicate) {     List<String> issues = new ArrayList<>().     Map<?, ?> properties = (Map<?, ?>) parentMap.get("properties").     if (properties == null) {         return issues.     }     for (Map.Entry<?, ?> entry : properties.entrySet()) {         Map<String, Object> valueMap = (Map<String, Object>) entry.getValue().         if (predicate.apply(valueMap)) {             issues.add("[type: " + type + ", field: " + entry.getKey() + "]").         }         Map<?, ?> values = (Map<?, ?>) valueMap.get("fields").         if (values != null) {             for (Map.Entry<?, ?> multifieldEntry : values.entrySet()) {                 Map<String, Object> multifieldValueMap = (Map<String, Object>) multifieldEntry.getValue().                 if (predicate.apply(multifieldValueMap)) {                     issues.add("[type: " + type + ", field: " + entry.getKey() + ", multifield: " + multifieldEntry.getKey() + "]").                 }                 if (multifieldValueMap.containsKey("properties")) {                     issues.addAll(findInPropertiesRecursively(type, multifieldValueMap, predicate)).                 }             }         }         if (valueMap.containsKey("properties")) {             issues.addAll(findInPropertiesRecursively(type, valueMap, predicate)).         }     }     return issues. }
false;static;1;11;;static DeprecationIssue oldIndicesCheck(IndexMetaData indexMetaData) {     Version createdWith = indexMetaData.getCreationVersion().     if (createdWith.before(Version.V_7_0_0)) {         return new DeprecationIssue(DeprecationIssue.Level.CRITICAL, "Index created before 7.0", "https://www.elastic.co/guide/en/elasticsearch/reference/master/" + "breaking-changes-8.0.html", "This index was created using version: " + createdWith).     }     return null. }
