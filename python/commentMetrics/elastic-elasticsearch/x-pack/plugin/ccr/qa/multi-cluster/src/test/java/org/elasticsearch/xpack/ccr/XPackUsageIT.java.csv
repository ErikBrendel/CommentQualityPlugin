commented;modifiers;parameterAmount;loc;comment;code
false;public;0;47;;public void testXPackCcrUsage() throws Exception {     if ("follow".equals(targetCluster) == false) {         logger.info("skipping test, waiting for target cluster [follow]").         return.     }     Map<?, ?> previousUsage = getCcrUsage().     putAutoFollowPattern("my_pattern", "leader_cluster", "messages-*").     // This index should be auto followed:     createLeaderIndex("messages-20200101").     // This index will be followed manually     createLeaderIndex("my_index").     followIndex("my_index", "my_index").     int previousFollowerIndicesCount = (Integer) previousUsage.get("follower_indices_count").     int previousAutoFollowPatternsCount = (Integer) previousUsage.get("auto_follow_patterns_count").     assertBusy(() -> {         Map<?, ?> ccrUsage = getCcrUsage().         assertThat(ccrUsage.get("follower_indices_count"), equalTo(previousFollowerIndicesCount + 2)).         assertThat(ccrUsage.get("auto_follow_patterns_count"), equalTo(previousAutoFollowPatternsCount + 1)).         assertThat((Integer) ccrUsage.get("last_follow_time_in_millis"), greaterThanOrEqualTo(0)).         // We need to wait until index following is active for auto followed indices:         // (otherwise pause follow may fail, if there are no shard follow tasks, in case this test gets executed too quickly)         assertIndexFollowingActive("messages-20200101").     }).     deleteAutoFollowPattern("my_pattern").     pauseFollow("messages-20200101").     closeIndex("messages-20200101").     unfollow("messages-20200101").     pauseFollow("my_index").     closeIndex("my_index").     unfollow("my_index").     assertBusy(() -> {         Map<?, ?> ccrUsage = getCcrUsage().         assertThat(ccrUsage.get("follower_indices_count"), equalTo(previousFollowerIndicesCount)).         assertThat(ccrUsage.get("auto_follow_patterns_count"), equalTo(previousAutoFollowPatternsCount)).         if (previousFollowerIndicesCount == 0) {             assertThat(ccrUsage.get("last_follow_time_in_millis"), nullValue()).         } else {             assertThat((Integer) ccrUsage.get("last_follow_time_in_millis"), greaterThanOrEqualTo(0)).         }     }). }
false;private;1;10;;private void createLeaderIndex(String indexName) throws IOException {     try (RestClient leaderClient = buildLeaderClient()) {         Settings settings = Settings.builder().put("index.soft_deletes.enabled", true).build().         Request request = new Request("PUT", "/" + indexName).         request.setJsonEntity("{\"settings\": " + Strings.toString(settings) + "}").         assertOK(leaderClient.performRequest(request)).     } }
false;private;0;6;;private Map<?, ?> getCcrUsage() throws IOException {     Request request = new Request("GET", "/_xpack/usage").     Map<String, ?> response = toMap(client().performRequest(request)).     logger.info("xpack usage response={}", response).     return (Map<?, ?>) response.get("ccr"). }
false;private;1;8;;private void assertIndexFollowingActive(String expectedFollowerIndex) throws IOException {     Request statsRequest = new Request("GET", "/" + expectedFollowerIndex + "/_ccr/info").     Map<?, ?> response = toMap(client().performRequest(statsRequest)).     String actualFollowerIndex = ObjectPath.eval("follower_indices.0.follower_index", response).     assertThat(actualFollowerIndex, equalTo(expectedFollowerIndex)).     String followStatus = ObjectPath.eval("follower_indices.0.status", response).     assertThat(followStatus, equalTo("active")). }
