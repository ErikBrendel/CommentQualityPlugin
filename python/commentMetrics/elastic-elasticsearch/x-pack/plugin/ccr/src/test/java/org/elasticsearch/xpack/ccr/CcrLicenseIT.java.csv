commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return Collections.singletonList(NonCompliantLicenseLocalStateCcr.class). }
false;protected;0;4;;@Override protected Settings nodeSettings() {     return Settings.EMPTY. }
false;public;1;5;;@Override public void onResponse(final AcknowledgedResponse response) {     latch.countDown().     fail(). }
false;public;1;5;;@Override public void onFailure(final Exception e) {     assertNonCompliantLicense(e).     latch.countDown(). }
false;public;0;21;;public void testThatFollowingIndexIsUnavailableWithNonCompliantLicense() throws InterruptedException {     final ResumeFollowAction.Request followRequest = getResumeFollowRequest("follower").     final CountDownLatch latch = new CountDownLatch(1).     client().execute(ResumeFollowAction.INSTANCE, followRequest, new ActionListener<AcknowledgedResponse>() {          @Override         public void onResponse(final AcknowledgedResponse response) {             latch.countDown().             fail().         }          @Override         public void onFailure(final Exception e) {             assertNonCompliantLicense(e).             latch.countDown().         }     }).     latch.await(). }
false;public;1;5;;@Override public void onResponse(final PutFollowAction.Response response) {     latch.countDown().     fail(). }
false;public;1;5;;@Override public void onFailure(final Exception e) {     assertNonCompliantLicense(e).     latch.countDown(). }
false;public;0;21;;public void testThatCreateAndFollowingIndexIsUnavailableWithNonCompliantLicense() throws InterruptedException {     final PutFollowAction.Request createAndFollowRequest = getPutFollowRequest("leader", "follower").     final CountDownLatch latch = new CountDownLatch(1).     client().execute(PutFollowAction.INSTANCE, createAndFollowRequest, new ActionListener<PutFollowAction.Response>() {          @Override         public void onResponse(final PutFollowAction.Response response) {             latch.countDown().             fail().         }          @Override         public void onFailure(final Exception e) {             assertNonCompliantLicense(e).             latch.countDown().         }     }).     latch.await(). }
false;public;1;5;;@Override public void onResponse(final FollowStatsAction.StatsResponses statsResponses) {     latch.countDown().     fail(). }
false;public;1;5;;@Override public void onFailure(final Exception e) {     assertNonCompliantLicense(e).     latch.countDown(). }
false;public;0;21;;public void testThatFollowStatsAreUnavailableWithNonCompliantLicense() throws InterruptedException {     final CountDownLatch latch = new CountDownLatch(1).     client().execute(FollowStatsAction.INSTANCE, new FollowStatsAction.StatsRequest(), new ActionListener<FollowStatsAction.StatsResponses>() {          @Override         public void onResponse(final FollowStatsAction.StatsResponses statsResponses) {             latch.countDown().             fail().         }          @Override         public void onFailure(final Exception e) {             assertNonCompliantLicense(e).             latch.countDown().         }     }).     latch.await(). }
false;public;1;5;;@Override public void onResponse(final AcknowledgedResponse response) {     latch.countDown().     fail(). }
false;public;1;5;;@Override public void onFailure(final Exception e) {     assertNonCompliantLicense(e).     latch.countDown(). }
false;public;0;24;;public void testThatPutAutoFollowPatternsIsUnavailableWithNonCompliantLicense() throws InterruptedException {     final CountDownLatch latch = new CountDownLatch(1).     final PutAutoFollowPatternAction.Request request = new PutAutoFollowPatternAction.Request().     request.setName("name").     request.setRemoteCluster("leader").     request.setLeaderIndexPatterns(Collections.singletonList("*")).     client().execute(PutAutoFollowPatternAction.INSTANCE, request, new ActionListener<AcknowledgedResponse>() {          @Override         public void onResponse(final AcknowledgedResponse response) {             latch.countDown().             fail().         }          @Override         public void onFailure(final Exception e) {             assertNonCompliantLicense(e).             latch.countDown().         }     }).     latch.await(). }
false;public;1;15;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     AutoFollowPattern autoFollowPattern = new AutoFollowPattern("test_alias", Collections.singletonList("logs-*"), null, null, null, null, null, null, null, null, null, null, null).     AutoFollowMetadata autoFollowMetadata = new AutoFollowMetadata(Collections.singletonMap("test_alias", autoFollowPattern), Collections.emptyMap(), Collections.emptyMap()).     ClusterState.Builder newState = ClusterState.builder(currentState).     newState.metaData(MetaData.builder(currentState.getMetaData()).putCustom(AutoFollowMetadata.TYPE, autoFollowMetadata).build()).     return newState.build(). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     latch.countDown(). }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     latch.countDown().     fail("unexpected error [" + e.getMessage() + "]"). }
false;public;0;57;;public void testAutoFollowCoordinatorLogsSkippingAutoFollowCoordinationWithNonCompliantLicense() throws Exception {     final Logger logger = LogManager.getLogger(AutoFollowCoordinator.class).     final MockLogAppender appender = new MockLogAppender().     appender.start().     appender.addExpectation(new MockLogAppender.ExceptionSeenEventExpectation(getTestName(), logger.getName(), Level.WARN, "skipping auto-follower coordination", ElasticsearchSecurityException.class, "current license is non-compliant for [ccr]")).     try {         // Need to add mock log appender before submitting CS update, otherwise we miss the expected log:         // (Auto followers for new remote clusters are bootstrapped when a new cluster state is published)         Loggers.addAppender(logger, appender).         // Update the cluster state so that we have auto follow patterns and verify that we log a warning         // in case of incompatible license:         CountDownLatch latch = new CountDownLatch(1).         ClusterService clusterService = getInstanceFromNode(ClusterService.class).         clusterService.submitStateUpdateTask("test-add-auto-follow-pattern", new ClusterStateUpdateTask() {              @Override             public ClusterState execute(ClusterState currentState) throws Exception {                 AutoFollowPattern autoFollowPattern = new AutoFollowPattern("test_alias", Collections.singletonList("logs-*"), null, null, null, null, null, null, null, null, null, null, null).                 AutoFollowMetadata autoFollowMetadata = new AutoFollowMetadata(Collections.singletonMap("test_alias", autoFollowPattern), Collections.emptyMap(), Collections.emptyMap()).                 ClusterState.Builder newState = ClusterState.builder(currentState).                 newState.metaData(MetaData.builder(currentState.getMetaData()).putCustom(AutoFollowMetadata.TYPE, autoFollowMetadata).build()).                 return newState.build().             }              @Override             public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {                 latch.countDown().             }              @Override             public void onFailure(String source, Exception e) {                 latch.countDown().                 fail("unexpected error [" + e.getMessage() + "]").             }         }).         latch.await().         appender.assertAllExpectationsMatched().     } finally {         Loggers.removeAppender(logger, appender).         appender.stop().     } }
false;private;1;4;;private void assertNonCompliantLicense(final Exception e) {     assertThat(e, instanceOf(ElasticsearchSecurityException.class)).     assertThat(e.getMessage(), equalTo("current license is non-compliant for [ccr]")). }
