commented;modifiers;parameterAmount;loc;comment;code
false;public;0;46;;public void testDoNotFillGaps() throws Exception {     Settings settings = Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build().     final IndexShard indexShard = newStartedShard(false, settings, new FollowingEngineFactory()).     long seqNo = -1.     for (int i = 0. i < 8. i++) {         final String id = Long.toString(i).         SourceToParse sourceToParse = new SourceToParse(indexShard.shardId().getIndexName(), "_doc", id, new BytesArray("{}"), XContentType.JSON).         indexShard.applyIndexOperationOnReplica(++seqNo, 1, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false, sourceToParse).     }     long seqNoBeforeGap = seqNo.     seqNo += 8.     SourceToParse sourceToParse = new SourceToParse(indexShard.shardId().getIndexName(), "_doc", "9", new BytesArray("{}"), XContentType.JSON).     indexShard.applyIndexOperationOnReplica(seqNo, 1, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false, sourceToParse).     // promote the replica to primary:     final ShardRouting replicaRouting = indexShard.routingEntry().     final ShardRouting primaryRouting = newShardRouting(replicaRouting.shardId(), replicaRouting.currentNodeId(), null, true, ShardRoutingState.STARTED, replicaRouting.allocationId()).     indexShard.updateShardState(primaryRouting, indexShard.getOperationPrimaryTerm() + 1, (shard, listener) -> {     }, 0L, Collections.singleton(primaryRouting.allocationId().getId()), new IndexShardRoutingTable.Builder(primaryRouting.shardId()).addShard(primaryRouting).build(), Collections.emptySet()).     final CountDownLatch latch = new CountDownLatch(1).     ActionListener<Releasable> actionListener = ActionListener.wrap(releasable -> {         releasable.close().         latch.countDown().     }, e -> {         assert false : "expected no exception, but got [" + e.getMessage() + "]".     }).     indexShard.acquirePrimaryOperationPermit(actionListener, ThreadPool.Names.GENERIC, "").     latch.await().     assertThat(indexShard.getLocalCheckpoint(), equalTo(seqNoBeforeGap)).     indexShard.refresh("test").     assertThat(indexShard.docStats().getCount(), equalTo(9L)).     closeShards(indexShard). }
false;public;6;15;;@Override public void restoreShard(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {     try {         cleanLuceneIndex(targetStore.directory()).         for (String file : sourceStore.directory().listAll()) {             if (file.equals("write.lock") || file.startsWith("extra")) {                 continue.             }             targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT).         }     } catch (Exception ex) {         throw new RuntimeException(ex).     } }
false;public;0;58;;public void testRestoreShard() throws IOException {     final Settings sourceSettings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build().     final IndexShard source = newStartedShard(true, sourceSettings).     final Settings targetSettings = Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build().     IndexShard target = newStartedShard(true, targetSettings, new FollowingEngineFactory()).     assertThat(IndexShardTestCase.getEngine(target), instanceOf(FollowingEngine.class)).     indexDoc(source, "_doc", "0").     EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(source)).     indexDoc(source, "_doc", "2").     if (randomBoolean()) {         source.refresh("test").     }     // only flush source     flushShard(source).     ShardRouting routing = ShardRoutingHelper.initWithSameId(target.routingEntry(), RecoverySource.ExistingStoreRecoverySource.INSTANCE).     final Snapshot snapshot = new Snapshot("foo", new SnapshotId("bar", UUIDs.randomBase64UUID())).     routing = ShardRoutingHelper.newWithRestoreSource(routing, new RecoverySource.SnapshotRecoverySource(UUIDs.randomBase64UUID(), snapshot, Version.CURRENT, "test")).     target = reinitShard(target, routing).     Store sourceStore = source.store().     Store targetStore = target.store().     DiscoveryNode localNode = new DiscoveryNode("foo", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT).     target.markAsRecovering("store", new RecoveryState(routing, localNode, null)).     assertTrue(target.restoreFromRepository(new RestoreOnlyRepository("test") {          @Override         public void restoreShard(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {             try {                 cleanLuceneIndex(targetStore.directory()).                 for (String file : sourceStore.directory().listAll()) {                     if (file.equals("write.lock") || file.startsWith("extra")) {                         continue.                     }                     targetStore.directory().copyFrom(sourceStore.directory(), file, file, IOContext.DEFAULT).                 }             } catch (Exception ex) {                 throw new RuntimeException(ex).             }         }     })).     assertThat(target.getLocalCheckpoint(), equalTo(0L)).     assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L)).     assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L)).     IndexShardTestCase.updateRoutingEntry(target, routing.moveToStarted()).     assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L)).     assertDocs(target, "0", "2").     closeShard(source, false).     closeShards(target). }
