# id;timestamp;commentText;codeText;commentWords;codeWords
CcrRetentionLeaseIT -> private List<ShardStats> getShardStats(final IndicesStatsResponse stats);1550348884;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shard,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardStats(final IndicesStatsResponse stats);1550435606;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shard,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550664347;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550673971;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550682532;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550686731;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550692640;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550769912;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550775841;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550778794;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550874150;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550877225;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550877388;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return -Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550878473;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return -Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1550885983;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return -Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
CcrRetentionLeaseIT -> private List<ShardStats> getShardsStats(final IndicesStatsResponse stats);1551132475;Extract the shard stats from an indices stats response, with the stats ordered by shard ID with primaries first. This is to have a_consistent ordering when comparing two responses.__@param stats the indices stats_@return the shard stats in sorted order with (shard ID, primary) as the sort key;private List<ShardStats> getShardsStats(final IndicesStatsResponse stats) {_        return Arrays.stream(stats.getShards())_                .sorted((s, t) -> {_                    if (s.getShardRouting().shardId().id() == t.getShardRouting().shardId().id()) {_                        return -Boolean.compare(s.getShardRouting().primary(), t.getShardRouting().primary())__                    } else {_                        return Integer.compare(s.getShardRouting().shardId().id(), t.getShardRouting().shardId().id())__                    }_                })_                .collect(Collectors.toList())__    };extract,the,shard,stats,from,an,indices,stats,response,with,the,stats,ordered,by,shard,id,with,primaries,first,this,is,to,have,a,consistent,ordering,when,comparing,two,responses,param,stats,the,indices,stats,return,the,shard,stats,in,sorted,order,with,shard,id,primary,as,the,sort,key;private,list,shard,stats,get,shards,stats,final,indices,stats,response,stats,return,arrays,stream,stats,get,shards,sorted,s,t,if,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,return,boolean,compare,s,get,shard,routing,primary,t,get,shard,routing,primary,else,return,integer,compare,s,get,shard,routing,shard,id,id,t,get,shard,routing,shard,id,id,collect,collectors,to,list
