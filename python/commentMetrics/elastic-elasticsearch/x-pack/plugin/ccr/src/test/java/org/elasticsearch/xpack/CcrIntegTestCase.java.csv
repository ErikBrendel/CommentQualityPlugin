# id;timestamp;commentText;codeText;commentWords;codeWords
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1541253654;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1543572216;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1544035746;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1544081506;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1544544737;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1545077972;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1545221025;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1545223884;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1545381400;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1547128950;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1547472462;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1548268873;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1548787649;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1548790146;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1548982944;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549045877;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(leaderStats, equalTo(followerStats))__        }, 60, TimeUnit.SECONDS)__        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),_                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)))__        }, 60, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,leader,stats,equal,to,follower,stats,60,time,unit,seconds,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,assert,that,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,equal,to,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,60,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549053879;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            logger.info("--> docs on the follower {}", docsOnFollower)__            assertThat(docsOnFollower, equalTo(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,logger,info,docs,on,the,follower,docs,on,follower,assert,that,docs,on,follower,equal,to,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549356412;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            logger.info("--> docs on the follower {}", docsOnFollower)__            assertThat(docsOnFollower, equalTo(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,logger,info,docs,on,the,follower,docs,on,follower,assert,that,docs,on,follower,equal,to,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549382719;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            logger.info("--> docs on the follower {}", docsOnFollower)__            assertThat(docsOnFollower, equalTo(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,logger,info,docs,on,the,follower,docs,on,follower,assert,that,docs,on,follower,equal,to,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549388544;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            logger.info("--> docs on the follower {}", docsOnFollower)__            assertThat(docsOnFollower, equalTo(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,logger,info,docs,on,the,follower,docs,on,follower,assert,that,docs,on,follower,equal,to,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549395161;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            logger.info("--> docs on the follower {}", docsOnFollower)__            assertThat(docsOnFollower, equalTo(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,logger,info,docs,on,the,follower,docs,on,follower,assert,that,docs,on,follower,equal,to,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549452878;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            logger.info("--> docs on the follower {}", docsOnFollower)__            assertThat(docsOnFollower, equalTo(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,logger,info,docs,on,the,follower,docs,on,follower,assert,that,docs,on,follower,equal,to,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549895739;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            logger.info("--> docs on the follower {}", docsOnFollower)__            assertThat(docsOnFollower, equalTo(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,logger,info,docs,on,the,follower,docs,on,follower,assert,that,docs,on,follower,equal,to,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549963152;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            logger.info("--> docs on the follower {}", docsOnFollower)__            assertThat(docsOnFollower, equalTo(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,logger,info,docs,on,the,follower,docs,on,follower,assert,that,docs,on,follower,equal,to,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1549989658;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnLeader = getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)__            Map<Integer, Set<DocIdSeqNoAndTerm>> mismatchedDocs = new HashMap<>()__            for (Map.Entry<Integer, List<DocIdSeqNoAndTerm>> fe : docsOnFollower.entrySet()) {_                Set<DocIdSeqNoAndTerm> d1 = Sets.difference(_                    Sets.newHashSet(fe.getValue()), Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())))__                Set<DocIdSeqNoAndTerm> d2 = Sets.difference(_                    Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())), Sets.newHashSet(fe.getValue()))__                if (d1.isEmpty() == false || d2.isEmpty() == false) {_                    mismatchedDocs.put(fe.getKey(), Sets.union(d1, d2))__                }_            }_            assertThat("mismatched documents [" + mismatchedDocs + "]", docsOnFollower, equalTo(docsOnLeader))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,map,integer,list,doc,id,seq,no,and,term,docs,on,leader,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,map,integer,set,doc,id,seq,no,and,term,mismatched,docs,new,hash,map,for,map,entry,integer,list,doc,id,seq,no,and,term,fe,docs,on,follower,entry,set,set,doc,id,seq,no,and,term,d1,sets,difference,sets,new,hash,set,fe,get,value,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,set,doc,id,seq,no,and,term,d2,sets,difference,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,sets,new,hash,set,fe,get,value,if,d1,is,empty,false,d2,is,empty,false,mismatched,docs,put,fe,get,key,sets,union,d1,d2,assert,that,mismatched,documents,mismatched,docs,docs,on,follower,equal,to,docs,on,leader,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1550256017;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnLeader = getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)__            Map<Integer, Set<DocIdSeqNoAndTerm>> mismatchedDocs = new HashMap<>()__            for (Map.Entry<Integer, List<DocIdSeqNoAndTerm>> fe : docsOnFollower.entrySet()) {_                Set<DocIdSeqNoAndTerm> d1 = Sets.difference(_                    Sets.newHashSet(fe.getValue()), Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())))__                Set<DocIdSeqNoAndTerm> d2 = Sets.difference(_                    Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())), Sets.newHashSet(fe.getValue()))__                if (d1.isEmpty() == false || d2.isEmpty() == false) {_                    mismatchedDocs.put(fe.getKey(), Sets.union(d1, d2))__                }_            }_            assertThat("mismatched documents [" + mismatchedDocs + "]", docsOnFollower, equalTo(docsOnLeader))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,map,integer,list,doc,id,seq,no,and,term,docs,on,leader,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,map,integer,set,doc,id,seq,no,and,term,mismatched,docs,new,hash,map,for,map,entry,integer,list,doc,id,seq,no,and,term,fe,docs,on,follower,entry,set,set,doc,id,seq,no,and,term,d1,sets,difference,sets,new,hash,set,fe,get,value,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,set,doc,id,seq,no,and,term,d2,sets,difference,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,sets,new,hash,set,fe,get,value,if,d1,is,empty,false,d2,is,empty,false,mismatched,docs,put,fe,get,key,sets,union,d1,d2,assert,that,mismatched,documents,mismatched,docs,docs,on,follower,equal,to,docs,on,leader,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1550348884;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnLeader = getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)__            Map<Integer, Set<DocIdSeqNoAndTerm>> mismatchedDocs = new HashMap<>()__            for (Map.Entry<Integer, List<DocIdSeqNoAndTerm>> fe : docsOnFollower.entrySet()) {_                Set<DocIdSeqNoAndTerm> d1 = Sets.difference(_                    Sets.newHashSet(fe.getValue()), Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())))__                Set<DocIdSeqNoAndTerm> d2 = Sets.difference(_                    Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())), Sets.newHashSet(fe.getValue()))__                if (d1.isEmpty() == false || d2.isEmpty() == false) {_                    mismatchedDocs.put(fe.getKey(), Sets.union(d1, d2))__                }_            }_            assertThat("mismatched documents [" + mismatchedDocs + "]", docsOnFollower, equalTo(docsOnLeader))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,map,integer,list,doc,id,seq,no,and,term,docs,on,leader,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,map,integer,set,doc,id,seq,no,and,term,mismatched,docs,new,hash,map,for,map,entry,integer,list,doc,id,seq,no,and,term,fe,docs,on,follower,entry,set,set,doc,id,seq,no,and,term,d1,sets,difference,sets,new,hash,set,fe,get,value,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,set,doc,id,seq,no,and,term,d2,sets,difference,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,sets,new,hash,set,fe,get,value,if,d1,is,empty,false,d2,is,empty,false,mismatched,docs,put,fe,get,key,sets,union,d1,d2,assert,that,mismatched,documents,mismatched,docs,docs,on,follower,equal,to,docs,on,leader,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1550502895;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnLeader = getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)__            Map<Integer, Set<DocIdSeqNoAndTerm>> mismatchedDocs = new HashMap<>()__            for (Map.Entry<Integer, List<DocIdSeqNoAndTerm>> fe : docsOnFollower.entrySet()) {_                Set<DocIdSeqNoAndTerm> d1 = Sets.difference(_                    Sets.newHashSet(fe.getValue()), Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())))__                Set<DocIdSeqNoAndTerm> d2 = Sets.difference(_                    Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())), Sets.newHashSet(fe.getValue()))__                if (d1.isEmpty() == false || d2.isEmpty() == false) {_                    mismatchedDocs.put(fe.getKey(), Sets.union(d1, d2))__                }_            }_            assertThat("mismatched documents [" + mismatchedDocs + "]", docsOnFollower, equalTo(docsOnLeader))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,map,integer,list,doc,id,seq,no,and,term,docs,on,leader,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,map,integer,set,doc,id,seq,no,and,term,mismatched,docs,new,hash,map,for,map,entry,integer,list,doc,id,seq,no,and,term,fe,docs,on,follower,entry,set,set,doc,id,seq,no,and,term,d1,sets,difference,sets,new,hash,set,fe,get,value,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,set,doc,id,seq,no,and,term,d2,sets,difference,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,sets,new,hash,set,fe,get,value,if,d1,is,empty,false,d2,is,empty,false,mismatched,docs,put,fe,get,key,sets,union,d1,d2,assert,that,mismatched,documents,mismatched,docs,docs,on,follower,equal,to,docs,on,leader,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception;1551132475;This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats_on the follower equal the leader's_ then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader.;protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {_        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnFollower = getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)__            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnLeader = getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex)__            Map<Integer, Set<DocIdSeqNoAndTerm>> mismatchedDocs = new HashMap<>()__            for (Map.Entry<Integer, List<DocIdSeqNoAndTerm>> fe : docsOnFollower.entrySet()) {_                Set<DocIdSeqNoAndTerm> d1 = Sets.difference(_                    Sets.newHashSet(fe.getValue()), Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())))__                Set<DocIdSeqNoAndTerm> d2 = Sets.difference(_                    Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())), Sets.newHashSet(fe.getValue()))__                if (d1.isEmpty() == false || d2.isEmpty() == false) {_                    mismatchedDocs.put(fe.getKey(), Sets.union(d1, d2))__                }_            }_            assertThat("mismatched documents [" + mismatchedDocs + "]", docsOnFollower, equalTo(docsOnLeader))__        }, 120, TimeUnit.SECONDS)___        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex)__        assertBusy(() -> {_            Map<Integer, SeqNoStats> leaderStats = new HashMap<>()__            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            Map<Integer, SeqNoStats> followerStats = new HashMap<>()__            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {_                if (shardStat.getSeqNoStats() == null) {_                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]")__                }_                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats())__            }_            assertThat(followerStats, equalTo(leaderStats))__        }, 120, TimeUnit.SECONDS)__    };this,asserts,the,index,is,fully,replicated,from,the,leader,index,to,the,follower,index,it,first,verifies,that,the,on,the,follower,equal,the,leader,s,then,verifies,the,existing,pairs,of,doc,id,seq,no,on,the,follower,also,equal,the,leader;protected,void,assert,index,fully,replicated,to,follower,string,leader,index,string,follower,index,throws,exception,logger,info,asserting,doc,id,seq,no,between,and,leader,index,follower,index,assert,busy,map,integer,list,doc,id,seq,no,and,term,docs,on,follower,get,doc,id,and,seq,nos,cluster,group,follower,cluster,follower,index,map,integer,list,doc,id,seq,no,and,term,docs,on,leader,get,doc,id,and,seq,nos,cluster,group,leader,cluster,leader,index,map,integer,set,doc,id,seq,no,and,term,mismatched,docs,new,hash,map,for,map,entry,integer,list,doc,id,seq,no,and,term,fe,docs,on,follower,entry,set,set,doc,id,seq,no,and,term,d1,sets,difference,sets,new,hash,set,fe,get,value,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,set,doc,id,seq,no,and,term,d2,sets,difference,sets,new,hash,set,docs,on,leader,get,or,default,fe,get,key,collections,empty,list,sets,new,hash,set,fe,get,value,if,d1,is,empty,false,d2,is,empty,false,mismatched,docs,put,fe,get,key,sets,union,d1,d2,assert,that,mismatched,documents,mismatched,docs,docs,on,follower,equal,to,docs,on,leader,120,time,unit,seconds,logger,info,asserting,between,and,leader,index,follower,index,assert,busy,map,integer,seq,no,stats,leader,stats,new,hash,map,for,shard,stats,shard,stat,leader,client,admin,indices,prepare,stats,leader,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,leader,is,not,available,strings,to,string,shard,stat,leader,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,map,integer,seq,no,stats,follower,stats,new,hash,map,for,shard,stats,shard,stat,follower,client,admin,indices,prepare,stats,follower,index,clear,get,get,shards,if,shard,stat,get,seq,no,stats,null,throw,new,assertion,error,follower,is,not,available,strings,to,string,shard,stat,follower,stats,put,shard,stat,get,shard,routing,shard,id,id,shard,stat,get,seq,no,stats,assert,that,follower,stats,equal,to,leader,stats,120,time,unit,seconds
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1543572216;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1544035746;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1544081506;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1544544737;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1545077972;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1545221025;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1545223884;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1545381400;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1547128950;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1547472462;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1548268873;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1548787649;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1548790146;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1548982944;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549045877;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549053879;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549356412;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549382719;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549388544;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549395161;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549452878;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549895739;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549963152;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1549989658;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1550256017;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1550348884;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1550502895;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> protected void disableDelayedAllocation(String index);1551132475;Follower indices don't get all the settings from leader, for example 'index.unassigned.node_left.delayed_timeout'_is not replicated and if tests kill nodes, we have to wait 60s by default...;protected void disableDelayedAllocation(String index) {_        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(index)__        Settings.Builder settingsBuilder = Settings.builder()__        settingsBuilder.put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), 0)__        updateSettingsRequest.settings(settingsBuilder)__        assertAcked(followerClient().admin().indices().updateSettings(updateSettingsRequest).actionGet())__    };follower,indices,don,t,get,all,the,settings,from,leader,for,example,index,unassigned,is,not,replicated,and,if,tests,kill,nodes,we,have,to,wait,60s,by,default;protected,void,disable,delayed,allocation,string,index,update,settings,request,update,settings,request,new,update,settings,request,index,settings,builder,settings,builder,settings,builder,settings,builder,put,unassigned,info,get,key,0,update,settings,request,settings,settings,builder,assert,acked,follower,client,admin,indices,update,settings,update,settings,request,action,get
CcrIntegTestCase -> public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException;1549395161;Waits until at least a give number of document is visible for searchers__@param numDocs number of documents to wait for_@param indexer a {@link org.elasticsearch.test.BackgroundIndexer}. Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException {_        _        return waitForDocs(numDocs, 90, TimeUnit.SECONDS, indexer)__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,indexer,a,link,org,elasticsearch,test,background,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,final,background,indexer,indexer,throws,interrupted,exception,return,wait,for,docs,num,docs,90,time,unit,seconds,indexer
CcrIntegTestCase -> public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException;1549452878;Waits until at least a give number of document is visible for searchers__@param numDocs number of documents to wait for_@param indexer a {@link org.elasticsearch.test.BackgroundIndexer}. Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException {_        _        return waitForDocs(numDocs, 90, TimeUnit.SECONDS, indexer)__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,indexer,a,link,org,elasticsearch,test,background,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,final,background,indexer,indexer,throws,interrupted,exception,return,wait,for,docs,num,docs,90,time,unit,seconds,indexer
CcrIntegTestCase -> public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException;1549895739;Waits until at least a give number of document is visible for searchers__@param numDocs number of documents to wait for_@param indexer a {@link org.elasticsearch.test.BackgroundIndexer}. Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException {_        _        return waitForDocs(numDocs, 90, TimeUnit.SECONDS, indexer)__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,indexer,a,link,org,elasticsearch,test,background,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,final,background,indexer,indexer,throws,interrupted,exception,return,wait,for,docs,num,docs,90,time,unit,seconds,indexer
CcrIntegTestCase -> public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException;1549963152;Waits until at least a give number of document is visible for searchers__@param numDocs number of documents to wait for_@param indexer a {@link org.elasticsearch.test.BackgroundIndexer}. Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException {_        _        return waitForDocs(numDocs, 90, TimeUnit.SECONDS, indexer)__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,indexer,a,link,org,elasticsearch,test,background,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,final,background,indexer,indexer,throws,interrupted,exception,return,wait,for,docs,num,docs,90,time,unit,seconds,indexer
CcrIntegTestCase -> public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException;1549989658;Waits until at least a give number of document is visible for searchers__@param numDocs number of documents to wait for_@param indexer a {@link org.elasticsearch.test.BackgroundIndexer}. Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException {_        _        return waitForDocs(numDocs, 90, TimeUnit.SECONDS, indexer)__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,indexer,a,link,org,elasticsearch,test,background,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,final,background,indexer,indexer,throws,interrupted,exception,return,wait,for,docs,num,docs,90,time,unit,seconds,indexer
CcrIntegTestCase -> public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException;1550256017;Waits until at least a give number of document is visible for searchers__@param numDocs number of documents to wait for_@param indexer a {@link org.elasticsearch.test.BackgroundIndexer}. Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException {_        _        return waitForDocs(numDocs, 90, TimeUnit.SECONDS, indexer)__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,indexer,a,link,org,elasticsearch,test,background,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,final,background,indexer,indexer,throws,interrupted,exception,return,wait,for,docs,num,docs,90,time,unit,seconds,indexer
CcrIntegTestCase -> public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException;1550348884;Waits until at least a give number of document is visible for searchers__@param numDocs number of documents to wait for_@param indexer a {@link org.elasticsearch.test.BackgroundIndexer}. Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException {_        _        return waitForDocs(numDocs, 90, TimeUnit.SECONDS, indexer)__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,indexer,a,link,org,elasticsearch,test,background,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,final,background,indexer,indexer,throws,interrupted,exception,return,wait,for,docs,num,docs,90,time,unit,seconds,indexer
CcrIntegTestCase -> public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException;1550502895;Waits until at least a give number of document is visible for searchers__@param numDocs number of documents to wait for_@param indexer a {@link org.elasticsearch.test.BackgroundIndexer}. Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException {_        _        return waitForDocs(numDocs, 90, TimeUnit.SECONDS, indexer)__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,indexer,a,link,org,elasticsearch,test,background,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,final,background,indexer,indexer,throws,interrupted,exception,return,wait,for,docs,num,docs,90,time,unit,seconds,indexer
CcrIntegTestCase -> public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException;1551132475;Waits until at least a give number of document is visible for searchers__@param numDocs number of documents to wait for_@param indexer a {@link org.elasticsearch.test.BackgroundIndexer}. Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, final BackgroundIndexer indexer) throws InterruptedException {_        _        return waitForDocs(numDocs, 90, TimeUnit.SECONDS, indexer)__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,indexer,a,link,org,elasticsearch,test,background,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,final,background,indexer,indexer,throws,interrupted,exception,return,wait,for,docs,num,docs,90,time,unit,seconds,indexer
CcrIntegTestCase -> public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)         throws InterruptedException;1549395161;Waits until at least a give number of document is visible for searchers__@param numDocs         number of documents to wait for_@param maxWaitTime     if not progress have been made during this time, fail the test_@param maxWaitTimeUnit the unit in which maxWaitTime is specified_@param indexer         Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)_        throws InterruptedException {_        final AtomicLong lastKnownCount = new AtomicLong(-1)__        long lastStartCount = -1__        BooleanSupplier testDocs = () -> {_            lastKnownCount.set(indexer.totalIndexedDocs())__            if (lastKnownCount.get() >= numDocs) {_                try {_                    long count = indexer.getClient().prepareSearch()_                        .setTrackTotalHits(true)_                        .setSize(0)_                        .setQuery(QueryBuilders.matchAllQuery())_                        .get()_                        .getHits().getTotalHits().value___                    if (count == lastKnownCount.get()) {_                        _                        indexer.getClient().admin().indices().prepareRefresh().get()__                    }_                    lastKnownCount.set(count)__                } catch (Exception e) { _                    logger.debug("failed to executed count", e)__                    return false__                }_                logger.debug("[{}] docs visible for search. waiting for [{}]", lastKnownCount.get(), numDocs)__            } else {_                logger.debug("[{}] docs indexed. waiting for [{}]", lastKnownCount.get(), numDocs)__            }_            return lastKnownCount.get() >= numDocs__        }___        while (!awaitBusy(testDocs, maxWaitTime, maxWaitTimeUnit)) {_            if (lastStartCount == lastKnownCount.get()) {_                _                fail("failed to reach " + numDocs + "docs")__            }_            lastStartCount = lastKnownCount.get()__        }_        return lastKnownCount.get()__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,max,wait,time,if,not,progress,have,been,made,during,this,time,fail,the,test,param,max,wait,time,unit,the,unit,in,which,max,wait,time,is,specified,param,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,int,max,wait,time,time,unit,max,wait,time,unit,final,background,indexer,indexer,throws,interrupted,exception,final,atomic,long,last,known,count,new,atomic,long,1,long,last,start,count,1,boolean,supplier,test,docs,last,known,count,set,indexer,total,indexed,docs,if,last,known,count,get,num,docs,try,long,count,indexer,get,client,prepare,search,set,track,total,hits,true,set,size,0,set,query,query,builders,match,all,query,get,get,hits,get,total,hits,value,if,count,last,known,count,get,indexer,get,client,admin,indices,prepare,refresh,get,last,known,count,set,count,catch,exception,e,logger,debug,failed,to,executed,count,e,return,false,logger,debug,docs,visible,for,search,waiting,for,last,known,count,get,num,docs,else,logger,debug,docs,indexed,waiting,for,last,known,count,get,num,docs,return,last,known,count,get,num,docs,while,await,busy,test,docs,max,wait,time,max,wait,time,unit,if,last,start,count,last,known,count,get,fail,failed,to,reach,num,docs,docs,last,start,count,last,known,count,get,return,last,known,count,get
CcrIntegTestCase -> public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)         throws InterruptedException;1549452878;Waits until at least a give number of document is visible for searchers__@param numDocs         number of documents to wait for_@param maxWaitTime     if not progress have been made during this time, fail the test_@param maxWaitTimeUnit the unit in which maxWaitTime is specified_@param indexer         Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)_        throws InterruptedException {_        final AtomicLong lastKnownCount = new AtomicLong(-1)__        long lastStartCount = -1__        BooleanSupplier testDocs = () -> {_            lastKnownCount.set(indexer.totalIndexedDocs())__            if (lastKnownCount.get() >= numDocs) {_                try {_                    long count = indexer.getClient().prepareSearch()_                        .setTrackTotalHits(true)_                        .setSize(0)_                        .setQuery(QueryBuilders.matchAllQuery())_                        .get()_                        .getHits().getTotalHits().value___                    if (count == lastKnownCount.get()) {_                        _                        indexer.getClient().admin().indices().prepareRefresh().get()__                    }_                    lastKnownCount.set(count)__                } catch (Exception e) { _                    logger.debug("failed to executed count", e)__                    return false__                }_                logger.debug("[{}] docs visible for search. waiting for [{}]", lastKnownCount.get(), numDocs)__            } else {_                logger.debug("[{}] docs indexed. waiting for [{}]", lastKnownCount.get(), numDocs)__            }_            return lastKnownCount.get() >= numDocs__        }___        while (!awaitBusy(testDocs, maxWaitTime, maxWaitTimeUnit)) {_            if (lastStartCount == lastKnownCount.get()) {_                _                fail("failed to reach " + numDocs + "docs")__            }_            lastStartCount = lastKnownCount.get()__        }_        return lastKnownCount.get()__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,max,wait,time,if,not,progress,have,been,made,during,this,time,fail,the,test,param,max,wait,time,unit,the,unit,in,which,max,wait,time,is,specified,param,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,int,max,wait,time,time,unit,max,wait,time,unit,final,background,indexer,indexer,throws,interrupted,exception,final,atomic,long,last,known,count,new,atomic,long,1,long,last,start,count,1,boolean,supplier,test,docs,last,known,count,set,indexer,total,indexed,docs,if,last,known,count,get,num,docs,try,long,count,indexer,get,client,prepare,search,set,track,total,hits,true,set,size,0,set,query,query,builders,match,all,query,get,get,hits,get,total,hits,value,if,count,last,known,count,get,indexer,get,client,admin,indices,prepare,refresh,get,last,known,count,set,count,catch,exception,e,logger,debug,failed,to,executed,count,e,return,false,logger,debug,docs,visible,for,search,waiting,for,last,known,count,get,num,docs,else,logger,debug,docs,indexed,waiting,for,last,known,count,get,num,docs,return,last,known,count,get,num,docs,while,await,busy,test,docs,max,wait,time,max,wait,time,unit,if,last,start,count,last,known,count,get,fail,failed,to,reach,num,docs,docs,last,start,count,last,known,count,get,return,last,known,count,get
CcrIntegTestCase -> public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)         throws InterruptedException;1549895739;Waits until at least a give number of document is visible for searchers__@param numDocs         number of documents to wait for_@param maxWaitTime     if not progress have been made during this time, fail the test_@param maxWaitTimeUnit the unit in which maxWaitTime is specified_@param indexer         Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)_        throws InterruptedException {_        final AtomicLong lastKnownCount = new AtomicLong(-1)__        long lastStartCount = -1__        BooleanSupplier testDocs = () -> {_            lastKnownCount.set(indexer.totalIndexedDocs())__            if (lastKnownCount.get() >= numDocs) {_                try {_                    long count = indexer.getClient().prepareSearch()_                        .setTrackTotalHits(true)_                        .setSize(0)_                        .setQuery(QueryBuilders.matchAllQuery())_                        .get()_                        .getHits().getTotalHits().value___                    if (count == lastKnownCount.get()) {_                        _                        indexer.getClient().admin().indices().prepareRefresh().get()__                    }_                    lastKnownCount.set(count)__                } catch (Exception e) { _                    logger.debug("failed to executed count", e)__                    return false__                }_                logger.debug("[{}] docs visible for search. waiting for [{}]", lastKnownCount.get(), numDocs)__            } else {_                logger.debug("[{}] docs indexed. waiting for [{}]", lastKnownCount.get(), numDocs)__            }_            return lastKnownCount.get() >= numDocs__        }___        while (!awaitBusy(testDocs, maxWaitTime, maxWaitTimeUnit)) {_            if (lastStartCount == lastKnownCount.get()) {_                _                fail("failed to reach " + numDocs + "docs")__            }_            lastStartCount = lastKnownCount.get()__        }_        return lastKnownCount.get()__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,max,wait,time,if,not,progress,have,been,made,during,this,time,fail,the,test,param,max,wait,time,unit,the,unit,in,which,max,wait,time,is,specified,param,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,int,max,wait,time,time,unit,max,wait,time,unit,final,background,indexer,indexer,throws,interrupted,exception,final,atomic,long,last,known,count,new,atomic,long,1,long,last,start,count,1,boolean,supplier,test,docs,last,known,count,set,indexer,total,indexed,docs,if,last,known,count,get,num,docs,try,long,count,indexer,get,client,prepare,search,set,track,total,hits,true,set,size,0,set,query,query,builders,match,all,query,get,get,hits,get,total,hits,value,if,count,last,known,count,get,indexer,get,client,admin,indices,prepare,refresh,get,last,known,count,set,count,catch,exception,e,logger,debug,failed,to,executed,count,e,return,false,logger,debug,docs,visible,for,search,waiting,for,last,known,count,get,num,docs,else,logger,debug,docs,indexed,waiting,for,last,known,count,get,num,docs,return,last,known,count,get,num,docs,while,await,busy,test,docs,max,wait,time,max,wait,time,unit,if,last,start,count,last,known,count,get,fail,failed,to,reach,num,docs,docs,last,start,count,last,known,count,get,return,last,known,count,get
CcrIntegTestCase -> public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)         throws InterruptedException;1549963152;Waits until at least a give number of document is visible for searchers__@param numDocs         number of documents to wait for_@param maxWaitTime     if not progress have been made during this time, fail the test_@param maxWaitTimeUnit the unit in which maxWaitTime is specified_@param indexer         Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)_        throws InterruptedException {_        final AtomicLong lastKnownCount = new AtomicLong(-1)__        long lastStartCount = -1__        BooleanSupplier testDocs = () -> {_            lastKnownCount.set(indexer.totalIndexedDocs())__            if (lastKnownCount.get() >= numDocs) {_                try {_                    long count = indexer.getClient().prepareSearch()_                        .setTrackTotalHits(true)_                        .setSize(0)_                        .setQuery(QueryBuilders.matchAllQuery())_                        .get()_                        .getHits().getTotalHits().value___                    if (count == lastKnownCount.get()) {_                        _                        indexer.getClient().admin().indices().prepareRefresh().get()__                    }_                    lastKnownCount.set(count)__                } catch (Exception e) { _                    logger.debug("failed to executed count", e)__                    return false__                }_                logger.debug("[{}] docs visible for search. waiting for [{}]", lastKnownCount.get(), numDocs)__            } else {_                logger.debug("[{}] docs indexed. waiting for [{}]", lastKnownCount.get(), numDocs)__            }_            return lastKnownCount.get() >= numDocs__        }___        while (!awaitBusy(testDocs, maxWaitTime, maxWaitTimeUnit)) {_            if (lastStartCount == lastKnownCount.get()) {_                _                fail("failed to reach " + numDocs + "docs")__            }_            lastStartCount = lastKnownCount.get()__        }_        return lastKnownCount.get()__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,max,wait,time,if,not,progress,have,been,made,during,this,time,fail,the,test,param,max,wait,time,unit,the,unit,in,which,max,wait,time,is,specified,param,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,int,max,wait,time,time,unit,max,wait,time,unit,final,background,indexer,indexer,throws,interrupted,exception,final,atomic,long,last,known,count,new,atomic,long,1,long,last,start,count,1,boolean,supplier,test,docs,last,known,count,set,indexer,total,indexed,docs,if,last,known,count,get,num,docs,try,long,count,indexer,get,client,prepare,search,set,track,total,hits,true,set,size,0,set,query,query,builders,match,all,query,get,get,hits,get,total,hits,value,if,count,last,known,count,get,indexer,get,client,admin,indices,prepare,refresh,get,last,known,count,set,count,catch,exception,e,logger,debug,failed,to,executed,count,e,return,false,logger,debug,docs,visible,for,search,waiting,for,last,known,count,get,num,docs,else,logger,debug,docs,indexed,waiting,for,last,known,count,get,num,docs,return,last,known,count,get,num,docs,while,await,busy,test,docs,max,wait,time,max,wait,time,unit,if,last,start,count,last,known,count,get,fail,failed,to,reach,num,docs,docs,last,start,count,last,known,count,get,return,last,known,count,get
CcrIntegTestCase -> public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)         throws InterruptedException;1549989658;Waits until at least a give number of document is visible for searchers__@param numDocs         number of documents to wait for_@param maxWaitTime     if not progress have been made during this time, fail the test_@param maxWaitTimeUnit the unit in which maxWaitTime is specified_@param indexer         Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)_        throws InterruptedException {_        final AtomicLong lastKnownCount = new AtomicLong(-1)__        long lastStartCount = -1__        BooleanSupplier testDocs = () -> {_            lastKnownCount.set(indexer.totalIndexedDocs())__            if (lastKnownCount.get() >= numDocs) {_                try {_                    long count = indexer.getClient().prepareSearch()_                        .setTrackTotalHits(true)_                        .setSize(0)_                        .setQuery(QueryBuilders.matchAllQuery())_                        .get()_                        .getHits().getTotalHits().value___                    if (count == lastKnownCount.get()) {_                        _                        indexer.getClient().admin().indices().prepareRefresh().get()__                    }_                    lastKnownCount.set(count)__                } catch (Exception e) { _                    logger.debug("failed to executed count", e)__                    return false__                }_                logger.debug("[{}] docs visible for search. waiting for [{}]", lastKnownCount.get(), numDocs)__            } else {_                logger.debug("[{}] docs indexed. waiting for [{}]", lastKnownCount.get(), numDocs)__            }_            return lastKnownCount.get() >= numDocs__        }___        while (!awaitBusy(testDocs, maxWaitTime, maxWaitTimeUnit)) {_            if (lastStartCount == lastKnownCount.get()) {_                _                fail("failed to reach " + numDocs + "docs")__            }_            lastStartCount = lastKnownCount.get()__        }_        return lastKnownCount.get()__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,max,wait,time,if,not,progress,have,been,made,during,this,time,fail,the,test,param,max,wait,time,unit,the,unit,in,which,max,wait,time,is,specified,param,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,int,max,wait,time,time,unit,max,wait,time,unit,final,background,indexer,indexer,throws,interrupted,exception,final,atomic,long,last,known,count,new,atomic,long,1,long,last,start,count,1,boolean,supplier,test,docs,last,known,count,set,indexer,total,indexed,docs,if,last,known,count,get,num,docs,try,long,count,indexer,get,client,prepare,search,set,track,total,hits,true,set,size,0,set,query,query,builders,match,all,query,get,get,hits,get,total,hits,value,if,count,last,known,count,get,indexer,get,client,admin,indices,prepare,refresh,get,last,known,count,set,count,catch,exception,e,logger,debug,failed,to,executed,count,e,return,false,logger,debug,docs,visible,for,search,waiting,for,last,known,count,get,num,docs,else,logger,debug,docs,indexed,waiting,for,last,known,count,get,num,docs,return,last,known,count,get,num,docs,while,await,busy,test,docs,max,wait,time,max,wait,time,unit,if,last,start,count,last,known,count,get,fail,failed,to,reach,num,docs,docs,last,start,count,last,known,count,get,return,last,known,count,get
CcrIntegTestCase -> public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)         throws InterruptedException;1550256017;Waits until at least a give number of document is visible for searchers__@param numDocs         number of documents to wait for_@param maxWaitTime     if not progress have been made during this time, fail the test_@param maxWaitTimeUnit the unit in which maxWaitTime is specified_@param indexer         Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)_        throws InterruptedException {_        final AtomicLong lastKnownCount = new AtomicLong(-1)__        long lastStartCount = -1__        BooleanSupplier testDocs = () -> {_            lastKnownCount.set(indexer.totalIndexedDocs())__            if (lastKnownCount.get() >= numDocs) {_                try {_                    long count = indexer.getClient().prepareSearch()_                        .setTrackTotalHits(true)_                        .setSize(0)_                        .setQuery(QueryBuilders.matchAllQuery())_                        .get()_                        .getHits().getTotalHits().value___                    if (count == lastKnownCount.get()) {_                        _                        indexer.getClient().admin().indices().prepareRefresh().get()__                    }_                    lastKnownCount.set(count)__                } catch (Exception e) { _                    logger.debug("failed to executed count", e)__                    return false__                }_                logger.debug("[{}] docs visible for search. waiting for [{}]", lastKnownCount.get(), numDocs)__            } else {_                logger.debug("[{}] docs indexed. waiting for [{}]", lastKnownCount.get(), numDocs)__            }_            return lastKnownCount.get() >= numDocs__        }___        while (!awaitBusy(testDocs, maxWaitTime, maxWaitTimeUnit)) {_            if (lastStartCount == lastKnownCount.get()) {_                _                fail("failed to reach " + numDocs + "docs")__            }_            lastStartCount = lastKnownCount.get()__        }_        return lastKnownCount.get()__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,max,wait,time,if,not,progress,have,been,made,during,this,time,fail,the,test,param,max,wait,time,unit,the,unit,in,which,max,wait,time,is,specified,param,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,int,max,wait,time,time,unit,max,wait,time,unit,final,background,indexer,indexer,throws,interrupted,exception,final,atomic,long,last,known,count,new,atomic,long,1,long,last,start,count,1,boolean,supplier,test,docs,last,known,count,set,indexer,total,indexed,docs,if,last,known,count,get,num,docs,try,long,count,indexer,get,client,prepare,search,set,track,total,hits,true,set,size,0,set,query,query,builders,match,all,query,get,get,hits,get,total,hits,value,if,count,last,known,count,get,indexer,get,client,admin,indices,prepare,refresh,get,last,known,count,set,count,catch,exception,e,logger,debug,failed,to,executed,count,e,return,false,logger,debug,docs,visible,for,search,waiting,for,last,known,count,get,num,docs,else,logger,debug,docs,indexed,waiting,for,last,known,count,get,num,docs,return,last,known,count,get,num,docs,while,await,busy,test,docs,max,wait,time,max,wait,time,unit,if,last,start,count,last,known,count,get,fail,failed,to,reach,num,docs,docs,last,start,count,last,known,count,get,return,last,known,count,get
CcrIntegTestCase -> public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)         throws InterruptedException;1550348884;Waits until at least a give number of document is visible for searchers__@param numDocs         number of documents to wait for_@param maxWaitTime     if not progress have been made during this time, fail the test_@param maxWaitTimeUnit the unit in which maxWaitTime is specified_@param indexer         Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)_        throws InterruptedException {_        final AtomicLong lastKnownCount = new AtomicLong(-1)__        long lastStartCount = -1__        BooleanSupplier testDocs = () -> {_            lastKnownCount.set(indexer.totalIndexedDocs())__            if (lastKnownCount.get() >= numDocs) {_                try {_                    long count = indexer.getClient().prepareSearch()_                        .setTrackTotalHits(true)_                        .setSize(0)_                        .setQuery(QueryBuilders.matchAllQuery())_                        .get()_                        .getHits().getTotalHits().value___                    if (count == lastKnownCount.get()) {_                        _                        indexer.getClient().admin().indices().prepareRefresh().get()__                    }_                    lastKnownCount.set(count)__                } catch (Exception e) { _                    logger.debug("failed to executed count", e)__                    return false__                }_                logger.debug("[{}] docs visible for search. waiting for [{}]", lastKnownCount.get(), numDocs)__            } else {_                logger.debug("[{}] docs indexed. waiting for [{}]", lastKnownCount.get(), numDocs)__            }_            return lastKnownCount.get() >= numDocs__        }___        while (!awaitBusy(testDocs, maxWaitTime, maxWaitTimeUnit)) {_            if (lastStartCount == lastKnownCount.get()) {_                _                fail("failed to reach " + numDocs + "docs")__            }_            lastStartCount = lastKnownCount.get()__        }_        return lastKnownCount.get()__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,max,wait,time,if,not,progress,have,been,made,during,this,time,fail,the,test,param,max,wait,time,unit,the,unit,in,which,max,wait,time,is,specified,param,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,int,max,wait,time,time,unit,max,wait,time,unit,final,background,indexer,indexer,throws,interrupted,exception,final,atomic,long,last,known,count,new,atomic,long,1,long,last,start,count,1,boolean,supplier,test,docs,last,known,count,set,indexer,total,indexed,docs,if,last,known,count,get,num,docs,try,long,count,indexer,get,client,prepare,search,set,track,total,hits,true,set,size,0,set,query,query,builders,match,all,query,get,get,hits,get,total,hits,value,if,count,last,known,count,get,indexer,get,client,admin,indices,prepare,refresh,get,last,known,count,set,count,catch,exception,e,logger,debug,failed,to,executed,count,e,return,false,logger,debug,docs,visible,for,search,waiting,for,last,known,count,get,num,docs,else,logger,debug,docs,indexed,waiting,for,last,known,count,get,num,docs,return,last,known,count,get,num,docs,while,await,busy,test,docs,max,wait,time,max,wait,time,unit,if,last,start,count,last,known,count,get,fail,failed,to,reach,num,docs,docs,last,start,count,last,known,count,get,return,last,known,count,get
CcrIntegTestCase -> public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)         throws InterruptedException;1550502895;Waits until at least a give number of document is visible for searchers__@param numDocs         number of documents to wait for_@param maxWaitTime     if not progress have been made during this time, fail the test_@param maxWaitTimeUnit the unit in which maxWaitTime is specified_@param indexer         Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)_        throws InterruptedException {_        final AtomicLong lastKnownCount = new AtomicLong(-1)__        long lastStartCount = -1__        BooleanSupplier testDocs = () -> {_            lastKnownCount.set(indexer.totalIndexedDocs())__            if (lastKnownCount.get() >= numDocs) {_                try {_                    long count = indexer.getClient().prepareSearch()_                        .setTrackTotalHits(true)_                        .setSize(0)_                        .setQuery(QueryBuilders.matchAllQuery())_                        .get()_                        .getHits().getTotalHits().value___                    if (count == lastKnownCount.get()) {_                        _                        indexer.getClient().admin().indices().prepareRefresh().get()__                    }_                    lastKnownCount.set(count)__                } catch (Exception e) { _                    logger.debug("failed to executed count", e)__                    return false__                }_                logger.debug("[{}] docs visible for search. waiting for [{}]", lastKnownCount.get(), numDocs)__            } else {_                logger.debug("[{}] docs indexed. waiting for [{}]", lastKnownCount.get(), numDocs)__            }_            return lastKnownCount.get() >= numDocs__        }___        while (!awaitBusy(testDocs, maxWaitTime, maxWaitTimeUnit)) {_            if (lastStartCount == lastKnownCount.get()) {_                _                fail("failed to reach " + numDocs + "docs")__            }_            lastStartCount = lastKnownCount.get()__        }_        return lastKnownCount.get()__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,max,wait,time,if,not,progress,have,been,made,during,this,time,fail,the,test,param,max,wait,time,unit,the,unit,in,which,max,wait,time,is,specified,param,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,int,max,wait,time,time,unit,max,wait,time,unit,final,background,indexer,indexer,throws,interrupted,exception,final,atomic,long,last,known,count,new,atomic,long,1,long,last,start,count,1,boolean,supplier,test,docs,last,known,count,set,indexer,total,indexed,docs,if,last,known,count,get,num,docs,try,long,count,indexer,get,client,prepare,search,set,track,total,hits,true,set,size,0,set,query,query,builders,match,all,query,get,get,hits,get,total,hits,value,if,count,last,known,count,get,indexer,get,client,admin,indices,prepare,refresh,get,last,known,count,set,count,catch,exception,e,logger,debug,failed,to,executed,count,e,return,false,logger,debug,docs,visible,for,search,waiting,for,last,known,count,get,num,docs,else,logger,debug,docs,indexed,waiting,for,last,known,count,get,num,docs,return,last,known,count,get,num,docs,while,await,busy,test,docs,max,wait,time,max,wait,time,unit,if,last,start,count,last,known,count,get,fail,failed,to,reach,num,docs,docs,last,start,count,last,known,count,get,return,last,known,count,get
CcrIntegTestCase -> public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)         throws InterruptedException;1551132475;Waits until at least a give number of document is visible for searchers__@param numDocs         number of documents to wait for_@param maxWaitTime     if not progress have been made during this time, fail the test_@param maxWaitTimeUnit the unit in which maxWaitTime is specified_@param indexer         Will be first checked for documents indexed._This saves on unneeded searches._@return the actual number of docs seen.;public long waitForDocs(final long numDocs, int maxWaitTime, TimeUnit maxWaitTimeUnit, final BackgroundIndexer indexer)_        throws InterruptedException {_        final AtomicLong lastKnownCount = new AtomicLong(-1)__        long lastStartCount = -1__        BooleanSupplier testDocs = () -> {_            lastKnownCount.set(indexer.totalIndexedDocs())__            if (lastKnownCount.get() >= numDocs) {_                try {_                    long count = indexer.getClient().prepareSearch()_                        .setTrackTotalHits(true)_                        .setSize(0)_                        .setQuery(QueryBuilders.matchAllQuery())_                        .get()_                        .getHits().getTotalHits().value___                    if (count == lastKnownCount.get()) {_                        _                        indexer.getClient().admin().indices().prepareRefresh().get()__                    }_                    lastKnownCount.set(count)__                } catch (Exception e) { _                    logger.debug("failed to executed count", e)__                    return false__                }_                logger.debug("[{}] docs visible for search. waiting for [{}]", lastKnownCount.get(), numDocs)__            } else {_                logger.debug("[{}] docs indexed. waiting for [{}]", lastKnownCount.get(), numDocs)__            }_            return lastKnownCount.get() >= numDocs__        }___        while (!awaitBusy(testDocs, maxWaitTime, maxWaitTimeUnit)) {_            if (lastStartCount == lastKnownCount.get()) {_                _                fail("failed to reach " + numDocs + "docs")__            }_            lastStartCount = lastKnownCount.get()__        }_        return lastKnownCount.get()__    };waits,until,at,least,a,give,number,of,document,is,visible,for,searchers,param,num,docs,number,of,documents,to,wait,for,param,max,wait,time,if,not,progress,have,been,made,during,this,time,fail,the,test,param,max,wait,time,unit,the,unit,in,which,max,wait,time,is,specified,param,indexer,will,be,first,checked,for,documents,indexed,this,saves,on,unneeded,searches,return,the,actual,number,of,docs,seen;public,long,wait,for,docs,final,long,num,docs,int,max,wait,time,time,unit,max,wait,time,unit,final,background,indexer,indexer,throws,interrupted,exception,final,atomic,long,last,known,count,new,atomic,long,1,long,last,start,count,1,boolean,supplier,test,docs,last,known,count,set,indexer,total,indexed,docs,if,last,known,count,get,num,docs,try,long,count,indexer,get,client,prepare,search,set,track,total,hits,true,set,size,0,set,query,query,builders,match,all,query,get,get,hits,get,total,hits,value,if,count,last,known,count,get,indexer,get,client,admin,indices,prepare,refresh,get,last,known,count,set,count,catch,exception,e,logger,debug,failed,to,executed,count,e,return,false,logger,debug,docs,visible,for,search,waiting,for,last,known,count,get,num,docs,else,logger,debug,docs,indexed,waiting,for,last,known,count,get,num,docs,return,last,known,count,get,num,docs,while,await,busy,test,docs,max,wait,time,max,wait,time,unit,if,last,start,count,last,known,count,get,fail,failed,to,reach,num,docs,docs,last,start,count,last,known,count,get,return,last,known,count,get
