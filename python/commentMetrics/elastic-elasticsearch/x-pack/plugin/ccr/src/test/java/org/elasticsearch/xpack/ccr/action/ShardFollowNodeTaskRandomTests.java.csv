commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public void testSingleReaderWriter() throws Exception {     TestRun testRun = createTestRun(randomNonNegativeLong(), randomNonNegativeLong(), randomNonNegativeLong(), randomIntBetween(1, 2048)).     ShardFollowNodeTask task = createShardFollowTask(1, testRun).     startAndAssertAndStopTask(task, testRun). }
false;public;0;6;;public void testMultipleReaderWriter() throws Exception {     int concurrency = randomIntBetween(2, 8).     TestRun testRun = createTestRun(0, 0, 0, between(1, 1024)).     ShardFollowNodeTask task = createShardFollowTask(concurrency, testRun).     startAndAssertAndStopTask(task, testRun). }
false;private;2;21;;private void startAndAssertAndStopTask(ShardFollowNodeTask task, TestRun testRun) throws Exception {     task.start("uuid", testRun.startSeqNo - 1, testRun.startSeqNo - 1, testRun.startSeqNo - 1, testRun.startSeqNo - 1).     assertBusy(() -> {         ShardFollowNodeTaskStatus status = task.getStatus().         assertThat(status.leaderGlobalCheckpoint(), equalTo(testRun.finalExpectedGlobalCheckpoint)).         assertThat(status.followerGlobalCheckpoint(), equalTo(testRun.finalExpectedGlobalCheckpoint)).         final long numberOfFailedFetches = testRun.responses.values().stream().flatMap(List::stream).filter(f -> f.exception != null).count().         assertThat(status.failedReadRequests(), equalTo(numberOfFailedFetches)).         // the failures were able to be retried so fetch failures should have cleared         assertThat(status.readExceptions().entrySet(), hasSize(0)).         assertThat(status.followerMappingVersion(), equalTo(testRun.finalMappingVersion)).     }).     task.markAsCompleted().     assertBusy(() -> {         ShardFollowNodeTaskStatus status = task.getStatus().         assertThat(status.outstandingReadRequests(), equalTo(0)).         assertThat(status.outstandingWriteRequests(), equalTo(0)).     }). }
false;protected;3;4;;@Override protected void innerUpdateMapping(long minRequiredMappingVersion, LongConsumer handler, Consumer<Exception> errorHandler) {     handler.accept(mappingVersion). }
false;protected;2;4;;@Override protected void innerUpdateSettings(LongConsumer handler, Consumer<Exception> errorHandler) {     handler.accept(settingsVersion). }
false;protected;5;17;;@Override protected void innerSendBulkShardOperationsRequest(String followerHistoryUUID, List<Translog.Operation> operations, long maxSeqNoOfUpdates, Consumer<BulkShardOperationsResponse> handler, Consumer<Exception> errorHandler) {     for (Translog.Operation op : operations) {         tracker.markSeqNoAsCompleted(op.seqNo()).     }     receivedOperations.addAll(operations).     // Emulate network thread and avoid SO:     final BulkShardOperationsResponse response = new BulkShardOperationsResponse().     response.setGlobalCheckpoint(tracker.getCheckpoint()).     response.setMaxSeqNo(tracker.getMaxSeqNo()).     threadPool.generic().execute(() -> handler.accept(response)). }
false;protected;4;38;;@Override protected void innerSendShardChangesRequest(long from, int maxOperationCount, Consumer<ShardChangesAction.Response> handler, Consumer<Exception> errorHandler) {     // Emulate network thread and avoid SO:     Runnable task = () -> {         List<TestResponse> items = testRun.responses.get(from).         if (items != null) {             final TestResponse testResponse.             synchronized (fromToSlot) {                 int slot.                 if (fromToSlot.get(from) == null) {                     slot = fromToSlot.getOrDefault(from, 0).                     fromToSlot.put(from, slot).                 } else {                     slot = fromToSlot.get(from).                 }                 testResponse = items.get(slot).                 fromToSlot.put(from, ++slot).             // if too many invocations occur with the same from then AOBE occurs, this ok and then something is wrong.             }             mappingVersion = testResponse.mappingVersion.             settingsVersion = testResponse.settingsVersion.             if (testResponse.exception != null) {                 errorHandler.accept(testResponse.exception).             } else {                 handler.accept(testResponse.response).             }         } else {             assert from >= testRun.finalExpectedGlobalCheckpoint.             final long globalCheckpoint = tracker.getCheckpoint().             final long maxSeqNo = tracker.getMaxSeqNo().             handler.accept(new ShardChangesAction.Response(0L, 0L, globalCheckpoint, maxSeqNo, randomNonNegativeLong(), new Translog.Operation[0], 1L)).         }     }.     threadPool.generic().execute(task). }
false;public;0;4;;@Override public boolean cancel() {     return true. }
false;public;0;4;;@Override public boolean isCancelled() {     return true. }
false;protected;1;16;;@Override protected Scheduler.Cancellable scheduleBackgroundRetentionLeaseRenewal(final LongSupplier followerGlobalCheckpoint) {     return new Scheduler.Cancellable() {          @Override         public boolean cancel() {             return true.         }          @Override         public boolean isCancelled() {             return true.         }     }. }
false;protected;0;4;;@Override protected boolean isStopped() {     return stopped.get(). }
false;public;0;5;;@Override public void markAsCompleted() {     stopped.set(true).     tearDown(). }
false;public;1;5;;@Override public void markAsFailed(Exception e) {     stopped.set(true).     tearDown(). }
false;private;0;17;;private void tearDown() {     threadPool.shutdown().     List<Translog.Operation> expectedOperations = testRun.responses.values().stream().flatMap(List::stream).map(testResponse -> testResponse.response).filter(Objects::nonNull).flatMap(response -> Arrays.stream(response.getOperations())).sorted(Comparator.comparingLong(Translog.Operation::seqNo)).collect(Collectors.toList()).     assertThat(receivedOperations.size(), equalTo(expectedOperations.size())).     receivedOperations.sort(Comparator.comparingLong(Translog.Operation::seqNo)).     for (int i = 0. i < receivedOperations.size(). i++) {         Translog.Operation actual = receivedOperations.get(i).         Translog.Operation expected = expectedOperations.get(i).         assertThat(actual, equalTo(expected)).     } }
false;private;2;155;;private ShardFollowNodeTask createShardFollowTask(int concurrency, TestRun testRun) {     AtomicBoolean stopped = new AtomicBoolean(false).     ShardFollowTask params = new ShardFollowTask(null, new ShardId("follow_index", "", 0), new ShardId("leader_index", "", 0), testRun.maxOperationCount, testRun.maxOperationCount, concurrency, concurrency, TransportResumeFollowAction.DEFAULT_MAX_READ_REQUEST_SIZE, TransportResumeFollowAction.DEFAULT_MAX_READ_REQUEST_SIZE, 10240, new ByteSizeValue(512, ByteSizeUnit.MB), TimeValue.timeValueMillis(10), TimeValue.timeValueMillis(10), Collections.emptyMap()).     ThreadPool threadPool = new TestThreadPool(getClass().getSimpleName()).     BiConsumer<TimeValue, Runnable> scheduler = (delay, task) -> {         assert delay.millis() < 100 : "The delay should be kept to a minimum, so that this test does not take to long to run".         if (stopped.get() == false) {             threadPool.schedule(task, delay, ThreadPool.Names.GENERIC).         }     }.     List<Translog.Operation> receivedOperations = Collections.synchronizedList(new ArrayList<>()).     LocalCheckpointTracker tracker = new LocalCheckpointTracker(testRun.startSeqNo - 1, testRun.startSeqNo - 1).     return new ShardFollowNodeTask(1L, "type", ShardFollowTask.NAME, "description", null, Collections.emptyMap(), params, scheduler, System::nanoTime) {          private volatile long mappingVersion = 0L.          private volatile long settingsVersion = 0L.          private final Map<Long, Integer> fromToSlot = new HashMap<>().          @Override         protected void innerUpdateMapping(long minRequiredMappingVersion, LongConsumer handler, Consumer<Exception> errorHandler) {             handler.accept(mappingVersion).         }          @Override         protected void innerUpdateSettings(LongConsumer handler, Consumer<Exception> errorHandler) {             handler.accept(settingsVersion).         }          @Override         protected void innerSendBulkShardOperationsRequest(String followerHistoryUUID, List<Translog.Operation> operations, long maxSeqNoOfUpdates, Consumer<BulkShardOperationsResponse> handler, Consumer<Exception> errorHandler) {             for (Translog.Operation op : operations) {                 tracker.markSeqNoAsCompleted(op.seqNo()).             }             receivedOperations.addAll(operations).             // Emulate network thread and avoid SO:             final BulkShardOperationsResponse response = new BulkShardOperationsResponse().             response.setGlobalCheckpoint(tracker.getCheckpoint()).             response.setMaxSeqNo(tracker.getMaxSeqNo()).             threadPool.generic().execute(() -> handler.accept(response)).         }          @Override         protected void innerSendShardChangesRequest(long from, int maxOperationCount, Consumer<ShardChangesAction.Response> handler, Consumer<Exception> errorHandler) {             // Emulate network thread and avoid SO:             Runnable task = () -> {                 List<TestResponse> items = testRun.responses.get(from).                 if (items != null) {                     final TestResponse testResponse.                     synchronized (fromToSlot) {                         int slot.                         if (fromToSlot.get(from) == null) {                             slot = fromToSlot.getOrDefault(from, 0).                             fromToSlot.put(from, slot).                         } else {                             slot = fromToSlot.get(from).                         }                         testResponse = items.get(slot).                         fromToSlot.put(from, ++slot).                     // if too many invocations occur with the same from then AOBE occurs, this ok and then something is wrong.                     }                     mappingVersion = testResponse.mappingVersion.                     settingsVersion = testResponse.settingsVersion.                     if (testResponse.exception != null) {                         errorHandler.accept(testResponse.exception).                     } else {                         handler.accept(testResponse.response).                     }                 } else {                     assert from >= testRun.finalExpectedGlobalCheckpoint.                     final long globalCheckpoint = tracker.getCheckpoint().                     final long maxSeqNo = tracker.getMaxSeqNo().                     handler.accept(new ShardChangesAction.Response(0L, 0L, globalCheckpoint, maxSeqNo, randomNonNegativeLong(), new Translog.Operation[0], 1L)).                 }             }.             threadPool.generic().execute(task).         }          @Override         protected Scheduler.Cancellable scheduleBackgroundRetentionLeaseRenewal(final LongSupplier followerGlobalCheckpoint) {             return new Scheduler.Cancellable() {                  @Override                 public boolean cancel() {                     return true.                 }                  @Override                 public boolean isCancelled() {                     return true.                 }             }.         }          @Override         protected boolean isStopped() {             return stopped.get().         }          @Override         public void markAsCompleted() {             stopped.set(true).             tearDown().         }          @Override         public void markAsFailed(Exception e) {             stopped.set(true).             tearDown().         }          private void tearDown() {             threadPool.shutdown().             List<Translog.Operation> expectedOperations = testRun.responses.values().stream().flatMap(List::stream).map(testResponse -> testResponse.response).filter(Objects::nonNull).flatMap(response -> Arrays.stream(response.getOperations())).sorted(Comparator.comparingLong(Translog.Operation::seqNo)).collect(Collectors.toList()).             assertThat(receivedOperations.size(), equalTo(expectedOperations.size())).             receivedOperations.sort(Comparator.comparingLong(Translog.Operation::seqNo)).             for (int i = 0. i < receivedOperations.size(). i++) {                 Translog.Operation actual = receivedOperations.get(i).                 Translog.Operation expected = expectedOperations.get(i).                 assertThat(actual, equalTo(expected)).             }         }     }. }
false;private,static;4;94;;private static TestRun createTestRun(long startSeqNo, long startMappingVersion, long startSettingsVersion, int maxOperationCount) {     long prevGlobalCheckpoint = startSeqNo.     long mappingVersion = startMappingVersion.     long settingsVersion = startSettingsVersion.     int numResponses = randomIntBetween(16, 256).     Map<Long, List<TestResponse>> responses = new HashMap<>(numResponses).     for (int i = 0. i < numResponses. i++) {         long nextGlobalCheckPoint = prevGlobalCheckpoint + maxOperationCount.         if (sometimes()) {             mappingVersion++.         }         if (sometimes()) {             settingsVersion++.         }         if (sometimes()) {             List<TestResponse> item = new ArrayList<>().             // Sometimes add a random retryable error             if (sometimes()) {                 Exception error = new UnavailableShardsException(new ShardId("test", "test", 0), "").                 item.add(new TestResponse(error, mappingVersion, settingsVersion, null)).             }             List<Translog.Operation> ops = new ArrayList<>().             for (long seqNo = prevGlobalCheckpoint. seqNo <= nextGlobalCheckPoint. seqNo++) {                 String id = UUIDs.randomBase64UUID().                 byte[] source = "{}".getBytes(StandardCharsets.UTF_8).                 ops.add(new Translog.Index("doc", id, seqNo, 0, source)).             }             item.add(new TestResponse(null, mappingVersion, settingsVersion, new ShardChangesAction.Response(mappingVersion, settingsVersion, nextGlobalCheckPoint, nextGlobalCheckPoint, randomNonNegativeLong(), ops.toArray(EMPTY), randomNonNegativeLong()))).             responses.put(prevGlobalCheckpoint, item).         } else {             // Simulates a leader shard copy not having all the operations the shard follow task thinks it has by             // splitting up a response into multiple responses AND simulates maxBatchSizeInBytes limit being reached:             long toSeqNo.             for (long fromSeqNo = prevGlobalCheckpoint. fromSeqNo <= nextGlobalCheckPoint. fromSeqNo = toSeqNo + 1) {                 toSeqNo = randomLongBetween(fromSeqNo, nextGlobalCheckPoint).                 List<TestResponse> item = new ArrayList<>().                 // Sometimes add a random retryable error                 if (sometimes()) {                     Exception error = new UnavailableShardsException(new ShardId("test", "test", 0), "").                     item.add(new TestResponse(error, mappingVersion, settingsVersion, null)).                 }                 // Sometimes add an empty shard changes response to also simulate a leader shard lagging behind                 if (sometimes()) {                     ShardChangesAction.Response response = new ShardChangesAction.Response(mappingVersion, settingsVersion, prevGlobalCheckpoint, prevGlobalCheckpoint, randomNonNegativeLong(), EMPTY, randomNonNegativeLong()).                     item.add(new TestResponse(null, mappingVersion, settingsVersion, response)).                 }                 List<Translog.Operation> ops = new ArrayList<>().                 for (long seqNo = fromSeqNo. seqNo <= toSeqNo. seqNo++) {                     String id = UUIDs.randomBase64UUID().                     byte[] source = "{}".getBytes(StandardCharsets.UTF_8).                     ops.add(new Translog.Index("doc", id, seqNo, 0, source)).                 }                 // Report toSeqNo to simulate maxBatchSizeInBytes limit being met or last op to simulate a shard lagging behind:                 long localLeaderGCP = randomBoolean() ? ops.get(ops.size() - 1).seqNo() : toSeqNo.                 ShardChangesAction.Response response = new ShardChangesAction.Response(mappingVersion, settingsVersion, localLeaderGCP, localLeaderGCP, randomNonNegativeLong(), ops.toArray(EMPTY), randomNonNegativeLong()).                 item.add(new TestResponse(null, mappingVersion, settingsVersion, response)).                 responses.put(fromSeqNo, Collections.unmodifiableList(item)).             }         }         prevGlobalCheckpoint = nextGlobalCheckPoint + 1.     }     return new TestRun(maxOperationCount, startSeqNo, startMappingVersion, mappingVersion, prevGlobalCheckpoint - 1, responses). }
true;private,static;0;3;// Instead of rarely(), which returns true very rarely especially not running in nightly mode or a multiplier have not been set ;// Instead of rarely(), which returns true very rarely especially not running in nightly mode or a multiplier have not been set private static boolean sometimes() {     return randomIntBetween(0, 10) == 5. }
