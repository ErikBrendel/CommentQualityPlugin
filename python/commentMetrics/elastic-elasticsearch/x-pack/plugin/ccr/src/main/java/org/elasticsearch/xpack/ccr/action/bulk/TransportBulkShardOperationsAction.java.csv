commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;9;;@Override protected WritePrimaryResult<BulkShardOperationsRequest, BulkShardOperationsResponse> shardOperationOnPrimary(final BulkShardOperationsRequest request, final IndexShard primary) throws Exception {     if (logger.isTraceEnabled()) {         logger.trace("index [{}] on the following primary shard {}", request.getOperations(), primary.routingEntry()).     }     return shardOperationOnPrimary(request.shardId(), request.getHistoryUUID(), request.getOperations(), request.getMaxSeqNoOfUpdatesOrDeletes(), primary, logger). }
false;public,static;2;34;;public static Translog.Operation rewriteOperationWithPrimaryTerm(Translog.Operation operation, long primaryTerm) {     final Translog.Operation operationWithPrimaryTerm.     switch(operation.opType()) {         case INDEX:             final Translog.Index index = (Translog.Index) operation.             operationWithPrimaryTerm = new Translog.Index(index.type(), index.id(), index.seqNo(), primaryTerm, index.version(), BytesReference.toBytes(index.source()), index.routing(), index.getAutoGeneratedIdTimestamp()).             break.         case DELETE:             final Translog.Delete delete = (Translog.Delete) operation.             operationWithPrimaryTerm = new Translog.Delete(delete.type(), delete.id(), delete.uid(), delete.seqNo(), primaryTerm, delete.version()).             break.         case NO_OP:             final Translog.NoOp noOp = (Translog.NoOp) operation.             operationWithPrimaryTerm = new Translog.NoOp(noOp.seqNo(), primaryTerm, noOp.reason()).             break.         default:             throw new IllegalStateException("unexpected operation type [" + operation.opType() + "]").     }     return operationWithPrimaryTerm. }
true;public,static;6;53;// public for testing purposes only ;// public for testing purposes only public static CcrWritePrimaryResult shardOperationOnPrimary(final ShardId shardId, final String historyUUID, final List<Translog.Operation> sourceOperations, final long maxSeqNoOfUpdatesOrDeletes, final IndexShard primary, final Logger logger) throws IOException {     if (historyUUID.equalsIgnoreCase(primary.getHistoryUUID()) == false) {         throw new IllegalStateException("unexpected history uuid, expected [" + historyUUID + "], actual [" + primary.getHistoryUUID() + "], shard is likely restored from snapshot or force allocated").     }     assert maxSeqNoOfUpdatesOrDeletes >= SequenceNumbers.NO_OPS_PERFORMED : "invalid msu [" + maxSeqNoOfUpdatesOrDeletes + "]".     primary.advanceMaxSeqNoOfUpdatesOrDeletes(maxSeqNoOfUpdatesOrDeletes).     final List<Translog.Operation> appliedOperations = new ArrayList<>(sourceOperations.size()).     Translog.Location location = null.     for (Translog.Operation sourceOp : sourceOperations) {         final Translog.Operation targetOp = rewriteOperationWithPrimaryTerm(sourceOp, primary.getOperationPrimaryTerm()).         final Engine.Result result = primary.applyTranslogOperation(targetOp, Engine.Operation.Origin.PRIMARY).         if (result.getResultType() == Engine.Result.Type.SUCCESS) {             assert result.getSeqNo() == targetOp.seqNo().             appliedOperations.add(targetOp).             location = locationToSync(location, result.getTranslogLocation()).         } else {             if (result.getFailure() instanceof AlreadyProcessedFollowingEngineException) {                 // The existing operations below the global checkpoint won't be replicated as they were processed                 // in every replicas already. However, the existing operations above the global checkpoint will be                 // replicated to replicas but with the existing primary term (not the current primary term) in order                 // to guarantee the consistency between the primary and replicas, and between translog and Lucene index.                 final AlreadyProcessedFollowingEngineException failure = (AlreadyProcessedFollowingEngineException) result.getFailure().                 if (logger.isTraceEnabled()) {                     logger.trace("operation [{}] was processed before on following primary shard {} with existing term {}", targetOp, primary.routingEntry(), failure.getExistingPrimaryTerm()).                 }                 assert failure.getSeqNo() == targetOp.seqNo() : targetOp.seqNo() + " != " + failure.getSeqNo().                 if (failure.getExistingPrimaryTerm().isPresent()) {                     appliedOperations.add(rewriteOperationWithPrimaryTerm(sourceOp, failure.getExistingPrimaryTerm().getAsLong())).                 } else if (targetOp.seqNo() > primary.getGlobalCheckpoint()) {                     assert false : "can't find primary_term for existing op=" + targetOp + " gcp=" + primary.getGlobalCheckpoint().                     throw new IllegalStateException("can't find primary_term for existing op=" + targetOp + " global_checkpoint=" + primary.getGlobalCheckpoint(), failure).                 }             } else {                 assert false : "Only already-processed error should happen. op=[" + targetOp + "] error=[" + result.getFailure() + "]".                 throw ExceptionsHelper.convertToElastic(result.getFailure()).             }         }     }     final BulkShardOperationsRequest replicaRequest = new BulkShardOperationsRequest(shardId, historyUUID, appliedOperations, maxSeqNoOfUpdatesOrDeletes).     return new CcrWritePrimaryResult(replicaRequest, location, primary, logger). }
false;protected;2;8;;@Override protected WriteReplicaResult<BulkShardOperationsRequest> shardOperationOnReplica(final BulkShardOperationsRequest request, final IndexShard replica) throws Exception {     if (logger.isTraceEnabled()) {         logger.trace("index [{}] on the following replica shard {}", request.getOperations(), replica.routingEntry()).     }     return shardOperationOnReplica(request, replica, logger). }
true;public,static;3;17;// public for testing purposes only ;// public for testing purposes only public static WriteReplicaResult<BulkShardOperationsRequest> shardOperationOnReplica(final BulkShardOperationsRequest request, final IndexShard replica, final Logger logger) throws IOException {     assert replica.getMaxSeqNoOfUpdatesOrDeletes() >= request.getMaxSeqNoOfUpdatesOrDeletes() : "mus on replica [" + replica + "] < mus of request [" + request.getMaxSeqNoOfUpdatesOrDeletes() + "]".     Translog.Location location = null.     for (final Translog.Operation operation : request.getOperations()) {         final Engine.Result result = replica.applyTranslogOperation(operation, Engine.Operation.Origin.REPLICA).         if (result.getResultType() != Engine.Result.Type.SUCCESS) {             assert false : "doc-level failure must not happen on replicas. op[" + operation + "] error[" + result.getFailure() + "]".             throw ExceptionsHelper.convertToElastic(result.getFailure()).         }         assert result.getSeqNo() == operation.seqNo().         location = locationToSync(location, result.getTranslogLocation()).     }     assert request.getOperations().size() == 0 || location != null.     return new WriteReplicaResult<>(request, location, null, replica, logger). }
false;protected;0;4;;@Override protected BulkShardOperationsResponse newResponseInstance() {     return new BulkShardOperationsResponse(). }
false;public,synchronized;1;11;;@Override public synchronized void respond(ActionListener<BulkShardOperationsResponse> listener) {     final ActionListener<BulkShardOperationsResponse> wrappedListener = ActionListener.wrap(response -> {         final SeqNoStats seqNoStats = primary.seqNoStats().         // return a fresh global checkpoint after the operations have been replicated for the shard follow task         response.setGlobalCheckpoint(seqNoStats.getGlobalCheckpoint()).         response.setMaxSeqNo(seqNoStats.getMaxSeqNo()).         listener.onResponse(response).     }, listener::onFailure).     super.respond(wrappedListener). }
