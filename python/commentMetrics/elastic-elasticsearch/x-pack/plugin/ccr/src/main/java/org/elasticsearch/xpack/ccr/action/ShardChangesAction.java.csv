# id;timestamp;commentText;codeText;commentWords;codeWords
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1538424609;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1539615817;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1540313026;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1540486836;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1541419698;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1541490167;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1541643651;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1548268873;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1548664204;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        } catch (MissingHistoryOperationsException e) {_            String message = "Operations are no longer available for replicating. Maybe increase the retention setting [" +_                IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey() + "]?"__            _            _            ResourceNotFoundException wrapper = new ResourceNotFoundException(message, e)__            wrapper.addMetadata(Ccr.REQUESTED_OPS_MISSING_METADATA_KEY, Long.toString(fromSeqNo), Long.toString(toSeqNo))__            throw wrapper__        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,catch,missing,history,operations,exception,e,string,message,operations,are,no,longer,available,for,replicating,maybe,increase,the,retention,setting,index,settings,get,key,resource,not,found,exception,wrapper,new,resource,not,found,exception,message,e,wrapper,add,metadata,ccr,long,to,string,from,seq,no,long,to,string,to,seq,no,throw,wrapper,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(             final IndexShard indexShard,             final long globalCheckpoint,             final long fromSeqNo,             final int maxOperationCount,             final String expectedHistoryUUID,             final ByteSizeValue maxBatchSize) throws IOException;1551098372;Returns at most the specified maximum number of operations from the specified from sequence number. This method will never return_operations above the specified global checkpoint.__Also if the sum of collected operations size is above the specified maximum batch size then this method stops collecting more_operations and returns what has been collected so far.__@param indexShard the shard_@param globalCheckpoint the global checkpoint_@param fromSeqNo the starting sequence number_@param maxOperationCount the maximum number of operations_@param expectedHistoryUUID the expected history UUID for the shard_@param maxBatchSize the maximum batch size_@return the operations_@throws IOException if an I/O exception occurs reading the operations;static Translog.Operation[] getOperations(_            final IndexShard indexShard,_            final long globalCheckpoint,_            final long fromSeqNo,_            final int maxOperationCount,_            final String expectedHistoryUUID,_            final ByteSizeValue maxBatchSize) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxBatchSize.getBytes()) {_                    break__                }_            }_        } catch (MissingHistoryOperationsException e) {_            String message = "Operations are no longer available for replicating. Maybe increase the retention setting [" +_                IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey() + "]?"__            _            _            ResourceNotFoundException wrapper = new ResourceNotFoundException(message, e)__            wrapper.addMetadata(Ccr.REQUESTED_OPS_MISSING_METADATA_KEY, Long.toString(fromSeqNo), Long.toString(toSeqNo))__            throw wrapper__        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,the,specified,maximum,number,of,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,maximum,batch,size,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far,param,index,shard,the,shard,param,global,checkpoint,the,global,checkpoint,param,from,seq,no,the,starting,sequence,number,param,max,operation,count,the,maximum,number,of,operations,param,expected,history,uuid,the,expected,history,uuid,for,the,shard,param,max,batch,size,the,maximum,batch,size,return,the,operations,throws,ioexception,if,an,i,o,exception,occurs,reading,the,operations;static,translog,operation,get,operations,final,index,shard,index,shard,final,long,global,checkpoint,final,long,from,seq,no,final,int,max,operation,count,final,string,expected,history,uuid,final,byte,size,value,max,batch,size,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,batch,size,get,bytes,break,catch,missing,history,operations,exception,e,string,message,operations,are,no,longer,available,for,replicating,maybe,increase,the,retention,setting,index,settings,get,key,resource,not,found,exception,wrapper,new,resource,not,found,exception,message,e,wrapper,add,metadata,ccr,long,to,string,from,seq,no,long,to,string,to,seq,no,throw,wrapper,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(IndexShard indexShard, long globalCheckpoint, long fromSeqNo, int maxOperationCount,                                               long maxOperationSizeInBytes) throws IOException;1535965276;Returns at most maxOperationCount operations from the specified from sequence number._This method will never return operations above the specified globalCheckpoint.__Also if the sum of collected operations' size is above the specified maxOperationSizeInBytes then this method_stops collecting more operations and returns what has been collected so far.;static Translog.Operation[] getOperations(IndexShard indexShard, long globalCheckpoint, long fromSeqNo, int maxOperationCount,_                                              long maxOperationSizeInBytes) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        if (fromSeqNo > indexShard.getGlobalCheckpoint()) {_            return EMPTY_OPERATIONS_ARRAY__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxOperationSizeInBytes) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,max,operation,count,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,max,operation,size,in,bytes,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far;static,translog,operation,get,operations,index,shard,index,shard,long,global,checkpoint,long,from,seq,no,int,max,operation,count,long,max,operation,size,in,bytes,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,if,from,seq,no,index,shard,get,global,checkpoint,return,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,operation,size,in,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(IndexShard indexShard, long globalCheckpoint, long fromSeqNo, int maxOperationCount,                                               long maxOperationSizeInBytes) throws IOException;1536611444;Returns at most maxOperationCount operations from the specified from sequence number._This method will never return operations above the specified globalCheckpoint.__Also if the sum of collected operations' size is above the specified maxOperationSizeInBytes then this method_stops collecting more operations and returns what has been collected so far.;static Translog.Operation[] getOperations(IndexShard indexShard, long globalCheckpoint, long fromSeqNo, int maxOperationCount,_                                              long maxOperationSizeInBytes) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        if (fromSeqNo > globalCheckpoint) {_            return EMPTY_OPERATIONS_ARRAY__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxOperationSizeInBytes) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,max,operation,count,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,max,operation,size,in,bytes,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far;static,translog,operation,get,operations,index,shard,index,shard,long,global,checkpoint,long,from,seq,no,int,max,operation,count,long,max,operation,size,in,bytes,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,if,from,seq,no,global,checkpoint,return,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,operation,size,in,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(IndexShard indexShard,                                               long globalCheckpoint,                                               long fromSeqNo,                                               int maxOperationCount,                                               String expectedHistoryUUID,                                               long maxOperationSizeInBytes) throws IOException;1536828374;Returns at most maxOperationCount operations from the specified from sequence number._This method will never return operations above the specified globalCheckpoint.__Also if the sum of collected operations' size is above the specified maxOperationSizeInBytes then this method_stops collecting more operations and returns what has been collected so far.;static Translog.Operation[] getOperations(IndexShard indexShard,_                                              long globalCheckpoint,_                                              long fromSeqNo,_                                              int maxOperationCount,_                                              String expectedHistoryUUID,_                                              long maxOperationSizeInBytes) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            return EMPTY_OPERATIONS_ARRAY__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxOperationSizeInBytes) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,max,operation,count,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,max,operation,size,in,bytes,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far;static,translog,operation,get,operations,index,shard,index,shard,long,global,checkpoint,long,from,seq,no,int,max,operation,count,string,expected,history,uuid,long,max,operation,size,in,bytes,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,return,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,operation,size,in,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(IndexShard indexShard,                                               long globalCheckpoint,                                               long fromSeqNo,                                               int maxOperationCount,                                               String expectedHistoryUUID,                                               long maxOperationSizeInBytes) throws IOException;1537202470;Returns at most maxOperationCount operations from the specified from sequence number._This method will never return operations above the specified globalCheckpoint.__Also if the sum of collected operations' size is above the specified maxOperationSizeInBytes then this method_stops collecting more operations and returns what has been collected so far.;static Translog.Operation[] getOperations(IndexShard indexShard,_                                              long globalCheckpoint,_                                              long fromSeqNo,_                                              int maxOperationCount,_                                              String expectedHistoryUUID,_                                              long maxOperationSizeInBytes) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxOperationSizeInBytes) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,max,operation,count,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,max,operation,size,in,bytes,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far;static,translog,operation,get,operations,index,shard,index,shard,long,global,checkpoint,long,from,seq,no,int,max,operation,count,string,expected,history,uuid,long,max,operation,size,in,bytes,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,operation,size,in,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(IndexShard indexShard,                                               long globalCheckpoint,                                               long fromSeqNo,                                               int maxOperationCount,                                               String expectedHistoryUUID,                                               long maxOperationSizeInBytes) throws IOException;1537371806;Returns at most maxOperationCount operations from the specified from sequence number._This method will never return operations above the specified globalCheckpoint.__Also if the sum of collected operations' size is above the specified maxOperationSizeInBytes then this method_stops collecting more operations and returns what has been collected so far.;static Translog.Operation[] getOperations(IndexShard indexShard,_                                              long globalCheckpoint,_                                              long fromSeqNo,_                                              int maxOperationCount,_                                              String expectedHistoryUUID,_                                              long maxOperationSizeInBytes) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxOperationSizeInBytes) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,max,operation,count,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,max,operation,size,in,bytes,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far;static,translog,operation,get,operations,index,shard,index,shard,long,global,checkpoint,long,from,seq,no,int,max,operation,count,string,expected,history,uuid,long,max,operation,size,in,bytes,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,operation,size,in,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(IndexShard indexShard,                                               long globalCheckpoint,                                               long fromSeqNo,                                               int maxOperationCount,                                               String expectedHistoryUUID,                                               long maxOperationSizeInBytes) throws IOException;1538067637;Returns at most maxOperationCount operations from the specified from sequence number._This method will never return operations above the specified globalCheckpoint.__Also if the sum of collected operations' size is above the specified maxOperationSizeInBytes then this method_stops collecting more operations and returns what has been collected so far.;static Translog.Operation[] getOperations(IndexShard indexShard,_                                              long globalCheckpoint,_                                              long fromSeqNo,_                                              int maxOperationCount,_                                              String expectedHistoryUUID,_                                              long maxOperationSizeInBytes) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxOperationSizeInBytes) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,max,operation,count,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,max,operation,size,in,bytes,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far;static,translog,operation,get,operations,index,shard,index,shard,long,global,checkpoint,long,from,seq,no,int,max,operation,count,string,expected,history,uuid,long,max,operation,size,in,bytes,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,operation,size,in,bytes,break,return,operations,to,array
ShardChangesAction -> static Translog.Operation[] getOperations(IndexShard indexShard,                                               long globalCheckpoint,                                               long fromSeqNo,                                               int maxOperationCount,                                               String expectedHistoryUUID,                                               long maxOperationSizeInBytes) throws IOException;1538170812;Returns at most maxOperationCount operations from the specified from sequence number._This method will never return operations above the specified globalCheckpoint.__Also if the sum of collected operations' size is above the specified maxOperationSizeInBytes then this method_stops collecting more operations and returns what has been collected so far.;static Translog.Operation[] getOperations(IndexShard indexShard,_                                              long globalCheckpoint,_                                              long fromSeqNo,_                                              int maxOperationCount,_                                              String expectedHistoryUUID,_                                              long maxOperationSizeInBytes) throws IOException {_        if (indexShard.state() != IndexShardState.STARTED) {_            throw new IndexShardNotStartedException(indexShard.shardId(), indexShard.state())__        }_        final String historyUUID = indexShard.getHistoryUUID()__        if (historyUUID.equals(expectedHistoryUUID) == false) {_            throw new IllegalStateException("unexpected history uuid, expected [" + expectedHistoryUUID + "], actual [" +_                historyUUID + "]")__        }_        if (fromSeqNo > globalCheckpoint) {_            throw new IllegalStateException(_                    "not exposing operations from [" + fromSeqNo + "] greater than the global checkpoint [" + globalCheckpoint + "]")__        }_        int seenBytes = 0__        _        long toSeqNo = Math.min(globalCheckpoint, (fromSeqNo + maxOperationCount) - 1)__        assert fromSeqNo <= toSeqNo : "invalid range from_seqno[" + fromSeqNo + "] > to_seqno[" + toSeqNo + "]"__        final List<Translog.Operation> operations = new ArrayList<>()__        try (Translog.Snapshot snapshot = indexShard.newChangesSnapshot("ccr", fromSeqNo, toSeqNo, true)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                operations.add(op)__                seenBytes += op.estimateSize()__                if (seenBytes > maxOperationSizeInBytes) {_                    break__                }_            }_        }_        return operations.toArray(EMPTY_OPERATIONS_ARRAY)__    };returns,at,most,max,operation,count,operations,from,the,specified,from,sequence,number,this,method,will,never,return,operations,above,the,specified,global,checkpoint,also,if,the,sum,of,collected,operations,size,is,above,the,specified,max,operation,size,in,bytes,then,this,method,stops,collecting,more,operations,and,returns,what,has,been,collected,so,far;static,translog,operation,get,operations,index,shard,index,shard,long,global,checkpoint,long,from,seq,no,int,max,operation,count,string,expected,history,uuid,long,max,operation,size,in,bytes,throws,ioexception,if,index,shard,state,index,shard,state,started,throw,new,index,shard,not,started,exception,index,shard,shard,id,index,shard,state,final,string,history,uuid,index,shard,get,history,uuid,if,history,uuid,equals,expected,history,uuid,false,throw,new,illegal,state,exception,unexpected,history,uuid,expected,expected,history,uuid,actual,history,uuid,if,from,seq,no,global,checkpoint,throw,new,illegal,state,exception,not,exposing,operations,from,from,seq,no,greater,than,the,global,checkpoint,global,checkpoint,int,seen,bytes,0,long,to,seq,no,math,min,global,checkpoint,from,seq,no,max,operation,count,1,assert,from,seq,no,to,seq,no,invalid,range,from,seq,no,to,seq,no,final,list,translog,operation,operations,new,array,list,try,translog,snapshot,snapshot,index,shard,new,changes,snapshot,ccr,from,seq,no,to,seq,no,true,translog,operation,op,while,op,snapshot,next,null,operations,add,op,seen,bytes,op,estimate,size,if,seen,bytes,max,operation,size,in,bytes,break,return,operations,to,array
