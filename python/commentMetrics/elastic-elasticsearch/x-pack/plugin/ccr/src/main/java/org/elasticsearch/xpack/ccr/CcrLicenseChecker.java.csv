# id;timestamp;commentText;codeText;commentWords;codeWords
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final Map<String, String> headers,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer);1538170812;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param headers                    the headers to use for leader client_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer;public void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final Map<String, String> headers,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer) {_        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                headers,_                clusterAlias,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,headers,the,headers,to,use,for,leader,client,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer;public,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,map,string,string,headers,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,check,remote,cluster,license,and,fetch,cluster,state,client,headers,cluster,alias,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final Map<String, String> headers,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer);1541593410;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param headers                    the headers to use for leader client_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer;public void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final Map<String, String> headers,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer) {_        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                headers,_                clusterAlias,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,headers,the,headers,to,use,for,leader,client,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer;public,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,map,string,string,headers,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,check,remote,cluster,license,and,fetch,cluster,state,client,headers,cluster,alias,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client remoteClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1541690774;Fetches the history UUIDs for leader index on per shard basis using the specified remoteClient.__@param remoteClient                              the remote client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client remoteClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            if (indexStats == null) {_                onFailure.accept(new IllegalArgumentException("no index stats available for the leader index"))__                return__            }__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        remoteClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,remote,client,param,remote,client,the,remote,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,remote,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,if,index,stats,null,on,failure,accept,new,illegal,argument,exception,no,index,stats,available,for,the,leader,index,return,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,remote,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client remoteClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1543935315;Fetches the history UUIDs for leader index on per shard basis using the specified remoteClient.__@param remoteClient                              the remote client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client remoteClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            if (indexStats == null) {_                onFailure.accept(new IllegalArgumentException("no index stats available for the leader index"))__                return__            }__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        remoteClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,remote,client,param,remote,client,the,remote,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,remote,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,if,index,stats,null,on,failure,accept,new,illegal,argument,exception,no,index,stats,available,for,the,leader,index,return,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,remote,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client remoteClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1544615244;Fetches the history UUIDs for leader index on per shard basis using the specified remoteClient.__@param remoteClient                              the remote client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client remoteClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            if (indexStats == null) {_                onFailure.accept(new IllegalArgumentException("no index stats available for the leader index"))__                return__            }__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        remoteClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,remote,client,param,remote,client,the,remote,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,remote,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,if,index,stats,null,on,failure,accept,new,illegal,argument,exception,no,index,stats,available,for,the,leader,index,return,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,remote,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client remoteClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1544855694;Fetches the history UUIDs for leader index on per shard basis using the specified remoteClient.__@param remoteClient                              the remote client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client remoteClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            if (indexStats == null) {_                onFailure.accept(new IllegalArgumentException("no index stats available for the leader index"))__                return__            }__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        remoteClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,remote,client,param,remote,client,the,remote,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,remote,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,if,index,stats,null,on,failure,accept,new,illegal,argument,exception,no,index,stats,available,for,the,leader,index,return,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,remote,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client remoteClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1545642998;Fetches the history UUIDs for leader index on per shard basis using the specified remoteClient.__@param remoteClient                              the remote client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client remoteClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            if (indexStats == null) {_                onFailure.accept(new IllegalArgumentException("no index stats available for the leader index"))__                return__            }__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        remoteClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,remote,client,param,remote,client,the,remote,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,remote,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,if,index,stats,null,on,failure,accept,new,illegal,argument,exception,no,index,stats,available,for,the,leader,index,return,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,remote,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client remoteClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1549336917;Fetches the history UUIDs for leader index on per shard basis using the specified remoteClient.__@param remoteClient                              the remote client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client remoteClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            if (indexStats == null) {_                onFailure.accept(new IllegalArgumentException("no index stats available for the leader index"))__                return__            }__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        remoteClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,remote,client,param,remote,client,the,remote,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,remote,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,if,index,stats,null,on,failure,accept,new,illegal,argument,exception,no,index,stats,available,for,the,leader,index,return,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,remote,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterStateResponse> leaderClusterStateConsumer);1544615244;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer;public void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterStateResponse> leaderClusterStateConsumer) {_        try {_            Client remoteClient = systemClient(client.getRemoteClusterClient(clusterAlias))__            checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                remoteClient,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__        } catch (Exception e) {_            _            _            onFailure.accept(e)__        }_    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer;public,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,response,leader,cluster,state,consumer,try,client,remote,client,system,client,client,get,remote,cluster,client,cluster,alias,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,remote,client,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e,catch,exception,e,on,failure,accept,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterStateResponse> leaderClusterStateConsumer);1544855694;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer;public void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterStateResponse> leaderClusterStateConsumer) {_        try {_            Client remoteClient = systemClient(client.getRemoteClusterClient(clusterAlias))__            checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                remoteClient,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__        } catch (Exception e) {_            _            _            onFailure.accept(e)__        }_    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer;public,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,response,leader,cluster,state,consumer,try,client,remote,client,system,client,client,get,remote,cluster,client,cluster,alias,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,remote,client,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e,catch,exception,e,on,failure,accept,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterStateResponse> leaderClusterStateConsumer);1545642998;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer;public void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterStateResponse> leaderClusterStateConsumer) {_        try {_            Client remoteClient = systemClient(client.getRemoteClusterClient(clusterAlias))__            checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                remoteClient,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__        } catch (Exception e) {_            _            _            onFailure.accept(e)__        }_    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer;public,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,response,leader,cluster,state,consumer,try,client,remote,client,system,client,client,get,remote,cluster,client,cluster,alias,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,remote,client,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e,catch,exception,e,on,failure,accept,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterStateResponse> leaderClusterStateConsumer);1549336917;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer;public void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterStateResponse> leaderClusterStateConsumer) {_        try {_            Client remoteClient = systemClient(client.getRemoteClusterClient(clusterAlias))__            checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                remoteClient,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__        } catch (Exception e) {_            _            _            onFailure.accept(e)__        }_    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer;public,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,response,leader,cluster,state,consumer,try,client,remote,client,system,client,client,get,remote,cluster,client,cluster,alias,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,remote,client,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e,catch,exception,e,on,failure,accept,e
CcrLicenseChecker -> private void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final Client remoteClient,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterStateResponse> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1544615244;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param remoteClient               the remote client to use to execute cluster state API_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure;private void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final Client remoteClient,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterStateResponse> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                ActionListener.wrap(leaderClusterStateConsumer::accept, onFailure)__                            _                            remoteClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,remote,client,the,remote,client,to,use,to,execute,cluster,state,api,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure;private,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,client,remote,client,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,response,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,leader,cluster,state,consumer,accept,on,failure,remote,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> private void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final Client remoteClient,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterStateResponse> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1544855694;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param remoteClient               the remote client to use to execute cluster state API_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure;private void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final Client remoteClient,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterStateResponse> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                ActionListener.wrap(leaderClusterStateConsumer::accept, onFailure)__                            _                            remoteClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,remote,client,the,remote,client,to,use,to,execute,cluster,state,api,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure;private,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,client,remote,client,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,response,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,leader,cluster,state,consumer,accept,on,failure,remote,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> private void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final Client remoteClient,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterStateResponse> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1545642998;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param remoteClient               the remote client to use to execute cluster state API_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure;private void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final Client remoteClient,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterStateResponse> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                ActionListener.wrap(leaderClusterStateConsumer::accept, onFailure)__                            _                            remoteClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,remote,client,the,remote,client,to,use,to,execute,cluster,state,api,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure;private,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,client,remote,client,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,response,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,leader,cluster,state,consumer,accept,on,failure,remote,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> private void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final Client remoteClient,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterStateResponse> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1549336917;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param remoteClient               the remote client to use to execute cluster state API_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure;private void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final Client remoteClient,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterStateResponse> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                ActionListener.wrap(leaderClusterStateConsumer::accept, onFailure)__                            _                            remoteClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,remote,client,the,remote,client,to,use,to,execute,cluster,state,api,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure;private,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,client,remote,client,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,response,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,leader,cluster,state,consumer,accept,on,failure,remote,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> CcrLicenseChecker(final BooleanSupplier isCcrAllowed);1535965276;Constructs a CCR license checker with the specified boolean supplier.__@param isCcrAllowed a boolean supplier that should return true if CCR is allowed and false otherwise;CcrLicenseChecker(final BooleanSupplier isCcrAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed)__    };constructs,a,ccr,license,checker,with,the,specified,boolean,supplier,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise;ccr,license,checker,final,boolean,supplier,is,ccr,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed
CcrLicenseChecker -> CcrLicenseChecker(final BooleanSupplier isCcrAllowed);1536611444;Constructs a CCR license checker with the specified boolean supplier.__@param isCcrAllowed a boolean supplier that should return true if CCR is allowed and false otherwise;CcrLicenseChecker(final BooleanSupplier isCcrAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed)__    };constructs,a,ccr,license,checker,with,the,specified,boolean,supplier,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise;ccr,license,checker,final,boolean,supplier,is,ccr,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed
CcrLicenseChecker -> CcrLicenseChecker(final BooleanSupplier isCcrAllowed);1536828374;Constructs a CCR license checker with the specified boolean supplier.__@param isCcrAllowed a boolean supplier that should return true if CCR is allowed and false otherwise;CcrLicenseChecker(final BooleanSupplier isCcrAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed)__    };constructs,a,ccr,license,checker,with,the,specified,boolean,supplier,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise;ccr,license,checker,final,boolean,supplier,is,ccr,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed
CcrLicenseChecker -> CcrLicenseChecker(final BooleanSupplier isCcrAllowed);1537202470;Constructs a CCR license checker with the specified boolean supplier.__@param isCcrAllowed a boolean supplier that should return true if CCR is allowed and false otherwise;CcrLicenseChecker(final BooleanSupplier isCcrAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed)__    };constructs,a,ccr,license,checker,with,the,specified,boolean,supplier,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise;ccr,license,checker,final,boolean,supplier,is,ccr,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed
CcrLicenseChecker -> public boolean isCcrAllowed();1535965276;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1536611444;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1536828374;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1537202470;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1537300661;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1538170812;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1541593410;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1541670507;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1541690774;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1543935315;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1544615244;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1544855694;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1545642998;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public boolean isCcrAllowed();1549336917;Returns whether or not CCR is allowed.__@return true if CCR is allowed, otherwise false;public boolean isCcrAllowed() {_        return isCcrAllowed.getAsBoolean()__    };returns,whether,or,not,ccr,is,allowed,return,true,if,ccr,is,allowed,otherwise,false;public,boolean,is,ccr,allowed,return,is,ccr,allowed,get,as,boolean
CcrLicenseChecker -> public <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final Map<String, String> headers,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer);1537202470;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param headers                    the headers to use for leader client_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param <T>                        the type of response the listener is waiting for;public <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final Map<String, String> headers,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer) {_        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                headers,_                clusterAlias,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,headers,the,headers,to,use,for,leader,client,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,t,the,type,of,response,the,listener,is,waiting,for;public,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,map,string,string,headers,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,check,remote,cluster,license,and,fetch,cluster,state,client,headers,cluster,alias,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e
CcrLicenseChecker -> public <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final Map<String, String> headers,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer);1537300661;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param headers                    the headers to use for leader client_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param <T>                        the type of response the listener is waiting for;public <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final Map<String, String> headers,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer) {_        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                headers,_                clusterAlias,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,headers,the,headers,to,use,for,leader,client,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,t,the,type,of,response,the,listener,is,waiting,for;public,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,map,string,string,headers,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,check,remote,cluster,license,and,fetch,cluster,state,client,headers,cluster,alias,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e
CcrLicenseChecker -> public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler);1541690774;Check if the user executing the current action has privileges to follow the specified indices on the cluster specified by the leader_client. The specified callback will be invoked with null if the user has the necessary privileges to follow the specified indices,_otherwise the callback will be invoked with an exception outlining the authorization error.__@param remoteClient the remote client_@param indices      the indices_@param handler      the callback;public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler) {_        Objects.requireNonNull(remoteClient, "remoteClient")__        Objects.requireNonNull(indices, "indices")__        if (indices.length == 0) {_            throw new IllegalArgumentException("indices must not be empty")__        }_        Objects.requireNonNull(handler, "handler")__        if (isAuthAllowed.getAsBoolean() == false) {_            handler.accept(null)__            return__        }__        ThreadContext threadContext = remoteClient.threadPool().getThreadContext()__        SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext)__        String username = securityContext.getUser().principal()___        RoleDescriptor.IndicesPrivileges privileges = RoleDescriptor.IndicesPrivileges.builder()_            .indices(indices)_            .privileges(IndicesStatsAction.NAME, ShardChangesAction.NAME)_            .build()___        HasPrivilegesRequest request = new HasPrivilegesRequest()__        request.username(username)__        request.clusterPrivileges(Strings.EMPTY_ARRAY)__        request.indexPrivileges(privileges)__        request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0])__        CheckedConsumer<HasPrivilegesResponse, Exception> responseHandler = response -> {_            if (response.isCompleteMatch()) {_                handler.accept(null)__            } else {_                StringBuilder message = new StringBuilder("insufficient privileges to follow")__                message.append(indices.length == 1 ? " index " : " indices ")__                message.append(Arrays.toString(indices))___                HasPrivilegesResponse.ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().get(0)__                for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {_                    if (entry.getValue() == false) {_                        message.append(", privilege for action [")__                        message.append(entry.getKey())__                        message.append("] is missing")__                    }_                }__                handler.accept(Exceptions.authorizationError(message.toString()))__            }_        }__        remoteClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler))__    };check,if,the,user,executing,the,current,action,has,privileges,to,follow,the,specified,indices,on,the,cluster,specified,by,the,leader,client,the,specified,callback,will,be,invoked,with,null,if,the,user,has,the,necessary,privileges,to,follow,the,specified,indices,otherwise,the,callback,will,be,invoked,with,an,exception,outlining,the,authorization,error,param,remote,client,the,remote,client,param,indices,the,indices,param,handler,the,callback;public,void,has,privileges,to,follow,indices,final,client,remote,client,final,string,indices,final,consumer,exception,handler,objects,require,non,null,remote,client,remote,client,objects,require,non,null,indices,indices,if,indices,length,0,throw,new,illegal,argument,exception,indices,must,not,be,empty,objects,require,non,null,handler,handler,if,is,auth,allowed,get,as,boolean,false,handler,accept,null,return,thread,context,thread,context,remote,client,thread,pool,get,thread,context,security,context,security,context,new,security,context,settings,empty,thread,context,string,username,security,context,get,user,principal,role,descriptor,indices,privileges,privileges,role,descriptor,indices,privileges,builder,indices,indices,privileges,indices,stats,action,name,shard,changes,action,name,build,has,privileges,request,request,new,has,privileges,request,request,username,username,request,cluster,privileges,strings,request,index,privileges,privileges,request,application,privileges,new,role,descriptor,application,resource,privileges,0,checked,consumer,has,privileges,response,exception,response,handler,response,if,response,is,complete,match,handler,accept,null,else,string,builder,message,new,string,builder,insufficient,privileges,to,follow,message,append,indices,length,1,index,indices,message,append,arrays,to,string,indices,has,privileges,response,resource,privileges,resource,privileges,response,get,index,privileges,get,0,for,map,entry,string,boolean,entry,resource,privileges,get,privileges,entry,set,if,entry,get,value,false,message,append,privilege,for,action,message,append,entry,get,key,message,append,is,missing,handler,accept,exceptions,authorization,error,message,to,string,remote,client,execute,has,privileges,action,instance,request,action,listener,wrap,response,handler,handler
CcrLicenseChecker -> public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler);1543935315;Check if the user executing the current action has privileges to follow the specified indices on the cluster specified by the leader_client. The specified callback will be invoked with null if the user has the necessary privileges to follow the specified indices,_otherwise the callback will be invoked with an exception outlining the authorization error.__@param remoteClient the remote client_@param indices      the indices_@param handler      the callback;public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler) {_        Objects.requireNonNull(remoteClient, "remoteClient")__        Objects.requireNonNull(indices, "indices")__        if (indices.length == 0) {_            throw new IllegalArgumentException("indices must not be empty")__        }_        Objects.requireNonNull(handler, "handler")__        if (isAuthAllowed.getAsBoolean() == false) {_            handler.accept(null)__            return__        }__        ThreadContext threadContext = remoteClient.threadPool().getThreadContext()__        SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext)__        String username = securityContext.getUser().principal()___        RoleDescriptor.IndicesPrivileges privileges = RoleDescriptor.IndicesPrivileges.builder()_            .indices(indices)_            .privileges(IndicesStatsAction.NAME, ShardChangesAction.NAME)_            .build()___        HasPrivilegesRequest request = new HasPrivilegesRequest()__        request.username(username)__        request.clusterPrivileges(Strings.EMPTY_ARRAY)__        request.indexPrivileges(privileges)__        request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0])__        CheckedConsumer<HasPrivilegesResponse, Exception> responseHandler = response -> {_            if (response.isCompleteMatch()) {_                handler.accept(null)__            } else {_                StringBuilder message = new StringBuilder("insufficient privileges to follow")__                message.append(indices.length == 1 ? " index " : " indices ")__                message.append(Arrays.toString(indices))___                HasPrivilegesResponse.ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().get(0)__                for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {_                    if (entry.getValue() == false) {_                        message.append(", privilege for action [")__                        message.append(entry.getKey())__                        message.append("] is missing")__                    }_                }__                handler.accept(Exceptions.authorizationError(message.toString()))__            }_        }__        remoteClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler))__    };check,if,the,user,executing,the,current,action,has,privileges,to,follow,the,specified,indices,on,the,cluster,specified,by,the,leader,client,the,specified,callback,will,be,invoked,with,null,if,the,user,has,the,necessary,privileges,to,follow,the,specified,indices,otherwise,the,callback,will,be,invoked,with,an,exception,outlining,the,authorization,error,param,remote,client,the,remote,client,param,indices,the,indices,param,handler,the,callback;public,void,has,privileges,to,follow,indices,final,client,remote,client,final,string,indices,final,consumer,exception,handler,objects,require,non,null,remote,client,remote,client,objects,require,non,null,indices,indices,if,indices,length,0,throw,new,illegal,argument,exception,indices,must,not,be,empty,objects,require,non,null,handler,handler,if,is,auth,allowed,get,as,boolean,false,handler,accept,null,return,thread,context,thread,context,remote,client,thread,pool,get,thread,context,security,context,security,context,new,security,context,settings,empty,thread,context,string,username,security,context,get,user,principal,role,descriptor,indices,privileges,privileges,role,descriptor,indices,privileges,builder,indices,indices,privileges,indices,stats,action,name,shard,changes,action,name,build,has,privileges,request,request,new,has,privileges,request,request,username,username,request,cluster,privileges,strings,request,index,privileges,privileges,request,application,privileges,new,role,descriptor,application,resource,privileges,0,checked,consumer,has,privileges,response,exception,response,handler,response,if,response,is,complete,match,handler,accept,null,else,string,builder,message,new,string,builder,insufficient,privileges,to,follow,message,append,indices,length,1,index,indices,message,append,arrays,to,string,indices,has,privileges,response,resource,privileges,resource,privileges,response,get,index,privileges,get,0,for,map,entry,string,boolean,entry,resource,privileges,get,privileges,entry,set,if,entry,get,value,false,message,append,privilege,for,action,message,append,entry,get,key,message,append,is,missing,handler,accept,exceptions,authorization,error,message,to,string,remote,client,execute,has,privileges,action,instance,request,action,listener,wrap,response,handler,handler
CcrLicenseChecker -> public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler);1544615244;Check if the user executing the current action has privileges to follow the specified indices on the cluster specified by the leader_client. The specified callback will be invoked with null if the user has the necessary privileges to follow the specified indices,_otherwise the callback will be invoked with an exception outlining the authorization error.__@param remoteClient the remote client_@param indices      the indices_@param handler      the callback;public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler) {_        Objects.requireNonNull(remoteClient, "remoteClient")__        Objects.requireNonNull(indices, "indices")__        if (indices.length == 0) {_            throw new IllegalArgumentException("indices must not be empty")__        }_        Objects.requireNonNull(handler, "handler")__        if (isAuthAllowed.getAsBoolean() == false) {_            handler.accept(null)__            return__        }__        ThreadContext threadContext = remoteClient.threadPool().getThreadContext()__        SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext)__        String username = securityContext.getUser().principal()___        RoleDescriptor.IndicesPrivileges privileges = RoleDescriptor.IndicesPrivileges.builder()_            .indices(indices)_            .privileges(IndicesStatsAction.NAME, ShardChangesAction.NAME)_            .build()___        HasPrivilegesRequest request = new HasPrivilegesRequest()__        request.username(username)__        request.clusterPrivileges(Strings.EMPTY_ARRAY)__        request.indexPrivileges(privileges)__        request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0])__        CheckedConsumer<HasPrivilegesResponse, Exception> responseHandler = response -> {_            if (response.isCompleteMatch()) {_                handler.accept(null)__            } else {_                StringBuilder message = new StringBuilder("insufficient privileges to follow")__                message.append(indices.length == 1 ? " index " : " indices ")__                message.append(Arrays.toString(indices))___                HasPrivilegesResponse.ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().get(0)__                for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {_                    if (entry.getValue() == false) {_                        message.append(", privilege for action [")__                        message.append(entry.getKey())__                        message.append("] is missing")__                    }_                }__                handler.accept(Exceptions.authorizationError(message.toString()))__            }_        }__        remoteClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler))__    };check,if,the,user,executing,the,current,action,has,privileges,to,follow,the,specified,indices,on,the,cluster,specified,by,the,leader,client,the,specified,callback,will,be,invoked,with,null,if,the,user,has,the,necessary,privileges,to,follow,the,specified,indices,otherwise,the,callback,will,be,invoked,with,an,exception,outlining,the,authorization,error,param,remote,client,the,remote,client,param,indices,the,indices,param,handler,the,callback;public,void,has,privileges,to,follow,indices,final,client,remote,client,final,string,indices,final,consumer,exception,handler,objects,require,non,null,remote,client,remote,client,objects,require,non,null,indices,indices,if,indices,length,0,throw,new,illegal,argument,exception,indices,must,not,be,empty,objects,require,non,null,handler,handler,if,is,auth,allowed,get,as,boolean,false,handler,accept,null,return,thread,context,thread,context,remote,client,thread,pool,get,thread,context,security,context,security,context,new,security,context,settings,empty,thread,context,string,username,security,context,get,user,principal,role,descriptor,indices,privileges,privileges,role,descriptor,indices,privileges,builder,indices,indices,privileges,indices,stats,action,name,shard,changes,action,name,build,has,privileges,request,request,new,has,privileges,request,request,username,username,request,cluster,privileges,strings,request,index,privileges,privileges,request,application,privileges,new,role,descriptor,application,resource,privileges,0,checked,consumer,has,privileges,response,exception,response,handler,response,if,response,is,complete,match,handler,accept,null,else,string,builder,message,new,string,builder,insufficient,privileges,to,follow,message,append,indices,length,1,index,indices,message,append,arrays,to,string,indices,has,privileges,response,resource,privileges,resource,privileges,response,get,index,privileges,get,0,for,map,entry,string,boolean,entry,resource,privileges,get,privileges,entry,set,if,entry,get,value,false,message,append,privilege,for,action,message,append,entry,get,key,message,append,is,missing,handler,accept,exceptions,authorization,error,message,to,string,remote,client,execute,has,privileges,action,instance,request,action,listener,wrap,response,handler,handler
CcrLicenseChecker -> public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler);1544855694;Check if the user executing the current action has privileges to follow the specified indices on the cluster specified by the leader_client. The specified callback will be invoked with null if the user has the necessary privileges to follow the specified indices,_otherwise the callback will be invoked with an exception outlining the authorization error.__@param remoteClient the remote client_@param indices      the indices_@param handler      the callback;public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler) {_        Objects.requireNonNull(remoteClient, "remoteClient")__        Objects.requireNonNull(indices, "indices")__        if (indices.length == 0) {_            throw new IllegalArgumentException("indices must not be empty")__        }_        Objects.requireNonNull(handler, "handler")__        if (isAuthAllowed.getAsBoolean() == false) {_            handler.accept(null)__            return__        }__        ThreadContext threadContext = remoteClient.threadPool().getThreadContext()__        SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext)__        String username = securityContext.getUser().principal()___        RoleDescriptor.IndicesPrivileges privileges = RoleDescriptor.IndicesPrivileges.builder()_            .indices(indices)_            .privileges(IndicesStatsAction.NAME, ShardChangesAction.NAME)_            .build()___        HasPrivilegesRequest request = new HasPrivilegesRequest()__        request.username(username)__        request.clusterPrivileges(Strings.EMPTY_ARRAY)__        request.indexPrivileges(privileges)__        request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0])__        CheckedConsumer<HasPrivilegesResponse, Exception> responseHandler = response -> {_            if (response.isCompleteMatch()) {_                handler.accept(null)__            } else {_                StringBuilder message = new StringBuilder("insufficient privileges to follow")__                message.append(indices.length == 1 ? " index " : " indices ")__                message.append(Arrays.toString(indices))___                HasPrivilegesResponse.ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().iterator().next()__                for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {_                    if (entry.getValue() == false) {_                        message.append(", privilege for action [")__                        message.append(entry.getKey())__                        message.append("] is missing")__                    }_                }__                handler.accept(Exceptions.authorizationError(message.toString()))__            }_        }__        remoteClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler))__    };check,if,the,user,executing,the,current,action,has,privileges,to,follow,the,specified,indices,on,the,cluster,specified,by,the,leader,client,the,specified,callback,will,be,invoked,with,null,if,the,user,has,the,necessary,privileges,to,follow,the,specified,indices,otherwise,the,callback,will,be,invoked,with,an,exception,outlining,the,authorization,error,param,remote,client,the,remote,client,param,indices,the,indices,param,handler,the,callback;public,void,has,privileges,to,follow,indices,final,client,remote,client,final,string,indices,final,consumer,exception,handler,objects,require,non,null,remote,client,remote,client,objects,require,non,null,indices,indices,if,indices,length,0,throw,new,illegal,argument,exception,indices,must,not,be,empty,objects,require,non,null,handler,handler,if,is,auth,allowed,get,as,boolean,false,handler,accept,null,return,thread,context,thread,context,remote,client,thread,pool,get,thread,context,security,context,security,context,new,security,context,settings,empty,thread,context,string,username,security,context,get,user,principal,role,descriptor,indices,privileges,privileges,role,descriptor,indices,privileges,builder,indices,indices,privileges,indices,stats,action,name,shard,changes,action,name,build,has,privileges,request,request,new,has,privileges,request,request,username,username,request,cluster,privileges,strings,request,index,privileges,privileges,request,application,privileges,new,role,descriptor,application,resource,privileges,0,checked,consumer,has,privileges,response,exception,response,handler,response,if,response,is,complete,match,handler,accept,null,else,string,builder,message,new,string,builder,insufficient,privileges,to,follow,message,append,indices,length,1,index,indices,message,append,arrays,to,string,indices,has,privileges,response,resource,privileges,resource,privileges,response,get,index,privileges,iterator,next,for,map,entry,string,boolean,entry,resource,privileges,get,privileges,entry,set,if,entry,get,value,false,message,append,privilege,for,action,message,append,entry,get,key,message,append,is,missing,handler,accept,exceptions,authorization,error,message,to,string,remote,client,execute,has,privileges,action,instance,request,action,listener,wrap,response,handler,handler
CcrLicenseChecker -> public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler);1545642998;Check if the user executing the current action has privileges to follow the specified indices on the cluster specified by the leader_client. The specified callback will be invoked with null if the user has the necessary privileges to follow the specified indices,_otherwise the callback will be invoked with an exception outlining the authorization error.__@param remoteClient the remote client_@param indices      the indices_@param handler      the callback;public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler) {_        Objects.requireNonNull(remoteClient, "remoteClient")__        Objects.requireNonNull(indices, "indices")__        if (indices.length == 0) {_            throw new IllegalArgumentException("indices must not be empty")__        }_        Objects.requireNonNull(handler, "handler")__        if (isAuthAllowed.getAsBoolean() == false) {_            handler.accept(null)__            return__        }__        ThreadContext threadContext = remoteClient.threadPool().getThreadContext()__        SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext)__        String username = securityContext.getUser().principal()___        RoleDescriptor.IndicesPrivileges privileges = RoleDescriptor.IndicesPrivileges.builder()_            .indices(indices)_            .privileges(IndicesStatsAction.NAME, ShardChangesAction.NAME)_            .build()___        HasPrivilegesRequest request = new HasPrivilegesRequest()__        request.username(username)__        request.clusterPrivileges(Strings.EMPTY_ARRAY)__        request.indexPrivileges(privileges)__        request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0])__        CheckedConsumer<HasPrivilegesResponse, Exception> responseHandler = response -> {_            if (response.isCompleteMatch()) {_                handler.accept(null)__            } else {_                StringBuilder message = new StringBuilder("insufficient privileges to follow")__                message.append(indices.length == 1 ? " index " : " indices ")__                message.append(Arrays.toString(indices))___                HasPrivilegesResponse.ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().iterator().next()__                for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {_                    if (entry.getValue() == false) {_                        message.append(", privilege for action [")__                        message.append(entry.getKey())__                        message.append("] is missing")__                    }_                }__                handler.accept(Exceptions.authorizationError(message.toString()))__            }_        }__        remoteClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler))__    };check,if,the,user,executing,the,current,action,has,privileges,to,follow,the,specified,indices,on,the,cluster,specified,by,the,leader,client,the,specified,callback,will,be,invoked,with,null,if,the,user,has,the,necessary,privileges,to,follow,the,specified,indices,otherwise,the,callback,will,be,invoked,with,an,exception,outlining,the,authorization,error,param,remote,client,the,remote,client,param,indices,the,indices,param,handler,the,callback;public,void,has,privileges,to,follow,indices,final,client,remote,client,final,string,indices,final,consumer,exception,handler,objects,require,non,null,remote,client,remote,client,objects,require,non,null,indices,indices,if,indices,length,0,throw,new,illegal,argument,exception,indices,must,not,be,empty,objects,require,non,null,handler,handler,if,is,auth,allowed,get,as,boolean,false,handler,accept,null,return,thread,context,thread,context,remote,client,thread,pool,get,thread,context,security,context,security,context,new,security,context,settings,empty,thread,context,string,username,security,context,get,user,principal,role,descriptor,indices,privileges,privileges,role,descriptor,indices,privileges,builder,indices,indices,privileges,indices,stats,action,name,shard,changes,action,name,build,has,privileges,request,request,new,has,privileges,request,request,username,username,request,cluster,privileges,strings,request,index,privileges,privileges,request,application,privileges,new,role,descriptor,application,resource,privileges,0,checked,consumer,has,privileges,response,exception,response,handler,response,if,response,is,complete,match,handler,accept,null,else,string,builder,message,new,string,builder,insufficient,privileges,to,follow,message,append,indices,length,1,index,indices,message,append,arrays,to,string,indices,has,privileges,response,resource,privileges,resource,privileges,response,get,index,privileges,iterator,next,for,map,entry,string,boolean,entry,resource,privileges,get,privileges,entry,set,if,entry,get,value,false,message,append,privilege,for,action,message,append,entry,get,key,message,append,is,missing,handler,accept,exceptions,authorization,error,message,to,string,remote,client,execute,has,privileges,action,instance,request,action,listener,wrap,response,handler,handler
CcrLicenseChecker -> public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler);1549336917;Check if the user executing the current action has privileges to follow the specified indices on the cluster specified by the leader_client. The specified callback will be invoked with null if the user has the necessary privileges to follow the specified indices,_otherwise the callback will be invoked with an exception outlining the authorization error.__@param remoteClient the remote client_@param indices      the indices_@param handler      the callback;public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler) {_        Objects.requireNonNull(remoteClient, "remoteClient")__        Objects.requireNonNull(indices, "indices")__        if (indices.length == 0) {_            throw new IllegalArgumentException("indices must not be empty")__        }_        Objects.requireNonNull(handler, "handler")__        if (isAuthAllowed.getAsBoolean() == false) {_            handler.accept(null)__            return__        }__        ThreadContext threadContext = remoteClient.threadPool().getThreadContext()__        SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext)__        String username = securityContext.getUser().principal()___        RoleDescriptor.IndicesPrivileges privileges = RoleDescriptor.IndicesPrivileges.builder()_            .indices(indices)_            .privileges(IndicesStatsAction.NAME, ShardChangesAction.NAME)_            .build()___        HasPrivilegesRequest request = new HasPrivilegesRequest()__        request.username(username)__        request.clusterPrivileges(Strings.EMPTY_ARRAY)__        request.indexPrivileges(privileges)__        request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0])__        CheckedConsumer<HasPrivilegesResponse, Exception> responseHandler = response -> {_            if (response.isCompleteMatch()) {_                handler.accept(null)__            } else {_                StringBuilder message = new StringBuilder("insufficient privileges to follow")__                message.append(indices.length == 1 ? " index " : " indices ")__                message.append(Arrays.toString(indices))___                ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().iterator().next()__                for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {_                    if (entry.getValue() == false) {_                        message.append(", privilege for action [")__                        message.append(entry.getKey())__                        message.append("] is missing")__                    }_                }__                handler.accept(Exceptions.authorizationError(message.toString()))__            }_        }__        remoteClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler))__    };check,if,the,user,executing,the,current,action,has,privileges,to,follow,the,specified,indices,on,the,cluster,specified,by,the,leader,client,the,specified,callback,will,be,invoked,with,null,if,the,user,has,the,necessary,privileges,to,follow,the,specified,indices,otherwise,the,callback,will,be,invoked,with,an,exception,outlining,the,authorization,error,param,remote,client,the,remote,client,param,indices,the,indices,param,handler,the,callback;public,void,has,privileges,to,follow,indices,final,client,remote,client,final,string,indices,final,consumer,exception,handler,objects,require,non,null,remote,client,remote,client,objects,require,non,null,indices,indices,if,indices,length,0,throw,new,illegal,argument,exception,indices,must,not,be,empty,objects,require,non,null,handler,handler,if,is,auth,allowed,get,as,boolean,false,handler,accept,null,return,thread,context,thread,context,remote,client,thread,pool,get,thread,context,security,context,security,context,new,security,context,settings,empty,thread,context,string,username,security,context,get,user,principal,role,descriptor,indices,privileges,privileges,role,descriptor,indices,privileges,builder,indices,indices,privileges,indices,stats,action,name,shard,changes,action,name,build,has,privileges,request,request,new,has,privileges,request,request,username,username,request,cluster,privileges,strings,request,index,privileges,privileges,request,application,privileges,new,role,descriptor,application,resource,privileges,0,checked,consumer,has,privileges,response,exception,response,handler,response,if,response,is,complete,match,handler,accept,null,else,string,builder,message,new,string,builder,insufficient,privileges,to,follow,message,append,indices,length,1,index,indices,message,append,arrays,to,string,indices,resource,privileges,resource,privileges,response,get,index,privileges,iterator,next,for,map,entry,string,boolean,entry,resource,privileges,get,privileges,entry,set,if,entry,get,value,false,message,append,privilege,for,action,message,append,entry,get,key,message,append,is,missing,handler,accept,exceptions,authorization,error,message,to,string,remote,client,execute,has,privileges,action,instance,request,action,listener,wrap,response,handler,handler
CcrLicenseChecker -> public <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer);1536611444;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param <T>                        the type of response the listener is waiting for;public <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer) {_        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,t,the,type,of,response,the,listener,is,waiting,for;public,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e
CcrLicenseChecker -> public <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer);1536828374;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param <T>                        the type of response the listener is waiting for;public <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer) {_        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,t,the,type,of,response,the,listener,is,waiting,for;public,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e
CcrLicenseChecker -> private void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final Client remoteClient,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1541690774;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param remoteClient               the remote client to use to execute cluster state API_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure;private void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final Client remoteClient,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                    ActionListener.wrap(s -> leaderClusterStateConsumer.accept(s.getState()), onFailure)__                            _                            remoteClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,remote,client,the,remote,client,to,use,to,execute,cluster,state,api,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure;private,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,client,remote,client,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,s,leader,cluster,state,consumer,accept,s,get,state,on,failure,remote,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> private void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final Client remoteClient,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1543935315;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param remoteClient               the remote client to use to execute cluster state API_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure;private void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final Client remoteClient,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                    ActionListener.wrap(s -> leaderClusterStateConsumer.accept(s.getState()), onFailure)__                            _                            remoteClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,remote,client,the,remote,client,to,use,to,execute,cluster,state,api,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure;private,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,client,remote,client,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,s,leader,cluster,state,consumer,accept,s,get,state,on,failure,remote,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1536828374;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards_@param <T>           the type of response the listener is waiting for;public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                request,_                onFailure,_                leaderClusterState -> {_                    IndexMetaData leaderIndexMetaData = leaderClusterState.getMetaData().index(leaderIndex)__                    final Client leaderClient = client.getRemoteClusterClient(clusterAlias)__                    fetchLeaderHistoryUUIDs(leaderClient, leaderIndexMetaData, onFailure, historyUUIDs -> {_                        consumer.accept(historyUUIDs, leaderIndexMetaData)__                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards,param,t,the,type,of,response,the,listener,is,waiting,for;public,t,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,request,on,failure,leader,cluster,state,index,meta,data,leader,index,meta,data,leader,cluster,state,get,meta,data,index,leader,index,final,client,leader,client,client,get,remote,cluster,client,cluster,alias,fetch,leader,history,uuids,leader,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1537202470;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards_@param <T>           the type of response the listener is waiting for;public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                Collections.emptyMap(),_                clusterAlias,_                request,_                onFailure,_                leaderClusterState -> {_                    IndexMetaData leaderIndexMetaData = leaderClusterState.getMetaData().index(leaderIndex)__                    final Client leaderClient = client.getRemoteClusterClient(clusterAlias)__                    fetchLeaderHistoryUUIDs(leaderClient, leaderIndexMetaData, onFailure, historyUUIDs -> {_                        consumer.accept(historyUUIDs, leaderIndexMetaData)__                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards,param,t,the,type,of,response,the,listener,is,waiting,for;public,t,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,collections,empty,map,cluster,alias,request,on,failure,leader,cluster,state,index,meta,data,leader,index,meta,data,leader,cluster,state,get,meta,data,index,leader,index,final,client,leader,client,client,get,remote,cluster,client,cluster,alias,fetch,leader,history,uuids,leader,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1537300661;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards_@param <T>           the type of response the listener is waiting for;public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                Collections.emptyMap(),_                clusterAlias,_                request,_                onFailure,_                leaderClusterState -> {_                    IndexMetaData leaderIndexMetaData = leaderClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client leaderClient = client.getRemoteClusterClient(clusterAlias)__                    fetchLeaderHistoryUUIDs(leaderClient, leaderIndexMetaData, onFailure, historyUUIDs -> {_                        consumer.accept(historyUUIDs, leaderIndexMetaData)__                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards,param,t,the,type,of,response,the,listener,is,waiting,for;public,t,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,collections,empty,map,cluster,alias,request,on,failure,leader,cluster,state,index,meta,data,leader,index,meta,data,leader,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,leader,client,client,get,remote,cluster,client,cluster,alias,fetch,leader,history,uuids,leader,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1538170812;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards_@param <T>           the type of response the listener is waiting for;public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                Collections.emptyMap(),_                clusterAlias,_                request,_                onFailure,_                leaderClusterState -> {_                    IndexMetaData leaderIndexMetaData = leaderClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client leaderClient = client.getRemoteClusterClient(clusterAlias)__                    hasPrivilegesToFollowIndices(leaderClient, new String[] {leaderIndex}, e -> {_                        if (e == null) {_                            fetchLeaderHistoryUUIDs(leaderClient, leaderIndexMetaData, onFailure, historyUUIDs ->_                                    consumer.accept(historyUUIDs, leaderIndexMetaData))__                        } else {_                            onFailure.accept(e)__                        }_                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards,param,t,the,type,of,response,the,listener,is,waiting,for;public,t,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,collections,empty,map,cluster,alias,request,on,failure,leader,cluster,state,index,meta,data,leader,index,meta,data,leader,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,leader,client,client,get,remote,cluster,client,cluster,alias,has,privileges,to,follow,indices,leader,client,new,string,leader,index,e,if,e,null,fetch,leader,history,uuids,leader,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,else,on,failure,accept,e,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1541593410;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards_@param <T>           the type of response the listener is waiting for;public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                Collections.emptyMap(),_                clusterAlias,_                request,_                onFailure,_                leaderClusterState -> {_                    IndexMetaData leaderIndexMetaData = leaderClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client leaderClient = client.getRemoteClusterClient(clusterAlias)__                    hasPrivilegesToFollowIndices(leaderClient, new String[] {leaderIndex}, e -> {_                        if (e == null) {_                            fetchLeaderHistoryUUIDs(leaderClient, leaderIndexMetaData, onFailure, historyUUIDs ->_                                    consumer.accept(historyUUIDs, leaderIndexMetaData))__                        } else {_                            onFailure.accept(e)__                        }_                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards,param,t,the,type,of,response,the,listener,is,waiting,for;public,t,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,collections,empty,map,cluster,alias,request,on,failure,leader,cluster,state,index,meta,data,leader,index,meta,data,leader,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,leader,client,client,get,remote,cluster,client,cluster,alias,has,privileges,to,follow,indices,leader,client,new,string,leader,index,e,if,e,null,fetch,leader,history,uuids,leader,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,else,on,failure,accept,e,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed);1538170812;Constructs a CCR license checker with the specified boolean suppliers.__@param isCcrAllowed  a boolean supplier that should return true if CCR is allowed and false otherwise_@param isAuthAllowed a boolean supplier that should return true if security, authentication, and authorization is allowed;public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed, "isCcrAllowed")__        this.isAuthAllowed = Objects.requireNonNull(isAuthAllowed, "isAuthAllowed")__    };constructs,a,ccr,license,checker,with,the,specified,boolean,suppliers,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise,param,is,auth,allowed,a,boolean,supplier,that,should,return,true,if,security,authentication,and,authorization,is,allowed;public,ccr,license,checker,final,boolean,supplier,is,ccr,allowed,final,boolean,supplier,is,auth,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed,is,ccr,allowed,this,is,auth,allowed,objects,require,non,null,is,auth,allowed,is,auth,allowed
CcrLicenseChecker -> public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed);1541593410;Constructs a CCR license checker with the specified boolean suppliers.__@param isCcrAllowed  a boolean supplier that should return true if CCR is allowed and false otherwise_@param isAuthAllowed a boolean supplier that should return true if security, authentication, and authorization is allowed;public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed, "isCcrAllowed")__        this.isAuthAllowed = Objects.requireNonNull(isAuthAllowed, "isAuthAllowed")__    };constructs,a,ccr,license,checker,with,the,specified,boolean,suppliers,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise,param,is,auth,allowed,a,boolean,supplier,that,should,return,true,if,security,authentication,and,authorization,is,allowed;public,ccr,license,checker,final,boolean,supplier,is,ccr,allowed,final,boolean,supplier,is,auth,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed,is,ccr,allowed,this,is,auth,allowed,objects,require,non,null,is,auth,allowed,is,auth,allowed
CcrLicenseChecker -> public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed);1541670507;Constructs a CCR license checker with the specified boolean suppliers.__@param isCcrAllowed  a boolean supplier that should return true if CCR is allowed and false otherwise_@param isAuthAllowed a boolean supplier that should return true if security, authentication, and authorization is allowed;public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed, "isCcrAllowed")__        this.isAuthAllowed = Objects.requireNonNull(isAuthAllowed, "isAuthAllowed")__    };constructs,a,ccr,license,checker,with,the,specified,boolean,suppliers,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise,param,is,auth,allowed,a,boolean,supplier,that,should,return,true,if,security,authentication,and,authorization,is,allowed;public,ccr,license,checker,final,boolean,supplier,is,ccr,allowed,final,boolean,supplier,is,auth,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed,is,ccr,allowed,this,is,auth,allowed,objects,require,non,null,is,auth,allowed,is,auth,allowed
CcrLicenseChecker -> public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed);1541690774;Constructs a CCR license checker with the specified boolean suppliers.__@param isCcrAllowed  a boolean supplier that should return true if CCR is allowed and false otherwise_@param isAuthAllowed a boolean supplier that should return true if security, authentication, and authorization is allowed;public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed, "isCcrAllowed")__        this.isAuthAllowed = Objects.requireNonNull(isAuthAllowed, "isAuthAllowed")__    };constructs,a,ccr,license,checker,with,the,specified,boolean,suppliers,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise,param,is,auth,allowed,a,boolean,supplier,that,should,return,true,if,security,authentication,and,authorization,is,allowed;public,ccr,license,checker,final,boolean,supplier,is,ccr,allowed,final,boolean,supplier,is,auth,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed,is,ccr,allowed,this,is,auth,allowed,objects,require,non,null,is,auth,allowed,is,auth,allowed
CcrLicenseChecker -> public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed);1543935315;Constructs a CCR license checker with the specified boolean suppliers.__@param isCcrAllowed  a boolean supplier that should return true if CCR is allowed and false otherwise_@param isAuthAllowed a boolean supplier that should return true if security, authentication, and authorization is allowed;public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed, "isCcrAllowed")__        this.isAuthAllowed = Objects.requireNonNull(isAuthAllowed, "isAuthAllowed")__    };constructs,a,ccr,license,checker,with,the,specified,boolean,suppliers,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise,param,is,auth,allowed,a,boolean,supplier,that,should,return,true,if,security,authentication,and,authorization,is,allowed;public,ccr,license,checker,final,boolean,supplier,is,ccr,allowed,final,boolean,supplier,is,auth,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed,is,ccr,allowed,this,is,auth,allowed,objects,require,non,null,is,auth,allowed,is,auth,allowed
CcrLicenseChecker -> public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed);1544615244;Constructs a CCR license checker with the specified boolean suppliers.__@param isCcrAllowed  a boolean supplier that should return true if CCR is allowed and false otherwise_@param isAuthAllowed a boolean supplier that should return true if security, authentication, and authorization is allowed;public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed, "isCcrAllowed")__        this.isAuthAllowed = Objects.requireNonNull(isAuthAllowed, "isAuthAllowed")__    };constructs,a,ccr,license,checker,with,the,specified,boolean,suppliers,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise,param,is,auth,allowed,a,boolean,supplier,that,should,return,true,if,security,authentication,and,authorization,is,allowed;public,ccr,license,checker,final,boolean,supplier,is,ccr,allowed,final,boolean,supplier,is,auth,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed,is,ccr,allowed,this,is,auth,allowed,objects,require,non,null,is,auth,allowed,is,auth,allowed
CcrLicenseChecker -> public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed);1544855694;Constructs a CCR license checker with the specified boolean suppliers.__@param isCcrAllowed  a boolean supplier that should return true if CCR is allowed and false otherwise_@param isAuthAllowed a boolean supplier that should return true if security, authentication, and authorization is allowed;public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed, "isCcrAllowed")__        this.isAuthAllowed = Objects.requireNonNull(isAuthAllowed, "isAuthAllowed")__    };constructs,a,ccr,license,checker,with,the,specified,boolean,suppliers,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise,param,is,auth,allowed,a,boolean,supplier,that,should,return,true,if,security,authentication,and,authorization,is,allowed;public,ccr,license,checker,final,boolean,supplier,is,ccr,allowed,final,boolean,supplier,is,auth,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed,is,ccr,allowed,this,is,auth,allowed,objects,require,non,null,is,auth,allowed,is,auth,allowed
CcrLicenseChecker -> public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed);1545642998;Constructs a CCR license checker with the specified boolean suppliers.__@param isCcrAllowed  a boolean supplier that should return true if CCR is allowed and false otherwise_@param isAuthAllowed a boolean supplier that should return true if security, authentication, and authorization is allowed;public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed, "isCcrAllowed")__        this.isAuthAllowed = Objects.requireNonNull(isAuthAllowed, "isAuthAllowed")__    };constructs,a,ccr,license,checker,with,the,specified,boolean,suppliers,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise,param,is,auth,allowed,a,boolean,supplier,that,should,return,true,if,security,authentication,and,authorization,is,allowed;public,ccr,license,checker,final,boolean,supplier,is,ccr,allowed,final,boolean,supplier,is,auth,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed,is,ccr,allowed,this,is,auth,allowed,objects,require,non,null,is,auth,allowed,is,auth,allowed
CcrLicenseChecker -> public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed);1549336917;Constructs a CCR license checker with the specified boolean suppliers.__@param isCcrAllowed  a boolean supplier that should return true if CCR is allowed and false otherwise_@param isAuthAllowed a boolean supplier that should return true if security, authentication, and authorization is allowed;public CcrLicenseChecker(final BooleanSupplier isCcrAllowed, final BooleanSupplier isAuthAllowed) {_        this.isCcrAllowed = Objects.requireNonNull(isCcrAllowed, "isCcrAllowed")__        this.isAuthAllowed = Objects.requireNonNull(isAuthAllowed, "isAuthAllowed")__    };constructs,a,ccr,license,checker,with,the,specified,boolean,suppliers,param,is,ccr,allowed,a,boolean,supplier,that,should,return,true,if,ccr,is,allowed,and,false,otherwise,param,is,auth,allowed,a,boolean,supplier,that,should,return,true,if,security,authentication,and,authorization,is,allowed;public,ccr,license,checker,final,boolean,supplier,is,ccr,allowed,final,boolean,supplier,is,auth,allowed,this,is,ccr,allowed,objects,require,non,null,is,ccr,allowed,is,ccr,allowed,this,is,auth,allowed,objects,require,non,null,is,auth,allowed,is,auth,allowed
CcrLicenseChecker -> private <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1536611444;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure_@param <T>                        the type of response the listener is waiting for;private <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final Client leaderClient = client.getRemoteClusterClient(clusterAlias)__                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                    ActionListener.wrap(s -> leaderClusterStateConsumer.accept(s.getState()), onFailure)__                            _                            leaderClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure,param,t,the,type,of,response,the,listener,is,waiting,for;private,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,client,leader,client,client,get,remote,cluster,client,cluster,alias,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,s,leader,cluster,state,consumer,accept,s,get,state,on,failure,leader,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> private <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1536828374;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure_@param <T>                        the type of response the listener is waiting for;private <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final Client leaderClient = client.getRemoteClusterClient(clusterAlias)__                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                    ActionListener.wrap(s -> leaderClusterStateConsumer.accept(s.getState()), onFailure)__                            _                            leaderClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure,param,t,the,type,of,response,the,listener,is,waiting,for;private,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,client,leader,client,client,get,remote,cluster,client,cluster,alias,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,s,leader,cluster,state,consumer,accept,s,get,state,on,failure,leader,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> private <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final Map<String, String> headers,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1537202470;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param headers                    the headers to use for leader client_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure_@param <T>                        the type of response the listener is waiting for;private <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final Map<String, String> headers,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final Client leaderClient = wrapClient(client.getRemoteClusterClient(clusterAlias), headers)__                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                    ActionListener.wrap(s -> leaderClusterStateConsumer.accept(s.getState()), onFailure)__                            _                            leaderClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,headers,the,headers,to,use,for,leader,client,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure,param,t,the,type,of,response,the,listener,is,waiting,for;private,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,map,string,string,headers,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,client,leader,client,wrap,client,client,get,remote,cluster,client,cluster,alias,headers,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,s,leader,cluster,state,consumer,accept,s,get,state,on,failure,leader,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> private <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final Map<String, String> headers,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1537300661;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param headers                    the headers to use for leader client_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure_@param <T>                        the type of response the listener is waiting for;private <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final Map<String, String> headers,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final Client leaderClient = wrapClient(client.getRemoteClusterClient(clusterAlias), headers)__                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                    ActionListener.wrap(s -> leaderClusterStateConsumer.accept(s.getState()), onFailure)__                            _                            leaderClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,headers,the,headers,to,use,for,leader,client,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure,param,t,the,type,of,response,the,listener,is,waiting,for;private,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,map,string,string,headers,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,client,leader,client,wrap,client,client,get,remote,cluster,client,cluster,alias,headers,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,s,leader,cluster,state,consumer,accept,s,get,state,on,failure,leader,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> private <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final Map<String, String> headers,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1538170812;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param headers                    the headers to use for leader client_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure_@param <T>                        the type of response the listener is waiting for;private <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final Map<String, String> headers,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final Client leaderClient = wrapClient(client.getRemoteClusterClient(clusterAlias), headers)__                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                    ActionListener.wrap(s -> leaderClusterStateConsumer.accept(s.getState()), onFailure)__                            _                            leaderClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,headers,the,headers,to,use,for,leader,client,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure,param,t,the,type,of,response,the,listener,is,waiting,for;private,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,map,string,string,headers,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,client,leader,client,wrap,client,client,get,remote,cluster,client,cluster,alias,headers,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,s,leader,cluster,state,consumer,accept,s,get,state,on,failure,leader,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> private <T> void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final Map<String, String> headers,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer,             final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,             final Function<Exception, ElasticsearchStatusException> unknownLicense);1541593410;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param headers                    the headers to use for leader client_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer_@param nonCompliantLicense        the supplier for when the license state of the remote cluster is non-compliant_@param unknownLicense             the supplier for when the license state of the remote cluster is unknown due to failure_@param <T>                        the type of response the listener is waiting for;private <T> void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final Map<String, String> headers,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer,_            final Function<RemoteClusterLicenseChecker.LicenseCheck, ElasticsearchStatusException> nonCompliantLicense,_            final Function<Exception, ElasticsearchStatusException> unknownLicense) {_        _        new RemoteClusterLicenseChecker(client, XPackLicenseState::isCcrAllowedForOperationMode).checkRemoteClusterLicenses(_                Collections.singletonList(clusterAlias),_                new ActionListener<RemoteClusterLicenseChecker.LicenseCheck>() {__                    @Override_                    public void onResponse(final RemoteClusterLicenseChecker.LicenseCheck licenseCheck) {_                        if (licenseCheck.isSuccess()) {_                            final Client leaderClient = wrapClient(client.getRemoteClusterClient(clusterAlias), headers)__                            final ActionListener<ClusterStateResponse> clusterStateListener =_                                    ActionListener.wrap(s -> leaderClusterStateConsumer.accept(s.getState()), onFailure)__                            _                            leaderClient.admin().cluster().state(request, clusterStateListener)__                        } else {_                            onFailure.accept(nonCompliantLicense.apply(licenseCheck))__                        }_                    }__                    @Override_                    public void onFailure(final Exception e) {_                        onFailure.accept(unknownLicense.apply(e))__                    }__                })__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,headers,the,headers,to,use,for,leader,client,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer,param,non,compliant,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,non,compliant,param,unknown,license,the,supplier,for,when,the,license,state,of,the,remote,cluster,is,unknown,due,to,failure,param,t,the,type,of,response,the,listener,is,waiting,for;private,t,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,map,string,string,headers,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,final,function,remote,cluster,license,checker,license,check,elasticsearch,status,exception,non,compliant,license,final,function,exception,elasticsearch,status,exception,unknown,license,new,remote,cluster,license,checker,client,xpack,license,state,is,ccr,allowed,for,operation,mode,check,remote,cluster,licenses,collections,singleton,list,cluster,alias,new,action,listener,remote,cluster,license,checker,license,check,override,public,void,on,response,final,remote,cluster,license,checker,license,check,license,check,if,license,check,is,success,final,client,leader,client,wrap,client,client,get,remote,cluster,client,cluster,alias,headers,final,action,listener,cluster,state,response,cluster,state,listener,action,listener,wrap,s,leader,cluster,state,consumer,accept,s,get,state,on,failure,leader,client,admin,cluster,state,request,cluster,state,listener,else,on,failure,accept,non,compliant,license,apply,license,check,override,public,void,on,failure,final,exception,e,on,failure,accept,unknown,license,apply,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer);1541670507;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer;public void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer) {_        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                systemClient(client.getRemoteClusterClient(clusterAlias)),_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer;public,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,system,client,client,get,remote,cluster,client,cluster,alias,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer);1541690774;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer;public void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer) {_        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                systemClient(client.getRemoteClusterClient(clusterAlias)),_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer;public,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,system,client,client,get,remote,cluster,client,cluster,alias,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchClusterState(             final Client client,             final String clusterAlias,             final ClusterStateRequest request,             final Consumer<Exception> onFailure,             final Consumer<ClusterState> leaderClusterStateConsumer);1543935315;Fetches the leader cluster state from the remote cluster by the specified cluster state request. Before fetching the cluster state,_the remote cluster is checked for license compliance with CCR. If the remote cluster is not licensed for CCR,_the {@code onFailure} consumer is invoked. Otherwise, the specified consumer is invoked with the leader cluster state fetched from_the remote cluster.__@param client                     the client_@param clusterAlias               the remote cluster alias_@param request                    the cluster state request_@param onFailure                  the failure consumer_@param leaderClusterStateConsumer the leader cluster state consumer;public void checkRemoteClusterLicenseAndFetchClusterState(_            final Client client,_            final String clusterAlias,_            final ClusterStateRequest request,_            final Consumer<Exception> onFailure,_            final Consumer<ClusterState> leaderClusterStateConsumer) {_        try {_            Client remoteClient = systemClient(client.getRemoteClusterClient(clusterAlias))__            checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                remoteClient,_                request,_                onFailure,_                leaderClusterStateConsumer,_                CcrLicenseChecker::clusterStateNonCompliantRemoteLicense,_                e -> clusterStateUnknownRemoteLicense(clusterAlias, e))__        } catch (Exception e) {_            _            _            onFailure.accept(e)__        }_    };fetches,the,leader,cluster,state,from,the,remote,cluster,by,the,specified,cluster,state,request,before,fetching,the,cluster,state,the,remote,cluster,is,checked,for,license,compliance,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,cluster,state,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,request,the,cluster,state,request,param,on,failure,the,failure,consumer,param,leader,cluster,state,consumer,the,leader,cluster,state,consumer;public,void,check,remote,cluster,license,and,fetch,cluster,state,final,client,client,final,string,cluster,alias,final,cluster,state,request,request,final,consumer,exception,on,failure,final,consumer,cluster,state,leader,cluster,state,consumer,try,client,remote,client,system,client,client,get,remote,cluster,client,cluster,alias,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,remote,client,request,on,failure,leader,cluster,state,consumer,ccr,license,checker,cluster,state,non,compliant,remote,license,e,cluster,state,unknown,remote,license,cluster,alias,e,catch,exception,e,on,failure,accept,e
CcrLicenseChecker -> CcrLicenseChecker();1535965276;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed
CcrLicenseChecker -> CcrLicenseChecker();1536611444;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed
CcrLicenseChecker -> CcrLicenseChecker();1536828374;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed
CcrLicenseChecker -> CcrLicenseChecker();1537202470;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed
CcrLicenseChecker -> CcrLicenseChecker();1537300661;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed
CcrLicenseChecker -> CcrLicenseChecker();1538170812;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed, XPackPlugin.getSharedLicenseState()::isAuthAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed,xpack,plugin,get,shared,license,state,is,auth,allowed
CcrLicenseChecker -> CcrLicenseChecker();1541593410;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed, XPackPlugin.getSharedLicenseState()::isAuthAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed,xpack,plugin,get,shared,license,state,is,auth,allowed
CcrLicenseChecker -> CcrLicenseChecker();1541670507;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed, XPackPlugin.getSharedLicenseState()::isAuthAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed,xpack,plugin,get,shared,license,state,is,auth,allowed
CcrLicenseChecker -> CcrLicenseChecker();1541690774;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed, XPackPlugin.getSharedLicenseState()::isAuthAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed,xpack,plugin,get,shared,license,state,is,auth,allowed
CcrLicenseChecker -> CcrLicenseChecker();1543935315;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed, XPackPlugin.getSharedLicenseState()::isAuthAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed,xpack,plugin,get,shared,license,state,is,auth,allowed
CcrLicenseChecker -> CcrLicenseChecker();1544615244;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed, XPackPlugin.getSharedLicenseState()::isAuthAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed,xpack,plugin,get,shared,license,state,is,auth,allowed
CcrLicenseChecker -> CcrLicenseChecker();1544855694;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed, XPackPlugin.getSharedLicenseState()::isAuthAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed,xpack,plugin,get,shared,license,state,is,auth,allowed
CcrLicenseChecker -> CcrLicenseChecker();1545642998;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed, XPackPlugin.getSharedLicenseState()::isAuthAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed,xpack,plugin,get,shared,license,state,is,auth,allowed
CcrLicenseChecker -> CcrLicenseChecker();1549336917;Constructs a CCR license checker with the default rule based on the license state for checking if CCR is allowed.;CcrLicenseChecker() {_        this(XPackPlugin.getSharedLicenseState()::isCcrAllowed, XPackPlugin.getSharedLicenseState()::isAuthAllowed)__    };constructs,a,ccr,license,checker,with,the,default,rule,based,on,the,license,state,for,checking,if,ccr,is,allowed;ccr,license,checker,this,xpack,plugin,get,shared,license,state,is,ccr,allowed,xpack,plugin,get,shared,license,state,is,auth,allowed
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client leaderClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1536828374;Fetches the history UUIDs for leader index on per shard basis using the specified leaderClient.__@param leaderClient                              the leader client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client leaderClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        leaderClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,leader,client,param,leader,client,the,leader,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,leader,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,leader,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client leaderClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1537202470;Fetches the history UUIDs for leader index on per shard basis using the specified leaderClient.__@param leaderClient                              the leader client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client leaderClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        leaderClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,leader,client,param,leader,client,the,leader,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,leader,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,leader,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client leaderClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1537300661;Fetches the history UUIDs for leader index on per shard basis using the specified leaderClient.__@param leaderClient                              the leader client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client leaderClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        leaderClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,leader,client,param,leader,client,the,leader,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,leader,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,leader,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client leaderClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1538170812;Fetches the history UUIDs for leader index on per shard basis using the specified leaderClient.__@param leaderClient                              the leader client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client leaderClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        leaderClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,leader,client,param,leader,client,the,leader,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,leader,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,leader,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client leaderClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1541593410;Fetches the history UUIDs for leader index on per shard basis using the specified leaderClient.__@param leaderClient                              the leader client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client leaderClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            if (indexStats == null) {_                onFailure.accept(new IllegalArgumentException("no index stats available for the leader index"))__                return__            }__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        leaderClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,leader,client,param,leader,client,the,leader,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,leader,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,if,index,stats,null,on,failure,accept,new,illegal,argument,exception,no,index,stats,available,for,the,leader,index,return,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,leader,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void fetchLeaderHistoryUUIDs(         final Client leaderClient,         final IndexMetaData leaderIndexMetaData,         final Consumer<Exception> onFailure,         final Consumer<String[]> historyUUIDConsumer);1541670507;Fetches the history UUIDs for leader index on per shard basis using the specified leaderClient.__@param leaderClient                              the leader client_@param leaderIndexMetaData                       the leader index metadata_@param onFailure                                 the failure consumer_@param historyUUIDConsumer                       the leader index history uuid and consumer;public void fetchLeaderHistoryUUIDs(_        final Client leaderClient,_        final IndexMetaData leaderIndexMetaData,_        final Consumer<Exception> onFailure,_        final Consumer<String[]> historyUUIDConsumer) {__        String leaderIndex = leaderIndexMetaData.getIndex().getName()__        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {_            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex)__            if (indexStats == null) {_                onFailure.accept(new IllegalArgumentException("no index stats available for the leader index"))__                return__            }__            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()]__            for (IndexShardStats indexShardStats : indexStats) {_                for (ShardStats shardStats : indexShardStats) {_                    _                    _                    if (shardStats.getShardRouting().primary() == false) {_                        continue__                    }__                    CommitStats commitStats = shardStats.getCommitStats()__                    if (commitStats == null) {_                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"))__                        return__                    }_                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY)__                    ShardId shardId = shardStats.getShardRouting().shardId()__                    historyUUIDs[shardId.id()] = historyUUID__                }_            }_            for (int i = 0_ i < historyUUIDs.length_ i++) {_                if (historyUUIDs[i] == null) {_                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"))__                    return__                }_            }_            historyUUIDConsumer.accept(historyUUIDs)__        }__        IndicesStatsRequest request = new IndicesStatsRequest()__        request.clear()__        request.indices(leaderIndex)__        leaderClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure))__    };fetches,the,history,uuids,for,leader,index,on,per,shard,basis,using,the,specified,leader,client,param,leader,client,the,leader,client,param,leader,index,meta,data,the,leader,index,metadata,param,on,failure,the,failure,consumer,param,history,uuidconsumer,the,leader,index,history,uuid,and,consumer;public,void,fetch,leader,history,uuids,final,client,leader,client,final,index,meta,data,leader,index,meta,data,final,consumer,exception,on,failure,final,consumer,string,history,uuidconsumer,string,leader,index,leader,index,meta,data,get,index,get,name,checked,consumer,indices,stats,response,exception,indices,stats,handler,indices,stats,response,index,stats,index,stats,indices,stats,response,get,indices,get,leader,index,if,index,stats,null,on,failure,accept,new,illegal,argument,exception,no,index,stats,available,for,the,leader,index,return,string,history,uuids,new,string,leader,index,meta,data,get,number,of,shards,for,index,shard,stats,index,shard,stats,index,stats,for,shard,stats,shard,stats,index,shard,stats,if,shard,stats,get,shard,routing,primary,false,continue,commit,stats,commit,stats,shard,stats,get,commit,stats,if,commit,stats,null,on,failure,accept,new,illegal,argument,exception,leader,index,s,commit,stats,are,missing,return,string,history,uuid,commit,stats,get,user,data,get,engine,shard,id,shard,id,shard,stats,get,shard,routing,shard,id,history,uuids,shard,id,id,history,uuid,for,int,i,0,i,history,uuids,length,i,if,history,uuids,i,null,on,failure,accept,new,illegal,argument,exception,no,history,uuid,for,leader,index,i,return,history,uuidconsumer,accept,history,uuids,indices,stats,request,request,new,indices,stats,request,request,clear,request,indices,leader,index,leader,client,admin,indices,stats,request,action,listener,wrap,indices,stats,handler,on,failure
CcrLicenseChecker -> public void hasPrivilegesToFollowIndices(final Client leaderClient, final String[] indices, final Consumer<Exception> handler);1538170812;Check if the user executing the current action has privileges to follow the specified indices on the cluster specified by the leader_client. The specified callback will be invoked with null if the user has the necessary privileges to follow the specified indices,_otherwise the callback will be invoked with an exception outlining the authorization error.__@param leaderClient the leader client_@param indices      the indices_@param handler      the callback;public void hasPrivilegesToFollowIndices(final Client leaderClient, final String[] indices, final Consumer<Exception> handler) {_        Objects.requireNonNull(leaderClient, "leaderClient")__        Objects.requireNonNull(indices, "indices")__        if (indices.length == 0) {_            throw new IllegalArgumentException("indices must not be empty")__        }_        Objects.requireNonNull(handler, "handler")__        if (isAuthAllowed.getAsBoolean() == false) {_            handler.accept(null)__            return__        }__        ThreadContext threadContext = leaderClient.threadPool().getThreadContext()__        SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext)__        String username = securityContext.getUser().principal()___        RoleDescriptor.IndicesPrivileges privileges = RoleDescriptor.IndicesPrivileges.builder()_            .indices(indices)_            .privileges(IndicesStatsAction.NAME, ShardChangesAction.NAME)_            .build()___        HasPrivilegesRequest request = new HasPrivilegesRequest()__        request.username(username)__        request.clusterPrivileges(Strings.EMPTY_ARRAY)__        request.indexPrivileges(privileges)__        request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0])__        CheckedConsumer<HasPrivilegesResponse, Exception> responseHandler = response -> {_            if (response.isCompleteMatch()) {_                handler.accept(null)__            } else {_                StringBuilder message = new StringBuilder("insufficient privileges to follow")__                message.append(indices.length == 1 ? " index " : " indices ")__                message.append(Arrays.toString(indices))___                HasPrivilegesResponse.ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().get(0)__                for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {_                    if (entry.getValue() == false) {_                        message.append(", privilege for action [")__                        message.append(entry.getKey())__                        message.append("] is missing")__                    }_                }__                handler.accept(Exceptions.authorizationError(message.toString()))__            }_        }__        leaderClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler))__    };check,if,the,user,executing,the,current,action,has,privileges,to,follow,the,specified,indices,on,the,cluster,specified,by,the,leader,client,the,specified,callback,will,be,invoked,with,null,if,the,user,has,the,necessary,privileges,to,follow,the,specified,indices,otherwise,the,callback,will,be,invoked,with,an,exception,outlining,the,authorization,error,param,leader,client,the,leader,client,param,indices,the,indices,param,handler,the,callback;public,void,has,privileges,to,follow,indices,final,client,leader,client,final,string,indices,final,consumer,exception,handler,objects,require,non,null,leader,client,leader,client,objects,require,non,null,indices,indices,if,indices,length,0,throw,new,illegal,argument,exception,indices,must,not,be,empty,objects,require,non,null,handler,handler,if,is,auth,allowed,get,as,boolean,false,handler,accept,null,return,thread,context,thread,context,leader,client,thread,pool,get,thread,context,security,context,security,context,new,security,context,settings,empty,thread,context,string,username,security,context,get,user,principal,role,descriptor,indices,privileges,privileges,role,descriptor,indices,privileges,builder,indices,indices,privileges,indices,stats,action,name,shard,changes,action,name,build,has,privileges,request,request,new,has,privileges,request,request,username,username,request,cluster,privileges,strings,request,index,privileges,privileges,request,application,privileges,new,role,descriptor,application,resource,privileges,0,checked,consumer,has,privileges,response,exception,response,handler,response,if,response,is,complete,match,handler,accept,null,else,string,builder,message,new,string,builder,insufficient,privileges,to,follow,message,append,indices,length,1,index,indices,message,append,arrays,to,string,indices,has,privileges,response,resource,privileges,resource,privileges,response,get,index,privileges,get,0,for,map,entry,string,boolean,entry,resource,privileges,get,privileges,entry,set,if,entry,get,value,false,message,append,privilege,for,action,message,append,entry,get,key,message,append,is,missing,handler,accept,exceptions,authorization,error,message,to,string,leader,client,execute,has,privileges,action,instance,request,action,listener,wrap,response,handler,handler
CcrLicenseChecker -> public void hasPrivilegesToFollowIndices(final Client leaderClient, final String[] indices, final Consumer<Exception> handler);1541593410;Check if the user executing the current action has privileges to follow the specified indices on the cluster specified by the leader_client. The specified callback will be invoked with null if the user has the necessary privileges to follow the specified indices,_otherwise the callback will be invoked with an exception outlining the authorization error.__@param leaderClient the leader client_@param indices      the indices_@param handler      the callback;public void hasPrivilegesToFollowIndices(final Client leaderClient, final String[] indices, final Consumer<Exception> handler) {_        Objects.requireNonNull(leaderClient, "leaderClient")__        Objects.requireNonNull(indices, "indices")__        if (indices.length == 0) {_            throw new IllegalArgumentException("indices must not be empty")__        }_        Objects.requireNonNull(handler, "handler")__        if (isAuthAllowed.getAsBoolean() == false) {_            handler.accept(null)__            return__        }__        ThreadContext threadContext = leaderClient.threadPool().getThreadContext()__        SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext)__        String username = securityContext.getUser().principal()___        RoleDescriptor.IndicesPrivileges privileges = RoleDescriptor.IndicesPrivileges.builder()_            .indices(indices)_            .privileges(IndicesStatsAction.NAME, ShardChangesAction.NAME)_            .build()___        HasPrivilegesRequest request = new HasPrivilegesRequest()__        request.username(username)__        request.clusterPrivileges(Strings.EMPTY_ARRAY)__        request.indexPrivileges(privileges)__        request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0])__        CheckedConsumer<HasPrivilegesResponse, Exception> responseHandler = response -> {_            if (response.isCompleteMatch()) {_                handler.accept(null)__            } else {_                StringBuilder message = new StringBuilder("insufficient privileges to follow")__                message.append(indices.length == 1 ? " index " : " indices ")__                message.append(Arrays.toString(indices))___                HasPrivilegesResponse.ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().get(0)__                for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {_                    if (entry.getValue() == false) {_                        message.append(", privilege for action [")__                        message.append(entry.getKey())__                        message.append("] is missing")__                    }_                }__                handler.accept(Exceptions.authorizationError(message.toString()))__            }_        }__        leaderClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler))__    };check,if,the,user,executing,the,current,action,has,privileges,to,follow,the,specified,indices,on,the,cluster,specified,by,the,leader,client,the,specified,callback,will,be,invoked,with,null,if,the,user,has,the,necessary,privileges,to,follow,the,specified,indices,otherwise,the,callback,will,be,invoked,with,an,exception,outlining,the,authorization,error,param,leader,client,the,leader,client,param,indices,the,indices,param,handler,the,callback;public,void,has,privileges,to,follow,indices,final,client,leader,client,final,string,indices,final,consumer,exception,handler,objects,require,non,null,leader,client,leader,client,objects,require,non,null,indices,indices,if,indices,length,0,throw,new,illegal,argument,exception,indices,must,not,be,empty,objects,require,non,null,handler,handler,if,is,auth,allowed,get,as,boolean,false,handler,accept,null,return,thread,context,thread,context,leader,client,thread,pool,get,thread,context,security,context,security,context,new,security,context,settings,empty,thread,context,string,username,security,context,get,user,principal,role,descriptor,indices,privileges,privileges,role,descriptor,indices,privileges,builder,indices,indices,privileges,indices,stats,action,name,shard,changes,action,name,build,has,privileges,request,request,new,has,privileges,request,request,username,username,request,cluster,privileges,strings,request,index,privileges,privileges,request,application,privileges,new,role,descriptor,application,resource,privileges,0,checked,consumer,has,privileges,response,exception,response,handler,response,if,response,is,complete,match,handler,accept,null,else,string,builder,message,new,string,builder,insufficient,privileges,to,follow,message,append,indices,length,1,index,indices,message,append,arrays,to,string,indices,has,privileges,response,resource,privileges,resource,privileges,response,get,index,privileges,get,0,for,map,entry,string,boolean,entry,resource,privileges,get,privileges,entry,set,if,entry,get,value,false,message,append,privilege,for,action,message,append,entry,get,key,message,append,is,missing,handler,accept,exceptions,authorization,error,message,to,string,leader,client,execute,has,privileges,action,instance,request,action,listener,wrap,response,handler,handler
CcrLicenseChecker -> public void hasPrivilegesToFollowIndices(final Client leaderClient, final String[] indices, final Consumer<Exception> handler);1541670507;Check if the user executing the current action has privileges to follow the specified indices on the cluster specified by the leader_client. The specified callback will be invoked with null if the user has the necessary privileges to follow the specified indices,_otherwise the callback will be invoked with an exception outlining the authorization error.__@param leaderClient the leader client_@param indices      the indices_@param handler      the callback;public void hasPrivilegesToFollowIndices(final Client leaderClient, final String[] indices, final Consumer<Exception> handler) {_        Objects.requireNonNull(leaderClient, "leaderClient")__        Objects.requireNonNull(indices, "indices")__        if (indices.length == 0) {_            throw new IllegalArgumentException("indices must not be empty")__        }_        Objects.requireNonNull(handler, "handler")__        if (isAuthAllowed.getAsBoolean() == false) {_            handler.accept(null)__            return__        }__        ThreadContext threadContext = leaderClient.threadPool().getThreadContext()__        SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext)__        String username = securityContext.getUser().principal()___        RoleDescriptor.IndicesPrivileges privileges = RoleDescriptor.IndicesPrivileges.builder()_            .indices(indices)_            .privileges(IndicesStatsAction.NAME, ShardChangesAction.NAME)_            .build()___        HasPrivilegesRequest request = new HasPrivilegesRequest()__        request.username(username)__        request.clusterPrivileges(Strings.EMPTY_ARRAY)__        request.indexPrivileges(privileges)__        request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0])__        CheckedConsumer<HasPrivilegesResponse, Exception> responseHandler = response -> {_            if (response.isCompleteMatch()) {_                handler.accept(null)__            } else {_                StringBuilder message = new StringBuilder("insufficient privileges to follow")__                message.append(indices.length == 1 ? " index " : " indices ")__                message.append(Arrays.toString(indices))___                HasPrivilegesResponse.ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().get(0)__                for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {_                    if (entry.getValue() == false) {_                        message.append(", privilege for action [")__                        message.append(entry.getKey())__                        message.append("] is missing")__                    }_                }__                handler.accept(Exceptions.authorizationError(message.toString()))__            }_        }__        leaderClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler))__    };check,if,the,user,executing,the,current,action,has,privileges,to,follow,the,specified,indices,on,the,cluster,specified,by,the,leader,client,the,specified,callback,will,be,invoked,with,null,if,the,user,has,the,necessary,privileges,to,follow,the,specified,indices,otherwise,the,callback,will,be,invoked,with,an,exception,outlining,the,authorization,error,param,leader,client,the,leader,client,param,indices,the,indices,param,handler,the,callback;public,void,has,privileges,to,follow,indices,final,client,leader,client,final,string,indices,final,consumer,exception,handler,objects,require,non,null,leader,client,leader,client,objects,require,non,null,indices,indices,if,indices,length,0,throw,new,illegal,argument,exception,indices,must,not,be,empty,objects,require,non,null,handler,handler,if,is,auth,allowed,get,as,boolean,false,handler,accept,null,return,thread,context,thread,context,leader,client,thread,pool,get,thread,context,security,context,security,context,new,security,context,settings,empty,thread,context,string,username,security,context,get,user,principal,role,descriptor,indices,privileges,privileges,role,descriptor,indices,privileges,builder,indices,indices,privileges,indices,stats,action,name,shard,changes,action,name,build,has,privileges,request,request,new,has,privileges,request,request,username,username,request,cluster,privileges,strings,request,index,privileges,privileges,request,application,privileges,new,role,descriptor,application,resource,privileges,0,checked,consumer,has,privileges,response,exception,response,handler,response,if,response,is,complete,match,handler,accept,null,else,string,builder,message,new,string,builder,insufficient,privileges,to,follow,message,append,indices,length,1,index,indices,message,append,arrays,to,string,indices,has,privileges,response,resource,privileges,resource,privileges,response,get,index,privileges,get,0,for,map,entry,string,boolean,entry,resource,privileges,get,privileges,entry,set,if,entry,get,value,false,message,append,privilege,for,action,message,append,entry,get,key,message,append,is,missing,handler,accept,exceptions,authorization,error,message,to,string,leader,client,execute,has,privileges,action,instance,request,action,listener,wrap,response,handler,handler
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1541670507;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards;public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                client.getRemoteClusterClient(clusterAlias),_                request,_                onFailure,_                leaderClusterState -> {_                    IndexMetaData leaderIndexMetaData = leaderClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client leaderClient = client.getRemoteClusterClient(clusterAlias)__                    hasPrivilegesToFollowIndices(leaderClient, new String[] {leaderIndex}, e -> {_                        if (e == null) {_                            fetchLeaderHistoryUUIDs(leaderClient, leaderIndexMetaData, onFailure, historyUUIDs ->_                                    consumer.accept(historyUUIDs, leaderIndexMetaData))__                        } else {_                            onFailure.accept(e)__                        }_                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards;public,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,client,get,remote,cluster,client,cluster,alias,request,on,failure,leader,cluster,state,index,meta,data,leader,index,meta,data,leader,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,leader,client,client,get,remote,cluster,client,cluster,alias,has,privileges,to,follow,indices,leader,client,new,string,leader,index,e,if,e,null,fetch,leader,history,uuids,leader,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,else,on,failure,accept,e,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1541690774;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards;public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                client.getRemoteClusterClient(clusterAlias),_                request,_                onFailure,_                leaderClusterState -> {_                    IndexMetaData leaderIndexMetaData = leaderClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client remoteClient = client.getRemoteClusterClient(clusterAlias)__                    hasPrivilegesToFollowIndices(remoteClient, new String[] {leaderIndex}, e -> {_                        if (e == null) {_                            fetchLeaderHistoryUUIDs(remoteClient, leaderIndexMetaData, onFailure, historyUUIDs ->_                                    consumer.accept(historyUUIDs, leaderIndexMetaData))__                        } else {_                            onFailure.accept(e)__                        }_                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards;public,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,client,get,remote,cluster,client,cluster,alias,request,on,failure,leader,cluster,state,index,meta,data,leader,index,meta,data,leader,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,remote,client,client,get,remote,cluster,client,cluster,alias,has,privileges,to,follow,indices,remote,client,new,string,leader,index,e,if,e,null,fetch,leader,history,uuids,remote,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,else,on,failure,accept,e,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1543935315;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards;public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                client.getRemoteClusterClient(clusterAlias),_                request,_                onFailure,_                leaderClusterState -> {_                    IndexMetaData leaderIndexMetaData = leaderClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client remoteClient = client.getRemoteClusterClient(clusterAlias)__                    hasPrivilegesToFollowIndices(remoteClient, new String[] {leaderIndex}, e -> {_                        if (e == null) {_                            fetchLeaderHistoryUUIDs(remoteClient, leaderIndexMetaData, onFailure, historyUUIDs ->_                                    consumer.accept(historyUUIDs, leaderIndexMetaData))__                        } else {_                            onFailure.accept(e)__                        }_                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards;public,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,client,get,remote,cluster,client,cluster,alias,request,on,failure,leader,cluster,state,index,meta,data,leader,index,meta,data,leader,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,remote,client,client,get,remote,cluster,client,cluster,alias,has,privileges,to,follow,indices,remote,client,new,string,leader,index,e,if,e,null,fetch,leader,history,uuids,remote,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,else,on,failure,accept,e,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1544615244;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards;public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                client.getRemoteClusterClient(clusterAlias),_                request,_                onFailure,_                remoteClusterStateResponse   -> {_                    ClusterState remoteClusterState = remoteClusterStateResponse.getState()__                    IndexMetaData leaderIndexMetaData = remoteClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client remoteClient = client.getRemoteClusterClient(clusterAlias)__                    hasPrivilegesToFollowIndices(remoteClient, new String[] {leaderIndex}, e -> {_                        if (e == null) {_                            fetchLeaderHistoryUUIDs(remoteClient, leaderIndexMetaData, onFailure, historyUUIDs ->_                                    consumer.accept(historyUUIDs, leaderIndexMetaData))__                        } else {_                            onFailure.accept(e)__                        }_                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards;public,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,client,get,remote,cluster,client,cluster,alias,request,on,failure,remote,cluster,state,response,cluster,state,remote,cluster,state,remote,cluster,state,response,get,state,index,meta,data,leader,index,meta,data,remote,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,remote,client,client,get,remote,cluster,client,cluster,alias,has,privileges,to,follow,indices,remote,client,new,string,leader,index,e,if,e,null,fetch,leader,history,uuids,remote,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,else,on,failure,accept,e,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1544855694;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards;public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                client.getRemoteClusterClient(clusterAlias),_                request,_                onFailure,_                remoteClusterStateResponse   -> {_                    ClusterState remoteClusterState = remoteClusterStateResponse.getState()__                    IndexMetaData leaderIndexMetaData = remoteClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client remoteClient = client.getRemoteClusterClient(clusterAlias)__                    hasPrivilegesToFollowIndices(remoteClient, new String[] {leaderIndex}, e -> {_                        if (e == null) {_                            fetchLeaderHistoryUUIDs(remoteClient, leaderIndexMetaData, onFailure, historyUUIDs ->_                                    consumer.accept(historyUUIDs, leaderIndexMetaData))__                        } else {_                            onFailure.accept(e)__                        }_                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards;public,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,client,get,remote,cluster,client,cluster,alias,request,on,failure,remote,cluster,state,response,cluster,state,remote,cluster,state,remote,cluster,state,response,get,state,index,meta,data,leader,index,meta,data,remote,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,remote,client,client,get,remote,cluster,client,cluster,alias,has,privileges,to,follow,indices,remote,client,new,string,leader,index,e,if,e,null,fetch,leader,history,uuids,remote,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,else,on,failure,accept,e,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1545642998;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards;public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                client.getRemoteClusterClient(clusterAlias),_                request,_                onFailure,_                remoteClusterStateResponse -> {_                    ClusterState remoteClusterState = remoteClusterStateResponse.getState()__                    IndexMetaData leaderIndexMetaData = remoteClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client remoteClient = client.getRemoteClusterClient(clusterAlias)__                    hasPrivilegesToFollowIndices(remoteClient, new String[] {leaderIndex}, e -> {_                        if (e == null) {_                            fetchLeaderHistoryUUIDs(remoteClient, leaderIndexMetaData, onFailure, historyUUIDs ->_                                    consumer.accept(historyUUIDs, leaderIndexMetaData))__                        } else {_                            onFailure.accept(e)__                        }_                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards;public,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,client,get,remote,cluster,client,cluster,alias,request,on,failure,remote,cluster,state,response,cluster,state,remote,cluster,state,remote,cluster,state,response,get,state,index,meta,data,leader,index,meta,data,remote,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,remote,client,client,get,remote,cluster,client,cluster,alias,has,privileges,to,follow,indices,remote,client,new,string,leader,index,e,if,e,null,fetch,leader,history,uuids,remote,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,else,on,failure,accept,e,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
CcrLicenseChecker -> public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(             final Client client,             final String clusterAlias,             final String leaderIndex,             final Consumer<Exception> onFailure,             final BiConsumer<String[], IndexMetaData> consumer);1549336917;Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster._Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR._If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,_the specified consumer is invoked with the leader index metadata fetched from the remote cluster.__@param client        the client_@param clusterAlias  the remote cluster alias_@param leaderIndex   the name of the leader index_@param onFailure     the failure consumer_@param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards;public void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(_            final Client client,_            final String clusterAlias,_            final String leaderIndex,_            final Consumer<Exception> onFailure,_            final BiConsumer<String[], IndexMetaData> consumer) {__        final ClusterStateRequest request = new ClusterStateRequest()__        request.clear()__        request.metaData(true)__        request.indices(leaderIndex)__        checkRemoteClusterLicenseAndFetchClusterState(_                client,_                clusterAlias,_                client.getRemoteClusterClient(clusterAlias),_                request,_                onFailure,_                remoteClusterStateResponse -> {_                    ClusterState remoteClusterState = remoteClusterStateResponse.getState()__                    IndexMetaData leaderIndexMetaData = remoteClusterState.getMetaData().index(leaderIndex)__                    if (leaderIndexMetaData == null) {_                        onFailure.accept(new IndexNotFoundException(leaderIndex))__                        return__                    }__                    final Client remoteClient = client.getRemoteClusterClient(clusterAlias)__                    hasPrivilegesToFollowIndices(remoteClient, new String[] {leaderIndex}, e -> {_                        if (e == null) {_                            fetchLeaderHistoryUUIDs(remoteClient, leaderIndexMetaData, onFailure, historyUUIDs ->_                                    consumer.accept(historyUUIDs, leaderIndexMetaData))__                        } else {_                            onFailure.accept(e)__                        }_                    })__                },_                licenseCheck -> indexMetadataNonCompliantRemoteLicense(leaderIndex, licenseCheck),_                e -> indexMetadataUnknownRemoteLicense(leaderIndex, clusterAlias, e))__    };fetches,the,leader,index,metadata,and,history,uuids,for,leader,index,shards,from,the,remote,cluster,before,fetching,the,index,metadata,the,remote,cluster,is,checked,for,license,compatibility,with,ccr,if,the,remote,cluster,is,not,licensed,for,ccr,the,code,on,failure,consumer,is,is,invoked,otherwise,the,specified,consumer,is,invoked,with,the,leader,index,metadata,fetched,from,the,remote,cluster,param,client,the,client,param,cluster,alias,the,remote,cluster,alias,param,leader,index,the,name,of,the,leader,index,param,on,failure,the,failure,consumer,param,consumer,the,consumer,for,supplying,the,leader,index,metadata,and,history,uuids,of,all,leader,shards;public,void,check,remote,cluster,license,and,fetch,leader,index,metadata,and,history,uuids,final,client,client,final,string,cluster,alias,final,string,leader,index,final,consumer,exception,on,failure,final,bi,consumer,string,index,meta,data,consumer,final,cluster,state,request,request,new,cluster,state,request,request,clear,request,meta,data,true,request,indices,leader,index,check,remote,cluster,license,and,fetch,cluster,state,client,cluster,alias,client,get,remote,cluster,client,cluster,alias,request,on,failure,remote,cluster,state,response,cluster,state,remote,cluster,state,remote,cluster,state,response,get,state,index,meta,data,leader,index,meta,data,remote,cluster,state,get,meta,data,index,leader,index,if,leader,index,meta,data,null,on,failure,accept,new,index,not,found,exception,leader,index,return,final,client,remote,client,client,get,remote,cluster,client,cluster,alias,has,privileges,to,follow,indices,remote,client,new,string,leader,index,e,if,e,null,fetch,leader,history,uuids,remote,client,leader,index,meta,data,on,failure,history,uuids,consumer,accept,history,uuids,leader,index,meta,data,else,on,failure,accept,e,license,check,index,metadata,non,compliant,remote,license,leader,index,license,check,e,index,metadata,unknown,remote,license,leader,index,cluster,alias,e
