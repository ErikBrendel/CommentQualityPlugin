commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public GetCcrRestoreFileChunkResponse newResponse() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Writeable.Reader<GetCcrRestoreFileChunkResponse> getResponseReader() {     return GetCcrRestoreFileChunkResponse::new. }
false;protected;3;19;;@Override protected void doExecute(Task task, GetCcrRestoreFileChunkRequest request, ActionListener<GetCcrRestoreFileChunkResponse> listener) {     int bytesRequested = request.getSize().     ByteArray array = bigArrays.newByteArray(bytesRequested, false).     String fileName = request.getFileName().     String sessionUUID = request.getSessionUUID().     // structure on the same thread. So the bytes will be copied before the reference is released.     try (ReleasablePagedBytesReference reference = new ReleasablePagedBytesReference(array, bytesRequested, array)) {         try (CcrRestoreSourceService.SessionReader sessionReader = restoreSourceService.getSessionReader(sessionUUID)) {             long offsetAfterRead = sessionReader.readFileBytes(fileName, reference).             long offsetBeforeRead = offsetAfterRead - reference.length().             listener.onResponse(new GetCcrRestoreFileChunkResponse(offsetBeforeRead, reference)).         }     } catch (IOException e) {         listener.onFailure(e).     } }
false;public;0;3;;public long getOffset() {     return offset. }
false;public;0;3;;public BytesReference getChunk() {     return chunk. }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVLong(offset).     out.writeBytesReference(chunk). }
