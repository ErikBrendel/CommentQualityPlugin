commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected AcknowledgedResponse newResponse() {     return new AcknowledgedResponse(). }
false;public;1;5;;@Override public ClusterState execute(final ClusterState current) {     String followerIndex = request.getFollowerIndex().     return unfollow(followerIndex, current). }
false;public;2;4;;@Override public void onFailure(final String source, final Exception e) {     listener.onFailure(e). }
false;public;1;8;;@Override public void onResponse(final Collection<RetentionLeaseActions.Response> responses) {     logger.trace("[{}] removed retention lease [{}] on all leader primary shards", indexMetaData.getIndex(), retentionLeaseId).     listener.onResponse(new AcknowledgedResponse(true)). }
false;public;1;11;;@Override public void onFailure(final Exception e) {     logger.warn(new ParameterizedMessage("[{}] failure while removing retention lease [{}] on leader primary shards", indexMetaData.getIndex(), retentionLeaseId), e).     final ElasticsearchException wrapper = new ElasticsearchException(e).     wrapper.addMetadata("es.failed_to_remove_retention_leases", retentionLeaseId).     listener.onFailure(wrapper). }
false;public;3;61;;@Override public void clusterStateProcessed(final String source, final ClusterState oldState, final ClusterState newState) {     final IndexMetaData indexMetaData = oldState.metaData().index(request.getFollowerIndex()).     final Map<String, String> ccrCustomMetaData = indexMetaData.getCustomData(Ccr.CCR_CUSTOM_METADATA_KEY).     final String remoteClusterName = ccrCustomMetaData.get(Ccr.CCR_CUSTOM_METADATA_REMOTE_CLUSTER_NAME_KEY).     final Client remoteClient = client.getRemoteClusterClient(remoteClusterName).     final String leaderIndexName = ccrCustomMetaData.get(Ccr.CCR_CUSTOM_METADATA_LEADER_INDEX_NAME_KEY).     final String leaderIndexUuid = ccrCustomMetaData.get(Ccr.CCR_CUSTOM_METADATA_LEADER_INDEX_UUID_KEY).     final Index leaderIndex = new Index(leaderIndexName, leaderIndexUuid).     final String retentionLeaseId = CcrRetentionLeases.retentionLeaseId(oldState.getClusterName().value(), indexMetaData.getIndex(), remoteClusterName, leaderIndex).     final int numberOfShards = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(indexMetaData.getSettings()).     final GroupedActionListener<RetentionLeaseActions.Response> groupListener = new GroupedActionListener<>(new ActionListener<Collection<RetentionLeaseActions.Response>>() {          @Override         public void onResponse(final Collection<RetentionLeaseActions.Response> responses) {             logger.trace("[{}] removed retention lease [{}] on all leader primary shards", indexMetaData.getIndex(), retentionLeaseId).             listener.onResponse(new AcknowledgedResponse(true)).         }          @Override         public void onFailure(final Exception e) {             logger.warn(new ParameterizedMessage("[{}] failure while removing retention lease [{}] on leader primary shards", indexMetaData.getIndex(), retentionLeaseId), e).             final ElasticsearchException wrapper = new ElasticsearchException(e).             wrapper.addMetadata("es.failed_to_remove_retention_leases", retentionLeaseId).             listener.onFailure(wrapper).         }     }, numberOfShards, Collections.emptyList()).     for (int i = 0. i < numberOfShards. i++) {         final ShardId followerShardId = new ShardId(indexMetaData.getIndex(), i).         final ShardId leaderShardId = new ShardId(leaderIndex, i).         removeRetentionLeaseForShard(followerShardId, leaderShardId, retentionLeaseId, remoteClient, ActionListener.wrap(groupListener::onResponse, e -> handleException(followerShardId, retentionLeaseId, leaderShardId, groupListener, e))).     } }
false;private;5;14;;private void removeRetentionLeaseForShard(final ShardId followerShardId, final ShardId leaderShardId, final String retentionLeaseId, final Client remoteClient, final ActionListener<RetentionLeaseActions.Response> listener) {     logger.trace("{} removing retention lease [{}] while unfollowing leader index", followerShardId, retentionLeaseId).     final ThreadContext threadContext = threadPool.getThreadContext().     try (ThreadContext.StoredContext ignore = threadPool.getThreadContext().stashContext()) {         // we have to execute under the system context so that if security is enabled the removal is authorized         threadContext.markAsSystemContext().         CcrRetentionLeases.asyncRemoveRetentionLease(leaderShardId, retentionLeaseId, remoteClient, listener).     } }
false;private;5;27;;private void handleException(final ShardId followerShardId, final String retentionLeaseId, final ShardId leaderShardId, final ActionListener<RetentionLeaseActions.Response> listener, final Exception e) {     final Throwable cause = ExceptionsHelper.unwrapCause(e).     assert cause instanceof ElasticsearchSecurityException == false : e.     if (cause instanceof RetentionLeaseNotFoundException) {         // treat as success         logger.trace(new ParameterizedMessage("{} retention lease [{}] not found on {} while unfollowing", followerShardId, retentionLeaseId, leaderShardId), e).         listener.onResponse(new RetentionLeaseActions.Response()).     } else {         logger.warn(new ParameterizedMessage("{} failed to remove retention lease [{}] on {} while unfollowing", followerShardId, retentionLeaseId, leaderShardId), e).         listener.onFailure(e).     } }
false;protected;3;125;;@Override protected void masterOperation(final UnfollowAction.Request request, final ClusterState state, final ActionListener<AcknowledgedResponse> listener) {     clusterService.submitStateUpdateTask("unfollow_action", new ClusterStateUpdateTask() {          @Override         public ClusterState execute(final ClusterState current) {             String followerIndex = request.getFollowerIndex().             return unfollow(followerIndex, current).         }          @Override         public void onFailure(final String source, final Exception e) {             listener.onFailure(e).         }          @Override         public void clusterStateProcessed(final String source, final ClusterState oldState, final ClusterState newState) {             final IndexMetaData indexMetaData = oldState.metaData().index(request.getFollowerIndex()).             final Map<String, String> ccrCustomMetaData = indexMetaData.getCustomData(Ccr.CCR_CUSTOM_METADATA_KEY).             final String remoteClusterName = ccrCustomMetaData.get(Ccr.CCR_CUSTOM_METADATA_REMOTE_CLUSTER_NAME_KEY).             final Client remoteClient = client.getRemoteClusterClient(remoteClusterName).             final String leaderIndexName = ccrCustomMetaData.get(Ccr.CCR_CUSTOM_METADATA_LEADER_INDEX_NAME_KEY).             final String leaderIndexUuid = ccrCustomMetaData.get(Ccr.CCR_CUSTOM_METADATA_LEADER_INDEX_UUID_KEY).             final Index leaderIndex = new Index(leaderIndexName, leaderIndexUuid).             final String retentionLeaseId = CcrRetentionLeases.retentionLeaseId(oldState.getClusterName().value(), indexMetaData.getIndex(), remoteClusterName, leaderIndex).             final int numberOfShards = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(indexMetaData.getSettings()).             final GroupedActionListener<RetentionLeaseActions.Response> groupListener = new GroupedActionListener<>(new ActionListener<Collection<RetentionLeaseActions.Response>>() {                  @Override                 public void onResponse(final Collection<RetentionLeaseActions.Response> responses) {                     logger.trace("[{}] removed retention lease [{}] on all leader primary shards", indexMetaData.getIndex(), retentionLeaseId).                     listener.onResponse(new AcknowledgedResponse(true)).                 }                  @Override                 public void onFailure(final Exception e) {                     logger.warn(new ParameterizedMessage("[{}] failure while removing retention lease [{}] on leader primary shards", indexMetaData.getIndex(), retentionLeaseId), e).                     final ElasticsearchException wrapper = new ElasticsearchException(e).                     wrapper.addMetadata("es.failed_to_remove_retention_leases", retentionLeaseId).                     listener.onFailure(wrapper).                 }             }, numberOfShards, Collections.emptyList()).             for (int i = 0. i < numberOfShards. i++) {                 final ShardId followerShardId = new ShardId(indexMetaData.getIndex(), i).                 final ShardId leaderShardId = new ShardId(leaderIndex, i).                 removeRetentionLeaseForShard(followerShardId, leaderShardId, retentionLeaseId, remoteClient, ActionListener.wrap(groupListener::onResponse, e -> handleException(followerShardId, retentionLeaseId, leaderShardId, groupListener, e))).             }         }          private void removeRetentionLeaseForShard(final ShardId followerShardId, final ShardId leaderShardId, final String retentionLeaseId, final Client remoteClient, final ActionListener<RetentionLeaseActions.Response> listener) {             logger.trace("{} removing retention lease [{}] while unfollowing leader index", followerShardId, retentionLeaseId).             final ThreadContext threadContext = threadPool.getThreadContext().             try (ThreadContext.StoredContext ignore = threadPool.getThreadContext().stashContext()) {                 // we have to execute under the system context so that if security is enabled the removal is authorized                 threadContext.markAsSystemContext().                 CcrRetentionLeases.asyncRemoveRetentionLease(leaderShardId, retentionLeaseId, remoteClient, listener).             }         }          private void handleException(final ShardId followerShardId, final String retentionLeaseId, final ShardId leaderShardId, final ActionListener<RetentionLeaseActions.Response> listener, final Exception e) {             final Throwable cause = ExceptionsHelper.unwrapCause(e).             assert cause instanceof ElasticsearchSecurityException == false : e.             if (cause instanceof RetentionLeaseNotFoundException) {                 // treat as success                 logger.trace(new ParameterizedMessage("{} retention lease [{}] not found on {} while unfollowing", followerShardId, retentionLeaseId, leaderShardId), e).                 listener.onResponse(new RetentionLeaseActions.Response()).             } else {                 logger.warn(new ParameterizedMessage("{} failed to remove retention lease [{}] on {} while unfollowing", followerShardId, retentionLeaseId, leaderShardId), e).                 listener.onFailure(e).             }         }     }). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(UnfollowAction.Request request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
false;static;2;46;;static ClusterState unfollow(String followerIndex, ClusterState current) {     IndexMetaData followerIMD = current.metaData().index(followerIndex).     if (followerIMD == null) {         throw new IndexNotFoundException(followerIndex).     }     if (followerIMD.getCustomData(Ccr.CCR_CUSTOM_METADATA_KEY) == null) {         throw new IllegalArgumentException("index [" + followerIndex + "] is not a follower index").     }     if (followerIMD.getState() != IndexMetaData.State.CLOSE) {         throw new IllegalArgumentException("cannot convert the follower index [" + followerIndex + "] to a non-follower, because it has not been closed").     }     PersistentTasksCustomMetaData persistentTasks = current.metaData().custom(PersistentTasksCustomMetaData.TYPE).     if (persistentTasks != null) {         for (PersistentTasksCustomMetaData.PersistentTask<?> persistentTask : persistentTasks.tasks()) {             if (persistentTask.getTaskName().equals(ShardFollowTask.NAME)) {                 ShardFollowTask shardFollowTask = (ShardFollowTask) persistentTask.getParams().                 if (shardFollowTask.getFollowShardId().getIndexName().equals(followerIndex)) {                     throw new IllegalArgumentException("cannot convert the follower index [" + followerIndex + "] to a non-follower, because it has not been paused").                 }             }         }     }     // Remove index.xpack.ccr.following_index setting     Settings.Builder builder = Settings.builder().     builder.put(followerIMD.getSettings()).     builder.remove(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey()).     final IndexMetaData.Builder newIndexMetaData = IndexMetaData.builder(followerIMD).     newIndexMetaData.settings(builder).     newIndexMetaData.settingsVersion(followerIMD.getSettingsVersion() + 1).     // Remove ccr custom metadata     newIndexMetaData.removeCustom(Ccr.CCR_CUSTOM_METADATA_KEY).     MetaData newMetaData = MetaData.builder(current.metaData()).put(newIndexMetaData).build().     return ClusterState.builder(current).metaData(newMetaData).build(). }
