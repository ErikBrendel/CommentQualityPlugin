commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;9;;private static EngineConfig validateEngineConfig(final EngineConfig engineConfig) {     if (CcrSettings.CCR_FOLLOWING_INDEX_SETTING.get(engineConfig.getIndexSettings().getSettings()) == false) {         throw new IllegalArgumentException("a following engine can not be constructed for a non-following index").     }     if (engineConfig.getIndexSettings().isSoftDeleteEnabled() == false) {         throw new IllegalArgumentException("a following engine requires soft deletes to be enabled").     }     return engineConfig. }
false;private;1;7;;private void preFlight(final Operation operation) {     assert FollowingEngineAssertions.preFlight(operation).     if (operation.seqNo() == SequenceNumbers.UNASSIGNED_SEQ_NO) {         throw new ElasticsearchStatusException("a following engine does not accept operations without an assigned sequence number", RestStatus.FORBIDDEN).     } }
false;protected;1;35;;@Override protected InternalEngine.IndexingStrategy indexingStrategyForOperation(final Index index) throws IOException {     preFlight(index).     markSeqNoAsSeen(index.seqNo()).     // NOTES: refer Engine#getMaxSeqNoOfUpdatesOrDeletes for the explanation of the optimization using sequence numbers.     final long maxSeqNoOfUpdatesOrDeletes = getMaxSeqNoOfUpdatesOrDeletes().     assert maxSeqNoOfUpdatesOrDeletes != SequenceNumbers.UNASSIGNED_SEQ_NO : "max_seq_no_of_updates is not initialized".     if (hasBeenProcessedBefore(index)) {         if (logger.isTraceEnabled()) {             logger.trace("index operation [id={} seq_no={} origin={}] was processed before", index.id(), index.seqNo(), index.origin()).         }         if (index.origin() == Operation.Origin.PRIMARY) {             /*                  * The existing operation in this engine was probably assigned the term of the previous primary shard which is different                  * from the term of the current operation. If the current operation arrives on replicas before the previous operation,                  * then the Lucene content between the primary and replicas are not identical (primary terms are different). We can safely                  * skip the existing operations below the global checkpoint, however must replicate the ones above the global checkpoint                  * but with the previous primary term (not the current term of the operation) in order to guarantee the consistency                  * between the primary and replicas (see TransportBulkShardOperationsAction#shardOperationOnPrimary).                  */             final AlreadyProcessedFollowingEngineException error = new AlreadyProcessedFollowingEngineException(shardId, index.seqNo(), lookupPrimaryTerm(index.seqNo())).             return IndexingStrategy.skipDueToVersionConflict(error, false, index.version(), index.primaryTerm()).         } else {             return IndexingStrategy.processButSkipLucene(false, index.seqNo(), index.version()).         }     } else if (maxSeqNoOfUpdatesOrDeletes <= getLocalCheckpoint()) {         assert maxSeqNoOfUpdatesOrDeletes < index.seqNo() : "seq_no[" + index.seqNo() + "] <= msu[" + maxSeqNoOfUpdatesOrDeletes + "]".         numOfOptimizedIndexing.inc().         return InternalEngine.IndexingStrategy.optimizedAppendOnly(index.seqNo(), index.version()).     } else {         return planIndexingAsNonPrimary(index).     } }
false;protected;1;13;;@Override protected InternalEngine.DeletionStrategy deletionStrategyForOperation(final Delete delete) throws IOException {     preFlight(delete).     markSeqNoAsSeen(delete.seqNo()).     if (delete.origin() == Operation.Origin.PRIMARY && hasBeenProcessedBefore(delete)) {         // See the comment in #indexingStrategyForOperation for the explanation why we can safely skip this operation.         final AlreadyProcessedFollowingEngineException error = new AlreadyProcessedFollowingEngineException(shardId, delete.seqNo(), lookupPrimaryTerm(delete.seqNo())).         return DeletionStrategy.skipDueToVersionConflict(error, delete.version(), delete.primaryTerm(), false).     } else {         return planDeletionAsNonPrimary(delete).     } }
false;protected;1;10;;@Override protected Optional<Exception> preFlightCheckForNoOp(NoOp noOp) throws IOException {     if (noOp.origin() == Operation.Origin.PRIMARY && hasBeenProcessedBefore(noOp)) {         // See the comment in #indexingStrategyForOperation for the explanation why we can safely skip this operation.         final OptionalLong existingTerm = lookupPrimaryTerm(noOp.seqNo()).         return Optional.of(new AlreadyProcessedFollowingEngineException(shardId, noOp.seqNo(), existingTerm)).     } else {         return super.preFlightCheckForNoOp(noOp).     } }
false;public;1;5;;@Override public int fillSeqNoGaps(long primaryTerm) throws IOException {     // a noop implementation, because follow shard does not own the history but the leader shard does.     return 0. }
false;protected;2;5;;@Override protected boolean assertPrimaryIncomingSequenceNumber(final Operation.Origin origin, final long seqNo) {     assert FollowingEngineAssertions.assertPrimaryIncomingSequenceNumber(origin, seqNo).     return true. }
false;protected;1;4;;@Override protected boolean assertNonPrimaryOrigin(final Operation operation) {     return true. }
false;protected;1;6;;@Override protected boolean assertPrimaryCanOptimizeAddDocument(final Index index) {     assert index.version() == 1 && index.versionType() == VersionType.EXTERNAL : "version [" + index.version() + "], type [" + index.versionType() + "]".     return true. }
false;private;1;40;;private OptionalLong lookupPrimaryTerm(final long seqNo) throws IOException {     // Don't need to look up term for operations before the global checkpoint for they were processed on every copies already.     if (seqNo <= engineConfig.getGlobalCheckpointSupplier().getAsLong()) {         return OptionalLong.empty().     }     refreshIfNeeded("lookup_primary_term", seqNo).     try (Searcher engineSearcher = acquireSearcher("lookup_primary_term", SearcherScope.INTERNAL)) {         final DirectoryReader reader = Lucene.wrapAllDocsLive(engineSearcher.getDirectoryReader()).         final IndexSearcher searcher = new IndexSearcher(reader).         searcher.setQueryCache(null).         final Query query = new BooleanQuery.Builder().add(LongPoint.newExactQuery(SeqNoFieldMapper.NAME, seqNo), BooleanClause.Occur.FILTER).add(new DocValuesFieldExistsQuery(SeqNoFieldMapper.PRIMARY_TERM_NAME), BooleanClause.Occur.FILTER).build().         final TopDocs topDocs = searcher.search(query, 1).         if (topDocs.scoreDocs.length == 1) {             final int docId = topDocs.scoreDocs[0].doc.             final LeafReaderContext leaf = reader.leaves().get(ReaderUtil.subIndex(docId, reader.leaves())).             final NumericDocValues primaryTermDV = leaf.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME).             if (primaryTermDV != null && primaryTermDV.advanceExact(docId - leaf.docBase)) {                 assert primaryTermDV.longValue() > 0 : "invalid term [" + primaryTermDV.longValue() + "]".                 return OptionalLong.of(primaryTermDV.longValue()).             }         }         if (seqNo <= engineConfig.getGlobalCheckpointSupplier().getAsLong()) {             // we have merged away the looking up operation.             return OptionalLong.empty().         } else {             assert false : "seq_no[" + seqNo + "] does not have primary_term, total_hits=[" + topDocs.totalHits + "]".             throw new IllegalStateException("seq_no[" + seqNo + "] does not have primary_term (total_hits=" + topDocs.totalHits + ")").         }     } catch (IOException e) {         try {             maybeFailEngine("lookup_primary_term", e).         } catch (Exception inner) {             e.addSuppressed(inner).         }         throw e.     } }
true;public;0;3;/**  * Returns the number of indexing operations that have been optimized (bypass version lookup) using sequence numbers in this engine.  * This metric is not persisted, and started from 0 when the engine is opened.  */ ;/**  * Returns the number of indexing operations that have been optimized (bypass version lookup) using sequence numbers in this engine.  * This metric is not persisted, and started from 0 when the engine is opened.  */ public long getNumberOfOptimizedIndexing() {     return numOfOptimizedIndexing.count(). }
false;public;0;7;;@Override public void verifyEngineBeforeIndexClosing() throws IllegalStateException { // the value of the global checkpoint is not verified when the following engine is closed, // allowing it to be closed even in the case where all operations have not been fetched and // processed from the leader and the operations history has gaps. This way the following // engine can be closed and reopened in order to bootstrap the follower index again. }
