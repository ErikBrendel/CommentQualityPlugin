commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected boolean removeEldestEntry(final Map.Entry<String, Tuple<Long, ElasticsearchException>> eldest) {     return size() > MAX_AUTO_FOLLOW_ERRORS. }
false;public,synchronized;0;23;;public synchronized AutoFollowStats getStats() {     final Map<String, AutoFollower> autoFollowers = this.autoFollowers.     final TreeMap<String, AutoFollowedCluster> timesSinceLastAutoFollowPerRemoteCluster = new TreeMap<>().     for (Map.Entry<String, AutoFollower> entry : autoFollowers.entrySet()) {         long lastAutoFollowTimeInMillis = entry.getValue().lastAutoFollowTimeInMillis.         long lastSeenMetadataVersion = entry.getValue().metadataVersion.         if (lastAutoFollowTimeInMillis != -1) {             long timeSinceLastCheckInMillis = relativeMillisTimeProvider.getAsLong() - lastAutoFollowTimeInMillis.             timesSinceLastAutoFollowPerRemoteCluster.put(entry.getKey(), new AutoFollowedCluster(timeSinceLastCheckInMillis, lastSeenMetadataVersion)).         } else {             timesSinceLastAutoFollowPerRemoteCluster.put(entry.getKey(), new AutoFollowedCluster(-1L, lastSeenMetadataVersion)).         }     }     return new AutoFollowStats(numberOfFailedIndicesAutoFollowed, numberOfFailedRemoteClusterStateRequests, numberOfSuccessfulIndicesAutoFollowed, new TreeMap<>(recentAutoFollowErrors), timesSinceLastAutoFollowPerRemoteCluster). }
false;synchronized;1;25;;synchronized void updateStats(List<AutoFollowResult> results) {     long newStatsReceivedTimeStamp = absoluteMillisTimeProvider.getAsLong().     for (AutoFollowResult result : results) {         if (result.clusterStateFetchException != null) {             recentAutoFollowErrors.put(result.autoFollowPatternName, Tuple.tuple(newStatsReceivedTimeStamp, new ElasticsearchException(result.clusterStateFetchException))).             numberOfFailedRemoteClusterStateRequests++.             LOGGER.warn(new ParameterizedMessage("failure occurred while fetching cluster state for auto follow pattern [{}]", result.autoFollowPatternName), result.clusterStateFetchException).         } else {             for (Map.Entry<Index, Exception> entry : result.autoFollowExecutionResults.entrySet()) {                 if (entry.getValue() != null) {                     numberOfFailedIndicesAutoFollowed++.                     recentAutoFollowErrors.put(result.autoFollowPatternName + ":" + entry.getKey().getName(), Tuple.tuple(newStatsReceivedTimeStamp, ExceptionsHelper.convertToElastic(entry.getValue()))).                     LOGGER.warn(new ParameterizedMessage("failure occurred while auto following index [{}] for auto follow " + "pattern [{}]", entry.getKey(), result.autoFollowPatternName), entry.getValue()).                 } else {                     numberOfSuccessfulIndicesAutoFollowed++.                 }             }         }     } }
false;;3;18;;@Override void getRemoteClusterState(final String remoteCluster, final long metadataVersion, final BiConsumer<ClusterStateResponse, Exception> handler) {     final ClusterStateRequest request = new ClusterStateRequest().     request.clear().     request.metaData(true).     request.routingTable(true).     request.waitForMetaDataVersion(metadataVersion).     request.waitForTimeout(waitForMetadataTimeOut).     // TODO: set non-compliant status on auto-follow coordination that can be viewed via a stats API     ccrLicenseChecker.checkRemoteClusterLicenseAndFetchClusterState(client, remoteCluster, request, e -> handler.accept(null, e), remoteClusterStateResponse -> handler.accept(remoteClusterStateResponse, null)). }
false;;4;12;;@Override void createAndFollow(Map<String, String> headers, PutFollowAction.Request request, Runnable successHandler, Consumer<Exception> failureHandler) {     Client followerClient = CcrLicenseChecker.wrapClient(client, headers).     followerClient.execute(PutFollowAction.INSTANCE, request, ActionListener.wrap(r -> successHandler.run(), failureHandler)). }
false;public;1;4;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     return updateFunction.apply(currentState). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     handler.accept(e). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     handler.accept(null). }
false;;2;21;;@Override void updateAutoFollowMetadata(Function<ClusterState, ClusterState> updateFunction, Consumer<Exception> handler) {     clusterService.submitStateUpdateTask("update_auto_follow_metadata", new ClusterStateUpdateTask() {          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             return updateFunction.apply(currentState).         }          @Override         public void onFailure(String source, Exception e) {             handler.accept(e).         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             handler.accept(null).         }     }). }
false;;1;104;;void updateAutoFollowers(ClusterState followerClusterState) {     AutoFollowMetadata autoFollowMetadata = followerClusterState.getMetaData().custom(AutoFollowMetadata.TYPE).     if (autoFollowMetadata == null) {         return.     }     if (ccrLicenseChecker.isCcrAllowed() == false) {         // TODO: set non-compliant status on auto-follow coordination that can be viewed via a stats API         LOGGER.warn("skipping auto-follower coordination", LicenseUtils.newComplianceException("ccr")).         return.     }     final CopyOnWriteHashMap<String, AutoFollower> autoFollowers = CopyOnWriteHashMap.copyOf(this.autoFollowers).     Set<String> newRemoteClusters = autoFollowMetadata.getPatterns().entrySet().stream().map(entry -> entry.getValue().getRemoteCluster()).filter(remoteCluster -> autoFollowers.containsKey(remoteCluster) == false).collect(Collectors.toSet()).     Map<String, AutoFollower> newAutoFollowers = new HashMap<>(newRemoteClusters.size()).     for (String remoteCluster : newRemoteClusters) {         AutoFollower autoFollower = new AutoFollower(remoteCluster, this::updateStats, clusterService::state, relativeMillisTimeProvider) {              @Override             void getRemoteClusterState(final String remoteCluster, final long metadataVersion, final BiConsumer<ClusterStateResponse, Exception> handler) {                 final ClusterStateRequest request = new ClusterStateRequest().                 request.clear().                 request.metaData(true).                 request.routingTable(true).                 request.waitForMetaDataVersion(metadataVersion).                 request.waitForTimeout(waitForMetadataTimeOut).                 // TODO: set non-compliant status on auto-follow coordination that can be viewed via a stats API                 ccrLicenseChecker.checkRemoteClusterLicenseAndFetchClusterState(client, remoteCluster, request, e -> handler.accept(null, e), remoteClusterStateResponse -> handler.accept(remoteClusterStateResponse, null)).             }              @Override             void createAndFollow(Map<String, String> headers, PutFollowAction.Request request, Runnable successHandler, Consumer<Exception> failureHandler) {                 Client followerClient = CcrLicenseChecker.wrapClient(client, headers).                 followerClient.execute(PutFollowAction.INSTANCE, request, ActionListener.wrap(r -> successHandler.run(), failureHandler)).             }              @Override             void updateAutoFollowMetadata(Function<ClusterState, ClusterState> updateFunction, Consumer<Exception> handler) {                 clusterService.submitStateUpdateTask("update_auto_follow_metadata", new ClusterStateUpdateTask() {                      @Override                     public ClusterState execute(ClusterState currentState) throws Exception {                         return updateFunction.apply(currentState).                     }                      @Override                     public void onFailure(String source, Exception e) {                         handler.accept(e).                     }                      @Override                     public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {                         handler.accept(null).                     }                 }).             }         }.         newAutoFollowers.put(remoteCluster, autoFollower).         LOGGER.info("starting auto follower for remote cluster [{}]", remoteCluster).         autoFollower.start().     }     List<String> removedRemoteClusters = new ArrayList<>().     for (Map.Entry<String, AutoFollower> entry : autoFollowers.entrySet()) {         String remoteCluster = entry.getKey().         AutoFollower autoFollower = entry.getValue().         boolean exist = autoFollowMetadata.getPatterns().values().stream().anyMatch(pattern -> pattern.getRemoteCluster().equals(remoteCluster)).         if (exist == false) {             LOGGER.info("removing auto follower for remote cluster [{}]", remoteCluster).             autoFollower.removed = true.             removedRemoteClusters.add(remoteCluster).         } else if (autoFollower.remoteClusterConnectionMissing) {             LOGGER.info("retrying auto follower [{}] after remote cluster connection was missing", remoteCluster).             autoFollower.remoteClusterConnectionMissing = false.             autoFollower.start().         }     }     assert assertNoOtherActiveAutoFollower(newAutoFollowers).     this.autoFollowers = autoFollowers.copyAndPutAll(newAutoFollowers).copyAndRemoveAll(removedRemoteClusters). }
false;private;1;7;;private boolean assertNoOtherActiveAutoFollower(Map<String, AutoFollower> newAutoFollowers) {     for (AutoFollower newAutoFollower : newAutoFollowers.values()) {         AutoFollower previousInstance = autoFollowers.get(newAutoFollower.remoteCluster).         assert previousInstance == null || previousInstance.removed.     }     return true. }
false;;0;3;;Map<String, AutoFollower> getAutoFollowers() {     return autoFollowers. }
false;public;1;6;;@Override public void clusterChanged(ClusterChangedEvent event) {     if (event.localNodeMaster()) {         updateAutoFollowers(event.state()).     } }
false;;0;63;;void start() {     if (removed) {         // This check exists to avoid two AutoFollower instances a single remote cluster.         // (If an auto follow pattern is deleted and then added back quickly enough then         // the old AutoFollower instance still sees that there is an auto follow pattern         // for the remote cluster it is tracking and will continue to operate, while in         // the meantime in updateAutoFollowers() method another AutoFollower instance has been         // started for the same remote cluster.)         LOGGER.info("AutoFollower instance for cluster [{}] has been removed", remoteCluster).         return.     }     lastAutoFollowTimeInMillis = relativeTimeProvider.getAsLong().     final ClusterState clusterState = followerClusterStateSupplier.get().     final AutoFollowMetadata autoFollowMetadata = clusterState.metaData().custom(AutoFollowMetadata.TYPE).     if (autoFollowMetadata == null) {         LOGGER.info("AutoFollower for cluster [{}] has stopped, because there is no autofollow metadata", remoteCluster).         return.     }     final List<String> patterns = autoFollowMetadata.getPatterns().entrySet().stream().filter(entry -> entry.getValue().getRemoteCluster().equals(remoteCluster)).map(Map.Entry::getKey).collect(Collectors.toList()).     if (patterns.isEmpty()) {         LOGGER.info("AutoFollower for cluster [{}] has stopped, because there are no more patterns", remoteCluster).         return.     }     this.autoFollowPatternsCountDown = new CountDown(patterns.size()).     this.autoFollowResults = new AtomicArray<>(patterns.size()).     getRemoteClusterState(remoteCluster, metadataVersion + 1, (remoteClusterStateResponse, remoteError) -> {         // Also check removed flag here, as it may take a while for this remote cluster state api call to return:         if (removed) {             LOGGER.info("AutoFollower instance for cluster [{}] has been removed", remoteCluster).             return.         }         if (remoteClusterStateResponse != null) {             assert remoteError == null.             if (remoteClusterStateResponse.isWaitForTimedOut()) {                 start().                 return.             }             ClusterState remoteClusterState = remoteClusterStateResponse.getState().             metadataVersion = remoteClusterState.metaData().version().             autoFollowIndices(autoFollowMetadata, clusterState, remoteClusterState, patterns).         } else {             assert remoteError != null.             if (remoteError instanceof NoSuchRemoteClusterException) {                 LOGGER.info("AutoFollower for cluster [{}] has stopped, because remote connection is gone", remoteCluster).                 remoteClusterConnectionMissing = true.                 return.             }             for (int i = 0. i < patterns.size(). i++) {                 String autoFollowPatternName = patterns.get(i).                 finalise(i, new AutoFollowResult(autoFollowPatternName, remoteError)).             }         }     }). }
false;private;4;31;;private void autoFollowIndices(final AutoFollowMetadata autoFollowMetadata, final ClusterState clusterState, final ClusterState remoteClusterState, final List<String> patterns) {     int i = 0.     for (String autoFollowPatternName : patterns) {         final int slot = i.         AutoFollowPattern autoFollowPattern = autoFollowMetadata.getPatterns().get(autoFollowPatternName).         Map<String, String> headers = autoFollowMetadata.getHeaders().get(autoFollowPatternName).         List<String> followedIndices = autoFollowMetadata.getFollowedLeaderIndexUUIDs().get(autoFollowPatternName).         final List<Index> leaderIndicesToFollow = getLeaderIndicesToFollow(autoFollowPattern, remoteClusterState, followedIndices).         if (leaderIndicesToFollow.isEmpty()) {             finalise(slot, new AutoFollowResult(autoFollowPatternName)).         } else {             List<Tuple<String, AutoFollowPattern>> patternsForTheSameRemoteCluster = autoFollowMetadata.getPatterns().entrySet().stream().filter(item -> autoFollowPatternName.equals(item.getKey()) == false).filter(item -> remoteCluster.equals(item.getValue().getRemoteCluster())).map(item -> new Tuple<>(item.getKey(), item.getValue())).collect(Collectors.toList()).             Consumer<AutoFollowResult> resultHandler = result -> finalise(slot, result).             checkAutoFollowPattern(autoFollowPatternName, remoteCluster, autoFollowPattern, leaderIndicesToFollow, headers, patternsForTheSameRemoteCluster, remoteClusterState.metaData(), clusterState.metaData(), resultHandler).         }         i++.     }     cleanFollowedRemoteIndices(remoteClusterState, patterns). }
false;private;9;62;;private void checkAutoFollowPattern(String autoFollowPattenName, String remoteCluster, AutoFollowPattern autoFollowPattern, List<Index> leaderIndicesToFollow, Map<String, String> headers, List<Tuple<String, AutoFollowPattern>> patternsForTheSameRemoteCluster, MetaData remoteMetadata, MetaData localMetadata, Consumer<AutoFollowResult> resultHandler) {     final CountDown leaderIndicesCountDown = new CountDown(leaderIndicesToFollow.size()).     final AtomicArray<Tuple<Index, Exception>> results = new AtomicArray<>(leaderIndicesToFollow.size()).     for (int i = 0. i < leaderIndicesToFollow.size(). i++) {         final Index indexToFollow = leaderIndicesToFollow.get(i).         final int slot = i.         List<String> otherMatchingPatterns = patternsForTheSameRemoteCluster.stream().filter(otherPattern -> otherPattern.v2().match(indexToFollow.getName())).map(Tuple::v1).collect(Collectors.toList()).         if (otherMatchingPatterns.size() != 0) {             results.set(slot, new Tuple<>(indexToFollow, new ElasticsearchException("index to follow [" + indexToFollow.getName() + "] for pattern [" + autoFollowPattenName + "] matches with other patterns " + otherMatchingPatterns + ""))).             if (leaderIndicesCountDown.countDown()) {                 resultHandler.accept(new AutoFollowResult(autoFollowPattenName, results.asList())).             }         } else {             final Settings leaderIndexSettings = remoteMetadata.getIndexSafe(indexToFollow).getSettings().             if (IndexSettings.INDEX_SOFT_DELETES_SETTING.get(leaderIndexSettings) == false) {                 String message = String.format(Locale.ROOT, "index [%s] cannot be followed, because soft deletes are not enabled", indexToFollow.getName()).                 LOGGER.warn(message).                 updateAutoFollowMetadata(recordLeaderIndexAsFollowFunction(autoFollowPattenName, indexToFollow), error -> {                     ElasticsearchException failure = new ElasticsearchException(message).                     if (error != null) {                         failure.addSuppressed(error).                     }                     results.set(slot, new Tuple<>(indexToFollow, failure)).                     if (leaderIndicesCountDown.countDown()) {                         resultHandler.accept(new AutoFollowResult(autoFollowPattenName, results.asList())).                     }                 }).                 continue.             } else if (leaderIndexAlreadyFollowed(autoFollowPattern, indexToFollow, localMetadata)) {                 updateAutoFollowMetadata(recordLeaderIndexAsFollowFunction(autoFollowPattenName, indexToFollow), error -> {                     results.set(slot, new Tuple<>(indexToFollow, error)).                     if (leaderIndicesCountDown.countDown()) {                         resultHandler.accept(new AutoFollowResult(autoFollowPattenName, results.asList())).                     }                 }).                 continue.             }             followLeaderIndex(autoFollowPattenName, remoteCluster, indexToFollow, autoFollowPattern, headers, error -> {                 results.set(slot, new Tuple<>(indexToFollow, error)).                 if (leaderIndicesCountDown.countDown()) {                     resultHandler.accept(new AutoFollowResult(autoFollowPattenName, results.asList())).                 }             }).         }     } }
false;private,static;3;18;;private static boolean leaderIndexAlreadyFollowed(AutoFollowPattern autoFollowPattern, Index leaderIndex, MetaData localMetadata) {     String followIndexName = getFollowerIndexName(autoFollowPattern, leaderIndex.getName()).     IndexMetaData indexMetaData = localMetadata.index(followIndexName).     if (indexMetaData != null) {         // If an index with the same name exists, but it is not a follow index for this leader index then         // we should let the auto follower attempt to auto follow it, so it can fail later and         // it is then visible in the auto follow stats. For example a cluster can just happen to have         // an index with the same name as the new follower index.         Map<String, String> customData = indexMetaData.getCustomData(Ccr.CCR_CUSTOM_METADATA_KEY).         if (customData != null) {             String recordedLeaderIndexUUID = customData.get(Ccr.CCR_CUSTOM_METADATA_LEADER_INDEX_UUID_KEY).             return leaderIndex.getUUID().equals(recordedLeaderIndexUUID).         }     }     return false. }
false;private;6;36;;private void followLeaderIndex(String autoFollowPattenName, String remoteCluster, Index indexToFollow, AutoFollowPattern pattern, Map<String, String> headers, Consumer<Exception> onResult) {     final String leaderIndexName = indexToFollow.getName().     final String followIndexName = getFollowerIndexName(pattern, leaderIndexName).     PutFollowAction.Request request = new PutFollowAction.Request().     request.setRemoteCluster(remoteCluster).     request.setLeaderIndex(indexToFollow.getName()).     request.setFollowerIndex(followIndexName).     request.getParameters().setMaxReadRequestOperationCount(pattern.getMaxReadRequestOperationCount()).     request.getParameters().setMaxReadRequestSize(pattern.getMaxReadRequestSize()).     request.getParameters().setMaxOutstandingReadRequests(pattern.getMaxOutstandingReadRequests()).     request.getParameters().setMaxWriteRequestOperationCount(pattern.getMaxWriteRequestOperationCount()).     request.getParameters().setMaxWriteRequestSize(pattern.getMaxWriteRequestSize()).     request.getParameters().setMaxOutstandingWriteRequests(pattern.getMaxOutstandingWriteRequests()).     request.getParameters().setMaxWriteBufferCount(pattern.getMaxWriteBufferCount()).     request.getParameters().setMaxWriteBufferSize(pattern.getMaxWriteBufferSize()).     request.getParameters().setMaxRetryDelay(pattern.getMaxRetryDelay()).     request.getParameters().setReadPollTimeout(pattern.getReadPollTimeout()).     // Execute if the create and follow api call succeeds:     Runnable successHandler = () -> {         LOGGER.info("Auto followed leader index [{}] as follow index [{}]", leaderIndexName, followIndexName).         // This function updates the auto follow metadata in the cluster to record that the leader index has been followed:         // (so that we do not try to follow it in subsequent auto follow runs)         Function<ClusterState, ClusterState> function = recordLeaderIndexAsFollowFunction(autoFollowPattenName, indexToFollow).         // The coordinator always runs on the elected master node, so we can update cluster state here:         updateAutoFollowMetadata(function, onResult).     }.     createAndFollow(headers, request, successHandler, onResult). }
false;private;2;8;;private void finalise(int slot, AutoFollowResult result) {     assert autoFollowResults.get(slot) == null.     autoFollowResults.set(slot, result).     if (autoFollowPatternsCountDown.countDown()) {         statsUpdater.accept(autoFollowResults.asList()).         start().     } }
false;static;3;21;;static List<Index> getLeaderIndicesToFollow(AutoFollowPattern autoFollowPattern, ClusterState remoteClusterState, List<String> followedIndexUUIDs) {     List<Index> leaderIndicesToFollow = new ArrayList<>().     for (IndexMetaData leaderIndexMetaData : remoteClusterState.getMetaData()) {         if (autoFollowPattern.match(leaderIndexMetaData.getIndex().getName())) {             IndexRoutingTable indexRoutingTable = remoteClusterState.routingTable().index(leaderIndexMetaData.getIndex()).             if (indexRoutingTable != null && // this index will be auto followed.             indexRoutingTable.allPrimaryShardsActive() && followedIndexUUIDs.contains(leaderIndexMetaData.getIndex().getUUID()) == false) {                 leaderIndicesToFollow.add(leaderIndexMetaData.getIndex()).             }         }     }     return leaderIndicesToFollow. }
false;static;2;7;;static String getFollowerIndexName(AutoFollowPattern autoFollowPattern, String leaderIndexName) {     if (autoFollowPattern.getFollowIndexPattern() != null) {         return autoFollowPattern.getFollowIndexPattern().replace("{{leader_index}}", leaderIndexName).     } else {         return leaderIndexName.     } }
false;static;2;26;;static Function<ClusterState, ClusterState> recordLeaderIndexAsFollowFunction(String name, Index indexToFollow) {     return currentState -> {         AutoFollowMetadata currentAutoFollowMetadata = currentState.metaData().custom(AutoFollowMetadata.TYPE).         Map<String, List<String>> newFollowedIndexUUIDS = new HashMap<>(currentAutoFollowMetadata.getFollowedLeaderIndexUUIDs()).         if (newFollowedIndexUUIDS.containsKey(name) == false) {             // happens, we can just skip this step.             return currentState.         }         newFollowedIndexUUIDS.compute(name, (key, existingUUIDs) -> {             assert existingUUIDs != null.             List<String> newUUIDs = new ArrayList<>(existingUUIDs).             newUUIDs.add(indexToFollow.getUUID()).             return Collections.unmodifiableList(newUUIDs).         }).         final AutoFollowMetadata newAutoFollowMetadata = new AutoFollowMetadata(currentAutoFollowMetadata.getPatterns(), newFollowedIndexUUIDS, currentAutoFollowMetadata.getHeaders()).         return ClusterState.builder(currentState).metaData(MetaData.builder(currentState.getMetaData()).putCustom(AutoFollowMetadata.TYPE, newAutoFollowMetadata).build()).build().     }. }
false;;2;7;;void cleanFollowedRemoteIndices(final ClusterState remoteClusterState, final List<String> patterns) {     updateAutoFollowMetadata(cleanFollowedRemoteIndices(remoteClusterState.metaData(), patterns), e -> {         if (e != null) {             LOGGER.warn("Error occured while cleaning followed leader indices", e).         }     }). }
false;static;2;42;;static Function<ClusterState, ClusterState> cleanFollowedRemoteIndices(final MetaData remoteMetadata, final List<String> autoFollowPatternNames) {     return currentState -> {         AutoFollowMetadata currentAutoFollowMetadata = currentState.metaData().custom(AutoFollowMetadata.TYPE).         Map<String, List<String>> autoFollowPatternNameToFollowedIndexUUIDs = new HashMap<>(currentAutoFollowMetadata.getFollowedLeaderIndexUUIDs()).         Set<String> remoteIndexUUIDS = new HashSet<>().         remoteMetadata.getIndices().values().forEach((ObjectPredicate<IndexMetaData>) value -> remoteIndexUUIDS.add(value.getIndexUUID())).         boolean requiresCSUpdate = false.         for (String autoFollowPatternName : autoFollowPatternNames) {             if (autoFollowPatternNameToFollowedIndexUUIDs.containsKey(autoFollowPatternName) == false) {                 // happens, we can just skip this step.                 continue.             }             List<String> followedIndexUUIDs = new ArrayList<>(autoFollowPatternNameToFollowedIndexUUIDs.get(autoFollowPatternName)).             // Remove leader indices that no longer exist in the remote cluster:             boolean entriesRemoved = followedIndexUUIDs.removeIf(followedLeaderIndexUUID -> remoteIndexUUIDS.contains(followedLeaderIndexUUID) == false).             if (entriesRemoved) {                 requiresCSUpdate = true.             }             autoFollowPatternNameToFollowedIndexUUIDs.put(autoFollowPatternName, followedIndexUUIDs).         }         if (requiresCSUpdate) {             final AutoFollowMetadata newAutoFollowMetadata = new AutoFollowMetadata(currentAutoFollowMetadata.getPatterns(), autoFollowPatternNameToFollowedIndexUUIDs, currentAutoFollowMetadata.getHeaders()).             return ClusterState.builder(currentState).metaData(MetaData.builder(currentState.getMetaData()).putCustom(AutoFollowMetadata.TYPE, newAutoFollowMetadata).build()).build().         } else {             return currentState.         }     }. }
true;abstract;3;5;/**  * Fetch a remote cluster state from with the specified cluster alias  * @param remoteCluster      the name of the leader cluster  * @param metadataVersion   the last seen metadata version  * @param handler            the callback to invoke  */ ;/**  * Fetch a remote cluster state from with the specified cluster alias  * @param remoteCluster      the name of the leader cluster  * @param metadataVersion   the last seen metadata version  * @param handler            the callback to invoke  */ abstract void getRemoteClusterState(String remoteCluster, long metadataVersion, BiConsumer<ClusterStateResponse, Exception> handler).
false;abstract;4;6;;abstract void createAndFollow(Map<String, String> headers, PutFollowAction.Request followRequest, Runnable successHandler, Consumer<Exception> failureHandler).
false;abstract;2;4;;abstract void updateAutoFollowMetadata(Function<ClusterState, ClusterState> updateFunction, Consumer<Exception> handler).
