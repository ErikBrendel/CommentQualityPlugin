commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected AcknowledgedResponse newResponse() {     return new AcknowledgedResponse(). }
false;protected;1;4;;@Override protected AcknowledgedResponse newResponse(boolean acknowledged) {     return new AcknowledgedResponse(acknowledged). }
false;public;1;4;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     return innerPut(request, filteredHeaders, currentState, remoteClusterState.getState()). }
false;protected;3;44;;@Override protected void masterOperation(PutAutoFollowPatternAction.Request request, ClusterState state, ActionListener<AcknowledgedResponse> listener) throws Exception {     if (ccrLicenseChecker.isCcrAllowed() == false) {         listener.onFailure(LicenseUtils.newComplianceException("ccr")).         return.     }     final Client remoteClient = client.getRemoteClusterClient(request.getRemoteCluster()).     final Map<String, String> filteredHeaders = threadPool.getThreadContext().getHeaders().entrySet().stream().filter(e -> ShardFollowTask.HEADER_FILTERS.contains(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).     Consumer<ClusterStateResponse> consumer = remoteClusterState -> {         String[] indices = request.getLeaderIndexPatterns().toArray(new String[0]).         ccrLicenseChecker.hasPrivilegesToFollowIndices(remoteClient, indices, e -> {             if (e == null) {                 clusterService.submitStateUpdateTask("put-auto-follow-pattern-" + request.getRemoteCluster(), new AckedClusterStateUpdateTask<AcknowledgedResponse>(request, listener) {                      @Override                     protected AcknowledgedResponse newResponse(boolean acknowledged) {                         return new AcknowledgedResponse(acknowledged).                     }                      @Override                     public ClusterState execute(ClusterState currentState) throws Exception {                         return innerPut(request, filteredHeaders, currentState, remoteClusterState.getState()).                     }                 }).             } else {                 listener.onFailure(e).             }         }).     }.     final ClusterStateRequest clusterStateRequest = new ClusterStateRequest().     clusterStateRequest.clear().     clusterStateRequest.metaData(true).     ccrLicenseChecker.checkRemoteClusterLicenseAndFetchClusterState(client, request.getRemoteCluster(), clusterStateRequest, listener::onFailure, consumer). }
false;static;4;62;;static ClusterState innerPut(PutAutoFollowPatternAction.Request request, Map<String, String> filteredHeaders, ClusterState localState, ClusterState remoteClusterState) {     // auto patterns are always overwritten     // only already followed index uuids are updated     AutoFollowMetadata currentAutoFollowMetadata = localState.metaData().custom(AutoFollowMetadata.TYPE).     Map<String, List<String>> followedLeaderIndices.     Map<String, AutoFollowPattern> patterns.     Map<String, Map<String, String>> headers.     if (currentAutoFollowMetadata != null) {         patterns = new HashMap<>(currentAutoFollowMetadata.getPatterns()).         followedLeaderIndices = new HashMap<>(currentAutoFollowMetadata.getFollowedLeaderIndexUUIDs()).         headers = new HashMap<>(currentAutoFollowMetadata.getHeaders()).     } else {         patterns = new HashMap<>().         followedLeaderIndices = new HashMap<>().         headers = new HashMap<>().     }     AutoFollowPattern previousPattern = patterns.get(request.getName()).     final List<String> followedIndexUUIDs.     if (followedLeaderIndices.containsKey(request.getName())) {         followedIndexUUIDs = new ArrayList<>(followedLeaderIndices.get(request.getName())).     } else {         followedIndexUUIDs = new ArrayList<>().     }     followedLeaderIndices.put(request.getName(), followedIndexUUIDs).     // Mark existing leader indices as already auto followed:     if (previousPattern != null) {         markExistingIndicesAsAutoFollowedForNewPatterns(request.getLeaderIndexPatterns(), remoteClusterState.metaData(), previousPattern, followedIndexUUIDs).     } else {         markExistingIndicesAsAutoFollowed(request.getLeaderIndexPatterns(), remoteClusterState.metaData(), followedIndexUUIDs).     }     if (filteredHeaders != null) {         headers.put(request.getName(), filteredHeaders).     }     AutoFollowPattern autoFollowPattern = new AutoFollowPattern(request.getRemoteCluster(), request.getLeaderIndexPatterns(), request.getFollowIndexNamePattern(), request.getParameters().getMaxReadRequestOperationCount(), request.getParameters().getMaxWriteRequestOperationCount(), request.getParameters().getMaxOutstandingReadRequests(), request.getParameters().getMaxOutstandingWriteRequests(), request.getParameters().getMaxReadRequestSize(), request.getParameters().getMaxWriteRequestSize(), request.getParameters().getMaxWriteBufferCount(), request.getParameters().getMaxWriteBufferSize(), request.getParameters().getMaxRetryDelay(), request.getParameters().getReadPollTimeout()).     patterns.put(request.getName(), autoFollowPattern).     ClusterState.Builder newState = ClusterState.builder(localState).     newState.metaData(MetaData.builder(localState.getMetaData()).putCustom(AutoFollowMetadata.TYPE, new AutoFollowMetadata(patterns, followedLeaderIndices, headers)).build()).     return newState.build(). }
false;private,static;4;12;;private static void markExistingIndicesAsAutoFollowedForNewPatterns(List<String> leaderIndexPatterns, MetaData leaderMetaData, AutoFollowPattern previousPattern, List<String> followedIndexUUIDS) {     final List<String> newPatterns = leaderIndexPatterns.stream().filter(p -> previousPattern.getLeaderIndexPatterns().contains(p) == false).collect(Collectors.toList()).     markExistingIndicesAsAutoFollowed(newPatterns, leaderMetaData, followedIndexUUIDS). }
false;private,static;3;11;;private static void markExistingIndicesAsAutoFollowed(List<String> patterns, MetaData leaderMetaData, List<String> followedIndexUUIDS) {     for (final IndexMetaData indexMetaData : leaderMetaData) {         if (AutoFollowPattern.match(patterns, indexMetaData.getIndex().getName())) {             followedIndexUUIDS.add(indexMetaData.getIndexUUID()).         }     } }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(PutAutoFollowPatternAction.Request request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
