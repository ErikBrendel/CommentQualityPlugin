commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected AcknowledgedResponse newResponse() {     return new AcknowledgedResponse(). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(ResumeFollowAction.Request request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
false;protected;3;36;;@Override protected void masterOperation(final ResumeFollowAction.Request request, ClusterState state, final ActionListener<AcknowledgedResponse> listener) throws Exception {     if (ccrLicenseChecker.isCcrAllowed() == false) {         listener.onFailure(LicenseUtils.newComplianceException("ccr")).         return.     }     final IndexMetaData followerIndexMetadata = state.getMetaData().index(request.getFollowerIndex()).     if (followerIndexMetadata == null) {         listener.onFailure(new IndexNotFoundException(request.getFollowerIndex())).         return.     }     final Map<String, String> ccrMetadata = followerIndexMetadata.getCustomData(Ccr.CCR_CUSTOM_METADATA_KEY).     if (ccrMetadata == null) {         throw new IllegalArgumentException("follow index [" + request.getFollowerIndex() + "] does not have ccr metadata").     }     final String leaderCluster = ccrMetadata.get(Ccr.CCR_CUSTOM_METADATA_REMOTE_CLUSTER_NAME_KEY).     // Validates whether the leader cluster has been configured properly:     client.getRemoteClusterClient(leaderCluster).     final String leaderIndex = ccrMetadata.get(Ccr.CCR_CUSTOM_METADATA_LEADER_INDEX_NAME_KEY).     ccrLicenseChecker.checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(client, leaderCluster, leaderIndex, listener::onFailure, (leaderHistoryUUID, leaderIndexMetadata) -> {         try {             start(request, leaderCluster, leaderIndexMetadata, followerIndexMetadata, leaderHistoryUUID, listener).         } catch (final IOException e) {             listener.onFailure(e).         }     }). }
true;;6;23;/**  * Performs validation on the provided leader and follow {@link IndexMetaData} instances and then  * creates a persistent task for each leader primary shard. This persistent tasks track changes in the leader  * shard and replicate these changes to a follower shard.  *  * Currently the following validation is performed:  * <ul>  *     <li>The leader index and follow index need to have the same number of primary shards</li>  * </ul>  */ ;/**  * Performs validation on the provided leader and follow {@link IndexMetaData} instances and then  * creates a persistent task for each leader primary shard. This persistent tasks track changes in the leader  * shard and replicate these changes to a follower shard.  *  * Currently the following validation is performed:  * <ul>  *     <li>The leader index and follow index need to have the same number of primary shards</li>  * </ul>  */ void start(ResumeFollowAction.Request request, String clusterNameAlias, IndexMetaData leaderIndexMetadata, IndexMetaData followIndexMetadata, String[] leaderIndexHistoryUUIDs, ActionListener<AcknowledgedResponse> listener) throws IOException {     MapperService mapperService = followIndexMetadata != null ? indicesService.createIndexMapperService(followIndexMetadata) : null.     validate(request, leaderIndexMetadata, followIndexMetadata, leaderIndexHistoryUUIDs, mapperService).     final int numShards = followIndexMetadata.getNumberOfShards().     final ResponseHandler handler = new ResponseHandler(numShards, listener).     Map<String, String> filteredHeaders = threadPool.getThreadContext().getHeaders().entrySet().stream().filter(e -> ShardFollowTask.HEADER_FILTERS.contains(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).     for (int shardId = 0. shardId < numShards. shardId++) {         String taskId = followIndexMetadata.getIndexUUID() + "-" + shardId.         final ShardFollowTask shardFollowTask = createShardFollowTask(shardId, clusterNameAlias, request.getParameters(), leaderIndexMetadata, followIndexMetadata, filteredHeaders).         persistentTasksService.sendStartRequest(taskId, ShardFollowTask.NAME, shardFollowTask, handler.getActionListener(shardId)).     } }
false;static;5;65;;static void validate(final ResumeFollowAction.Request request, final IndexMetaData leaderIndex, final IndexMetaData followIndex, final String[] leaderIndexHistoryUUID, final MapperService followerMapperService) {     FollowParameters parameters = request.getParameters().     Map<String, String> ccrIndexMetadata = followIndex.getCustomData(Ccr.CCR_CUSTOM_METADATA_KEY).     if (ccrIndexMetadata == null) {         throw new IllegalArgumentException("follow index [" + followIndex.getIndex().getName() + "] does not have ccr metadata").     }     String leaderIndexUUID = leaderIndex.getIndex().getUUID().     String recordedLeaderIndexUUID = ccrIndexMetadata.get(Ccr.CCR_CUSTOM_METADATA_LEADER_INDEX_UUID_KEY).     if (leaderIndexUUID.equals(recordedLeaderIndexUUID) == false) {         throw new IllegalArgumentException("follow index [" + request.getFollowerIndex() + "] should reference [" + leaderIndexUUID + "] as leader index but instead reference [" + recordedLeaderIndexUUID + "] as leader index").     }     String[] recordedHistoryUUIDs = extractLeaderShardHistoryUUIDs(ccrIndexMetadata).     assert recordedHistoryUUIDs.length == leaderIndexHistoryUUID.length.     for (int i = 0. i < leaderIndexHistoryUUID.length. i++) {         String recordedLeaderIndexHistoryUUID = recordedHistoryUUIDs[i].         String actualLeaderIndexHistoryUUID = leaderIndexHistoryUUID[i].         if (recordedLeaderIndexHistoryUUID.equals(actualLeaderIndexHistoryUUID) == false) {             throw new IllegalArgumentException("leader shard [" + request.getFollowerIndex() + "][" + i + "] should reference [" + recordedLeaderIndexHistoryUUID + "] as history uuid but instead reference [" + actualLeaderIndexHistoryUUID + "] as history uuid").         }     }     if (IndexSettings.INDEX_SOFT_DELETES_SETTING.get(leaderIndex.getSettings()) == false) {         throw new IllegalArgumentException("leader index [" + leaderIndex.getIndex().getName() + "] does not have soft deletes enabled").     }     if (IndexSettings.INDEX_SOFT_DELETES_SETTING.get(followIndex.getSettings()) == false) {         throw new IllegalArgumentException("follower index [" + request.getFollowerIndex() + "] does not have soft deletes enabled").     }     if (leaderIndex.getNumberOfShards() != followIndex.getNumberOfShards()) {         throw new IllegalArgumentException("leader index primary shards [" + leaderIndex.getNumberOfShards() + "] does not match with the number of shards of the follow index [" + followIndex.getNumberOfShards() + "]").     }     if (leaderIndex.getRoutingNumShards() != followIndex.getRoutingNumShards()) {         throw new IllegalArgumentException("leader index number_of_routing_shards [" + leaderIndex.getRoutingNumShards() + "] does not match with the number_of_routing_shards of the follow index [" + followIndex.getRoutingNumShards() + "]").     }     if (leaderIndex.getState() != IndexMetaData.State.OPEN || followIndex.getState() != IndexMetaData.State.OPEN) {         throw new IllegalArgumentException("leader and follow index must be open").     }     if (CcrSettings.CCR_FOLLOWING_INDEX_SETTING.get(followIndex.getSettings()) == false) {         throw new IllegalArgumentException("the following index [" + request.getFollowerIndex() + "] is not ready " + "to follow. the setting [" + CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey() + "] must be enabled.").     }     // Make a copy, remove settings that are allowed to be different and then compare if the settings are equal.     Settings leaderSettings = filter(leaderIndex.getSettings()).     Settings followerSettings = filter(followIndex.getSettings()).     if (leaderSettings.equals(followerSettings) == false) {         throw new IllegalArgumentException("the leader index setting[" + leaderSettings + "] and follower index settings [" + followerSettings + "] must be identical").     }     // Validates if the current follower mapping is mergable with the leader mapping.     // This also validates for example whether specific mapper plugins have been installed     followerMapperService.merge(leaderIndex, MapperService.MergeReason.MAPPING_RECOVERY). }
false;private,static;6;84;;private static ShardFollowTask createShardFollowTask(int shardId, String clusterAliasName, FollowParameters parameters, IndexMetaData leaderIndexMetadata, IndexMetaData followIndexMetadata, Map<String, String> filteredHeaders) {     int maxReadRequestOperationCount.     if (parameters.getMaxReadRequestOperationCount() != null) {         maxReadRequestOperationCount = parameters.getMaxReadRequestOperationCount().     } else {         maxReadRequestOperationCount = DEFAULT_MAX_READ_REQUEST_OPERATION_COUNT.     }     ByteSizeValue maxReadRequestSize.     if (parameters.getMaxReadRequestSize() != null) {         maxReadRequestSize = parameters.getMaxReadRequestSize().     } else {         maxReadRequestSize = DEFAULT_MAX_READ_REQUEST_SIZE.     }     int maxOutstandingReadRequests.     if (parameters.getMaxOutstandingReadRequests() != null) {         maxOutstandingReadRequests = parameters.getMaxOutstandingReadRequests().     } else {         maxOutstandingReadRequests = DEFAULT_MAX_OUTSTANDING_READ_REQUESTS.     }     final int maxWriteRequestOperationCount.     if (parameters.getMaxWriteRequestOperationCount() != null) {         maxWriteRequestOperationCount = parameters.getMaxWriteRequestOperationCount().     } else {         maxWriteRequestOperationCount = DEFAULT_MAX_WRITE_REQUEST_OPERATION_COUNT.     }     final ByteSizeValue maxWriteRequestSize.     if (parameters.getMaxWriteRequestSize() != null) {         maxWriteRequestSize = parameters.getMaxWriteRequestSize().     } else {         maxWriteRequestSize = DEFAULT_MAX_WRITE_REQUEST_SIZE.     }     int maxOutstandingWriteRequests.     if (parameters.getMaxOutstandingWriteRequests() != null) {         maxOutstandingWriteRequests = parameters.getMaxOutstandingWriteRequests().     } else {         maxOutstandingWriteRequests = DEFAULT_MAX_OUTSTANDING_WRITE_REQUESTS.     }     int maxWriteBufferCount.     if (parameters.getMaxWriteBufferCount() != null) {         maxWriteBufferCount = parameters.getMaxWriteBufferCount().     } else {         maxWriteBufferCount = DEFAULT_MAX_WRITE_BUFFER_COUNT.     }     ByteSizeValue maxWriteBufferSize.     if (parameters.getMaxWriteBufferSize() != null) {         maxWriteBufferSize = parameters.getMaxWriteBufferSize().     } else {         maxWriteBufferSize = DEFAULT_MAX_WRITE_BUFFER_SIZE.     }     TimeValue maxRetryDelay = parameters.getMaxRetryDelay() == null ? DEFAULT_MAX_RETRY_DELAY : parameters.getMaxRetryDelay().     TimeValue readPollTimeout = parameters.getReadPollTimeout() == null ? DEFAULT_READ_POLL_TIMEOUT : parameters.getReadPollTimeout().     return new ShardFollowTask(clusterAliasName, new ShardId(followIndexMetadata.getIndex(), shardId), new ShardId(leaderIndexMetadata.getIndex(), shardId), maxReadRequestOperationCount, maxWriteRequestOperationCount, maxOutstandingReadRequests, maxOutstandingWriteRequests, maxReadRequestSize, maxWriteRequestSize, maxWriteBufferCount, maxWriteBufferSize, maxRetryDelay, readPollTimeout, filteredHeaders). }
false;static;1;8;;static String[] extractLeaderShardHistoryUUIDs(Map<String, String> ccrIndexMetaData) {     String historyUUIDs = ccrIndexMetaData.get(Ccr.CCR_CUSTOM_METADATA_LEADER_INDEX_SHARD_HISTORY_UUIDS).     if (historyUUIDs == null) {         throw new IllegalArgumentException("leader index shard UUIDs are missing").     }     return historyUUIDs.split(","). }
false;static;1;28;;static Settings filter(Settings originalSettings) {     Settings.Builder settings = Settings.builder().put(originalSettings).     // Remove settings that are always going to be different between leader and follow index:     settings.remove(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey()).     // soft deletes setting is checked manually     settings.remove(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey()).     settings.remove(IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey()).     settings.remove(IndexMetaData.SETTING_INDEX_UUID).     settings.remove(IndexMetaData.SETTING_INDEX_PROVIDED_NAME).     settings.remove(IndexMetaData.SETTING_CREATION_DATE).     // Follower index may be upgraded, while the leader index hasn't been upgraded, so it is expected     // that these settings are different:     settings.remove(IndexMetaData.SETTING_VERSION_UPGRADED).     settings.remove(IndexMetaData.SETTING_VERSION_UPGRADED_STRING).     Iterator<String> iterator = settings.keys().iterator().     while (iterator.hasNext()) {         String key = iterator.next().         for (Setting<?> whitelistedSetting : NON_REPLICATED_SETTINGS) {             if (whitelistedSetting.match(key)) {                 iterator.remove().                 break.             }         }     }     return settings.build(). }
