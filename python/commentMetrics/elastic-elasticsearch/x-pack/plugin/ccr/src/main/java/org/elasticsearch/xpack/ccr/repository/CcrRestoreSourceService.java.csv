commented;modifiers;parameterAmount;loc;comment;code
false;public,synchronized;3;13;;@Override public synchronized void afterIndexShardClosed(ShardId shardId, @Nullable IndexShard indexShard, Settings indexSettings) {     if (indexShard != null) {         HashSet<String> sessions = sessionsForShard.remove(indexShard).         if (sessions != null) {             for (String sessionUUID : sessions) {                 RestoreSession restore = onGoingRestores.remove(sessionUUID).                 assert restore != null : "Session UUID [" + sessionUUID + "] registered for shard but not found in ongoing restores".                 restore.decRef().             }         }     } }
false;protected;0;4;;@Override protected void doStart() { }
false;protected;0;4;;@Override protected void doStop() { }
false;protected,synchronized;0;6;;@Override protected synchronized void doClose() throws IOException {     sessionsForShard.clear().     onGoingRestores.values().forEach(AbstractRefCounted::decRef).     onGoingRestores.clear(). }
false;public,synchronized;2;29;;public synchronized Store.MetadataSnapshot openSession(String sessionUUID, IndexShard indexShard) throws IOException {     boolean success = false.     RestoreSession restore = null.     try {         if (onGoingRestores.containsKey(sessionUUID)) {             logger.debug("not opening new session [{}] as it already exists", sessionUUID).             restore = onGoingRestores.get(sessionUUID).         } else {             logger.debug("opening session [{}] for shard [{}]", sessionUUID, indexShard.shardId()).             if (indexShard.state() == IndexShardState.CLOSED) {                 throw new IndexShardClosedException(indexShard.shardId(), "cannot open ccr restore session if shard closed").             }             restore = new RestoreSession(sessionUUID, indexShard, indexShard.acquireSafeIndexCommit(), scheduleTimeout(sessionUUID)).             onGoingRestores.put(sessionUUID, restore).             HashSet<String> sessions = sessionsForShard.computeIfAbsent(indexShard, (s) -> new HashSet<>()).             sessions.add(sessionUUID).         }         Store.MetadataSnapshot metaData = restore.getMetaData().         success = true.         return metaData.     } finally {         if (success == false) {             onGoingRestores.remove(sessionUUID).             if (restore != null) {                 restore.decRef().             }         }     } }
false;public;1;3;;public void closeSession(String sessionUUID) {     internalCloseSession(sessionUUID, true). }
false;public,synchronized;1;9;;public synchronized SessionReader getSessionReader(String sessionUUID) {     RestoreSession restore = onGoingRestores.get(sessionUUID).     if (restore == null) {         logger.debug("could not get session [{}] because session not found", sessionUUID).         throw new IllegalArgumentException("session [" + sessionUUID + "] not found").     }     restore.idle = false.     return new SessionReader(restore, ccrSettings, throttleTime::inc). }
false;private;2;24;;private void internalCloseSession(String sessionUUID, boolean throwIfSessionMissing) {     final RestoreSession restore.     synchronized (this) {         restore = onGoingRestores.remove(sessionUUID).         if (restore == null) {             if (throwIfSessionMissing) {                 logger.debug("could not close session [{}] because session not found", sessionUUID).                 throw new IllegalArgumentException("session [" + sessionUUID + "] not found").             } else {                 return.             }         }         HashSet<String> sessions = sessionsForShard.get(restore.indexShard).         assert sessions != null : "No session UUIDs for shard even though one [" + sessionUUID + "] is active in ongoing restores".         if (sessions != null) {             boolean removed = sessions.remove(sessionUUID).             assert removed : "No session found for UUID [" + sessionUUID + "]".             if (sessions.isEmpty()) {                 sessionsForShard.remove(restore.indexShard).             }         }     }     restore.decRef(). }
false;private;1;4;;private Scheduler.Cancellable scheduleTimeout(String sessionUUID) {     TimeValue idleTimeout = ccrSettings.getRecoveryActivityTimeout().     return threadPool.scheduleWithFixedDelay(() -> maybeTimeout(sessionUUID), idleTimeout, ThreadPool.Names.GENERIC). }
false;private;1;10;;private void maybeTimeout(String sessionUUID) {     RestoreSession restoreSession = onGoingRestores.get(sessionUUID).     if (restoreSession != null) {         if (restoreSession.idle) {             internalCloseSession(sessionUUID, false).         } else {             restoreSession.idle = true.         }     } }
false;public;0;3;;public long getThrottleTime() {     return this.throttleTime.count(). }
false;private;0;8;;private Store.MetadataSnapshot getMetaData() throws IOException {     indexShard.store().incRef().     try {         return indexShard.store().getMetadata(commitRef.getIndexCommit()).     } finally {         indexShard.store().decRef().     } }
false;private;2;26;;private long readFileBytes(String fileName, BytesReference reference) throws IOException {     try (Releasable ignored = keyedLock.acquire(fileName)) {         final IndexInput indexInput = cachedInputs.computeIfAbsent(fileName, f -> {             try {                 return commitRef.getIndexCommit().getDirectory().openInput(fileName, IOContext.READONCE).             } catch (IOException e) {                 throw new UncheckedIOException(e).             }         }).         BytesRefIterator refIterator = reference.iterator().         BytesRef ref.         while ((ref = refIterator.next()) != null) {             indexInput.readBytes(ref.bytes, ref.offset, ref.length).         }         long offsetAfterRead = indexInput.getFilePointer().         if (offsetAfterRead == indexInput.length()) {             cachedInputs.remove(fileName).             IOUtils.close(indexInput).         }         return offsetAfterRead.     } }
false;protected;0;8;;@Override protected void closeInternal() {     logger.debug("closing session [{}] for shard [{}]", sessionUUID, indexShard.shardId()).     assert keyedLock.hasLockedKeys() == false : "Should not hold any file locks when closing".     timeoutTask.cancel().     IOUtils.closeWhileHandlingException(cachedInputs.values()).     IOUtils.closeWhileHandlingException(commitRef). }
true;public;2;6;/**  * Read bytes into the reference from the file. This method will return the offset in the file where  * the read completed.  *  * @param fileName to read  * @param reference to read bytes into  * @return the offset of the file after the read is complete  * @throws IOException if the read fails  */ ;/**  * Read bytes into the reference from the file. This method will return the offset in the file where  * the read completed.  *  * @param fileName to read  * @param reference to read bytes into  * @return the offset of the file after the read is complete  * @throws IOException if the read fails  */ public long readFileBytes(String fileName, BytesReference reference) throws IOException {     CombinedRateLimiter rateLimiter = ccrSettings.getRateLimiter().     long throttleTime = rateLimiter.maybePause(reference.length()).     throttleListener.accept(throttleTime).     return restoreSession.readFileBytes(fileName, reference). }
false;public;0;4;;@Override public void close() {     restoreSession.decRef(). }
