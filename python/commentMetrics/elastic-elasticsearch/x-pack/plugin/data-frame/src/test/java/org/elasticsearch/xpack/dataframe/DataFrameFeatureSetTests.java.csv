commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void init() {     licenseState = mock(XPackLicenseState.class). }
false;public;0;6;;public void testAvailable() {     DataFrameFeatureSet featureSet = new DataFrameFeatureSet(Settings.EMPTY, mock(Client.class), licenseState).     boolean available = randomBoolean().     when(licenseState.isDataFrameAllowed()).thenReturn(available).     assertThat(featureSet.available(), is(available)). }
false;public;0;7;;public void testEnabledSetting() {     boolean enabled = randomBoolean().     Settings.Builder settings = Settings.builder().     settings.put("xpack.data_frame.enabled", enabled).     DataFrameFeatureSet featureSet = new DataFrameFeatureSet(settings.build(), mock(Client.class), licenseState).     assertThat(featureSet.enabled(), is(enabled)). }
false;public;0;4;;public void testEnabledDefault() {     DataFrameFeatureSet featureSet = new DataFrameFeatureSet(Settings.EMPTY, mock(Client.class), licenseState).     assertTrue(featureSet.enabled()). }
false;public;0;57;;public void testUsage() throws InterruptedException, ExecutionException, IOException {     Client client = mock(Client.class).     when(licenseState.isDataFrameAllowed()).thenReturn(true).     DataFrameFeatureSet featureSet = new DataFrameFeatureSet(Settings.EMPTY, client, licenseState).     List<DataFrameTransformStateAndStats> transformsStateAndStats = new ArrayList<>().     for (int i = 0. i < randomIntBetween(0, 10). ++i) {         transformsStateAndStats.add(DataFrameTransformStateAndStatsTests.randomDataFrameTransformStateAndStats()).     }     GetDataFrameTransformsStatsAction.Response mockResponse = new GetDataFrameTransformsStatsAction.Response(transformsStateAndStats).     doAnswer(invocationOnMock -> {         @SuppressWarnings("unchecked")         ActionListener<Response> listener = (ActionListener<Response>) invocationOnMock.getArguments()[2].         listener.onResponse(mockResponse).         return Void.TYPE.     }).when(client).execute(same(GetDataFrameTransformsStatsAction.INSTANCE), any(), any()).     PlainActionFuture<Usage> future = new PlainActionFuture<>().     featureSet.usage(future).     XPackFeatureSet.Usage usage = future.get().     assertTrue(usage.enabled()).     try (XContentBuilder builder = XContentFactory.jsonBuilder()) {         usage.toXContent(builder, ToXContent.EMPTY_PARAMS).         XContentParser parser = createParser(builder).         Map<String, Object> usageAsMap = parser.map().         assertTrue((boolean) XContentMapValues.extractValue("available", usageAsMap)).         if (transformsStateAndStats.isEmpty()) {             // no transforms, no stats             assertEquals(null, XContentMapValues.extractValue("transforms", usageAsMap)).             assertEquals(null, XContentMapValues.extractValue("stats", usageAsMap)).         } else {             assertEquals(transformsStateAndStats.size(), XContentMapValues.extractValue("transforms._all", usageAsMap)).             Map<String, Integer> stateCounts = new HashMap<>().             transformsStateAndStats.stream().map(x -> x.getTransformState().getIndexerState().value()).forEach(x -> stateCounts.merge(x, 1, Integer::sum)).             stateCounts.forEach((k, v) -> assertEquals(v, XContentMapValues.extractValue("transforms." + k, usageAsMap))).             DataFrameIndexerTransformStats combinedStats = transformsStateAndStats.stream().map(x -> x.getTransformStats()).reduce((l, r) -> l.merge(r)).get().             assertEquals(toIntExact(combinedStats.getIndexFailures()), XContentMapValues.extractValue("stats.index_failures", usageAsMap)).             assertEquals(toIntExact(combinedStats.getIndexTotal()), XContentMapValues.extractValue("stats.index_total", usageAsMap)).             assertEquals(toIntExact(combinedStats.getSearchTime()), XContentMapValues.extractValue("stats.search_time_in_ms", usageAsMap)).             assertEquals(toIntExact(combinedStats.getNumDocuments()), XContentMapValues.extractValue("stats.documents_processed", usageAsMap)).         }     } }
false;public;0;22;;public void testUsageDisabled() throws IOException, InterruptedException, ExecutionException {     when(licenseState.isDataFrameAllowed()).thenReturn(true).     Settings.Builder settings = Settings.builder().     settings.put("xpack.data_frame.enabled", false).     DataFrameFeatureSet featureSet = new DataFrameFeatureSet(settings.build(), mock(Client.class), licenseState).     PlainActionFuture<Usage> future = new PlainActionFuture<>().     featureSet.usage(future).     XPackFeatureSet.Usage usage = future.get().     assertFalse(usage.enabled()).     try (XContentBuilder builder = XContentFactory.jsonBuilder()) {         usage.toXContent(builder, ToXContent.EMPTY_PARAMS).         XContentParser parser = createParser(builder).         Map<String, Object> usageAsMap = parser.map().         assertTrue((boolean) XContentMapValues.extractValue("available", usageAsMap)).         assertFalse((boolean) XContentMapValues.extractValue("enabled", usageAsMap)).         // not enabled -> no transforms, no stats         assertEquals(null, XContentMapValues.extractValue("transforms", usageAsMap)).         assertEquals(null, XContentMapValues.extractValue("stats", usageAsMap)).     } }
