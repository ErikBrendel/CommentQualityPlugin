commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void registerAggregationNamedObjects() throws Exception {     // register aggregations as NamedWriteable     SearchModule searchModule = new SearchModule(Settings.EMPTY, false, emptyList()).     namedXContentRegistry = new NamedXContentRegistry(searchModule.getNamedXContents()). }
false;public;0;7;;@Before public void setupClient() {     if (client != null) {         client.close().     }     client = new MyMockClient(getTestName()). }
false;public;0;4;;@After public void tearDownClient() {     client.close(). }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return namedXContentRegistry. }
false;public;0;5;;public void testValidateExistingIndex() throws Exception {     Pivot pivot = new Pivot("existing_source_index", new MatchAllQueryBuilder(), getValidPivotConfig()).     assertValidTransform(client, pivot). }
false;public;0;5;;public void testValidateNonExistingIndex() throws Exception {     Pivot pivot = new Pivot("non_existing_source_index", new MatchAllQueryBuilder(), getValidPivotConfig()).     assertInvalidTransform(client, pivot). }
false;public;0;7;;public void testSearchFailure() throws Exception {     // test a failure during the search operation, transform creation fails if     // search has failures although they might just be temporary     Pivot pivot = new Pivot("existing_source_index_with_failing_shards", new MatchAllQueryBuilder(), getValidPivotConfig()).     assertInvalidTransform(client, pivot). }
false;public;0;9;;public void testValidateAllSupportedAggregations() throws Exception {     for (String agg : supportedAggregations) {         AggregationConfig aggregationConfig = getAggregationConfig(agg).         Pivot pivot = new Pivot("existing_source", new MatchAllQueryBuilder(), getValidPivotConfig(aggregationConfig)).         assertValidTransform(client, pivot).     } }
false;public;0;9;;public void testValidateAllUnsupportedAggregations() throws Exception {     for (String agg : unsupportedAggregations) {         AggregationConfig aggregationConfig = getAggregationConfig(agg).         Pivot pivot = new Pivot("existing_source", new MatchAllQueryBuilder(), getValidPivotConfig(aggregationConfig)).         assertInvalidTransform(client, pivot).     } }
false;protected;3;32;;@SuppressWarnings("unchecked") @Override protected <Request extends ActionRequest, Response extends ActionResponse> void doExecute(Action<Response> action, Request request, ActionListener<Response> listener) {     if (request instanceof SearchRequest) {         SearchRequest searchRequest = (SearchRequest) request.         List<ShardSearchFailure> searchFailures = new ArrayList<>().         for (String index : searchRequest.indices()) {             if (index.contains("non_existing")) {                 listener.onFailure(new IndexNotFoundException(index)).                 return.             }             if (index.contains("with_failing_shards")) {                 searchFailures.add(new ShardSearchFailure(new RuntimeException("shard failed"))).             }         }         final SearchResponseSections sections = new SearchResponseSections(new SearchHits(new SearchHit[0], new TotalHits(0L, TotalHits.Relation.EQUAL_TO), 0), null, null, false, null, null, 1).         final SearchResponse response = new SearchResponse(sections, null, 10, searchFailures.size() > 0 ? 0 : 5, 0, 0, searchFailures.toArray(new ShardSearchFailure[searchFailures.size()]), null).         listener.onResponse((Response) response).         return.     }     super.doExecute(action, request, listener). }
false;private;0;3;;private PivotConfig getValidPivotConfig() throws IOException {     return new PivotConfig(GroupConfigTests.randomGroupConfig(), getValidAggregationConfig()). }
false;private;1;3;;private PivotConfig getValidPivotConfig(AggregationConfig aggregationConfig) throws IOException {     return new PivotConfig(GroupConfigTests.randomGroupConfig(), aggregationConfig). }
false;private;0;3;;private AggregationConfig getValidAggregationConfig() throws IOException {     return getAggregationConfig(randomFrom(supportedAggregations)). }
false;private;1;4;;private AggregationConfig getAggregationConfig(String agg) throws IOException {     return parseAggregations("{\n" + "  \"pivot_" + agg + "\": {\n" + "    \"" + agg + "\": {\n" + "      \"field\": \"values\"\n" + "    }\n" + "  }" + "}"). }
false;private;1;7;;private AggregationConfig parseAggregations(String json) throws IOException {     final XContentParser parser = XContentType.JSON.xContent().createParser(xContentRegistry(), DeprecationHandler.THROW_UNSUPPORTED_OPERATION, json).     // parseAggregators expects to be already inside the xcontent object     assertThat(parser.nextToken(), equalTo(XContentParser.Token.START_OBJECT)).     return AggregationConfig.fromXContent(parser, false). }
false;private,static;2;3;;private static void assertValidTransform(Client client, Pivot pivot) throws Exception {     validate(client, pivot, true). }
false;private,static;2;3;;private static void assertInvalidTransform(Client client, Pivot pivot) throws Exception {     validate(client, pivot, false). }
false;private,static;3;18;;private static void validate(Client client, Pivot pivot, boolean expectValid) throws Exception {     CountDownLatch latch = new CountDownLatch(1).     final AtomicReference<Exception> exceptionHolder = new AtomicReference<>().     pivot.validate(client, ActionListener.wrap(validity -> {         assertEquals(expectValid, validity).         latch.countDown().     }, e -> {         exceptionHolder.set(e).         latch.countDown().     })).     assertTrue(latch.await(100, TimeUnit.MILLISECONDS)).     if (expectValid == true && exceptionHolder.get() != null) {         throw exceptionHolder.get().     } else if (expectValid == false && exceptionHolder.get() == null) {         fail("Expected config to be invalid").     } }
