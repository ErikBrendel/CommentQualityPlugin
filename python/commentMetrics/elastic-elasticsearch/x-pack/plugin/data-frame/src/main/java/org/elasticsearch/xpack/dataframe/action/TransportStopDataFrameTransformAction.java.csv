commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;5;;@Override protected void doExecute(Task task, StopDataFrameTransformAction.Request request, ActionListener<StopDataFrameTransformAction.Response> listener) {     super.doExecute(task, request, listener). }
false;protected;3;45;;@Override protected void taskOperation(StopDataFrameTransformAction.Request request, DataFrameTransformTask transformTask, ActionListener<StopDataFrameTransformAction.Response> listener) {     if (transformTask.getTransformId().equals(request.getId())) {         if (request.waitForCompletion() == false) {             transformTask.stop(listener).         } else {             ActionListener<StopDataFrameTransformAction.Response> blockingListener = ActionListener.wrap(response -> {                 if (response.isStopped()) {                     // The Task acknowledged that it is stopped/stopping... wait until the status actually                     // changes over before returning. Switch over to Generic threadpool so                     // we don't block the network thread                     threadPool.generic().execute(() -> {                         try {                             long untilInNanos = System.nanoTime() + request.getTimeout().getNanos().                             while (System.nanoTime() - untilInNanos < 0) {                                 if (transformTask.isStopped()) {                                     listener.onResponse(response).                                     return.                                 }                                 Thread.sleep(WAIT_FOR_COMPLETION_POLL.millis()).                             }                             // ran out of time                             listener.onFailure(new ElasticsearchTimeoutException(DataFrameMessages.getMessage(DataFrameMessages.REST_STOP_TRANSFORM_WAIT_FOR_COMPLETION_TIMEOUT, request.getTimeout().getStringRep(), request.getId()))).                         } catch (InterruptedException e) {                             listener.onFailure(new ElasticsearchException(DataFrameMessages.getMessage(DataFrameMessages.REST_STOP_TRANSFORM_WAIT_FOR_COMPLETION_INTERRUPT, request.getId()), e)).                         }                     }).                 } else {                     // Did not acknowledge stop, just return the response                     listener.onResponse(response).                 }             }, listener::onFailure).             transformTask.stop(blockingListener).         }     } else {         listener.onFailure(new RuntimeException("ID of data frame indexer task [" + transformTask.getTransformId() + "] does not match request's ID [" + request.getId() + "]")).     } }
false;protected;4;23;;@Override protected StopDataFrameTransformAction.Response newResponse(StopDataFrameTransformAction.Request request, List<StopDataFrameTransformAction.Response> tasks, List<TaskOperationFailure> taskOperationFailures, List<FailedNodeException> failedNodeExceptions) {     if (taskOperationFailures.isEmpty() == false) {         throw ExceptionsHelper.convertToElastic(taskOperationFailures.get(0).getCause()).     } else if (failedNodeExceptions.isEmpty() == false) {         throw ExceptionsHelper.convertToElastic(failedNodeExceptions.get(0)).     }     // In either case, let the user know     if (tasks.size() == 0) {         throw new ResourceNotFoundException("Task for Data Frame transform [" + request.getId() + "] not found").     }     assert tasks.size() == 1.     boolean allStopped = tasks.stream().allMatch(StopDataFrameTransformAction.Response::isStopped).     return new StopDataFrameTransformAction.Response(allStopped). }
