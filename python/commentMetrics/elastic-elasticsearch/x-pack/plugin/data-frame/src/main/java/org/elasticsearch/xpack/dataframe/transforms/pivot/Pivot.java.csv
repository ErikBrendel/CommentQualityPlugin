commented;modifiers;parameterAmount;loc;comment;code
false;public;2;12;;public void validate(Client client, final ActionListener<Boolean> listener) {     // step 1: check if used aggregations are supported     for (AggregationBuilder agg : config.getAggregationConfig().getAggregatorFactories()) {         if (Aggregations.isSupportedByDataframe(agg.getType()) == false) {             listener.onFailure(new RuntimeException("Unsupported aggregation type [" + agg.getType() + "]")).             return.         }     }     // step 2: run a query to validate that config is valid     runTestQuery(client, listener). }
false;public;2;3;;public void deduceMappings(Client client, final ActionListener<Map<String, String>> listener) {     SchemaUtil.deduceMappings(client, config, source, listener). }
false;public;1;7;;public SearchRequest buildSearchRequest(Map<String, Object> position) {     if (position != null) {         cachedCompositeAggregation.aggregateAfter(position).     }     return cachedSearchRequest. }
false;public;2;8;;public Stream<Map<String, Object>> extractResults(CompositeAggregation agg, DataFrameIndexerTransformStats dataFrameIndexerTransformStats) {     GroupConfig groups = config.getGroupConfig().     Collection<AggregationBuilder> aggregationBuilders = config.getAggregationConfig().getAggregatorFactories().     return AggregationResultUtils.extractCompositeAggregationResults(agg, groups, aggregationBuilders, dataFrameIndexerTransformStats). }
false;private;2;17;;private void runTestQuery(Client client, final ActionListener<Boolean> listener) {     // no after key     cachedCompositeAggregation.aggregateAfter(null).     client.execute(SearchAction.INSTANCE, cachedSearchRequest, ActionListener.wrap(response -> {         if (response == null) {             listener.onFailure(new RuntimeException("Unexpected null response from test query")).             return.         }         if (response.status() != RestStatus.OK) {             listener.onFailure(new RuntimeException("Unexpected status from response of test query: " + response.status())).             return.         }         listener.onResponse(true).     }, e -> {         listener.onFailure(new RuntimeException("Failed to test query", e)).     })). }
false;private,static;3;9;;private static SearchRequest createSearchRequest(String index, QueryBuilder query, CompositeAggregationBuilder compositeAggregation) {     SearchRequest searchRequest = new SearchRequest(index).     SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().     sourceBuilder.aggregation(compositeAggregation).     sourceBuilder.size(0).     sourceBuilder.query(query).     searchRequest.source(sourceBuilder).     return searchRequest. }
false;private,static;1;16;;private static CompositeAggregationBuilder createCompositeAggregation(PivotConfig config) {     CompositeAggregationBuilder compositeAggregation.     try (XContentBuilder builder = jsonBuilder()) {         // write configuration for composite aggs into builder         config.toCompositeAggXContent(builder, ToXContentObject.EMPTY_PARAMS).         XContentParser parser = builder.generator().contentType().xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(builder).streamInput()).         compositeAggregation = CompositeAggregationBuilder.parse(COMPOSITE_AGGREGATION_NAME, parser).         compositeAggregation.size(1000).         config.getAggregationConfig().getAggregatorFactories().forEach(agg -> compositeAggregation.subAggregation(agg)).     } catch (IOException e) {         throw new RuntimeException(DataFrameMessages.DATA_FRAME_TRANSFORM_PIVOT_FAILED_TO_CREATE_COMPOSITE_AGGREGATION, e).     }     return compositeAggregation. }
