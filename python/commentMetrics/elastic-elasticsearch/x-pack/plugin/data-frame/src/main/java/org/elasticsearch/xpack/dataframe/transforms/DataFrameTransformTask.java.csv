commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getTransformId() {     return transform.getId(). }
true;public;0;4;/**  * Enable Task API to return detailed status information  */ ;/**  * Enable Task API to return detailed status information  */ @Override public Status getStatus() {     return getState(). }
false;public;0;3;;public DataFrameTransformState getState() {     return new DataFrameTransformState(indexer.getState(), indexer.getPosition(), generation.get()). }
false;public;0;3;;public DataFrameIndexerTransformStats getStats() {     return indexer.getStats(). }
false;public;0;3;;public long getGeneration() {     return generation.get(). }
false;public;0;3;;public boolean isStopped() {     return indexer.getState().equals(IndexerState.STOPPED). }
false;public,synchronized;1;34;;public synchronized void start(ActionListener<Response> listener) {     final IndexerState prevState = indexer.getState().     if (prevState != IndexerState.STOPPED) {         // fails if the task is not STOPPED         listener.onFailure(new ElasticsearchException("Cannot start task for data frame transform [{}], because state was [{}]", transform.getId(), prevState)).         return.     }     final IndexerState newState = indexer.start().     if (newState != IndexerState.STARTED) {         listener.onFailure(new ElasticsearchException("Cannot start task for data frame transform [{}], because state was [{}]", transform.getId(), newState)).         return.     }     final DataFrameTransformState state = new DataFrameTransformState(IndexerState.STOPPED, indexer.getPosition(), generation.get()).     logger.debug("Updating state for data frame transform [{}] to [{}][{}]", transform.getId(), state.getIndexerState(), state.getPosition()).     updatePersistentTaskState(state, ActionListener.wrap((task) -> {         logger.debug("Successfully updated state for data frame transform [" + transform.getId() + "] to [" + state.getIndexerState() + "][" + state.getPosition() + "]").         listener.onResponse(new StartDataFrameTransformAction.Response(true)).     }, (exc) -> {         // We were unable to update the persistent status, so we need to shutdown the indexer too.         indexer.stop().         listener.onFailure(new ElasticsearchException("Error while updating state for data frame transform [" + transform.getId() + "] to [" + state.getIndexerState() + "].", exc)).     })). }
false;public,synchronized;1;30;;public synchronized void stop(ActionListener<StopDataFrameTransformAction.Response> listener) {     final IndexerState newState = indexer.stop().     switch(newState) {         case STOPPED:             listener.onResponse(new StopDataFrameTransformAction.Response(true)).             break.         case STOPPING:             // update the persistent state to STOPPED. There are two scenarios and both are safe:             // 1. we persist STOPPED now, indexer continues a bit then sees the flag and checkpoints another STOPPED with the more recent             // position.             // 2. we persist STOPPED now, indexer continues a bit but then dies. When/if we resume we'll pick up at last checkpoint,             // overwrite some docs and eventually checkpoint.             DataFrameTransformState state = new DataFrameTransformState(IndexerState.STOPPED, indexer.getPosition(), generation.get()).             updatePersistentTaskState(state, ActionListener.wrap((task) -> {                 logger.debug("Successfully updated state for data frame transform [{}] to [{}]", transform.getId(), state.getIndexerState()).                 listener.onResponse(new StopDataFrameTransformAction.Response(true)).             }, (exc) -> {                 listener.onFailure(new ElasticsearchException("Error while updating state for data frame transform [{}] to [{}]", exc, transform.getId(), state.getIndexerState())).             })).             break.         default:             listener.onFailure(new ElasticsearchException("Cannot stop task for data frame transform [{}], because state was [{}]", transform.getId(), newState)).             break.     } }
false;public,synchronized;1;7;;@Override public synchronized void triggered(Event event) {     if (generation.get() == 0 && event.getJobName().equals(SCHEDULE_NAME + "_" + transform.getId())) {         logger.debug("Data frame indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]").         indexer.maybeTriggerAsyncJob(System.currentTimeMillis()).     } }
true;synchronized;0;11;/**  * Attempt to gracefully cleanup the data frame transform so it can be terminated.  * This tries to remove the job from the scheduler, and potentially any other  * cleanup operations in the future  */ ;/**  * Attempt to gracefully cleanup the data frame transform so it can be terminated.  * This tries to remove the job from the scheduler, and potentially any other  * cleanup operations in the future  */ synchronized void shutdown() {     try {         logger.info("Data frame indexer [" + transform.getId() + "] received abort request, stopping indexer.").         schedulerEngine.remove(SCHEDULE_NAME + "_" + transform.getId()).         schedulerEngine.unregister(this).     } catch (Exception e) {         markAsFailed(e).         return.     }     markAsCompleted(). }
true;public,synchronized;0;9;/**  * This is called when the persistent task signals that the allocated task should be terminated.  * Termination in the task framework is essentially voluntary, as the allocated task can only be  * shut down from the inside.  */ ;/**  * This is called when the persistent task signals that the allocated task should be terminated.  * Termination in the task framework is essentially voluntary, as the allocated task can only be  * shut down from the inside.  */ @Override public synchronized void onCancelled() {     logger.info("Received cancellation request for data frame transform [" + transform.getId() + "], state: [" + indexer.getState() + "]").     if (indexer.abort()) {         // there is no background transform running, we can shutdown safely         shutdown().     } }
false;protected;0;4;;@Override protected DataFrameTransformConfig getConfig() {     return transformConfig. }
false;protected;0;4;;@Override protected String getJobId() {     return transformId. }
false;public,synchronized;1;28;;@Override public synchronized boolean maybeTriggerAsyncJob(long now) {     if (transformConfig == null) {         CountDownLatch latch = new CountDownLatch(1).         transformsConfigManager.getTransformConfiguration(transformId, new LatchedActionListener<>(ActionListener.wrap(config -> {             transformConfig = config.         }, e -> {             throw new RuntimeException(DataFrameMessages.getMessage(DataFrameMessages.FAILED_TO_LOAD_TRANSFORM_CONFIGURATION, transformId), e).         }), latch)).         try {             latch.await(LOAD_TRANSFORM_TIMEOUT_IN_SECONDS, TimeUnit.SECONDS).         } catch (InterruptedException e) {             throw new RuntimeException(DataFrameMessages.getMessage(DataFrameMessages.FAILED_TO_LOAD_TRANSFORM_CONFIGURATION, transformId), e).         }     }     // todo: set job into failed state     if (transformConfig.isValid() == false) {         throw new RuntimeException(DataFrameMessages.getMessage(DataFrameMessages.DATA_FRAME_TRANSFORM_CONFIGURATION_INVALID, transformId)).     }     return super.maybeTriggerAsyncJob(now). }
false;protected;2;5;;@Override protected void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase) {     ClientHelper.executeWithHeadersAsync(transformConfig.getHeaders(), ClientHelper.DATA_FRAME_ORIGIN, client, SearchAction.INSTANCE, request, nextPhase). }
false;protected;2;5;;@Override protected void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase) {     ClientHelper.executeWithHeadersAsync(transformConfig.getHeaders(), ClientHelper.DATA_FRAME_ORIGIN, client, BulkAction.INSTANCE, request, nextPhase). }
false;protected;3;21;;@Override protected void doSaveState(IndexerState indexerState, Map<String, Object> position, Runnable next) {     if (indexerState.equals(IndexerState.ABORTING)) {         // If we're aborting, just invoke `next` (which is likely an onFailure handler)         next.run().         return.     }     if (indexerState.equals(IndexerState.STARTED)) {         // if the indexer resets the state to started, it means it is done, so increment the generation         generation.compareAndSet(0L, 1L).     }     final DataFrameTransformState state = new DataFrameTransformState(indexerState, getPosition(), generation.get()).     logger.info("Updating persistent state of transform [" + transform.getId() + "] to [" + state.toString() + "]").     updatePersistentTaskState(state, ActionListener.wrap(task -> next.run(), exc -> {         logger.error("Updating persistent state of transform [" + transform.getId() + "] failed", exc).         next.run().     })). }
false;protected;1;4;;@Override protected void onFailure(Exception exc) {     logger.warn("Data frame transform [" + transform.getId() + "] failed with an exception: ", exc). }
false;protected;0;4;;@Override protected void onFinish() {     logger.info("Finished indexing for data frame transform [" + transform.getId() + "]"). }
false;protected;0;5;;@Override protected void onAbort() {     logger.info("Data frame transform [" + transform.getId() + "] received abort request, stopping indexer").     shutdown(). }
