commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;4;// preserve indices in order to reuse source indices in several test cases ;// preserve indices in order to reuse source indices in several test cases @Override protected boolean preserveIndicesUponCompletion() {     return true. }
false;public;0;11;;@Before public void createIndexes() throws IOException {     // it's not possible to run it as @BeforeClass as clients aren't initialized then, so we need this little hack     if (indicesCreated) {         return.     }     createReviewsIndex().     indicesCreated = true. }
false;public;0;20;;public void testUsage() throws IOException {     Response usageResponse = client().performRequest(new Request("GET", "_xpack/usage")).     Map<?, ?> usageAsMap = entityAsMap(usageResponse).     assertTrue((boolean) XContentMapValues.extractValue("data_frame.available", usageAsMap)).     assertTrue((boolean) XContentMapValues.extractValue("data_frame.enabled", usageAsMap)).     // no transforms, no stats     assertEquals(null, XContentMapValues.extractValue("data_frame.transforms", usageAsMap)).     assertEquals(null, XContentMapValues.extractValue("data_frame.stats", usageAsMap)).     // create a transform     createPivotReviewsTransform("test_usage", "pivot_reviews", null).     usageResponse = client().performRequest(new Request("GET", "_xpack/usage")).     usageAsMap = entityAsMap(usageResponse).     // we should see some stats     assertEquals(1, XContentMapValues.extractValue("data_frame.transforms._all", usageAsMap)).     assertEquals(0, XContentMapValues.extractValue("data_frame.stats.index_failures", usageAsMap)). }
