commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;7;;@AfterClass public static void stopThreadPool() {     if (pool != null) {         pool.shutdownNow().         pool = null.     } }
false;public;0;12;;public void testInitialStatusStopped() {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.STOPPED, Collections.singletonMap("foo", "bar"), randomBoolean()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertThat(((RollupJobStatus) task.getStatus()).getPosition().size(), equalTo(1)).     assertTrue(((RollupJobStatus) task.getStatus()).getPosition().containsKey("foo")). }
false;public;0;12;;public void testInitialStatusAborting() {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.ABORTING, Collections.singletonMap("foo", "bar"), randomBoolean()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertThat(((RollupJobStatus) task.getStatus()).getPosition().size(), equalTo(1)).     assertTrue(((RollupJobStatus) task.getStatus()).getPosition().containsKey("foo")). }
false;public;0;12;;public void testInitialStatusStopping() {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.STOPPING, Collections.singletonMap("foo", "bar"), randomBoolean()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertThat(((RollupJobStatus) task.getStatus()).getPosition().size(), equalTo(1)).     assertTrue(((RollupJobStatus) task.getStatus()).getPosition().containsKey("foo")). }
false;public;0;12;;public void testInitialStatusStarted() {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.STARTED, Collections.singletonMap("foo", "bar"), randomBoolean()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     assertThat(((RollupJobStatus) task.getStatus()).getPosition().size(), equalTo(1)).     assertTrue(((RollupJobStatus) task.getStatus()).getPosition().containsKey("foo")). }
false;public;0;13;;public void testInitialStatusIndexingOldID() {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.INDEXING, Collections.singletonMap("foo", "bar"), false).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     assertThat(((RollupJobStatus) task.getStatus()).getPosition().size(), equalTo(1)).     assertTrue(((RollupJobStatus) task.getStatus()).getPosition().containsKey("foo")).     assertFalse(((RollupJobStatus) task.getStatus()).isUpgradedDocumentID()). }
false;public;0;13;;public void testInitialStatusIndexingNewID() {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.INDEXING, Collections.singletonMap("foo", "bar"), true).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     assertThat(((RollupJobStatus) task.getStatus()).getPosition().size(), equalTo(1)).     assertTrue(((RollupJobStatus) task.getStatus()).getPosition().containsKey("foo")).     assertTrue(((RollupJobStatus) task.getStatus()).isUpgradedDocumentID()). }
false;public;0;11;;public void testNoInitialStatus() {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, null, client, schedulerEngine, pool, Collections.emptyMap()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertNull(((RollupJobStatus) task.getStatus()).getPosition()).     assertTrue(((RollupJobStatus) task.getStatus()).isUpgradedDocumentID()). }
false;public;1;4;;@Override public void onResponse(StartRollupJobAction.Response response) {     fail("Should not have entered onResponse."). }
false;public;1;6;;@Override public void onFailure(Exception e) {     assertThat(e.getMessage(), equalTo("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because state was [STARTED]")).     latch.countDown(). }
false;public;0;28;;public void testStartWhenStarted() throws InterruptedException {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.STARTED, Collections.singletonMap("foo", "bar"), randomBoolean()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     assertThat(((RollupJobStatus) task.getStatus()).getPosition().size(), equalTo(1)).     assertTrue(((RollupJobStatus) task.getStatus()).getPosition().containsKey("foo")).     CountDownLatch latch = new CountDownLatch(1).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             fail("Should not have entered onResponse.").         }          @Override         public void onFailure(Exception e) {             assertThat(e.getMessage(), equalTo("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because state was [STARTED]")).             latch.countDown().         }     }).     latch.await(3, TimeUnit.SECONDS). }
false;public;2;16;;@Override public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {     assertThat(taskState, instanceOf(RollupJobStatus.class)).     int c = counter.get().     if (c == 0) {         assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).     } else if (c == 1) {         assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STOPPED)).     } else {         fail("Should not have updated persistent statuses > 2 times").     }     listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).     counter.incrementAndGet(). }
false;public;1;6;;@Override public void onResponse(StartRollupJobAction.Response response) {     assertTrue(response.isStarted()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     latch.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;1;4;;@Override public void onResponse(StopRollupJobAction.Response response) {     assertTrue(response.isStopped()). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("should not have entered onFailure"). }
false;public;1;4;;@Override public void onResponse(StartRollupJobAction.Response response) {     fail("should not have entered onResponse"). }
false;public;1;6;;@Override public void onFailure(Exception e) {     assertThat(e.getMessage(), equalTo("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because state was [STOPPING]")).     latch2.countDown(). }
false;public;0;78;;public void testStartWhenStopping() throws InterruptedException {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     when(client.threadPool()).thenReturn(pool).     SchedulerEngine schedulerEngine = mock(SchedulerEngine.class).     AtomicInteger counter = new AtomicInteger(0).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, null, client, schedulerEngine, pool, Collections.emptyMap()) {          @Override         public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {             assertThat(taskState, instanceOf(RollupJobStatus.class)).             int c = counter.get().             if (c == 0) {                 assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).             } else if (c == 1) {                 assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STOPPED)).             } else {                 fail("Should not have updated persistent statuses > 2 times").             }             listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).             counter.incrementAndGet().         }     }.     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertNull(((RollupJobStatus) task.getStatus()).getPosition()).     CountDownLatch latch = new CountDownLatch(1).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             assertTrue(response.isStarted()).             assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     latch.await(3, TimeUnit.SECONDS).     task.triggered(new SchedulerEngine.Event(RollupJobTask.SCHEDULE_NAME + "_" + job.getConfig().getId(), 123, 123)).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.INDEXING)).     assertThat(task.getStats().getNumInvocations(), equalTo(1L)).     task.stop(new ActionListener<StopRollupJobAction.Response>() {          @Override         public void onResponse(StopRollupJobAction.Response response) {             assertTrue(response.isStopped()).         }          @Override         public void onFailure(Exception e) {             fail("should not have entered onFailure").         }     }).     CountDownLatch latch2 = new CountDownLatch(1).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             fail("should not have entered onResponse").         }          @Override         public void onFailure(Exception e) {             assertThat(e.getMessage(), equalTo("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because state was [STOPPING]")).             latch2.countDown().         }     }).     latch2.await(3, TimeUnit.SECONDS). }
false;public;2;8;;@Override public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {     assertThat(taskState, instanceOf(RollupJobStatus.class)).     assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).     listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))). }
false;public;1;6;;@Override public void onResponse(StartRollupJobAction.Response response) {     assertTrue(response.isStarted()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     latch.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;0;37;;public void testStartWhenStopped() throws InterruptedException {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.STOPPED, Collections.singletonMap("foo", "bar"), randomBoolean()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = mock(SchedulerEngine.class).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()) {          @Override         public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {             assertThat(taskState, instanceOf(RollupJobStatus.class)).             assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).             listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).         }     }.     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertThat(((RollupJobStatus) task.getStatus()).getPosition().size(), equalTo(1)).     assertTrue(((RollupJobStatus) task.getStatus()).getPosition().containsKey("foo")).     CountDownLatch latch = new CountDownLatch(1).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             assertTrue(response.isStarted()).             assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     latch.await(3, TimeUnit.SECONDS). }
false;public;2;8;;@Override public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {     assertThat(taskState, instanceOf(RollupJobStatus.class)).     assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).     listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))). }
false;public;1;6;;@Override public void onResponse(StartRollupJobAction.Response response) {     assertTrue(response.isStarted()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     latch.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;0;40;;public void testTriggerUnrelated() throws InterruptedException {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.STOPPED, Collections.singletonMap("foo", "bar"), randomBoolean()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = mock(SchedulerEngine.class).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()) {          @Override         public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {             assertThat(taskState, instanceOf(RollupJobStatus.class)).             assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).             listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).         }     }.     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertThat(((RollupJobStatus) task.getStatus()).getPosition().size(), equalTo(1)).     assertTrue(((RollupJobStatus) task.getStatus()).getPosition().containsKey("foo")).     CountDownLatch latch = new CountDownLatch(1).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             assertTrue(response.isStarted()).             assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     latch.await(3, TimeUnit.SECONDS).     task.triggered(new SchedulerEngine.Event("unrelated", 123, 123)).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)). }
false;public;2;8;;@Override public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {     assertThat(taskState, instanceOf(RollupJobStatus.class)).     assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).     listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))). }
false;public;1;6;;@Override public void onResponse(StartRollupJobAction.Response response) {     assertTrue(response.isStarted()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     latch.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;0;40;;public void testTrigger() throws InterruptedException {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     when(client.threadPool()).thenReturn(pool).     SchedulerEngine schedulerEngine = mock(SchedulerEngine.class).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, null, client, schedulerEngine, pool, Collections.emptyMap()) {          @Override         public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {             assertThat(taskState, instanceOf(RollupJobStatus.class)).             assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).             listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).         }     }.     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertNull(((RollupJobStatus) task.getStatus()).getPosition()).     CountDownLatch latch = new CountDownLatch(1).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             assertTrue(response.isStarted()).             assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     latch.await(3, TimeUnit.SECONDS).     task.triggered(new SchedulerEngine.Event(RollupJobTask.SCHEDULE_NAME + "_" + job.getConfig().getId(), 123, 123)).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.INDEXING)).     assertThat(task.getStats().getNumInvocations(), equalTo(1L)). }
false;public;2;18;;@Override public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {     Integer counterValue = counter.getAndIncrement().     if (counterValue == 0) {         assertThat(taskState, instanceOf(RollupJobStatus.class)).         assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).         listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).     } else if (counterValue == 1) {         // When we get here, doSaveState() was just invoked so we will have         // have upgraded IDs         RollupJobStatus s = (RollupJobStatus) this.getStatus().         assertTrue(s.isUpgradedDocumentID()).         finished.set(true).     } }
false;public;1;6;;@Override public void onResponse(StartRollupJobAction.Response response) {     assertTrue(response.isStarted()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     started.set(true). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;0;81;;@SuppressWarnings("unchecked") public void testTriggerWithoutHeaders() throws InterruptedException {     final ThreadContext threadContext = new ThreadContext(Settings.EMPTY).     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     AtomicBoolean started = new AtomicBoolean(false).     AtomicBoolean finished = new AtomicBoolean(false).     AtomicInteger counter = new AtomicInteger(0).     CountDownLatch latch = new CountDownLatch(1).     final ThreadPool threadPool = mock(ThreadPool.class).     when(client.threadPool()).thenReturn(threadPool).     when(threadPool.getThreadContext()).thenReturn(threadContext).     doAnswer(invocationOnMock -> {         assertTrue(threadContext.getHeaders().isEmpty()).         SearchResponse r = mock(SearchResponse.class).         when(r.getShardFailures()).thenReturn(ShardSearchFailure.EMPTY_ARRAY).         CompositeAggregation compositeAgg = mock(CompositeAggregation.class).         when(compositeAgg.getBuckets()).thenReturn(Collections.emptyList()).         when(compositeAgg.getName()).thenReturn(RollupField.NAME).         Aggregations aggs = new Aggregations(Collections.singletonList(compositeAgg)).         when(r.getAggregations()).thenReturn(aggs).         // Wait before progressing         latch.await().         ((ActionListener) invocationOnMock.getArguments()[2]).onResponse(r).         return null.     }).when(client).execute(anyObject(), anyObject(), anyObject()).     SchedulerEngine schedulerEngine = mock(SchedulerEngine.class).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, null, client, schedulerEngine, pool, Collections.emptyMap()) {          @Override         public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {             Integer counterValue = counter.getAndIncrement().             if (counterValue == 0) {                 assertThat(taskState, instanceOf(RollupJobStatus.class)).                 assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).                 listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).             } else if (counterValue == 1) {                 // When we get here, doSaveState() was just invoked so we will have                 // have upgraded IDs                 RollupJobStatus s = (RollupJobStatus) this.getStatus().                 assertTrue(s.isUpgradedDocumentID()).                 finished.set(true).             }         }     }.     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertNull(((RollupJobStatus) task.getStatus()).getPosition()).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             assertTrue(response.isStarted()).             assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).             started.set(true).         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     ESTestCase.awaitBusy(started::get).     task.triggered(new SchedulerEngine.Event(RollupJobTask.SCHEDULE_NAME + "_" + job.getConfig().getId(), 123, 123)).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.INDEXING)).     assertThat(task.getStats().getNumInvocations(), equalTo(1L)).     // Allow search response to return now     latch.countDown().     // Wait for the final persistent status to finish     ESTestCase.awaitBusy(finished::get). }
false;public;2;18;;@Override public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {     Integer counterValue = counter.getAndIncrement().     if (counterValue == 0) {         assertThat(taskState, instanceOf(RollupJobStatus.class)).         assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).         listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).     } else if (counterValue == 1) {         // When we get here, doSaveState() was just invoked so we will have         // have upgraded IDs         RollupJobStatus s = (RollupJobStatus) this.getStatus().         assertTrue(s.isUpgradedDocumentID()).         finished.set(true).     } }
false;public;1;6;;@Override public void onResponse(StartRollupJobAction.Response response) {     assertTrue(response.isStarted()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     started.set(true). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;0;87;;@SuppressWarnings("unchecked") public void testTriggerWithHeaders() throws InterruptedException {     final ThreadContext threadContext = new ThreadContext(Settings.EMPTY).     Map<String, String> headers = new HashMap<>(1).     headers.put("es-security-runas-user", "foo").     headers.put("_xpack_security_authentication", "bar").     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), headers).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     AtomicBoolean started = new AtomicBoolean(false).     AtomicBoolean finished = new AtomicBoolean(false).     AtomicInteger counter = new AtomicInteger(0).     CountDownLatch latch = new CountDownLatch(1).     final ThreadPool threadPool = mock(ThreadPool.class).     when(client.threadPool()).thenReturn(threadPool).     when(threadPool.getThreadContext()).thenReturn(threadContext).     doAnswer(invocationOnMock -> {         assertFalse(threadContext.getHeaders().isEmpty()).         assertThat(threadContext.getHeaders().get("es-security-runas-user"), equalTo("foo")).         assertThat(threadContext.getHeaders().get("_xpack_security_authentication"), equalTo("bar")).         SearchResponse r = mock(SearchResponse.class).         when(r.getShardFailures()).thenReturn(ShardSearchFailure.EMPTY_ARRAY).         CompositeAggregation compositeAgg = mock(CompositeAggregation.class).         when(compositeAgg.getBuckets()).thenReturn(Collections.emptyList()).         when(compositeAgg.getName()).thenReturn(RollupField.NAME).         Aggregations aggs = new Aggregations(Collections.singletonList(compositeAgg)).         when(r.getAggregations()).thenReturn(aggs).         // Wait before progressing         latch.await().         ((ActionListener) invocationOnMock.getArguments()[2]).onResponse(r).         return null.     }).when(client).execute(anyObject(), anyObject(), anyObject()).     SchedulerEngine schedulerEngine = mock(SchedulerEngine.class).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, null, client, schedulerEngine, pool, Collections.emptyMap()) {          @Override         public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {             Integer counterValue = counter.getAndIncrement().             if (counterValue == 0) {                 assertThat(taskState, instanceOf(RollupJobStatus.class)).                 assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).                 listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).             } else if (counterValue == 1) {                 // When we get here, doSaveState() was just invoked so we will have                 // have upgraded IDs                 RollupJobStatus s = (RollupJobStatus) this.getStatus().                 assertTrue(s.isUpgradedDocumentID()).                 finished.set(true).             }         }     }.     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertNull(((RollupJobStatus) task.getStatus()).getPosition()).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             assertTrue(response.isStarted()).             assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).             started.set(true).         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     ESTestCase.awaitBusy(started::get).     task.triggered(new SchedulerEngine.Event(RollupJobTask.SCHEDULE_NAME + "_" + job.getConfig().getId(), 123, 123)).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.INDEXING)).     assertThat(task.getStats().getNumInvocations(), equalTo(1L)).     // Allow search response to return now     latch.countDown().     // Wait for the final persistent status to finish     ESTestCase.awaitBusy(finished::get). }
false;public;2;18;;@Override public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {     Integer counterValue = counter.getAndIncrement().     if (counterValue == 0) {         assertThat(taskState, instanceOf(RollupJobStatus.class)).         assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).         listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).     } else if (counterValue == 1) {         // When we get here, doSaveState() was just invoked so we will have         // have upgraded IDs         RollupJobStatus s = (RollupJobStatus) this.getStatus().         assertTrue(s.isUpgradedDocumentID()).         finished.set(true).     } }
false;public;1;6;;@Override public void onResponse(StartRollupJobAction.Response response) {     assertTrue(response.isStarted()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     started.set(true). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;0;88;;@SuppressWarnings("unchecked") public void testSaveStateChangesIDScheme() throws InterruptedException {     final ThreadContext threadContext = new ThreadContext(Settings.EMPTY).     Map<String, String> headers = new HashMap<>(1).     headers.put("es-security-runas-user", "foo").     headers.put("_xpack_security_authentication", "bar").     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), headers).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     AtomicBoolean started = new AtomicBoolean(false).     AtomicBoolean finished = new AtomicBoolean(false).     AtomicInteger counter = new AtomicInteger(0).     CountDownLatch latch = new CountDownLatch(1).     final ThreadPool threadPool = mock(ThreadPool.class).     when(client.threadPool()).thenReturn(threadPool).     when(threadPool.getThreadContext()).thenReturn(threadContext).     doAnswer(invocationOnMock -> {         assertFalse(threadContext.getHeaders().isEmpty()).         assertThat(threadContext.getHeaders().get("es-security-runas-user"), equalTo("foo")).         assertThat(threadContext.getHeaders().get("_xpack_security_authentication"), equalTo("bar")).         SearchResponse r = mock(SearchResponse.class).         when(r.getShardFailures()).thenReturn(ShardSearchFailure.EMPTY_ARRAY).         CompositeAggregation compositeAgg = mock(CompositeAggregation.class).         when(compositeAgg.getBuckets()).thenReturn(Collections.emptyList()).         when(compositeAgg.getName()).thenReturn(RollupField.NAME).         Aggregations aggs = new Aggregations(Collections.singletonList(compositeAgg)).         when(r.getAggregations()).thenReturn(aggs).         // Wait before progressing         latch.await().         ((ActionListener) invocationOnMock.getArguments()[2]).onResponse(r).         return null.     }).when(client).execute(anyObject(), anyObject(), anyObject()).     SchedulerEngine schedulerEngine = mock(SchedulerEngine.class).     RollupJobStatus status = new RollupJobStatus(IndexerState.STOPPED, null, false).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()) {          @Override         public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {             Integer counterValue = counter.getAndIncrement().             if (counterValue == 0) {                 assertThat(taskState, instanceOf(RollupJobStatus.class)).                 assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).                 listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).             } else if (counterValue == 1) {                 // When we get here, doSaveState() was just invoked so we will have                 // have upgraded IDs                 RollupJobStatus s = (RollupJobStatus) this.getStatus().                 assertTrue(s.isUpgradedDocumentID()).                 finished.set(true).             }         }     }.     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertNull(((RollupJobStatus) task.getStatus()).getPosition()).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             assertTrue(response.isStarted()).             assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).             started.set(true).         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     ESTestCase.awaitBusy(started::get).     task.triggered(new SchedulerEngine.Event(RollupJobTask.SCHEDULE_NAME + "_" + job.getConfig().getId(), 123, 123)).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.INDEXING)).     assertThat(task.getStats().getNumInvocations(), equalTo(1L)).     // Allow search response to return now     latch.countDown().     // Wait for the final persistent status to finish     ESTestCase.awaitBusy(finished::get). }
false;public;1;5;;@Override public void onResponse(StopRollupJobAction.Response response) {     assertTrue(response.isStopped()).     latch.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;0;25;;public void testStopWhenStopped() throws InterruptedException {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.STOPPED, null, randomBoolean()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     CountDownLatch latch = new CountDownLatch(1).     task.stop(new ActionListener<StopRollupJobAction.Response>() {          @Override         public void onResponse(StopRollupJobAction.Response response) {             assertTrue(response.isStopped()).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     latch.await(3, TimeUnit.SECONDS). }
false;public;2;19;;@Override public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {     assertThat(taskState, instanceOf(RollupJobStatus.class)).     int c = counter.get().     if (c == 0) {         assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).     } else if (c == 1) {         assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STOPPED)).     } else if (c == 2) {         assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STOPPED)).     } else {         fail("Should not have updated persistent statuses > 3 times").     }     listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).     counter.incrementAndGet(). }
false;public;1;6;;@Override public void onResponse(StartRollupJobAction.Response response) {     assertTrue(response.isStarted()).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).     latch.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;1;4;;@Override public void onResponse(StopRollupJobAction.Response response) {     assertTrue(response.isStopped()). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("should not have entered onFailure"). }
false;public;1;5;;@Override public void onResponse(StopRollupJobAction.Response response) {     assertTrue(response.isStopped()).     latch2.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("Should not have entered onFailure"). }
false;public;0;80;;public void testStopWhenStopping() throws InterruptedException {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     when(client.threadPool()).thenReturn(pool).     SchedulerEngine schedulerEngine = mock(SchedulerEngine.class).     AtomicInteger counter = new AtomicInteger(0).     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, null, client, schedulerEngine, pool, Collections.emptyMap()) {          @Override         public void updatePersistentTaskState(PersistentTaskState taskState, ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {             assertThat(taskState, instanceOf(RollupJobStatus.class)).             int c = counter.get().             if (c == 0) {                 assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STARTED)).             } else if (c == 1) {                 assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STOPPED)).             } else if (c == 2) {                 assertThat(((RollupJobStatus) taskState).getIndexerState(), equalTo(IndexerState.STOPPED)).             } else {                 fail("Should not have updated persistent statuses > 3 times").             }             listener.onResponse(new PersistentTasksCustomMetaData.PersistentTask<>("foo", RollupField.TASK_NAME, job, 1, new PersistentTasksCustomMetaData.Assignment("foo", "foo"))).             counter.incrementAndGet().         }     }.     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     assertNull(((RollupJobStatus) task.getStatus()).getPosition()).     CountDownLatch latch = new CountDownLatch(1).     task.start(new ActionListener<StartRollupJobAction.Response>() {          @Override         public void onResponse(StartRollupJobAction.Response response) {             assertTrue(response.isStarted()).             assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STARTED)).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     latch.await(3, TimeUnit.SECONDS).     task.triggered(new SchedulerEngine.Event(RollupJobTask.SCHEDULE_NAME + "_" + job.getConfig().getId(), 123, 123)).     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.INDEXING)).     assertThat(task.getStats().getNumInvocations(), equalTo(1L)).     task.stop(new ActionListener<StopRollupJobAction.Response>() {          @Override         public void onResponse(StopRollupJobAction.Response response) {             assertTrue(response.isStopped()).         }          @Override         public void onFailure(Exception e) {             fail("should not have entered onFailure").         }     }).     CountDownLatch latch2 = new CountDownLatch(1).     task.stop(new ActionListener<StopRollupJobAction.Response>() {          @Override         public void onResponse(StopRollupJobAction.Response response) {             assertTrue(response.isStopped()).             latch2.countDown().         }          @Override         public void onFailure(Exception e) {             fail("Should not have entered onFailure").         }     }).     latch2.await(3, TimeUnit.SECONDS). }
false;public;0;4;;@Override public void markAsCompleted() {     latch.countDown(). }
false;public;1;5;;@Override public void onResponse(StopRollupJobAction.Response response) {     fail("Should not have entered onFailure"). }
false;public;1;6;;@Override public void onFailure(Exception e) {     assertThat(e.getMessage(), equalTo("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because state was [ABORTING]")).     latch.countDown(). }
false;public;0;39;;public void testStopWhenAborting() throws InterruptedException {     RollupJob job = new RollupJob(ConfigTestHelpers.randomRollupJobConfig(random()), Collections.emptyMap()).     RollupJobStatus status = new RollupJobStatus(IndexerState.STOPPED, null, randomBoolean()).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     SchedulerEngine schedulerEngine = new SchedulerEngine(SETTINGS, Clock.systemUTC()).     CountDownLatch latch = new CountDownLatch(2).     // This isn't really realistic, since start/stop/cancelled are all synchronized...     // the task would end before stop could be called.  But to help test out all pathways,     // just in case, we can override markAsCompleted so it's a no-op and test how stop     // handles the situation     RollupJobTask task = new RollupJobTask(1, "type", "action", new TaskId("node", 123), job, status, client, schedulerEngine, pool, Collections.emptyMap()) {          @Override         public void markAsCompleted() {             latch.countDown().         }     }.     assertThat(((RollupJobStatus) task.getStatus()).getIndexerState(), equalTo(IndexerState.STOPPED)).     task.onCancelled().     task.stop(new ActionListener<StopRollupJobAction.Response>() {          @Override         public void onResponse(StopRollupJobAction.Response response) {             fail("Should not have entered onFailure").         }          @Override         public void onFailure(Exception e) {             assertThat(e.getMessage(), equalTo("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because state was [ABORTING]")).             latch.countDown().         }     }).     latch.await(3, TimeUnit.SECONDS). }
