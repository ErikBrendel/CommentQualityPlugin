commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;public void testOneMatch() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(job.getGroupConfig().getDateHistogram().getInterval()).     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(builder, caps).     assertThat(bestCaps.size(), equalTo(1)). }
false;public;0;12;;public void testBiggerButCompatibleInterval() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1d")).     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(builder, caps).     assertThat(bestCaps.size(), equalTo(1)). }
false;public;0;12;;public void testBiggerButCompatibleFixedInterval() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("100s"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1000s")).     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(builder, caps).     assertThat(bestCaps.size(), equalTo(1)). }
false;public;0;12;;public void testBiggerButCompatibleFixedMillisInterval() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("100ms"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").interval(1000).     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(builder, caps).     assertThat(bestCaps.size(), equalTo(1)). }
false;public;0;13;;public void testIncompatibleInterval() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1d"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1h")).     RuntimeException e = expectThrows(RuntimeException.class, () -> RollupJobIdentifierUtils.findBestJobs(builder, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [date_histogram] agg on field " + "[foo] which also satisfies all requirements of query.")). }
false;public;0;13;;public void testIncompatibleFixedCalendarInterval() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("5d"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("day")).     RuntimeException e = expectThrows(RuntimeException.class, () -> RollupJobIdentifierUtils.findBestJobs(builder, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [date_histogram] agg on field " + "[foo] which also satisfies all requirements of query.")). }
false;public;0;14;;public void testBadTimeZone() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"), null, "CET")).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1h")).timeZone(ZoneOffset.UTC).     RuntimeException e = expectThrows(RuntimeException.class, () -> RollupJobIdentifierUtils.findBestJobs(builder, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [date_histogram] agg on field " + "[foo] which also satisfies all requirements of query.")). }
false;public;0;12;;public void testMetricOnlyAgg() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final List<MetricConfig> metrics = singletonList(new MetricConfig("bar", singletonList("max"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, metrics, null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     MaxAggregationBuilder max = new MaxAggregationBuilder("the_max").field("bar").     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(max, caps).     assertThat(bestCaps.size(), equalTo(1)). }
false;public;0;14;;public void testOneOfTwoMatchingCaps() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1h")).subAggregation(new MaxAggregationBuilder("the_max").field("bar")).     RuntimeException e = expectThrows(RuntimeException.class, () -> RollupJobIdentifierUtils.findBestJobs(builder, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [max] agg with name [the_max] which also satisfies " + "all requirements of query.")). }
false;public;0;21;;public void testTwoJobsSameRollupIndex() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = new HashSet<>(2).     caps.add(cap).     final GroupConfig group2 = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final RollupJobConfig job2 = new RollupJobConfig("foo2", "index", job.getRollupIndex(), "*/5 * * * * ?", 10, group2, emptyList(), null).     RollupJobCaps cap2 = new RollupJobCaps(job2).     caps.add(cap2).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1h")).     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(builder, caps).     // Both jobs functionally identical, so only one is actually needed to be searched     assertThat(bestCaps.size(), equalTo(1)). }
false;public;0;22;;public void testTwoJobsButBothPartialMatches() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final List<MetricConfig> metrics = singletonList(new MetricConfig("bar", singletonList("max"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, metrics, null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = new HashSet<>(2).     caps.add(cap).     // TODO Is it what we really want to test?     final RollupJobConfig job2 = new RollupJobConfig("foo2", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap2 = new RollupJobCaps(job2).     caps.add(cap2).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1h")).subAggregation(// <-- comes from job1     new MaxAggregationBuilder("the_max").field("bar")).subAggregation(// <-- comes from job2     new MinAggregationBuilder("the_min").field("bar")).     RuntimeException e = expectThrows(RuntimeException.class, () -> RollupJobIdentifierUtils.findBestJobs(builder, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [min] agg with name [the_min] which also " + "satisfies all requirements of query.")). }
false;public;0;21;;public void testComparableDifferentDateIntervals() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     final GroupConfig group2 = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1d"))).     final RollupJobConfig job2 = new RollupJobConfig("foo2", "index", job.getRollupIndex(), "*/5 * * * * ?", 10, group2, emptyList(), null).     RollupJobCaps cap2 = new RollupJobCaps(job2).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1d")).     Set<RollupJobCaps> caps = new HashSet<>(2).     caps.add(cap).     caps.add(cap2).     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(builder, caps).     assertThat(bestCaps.size(), equalTo(1)).     assertTrue(bestCaps.contains(cap2)). }
false;public;0;21;;public void testComparableDifferentDateIntervalsOnlyOneWorks() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     final GroupConfig group2 = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1d"))).     final RollupJobConfig job2 = new RollupJobConfig("foo2", "index", job.getRollupIndex(), "*/5 * * * * ?", 10, group2, emptyList(), null).     RollupJobCaps cap2 = new RollupJobCaps(job2).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1h")).     Set<RollupJobCaps> caps = new HashSet<>(2).     caps.add(cap).     caps.add(cap2).     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(builder, caps).     assertThat(bestCaps.size(), equalTo(1)).     assertTrue(bestCaps.contains(cap)). }
false;public;0;23;;public void testComparableNoHistoVsHisto() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     final HistogramGroupConfig histoConfig = new HistogramGroupConfig(100L, "bar").     final GroupConfig group2 = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h")), histoConfig, null).     final RollupJobConfig job2 = new RollupJobConfig("foo2", "index", job.getRollupIndex(), "*/5 * * * * ?", 10, group2, emptyList(), null).     RollupJobCaps cap2 = new RollupJobCaps(job2).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1h")).subAggregation(new HistogramAggregationBuilder("histo").field("bar").interval(100)).     Set<RollupJobCaps> caps = new HashSet<>(2).     caps.add(cap).     caps.add(cap2).     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(builder, caps).     assertThat(bestCaps.size(), equalTo(1)).     assertTrue(bestCaps.contains(cap2)). }
false;public;0;23;;public void testComparableNoTermsVsTerms() {     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     final TermsGroupConfig termsConfig = new TermsGroupConfig("bar").     final GroupConfig group2 = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h")), null, termsConfig).     final RollupJobConfig job2 = new RollupJobConfig("foo2", "index", job.getRollupIndex(), "*/5 * * * * ?", 10, group2, emptyList(), null).     RollupJobCaps cap2 = new RollupJobCaps(job2).     DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("foo").field("foo").dateHistogramInterval(new DateHistogramInterval("1h")).subAggregation(new TermsAggregationBuilder("histo", ValueType.STRING).field("bar")).     Set<RollupJobCaps> caps = new HashSet<>(2).     caps.add(cap).     caps.add(cap2).     Set<RollupJobCaps> bestCaps = RollupJobIdentifierUtils.findBestJobs(builder, caps).     assertThat(bestCaps.size(), equalTo(1)).     assertTrue(bestCaps.contains(cap2)). }
false;public;0;23;;public void testHistoSameNameWrongTypeInCaps() {     HistogramAggregationBuilder histo = new HistogramAggregationBuilder("test_histo").     histo.field("foo").interval(1L).subAggregation(new MaxAggregationBuilder("the_max").field("max_field")).subAggregation(new AvgAggregationBuilder("the_avg").field("avg_field")).     final GroupConfig group = new GroupConfig(// NOTE same name but wrong type     new DateHistogramGroupConfig("foo", new DateHistogramInterval("1d"), null, DateTimeZone.UTC.getID()), // <-- NOTE right type but wrong name     new HistogramGroupConfig(1L, "baz"), null).     final List<MetricConfig> metrics = Arrays.asList(new MetricConfig("max_field", singletonList("max")), new MetricConfig("avg_field", singletonList("avg"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, metrics, null).     Set<RollupJobCaps> caps = singletonSet(new RollupJobCaps(job)).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> RollupJobIdentifierUtils.findBestJobs(histo, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [histogram] " + "agg on field [foo] which also satisfies all requirements of query.")). }
false;public;0;20;;public void testMissingDateHisto() {     DateHistogramAggregationBuilder histo = new DateHistogramAggregationBuilder("test_histo").     histo.dateHistogramInterval(new DateHistogramInterval("1d")).field("other_field").subAggregation(new MaxAggregationBuilder("the_max").field("max_field")).subAggregation(new AvgAggregationBuilder("the_avg").field("avg_field")).     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1d"), null, DateTimeZone.UTC.getID())).     final List<MetricConfig> metrics = Arrays.asList(new MetricConfig("max_field", singletonList("max")), new MetricConfig("avg_field", singletonList("avg"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, metrics, null).     Set<RollupJobCaps> caps = singletonSet(new RollupJobCaps(job)).     Exception e = expectThrows(IllegalArgumentException.class, () -> RollupJobIdentifierUtils.findBestJobs(histo, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [date_histogram] agg on field " + "[other_field] which also satisfies all requirements of query.")). }
false;public;0;18;;public void testNoMatchingInterval() {     DateHistogramAggregationBuilder histo = new DateHistogramAggregationBuilder("test_histo").     histo.interval(1).field("foo").subAggregation(new MaxAggregationBuilder("the_max").field("max_field")).subAggregation(new AvgAggregationBuilder("the_avg").field("avg_field")).     final GroupConfig group = new GroupConfig(// interval in job is much higher than agg interval above     new DateHistogramGroupConfig("foo", new DateHistogramInterval("100d"), null, DateTimeZone.UTC.getID())).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     Set<RollupJobCaps> caps = singletonSet(new RollupJobCaps(job)).     Exception e = expectThrows(RuntimeException.class, () -> RollupJobIdentifierUtils.findBestJobs(histo, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [date_histogram] agg on field [foo] " + "which also satisfies all requirements of query.")). }
false;public;0;21;;public void testDateHistoMissingFieldInCaps() {     DateHistogramAggregationBuilder histo = new DateHistogramAggregationBuilder("test_histo").     histo.dateHistogramInterval(new DateHistogramInterval("1d")).field("foo").subAggregation(new MaxAggregationBuilder("the_max").field("max_field")).subAggregation(new AvgAggregationBuilder("the_avg").field("avg_field")).     final GroupConfig group = new GroupConfig(// NOTE different field from the one in the query     new DateHistogramGroupConfig("bar", new DateHistogramInterval("1d"), null, DateTimeZone.UTC.getID())).     final List<MetricConfig> metrics = Arrays.asList(new MetricConfig("max_field", singletonList("max")), new MetricConfig("avg_field", singletonList("avg"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, metrics, null).     Set<RollupJobCaps> caps = singletonSet(new RollupJobCaps(job)).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> RollupJobIdentifierUtils.findBestJobs(histo, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [date_histogram] agg on field [foo] which also " + "satisfies all requirements of query.")). }
false;public;0;22;;public void testHistoMissingFieldInCaps() {     HistogramAggregationBuilder histo = new HistogramAggregationBuilder("test_histo").     histo.interval(1).field("foo").subAggregation(new MaxAggregationBuilder("the_max").field("max_field")).subAggregation(new AvgAggregationBuilder("the_avg").field("avg_field")).     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("bar", new DateHistogramInterval("1d"), null, DateTimeZone.UTC.getID()), // <-- NOTE right type but wrong name     new HistogramGroupConfig(1L, "baz"), null).     final List<MetricConfig> metrics = Arrays.asList(new MetricConfig("max_field", singletonList("max")), new MetricConfig("avg_field", singletonList("avg"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, metrics, null).     Set<RollupJobCaps> caps = singletonSet(new RollupJobCaps(job)).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> RollupJobIdentifierUtils.findBestJobs(histo, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [histogram] agg on field [foo] which also " + "satisfies all requirements of query.")). }
false;public;0;20;;public void testNoMatchingHistoInterval() {     HistogramAggregationBuilder histo = new HistogramAggregationBuilder("test_histo").     histo.interval(1).field("bar").subAggregation(new MaxAggregationBuilder("the_max").field("max_field")).subAggregation(new AvgAggregationBuilder("the_avg").field("avg_field")).     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1d"), null, DateTimeZone.UTC.getID()), // <-- NOTE right type but wrong name     new HistogramGroupConfig(1L, "baz"), null).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     Set<RollupJobCaps> caps = singletonSet(new RollupJobCaps(job)).     Exception e = expectThrows(RuntimeException.class, () -> RollupJobIdentifierUtils.findBestJobs(histo, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [histogram] agg on field " + "[bar] which also satisfies all requirements of query.")). }
false;public;0;20;;public void testHistoIntervalNotMultiple() {     HistogramAggregationBuilder histo = new HistogramAggregationBuilder("test_histo").     // <--- interval is not a multiple of 3     histo.interval(10).field("bar").subAggregation(new MaxAggregationBuilder("the_max").field("max_field")).subAggregation(new AvgAggregationBuilder("the_avg").field("avg_field")).     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1d"), null, "UTC"), new HistogramGroupConfig(3L, "bar"), null).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     RollupJobCaps cap = new RollupJobCaps(job).     Set<RollupJobCaps> caps = singletonSet(cap).     Exception e = expectThrows(RuntimeException.class, () -> RollupJobIdentifierUtils.findBestJobs(histo, caps)).     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [histogram] agg on field " + "[bar] which also satisfies all requirements of query.")). }
false;public;0;31;;public void testMissingMetric() {     int i = ESTestCase.randomIntBetween(0, 3).     final GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", new DateHistogramInterval("1h"))).     final List<MetricConfig> metrics = singletonList(new MetricConfig("foo", Arrays.asList("avg", "max", "min", "sum"))).     final RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).     Set<RollupJobCaps> caps = singletonSet(new RollupJobCaps(job)).     String aggType.     Exception e.     if (i == 0) {         e = expectThrows(IllegalArgumentException.class, () -> RollupJobIdentifierUtils.findBestJobs(new MaxAggregationBuilder("test_metric").field("other_field"), caps)).         aggType = "max".     } else if (i == 1) {         e = expectThrows(IllegalArgumentException.class, () -> RollupJobIdentifierUtils.findBestJobs(new MinAggregationBuilder("test_metric").field("other_field"), caps)).         aggType = "min".     } else if (i == 2) {         e = expectThrows(IllegalArgumentException.class, () -> RollupJobIdentifierUtils.findBestJobs(new SumAggregationBuilder("test_metric").field("other_field"), caps)).         aggType = "sum".     } else {         e = expectThrows(IllegalArgumentException.class, () -> RollupJobIdentifierUtils.findBestJobs(new AvgAggregationBuilder("test_metric").field("other_field"), caps)).         aggType = "avg".     }     assertThat(e.getMessage(), equalTo("There is not a rollup job that has a [" + aggType + "] agg with name " + "[test_metric] which also satisfies all requirements of query.")). }
false;public;0;67;;public void testValidateFixedInterval() {     boolean valid = RollupJobIdentifierUtils.validateFixedInterval(100, new DateHistogramInterval("100ms")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(200, new DateHistogramInterval("100ms")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(1000, new DateHistogramInterval("200ms")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(5 * 60 * 1000, new DateHistogramInterval("5m")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(10 * 5 * 60 * 1000, new DateHistogramInterval("5m")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(100, new DateHistogramInterval("500ms")).     assertFalse(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(100, new DateHistogramInterval("5m")).     assertFalse(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(100, new DateHistogramInterval("minute")).     assertFalse(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(100, new DateHistogramInterval("second")).     assertFalse(valid).     // -----------     // Same tests, with both being DateHistoIntervals     // -----------     valid = RollupJobIdentifierUtils.validateFixedInterval(new DateHistogramInterval("100ms"), new DateHistogramInterval("100ms")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(new DateHistogramInterval("200ms"), new DateHistogramInterval("100ms")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(new DateHistogramInterval("1000ms"), new DateHistogramInterval("200ms")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(new DateHistogramInterval("5m"), new DateHistogramInterval("5m")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(new DateHistogramInterval("20m"), new DateHistogramInterval("5m")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(new DateHistogramInterval("100ms"), new DateHistogramInterval("500ms")).     assertFalse(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(new DateHistogramInterval("100ms"), new DateHistogramInterval("5m")).     assertFalse(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(new DateHistogramInterval("100ms"), new DateHistogramInterval("minute")).     assertFalse(valid).     valid = RollupJobIdentifierUtils.validateFixedInterval(new DateHistogramInterval("100ms"), new DateHistogramInterval("second")).     assertFalse(valid). }
false;public;0;30;;public void testValidateCalendarInterval() {     boolean valid = RollupJobIdentifierUtils.validateCalendarInterval(new DateHistogramInterval("second"), new DateHistogramInterval("second")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateCalendarInterval(new DateHistogramInterval("minute"), new DateHistogramInterval("second")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateCalendarInterval(new DateHistogramInterval("month"), new DateHistogramInterval("day")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateCalendarInterval(new DateHistogramInterval("1d"), new DateHistogramInterval("1s")).     assertTrue(valid).     valid = RollupJobIdentifierUtils.validateCalendarInterval(new DateHistogramInterval("second"), new DateHistogramInterval("minute")).     assertFalse(valid).     valid = RollupJobIdentifierUtils.validateCalendarInterval(new DateHistogramInterval("second"), new DateHistogramInterval("1m")).     assertFalse(valid).     // Fails because both are actually fixed     valid = RollupJobIdentifierUtils.validateCalendarInterval(new DateHistogramInterval("100ms"), new DateHistogramInterval("100ms")).     assertFalse(valid). }
false;public;0;25;;public void testComparatorMixed() {     int numCaps = randomIntBetween(1, 10).     List<RollupJobCaps> caps = new ArrayList<>(numCaps).     for (int i = 0. i < numCaps. i++) {         DateHistogramInterval interval = getRandomInterval().         GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", interval)).         RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).         RollupJobCaps cap = new RollupJobCaps(job).         caps.add(cap).     }     caps.sort(RollupJobIdentifierUtils.COMPARATOR).     // This only tests for calendar/fixed ordering, ignoring the other criteria     for (int i = 1. i < numCaps. i++) {         RollupJobCaps a = caps.get(i - 1).         RollupJobCaps b = caps.get(i).         long aMillis = getMillis(a).         long bMillis = getMillis(b).         assertThat(aMillis, greaterThanOrEqualTo(bMillis)).     } }
false;public;0;25;;public void testComparatorFixed() {     int numCaps = randomIntBetween(1, 10).     List<RollupJobCaps> caps = new ArrayList<>(numCaps).     for (int i = 0. i < numCaps. i++) {         DateHistogramInterval interval = getRandomFixedInterval().         GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", interval)).         RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).         RollupJobCaps cap = new RollupJobCaps(job).         caps.add(cap).     }     caps.sort(RollupJobIdentifierUtils.COMPARATOR).     // This only tests for fixed ordering, ignoring the other criteria     for (int i = 1. i < numCaps. i++) {         RollupJobCaps a = caps.get(i - 1).         RollupJobCaps b = caps.get(i).         long aMillis = getMillis(a).         long bMillis = getMillis(b).         assertThat(aMillis, greaterThanOrEqualTo(bMillis)).     } }
false;public;0;25;;public void testComparatorCalendar() {     int numCaps = randomIntBetween(1, 10).     List<RollupJobCaps> caps = new ArrayList<>(numCaps).     for (int i = 0. i < numCaps. i++) {         DateHistogramInterval interval = getRandomCalendarInterval().         GroupConfig group = new GroupConfig(new DateHistogramGroupConfig("foo", interval)).         RollupJobConfig job = new RollupJobConfig("foo", "index", "rollup", "*/5 * * * * ?", 10, group, emptyList(), null).         RollupJobCaps cap = new RollupJobCaps(job).         caps.add(cap).     }     caps.sort(RollupJobIdentifierUtils.COMPARATOR).     // This only tests for calendar ordering, ignoring the other criteria     for (int i = 1. i < numCaps. i++) {         RollupJobCaps a = caps.get(i - 1).         RollupJobCaps b = caps.get(i).         long aMillis = getMillis(a).         long bMillis = getMillis(b).         assertThat(aMillis, greaterThanOrEqualTo(bMillis)).     } }
false;private,static;1;10;;private static long getMillis(RollupJobCaps cap) {     for (RollupJobCaps.RollupFieldCaps fieldCaps : cap.getFieldCaps().values()) {         for (Map<String, Object> agg : fieldCaps.getAggs()) {             if (agg.get(RollupField.AGG).equals(DateHistogramAggregationBuilder.NAME)) {                 return RollupJobIdentifierUtils.getMillisFixedOrCalendar((String) agg.get(RollupField.INTERVAL)).             }         }     }     return Long.MAX_VALUE. }
false;private,static;0;6;;private static DateHistogramInterval getRandomInterval() {     if (randomBoolean()) {         return getRandomFixedInterval().     }     return getRandomCalendarInterval(). }
false;private,static;0;17;;private static DateHistogramInterval getRandomFixedInterval() {     int value = randomIntBetween(1, 1000).     String unit.     int randomValue = randomInt(4).     if (randomValue == 0) {         unit = "ms".     } else if (randomValue == 1) {         unit = "s".     } else if (randomValue == 2) {         unit = "m".     } else if (randomValue == 3) {         unit = "h".     } else {         unit = "d".     }     return new DateHistogramInterval(Integer.toString(value) + unit). }
false;private,static;0;3;;private static DateHistogramInterval getRandomCalendarInterval() {     return new DateHistogramInterval(UNITS.get(randomIntBetween(0, UNITS.size() - 1))). }
false;private;1;5;;private Set<RollupJobCaps> singletonSet(RollupJobCaps cap) {     Set<RollupJobCaps> caps = new HashSet<>().     caps.add(cap).     return caps. }
