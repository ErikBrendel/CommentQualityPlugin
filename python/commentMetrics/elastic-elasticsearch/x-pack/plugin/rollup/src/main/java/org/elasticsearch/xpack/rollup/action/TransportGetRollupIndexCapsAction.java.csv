commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;11;;@Override protected void doExecute(Task task, GetRollupIndexCapsAction.Request request, ActionListener<GetRollupIndexCapsAction.Response> listener) {     IndexNameExpressionResolver resolver = new IndexNameExpressionResolver().     String[] indices = resolver.concreteIndexNames(clusterService.state(), request.indicesOptions(), request.indices()).     Map<String, RollableIndexCaps> allCaps = getCapsByRollupIndex(Arrays.asList(indices), clusterService.state().getMetaData().indices()).     listener.onResponse(new GetRollupIndexCapsAction.Response(allCaps)). }
false;static;2;27;;static Map<String, RollableIndexCaps> getCapsByRollupIndex(List<String> resolvedIndexNames, ImmutableOpenMap<String, IndexMetaData> indices) {     Map<String, List<RollupJobCaps>> allCaps = new TreeMap<>().     StreamSupport.stream(indices.spliterator(), false).filter(entry -> resolvedIndexNames.contains(entry.key)).forEach(entry -> {         // Does this index have rollup metadata?         TransportGetRollupCapsAction.findRollupIndexCaps(entry.key, entry.value).ifPresent(cap -> {             cap.getJobCaps().forEach(jobCap -> {                 // Do we already have an entry for this index?                 List<RollupJobCaps> indexCaps = allCaps.get(jobCap.getRollupIndex()).                 if (indexCaps == null) {                     indexCaps = new ArrayList<>().                 }                 indexCaps.add(jobCap).                 allCaps.put(jobCap.getRollupIndex(), indexCaps).             }).         }).     }).     // Convert the mutable lists into the RollableIndexCaps     return allCaps.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> new RollableIndexCaps(e.getKey(), e.getValue()))). }
