commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected AcknowledgedResponse newResponse() {     return new AcknowledgedResponse(). }
false;public;1;11;;@Override public void onResponse(FieldCapabilitiesResponse fieldCapabilitiesResponse) {     ActionRequestValidationException validationException = request.validateMappings(fieldCapabilitiesResponse.get()).     if (validationException != null) {         listener.onFailure(validationException).         return.     }     RollupJob job = createRollupJob(request.getConfig(), threadPool).     createIndex(job, listener, persistentTasksService, client, logger). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;protected;3;34;;@Override protected void masterOperation(PutRollupJobAction.Request request, ClusterState clusterState, ActionListener<AcknowledgedResponse> listener) {     if (!licenseState.isRollupAllowed()) {         listener.onFailure(LicenseUtils.newComplianceException(XPackField.ROLLUP)).         return.     }     XPackPlugin.checkReadyForXPackCustomMetadata(clusterState).     FieldCapabilitiesRequest fieldCapsRequest = new FieldCapabilitiesRequest().indices(request.getConfig().getIndexPattern()).fields(request.getConfig().getAllFields().toArray(new String[0])).     client.fieldCaps(fieldCapsRequest, new ActionListener<FieldCapabilitiesResponse>() {          @Override         public void onResponse(FieldCapabilitiesResponse fieldCapabilitiesResponse) {             ActionRequestValidationException validationException = request.validateMappings(fieldCapabilitiesResponse.get()).             if (validationException != null) {                 listener.onFailure(validationException).                 return.             }             RollupJob job = createRollupJob(request.getConfig(), threadPool).             createIndex(job, listener, persistentTasksService, client, logger).         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }). }
false;private,static;2;7;;private static RollupJob createRollupJob(RollupJobConfig config, ThreadPool threadPool) {     // ensure we only filter for the allowed headers     Map<String, String> filteredHeaders = threadPool.getThreadContext().getHeaders().entrySet().stream().filter(e -> Rollup.HEADER_FILTERS.contains(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).     return new RollupJob(config, filteredHeaders). }
false;static;5;23;;static void createIndex(RollupJob job, ActionListener<AcknowledgedResponse> listener, PersistentTasksService persistentTasksService, Client client, Logger logger) {     String jobMetadata = "\"" + job.getConfig().getId() + "\":" + job.getConfig().toJSONString().     String mapping = Rollup.DYNAMIC_MAPPING_TEMPLATE.replace(Rollup.MAPPING_METADATA_PLACEHOLDER, jobMetadata).     CreateIndexRequest request = new CreateIndexRequest(job.getConfig().getRollupIndex()).     request.mapping(RollupField.TYPE_NAME, mapping, XContentType.JSON).     client.execute(CreateIndexAction.INSTANCE, request, ActionListener.wrap(createIndexResponse -> startPersistentTask(job, listener, persistentTasksService), e -> {         if (e instanceof ResourceAlreadyExistsException) {             logger.debug("Rolled index already exists for rollup job [" + job.getConfig().getId() + "], updating metadata.").             updateMapping(job, listener, persistentTasksService, client, logger).         } else {             String msg = "Could not create index for rollup job [" + job.getConfig().getId() + "]".             logger.error(msg).             listener.onFailure(new RuntimeException(msg, e)).         }     })). }
false;static;5;64;;@SuppressWarnings("unchecked") static void updateMapping(RollupJob job, ActionListener<AcknowledgedResponse> listener, PersistentTasksService persistentTasksService, Client client, Logger logger) {     final String indexName = job.getConfig().getRollupIndex().     CheckedConsumer<GetMappingsResponse, Exception> getMappingResponseHandler = getMappingResponse -> {         MappingMetaData mappings = getMappingResponse.getMappings().get(indexName).get(RollupField.TYPE_NAME).         Object m = mappings.getSourceAsMap().get("_meta").         if (m == null) {             String msg = "Rollup data cannot be added to existing indices that contain non-rollup data (expected " + "to find _meta key in mapping of rollup index [" + indexName + "] but not found).".             logger.error(msg).             listener.onFailure(new RuntimeException(msg)).             return.         }         Map<String, Object> metadata = (Map<String, Object>) m.         if (metadata.get(RollupField.ROLLUP_META) == null) {             String msg = "Rollup data cannot be added to existing indices that contain non-rollup data (expected " + "to find rollup meta key [" + RollupField.ROLLUP_META + "] in mapping of rollup index [" + indexName + "] but not found).".             logger.error(msg).             listener.onFailure(new RuntimeException(msg)).             return.         }         Map<String, Object> rollupMeta = (Map<String, Object>) ((Map<String, Object>) m).get(RollupField.ROLLUP_META).         String stringVersion = (String) ((Map<String, Object>) m).get(Rollup.ROLLUP_TEMPLATE_VERSION_FIELD).         if (stringVersion == null) {             listener.onFailure(new IllegalStateException("Could not determine version of existing rollup metadata for index [" + indexName + "]")).             return.         }         if (rollupMeta.get(job.getConfig().getId()) != null) {             String msg = "Cannot create rollup job [" + job.getConfig().getId() + "] because job was previously created (existing metadata).".             logger.error(msg).             listener.onFailure(new ElasticsearchStatusException(msg, RestStatus.CONFLICT)).             return.         }         rollupMeta.put(job.getConfig().getId(), job.getConfig()).         metadata.put(RollupField.ROLLUP_META, rollupMeta).         Map<String, Object> newMapping = mappings.getSourceAsMap().         newMapping.put("_meta", metadata).         PutMappingRequest request = new PutMappingRequest(indexName).         request.type(RollupField.TYPE_NAME).         request.source(newMapping).         client.execute(PutMappingAction.INSTANCE, request, ActionListener.wrap(putMappingResponse -> startPersistentTask(job, listener, persistentTasksService), listener::onFailure)).     }.     GetMappingsRequest request = new GetMappingsRequest().     client.execute(GetMappingsAction.INSTANCE, request, ActionListener.wrap(getMappingResponseHandler, e -> {         String msg = "Could not update mappings for rollup job [" + job.getConfig().getId() + "]".         logger.error(msg).         listener.onFailure(new RuntimeException(msg, e)).     })). }
false;static;3;14;;static void startPersistentTask(RollupJob job, ActionListener<AcknowledgedResponse> listener, PersistentTasksService persistentTasksService) {     persistentTasksService.sendStartRequest(job.getConfig().getId(), RollupField.TASK_NAME, job, ActionListener.wrap(rollupConfigPersistentTask -> waitForRollupStarted(job, listener, persistentTasksService), e -> {         if (e instanceof ResourceAlreadyExistsException) {             e = new ElasticsearchStatusException("Cannot create job [" + job.getConfig().getId() + "] because it has already been created (task exists)", RestStatus.CONFLICT, e).         }         listener.onFailure(e).     })). }
false;public;1;4;;@Override public void onResponse(PersistentTasksCustomMetaData.PersistentTask<RollupJob> task) {     listener.onResponse(new AcknowledgedResponse(true)). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;1;5;;@Override public void onTimeout(TimeValue timeout) {     listener.onFailure(new ElasticsearchException("Creation of task for Rollup Job ID [" + job.getConfig().getId() + "] timed out after [" + timeout + "]")). }
false;private,static;3;21;;private static void waitForRollupStarted(RollupJob job, ActionListener<AcknowledgedResponse> listener, PersistentTasksService persistentTasksService) {     persistentTasksService.waitForPersistentTaskCondition(job.getConfig().getId(), Objects::nonNull, job.getConfig().getTimeout(), new PersistentTasksService.WaitForPersistentTaskListener<RollupJob>() {          @Override         public void onResponse(PersistentTasksCustomMetaData.PersistentTask<RollupJob> task) {             listener.onResponse(new AcknowledgedResponse(true)).         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }          @Override         public void onTimeout(TimeValue timeout) {             listener.onFailure(new ElasticsearchException("Creation of task for Rollup Job ID [" + job.getConfig().getId() + "] timed out after [" + timeout + "]")).         }     }). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(PutRollupJobAction.Request request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
