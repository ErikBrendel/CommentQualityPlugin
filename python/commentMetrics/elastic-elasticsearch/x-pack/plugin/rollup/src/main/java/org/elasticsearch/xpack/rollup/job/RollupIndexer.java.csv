# id;timestamp;commentText;codeText;commentWords;codeWords
RollupIndexer -> public Map<String, Object> getPosition();1524684173;Get the current position of the indexer.;public Map<String, Object> getPosition() {_        return position.get()__    };get,the,current,position,of,the,indexer;public,map,string,object,get,position,return,position,get
RollupIndexer -> public Map<String, Object> getPosition();1531179852;Get the current position of the indexer.;public Map<String, Object> getPosition() {_        return position.get()__    };get,the,current,position,of,the,indexer;public,map,string,object,get,position,return,position,get
RollupIndexer -> public Map<String, Object> getPosition();1531729807;Get the current position of the indexer.;public Map<String, Object> getPosition() {_        return position.get()__    };get,the,current,position,of,the,indexer;public,map,string,object,get,position,return,position,get
RollupIndexer -> public Map<String, Object> getPosition();1532028790;Get the current position of the indexer.;public Map<String, Object> getPosition() {_        return position.get()__    };get,the,current,position,of,the,indexer;public,map,string,object,get,position,return,position,get
RollupIndexer -> public Map<String, Object> getPosition();1533143718;Get the current position of the indexer.;public Map<String, Object> getPosition() {_        return position.get()__    };get,the,current,position,of,the,indexer;public,map,string,object,get,position,return,position,get
RollupIndexer -> public Map<String, Object> getPosition();1533319589;Get the current position of the indexer.;public Map<String, Object> getPosition() {_        return position.get()__    };get,the,current,position,of,the,indexer;public,map,string,object,get,position,return,position,get
RollupIndexer -> public Map<String, Object> getPosition();1533641732;Get the current position of the indexer.;public Map<String, Object> getPosition() {_        return position.get()__    };get,the,current,position,of,the,indexer;public,map,string,object,get,position,return,position,get
RollupIndexer -> public Map<String, Object> getPosition();1535139672;Get the current position of the indexer.;public Map<String, Object> getPosition() {_        return position.get()__    };get,the,current,position,of,the,indexer;public,map,string,object,get,position,return,position,get
RollupIndexer -> public Map<String, Object> getPosition();1535383145;Get the current position of the indexer.;public Map<String, Object> getPosition() {_        return position.get()__    };get,the,current,position,of,the,indexer;public,map,string,object,get,position,return,position,get
RollupIndexer -> protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;1524684173;Executes the {@link BulkRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The bulk request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;executes,the,link,bulk,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,bulk,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,bulk,bulk,request,request,action,listener,bulk,response,next,phase
RollupIndexer -> protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;1531179852;Executes the {@link BulkRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The bulk request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;executes,the,link,bulk,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,bulk,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,bulk,bulk,request,request,action,listener,bulk,response,next,phase
RollupIndexer -> protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;1531729807;Executes the {@link BulkRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The bulk request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;executes,the,link,bulk,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,bulk,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,bulk,bulk,request,request,action,listener,bulk,response,next,phase
RollupIndexer -> protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;1532028790;Executes the {@link BulkRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The bulk request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;executes,the,link,bulk,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,bulk,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,bulk,bulk,request,request,action,listener,bulk,response,next,phase
RollupIndexer -> protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;1533143718;Executes the {@link BulkRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The bulk request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;executes,the,link,bulk,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,bulk,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,bulk,bulk,request,request,action,listener,bulk,response,next,phase
RollupIndexer -> protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;1533319589;Executes the {@link BulkRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The bulk request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;executes,the,link,bulk,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,bulk,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,bulk,bulk,request,request,action,listener,bulk,response,next,phase
RollupIndexer -> protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;1533641732;Executes the {@link BulkRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The bulk request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;executes,the,link,bulk,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,bulk,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,bulk,bulk,request,request,action,listener,bulk,response,next,phase
RollupIndexer -> protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;1535139672;Executes the {@link BulkRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The bulk request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;executes,the,link,bulk,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,bulk,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,bulk,bulk,request,request,action,listener,bulk,response,next,phase
RollupIndexer -> protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;1535383145;Executes the {@link BulkRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The bulk request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase)_;executes,the,link,bulk,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,bulk,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,bulk,bulk,request,request,action,listener,bulk,response,next,phase
RollupIndexer -> public RollupJobStats getStats();1524684173;Get the stats of this indexer.;public RollupJobStats getStats() {_        return stats__    };get,the,stats,of,this,indexer;public,rollup,job,stats,get,stats,return,stats
RollupIndexer -> public RollupJobStats getStats();1531179852;Get the stats of this indexer.;public RollupJobStats getStats() {_        return stats__    };get,the,stats,of,this,indexer;public,rollup,job,stats,get,stats,return,stats
RollupIndexer -> public RollupJobStats getStats();1531729807;Get the stats of this indexer.;public RollupJobStats getStats() {_        return stats__    };get,the,stats,of,this,indexer;public,rollup,job,stats,get,stats,return,stats
RollupIndexer -> public RollupJobStats getStats();1532028790;Get the stats of this indexer.;public RollupJobStats getStats() {_        return stats__    };get,the,stats,of,this,indexer;public,rollup,job,stats,get,stats,return,stats
RollupIndexer -> public RollupJobStats getStats();1533143718;Get the stats of this indexer.;public RollupJobStats getStats() {_        return stats__    };get,the,stats,of,this,indexer;public,rollup,job,stats,get,stats,return,stats
RollupIndexer -> public RollupJobStats getStats();1533319589;Get the stats of this indexer.;public RollupJobStats getStats() {_        return stats__    };get,the,stats,of,this,indexer;public,rollup,job,stats,get,stats,return,stats
RollupIndexer -> public RollupJobStats getStats();1533641732;Get the stats of this indexer.;public RollupJobStats getStats() {_        return stats__    };get,the,stats,of,this,indexer;public,rollup,job,stats,get,stats,return,stats
RollupIndexer -> public RollupJobStats getStats();1535139672;Get the stats of this indexer.;public RollupJobStats getStats() {_        return stats__    };get,the,stats,of,this,indexer;public,rollup,job,stats,get,stats,return,stats
RollupIndexer -> public RollupJobStats getStats();1535383145;Get the stats of this indexer.;public RollupJobStats getStats() {_        return stats__    };get,the,stats,of,this,indexer;public,rollup,job,stats,get,stats,return,stats
RollupIndexer -> static List<AggregationBuilder> createAggregationBuilders(final List<MetricConfig> metricsConfigs);1535383145;This returns a set of aggregation builders which represent the configured_set of metrics. Used to iterate over historical data.;static List<AggregationBuilder> createAggregationBuilders(final List<MetricConfig> metricsConfigs) {_        final List<AggregationBuilder> builders = new ArrayList<>()__        if (metricsConfigs != null) {_            for (MetricConfig metricConfig : metricsConfigs) {_                final List<String> metrics = metricConfig.getMetrics()__                if (metrics.isEmpty() == false) {_                    final String field = metricConfig.getField()__                    for (String metric : metrics) {_                        ValuesSourceAggregationBuilder.LeafOnly newBuilder__                        if (metric.equals(MetricConfig.MIN.getPreferredName())) {_                            newBuilder = new MinAggregationBuilder(formatFieldName(field, MinAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.MAX.getPreferredName())) {_                            newBuilder = new MaxAggregationBuilder(formatFieldName(field, MaxAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.AVG.getPreferredName())) {_                            _                            newBuilder = new SumAggregationBuilder(formatFieldName(field, AvgAggregationBuilder.NAME, RollupField.VALUE))__                            ValuesSourceAggregationBuilder.LeafOnly countBuilder_                                = new ValueCountAggregationBuilder(_                                formatFieldName(field, AvgAggregationBuilder.NAME, RollupField.COUNT_FIELD), ValueType.NUMERIC)__                            countBuilder.field(field)__                            builders.add(countBuilder)__                        } else if (metric.equals(MetricConfig.SUM.getPreferredName())) {_                            newBuilder = new SumAggregationBuilder(formatFieldName(field, SumAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.VALUE_COUNT.getPreferredName())) {_                            _                            _                            newBuilder = new ValueCountAggregationBuilder(_                                formatFieldName(field, ValueCountAggregationBuilder.NAME, RollupField.VALUE), ValueType.NUMERIC)__                        } else {_                            throw new IllegalArgumentException("Unsupported metric type [" + metric + "]")__                        }_                        newBuilder.field(field)__                        builders.add(newBuilder)__                    }_                }_            }_        }_        return unmodifiableList(builders)__    };this,returns,a,set,of,aggregation,builders,which,represent,the,configured,set,of,metrics,used,to,iterate,over,historical,data;static,list,aggregation,builder,create,aggregation,builders,final,list,metric,config,metrics,configs,final,list,aggregation,builder,builders,new,array,list,if,metrics,configs,null,for,metric,config,metric,config,metrics,configs,final,list,string,metrics,metric,config,get,metrics,if,metrics,is,empty,false,final,string,field,metric,config,get,field,for,string,metric,metrics,values,source,aggregation,builder,leaf,only,new,builder,if,metric,equals,metric,config,min,get,preferred,name,new,builder,new,min,aggregation,builder,format,field,name,field,min,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,max,get,preferred,name,new,builder,new,max,aggregation,builder,format,field,name,field,max,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,avg,get,preferred,name,new,builder,new,sum,aggregation,builder,format,field,name,field,avg,aggregation,builder,name,rollup,field,value,values,source,aggregation,builder,leaf,only,count,builder,new,value,count,aggregation,builder,format,field,name,field,avg,aggregation,builder,name,rollup,field,value,type,numeric,count,builder,field,field,builders,add,count,builder,else,if,metric,equals,metric,config,sum,get,preferred,name,new,builder,new,sum,aggregation,builder,format,field,name,field,sum,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,get,preferred,name,new,builder,new,value,count,aggregation,builder,format,field,name,field,value,count,aggregation,builder,name,rollup,field,value,value,type,numeric,else,throw,new,illegal,argument,exception,unsupported,metric,type,metric,new,builder,field,field,builders,add,new,builder,return,unmodifiable,list,builders
RollupIndexer -> static List<AggregationBuilder> createAggregationBuilders(final List<MetricConfig> metricsConfigs);1535666657;This returns a set of aggregation builders which represent the configured_set of metrics. Used to iterate over historical data.;static List<AggregationBuilder> createAggregationBuilders(final List<MetricConfig> metricsConfigs) {_        final List<AggregationBuilder> builders = new ArrayList<>()__        if (metricsConfigs != null) {_            for (MetricConfig metricConfig : metricsConfigs) {_                final List<String> metrics = metricConfig.getMetrics()__                if (metrics.isEmpty() == false) {_                    final String field = metricConfig.getField()__                    for (String metric : metrics) {_                        ValuesSourceAggregationBuilder.LeafOnly newBuilder__                        if (metric.equals(MetricConfig.MIN.getPreferredName())) {_                            newBuilder = new MinAggregationBuilder(formatFieldName(field, MinAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.MAX.getPreferredName())) {_                            newBuilder = new MaxAggregationBuilder(formatFieldName(field, MaxAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.AVG.getPreferredName())) {_                            _                            newBuilder = new SumAggregationBuilder(formatFieldName(field, AvgAggregationBuilder.NAME, RollupField.VALUE))__                            ValuesSourceAggregationBuilder.LeafOnly countBuilder_                                = new ValueCountAggregationBuilder(_                                formatFieldName(field, AvgAggregationBuilder.NAME, RollupField.COUNT_FIELD), ValueType.NUMERIC)__                            countBuilder.field(field)__                            builders.add(countBuilder)__                        } else if (metric.equals(MetricConfig.SUM.getPreferredName())) {_                            newBuilder = new SumAggregationBuilder(formatFieldName(field, SumAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.VALUE_COUNT.getPreferredName())) {_                            _                            _                            newBuilder = new ValueCountAggregationBuilder(_                                formatFieldName(field, ValueCountAggregationBuilder.NAME, RollupField.VALUE), ValueType.NUMERIC)__                        } else {_                            throw new IllegalArgumentException("Unsupported metric type [" + metric + "]")__                        }_                        newBuilder.field(field)__                        builders.add(newBuilder)__                    }_                }_            }_        }_        return Collections.unmodifiableList(builders)__    };this,returns,a,set,of,aggregation,builders,which,represent,the,configured,set,of,metrics,used,to,iterate,over,historical,data;static,list,aggregation,builder,create,aggregation,builders,final,list,metric,config,metrics,configs,final,list,aggregation,builder,builders,new,array,list,if,metrics,configs,null,for,metric,config,metric,config,metrics,configs,final,list,string,metrics,metric,config,get,metrics,if,metrics,is,empty,false,final,string,field,metric,config,get,field,for,string,metric,metrics,values,source,aggregation,builder,leaf,only,new,builder,if,metric,equals,metric,config,min,get,preferred,name,new,builder,new,min,aggregation,builder,format,field,name,field,min,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,max,get,preferred,name,new,builder,new,max,aggregation,builder,format,field,name,field,max,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,avg,get,preferred,name,new,builder,new,sum,aggregation,builder,format,field,name,field,avg,aggregation,builder,name,rollup,field,value,values,source,aggregation,builder,leaf,only,count,builder,new,value,count,aggregation,builder,format,field,name,field,avg,aggregation,builder,name,rollup,field,value,type,numeric,count,builder,field,field,builders,add,count,builder,else,if,metric,equals,metric,config,sum,get,preferred,name,new,builder,new,sum,aggregation,builder,format,field,name,field,sum,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,get,preferred,name,new,builder,new,value,count,aggregation,builder,format,field,name,field,value,count,aggregation,builder,name,rollup,field,value,value,type,numeric,else,throw,new,illegal,argument,exception,unsupported,metric,type,metric,new,builder,field,field,builders,add,new,builder,return,collections,unmodifiable,list,builders
RollupIndexer -> static List<AggregationBuilder> createAggregationBuilders(final List<MetricConfig> metricsConfigs);1536314350;This returns a set of aggregation builders which represent the configured_set of metrics. Used to iterate over historical data.;static List<AggregationBuilder> createAggregationBuilders(final List<MetricConfig> metricsConfigs) {_        final List<AggregationBuilder> builders = new ArrayList<>()__        if (metricsConfigs != null) {_            for (MetricConfig metricConfig : metricsConfigs) {_                final List<String> metrics = metricConfig.getMetrics()__                if (metrics.isEmpty() == false) {_                    final String field = metricConfig.getField()__                    for (String metric : metrics) {_                        ValuesSourceAggregationBuilder.LeafOnly newBuilder__                        if (metric.equals(MetricConfig.MIN.getPreferredName())) {_                            newBuilder = new MinAggregationBuilder(formatFieldName(field, MinAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.MAX.getPreferredName())) {_                            newBuilder = new MaxAggregationBuilder(formatFieldName(field, MaxAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.AVG.getPreferredName())) {_                            _                            newBuilder = new SumAggregationBuilder(formatFieldName(field, AvgAggregationBuilder.NAME, RollupField.VALUE))__                            ValuesSourceAggregationBuilder.LeafOnly countBuilder_                                = new ValueCountAggregationBuilder(_                                formatFieldName(field, AvgAggregationBuilder.NAME, RollupField.COUNT_FIELD), ValueType.NUMERIC)__                            countBuilder.field(field)__                            builders.add(countBuilder)__                        } else if (metric.equals(MetricConfig.SUM.getPreferredName())) {_                            newBuilder = new SumAggregationBuilder(formatFieldName(field, SumAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.VALUE_COUNT.getPreferredName())) {_                            _                            _                            newBuilder = new ValueCountAggregationBuilder(_                                formatFieldName(field, ValueCountAggregationBuilder.NAME, RollupField.VALUE), ValueType.NUMERIC)__                        } else {_                            throw new IllegalArgumentException("Unsupported metric type [" + metric + "]")__                        }_                        newBuilder.field(field)__                        builders.add(newBuilder)__                    }_                }_            }_        }_        return Collections.unmodifiableList(builders)__    };this,returns,a,set,of,aggregation,builders,which,represent,the,configured,set,of,metrics,used,to,iterate,over,historical,data;static,list,aggregation,builder,create,aggregation,builders,final,list,metric,config,metrics,configs,final,list,aggregation,builder,builders,new,array,list,if,metrics,configs,null,for,metric,config,metric,config,metrics,configs,final,list,string,metrics,metric,config,get,metrics,if,metrics,is,empty,false,final,string,field,metric,config,get,field,for,string,metric,metrics,values,source,aggregation,builder,leaf,only,new,builder,if,metric,equals,metric,config,min,get,preferred,name,new,builder,new,min,aggregation,builder,format,field,name,field,min,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,max,get,preferred,name,new,builder,new,max,aggregation,builder,format,field,name,field,max,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,avg,get,preferred,name,new,builder,new,sum,aggregation,builder,format,field,name,field,avg,aggregation,builder,name,rollup,field,value,values,source,aggregation,builder,leaf,only,count,builder,new,value,count,aggregation,builder,format,field,name,field,avg,aggregation,builder,name,rollup,field,value,type,numeric,count,builder,field,field,builders,add,count,builder,else,if,metric,equals,metric,config,sum,get,preferred,name,new,builder,new,sum,aggregation,builder,format,field,name,field,sum,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,get,preferred,name,new,builder,new,value,count,aggregation,builder,format,field,name,field,value,count,aggregation,builder,name,rollup,field,value,value,type,numeric,else,throw,new,illegal,argument,exception,unsupported,metric,type,metric,new,builder,field,field,builders,add,new,builder,return,collections,unmodifiable,list,builders
RollupIndexer -> static List<AggregationBuilder> createAggregationBuilders(final List<MetricConfig> metricsConfigs);1548236405;This returns a set of aggregation builders which represent the configured_set of metrics. Used to iterate over historical data.;static List<AggregationBuilder> createAggregationBuilders(final List<MetricConfig> metricsConfigs) {_        final List<AggregationBuilder> builders = new ArrayList<>()__        if (metricsConfigs != null) {_            for (MetricConfig metricConfig : metricsConfigs) {_                final List<String> metrics = metricConfig.getMetrics()__                if (metrics.isEmpty() == false) {_                    final String field = metricConfig.getField()__                    for (String metric : metrics) {_                        ValuesSourceAggregationBuilder.LeafOnly newBuilder__                        if (metric.equals(MetricConfig.MIN.getPreferredName())) {_                            newBuilder = new MinAggregationBuilder(formatFieldName(field, MinAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.MAX.getPreferredName())) {_                            newBuilder = new MaxAggregationBuilder(formatFieldName(field, MaxAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.AVG.getPreferredName())) {_                            _                            newBuilder = new SumAggregationBuilder(formatFieldName(field, AvgAggregationBuilder.NAME, RollupField.VALUE))__                            ValuesSourceAggregationBuilder.LeafOnly countBuilder_                                = new ValueCountAggregationBuilder(_                                formatFieldName(field, AvgAggregationBuilder.NAME, RollupField.COUNT_FIELD), ValueType.NUMERIC)__                            countBuilder.field(field)__                            builders.add(countBuilder)__                        } else if (metric.equals(MetricConfig.SUM.getPreferredName())) {_                            newBuilder = new SumAggregationBuilder(formatFieldName(field, SumAggregationBuilder.NAME, RollupField.VALUE))__                        } else if (metric.equals(MetricConfig.VALUE_COUNT.getPreferredName())) {_                            _                            _                            newBuilder = new ValueCountAggregationBuilder(_                                formatFieldName(field, ValueCountAggregationBuilder.NAME, RollupField.VALUE), ValueType.NUMERIC)__                        } else {_                            throw new IllegalArgumentException("Unsupported metric type [" + metric + "]")__                        }_                        newBuilder.field(field)__                        builders.add(newBuilder)__                    }_                }_            }_        }_        return Collections.unmodifiableList(builders)__    };this,returns,a,set,of,aggregation,builders,which,represent,the,configured,set,of,metrics,used,to,iterate,over,historical,data;static,list,aggregation,builder,create,aggregation,builders,final,list,metric,config,metrics,configs,final,list,aggregation,builder,builders,new,array,list,if,metrics,configs,null,for,metric,config,metric,config,metrics,configs,final,list,string,metrics,metric,config,get,metrics,if,metrics,is,empty,false,final,string,field,metric,config,get,field,for,string,metric,metrics,values,source,aggregation,builder,leaf,only,new,builder,if,metric,equals,metric,config,min,get,preferred,name,new,builder,new,min,aggregation,builder,format,field,name,field,min,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,max,get,preferred,name,new,builder,new,max,aggregation,builder,format,field,name,field,max,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,avg,get,preferred,name,new,builder,new,sum,aggregation,builder,format,field,name,field,avg,aggregation,builder,name,rollup,field,value,values,source,aggregation,builder,leaf,only,count,builder,new,value,count,aggregation,builder,format,field,name,field,avg,aggregation,builder,name,rollup,field,value,type,numeric,count,builder,field,field,builders,add,count,builder,else,if,metric,equals,metric,config,sum,get,preferred,name,new,builder,new,sum,aggregation,builder,format,field,name,field,sum,aggregation,builder,name,rollup,field,value,else,if,metric,equals,metric,config,get,preferred,name,new,builder,new,value,count,aggregation,builder,format,field,name,field,value,count,aggregation,builder,name,rollup,field,value,value,type,numeric,else,throw,new,illegal,argument,exception,unsupported,metric,type,metric,new,builder,field,field,builders,add,new,builder,return,collections,unmodifiable,list,builders
RollupIndexer -> public synchronized IndexerState start();1524684173;Sets the internal state to {@link IndexerState#STARTED} if the previous state was {@link IndexerState#STOPPED}. Setting the state to_STARTED allows a job to run in the background when {@link #maybeTriggerAsyncJob(long)} is called._@return The new state for the indexer (STARTED, INDEXING or ABORTING if the job was already aborted).;public synchronized IndexerState start() {_        state.compareAndSet(IndexerState.STOPPED, IndexerState.STARTED)__        return state.get()__    };sets,the,internal,state,to,link,indexer,state,started,if,the,previous,state,was,link,indexer,state,stopped,setting,the,state,to,started,allows,a,job,to,run,in,the,background,when,link,maybe,trigger,async,job,long,is,called,return,the,new,state,for,the,indexer,started,indexing,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,start,state,compare,and,set,indexer,state,stopped,indexer,state,started,return,state,get
RollupIndexer -> public synchronized IndexerState start();1531179852;Sets the internal state to {@link IndexerState#STARTED} if the previous state was {@link IndexerState#STOPPED}. Setting the state to_STARTED allows a job to run in the background when {@link #maybeTriggerAsyncJob(long)} is called._@return The new state for the indexer (STARTED, INDEXING or ABORTING if the job was already aborted).;public synchronized IndexerState start() {_        state.compareAndSet(IndexerState.STOPPED, IndexerState.STARTED)__        return state.get()__    };sets,the,internal,state,to,link,indexer,state,started,if,the,previous,state,was,link,indexer,state,stopped,setting,the,state,to,started,allows,a,job,to,run,in,the,background,when,link,maybe,trigger,async,job,long,is,called,return,the,new,state,for,the,indexer,started,indexing,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,start,state,compare,and,set,indexer,state,stopped,indexer,state,started,return,state,get
RollupIndexer -> public synchronized IndexerState start();1531729807;Sets the internal state to {@link IndexerState#STARTED} if the previous state was {@link IndexerState#STOPPED}. Setting the state to_STARTED allows a job to run in the background when {@link #maybeTriggerAsyncJob(long)} is called._@return The new state for the indexer (STARTED, INDEXING or ABORTING if the job was already aborted).;public synchronized IndexerState start() {_        state.compareAndSet(IndexerState.STOPPED, IndexerState.STARTED)__        return state.get()__    };sets,the,internal,state,to,link,indexer,state,started,if,the,previous,state,was,link,indexer,state,stopped,setting,the,state,to,started,allows,a,job,to,run,in,the,background,when,link,maybe,trigger,async,job,long,is,called,return,the,new,state,for,the,indexer,started,indexing,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,start,state,compare,and,set,indexer,state,stopped,indexer,state,started,return,state,get
RollupIndexer -> public synchronized IndexerState start();1532028790;Sets the internal state to {@link IndexerState#STARTED} if the previous state was {@link IndexerState#STOPPED}. Setting the state to_STARTED allows a job to run in the background when {@link #maybeTriggerAsyncJob(long)} is called._@return The new state for the indexer (STARTED, INDEXING or ABORTING if the job was already aborted).;public synchronized IndexerState start() {_        state.compareAndSet(IndexerState.STOPPED, IndexerState.STARTED)__        return state.get()__    };sets,the,internal,state,to,link,indexer,state,started,if,the,previous,state,was,link,indexer,state,stopped,setting,the,state,to,started,allows,a,job,to,run,in,the,background,when,link,maybe,trigger,async,job,long,is,called,return,the,new,state,for,the,indexer,started,indexing,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,start,state,compare,and,set,indexer,state,stopped,indexer,state,started,return,state,get
RollupIndexer -> public synchronized IndexerState start();1533143718;Sets the internal state to {@link IndexerState#STARTED} if the previous state was {@link IndexerState#STOPPED}. Setting the state to_STARTED allows a job to run in the background when {@link #maybeTriggerAsyncJob(long)} is called._@return The new state for the indexer (STARTED, INDEXING or ABORTING if the job was already aborted).;public synchronized IndexerState start() {_        state.compareAndSet(IndexerState.STOPPED, IndexerState.STARTED)__        return state.get()__    };sets,the,internal,state,to,link,indexer,state,started,if,the,previous,state,was,link,indexer,state,stopped,setting,the,state,to,started,allows,a,job,to,run,in,the,background,when,link,maybe,trigger,async,job,long,is,called,return,the,new,state,for,the,indexer,started,indexing,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,start,state,compare,and,set,indexer,state,stopped,indexer,state,started,return,state,get
RollupIndexer -> public synchronized IndexerState start();1533319589;Sets the internal state to {@link IndexerState#STARTED} if the previous state was {@link IndexerState#STOPPED}. Setting the state to_STARTED allows a job to run in the background when {@link #maybeTriggerAsyncJob(long)} is called._@return The new state for the indexer (STARTED, INDEXING or ABORTING if the job was already aborted).;public synchronized IndexerState start() {_        state.compareAndSet(IndexerState.STOPPED, IndexerState.STARTED)__        return state.get()__    };sets,the,internal,state,to,link,indexer,state,started,if,the,previous,state,was,link,indexer,state,stopped,setting,the,state,to,started,allows,a,job,to,run,in,the,background,when,link,maybe,trigger,async,job,long,is,called,return,the,new,state,for,the,indexer,started,indexing,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,start,state,compare,and,set,indexer,state,stopped,indexer,state,started,return,state,get
RollupIndexer -> public synchronized IndexerState start();1533641732;Sets the internal state to {@link IndexerState#STARTED} if the previous state was {@link IndexerState#STOPPED}. Setting the state to_STARTED allows a job to run in the background when {@link #maybeTriggerAsyncJob(long)} is called._@return The new state for the indexer (STARTED, INDEXING or ABORTING if the job was already aborted).;public synchronized IndexerState start() {_        state.compareAndSet(IndexerState.STOPPED, IndexerState.STARTED)__        return state.get()__    };sets,the,internal,state,to,link,indexer,state,started,if,the,previous,state,was,link,indexer,state,stopped,setting,the,state,to,started,allows,a,job,to,run,in,the,background,when,link,maybe,trigger,async,job,long,is,called,return,the,new,state,for,the,indexer,started,indexing,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,start,state,compare,and,set,indexer,state,stopped,indexer,state,started,return,state,get
RollupIndexer -> public synchronized IndexerState start();1535139672;Sets the internal state to {@link IndexerState#STARTED} if the previous state was {@link IndexerState#STOPPED}. Setting the state to_STARTED allows a job to run in the background when {@link #maybeTriggerAsyncJob(long)} is called._@return The new state for the indexer (STARTED, INDEXING or ABORTING if the job was already aborted).;public synchronized IndexerState start() {_        state.compareAndSet(IndexerState.STOPPED, IndexerState.STARTED)__        return state.get()__    };sets,the,internal,state,to,link,indexer,state,started,if,the,previous,state,was,link,indexer,state,stopped,setting,the,state,to,started,allows,a,job,to,run,in,the,background,when,link,maybe,trigger,async,job,long,is,called,return,the,new,state,for,the,indexer,started,indexing,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,start,state,compare,and,set,indexer,state,stopped,indexer,state,started,return,state,get
RollupIndexer -> public synchronized IndexerState start();1535383145;Sets the internal state to {@link IndexerState#STARTED} if the previous state was {@link IndexerState#STOPPED}. Setting the state to_STARTED allows a job to run in the background when {@link #maybeTriggerAsyncJob(long)} is called._@return The new state for the indexer (STARTED, INDEXING or ABORTING if the job was already aborted).;public synchronized IndexerState start() {_        state.compareAndSet(IndexerState.STOPPED, IndexerState.STARTED)__        return state.get()__    };sets,the,internal,state,to,link,indexer,state,started,if,the,previous,state,was,link,indexer,state,stopped,setting,the,state,to,started,allows,a,job,to,run,in,the,background,when,link,maybe,trigger,async,job,long,is,called,return,the,new,state,for,the,indexer,started,indexing,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,start,state,compare,and,set,indexer,state,stopped,indexer,state,started,return,state,get
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1524684173;Creates the range query that limits the search to documents that appear before the maximum allowed time (see {@link this#maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = position != null ? (long) position.get(rollupFieldName) : 0__        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,this,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,position,null,long,position,get,rollup,field,name,0,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1531179852;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1531729807;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1532028790;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)_                .format("epoch_millis")__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,format,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1533143718;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)_                .format("epoch_millis")__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,format,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1533319589;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)_                .format("epoch_millis")__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histo,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,format,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1533641732;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHistogram()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)_                .format("epoch_millis")__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histogram,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,format,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1535139672;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHistogram()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)_                .format("epoch_millis")__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histogram,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,format,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1535383145;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHistogram()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)_                .format("epoch_millis")__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histogram,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,format,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1535666657;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHistogram()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)_                .format("epoch_millis")__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histogram,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,format,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1536314350;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHistogram()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)_                .format("epoch_millis")__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histogram,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,format,return,query
RollupIndexer -> private QueryBuilder createBoundaryQuery(Map<String, Object> position);1548236405;Creates the range query that limits the search to documents that appear before the maximum allowed time_(see {@link #maxBoundary}_and on or after the last processed time._@param position The current position of the pagination_@return The range query to execute;private QueryBuilder createBoundaryQuery(Map<String, Object> position) {_        assert maxBoundary < Long.MAX_VALUE__        DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHistogram()__        String fieldName = dateHisto.getField()__        String rollupFieldName = fieldName + "."  + DateHistogramAggregationBuilder.NAME__        long lowerBound = 0L__        if (position != null) {_            Number value = (Number) position.get(rollupFieldName)__            lowerBound = value.longValue()__        }_        assert lowerBound <= maxBoundary__        final RangeQueryBuilder query = new RangeQueryBuilder(fieldName)_                .gte(lowerBound)_                .lt(maxBoundary)_                .format("epoch_millis")__        return query__    };creates,the,range,query,that,limits,the,search,to,documents,that,appear,before,the,maximum,allowed,time,see,link,max,boundary,and,on,or,after,the,last,processed,time,param,position,the,current,position,of,the,pagination,return,the,range,query,to,execute;private,query,builder,create,boundary,query,map,string,object,position,assert,max,boundary,long,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histogram,string,field,name,date,histo,get,field,string,rollup,field,name,field,name,date,histogram,aggregation,builder,name,long,lower,bound,0l,if,position,null,number,value,number,position,get,rollup,field,name,lower,bound,value,long,value,assert,lower,bound,max,boundary,final,range,query,builder,query,new,range,query,builder,field,name,gte,lower,bound,lt,max,boundary,format,return,query
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState,                   Map<String, Object> initialPosition, AtomicBoolean upgradedDocumentID);1533319589;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task;RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState,_                  Map<String, Object> initialPosition, AtomicBoolean upgradedDocumentID) {_        this.executor = executor__        this.job = job__        this.stats = new RollupJobStats()__        this.state = initialState__        this.position = new AtomicReference<>(initialPosition)__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__        this.upgradedDocumentID = upgradedDocumentID__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,atomic,boolean,upgraded,document,id,this,executor,executor,this,job,job,this,stats,new,rollup,job,stats,this,state,initial,state,this,position,new,atomic,reference,initial,position,this,composite,builder,create,composite,builder,job,get,config,this,upgraded,document,id,upgraded,document,id
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState,                   Map<String, Object> initialPosition, AtomicBoolean upgradedDocumentID);1533641732;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task;RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState,_                  Map<String, Object> initialPosition, AtomicBoolean upgradedDocumentID) {_        this.executor = executor__        this.job = job__        this.stats = new RollupJobStats()__        this.state = initialState__        this.position = new AtomicReference<>(initialPosition)__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__        this.upgradedDocumentID = upgradedDocumentID__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,atomic,boolean,upgraded,document,id,this,executor,executor,this,job,job,this,stats,new,rollup,job,stats,this,state,initial,state,this,position,new,atomic,reference,initial,position,this,composite,builder,create,composite,builder,job,get,config,this,upgraded,document,id,upgraded,document,id
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState,                   Map<String, Object> initialPosition, AtomicBoolean upgradedDocumentID);1535139672;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task;RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState,_                  Map<String, Object> initialPosition, AtomicBoolean upgradedDocumentID) {_        this.executor = executor__        this.job = job__        this.stats = new RollupJobStats()__        this.state = initialState__        this.position = new AtomicReference<>(initialPosition)__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__        this.upgradedDocumentID = upgradedDocumentID__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,atomic,boolean,upgraded,document,id,this,executor,executor,this,job,job,this,stats,new,rollup,job,stats,this,state,initial,state,this,position,new,atomic,reference,initial,position,this,composite,builder,create,composite,builder,job,get,config,this,upgraded,document,id,upgraded,document,id
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState,                   Map<String, Object> initialPosition, AtomicBoolean upgradedDocumentID);1535383145;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task;RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState,_                  Map<String, Object> initialPosition, AtomicBoolean upgradedDocumentID) {_        this.executor = executor__        this.job = job__        this.stats = new RollupJobStats()__        this.state = initialState__        this.position = new AtomicReference<>(initialPosition)__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__        this.upgradedDocumentID = upgradedDocumentID__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,atomic,boolean,upgraded,document,id,this,executor,executor,this,job,job,this,stats,new,rollup,job,stats,this,state,initial,state,this,position,new,atomic,reference,initial,position,this,composite,builder,create,composite,builder,job,get,config,this,upgraded,document,id,upgraded,document,id
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition,             AtomicBoolean upgradedDocumentID);1535666657;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task_@param upgradedDocumentID whether job has updated IDs (for BWC);RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition,_            AtomicBoolean upgradedDocumentID) {_        super(executor, initialState, initialPosition, new RollupIndexerJobStats())__        this.job = job__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__        this.upgradedDocumentID = upgradedDocumentID__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task,param,upgraded,document,id,whether,job,has,updated,ids,for,bwc;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,atomic,boolean,upgraded,document,id,super,executor,initial,state,initial,position,new,rollup,indexer,job,stats,this,job,job,this,composite,builder,create,composite,builder,job,get,config,this,upgraded,document,id,upgraded,document,id
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition,             AtomicBoolean upgradedDocumentID);1536314350;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task_@param upgradedDocumentID whether job has updated IDs (for BWC);RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition,_            AtomicBoolean upgradedDocumentID) {_        super(executor, initialState, initialPosition, new RollupIndexerJobStats())__        this.job = job__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__        this.upgradedDocumentID = upgradedDocumentID__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task,param,upgraded,document,id,whether,job,has,updated,ids,for,bwc;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,atomic,boolean,upgraded,document,id,super,executor,initial,state,initial,position,new,rollup,indexer,job,stats,this,job,job,this,composite,builder,create,composite,builder,job,get,config,this,upgraded,document,id,upgraded,document,id
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition,             AtomicBoolean upgradedDocumentID);1548236405;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task_@param upgradedDocumentID whether job has updated IDs (for BWC);RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition,_            AtomicBoolean upgradedDocumentID) {_        super(executor, initialState, initialPosition, new RollupIndexerJobStats())__        this.job = job__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__        this.upgradedDocumentID = upgradedDocumentID__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task,param,upgraded,document,id,whether,job,has,updated,ids,for,bwc;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,atomic,boolean,upgraded,document,id,super,executor,initial,state,initial,position,new,rollup,indexer,job,stats,this,job,job,this,composite,builder,create,composite,builder,job,get,config,this,upgraded,document,id,upgraded,document,id
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition);1524684173;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task;RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition) {_        this.executor = executor__        this.job = job__        this.stats = new RollupJobStats()__        this.state = initialState__        this.position = new AtomicReference<>(initialPosition)__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,this,executor,executor,this,job,job,this,stats,new,rollup,job,stats,this,state,initial,state,this,position,new,atomic,reference,initial,position,this,composite,builder,create,composite,builder,job,get,config
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition);1531179852;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task;RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition) {_        this.executor = executor__        this.job = job__        this.stats = new RollupJobStats()__        this.state = initialState__        this.position = new AtomicReference<>(initialPosition)__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,this,executor,executor,this,job,job,this,stats,new,rollup,job,stats,this,state,initial,state,this,position,new,atomic,reference,initial,position,this,composite,builder,create,composite,builder,job,get,config
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition);1531729807;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task;RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition) {_        this.executor = executor__        this.job = job__        this.stats = new RollupJobStats()__        this.state = initialState__        this.position = new AtomicReference<>(initialPosition)__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,this,executor,executor,this,job,job,this,stats,new,rollup,job,stats,this,state,initial,state,this,position,new,atomic,reference,initial,position,this,composite,builder,create,composite,builder,job,get,config
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition);1532028790;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task;RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition) {_        this.executor = executor__        this.job = job__        this.stats = new RollupJobStats()__        this.state = initialState__        this.position = new AtomicReference<>(initialPosition)__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,this,executor,executor,this,job,job,this,stats,new,rollup,job,stats,this,state,initial,state,this,position,new,atomic,reference,initial,position,this,composite,builder,create,composite,builder,job,get,config
RollupIndexer -> RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition);1533143718;Ctr_@param executor Executor to use to fire the first request of a background job._@param job The rollup job_@param initialState Initial state for the indexer_@param initialPosition The last indexed bucket of the task;RollupIndexer(Executor executor, RollupJob job, AtomicReference<IndexerState> initialState, Map<String, Object> initialPosition) {_        this.executor = executor__        this.job = job__        this.stats = new RollupJobStats()__        this.state = initialState__        this.position = new AtomicReference<>(initialPosition)__        this.compositeBuilder = createCompositeBuilder(job.getConfig())__    };ctr,param,executor,executor,to,use,to,fire,the,first,request,of,a,background,job,param,job,the,rollup,job,param,initial,state,initial,state,for,the,indexer,param,initial,position,the,last,indexed,bucket,of,the,task;rollup,indexer,executor,executor,rollup,job,job,atomic,reference,indexer,state,initial,state,map,string,object,initial,position,this,executor,executor,this,job,job,this,stats,new,rollup,job,stats,this,state,initial,state,this,position,new,atomic,reference,initial,position,this,composite,builder,create,composite,builder,job,get,config
RollupIndexer -> protected abstract void onAbort()_;1524684173;Called when a background job detects that the indexer is aborted causing the async execution_to stop.;protected abstract void onAbort()_;called,when,a,background,job,detects,that,the,indexer,is,aborted,causing,the,async,execution,to,stop;protected,abstract,void,on,abort
RollupIndexer -> protected abstract void onAbort()_;1531179852;Called when a background job detects that the indexer is aborted causing the async execution_to stop.;protected abstract void onAbort()_;called,when,a,background,job,detects,that,the,indexer,is,aborted,causing,the,async,execution,to,stop;protected,abstract,void,on,abort
RollupIndexer -> protected abstract void onAbort()_;1531729807;Called when a background job detects that the indexer is aborted causing the async execution_to stop.;protected abstract void onAbort()_;called,when,a,background,job,detects,that,the,indexer,is,aborted,causing,the,async,execution,to,stop;protected,abstract,void,on,abort
RollupIndexer -> protected abstract void onAbort()_;1532028790;Called when a background job detects that the indexer is aborted causing the async execution_to stop.;protected abstract void onAbort()_;called,when,a,background,job,detects,that,the,indexer,is,aborted,causing,the,async,execution,to,stop;protected,abstract,void,on,abort
RollupIndexer -> protected abstract void onAbort()_;1533143718;Called when a background job detects that the indexer is aborted causing the async execution_to stop.;protected abstract void onAbort()_;called,when,a,background,job,detects,that,the,indexer,is,aborted,causing,the,async,execution,to,stop;protected,abstract,void,on,abort
RollupIndexer -> protected abstract void onAbort()_;1533319589;Called when a background job detects that the indexer is aborted causing the async execution_to stop.;protected abstract void onAbort()_;called,when,a,background,job,detects,that,the,indexer,is,aborted,causing,the,async,execution,to,stop;protected,abstract,void,on,abort
RollupIndexer -> protected abstract void onAbort()_;1533641732;Called when a background job detects that the indexer is aborted causing the async execution_to stop.;protected abstract void onAbort()_;called,when,a,background,job,detects,that,the,indexer,is,aborted,causing,the,async,execution,to,stop;protected,abstract,void,on,abort
RollupIndexer -> protected abstract void onAbort()_;1535139672;Called when a background job detects that the indexer is aborted causing the async execution_to stop.;protected abstract void onAbort()_;called,when,a,background,job,detects,that,the,indexer,is,aborted,causing,the,async,execution,to,stop;protected,abstract,void,on,abort
RollupIndexer -> protected abstract void onAbort()_;1535383145;Called when a background job detects that the indexer is aborted causing the async execution_to stop.;protected abstract void onAbort()_;called,when,a,background,job,detects,that,the,indexer,is,aborted,causing,the,async,execution,to,stop;protected,abstract,void,on,abort
RollupIndexer -> public synchronized boolean maybeTriggerAsyncJob(long now);1524684173;Triggers a background job that builds the rollup index asynchronously iff there is no other job that runs_and the indexer is started ({@link IndexerState#STARTED}.__@param now The current time in milliseconds (used to limit the job to complete buckets)_@return true if a job has been triggered, false otherwise;public synchronized boolean maybeTriggerAsyncJob(long now) {_        final IndexerState currentState = state.get()__        switch (currentState) {_            case INDEXING:_            case STOPPING:_            case ABORTING:_                logger.warn("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], but prior indexer is still running.")__                return false___            case STOPPED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId()_                        + "] but job is stopped.  Ignoring trigger.")__                return false___            case STARTED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                _                stats.incrementNumInvocations(1)___                _                _                DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__                long rounded = dateHisto.createRounding().round(now)__                if (dateHisto.getDelay() != null) {_                    _                    maxBoundary = rounded - TimeValue.parseTimeValue(dateHisto.getDelay().toString(), "").millis()__                } else {_                    maxBoundary = rounded__                }__                if (state.compareAndSet(IndexerState.STARTED, IndexerState.INDEXING)) {_                    _                    executor.execute(() -> doNextSearch(buildSearchRequest(),_                            ActionListener.wrap(this::onSearchResponse, exc -> finishWithFailure(exc))))__                    logger.debug("Beginning to rollup [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                    return true__                } else {_                    logger.debug("Could not move from STARTED to INDEXING state because current state is [" + state.get() + "]")__                    return false__                }__            default:_                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };triggers,a,background,job,that,builds,the,rollup,index,asynchronously,iff,there,is,no,other,job,that,runs,and,the,indexer,is,started,link,indexer,state,started,param,now,the,current,time,in,milliseconds,used,to,limit,the,job,to,complete,buckets,return,true,if,a,job,has,been,triggered,false,otherwise;public,synchronized,boolean,maybe,trigger,async,job,long,now,final,indexer,state,current,state,state,get,switch,current,state,case,indexing,case,stopping,case,aborting,logger,warn,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,prior,indexer,is,still,running,return,false,case,stopped,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,job,is,stopped,ignoring,trigger,return,false,case,started,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,state,current,state,stats,increment,num,invocations,1,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,long,rounded,date,histo,create,rounding,round,now,if,date,histo,get,delay,null,max,boundary,rounded,time,value,parse,time,value,date,histo,get,delay,to,string,millis,else,max,boundary,rounded,if,state,compare,and,set,indexer,state,started,indexer,state,indexing,executor,execute,do,next,search,build,search,request,action,listener,wrap,this,on,search,response,exc,finish,with,failure,exc,logger,debug,beginning,to,rollup,job,get,config,get,id,state,current,state,return,true,else,logger,debug,could,not,move,from,started,to,indexing,state,because,current,state,is,state,get,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> public synchronized boolean maybeTriggerAsyncJob(long now);1531179852;Triggers a background job that builds the rollup index asynchronously iff there is no other job that runs_and the indexer is started ({@link IndexerState#STARTED}.__@param now The current time in milliseconds (used to limit the job to complete buckets)_@return true if a job has been triggered, false otherwise;public synchronized boolean maybeTriggerAsyncJob(long now) {_        final IndexerState currentState = state.get()__        switch (currentState) {_            case INDEXING:_            case STOPPING:_            case ABORTING:_                logger.warn("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], but prior indexer is still running.")__                return false___            case STOPPED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId()_                        + "] but job is stopped.  Ignoring trigger.")__                return false___            case STARTED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                _                stats.incrementNumInvocations(1)___                _                _                DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__                long rounded = dateHisto.createRounding().round(now)__                if (dateHisto.getDelay() != null) {_                    _                    maxBoundary = rounded - TimeValue.parseTimeValue(dateHisto.getDelay().toString(), "").millis()__                } else {_                    maxBoundary = rounded__                }__                if (state.compareAndSet(IndexerState.STARTED, IndexerState.INDEXING)) {_                    _                    executor.execute(() -> doNextSearch(buildSearchRequest(),_                            ActionListener.wrap(this::onSearchResponse, exc -> finishWithFailure(exc))))__                    logger.debug("Beginning to rollup [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                    return true__                } else {_                    logger.debug("Could not move from STARTED to INDEXING state because current state is [" + state.get() + "]")__                    return false__                }__            default:_                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };triggers,a,background,job,that,builds,the,rollup,index,asynchronously,iff,there,is,no,other,job,that,runs,and,the,indexer,is,started,link,indexer,state,started,param,now,the,current,time,in,milliseconds,used,to,limit,the,job,to,complete,buckets,return,true,if,a,job,has,been,triggered,false,otherwise;public,synchronized,boolean,maybe,trigger,async,job,long,now,final,indexer,state,current,state,state,get,switch,current,state,case,indexing,case,stopping,case,aborting,logger,warn,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,prior,indexer,is,still,running,return,false,case,stopped,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,job,is,stopped,ignoring,trigger,return,false,case,started,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,state,current,state,stats,increment,num,invocations,1,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,long,rounded,date,histo,create,rounding,round,now,if,date,histo,get,delay,null,max,boundary,rounded,time,value,parse,time,value,date,histo,get,delay,to,string,millis,else,max,boundary,rounded,if,state,compare,and,set,indexer,state,started,indexer,state,indexing,executor,execute,do,next,search,build,search,request,action,listener,wrap,this,on,search,response,exc,finish,with,failure,exc,logger,debug,beginning,to,rollup,job,get,config,get,id,state,current,state,return,true,else,logger,debug,could,not,move,from,started,to,indexing,state,because,current,state,is,state,get,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> public synchronized boolean maybeTriggerAsyncJob(long now);1531729807;Triggers a background job that builds the rollup index asynchronously iff there is no other job that runs_and the indexer is started ({@link IndexerState#STARTED}.__@param now The current time in milliseconds (used to limit the job to complete buckets)_@return true if a job has been triggered, false otherwise;public synchronized boolean maybeTriggerAsyncJob(long now) {_        final IndexerState currentState = state.get()__        switch (currentState) {_            case INDEXING:_            case STOPPING:_            case ABORTING:_                logger.warn("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], but prior indexer is still running.")__                return false___            case STOPPED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId()_                        + "] but job is stopped.  Ignoring trigger.")__                return false___            case STARTED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                _                stats.incrementNumInvocations(1)___                _                _                DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__                long rounded = dateHisto.createRounding().round(now)__                if (dateHisto.getDelay() != null) {_                    _                    maxBoundary = rounded - TimeValue.parseTimeValue(dateHisto.getDelay().toString(), "").millis()__                } else {_                    maxBoundary = rounded__                }__                if (state.compareAndSet(IndexerState.STARTED, IndexerState.INDEXING)) {_                    _                    executor.execute(() -> doNextSearch(buildSearchRequest(),_                            ActionListener.wrap(this::onSearchResponse, exc -> finishWithFailure(exc))))__                    logger.debug("Beginning to rollup [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                    return true__                } else {_                    logger.debug("Could not move from STARTED to INDEXING state because current state is [" + state.get() + "]")__                    return false__                }__            default:_                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };triggers,a,background,job,that,builds,the,rollup,index,asynchronously,iff,there,is,no,other,job,that,runs,and,the,indexer,is,started,link,indexer,state,started,param,now,the,current,time,in,milliseconds,used,to,limit,the,job,to,complete,buckets,return,true,if,a,job,has,been,triggered,false,otherwise;public,synchronized,boolean,maybe,trigger,async,job,long,now,final,indexer,state,current,state,state,get,switch,current,state,case,indexing,case,stopping,case,aborting,logger,warn,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,prior,indexer,is,still,running,return,false,case,stopped,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,job,is,stopped,ignoring,trigger,return,false,case,started,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,state,current,state,stats,increment,num,invocations,1,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,long,rounded,date,histo,create,rounding,round,now,if,date,histo,get,delay,null,max,boundary,rounded,time,value,parse,time,value,date,histo,get,delay,to,string,millis,else,max,boundary,rounded,if,state,compare,and,set,indexer,state,started,indexer,state,indexing,executor,execute,do,next,search,build,search,request,action,listener,wrap,this,on,search,response,exc,finish,with,failure,exc,logger,debug,beginning,to,rollup,job,get,config,get,id,state,current,state,return,true,else,logger,debug,could,not,move,from,started,to,indexing,state,because,current,state,is,state,get,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> public synchronized boolean maybeTriggerAsyncJob(long now);1532028790;Triggers a background job that builds the rollup index asynchronously iff there is no other job that runs_and the indexer is started ({@link IndexerState#STARTED}.__@param now The current time in milliseconds (used to limit the job to complete buckets)_@return true if a job has been triggered, false otherwise;public synchronized boolean maybeTriggerAsyncJob(long now) {_        final IndexerState currentState = state.get()__        switch (currentState) {_            case INDEXING:_            case STOPPING:_            case ABORTING:_                logger.warn("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], but prior indexer is still running.")__                return false___            case STOPPED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId()_                        + "] but job is stopped.  Ignoring trigger.")__                return false___            case STARTED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                _                stats.incrementNumInvocations(1)___                _                _                DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__                long rounded = dateHisto.createRounding().round(now)__                if (dateHisto.getDelay() != null) {_                    _                    maxBoundary = rounded - TimeValue.parseTimeValue(dateHisto.getDelay().toString(), "").millis()__                } else {_                    maxBoundary = rounded__                }__                if (state.compareAndSet(IndexerState.STARTED, IndexerState.INDEXING)) {_                    _                    executor.execute(() -> doNextSearch(buildSearchRequest(),_                            ActionListener.wrap(this::onSearchResponse, exc -> finishWithFailure(exc))))__                    logger.debug("Beginning to rollup [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                    return true__                } else {_                    logger.debug("Could not move from STARTED to INDEXING state because current state is [" + state.get() + "]")__                    return false__                }__            default:_                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };triggers,a,background,job,that,builds,the,rollup,index,asynchronously,iff,there,is,no,other,job,that,runs,and,the,indexer,is,started,link,indexer,state,started,param,now,the,current,time,in,milliseconds,used,to,limit,the,job,to,complete,buckets,return,true,if,a,job,has,been,triggered,false,otherwise;public,synchronized,boolean,maybe,trigger,async,job,long,now,final,indexer,state,current,state,state,get,switch,current,state,case,indexing,case,stopping,case,aborting,logger,warn,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,prior,indexer,is,still,running,return,false,case,stopped,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,job,is,stopped,ignoring,trigger,return,false,case,started,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,state,current,state,stats,increment,num,invocations,1,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,long,rounded,date,histo,create,rounding,round,now,if,date,histo,get,delay,null,max,boundary,rounded,time,value,parse,time,value,date,histo,get,delay,to,string,millis,else,max,boundary,rounded,if,state,compare,and,set,indexer,state,started,indexer,state,indexing,executor,execute,do,next,search,build,search,request,action,listener,wrap,this,on,search,response,exc,finish,with,failure,exc,logger,debug,beginning,to,rollup,job,get,config,get,id,state,current,state,return,true,else,logger,debug,could,not,move,from,started,to,indexing,state,because,current,state,is,state,get,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> public synchronized boolean maybeTriggerAsyncJob(long now);1533143718;Triggers a background job that builds the rollup index asynchronously iff there is no other job that runs_and the indexer is started ({@link IndexerState#STARTED}.__@param now The current time in milliseconds (used to limit the job to complete buckets)_@return true if a job has been triggered, false otherwise;public synchronized boolean maybeTriggerAsyncJob(long now) {_        final IndexerState currentState = state.get()__        switch (currentState) {_            case INDEXING:_            case STOPPING:_            case ABORTING:_                logger.warn("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], but prior indexer is still running.")__                return false___            case STOPPED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId()_                        + "] but job is stopped.  Ignoring trigger.")__                return false___            case STARTED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                _                stats.incrementNumInvocations(1)___                _                _                DateHistoGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__                long rounded = dateHisto.createRounding().round(now)__                if (dateHisto.getDelay() != null) {_                    _                    maxBoundary = rounded - TimeValue.parseTimeValue(dateHisto.getDelay().toString(), "").millis()__                } else {_                    maxBoundary = rounded__                }__                if (state.compareAndSet(IndexerState.STARTED, IndexerState.INDEXING)) {_                    _                    executor.execute(() -> doNextSearch(buildSearchRequest(),_                            ActionListener.wrap(this::onSearchResponse, exc -> finishWithFailure(exc))))__                    logger.debug("Beginning to rollup [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                    return true__                } else {_                    logger.debug("Could not move from STARTED to INDEXING state because current state is [" + state.get() + "]")__                    return false__                }__            default:_                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };triggers,a,background,job,that,builds,the,rollup,index,asynchronously,iff,there,is,no,other,job,that,runs,and,the,indexer,is,started,link,indexer,state,started,param,now,the,current,time,in,milliseconds,used,to,limit,the,job,to,complete,buckets,return,true,if,a,job,has,been,triggered,false,otherwise;public,synchronized,boolean,maybe,trigger,async,job,long,now,final,indexer,state,current,state,state,get,switch,current,state,case,indexing,case,stopping,case,aborting,logger,warn,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,prior,indexer,is,still,running,return,false,case,stopped,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,job,is,stopped,ignoring,trigger,return,false,case,started,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,state,current,state,stats,increment,num,invocations,1,date,histo,group,config,date,histo,job,get,config,get,group,config,get,date,histo,long,rounded,date,histo,create,rounding,round,now,if,date,histo,get,delay,null,max,boundary,rounded,time,value,parse,time,value,date,histo,get,delay,to,string,millis,else,max,boundary,rounded,if,state,compare,and,set,indexer,state,started,indexer,state,indexing,executor,execute,do,next,search,build,search,request,action,listener,wrap,this,on,search,response,exc,finish,with,failure,exc,logger,debug,beginning,to,rollup,job,get,config,get,id,state,current,state,return,true,else,logger,debug,could,not,move,from,started,to,indexing,state,because,current,state,is,state,get,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> public synchronized boolean maybeTriggerAsyncJob(long now);1533319589;Triggers a background job that builds the rollup index asynchronously iff there is no other job that runs_and the indexer is started ({@link IndexerState#STARTED}.__@param now The current time in milliseconds (used to limit the job to complete buckets)_@return true if a job has been triggered, false otherwise;public synchronized boolean maybeTriggerAsyncJob(long now) {_        final IndexerState currentState = state.get()__        switch (currentState) {_            case INDEXING:_            case STOPPING:_            case ABORTING:_                logger.warn("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], but prior indexer is still running.")__                return false___            case STOPPED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId()_                        + "] but job is stopped.  Ignoring trigger.")__                return false___            case STARTED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                _                stats.incrementNumInvocations(1)___                _                _                DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHisto()__                long rounded = dateHisto.createRounding().round(now)__                if (dateHisto.getDelay() != null) {_                    _                    maxBoundary = rounded - TimeValue.parseTimeValue(dateHisto.getDelay().toString(), "").millis()__                } else {_                    maxBoundary = rounded__                }__                if (state.compareAndSet(IndexerState.STARTED, IndexerState.INDEXING)) {_                    _                    executor.execute(() -> doNextSearch(buildSearchRequest(),_                            ActionListener.wrap(this::onSearchResponse, exc -> finishWithFailure(exc))))__                    logger.debug("Beginning to rollup [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                    return true__                } else {_                    logger.debug("Could not move from STARTED to INDEXING state because current state is [" + state.get() + "]")__                    return false__                }__            default:_                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };triggers,a,background,job,that,builds,the,rollup,index,asynchronously,iff,there,is,no,other,job,that,runs,and,the,indexer,is,started,link,indexer,state,started,param,now,the,current,time,in,milliseconds,used,to,limit,the,job,to,complete,buckets,return,true,if,a,job,has,been,triggered,false,otherwise;public,synchronized,boolean,maybe,trigger,async,job,long,now,final,indexer,state,current,state,state,get,switch,current,state,case,indexing,case,stopping,case,aborting,logger,warn,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,prior,indexer,is,still,running,return,false,case,stopped,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,job,is,stopped,ignoring,trigger,return,false,case,started,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,state,current,state,stats,increment,num,invocations,1,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histo,long,rounded,date,histo,create,rounding,round,now,if,date,histo,get,delay,null,max,boundary,rounded,time,value,parse,time,value,date,histo,get,delay,to,string,millis,else,max,boundary,rounded,if,state,compare,and,set,indexer,state,started,indexer,state,indexing,executor,execute,do,next,search,build,search,request,action,listener,wrap,this,on,search,response,exc,finish,with,failure,exc,logger,debug,beginning,to,rollup,job,get,config,get,id,state,current,state,return,true,else,logger,debug,could,not,move,from,started,to,indexing,state,because,current,state,is,state,get,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> public synchronized boolean maybeTriggerAsyncJob(long now);1533641732;Triggers a background job that builds the rollup index asynchronously iff there is no other job that runs_and the indexer is started ({@link IndexerState#STARTED}.__@param now The current time in milliseconds (used to limit the job to complete buckets)_@return true if a job has been triggered, false otherwise;public synchronized boolean maybeTriggerAsyncJob(long now) {_        final IndexerState currentState = state.get()__        switch (currentState) {_            case INDEXING:_            case STOPPING:_            case ABORTING:_                logger.warn("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], but prior indexer is still running.")__                return false___            case STOPPED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId()_                        + "] but job is stopped.  Ignoring trigger.")__                return false___            case STARTED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                _                stats.incrementNumInvocations(1)___                _                _                DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHistogram()__                long rounded = dateHisto.createRounding().round(now)__                if (dateHisto.getDelay() != null) {_                    _                    maxBoundary = rounded - TimeValue.parseTimeValue(dateHisto.getDelay().toString(), "").millis()__                } else {_                    maxBoundary = rounded__                }__                if (state.compareAndSet(IndexerState.STARTED, IndexerState.INDEXING)) {_                    _                    executor.execute(() -> doNextSearch(buildSearchRequest(),_                            ActionListener.wrap(this::onSearchResponse, exc -> finishWithFailure(exc))))__                    logger.debug("Beginning to rollup [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                    return true__                } else {_                    logger.debug("Could not move from STARTED to INDEXING state because current state is [" + state.get() + "]")__                    return false__                }__            default:_                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };triggers,a,background,job,that,builds,the,rollup,index,asynchronously,iff,there,is,no,other,job,that,runs,and,the,indexer,is,started,link,indexer,state,started,param,now,the,current,time,in,milliseconds,used,to,limit,the,job,to,complete,buckets,return,true,if,a,job,has,been,triggered,false,otherwise;public,synchronized,boolean,maybe,trigger,async,job,long,now,final,indexer,state,current,state,state,get,switch,current,state,case,indexing,case,stopping,case,aborting,logger,warn,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,prior,indexer,is,still,running,return,false,case,stopped,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,job,is,stopped,ignoring,trigger,return,false,case,started,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,state,current,state,stats,increment,num,invocations,1,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histogram,long,rounded,date,histo,create,rounding,round,now,if,date,histo,get,delay,null,max,boundary,rounded,time,value,parse,time,value,date,histo,get,delay,to,string,millis,else,max,boundary,rounded,if,state,compare,and,set,indexer,state,started,indexer,state,indexing,executor,execute,do,next,search,build,search,request,action,listener,wrap,this,on,search,response,exc,finish,with,failure,exc,logger,debug,beginning,to,rollup,job,get,config,get,id,state,current,state,return,true,else,logger,debug,could,not,move,from,started,to,indexing,state,because,current,state,is,state,get,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> public synchronized boolean maybeTriggerAsyncJob(long now);1535139672;Triggers a background job that builds the rollup index asynchronously iff there is no other job that runs_and the indexer is started ({@link IndexerState#STARTED}.__@param now The current time in milliseconds (used to limit the job to complete buckets)_@return true if a job has been triggered, false otherwise;public synchronized boolean maybeTriggerAsyncJob(long now) {_        final IndexerState currentState = state.get()__        switch (currentState) {_            case INDEXING:_            case STOPPING:_            case ABORTING:_                logger.warn("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], but prior indexer is still running.")__                return false___            case STOPPED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId()_                        + "] but job is stopped.  Ignoring trigger.")__                return false___            case STARTED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                _                stats.incrementNumInvocations(1)___                _                _                DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHistogram()__                long rounded = dateHisto.createRounding().round(now)__                if (dateHisto.getDelay() != null) {_                    _                    maxBoundary = rounded - TimeValue.parseTimeValue(dateHisto.getDelay().toString(), "").millis()__                } else {_                    maxBoundary = rounded__                }__                if (state.compareAndSet(IndexerState.STARTED, IndexerState.INDEXING)) {_                    _                    executor.execute(() -> doNextSearch(buildSearchRequest(),_                            ActionListener.wrap(this::onSearchResponse, exc -> finishWithFailure(exc))))__                    logger.debug("Beginning to rollup [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                    return true__                } else {_                    logger.debug("Could not move from STARTED to INDEXING state because current state is [" + state.get() + "]")__                    return false__                }__            default:_                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };triggers,a,background,job,that,builds,the,rollup,index,asynchronously,iff,there,is,no,other,job,that,runs,and,the,indexer,is,started,link,indexer,state,started,param,now,the,current,time,in,milliseconds,used,to,limit,the,job,to,complete,buckets,return,true,if,a,job,has,been,triggered,false,otherwise;public,synchronized,boolean,maybe,trigger,async,job,long,now,final,indexer,state,current,state,state,get,switch,current,state,case,indexing,case,stopping,case,aborting,logger,warn,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,prior,indexer,is,still,running,return,false,case,stopped,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,job,is,stopped,ignoring,trigger,return,false,case,started,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,state,current,state,stats,increment,num,invocations,1,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histogram,long,rounded,date,histo,create,rounding,round,now,if,date,histo,get,delay,null,max,boundary,rounded,time,value,parse,time,value,date,histo,get,delay,to,string,millis,else,max,boundary,rounded,if,state,compare,and,set,indexer,state,started,indexer,state,indexing,executor,execute,do,next,search,build,search,request,action,listener,wrap,this,on,search,response,exc,finish,with,failure,exc,logger,debug,beginning,to,rollup,job,get,config,get,id,state,current,state,return,true,else,logger,debug,could,not,move,from,started,to,indexing,state,because,current,state,is,state,get,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> public synchronized boolean maybeTriggerAsyncJob(long now);1535383145;Triggers a background job that builds the rollup index asynchronously iff there is no other job that runs_and the indexer is started ({@link IndexerState#STARTED}.__@param now The current time in milliseconds (used to limit the job to complete buckets)_@return true if a job has been triggered, false otherwise;public synchronized boolean maybeTriggerAsyncJob(long now) {_        final IndexerState currentState = state.get()__        switch (currentState) {_            case INDEXING:_            case STOPPING:_            case ABORTING:_                logger.warn("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], but prior indexer is still running.")__                return false___            case STOPPED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId()_                        + "] but job is stopped.  Ignoring trigger.")__                return false___            case STARTED:_                logger.debug("Schedule was triggered for rollup job [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                _                stats.incrementNumInvocations(1)___                _                _                DateHistogramGroupConfig dateHisto = job.getConfig().getGroupConfig().getDateHistogram()__                long rounded = dateHisto.createRounding().round(now)__                if (dateHisto.getDelay() != null) {_                    _                    maxBoundary = rounded - TimeValue.parseTimeValue(dateHisto.getDelay().toString(), "").millis()__                } else {_                    maxBoundary = rounded__                }__                if (state.compareAndSet(IndexerState.STARTED, IndexerState.INDEXING)) {_                    _                    executor.execute(() -> doNextSearch(buildSearchRequest(),_                            ActionListener.wrap(this::onSearchResponse, exc -> finishWithFailure(exc))))__                    logger.debug("Beginning to rollup [" + job.getConfig().getId() + "], state: [" + currentState + "]")__                    return true__                } else {_                    logger.debug("Could not move from STARTED to INDEXING state because current state is [" + state.get() + "]")__                    return false__                }__            default:_                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };triggers,a,background,job,that,builds,the,rollup,index,asynchronously,iff,there,is,no,other,job,that,runs,and,the,indexer,is,started,link,indexer,state,started,param,now,the,current,time,in,milliseconds,used,to,limit,the,job,to,complete,buckets,return,true,if,a,job,has,been,triggered,false,otherwise;public,synchronized,boolean,maybe,trigger,async,job,long,now,final,indexer,state,current,state,state,get,switch,current,state,case,indexing,case,stopping,case,aborting,logger,warn,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,prior,indexer,is,still,running,return,false,case,stopped,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,but,job,is,stopped,ignoring,trigger,return,false,case,started,logger,debug,schedule,was,triggered,for,rollup,job,job,get,config,get,id,state,current,state,stats,increment,num,invocations,1,date,histogram,group,config,date,histo,job,get,config,get,group,config,get,date,histogram,long,rounded,date,histo,create,rounding,round,now,if,date,histo,get,delay,null,max,boundary,rounded,time,value,parse,time,value,date,histo,get,delay,to,string,millis,else,max,boundary,rounded,if,state,compare,and,set,indexer,state,started,indexer,state,indexing,executor,execute,do,next,search,build,search,request,action,listener,wrap,this,on,search,response,exc,finish,with,failure,exc,logger,debug,beginning,to,rollup,job,get,config,get,id,state,current,state,return,true,else,logger,debug,could,not,move,from,started,to,indexing,state,because,current,state,is,state,get,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> private boolean checkState(IndexerState currentState);1524684173;Checks the {@link IndexerState} and returns false if the execution_should be stopped.;private boolean checkState(IndexerState currentState) {_        switch (currentState) {_            case INDEXING:_                _                return true___            case STOPPING:_                logger.info("Rollup job encountered [" + IndexerState.STOPPING + "] state, halting indexer.")__                doSaveState(finishAndSetState(), getPosition(), () -> {})__                return false___            case STOPPED:_                return false___            case ABORTING:_                logger.info("Requested shutdown of indexer for job [" + job.getConfig().getId() + "]")__                onAbort()__                return false___            default:_                _                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };checks,the,link,indexer,state,and,returns,false,if,the,execution,should,be,stopped;private,boolean,check,state,indexer,state,current,state,switch,current,state,case,indexing,return,true,case,stopping,logger,info,rollup,job,encountered,indexer,state,stopping,state,halting,indexer,do,save,state,finish,and,set,state,get,position,return,false,case,stopped,return,false,case,aborting,logger,info,requested,shutdown,of,indexer,for,job,job,get,config,get,id,on,abort,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> private boolean checkState(IndexerState currentState);1531179852;Checks the {@link IndexerState} and returns false if the execution_should be stopped.;private boolean checkState(IndexerState currentState) {_        switch (currentState) {_            case INDEXING:_                _                return true___            case STOPPING:_                logger.info("Rollup job encountered [" + IndexerState.STOPPING + "] state, halting indexer.")__                doSaveState(finishAndSetState(), getPosition(), () -> {})__                return false___            case STOPPED:_                return false___            case ABORTING:_                logger.info("Requested shutdown of indexer for job [" + job.getConfig().getId() + "]")__                onAbort()__                return false___            default:_                _                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };checks,the,link,indexer,state,and,returns,false,if,the,execution,should,be,stopped;private,boolean,check,state,indexer,state,current,state,switch,current,state,case,indexing,return,true,case,stopping,logger,info,rollup,job,encountered,indexer,state,stopping,state,halting,indexer,do,save,state,finish,and,set,state,get,position,return,false,case,stopped,return,false,case,aborting,logger,info,requested,shutdown,of,indexer,for,job,job,get,config,get,id,on,abort,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> private boolean checkState(IndexerState currentState);1531729807;Checks the {@link IndexerState} and returns false if the execution_should be stopped.;private boolean checkState(IndexerState currentState) {_        switch (currentState) {_            case INDEXING:_                _                return true___            case STOPPING:_                logger.info("Rollup job encountered [" + IndexerState.STOPPING + "] state, halting indexer.")__                doSaveState(finishAndSetState(), getPosition(), () -> {})__                return false___            case STOPPED:_                return false___            case ABORTING:_                logger.info("Requested shutdown of indexer for job [" + job.getConfig().getId() + "]")__                onAbort()__                return false___            default:_                _                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };checks,the,link,indexer,state,and,returns,false,if,the,execution,should,be,stopped;private,boolean,check,state,indexer,state,current,state,switch,current,state,case,indexing,return,true,case,stopping,logger,info,rollup,job,encountered,indexer,state,stopping,state,halting,indexer,do,save,state,finish,and,set,state,get,position,return,false,case,stopped,return,false,case,aborting,logger,info,requested,shutdown,of,indexer,for,job,job,get,config,get,id,on,abort,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> private boolean checkState(IndexerState currentState);1532028790;Checks the {@link IndexerState} and returns false if the execution_should be stopped.;private boolean checkState(IndexerState currentState) {_        switch (currentState) {_            case INDEXING:_                _                return true___            case STOPPING:_                logger.info("Rollup job encountered [" + IndexerState.STOPPING + "] state, halting indexer.")__                doSaveState(finishAndSetState(), getPosition(), () -> {})__                return false___            case STOPPED:_                return false___            case ABORTING:_                logger.info("Requested shutdown of indexer for job [" + job.getConfig().getId() + "]")__                onAbort()__                return false___            default:_                _                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };checks,the,link,indexer,state,and,returns,false,if,the,execution,should,be,stopped;private,boolean,check,state,indexer,state,current,state,switch,current,state,case,indexing,return,true,case,stopping,logger,info,rollup,job,encountered,indexer,state,stopping,state,halting,indexer,do,save,state,finish,and,set,state,get,position,return,false,case,stopped,return,false,case,aborting,logger,info,requested,shutdown,of,indexer,for,job,job,get,config,get,id,on,abort,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> private boolean checkState(IndexerState currentState);1533143718;Checks the {@link IndexerState} and returns false if the execution_should be stopped.;private boolean checkState(IndexerState currentState) {_        switch (currentState) {_            case INDEXING:_                _                return true___            case STOPPING:_                logger.info("Rollup job encountered [" + IndexerState.STOPPING + "] state, halting indexer.")__                doSaveState(finishAndSetState(), getPosition(), () -> {})__                return false___            case STOPPED:_                return false___            case ABORTING:_                logger.info("Requested shutdown of indexer for job [" + job.getConfig().getId() + "]")__                onAbort()__                return false___            default:_                _                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };checks,the,link,indexer,state,and,returns,false,if,the,execution,should,be,stopped;private,boolean,check,state,indexer,state,current,state,switch,current,state,case,indexing,return,true,case,stopping,logger,info,rollup,job,encountered,indexer,state,stopping,state,halting,indexer,do,save,state,finish,and,set,state,get,position,return,false,case,stopped,return,false,case,aborting,logger,info,requested,shutdown,of,indexer,for,job,job,get,config,get,id,on,abort,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> private boolean checkState(IndexerState currentState);1533319589;Checks the {@link IndexerState} and returns false if the execution_should be stopped.;private boolean checkState(IndexerState currentState) {_        switch (currentState) {_            case INDEXING:_                _                return true___            case STOPPING:_                logger.info("Rollup job encountered [" + IndexerState.STOPPING + "] state, halting indexer.")__                doSaveState(finishAndSetState(), getPosition(), () -> {})__                return false___            case STOPPED:_                return false___            case ABORTING:_                logger.info("Requested shutdown of indexer for job [" + job.getConfig().getId() + "]")__                onAbort()__                return false___            default:_                _                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };checks,the,link,indexer,state,and,returns,false,if,the,execution,should,be,stopped;private,boolean,check,state,indexer,state,current,state,switch,current,state,case,indexing,return,true,case,stopping,logger,info,rollup,job,encountered,indexer,state,stopping,state,halting,indexer,do,save,state,finish,and,set,state,get,position,return,false,case,stopped,return,false,case,aborting,logger,info,requested,shutdown,of,indexer,for,job,job,get,config,get,id,on,abort,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> private boolean checkState(IndexerState currentState);1533641732;Checks the {@link IndexerState} and returns false if the execution_should be stopped.;private boolean checkState(IndexerState currentState) {_        switch (currentState) {_            case INDEXING:_                _                return true___            case STOPPING:_                logger.info("Rollup job encountered [" + IndexerState.STOPPING + "] state, halting indexer.")__                doSaveState(finishAndSetState(), getPosition(), () -> {})__                return false___            case STOPPED:_                return false___            case ABORTING:_                logger.info("Requested shutdown of indexer for job [" + job.getConfig().getId() + "]")__                onAbort()__                return false___            default:_                _                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };checks,the,link,indexer,state,and,returns,false,if,the,execution,should,be,stopped;private,boolean,check,state,indexer,state,current,state,switch,current,state,case,indexing,return,true,case,stopping,logger,info,rollup,job,encountered,indexer,state,stopping,state,halting,indexer,do,save,state,finish,and,set,state,get,position,return,false,case,stopped,return,false,case,aborting,logger,info,requested,shutdown,of,indexer,for,job,job,get,config,get,id,on,abort,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> private boolean checkState(IndexerState currentState);1535139672;Checks the {@link IndexerState} and returns false if the execution_should be stopped.;private boolean checkState(IndexerState currentState) {_        switch (currentState) {_            case INDEXING:_                _                return true___            case STOPPING:_                logger.info("Rollup job encountered [" + IndexerState.STOPPING + "] state, halting indexer.")__                doSaveState(finishAndSetState(), getPosition(), () -> {})__                return false___            case STOPPED:_                return false___            case ABORTING:_                logger.info("Requested shutdown of indexer for job [" + job.getConfig().getId() + "]")__                onAbort()__                return false___            default:_                _                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };checks,the,link,indexer,state,and,returns,false,if,the,execution,should,be,stopped;private,boolean,check,state,indexer,state,current,state,switch,current,state,case,indexing,return,true,case,stopping,logger,info,rollup,job,encountered,indexer,state,stopping,state,halting,indexer,do,save,state,finish,and,set,state,get,position,return,false,case,stopped,return,false,case,aborting,logger,info,requested,shutdown,of,indexer,for,job,job,get,config,get,id,on,abort,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> private boolean checkState(IndexerState currentState);1535383145;Checks the {@link IndexerState} and returns false if the execution_should be stopped.;private boolean checkState(IndexerState currentState) {_        switch (currentState) {_            case INDEXING:_                _                return true___            case STOPPING:_                logger.info("Rollup job encountered [" + IndexerState.STOPPING + "] state, halting indexer.")__                doSaveState(finishAndSetState(), getPosition(), () -> {})__                return false___            case STOPPED:_                return false___            case ABORTING:_                logger.info("Requested shutdown of indexer for job [" + job.getConfig().getId() + "]")__                onAbort()__                return false___            default:_                _                logger.warn("Encountered unexpected state [" + currentState + "] while indexing")__                throw new IllegalStateException("Rollup job encountered an illegal state [" + currentState + "]")__        }_    };checks,the,link,indexer,state,and,returns,false,if,the,execution,should,be,stopped;private,boolean,check,state,indexer,state,current,state,switch,current,state,case,indexing,return,true,case,stopping,logger,info,rollup,job,encountered,indexer,state,stopping,state,halting,indexer,do,save,state,finish,and,set,state,get,position,return,false,case,stopped,return,false,case,aborting,logger,info,requested,shutdown,of,indexer,for,job,job,get,config,get,id,on,abort,return,false,default,logger,warn,encountered,unexpected,state,current,state,while,indexing,throw,new,illegal,state,exception,rollup,job,encountered,an,illegal,state,current,state
RollupIndexer -> public synchronized IndexerState stop();1524684173;Sets the internal state to {@link IndexerState#STOPPING} if an async job is running in the background and in such case_{@link #onFinish()} will be called as soon as the background job detects that the indexer is stopped. If there is no job running when_this function is called, the state is directly set to {@link IndexerState#STOPPED} and {@link #onFinish()} will never be called._@return The new state for the indexer (STOPPED, STOPPING or ABORTING if the job was already aborted).;public synchronized IndexerState stop() {_        IndexerState currentState = state.updateAndGet(previousState -> {_            if (previousState == IndexerState.INDEXING) {_                return IndexerState.STOPPING__            } else if (previousState == IndexerState.STARTED) {_                return IndexerState.STOPPED__            } else {_                return previousState__            }_        })__        return currentState__    };sets,the,internal,state,to,link,indexer,state,stopping,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,finish,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,stopped,if,there,is,no,job,running,when,this,function,is,called,the,state,is,directly,set,to,link,indexer,state,stopped,and,link,on,finish,will,never,be,called,return,the,new,state,for,the,indexer,stopped,stopping,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,stop,indexer,state,current,state,state,update,and,get,previous,state,if,previous,state,indexer,state,indexing,return,indexer,state,stopping,else,if,previous,state,indexer,state,started,return,indexer,state,stopped,else,return,previous,state,return,current,state
RollupIndexer -> public synchronized IndexerState stop();1531179852;Sets the internal state to {@link IndexerState#STOPPING} if an async job is running in the background and in such case_{@link #onFinish()} will be called as soon as the background job detects that the indexer is stopped. If there is no job running when_this function is called, the state is directly set to {@link IndexerState#STOPPED} and {@link #onFinish()} will never be called._@return The new state for the indexer (STOPPED, STOPPING or ABORTING if the job was already aborted).;public synchronized IndexerState stop() {_        IndexerState currentState = state.updateAndGet(previousState -> {_            if (previousState == IndexerState.INDEXING) {_                return IndexerState.STOPPING__            } else if (previousState == IndexerState.STARTED) {_                return IndexerState.STOPPED__            } else {_                return previousState__            }_        })__        return currentState__    };sets,the,internal,state,to,link,indexer,state,stopping,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,finish,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,stopped,if,there,is,no,job,running,when,this,function,is,called,the,state,is,directly,set,to,link,indexer,state,stopped,and,link,on,finish,will,never,be,called,return,the,new,state,for,the,indexer,stopped,stopping,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,stop,indexer,state,current,state,state,update,and,get,previous,state,if,previous,state,indexer,state,indexing,return,indexer,state,stopping,else,if,previous,state,indexer,state,started,return,indexer,state,stopped,else,return,previous,state,return,current,state
RollupIndexer -> public synchronized IndexerState stop();1531729807;Sets the internal state to {@link IndexerState#STOPPING} if an async job is running in the background and in such case_{@link #onFinish()} will be called as soon as the background job detects that the indexer is stopped. If there is no job running when_this function is called, the state is directly set to {@link IndexerState#STOPPED} and {@link #onFinish()} will never be called._@return The new state for the indexer (STOPPED, STOPPING or ABORTING if the job was already aborted).;public synchronized IndexerState stop() {_        IndexerState currentState = state.updateAndGet(previousState -> {_            if (previousState == IndexerState.INDEXING) {_                return IndexerState.STOPPING__            } else if (previousState == IndexerState.STARTED) {_                return IndexerState.STOPPED__            } else {_                return previousState__            }_        })__        return currentState__    };sets,the,internal,state,to,link,indexer,state,stopping,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,finish,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,stopped,if,there,is,no,job,running,when,this,function,is,called,the,state,is,directly,set,to,link,indexer,state,stopped,and,link,on,finish,will,never,be,called,return,the,new,state,for,the,indexer,stopped,stopping,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,stop,indexer,state,current,state,state,update,and,get,previous,state,if,previous,state,indexer,state,indexing,return,indexer,state,stopping,else,if,previous,state,indexer,state,started,return,indexer,state,stopped,else,return,previous,state,return,current,state
RollupIndexer -> public synchronized IndexerState stop();1532028790;Sets the internal state to {@link IndexerState#STOPPING} if an async job is running in the background and in such case_{@link #onFinish()} will be called as soon as the background job detects that the indexer is stopped. If there is no job running when_this function is called, the state is directly set to {@link IndexerState#STOPPED} and {@link #onFinish()} will never be called._@return The new state for the indexer (STOPPED, STOPPING or ABORTING if the job was already aborted).;public synchronized IndexerState stop() {_        IndexerState currentState = state.updateAndGet(previousState -> {_            if (previousState == IndexerState.INDEXING) {_                return IndexerState.STOPPING__            } else if (previousState == IndexerState.STARTED) {_                return IndexerState.STOPPED__            } else {_                return previousState__            }_        })__        return currentState__    };sets,the,internal,state,to,link,indexer,state,stopping,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,finish,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,stopped,if,there,is,no,job,running,when,this,function,is,called,the,state,is,directly,set,to,link,indexer,state,stopped,and,link,on,finish,will,never,be,called,return,the,new,state,for,the,indexer,stopped,stopping,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,stop,indexer,state,current,state,state,update,and,get,previous,state,if,previous,state,indexer,state,indexing,return,indexer,state,stopping,else,if,previous,state,indexer,state,started,return,indexer,state,stopped,else,return,previous,state,return,current,state
RollupIndexer -> public synchronized IndexerState stop();1533143718;Sets the internal state to {@link IndexerState#STOPPING} if an async job is running in the background and in such case_{@link #onFinish()} will be called as soon as the background job detects that the indexer is stopped. If there is no job running when_this function is called, the state is directly set to {@link IndexerState#STOPPED} and {@link #onFinish()} will never be called._@return The new state for the indexer (STOPPED, STOPPING or ABORTING if the job was already aborted).;public synchronized IndexerState stop() {_        IndexerState currentState = state.updateAndGet(previousState -> {_            if (previousState == IndexerState.INDEXING) {_                return IndexerState.STOPPING__            } else if (previousState == IndexerState.STARTED) {_                return IndexerState.STOPPED__            } else {_                return previousState__            }_        })__        return currentState__    };sets,the,internal,state,to,link,indexer,state,stopping,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,finish,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,stopped,if,there,is,no,job,running,when,this,function,is,called,the,state,is,directly,set,to,link,indexer,state,stopped,and,link,on,finish,will,never,be,called,return,the,new,state,for,the,indexer,stopped,stopping,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,stop,indexer,state,current,state,state,update,and,get,previous,state,if,previous,state,indexer,state,indexing,return,indexer,state,stopping,else,if,previous,state,indexer,state,started,return,indexer,state,stopped,else,return,previous,state,return,current,state
RollupIndexer -> public synchronized IndexerState stop();1533319589;Sets the internal state to {@link IndexerState#STOPPING} if an async job is running in the background and in such case_{@link #onFinish()} will be called as soon as the background job detects that the indexer is stopped. If there is no job running when_this function is called, the state is directly set to {@link IndexerState#STOPPED} and {@link #onFinish()} will never be called._@return The new state for the indexer (STOPPED, STOPPING or ABORTING if the job was already aborted).;public synchronized IndexerState stop() {_        IndexerState currentState = state.updateAndGet(previousState -> {_            if (previousState == IndexerState.INDEXING) {_                return IndexerState.STOPPING__            } else if (previousState == IndexerState.STARTED) {_                return IndexerState.STOPPED__            } else {_                return previousState__            }_        })__        return currentState__    };sets,the,internal,state,to,link,indexer,state,stopping,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,finish,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,stopped,if,there,is,no,job,running,when,this,function,is,called,the,state,is,directly,set,to,link,indexer,state,stopped,and,link,on,finish,will,never,be,called,return,the,new,state,for,the,indexer,stopped,stopping,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,stop,indexer,state,current,state,state,update,and,get,previous,state,if,previous,state,indexer,state,indexing,return,indexer,state,stopping,else,if,previous,state,indexer,state,started,return,indexer,state,stopped,else,return,previous,state,return,current,state
RollupIndexer -> public synchronized IndexerState stop();1533641732;Sets the internal state to {@link IndexerState#STOPPING} if an async job is running in the background and in such case_{@link #onFinish()} will be called as soon as the background job detects that the indexer is stopped. If there is no job running when_this function is called, the state is directly set to {@link IndexerState#STOPPED} and {@link #onFinish()} will never be called._@return The new state for the indexer (STOPPED, STOPPING or ABORTING if the job was already aborted).;public synchronized IndexerState stop() {_        IndexerState currentState = state.updateAndGet(previousState -> {_            if (previousState == IndexerState.INDEXING) {_                return IndexerState.STOPPING__            } else if (previousState == IndexerState.STARTED) {_                return IndexerState.STOPPED__            } else {_                return previousState__            }_        })__        return currentState__    };sets,the,internal,state,to,link,indexer,state,stopping,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,finish,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,stopped,if,there,is,no,job,running,when,this,function,is,called,the,state,is,directly,set,to,link,indexer,state,stopped,and,link,on,finish,will,never,be,called,return,the,new,state,for,the,indexer,stopped,stopping,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,stop,indexer,state,current,state,state,update,and,get,previous,state,if,previous,state,indexer,state,indexing,return,indexer,state,stopping,else,if,previous,state,indexer,state,started,return,indexer,state,stopped,else,return,previous,state,return,current,state
RollupIndexer -> public synchronized IndexerState stop();1535139672;Sets the internal state to {@link IndexerState#STOPPING} if an async job is running in the background and in such case_{@link #onFinish()} will be called as soon as the background job detects that the indexer is stopped. If there is no job running when_this function is called, the state is directly set to {@link IndexerState#STOPPED} and {@link #onFinish()} will never be called._@return The new state for the indexer (STOPPED, STOPPING or ABORTING if the job was already aborted).;public synchronized IndexerState stop() {_        IndexerState currentState = state.updateAndGet(previousState -> {_            if (previousState == IndexerState.INDEXING) {_                return IndexerState.STOPPING__            } else if (previousState == IndexerState.STARTED) {_                return IndexerState.STOPPED__            } else {_                return previousState__            }_        })__        return currentState__    };sets,the,internal,state,to,link,indexer,state,stopping,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,finish,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,stopped,if,there,is,no,job,running,when,this,function,is,called,the,state,is,directly,set,to,link,indexer,state,stopped,and,link,on,finish,will,never,be,called,return,the,new,state,for,the,indexer,stopped,stopping,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,stop,indexer,state,current,state,state,update,and,get,previous,state,if,previous,state,indexer,state,indexing,return,indexer,state,stopping,else,if,previous,state,indexer,state,started,return,indexer,state,stopped,else,return,previous,state,return,current,state
RollupIndexer -> public synchronized IndexerState stop();1535383145;Sets the internal state to {@link IndexerState#STOPPING} if an async job is running in the background and in such case_{@link #onFinish()} will be called as soon as the background job detects that the indexer is stopped. If there is no job running when_this function is called, the state is directly set to {@link IndexerState#STOPPED} and {@link #onFinish()} will never be called._@return The new state for the indexer (STOPPED, STOPPING or ABORTING if the job was already aborted).;public synchronized IndexerState stop() {_        IndexerState currentState = state.updateAndGet(previousState -> {_            if (previousState == IndexerState.INDEXING) {_                return IndexerState.STOPPING__            } else if (previousState == IndexerState.STARTED) {_                return IndexerState.STOPPED__            } else {_                return previousState__            }_        })__        return currentState__    };sets,the,internal,state,to,link,indexer,state,stopping,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,finish,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,stopped,if,there,is,no,job,running,when,this,function,is,called,the,state,is,directly,set,to,link,indexer,state,stopped,and,link,on,finish,will,never,be,called,return,the,new,state,for,the,indexer,stopped,stopping,or,aborting,if,the,job,was,already,aborted;public,synchronized,indexer,state,stop,indexer,state,current,state,state,update,and,get,previous,state,if,previous,state,indexer,state,indexing,return,indexer,state,stopping,else,if,previous,state,indexer,state,started,return,indexer,state,stopped,else,return,previous,state,return,current,state
RollupIndexer -> public synchronized boolean abort();1524684173;Sets the internal state to {@link IndexerState#ABORTING}. It returns false if an async job is running in the background and in such_case {@link #onAbort} will be called as soon as the background job detects that the indexer is aborted. If there is no job running_when this function is called, it returns true and {@link #onAbort()} will never be called._@return true if the indexer is aborted, false if a background job is running and abort is delayed.;public synchronized boolean abort() {_        IndexerState prevState = state.getAndUpdate((prev) -> IndexerState.ABORTING)__        return prevState == IndexerState.STOPPED || prevState == IndexerState.STARTED__    };sets,the,internal,state,to,link,indexer,state,aborting,it,returns,false,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,abort,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,aborted,if,there,is,no,job,running,when,this,function,is,called,it,returns,true,and,link,on,abort,will,never,be,called,return,true,if,the,indexer,is,aborted,false,if,a,background,job,is,running,and,abort,is,delayed;public,synchronized,boolean,abort,indexer,state,prev,state,state,get,and,update,prev,indexer,state,aborting,return,prev,state,indexer,state,stopped,prev,state,indexer,state,started
RollupIndexer -> public synchronized boolean abort();1531179852;Sets the internal state to {@link IndexerState#ABORTING}. It returns false if an async job is running in the background and in such_case {@link #onAbort} will be called as soon as the background job detects that the indexer is aborted. If there is no job running_when this function is called, it returns true and {@link #onAbort()} will never be called._@return true if the indexer is aborted, false if a background job is running and abort is delayed.;public synchronized boolean abort() {_        IndexerState prevState = state.getAndUpdate((prev) -> IndexerState.ABORTING)__        return prevState == IndexerState.STOPPED || prevState == IndexerState.STARTED__    };sets,the,internal,state,to,link,indexer,state,aborting,it,returns,false,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,abort,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,aborted,if,there,is,no,job,running,when,this,function,is,called,it,returns,true,and,link,on,abort,will,never,be,called,return,true,if,the,indexer,is,aborted,false,if,a,background,job,is,running,and,abort,is,delayed;public,synchronized,boolean,abort,indexer,state,prev,state,state,get,and,update,prev,indexer,state,aborting,return,prev,state,indexer,state,stopped,prev,state,indexer,state,started
RollupIndexer -> public synchronized boolean abort();1531729807;Sets the internal state to {@link IndexerState#ABORTING}. It returns false if an async job is running in the background and in such_case {@link #onAbort} will be called as soon as the background job detects that the indexer is aborted. If there is no job running_when this function is called, it returns true and {@link #onAbort()} will never be called._@return true if the indexer is aborted, false if a background job is running and abort is delayed.;public synchronized boolean abort() {_        IndexerState prevState = state.getAndUpdate((prev) -> IndexerState.ABORTING)__        return prevState == IndexerState.STOPPED || prevState == IndexerState.STARTED__    };sets,the,internal,state,to,link,indexer,state,aborting,it,returns,false,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,abort,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,aborted,if,there,is,no,job,running,when,this,function,is,called,it,returns,true,and,link,on,abort,will,never,be,called,return,true,if,the,indexer,is,aborted,false,if,a,background,job,is,running,and,abort,is,delayed;public,synchronized,boolean,abort,indexer,state,prev,state,state,get,and,update,prev,indexer,state,aborting,return,prev,state,indexer,state,stopped,prev,state,indexer,state,started
RollupIndexer -> public synchronized boolean abort();1532028790;Sets the internal state to {@link IndexerState#ABORTING}. It returns false if an async job is running in the background and in such_case {@link #onAbort} will be called as soon as the background job detects that the indexer is aborted. If there is no job running_when this function is called, it returns true and {@link #onAbort()} will never be called._@return true if the indexer is aborted, false if a background job is running and abort is delayed.;public synchronized boolean abort() {_        IndexerState prevState = state.getAndUpdate((prev) -> IndexerState.ABORTING)__        return prevState == IndexerState.STOPPED || prevState == IndexerState.STARTED__    };sets,the,internal,state,to,link,indexer,state,aborting,it,returns,false,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,abort,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,aborted,if,there,is,no,job,running,when,this,function,is,called,it,returns,true,and,link,on,abort,will,never,be,called,return,true,if,the,indexer,is,aborted,false,if,a,background,job,is,running,and,abort,is,delayed;public,synchronized,boolean,abort,indexer,state,prev,state,state,get,and,update,prev,indexer,state,aborting,return,prev,state,indexer,state,stopped,prev,state,indexer,state,started
RollupIndexer -> public synchronized boolean abort();1533143718;Sets the internal state to {@link IndexerState#ABORTING}. It returns false if an async job is running in the background and in such_case {@link #onAbort} will be called as soon as the background job detects that the indexer is aborted. If there is no job running_when this function is called, it returns true and {@link #onAbort()} will never be called._@return true if the indexer is aborted, false if a background job is running and abort is delayed.;public synchronized boolean abort() {_        IndexerState prevState = state.getAndUpdate((prev) -> IndexerState.ABORTING)__        return prevState == IndexerState.STOPPED || prevState == IndexerState.STARTED__    };sets,the,internal,state,to,link,indexer,state,aborting,it,returns,false,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,abort,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,aborted,if,there,is,no,job,running,when,this,function,is,called,it,returns,true,and,link,on,abort,will,never,be,called,return,true,if,the,indexer,is,aborted,false,if,a,background,job,is,running,and,abort,is,delayed;public,synchronized,boolean,abort,indexer,state,prev,state,state,get,and,update,prev,indexer,state,aborting,return,prev,state,indexer,state,stopped,prev,state,indexer,state,started
RollupIndexer -> public synchronized boolean abort();1533319589;Sets the internal state to {@link IndexerState#ABORTING}. It returns false if an async job is running in the background and in such_case {@link #onAbort} will be called as soon as the background job detects that the indexer is aborted. If there is no job running_when this function is called, it returns true and {@link #onAbort()} will never be called._@return true if the indexer is aborted, false if a background job is running and abort is delayed.;public synchronized boolean abort() {_        IndexerState prevState = state.getAndUpdate((prev) -> IndexerState.ABORTING)__        return prevState == IndexerState.STOPPED || prevState == IndexerState.STARTED__    };sets,the,internal,state,to,link,indexer,state,aborting,it,returns,false,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,abort,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,aborted,if,there,is,no,job,running,when,this,function,is,called,it,returns,true,and,link,on,abort,will,never,be,called,return,true,if,the,indexer,is,aborted,false,if,a,background,job,is,running,and,abort,is,delayed;public,synchronized,boolean,abort,indexer,state,prev,state,state,get,and,update,prev,indexer,state,aborting,return,prev,state,indexer,state,stopped,prev,state,indexer,state,started
RollupIndexer -> public synchronized boolean abort();1533641732;Sets the internal state to {@link IndexerState#ABORTING}. It returns false if an async job is running in the background and in such_case {@link #onAbort} will be called as soon as the background job detects that the indexer is aborted. If there is no job running_when this function is called, it returns true and {@link #onAbort()} will never be called._@return true if the indexer is aborted, false if a background job is running and abort is delayed.;public synchronized boolean abort() {_        IndexerState prevState = state.getAndUpdate((prev) -> IndexerState.ABORTING)__        return prevState == IndexerState.STOPPED || prevState == IndexerState.STARTED__    };sets,the,internal,state,to,link,indexer,state,aborting,it,returns,false,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,abort,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,aborted,if,there,is,no,job,running,when,this,function,is,called,it,returns,true,and,link,on,abort,will,never,be,called,return,true,if,the,indexer,is,aborted,false,if,a,background,job,is,running,and,abort,is,delayed;public,synchronized,boolean,abort,indexer,state,prev,state,state,get,and,update,prev,indexer,state,aborting,return,prev,state,indexer,state,stopped,prev,state,indexer,state,started
RollupIndexer -> public synchronized boolean abort();1535139672;Sets the internal state to {@link IndexerState#ABORTING}. It returns false if an async job is running in the background and in such_case {@link #onAbort} will be called as soon as the background job detects that the indexer is aborted. If there is no job running_when this function is called, it returns true and {@link #onAbort()} will never be called._@return true if the indexer is aborted, false if a background job is running and abort is delayed.;public synchronized boolean abort() {_        IndexerState prevState = state.getAndUpdate((prev) -> IndexerState.ABORTING)__        return prevState == IndexerState.STOPPED || prevState == IndexerState.STARTED__    };sets,the,internal,state,to,link,indexer,state,aborting,it,returns,false,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,abort,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,aborted,if,there,is,no,job,running,when,this,function,is,called,it,returns,true,and,link,on,abort,will,never,be,called,return,true,if,the,indexer,is,aborted,false,if,a,background,job,is,running,and,abort,is,delayed;public,synchronized,boolean,abort,indexer,state,prev,state,state,get,and,update,prev,indexer,state,aborting,return,prev,state,indexer,state,stopped,prev,state,indexer,state,started
RollupIndexer -> public synchronized boolean abort();1535383145;Sets the internal state to {@link IndexerState#ABORTING}. It returns false if an async job is running in the background and in such_case {@link #onAbort} will be called as soon as the background job detects that the indexer is aborted. If there is no job running_when this function is called, it returns true and {@link #onAbort()} will never be called._@return true if the indexer is aborted, false if a background job is running and abort is delayed.;public synchronized boolean abort() {_        IndexerState prevState = state.getAndUpdate((prev) -> IndexerState.ABORTING)__        return prevState == IndexerState.STOPPED || prevState == IndexerState.STARTED__    };sets,the,internal,state,to,link,indexer,state,aborting,it,returns,false,if,an,async,job,is,running,in,the,background,and,in,such,case,link,on,abort,will,be,called,as,soon,as,the,background,job,detects,that,the,indexer,is,aborted,if,there,is,no,job,running,when,this,function,is,called,it,returns,true,and,link,on,abort,will,never,be,called,return,true,if,the,indexer,is,aborted,false,if,a,background,job,is,running,and,abort,is,delayed;public,synchronized,boolean,abort,indexer,state,prev,state,state,get,and,update,prev,indexer,state,aborting,return,prev,state,indexer,state,stopped,prev,state,indexer,state,started
RollupIndexer -> public IndexerState getState();1524684173;Get the current state of the indexer.;public IndexerState getState() {_        return state.get()__    };get,the,current,state,of,the,indexer;public,indexer,state,get,state,return,state,get
RollupIndexer -> public IndexerState getState();1531179852;Get the current state of the indexer.;public IndexerState getState() {_        return state.get()__    };get,the,current,state,of,the,indexer;public,indexer,state,get,state,return,state,get
RollupIndexer -> public IndexerState getState();1531729807;Get the current state of the indexer.;public IndexerState getState() {_        return state.get()__    };get,the,current,state,of,the,indexer;public,indexer,state,get,state,return,state,get
RollupIndexer -> public IndexerState getState();1532028790;Get the current state of the indexer.;public IndexerState getState() {_        return state.get()__    };get,the,current,state,of,the,indexer;public,indexer,state,get,state,return,state,get
RollupIndexer -> public IndexerState getState();1533143718;Get the current state of the indexer.;public IndexerState getState() {_        return state.get()__    };get,the,current,state,of,the,indexer;public,indexer,state,get,state,return,state,get
RollupIndexer -> public IndexerState getState();1533319589;Get the current state of the indexer.;public IndexerState getState() {_        return state.get()__    };get,the,current,state,of,the,indexer;public,indexer,state,get,state,return,state,get
RollupIndexer -> public IndexerState getState();1533641732;Get the current state of the indexer.;public IndexerState getState() {_        return state.get()__    };get,the,current,state,of,the,indexer;public,indexer,state,get,state,return,state,get
RollupIndexer -> public IndexerState getState();1535139672;Get the current state of the indexer.;public IndexerState getState() {_        return state.get()__    };get,the,current,state,of,the,indexer;public,indexer,state,get,state,return,state,get
RollupIndexer -> public IndexerState getState();1535383145;Get the current state of the indexer.;public IndexerState getState() {_        return state.get()__    };get,the,current,state,of,the,indexer;public,indexer,state,get,state,return,state,get
RollupIndexer -> protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;1524684173;Called periodically during the execution of a background job. Implementation should_persists the state somewhere and continue the execution asynchronously using <code>next</code>.__@param state The current state of the indexer_@param position The current position of the indexer_@param next Runnable for the next phase;protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;called,periodically,during,the,execution,of,a,background,job,implementation,should,persists,the,state,somewhere,and,continue,the,execution,asynchronously,using,code,next,code,param,state,the,current,state,of,the,indexer,param,position,the,current,position,of,the,indexer,param,next,runnable,for,the,next,phase;protected,abstract,void,do,save,state,indexer,state,state,map,string,object,position,runnable,next
RollupIndexer -> protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;1531179852;Called periodically during the execution of a background job. Implementation should_persists the state somewhere and continue the execution asynchronously using <code>next</code>.__@param state The current state of the indexer_@param position The current position of the indexer_@param next Runnable for the next phase;protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;called,periodically,during,the,execution,of,a,background,job,implementation,should,persists,the,state,somewhere,and,continue,the,execution,asynchronously,using,code,next,code,param,state,the,current,state,of,the,indexer,param,position,the,current,position,of,the,indexer,param,next,runnable,for,the,next,phase;protected,abstract,void,do,save,state,indexer,state,state,map,string,object,position,runnable,next
RollupIndexer -> protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;1531729807;Called periodically during the execution of a background job. Implementation should_persists the state somewhere and continue the execution asynchronously using <code>next</code>.__@param state The current state of the indexer_@param position The current position of the indexer_@param next Runnable for the next phase;protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;called,periodically,during,the,execution,of,a,background,job,implementation,should,persists,the,state,somewhere,and,continue,the,execution,asynchronously,using,code,next,code,param,state,the,current,state,of,the,indexer,param,position,the,current,position,of,the,indexer,param,next,runnable,for,the,next,phase;protected,abstract,void,do,save,state,indexer,state,state,map,string,object,position,runnable,next
RollupIndexer -> protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;1532028790;Called periodically during the execution of a background job. Implementation should_persists the state somewhere and continue the execution asynchronously using <code>next</code>.__@param state The current state of the indexer_@param position The current position of the indexer_@param next Runnable for the next phase;protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;called,periodically,during,the,execution,of,a,background,job,implementation,should,persists,the,state,somewhere,and,continue,the,execution,asynchronously,using,code,next,code,param,state,the,current,state,of,the,indexer,param,position,the,current,position,of,the,indexer,param,next,runnable,for,the,next,phase;protected,abstract,void,do,save,state,indexer,state,state,map,string,object,position,runnable,next
RollupIndexer -> protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;1533143718;Called periodically during the execution of a background job. Implementation should_persists the state somewhere and continue the execution asynchronously using <code>next</code>.__@param state The current state of the indexer_@param position The current position of the indexer_@param next Runnable for the next phase;protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;called,periodically,during,the,execution,of,a,background,job,implementation,should,persists,the,state,somewhere,and,continue,the,execution,asynchronously,using,code,next,code,param,state,the,current,state,of,the,indexer,param,position,the,current,position,of,the,indexer,param,next,runnable,for,the,next,phase;protected,abstract,void,do,save,state,indexer,state,state,map,string,object,position,runnable,next
RollupIndexer -> protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;1533319589;Called periodically during the execution of a background job. Implementation should_persists the state somewhere and continue the execution asynchronously using <code>next</code>.__@param state The current state of the indexer_@param position The current position of the indexer_@param next Runnable for the next phase;protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;called,periodically,during,the,execution,of,a,background,job,implementation,should,persists,the,state,somewhere,and,continue,the,execution,asynchronously,using,code,next,code,param,state,the,current,state,of,the,indexer,param,position,the,current,position,of,the,indexer,param,next,runnable,for,the,next,phase;protected,abstract,void,do,save,state,indexer,state,state,map,string,object,position,runnable,next
RollupIndexer -> protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;1533641732;Called periodically during the execution of a background job. Implementation should_persists the state somewhere and continue the execution asynchronously using <code>next</code>.__@param state The current state of the indexer_@param position The current position of the indexer_@param next Runnable for the next phase;protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;called,periodically,during,the,execution,of,a,background,job,implementation,should,persists,the,state,somewhere,and,continue,the,execution,asynchronously,using,code,next,code,param,state,the,current,state,of,the,indexer,param,position,the,current,position,of,the,indexer,param,next,runnable,for,the,next,phase;protected,abstract,void,do,save,state,indexer,state,state,map,string,object,position,runnable,next
RollupIndexer -> protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;1535139672;Called periodically during the execution of a background job. Implementation should_persists the state somewhere and continue the execution asynchronously using <code>next</code>.__@param state The current state of the indexer_@param position The current position of the indexer_@param next Runnable for the next phase;protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;called,periodically,during,the,execution,of,a,background,job,implementation,should,persists,the,state,somewhere,and,continue,the,execution,asynchronously,using,code,next,code,param,state,the,current,state,of,the,indexer,param,position,the,current,position,of,the,indexer,param,next,runnable,for,the,next,phase;protected,abstract,void,do,save,state,indexer,state,state,map,string,object,position,runnable,next
RollupIndexer -> protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;1535383145;Called periodically during the execution of a background job. Implementation should_persists the state somewhere and continue the execution asynchronously using <code>next</code>.__@param state The current state of the indexer_@param position The current position of the indexer_@param next Runnable for the next phase;protected abstract void doSaveState(IndexerState state, Map<String, Object> position, Runnable next)_;called,periodically,during,the,execution,of,a,background,job,implementation,should,persists,the,state,somewhere,and,continue,the,execution,asynchronously,using,code,next,code,param,state,the,current,state,of,the,indexer,param,position,the,current,position,of,the,indexer,param,next,runnable,for,the,next,phase;protected,abstract,void,do,save,state,indexer,state,state,map,string,object,position,runnable,next
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1524684173;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = new ArrayList<>()__        Map<String, Object> metadata = new HashMap<>()___        _        if (groupConfig != null) {_            builders.addAll(groupConfig.getDateHisto().toBuilders())__            metadata.putAll(groupConfig.getDateHisto().getMetadata())__            if (groupConfig.getHisto() != null) {_                builders.addAll(groupConfig.getHisto().toBuilders())__                metadata.putAll(groupConfig.getHisto().getMetadata())__            }_            if (groupConfig.getTerms() != null) {_                builders.addAll(groupConfig.getTerms().toBuilders())__                metadata.putAll(groupConfig.getTerms().getMetadata())__            }_        }__        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)__        config.getMetricsConfig().forEach(m -> m.toBuilders().forEach(composite::subAggregation))__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())__        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,new,array,list,map,string,object,metadata,new,hash,map,if,group,config,null,builders,add,all,group,config,get,date,histo,to,builders,metadata,put,all,group,config,get,date,histo,get,metadata,if,group,config,get,histo,null,builders,add,all,group,config,get,histo,to,builders,metadata,put,all,group,config,get,histo,get,metadata,if,group,config,get,terms,null,builders,add,all,group,config,get,terms,to,builders,metadata,put,all,group,config,get,terms,get,metadata,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,config,get,metrics,config,for,each,m,m,to,builders,for,each,composite,sub,aggregation,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1531179852;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = new ArrayList<>()__        Map<String, Object> metadata = new HashMap<>()___        _        if (groupConfig != null) {_            builders.addAll(groupConfig.getDateHisto().toBuilders())__            metadata.putAll(groupConfig.getDateHisto().getMetadata())__            if (groupConfig.getHisto() != null) {_                builders.addAll(groupConfig.getHisto().toBuilders())__                metadata.putAll(groupConfig.getHisto().getMetadata())__            }_            if (groupConfig.getTerms() != null) {_                builders.addAll(groupConfig.getTerms().toBuilders())__                metadata.putAll(groupConfig.getTerms().getMetadata())__            }_        }__        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)__        config.getMetricsConfig().forEach(m -> m.toBuilders().forEach(composite::subAggregation))__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())__        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,new,array,list,map,string,object,metadata,new,hash,map,if,group,config,null,builders,add,all,group,config,get,date,histo,to,builders,metadata,put,all,group,config,get,date,histo,get,metadata,if,group,config,get,histo,null,builders,add,all,group,config,get,histo,to,builders,metadata,put,all,group,config,get,histo,get,metadata,if,group,config,get,terms,null,builders,add,all,group,config,get,terms,to,builders,metadata,put,all,group,config,get,terms,get,metadata,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,config,get,metrics,config,for,each,m,m,to,builders,for,each,composite,sub,aggregation,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1531729807;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = new ArrayList<>()__        Map<String, Object> metadata = new HashMap<>()___        _        if (groupConfig != null) {_            builders.addAll(groupConfig.getDateHisto().toBuilders())__            metadata.putAll(groupConfig.getDateHisto().getMetadata())__            if (groupConfig.getHisto() != null) {_                builders.addAll(groupConfig.getHisto().toBuilders())__                metadata.putAll(groupConfig.getHisto().getMetadata())__            }_            if (groupConfig.getTerms() != null) {_                builders.addAll(groupConfig.getTerms().toBuilders())__                metadata.putAll(groupConfig.getTerms().getMetadata())__            }_        }__        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)__        config.getMetricsConfig().forEach(m -> m.toBuilders().forEach(composite::subAggregation))__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,new,array,list,map,string,object,metadata,new,hash,map,if,group,config,null,builders,add,all,group,config,get,date,histo,to,builders,metadata,put,all,group,config,get,date,histo,get,metadata,if,group,config,get,histo,null,builders,add,all,group,config,get,histo,to,builders,metadata,put,all,group,config,get,histo,get,metadata,if,group,config,get,terms,null,builders,add,all,group,config,get,terms,to,builders,metadata,put,all,group,config,get,terms,get,metadata,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,config,get,metrics,config,for,each,m,m,to,builders,for,each,composite,sub,aggregation,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1532028790;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = new ArrayList<>()__        Map<String, Object> metadata = new HashMap<>()___        _        if (groupConfig != null) {_            builders.addAll(groupConfig.getDateHisto().toBuilders())__            metadata.putAll(groupConfig.getDateHisto().getMetadata())__            if (groupConfig.getHisto() != null) {_                builders.addAll(groupConfig.getHisto().toBuilders())__                metadata.putAll(groupConfig.getHisto().getMetadata())__            }_            if (groupConfig.getTerms() != null) {_                builders.addAll(groupConfig.getTerms().toBuilders())__                metadata.putAll(groupConfig.getTerms().getMetadata())__            }_        }__        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)__        config.getMetricsConfig().forEach(m -> m.toBuilders().forEach(composite::subAggregation))__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,new,array,list,map,string,object,metadata,new,hash,map,if,group,config,null,builders,add,all,group,config,get,date,histo,to,builders,metadata,put,all,group,config,get,date,histo,get,metadata,if,group,config,get,histo,null,builders,add,all,group,config,get,histo,to,builders,metadata,put,all,group,config,get,histo,get,metadata,if,group,config,get,terms,null,builders,add,all,group,config,get,terms,to,builders,metadata,put,all,group,config,get,terms,get,metadata,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,config,get,metrics,config,for,each,m,m,to,builders,for,each,composite,sub,aggregation,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1533143718;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = new ArrayList<>()__        Map<String, Object> metadata = new HashMap<>()___        _        if (groupConfig != null) {_            builders.addAll(groupConfig.getDateHisto().toBuilders())__            metadata.putAll(groupConfig.getDateHisto().getMetadata())__            if (groupConfig.getHisto() != null) {_                builders.addAll(groupConfig.getHisto().toBuilders())__                metadata.putAll(groupConfig.getHisto().getMetadata())__            }_            if (groupConfig.getTerms() != null) {_                builders.addAll(groupConfig.getTerms().toBuilders())__            }_        }__        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)__        config.getMetricsConfig().forEach(m -> m.toBuilders().forEach(composite::subAggregation))__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,new,array,list,map,string,object,metadata,new,hash,map,if,group,config,null,builders,add,all,group,config,get,date,histo,to,builders,metadata,put,all,group,config,get,date,histo,get,metadata,if,group,config,get,histo,null,builders,add,all,group,config,get,histo,to,builders,metadata,put,all,group,config,get,histo,get,metadata,if,group,config,get,terms,null,builders,add,all,group,config,get,terms,to,builders,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,config,get,metrics,config,for,each,m,m,to,builders,for,each,composite,sub,aggregation,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1533319589;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = new ArrayList<>()__        Map<String, Object> metadata = new HashMap<>()___        _        if (groupConfig != null) {_            builders.addAll(groupConfig.getDateHisto().toBuilders())__            metadata.putAll(groupConfig.getDateHisto().getMetadata())__            if (groupConfig.getHisto() != null) {_                builders.addAll(groupConfig.getHisto().toBuilders())__                metadata.putAll(groupConfig.getHisto().getMetadata())__            }_            if (groupConfig.getTerms() != null) {_                builders.addAll(groupConfig.getTerms().toBuilders())__            }_        }__        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)__        config.getMetricsConfig().forEach(m -> m.toBuilders().forEach(composite::subAggregation))__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,new,array,list,map,string,object,metadata,new,hash,map,if,group,config,null,builders,add,all,group,config,get,date,histo,to,builders,metadata,put,all,group,config,get,date,histo,get,metadata,if,group,config,get,histo,null,builders,add,all,group,config,get,histo,to,builders,metadata,put,all,group,config,get,histo,get,metadata,if,group,config,get,terms,null,builders,add,all,group,config,get,terms,to,builders,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,config,get,metrics,config,for,each,m,m,to,builders,for,each,composite,sub,aggregation,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1533641732;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = new ArrayList<>()__        Map<String, Object> metadata = new HashMap<>()___        _        if (groupConfig != null) {_            builders.addAll(groupConfig.getDateHistogram().toBuilders())__            metadata.putAll(groupConfig.getDateHistogram().getMetadata())__            if (groupConfig.getHistogram() != null) {_                builders.addAll(groupConfig.getHistogram().toBuilders())__                metadata.putAll(groupConfig.getHistogram().getMetadata())__            }_            if (groupConfig.getTerms() != null) {_                builders.addAll(groupConfig.getTerms().toBuilders())__            }_        }__        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)__        config.getMetricsConfig().forEach(m -> m.toBuilders().forEach(composite::subAggregation))__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,new,array,list,map,string,object,metadata,new,hash,map,if,group,config,null,builders,add,all,group,config,get,date,histogram,to,builders,metadata,put,all,group,config,get,date,histogram,get,metadata,if,group,config,get,histogram,null,builders,add,all,group,config,get,histogram,to,builders,metadata,put,all,group,config,get,histogram,get,metadata,if,group,config,get,terms,null,builders,add,all,group,config,get,terms,to,builders,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,config,get,metrics,config,for,each,m,m,to,builders,for,each,composite,sub,aggregation,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1535139672;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = new ArrayList<>()___        _        if (groupConfig != null) {_            builders.addAll(groupConfig.getDateHistogram().toBuilders())__            if (groupConfig.getHistogram() != null) {_                builders.addAll(groupConfig.getHistogram().toBuilders())__            }_            if (groupConfig.getTerms() != null) {_                builders.addAll(groupConfig.getTerms().toBuilders())__            }_        }__        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)__        config.getMetricsConfig().forEach(m -> m.toBuilders().forEach(composite::subAggregation))___        final Map<String, Object> metadata = createMetadata(groupConfig)__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,new,array,list,if,group,config,null,builders,add,all,group,config,get,date,histogram,to,builders,if,group,config,get,histogram,null,builders,add,all,group,config,get,histogram,to,builders,if,group,config,get,terms,null,builders,add,all,group,config,get,terms,to,builders,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,config,get,metrics,config,for,each,m,m,to,builders,for,each,composite,sub,aggregation,final,map,string,object,metadata,create,metadata,group,config,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1535383145;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = createValueSourceBuilders(groupConfig)___        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)___        List<AggregationBuilder> aggregations = createAggregationBuilders(config.getMetricsConfig())__        aggregations.forEach(composite::subAggregation)___        final Map<String, Object> metadata = createMetadata(groupConfig)__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,create,value,source,builders,group,config,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,list,aggregation,builder,aggregations,create,aggregation,builders,config,get,metrics,config,aggregations,for,each,composite,sub,aggregation,final,map,string,object,metadata,create,metadata,group,config,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1535666657;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = createValueSourceBuilders(groupConfig)___        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)___        List<AggregationBuilder> aggregations = createAggregationBuilders(config.getMetricsConfig())__        aggregations.forEach(composite::subAggregation)___        final Map<String, Object> metadata = createMetadata(groupConfig)__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,create,value,source,builders,group,config,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,list,aggregation,builder,aggregations,create,aggregation,builders,config,get,metrics,config,aggregations,for,each,composite,sub,aggregation,final,map,string,object,metadata,create,metadata,group,config,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1536314350;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = createValueSourceBuilders(groupConfig)___        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)___        List<AggregationBuilder> aggregations = createAggregationBuilders(config.getMetricsConfig())__        aggregations.forEach(composite::subAggregation)___        final Map<String, Object> metadata = createMetadata(groupConfig)__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,create,value,source,builders,group,config,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,list,aggregation,builder,aggregations,create,aggregation,builders,config,get,metrics,config,aggregations,for,each,composite,sub,aggregation,final,map,string,object,metadata,create,metadata,group,config,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config);1548236405;Creates a skeleton {@link CompositeAggregationBuilder} from the provided job config._@param config The config for the job._@return The composite aggregation that creates the rollup buckets;private CompositeAggregationBuilder createCompositeBuilder(RollupJobConfig config) {_        final GroupConfig groupConfig = config.getGroupConfig()__        List<CompositeValuesSourceBuilder<?>> builders = createValueSourceBuilders(groupConfig)___        CompositeAggregationBuilder composite = new CompositeAggregationBuilder(AGGREGATION_NAME, builders)___        List<AggregationBuilder> aggregations = createAggregationBuilders(config.getMetricsConfig())__        aggregations.forEach(composite::subAggregation)___        final Map<String, Object> metadata = createMetadata(groupConfig)__        if (metadata.isEmpty() == false) {_            composite.setMetaData(metadata)__        }_        composite.size(config.getPageSize())___        return composite__    };creates,a,skeleton,link,composite,aggregation,builder,from,the,provided,job,config,param,config,the,config,for,the,job,return,the,composite,aggregation,that,creates,the,rollup,buckets;private,composite,aggregation,builder,create,composite,builder,rollup,job,config,config,final,group,config,group,config,config,get,group,config,list,composite,values,source,builder,builders,create,value,source,builders,group,config,composite,aggregation,builder,composite,new,composite,aggregation,builder,builders,list,aggregation,builder,aggregations,create,aggregation,builders,config,get,metrics,config,aggregations,for,each,composite,sub,aggregation,final,map,string,object,metadata,create,metadata,group,config,if,metadata,is,empty,false,composite,set,meta,data,metadata,composite,size,config,get,page,size,return,composite
RollupIndexer -> public boolean isUpgradedDocumentID();1533319589;Returns if this job has upgraded it's ID scheme yet or not;public boolean isUpgradedDocumentID() {_        return upgradedDocumentID.get()__    };returns,if,this,job,has,upgraded,it,s,id,scheme,yet,or,not;public,boolean,is,upgraded,document,id,return,upgraded,document,id,get
RollupIndexer -> public boolean isUpgradedDocumentID();1533641732;Returns if this job has upgraded it's ID scheme yet or not;public boolean isUpgradedDocumentID() {_        return upgradedDocumentID.get()__    };returns,if,this,job,has,upgraded,it,s,id,scheme,yet,or,not;public,boolean,is,upgraded,document,id,return,upgraded,document,id,get
RollupIndexer -> public boolean isUpgradedDocumentID();1535139672;Returns if this job has upgraded it's ID scheme yet or not;public boolean isUpgradedDocumentID() {_        return upgradedDocumentID.get()__    };returns,if,this,job,has,upgraded,it,s,id,scheme,yet,or,not;public,boolean,is,upgraded,document,id,return,upgraded,document,id,get
RollupIndexer -> public boolean isUpgradedDocumentID();1535383145;Returns if this job has upgraded it's ID scheme yet or not;public boolean isUpgradedDocumentID() {_        return upgradedDocumentID.get()__    };returns,if,this,job,has,upgraded,it,s,id,scheme,yet,or,not;public,boolean,is,upgraded,document,id,return,upgraded,document,id,get
RollupIndexer -> public boolean isUpgradedDocumentID();1535666657;Returns if this job has upgraded it's ID scheme yet or not;public boolean isUpgradedDocumentID() {_        return upgradedDocumentID.get()__    };returns,if,this,job,has,upgraded,it,s,id,scheme,yet,or,not;public,boolean,is,upgraded,document,id,return,upgraded,document,id,get
RollupIndexer -> public boolean isUpgradedDocumentID();1536314350;Returns if this job has upgraded it's ID scheme yet or not;public boolean isUpgradedDocumentID() {_        return upgradedDocumentID.get()__    };returns,if,this,job,has,upgraded,it,s,id,scheme,yet,or,not;public,boolean,is,upgraded,document,id,return,upgraded,document,id,get
RollupIndexer -> public boolean isUpgradedDocumentID();1548236405;Returns if this job has upgraded it's ID scheme yet or not;public boolean isUpgradedDocumentID() {_        return upgradedDocumentID.get()__    };returns,if,this,job,has,upgraded,it,s,id,scheme,yet,or,not;public,boolean,is,upgraded,document,id,return,upgraded,document,id,get
RollupIndexer -> protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;1524684173;Executes the {@link SearchRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The search request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;executes,the,link,search,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,search,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,search,search,request,request,action,listener,search,response,next,phase
RollupIndexer -> protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;1531179852;Executes the {@link SearchRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The search request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;executes,the,link,search,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,search,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,search,search,request,request,action,listener,search,response,next,phase
RollupIndexer -> protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;1531729807;Executes the {@link SearchRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The search request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;executes,the,link,search,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,search,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,search,search,request,request,action,listener,search,response,next,phase
RollupIndexer -> protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;1532028790;Executes the {@link SearchRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The search request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;executes,the,link,search,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,search,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,search,search,request,request,action,listener,search,response,next,phase
RollupIndexer -> protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;1533143718;Executes the {@link SearchRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The search request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;executes,the,link,search,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,search,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,search,search,request,request,action,listener,search,response,next,phase
RollupIndexer -> protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;1533319589;Executes the {@link SearchRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The search request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;executes,the,link,search,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,search,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,search,search,request,request,action,listener,search,response,next,phase
RollupIndexer -> protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;1533641732;Executes the {@link SearchRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The search request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;executes,the,link,search,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,search,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,search,search,request,request,action,listener,search,response,next,phase
RollupIndexer -> protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;1535139672;Executes the {@link SearchRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The search request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;executes,the,link,search,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,search,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,search,search,request,request,action,listener,search,response,next,phase
RollupIndexer -> protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;1535383145;Executes the {@link SearchRequest} and calls <code>nextPhase</code> with the response_or the exception if an error occurs.__@param request The search request to execute_@param nextPhase Listener for the next phase;protected abstract void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase)_;executes,the,link,search,request,and,calls,code,next,phase,code,with,the,response,or,the,exception,if,an,error,occurs,param,request,the,search,request,to,execute,param,next,phase,listener,for,the,next,phase;protected,abstract,void,do,next,search,search,request,request,action,listener,search,response,next,phase
RollupIndexer -> protected abstract void onFailure(Exception exc)_;1524684173;Called when a failure occurs in an async job causing the execution to stop._@param exc The exception;protected abstract void onFailure(Exception exc)_;called,when,a,failure,occurs,in,an,async,job,causing,the,execution,to,stop,param,exc,the,exception;protected,abstract,void,on,failure,exception,exc
RollupIndexer -> protected abstract void onFailure(Exception exc)_;1531179852;Called when a failure occurs in an async job causing the execution to stop._@param exc The exception;protected abstract void onFailure(Exception exc)_;called,when,a,failure,occurs,in,an,async,job,causing,the,execution,to,stop,param,exc,the,exception;protected,abstract,void,on,failure,exception,exc
RollupIndexer -> protected abstract void onFailure(Exception exc)_;1531729807;Called when a failure occurs in an async job causing the execution to stop._@param exc The exception;protected abstract void onFailure(Exception exc)_;called,when,a,failure,occurs,in,an,async,job,causing,the,execution,to,stop,param,exc,the,exception;protected,abstract,void,on,failure,exception,exc
RollupIndexer -> protected abstract void onFailure(Exception exc)_;1532028790;Called when a failure occurs in an async job causing the execution to stop._@param exc The exception;protected abstract void onFailure(Exception exc)_;called,when,a,failure,occurs,in,an,async,job,causing,the,execution,to,stop,param,exc,the,exception;protected,abstract,void,on,failure,exception,exc
RollupIndexer -> protected abstract void onFailure(Exception exc)_;1533143718;Called when a failure occurs in an async job causing the execution to stop._@param exc The exception;protected abstract void onFailure(Exception exc)_;called,when,a,failure,occurs,in,an,async,job,causing,the,execution,to,stop,param,exc,the,exception;protected,abstract,void,on,failure,exception,exc
RollupIndexer -> protected abstract void onFailure(Exception exc)_;1533319589;Called when a failure occurs in an async job causing the execution to stop._@param exc The exception;protected abstract void onFailure(Exception exc)_;called,when,a,failure,occurs,in,an,async,job,causing,the,execution,to,stop,param,exc,the,exception;protected,abstract,void,on,failure,exception,exc
RollupIndexer -> protected abstract void onFailure(Exception exc)_;1533641732;Called when a failure occurs in an async job causing the execution to stop._@param exc The exception;protected abstract void onFailure(Exception exc)_;called,when,a,failure,occurs,in,an,async,job,causing,the,execution,to,stop,param,exc,the,exception;protected,abstract,void,on,failure,exception,exc
RollupIndexer -> protected abstract void onFailure(Exception exc)_;1535139672;Called when a failure occurs in an async job causing the execution to stop._@param exc The exception;protected abstract void onFailure(Exception exc)_;called,when,a,failure,occurs,in,an,async,job,causing,the,execution,to,stop,param,exc,the,exception;protected,abstract,void,on,failure,exception,exc
RollupIndexer -> protected abstract void onFailure(Exception exc)_;1535383145;Called when a failure occurs in an async job causing the execution to stop._@param exc The exception;protected abstract void onFailure(Exception exc)_;called,when,a,failure,occurs,in,an,async,job,causing,the,execution,to,stop,param,exc,the,exception;protected,abstract,void,on,failure,exception,exc
RollupIndexer -> protected abstract void onFinish()_;1524684173;Called when a background job finishes.;protected abstract void onFinish()_;called,when,a,background,job,finishes;protected,abstract,void,on,finish
RollupIndexer -> protected abstract void onFinish()_;1531179852;Called when a background job finishes.;protected abstract void onFinish()_;called,when,a,background,job,finishes;protected,abstract,void,on,finish
RollupIndexer -> protected abstract void onFinish()_;1531729807;Called when a background job finishes.;protected abstract void onFinish()_;called,when,a,background,job,finishes;protected,abstract,void,on,finish
RollupIndexer -> protected abstract void onFinish()_;1532028790;Called when a background job finishes.;protected abstract void onFinish()_;called,when,a,background,job,finishes;protected,abstract,void,on,finish
RollupIndexer -> protected abstract void onFinish()_;1533143718;Called when a background job finishes.;protected abstract void onFinish()_;called,when,a,background,job,finishes;protected,abstract,void,on,finish
RollupIndexer -> protected abstract void onFinish()_;1533319589;Called when a background job finishes.;protected abstract void onFinish()_;called,when,a,background,job,finishes;protected,abstract,void,on,finish
RollupIndexer -> protected abstract void onFinish()_;1533641732;Called when a background job finishes.;protected abstract void onFinish()_;called,when,a,background,job,finishes;protected,abstract,void,on,finish
RollupIndexer -> protected abstract void onFinish()_;1535139672;Called when a background job finishes.;protected abstract void onFinish()_;called,when,a,background,job,finishes;protected,abstract,void,on,finish
RollupIndexer -> protected abstract void onFinish()_;1535383145;Called when a background job finishes.;protected abstract void onFinish()_;called,when,a,background,job,finishes;protected,abstract,void,on,finish
