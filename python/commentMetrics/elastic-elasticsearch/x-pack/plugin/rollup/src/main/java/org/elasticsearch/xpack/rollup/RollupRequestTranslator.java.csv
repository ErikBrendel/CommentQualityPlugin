# id;timestamp;commentText;codeText;commentWords;codeWords
RollupRequestTranslator -> private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,                                                                    List<QueryBuilder> filterConditions,                                                                    NamedWriteableRegistry registry);1524684173;Translate a normal date_histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__E.g. this date_histogram:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "day"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "day"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source histogram</li>_<li>Field: `{timestamp field}.date_histogram.timestamp`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent histogram name}._count`</li>_<li>Field: `{timestamp field}.date_histogram._count`</li>_</ul>_</li>_<li>Add a filter condition:</li>_<li>_<ul>_<li>Query type: TermQuery</li>_<li>Field: `{timestamp_field}.date_histogram.interval`</li>_<li>Value: `{source interval}`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,_                                                                   List<QueryBuilder> filterConditions,_                                                                   NamedWriteableRegistry registry) {_        _        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            DateHistogramAggregationBuilder rolledDateHisto_                    = new DateHistogramAggregationBuilder(source.getName())___            if (source.dateHistogramInterval() != null) {_                rolledDateHisto.dateHistogramInterval(source.dateHistogramInterval())__            } else {_                rolledDateHisto.interval(source.interval())__            }__            String timezone = source.timeZone() == null ? DateTimeZone.UTC.toString() : source.timeZone().toString()__            filterConditions.add(new TermQueryBuilder(RollupField.formatFieldName(source,_                    DateHistoGroupConfig.TIME_ZONE.getPreferredName()), timezone))___            rolledDateHisto.offset(source.offset())__            if (source.extendedBounds() != null) {_                rolledDateHisto.extendedBounds(source.extendedBounds())__            }_            rolledDateHisto.keyed(source.keyed())__            rolledDateHisto.minDocCount(source.minDocCount())__            rolledDateHisto.order(source.order())__            rolledDateHisto.field(RollupField.formatFieldName(source, RollupField.TIMESTAMP))__            rolledDateHisto.setMetaData(source.getMetaData())__            return rolledDateHisto__        })__    };translate,a,normal,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,pre,code,post,foo,aggregations,field,ts,interval,day,pre,is,translated,into,pre,code,post,aggregations,field,ts,timestamp,interval,day,aggregations,sum,field,ts,pre,the,conventions,are,ul,li,named,same,as,the,source,histogram,li,li,field,timestamp,field,timestamp,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,histogram,name,li,li,field,timestamp,field,li,ul,li,li,add,a,filter,condition,li,li,ul,li,query,type,term,query,li,li,field,interval,li,li,value,source,interval,li,ul,li,ul;private,static,list,aggregation,builder,translate,date,histogram,date,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,date,histogram,aggregation,builder,rolled,date,histo,new,date,histogram,aggregation,builder,source,get,name,if,source,date,histogram,interval,null,rolled,date,histo,date,histogram,interval,source,date,histogram,interval,else,rolled,date,histo,interval,source,interval,string,timezone,source,time,zone,null,date,time,zone,utc,to,string,source,time,zone,to,string,filter,conditions,add,new,term,query,builder,rollup,field,format,field,name,source,date,histo,group,config,get,preferred,name,timezone,rolled,date,histo,offset,source,offset,if,source,extended,bounds,null,rolled,date,histo,extended,bounds,source,extended,bounds,rolled,date,histo,keyed,source,keyed,rolled,date,histo,min,doc,count,source,min,doc,count,rolled,date,histo,order,source,order,rolled,date,histo,field,rollup,field,format,field,name,source,rollup,field,timestamp,rolled,date,histo,set,meta,data,source,get,meta,data,return,rolled,date,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,                                                                    List<QueryBuilder> filterConditions,                                                                    NamedWriteableRegistry registry);1532434432;Translate a normal date_histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__E.g. this date_histogram:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "day"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "day"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source histogram</li>_<li>Field: `{timestamp field}.date_histogram.timestamp`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent histogram name}._count`</li>_<li>Field: `{timestamp field}.date_histogram._count`</li>_</ul>_</li>_<li>Add a filter condition:</li>_<li>_<ul>_<li>Query type: TermQuery</li>_<li>Field: `{timestamp_field}.date_histogram.interval`</li>_<li>Value: `{source interval}`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,_                                                                   List<QueryBuilder> filterConditions,_                                                                   NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            DateHistogramAggregationBuilder rolledDateHisto_                    = new DateHistogramAggregationBuilder(source.getName())___            if (source.dateHistogramInterval() != null) {_                rolledDateHisto.dateHistogramInterval(source.dateHistogramInterval())__            } else {_                rolledDateHisto.interval(source.interval())__            }__            String timezone = source.timeZone() == null ? DateTimeZone.UTC.toString() : source.timeZone().toString()__            filterConditions.add(new TermQueryBuilder(RollupField.formatFieldName(source,_                    DateHistoGroupConfig.TIME_ZONE.getPreferredName()), timezone))___            rolledDateHisto.offset(source.offset())__            if (source.extendedBounds() != null) {_                rolledDateHisto.extendedBounds(source.extendedBounds())__            }_            rolledDateHisto.keyed(source.keyed())__            rolledDateHisto.minDocCount(source.minDocCount())__            rolledDateHisto.order(source.order())__            rolledDateHisto.field(RollupField.formatFieldName(source, RollupField.TIMESTAMP))__            rolledDateHisto.setMetaData(source.getMetaData())__            return rolledDateHisto__        })__    };translate,a,normal,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,pre,code,post,foo,aggregations,field,ts,interval,day,pre,is,translated,into,pre,code,post,aggregations,field,ts,timestamp,interval,day,aggregations,sum,field,ts,pre,the,conventions,are,ul,li,named,same,as,the,source,histogram,li,li,field,timestamp,field,timestamp,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,histogram,name,li,li,field,timestamp,field,li,ul,li,li,add,a,filter,condition,li,li,ul,li,query,type,term,query,li,li,field,interval,li,li,value,source,interval,li,ul,li,ul;private,static,list,aggregation,builder,translate,date,histogram,date,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,date,histogram,aggregation,builder,rolled,date,histo,new,date,histogram,aggregation,builder,source,get,name,if,source,date,histogram,interval,null,rolled,date,histo,date,histogram,interval,source,date,histogram,interval,else,rolled,date,histo,interval,source,interval,string,timezone,source,time,zone,null,date,time,zone,utc,to,string,source,time,zone,to,string,filter,conditions,add,new,term,query,builder,rollup,field,format,field,name,source,date,histo,group,config,get,preferred,name,timezone,rolled,date,histo,offset,source,offset,if,source,extended,bounds,null,rolled,date,histo,extended,bounds,source,extended,bounds,rolled,date,histo,keyed,source,keyed,rolled,date,histo,min,doc,count,source,min,doc,count,rolled,date,histo,order,source,order,rolled,date,histo,field,rollup,field,format,field,name,source,rollup,field,timestamp,rolled,date,histo,set,meta,data,source,get,meta,data,return,rolled,date,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,                                                                    List<QueryBuilder> filterConditions,                                                                    NamedWriteableRegistry registry);1533319589;Translate a normal date_histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__E.g. this date_histogram:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "day"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "day"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source histogram</li>_<li>Field: `{timestamp field}.date_histogram.timestamp`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent histogram name}._count`</li>_<li>Field: `{timestamp field}.date_histogram._count`</li>_</ul>_</li>_<li>Add a filter condition:</li>_<li>_<ul>_<li>Query type: TermQuery</li>_<li>Field: `{timestamp_field}.date_histogram.interval`</li>_<li>Value: `{source interval}`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,_                                                                   List<QueryBuilder> filterConditions,_                                                                   NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            DateHistogramAggregationBuilder rolledDateHisto_                    = new DateHistogramAggregationBuilder(source.getName())___            if (source.dateHistogramInterval() != null) {_                rolledDateHisto.dateHistogramInterval(source.dateHistogramInterval())__            } else {_                rolledDateHisto.interval(source.interval())__            }__            String timezone = source.timeZone() == null ? DateTimeZone.UTC.toString() : source.timeZone().toString()__            filterConditions.add(new TermQueryBuilder(RollupField.formatFieldName(source,_                DateHistogramGroupConfig.TIME_ZONE), timezone))___            rolledDateHisto.offset(source.offset())__            if (source.extendedBounds() != null) {_                rolledDateHisto.extendedBounds(source.extendedBounds())__            }_            rolledDateHisto.keyed(source.keyed())__            rolledDateHisto.minDocCount(source.minDocCount())__            rolledDateHisto.order(source.order())__            rolledDateHisto.field(RollupField.formatFieldName(source, RollupField.TIMESTAMP))__            rolledDateHisto.setMetaData(source.getMetaData())__            return rolledDateHisto__        })__    };translate,a,normal,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,pre,code,post,foo,aggregations,field,ts,interval,day,pre,is,translated,into,pre,code,post,aggregations,field,ts,timestamp,interval,day,aggregations,sum,field,ts,pre,the,conventions,are,ul,li,named,same,as,the,source,histogram,li,li,field,timestamp,field,timestamp,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,histogram,name,li,li,field,timestamp,field,li,ul,li,li,add,a,filter,condition,li,li,ul,li,query,type,term,query,li,li,field,interval,li,li,value,source,interval,li,ul,li,ul;private,static,list,aggregation,builder,translate,date,histogram,date,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,date,histogram,aggregation,builder,rolled,date,histo,new,date,histogram,aggregation,builder,source,get,name,if,source,date,histogram,interval,null,rolled,date,histo,date,histogram,interval,source,date,histogram,interval,else,rolled,date,histo,interval,source,interval,string,timezone,source,time,zone,null,date,time,zone,utc,to,string,source,time,zone,to,string,filter,conditions,add,new,term,query,builder,rollup,field,format,field,name,source,date,histogram,group,config,timezone,rolled,date,histo,offset,source,offset,if,source,extended,bounds,null,rolled,date,histo,extended,bounds,source,extended,bounds,rolled,date,histo,keyed,source,keyed,rolled,date,histo,min,doc,count,source,min,doc,count,rolled,date,histo,order,source,order,rolled,date,histo,field,rollup,field,format,field,name,source,rollup,field,timestamp,rolled,date,histo,set,meta,data,source,get,meta,data,return,rolled,date,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,                                                                    List<QueryBuilder> filterConditions,                                                                    NamedWriteableRegistry registry);1536314350;Translate a normal date_histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__E.g. this date_histogram:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "day"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "day"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source histogram</li>_<li>Field: `{timestamp field}.date_histogram.timestamp`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent histogram name}._count`</li>_<li>Field: `{timestamp field}.date_histogram._count`</li>_</ul>_</li>_<li>Add a filter condition:</li>_<li>_<ul>_<li>Query type: TermQuery</li>_<li>Field: `{timestamp_field}.date_histogram.interval`</li>_<li>Value: `{source interval}`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,_                                                                   List<QueryBuilder> filterConditions,_                                                                   NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            DateHistogramAggregationBuilder rolledDateHisto_                    = new DateHistogramAggregationBuilder(source.getName())___            if (source.dateHistogramInterval() != null) {_                rolledDateHisto.dateHistogramInterval(source.dateHistogramInterval())__            } else {_                rolledDateHisto.interval(source.interval())__            }__            String timezone = source.timeZone() == null ? DateTimeZone.UTC.toString() : source.timeZone().toString()__            filterConditions.add(new TermQueryBuilder(RollupField.formatFieldName(source,_                DateHistogramGroupConfig.TIME_ZONE), timezone))___            rolledDateHisto.offset(source.offset())__            if (source.extendedBounds() != null) {_                rolledDateHisto.extendedBounds(source.extendedBounds())__            }_            rolledDateHisto.keyed(source.keyed())__            rolledDateHisto.minDocCount(source.minDocCount())__            rolledDateHisto.order(source.order())__            rolledDateHisto.field(RollupField.formatFieldName(source, RollupField.TIMESTAMP))__            rolledDateHisto.setMetaData(source.getMetaData())__            return rolledDateHisto__        })__    };translate,a,normal,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,pre,code,post,foo,aggregations,field,ts,interval,day,pre,is,translated,into,pre,code,post,aggregations,field,ts,timestamp,interval,day,aggregations,sum,field,ts,pre,the,conventions,are,ul,li,named,same,as,the,source,histogram,li,li,field,timestamp,field,timestamp,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,histogram,name,li,li,field,timestamp,field,li,ul,li,li,add,a,filter,condition,li,li,ul,li,query,type,term,query,li,li,field,interval,li,li,value,source,interval,li,ul,li,ul;private,static,list,aggregation,builder,translate,date,histogram,date,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,date,histogram,aggregation,builder,rolled,date,histo,new,date,histogram,aggregation,builder,source,get,name,if,source,date,histogram,interval,null,rolled,date,histo,date,histogram,interval,source,date,histogram,interval,else,rolled,date,histo,interval,source,interval,string,timezone,source,time,zone,null,date,time,zone,utc,to,string,source,time,zone,to,string,filter,conditions,add,new,term,query,builder,rollup,field,format,field,name,source,date,histogram,group,config,timezone,rolled,date,histo,offset,source,offset,if,source,extended,bounds,null,rolled,date,histo,extended,bounds,source,extended,bounds,rolled,date,histo,keyed,source,keyed,rolled,date,histo,min,doc,count,source,min,doc,count,rolled,date,histo,order,source,order,rolled,date,histo,field,rollup,field,format,field,name,source,rollup,field,timestamp,rolled,date,histo,set,meta,data,source,get,meta,data,return,rolled,date,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,                                                                    List<QueryBuilder> filterConditions,                                                                    NamedWriteableRegistry registry);1539951844;Translate a normal date_histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__E.g. this date_histogram:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "day"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "day"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source histogram</li>_<li>Field: `{timestamp field}.date_histogram.timestamp`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent histogram name}._count`</li>_<li>Field: `{timestamp field}.date_histogram._count`</li>_</ul>_</li>_<li>Add a filter condition:</li>_<li>_<ul>_<li>Query type: TermQuery</li>_<li>Field: `{timestamp_field}.date_histogram.interval`</li>_<li>Value: `{source interval}`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateDateHistogram(DateHistogramAggregationBuilder source,_                                                                   List<QueryBuilder> filterConditions,_                                                                   NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            DateHistogramAggregationBuilder rolledDateHisto_                    = new DateHistogramAggregationBuilder(source.getName())___            if (source.dateHistogramInterval() != null) {_                rolledDateHisto.dateHistogramInterval(source.dateHistogramInterval())__            } else {_                rolledDateHisto.interval(source.interval())__            }__            String timezone = source.timeZone() == null ? DateTimeZone.UTC.toString() : source.timeZone().toString()__            filterConditions.add(new TermQueryBuilder(RollupField.formatFieldName(source,_                DateHistogramGroupConfig.TIME_ZONE), timezone))___            rolledDateHisto.offset(source.offset())__            if (source.extendedBounds() != null) {_                rolledDateHisto.extendedBounds(source.extendedBounds())__            }_            if (Strings.isNullOrEmpty(source.format()) == false) {_                rolledDateHisto.format(source.format())__            }_            rolledDateHisto.keyed(source.keyed())__            rolledDateHisto.minDocCount(source.minDocCount())__            rolledDateHisto.order(source.order())__            rolledDateHisto.field(RollupField.formatFieldName(source, RollupField.TIMESTAMP))__            rolledDateHisto.setMetaData(source.getMetaData())__            return rolledDateHisto__        })__    };translate,a,normal,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,pre,code,post,foo,aggregations,field,ts,interval,day,pre,is,translated,into,pre,code,post,aggregations,field,ts,timestamp,interval,day,aggregations,sum,field,ts,pre,the,conventions,are,ul,li,named,same,as,the,source,histogram,li,li,field,timestamp,field,timestamp,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,histogram,name,li,li,field,timestamp,field,li,ul,li,li,add,a,filter,condition,li,li,ul,li,query,type,term,query,li,li,field,interval,li,li,value,source,interval,li,ul,li,ul;private,static,list,aggregation,builder,translate,date,histogram,date,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,date,histogram,aggregation,builder,rolled,date,histo,new,date,histogram,aggregation,builder,source,get,name,if,source,date,histogram,interval,null,rolled,date,histo,date,histogram,interval,source,date,histogram,interval,else,rolled,date,histo,interval,source,interval,string,timezone,source,time,zone,null,date,time,zone,utc,to,string,source,time,zone,to,string,filter,conditions,add,new,term,query,builder,rollup,field,format,field,name,source,date,histogram,group,config,timezone,rolled,date,histo,offset,source,offset,if,source,extended,bounds,null,rolled,date,histo,extended,bounds,source,extended,bounds,if,strings,is,null,or,empty,source,format,false,rolled,date,histo,format,source,format,rolled,date,histo,keyed,source,keyed,rolled,date,histo,min,doc,count,source,min,doc,count,rolled,date,histo,order,source,order,rolled,date,histo,field,rollup,field,format,field,name,source,rollup,field,timestamp,rolled,date,histo,set,meta,data,source,get,meta,data,return,rolled,date,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,                                                                List<QueryBuilder> filterConditions,                                                                NamedWriteableRegistry registry);1524684173;Translate a normal histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__Conventions are identical to a date_histogram (excepting date-specific details), so see_{@link #translateDateHistogram(DateHistogramAggregationBuilder, List, NamedWriteableRegistry)} for_a complete list of conventions, examples, etc;private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,_                                                               List<QueryBuilder> filterConditions,_                                                               NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            HistogramAggregationBuilder rolledHisto_                    = new HistogramAggregationBuilder(source.getName())___            rolledHisto.interval(source.interval())__            rolledHisto.offset(source.offset())__            if (Double.isFinite(source.minBound()) && Double.isFinite(source.maxBound())) {_                rolledHisto.extendedBounds(source.minBound(), source.maxBound())__            }_            rolledHisto.keyed(source.keyed())__            rolledHisto.minDocCount(source.minDocCount())__            rolledHisto.order(source.order())__            rolledHisto.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledHisto.setMetaData(source.getMetaData())__            return rolledHisto__        })__    };translate,a,normal,histogram,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,conventions,are,identical,to,a,excepting,date,specific,details,so,see,link,translate,date,histogram,date,histogram,aggregation,builder,list,named,writeable,registry,for,a,complete,list,of,conventions,examples,etc;private,static,list,aggregation,builder,translate,histogram,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,histogram,aggregation,builder,rolled,histo,new,histogram,aggregation,builder,source,get,name,rolled,histo,interval,source,interval,rolled,histo,offset,source,offset,if,double,is,finite,source,min,bound,double,is,finite,source,max,bound,rolled,histo,extended,bounds,source,min,bound,source,max,bound,rolled,histo,keyed,source,keyed,rolled,histo,min,doc,count,source,min,doc,count,rolled,histo,order,source,order,rolled,histo,field,rollup,field,format,field,name,source,rollup,field,value,rolled,histo,set,meta,data,source,get,meta,data,return,rolled,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,                                                                List<QueryBuilder> filterConditions,                                                                NamedWriteableRegistry registry);1532434432;Translate a normal histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__Conventions are identical to a date_histogram (excepting date-specific details), so see_{@link #translateDateHistogram(DateHistogramAggregationBuilder, List, NamedWriteableRegistry)} for_a complete list of conventions, examples, etc;private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,_                                                               List<QueryBuilder> filterConditions,_                                                               NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            HistogramAggregationBuilder rolledHisto_                    = new HistogramAggregationBuilder(source.getName())___            rolledHisto.interval(source.interval())__            rolledHisto.offset(source.offset())__            if (Double.isFinite(source.minBound()) && Double.isFinite(source.maxBound())) {_                rolledHisto.extendedBounds(source.minBound(), source.maxBound())__            }_            rolledHisto.keyed(source.keyed())__            rolledHisto.minDocCount(source.minDocCount())__            rolledHisto.order(source.order())__            rolledHisto.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledHisto.setMetaData(source.getMetaData())__            return rolledHisto__        })__    };translate,a,normal,histogram,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,conventions,are,identical,to,a,excepting,date,specific,details,so,see,link,translate,date,histogram,date,histogram,aggregation,builder,list,named,writeable,registry,for,a,complete,list,of,conventions,examples,etc;private,static,list,aggregation,builder,translate,histogram,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,histogram,aggregation,builder,rolled,histo,new,histogram,aggregation,builder,source,get,name,rolled,histo,interval,source,interval,rolled,histo,offset,source,offset,if,double,is,finite,source,min,bound,double,is,finite,source,max,bound,rolled,histo,extended,bounds,source,min,bound,source,max,bound,rolled,histo,keyed,source,keyed,rolled,histo,min,doc,count,source,min,doc,count,rolled,histo,order,source,order,rolled,histo,field,rollup,field,format,field,name,source,rollup,field,value,rolled,histo,set,meta,data,source,get,meta,data,return,rolled,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,                                                                List<QueryBuilder> filterConditions,                                                                NamedWriteableRegistry registry);1533319589;Translate a normal histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__Conventions are identical to a date_histogram (excepting date-specific details), so see_{@link #translateDateHistogram(DateHistogramAggregationBuilder, List, NamedWriteableRegistry)} for_a complete list of conventions, examples, etc;private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,_                                                               List<QueryBuilder> filterConditions,_                                                               NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            HistogramAggregationBuilder rolledHisto_                    = new HistogramAggregationBuilder(source.getName())___            rolledHisto.interval(source.interval())__            rolledHisto.offset(source.offset())__            if (Double.isFinite(source.minBound()) && Double.isFinite(source.maxBound())) {_                rolledHisto.extendedBounds(source.minBound(), source.maxBound())__            }_            rolledHisto.keyed(source.keyed())__            rolledHisto.minDocCount(source.minDocCount())__            rolledHisto.order(source.order())__            rolledHisto.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledHisto.setMetaData(source.getMetaData())__            return rolledHisto__        })__    };translate,a,normal,histogram,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,conventions,are,identical,to,a,excepting,date,specific,details,so,see,link,translate,date,histogram,date,histogram,aggregation,builder,list,named,writeable,registry,for,a,complete,list,of,conventions,examples,etc;private,static,list,aggregation,builder,translate,histogram,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,histogram,aggregation,builder,rolled,histo,new,histogram,aggregation,builder,source,get,name,rolled,histo,interval,source,interval,rolled,histo,offset,source,offset,if,double,is,finite,source,min,bound,double,is,finite,source,max,bound,rolled,histo,extended,bounds,source,min,bound,source,max,bound,rolled,histo,keyed,source,keyed,rolled,histo,min,doc,count,source,min,doc,count,rolled,histo,order,source,order,rolled,histo,field,rollup,field,format,field,name,source,rollup,field,value,rolled,histo,set,meta,data,source,get,meta,data,return,rolled,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,                                                                List<QueryBuilder> filterConditions,                                                                NamedWriteableRegistry registry);1536314350;Translate a normal histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__Conventions are identical to a date_histogram (excepting date-specific details), so see_{@link #translateDateHistogram(DateHistogramAggregationBuilder, List, NamedWriteableRegistry)} for_a complete list of conventions, examples, etc;private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,_                                                               List<QueryBuilder> filterConditions,_                                                               NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            HistogramAggregationBuilder rolledHisto_                    = new HistogramAggregationBuilder(source.getName())___            rolledHisto.interval(source.interval())__            rolledHisto.offset(source.offset())__            if (Double.isFinite(source.minBound()) && Double.isFinite(source.maxBound())) {_                rolledHisto.extendedBounds(source.minBound(), source.maxBound())__            }_            rolledHisto.keyed(source.keyed())__            rolledHisto.minDocCount(source.minDocCount())__            rolledHisto.order(source.order())__            rolledHisto.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledHisto.setMetaData(source.getMetaData())__            return rolledHisto__        })__    };translate,a,normal,histogram,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,conventions,are,identical,to,a,excepting,date,specific,details,so,see,link,translate,date,histogram,date,histogram,aggregation,builder,list,named,writeable,registry,for,a,complete,list,of,conventions,examples,etc;private,static,list,aggregation,builder,translate,histogram,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,histogram,aggregation,builder,rolled,histo,new,histogram,aggregation,builder,source,get,name,rolled,histo,interval,source,interval,rolled,histo,offset,source,offset,if,double,is,finite,source,min,bound,double,is,finite,source,max,bound,rolled,histo,extended,bounds,source,min,bound,source,max,bound,rolled,histo,keyed,source,keyed,rolled,histo,min,doc,count,source,min,doc,count,rolled,histo,order,source,order,rolled,histo,field,rollup,field,format,field,name,source,rollup,field,value,rolled,histo,set,meta,data,source,get,meta,data,return,rolled,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,                                                                List<QueryBuilder> filterConditions,                                                                NamedWriteableRegistry registry);1539951844;Translate a normal histogram into one that follows the rollup conventions._Notably, it adds a Sum metric to calculate the doc_count in each bucket.__Conventions are identical to a date_histogram (excepting date-specific details), so see_{@link #translateDateHistogram(DateHistogramAggregationBuilder, List, NamedWriteableRegistry)} for_a complete list of conventions, examples, etc;private static List<AggregationBuilder> translateHistogram(HistogramAggregationBuilder source,_                                                               List<QueryBuilder> filterConditions,_                                                               NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            HistogramAggregationBuilder rolledHisto_                    = new HistogramAggregationBuilder(source.getName())___            rolledHisto.interval(source.interval())__            rolledHisto.offset(source.offset())__            if (Double.isFinite(source.minBound()) && Double.isFinite(source.maxBound())) {_                rolledHisto.extendedBounds(source.minBound(), source.maxBound())__            }_            rolledHisto.keyed(source.keyed())__            rolledHisto.minDocCount(source.minDocCount())__            rolledHisto.order(source.order())__            rolledHisto.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledHisto.setMetaData(source.getMetaData())__            return rolledHisto__        })__    };translate,a,normal,histogram,into,one,that,follows,the,rollup,conventions,notably,it,adds,a,sum,metric,to,calculate,the,in,each,bucket,conventions,are,identical,to,a,excepting,date,specific,details,so,see,link,translate,date,histogram,date,histogram,aggregation,builder,list,named,writeable,registry,for,a,complete,list,of,conventions,examples,etc;private,static,list,aggregation,builder,translate,histogram,histogram,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,histogram,aggregation,builder,rolled,histo,new,histogram,aggregation,builder,source,get,name,rolled,histo,interval,source,interval,rolled,histo,offset,source,offset,if,double,is,finite,source,min,bound,double,is,finite,source,max,bound,rolled,histo,extended,bounds,source,min,bound,source,max,bound,rolled,histo,keyed,source,keyed,rolled,histo,min,doc,count,source,min,doc,count,rolled,histo,order,source,order,rolled,histo,field,rollup,field,format,field,name,source,rollup,field,value,rolled,histo,set,meta,data,source,get,meta,data,return,rolled,histo
RollupRequestTranslator -> private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,                                                            List<QueryBuilder> filterConditions,                                                            NamedWriteableRegistry registry);1524684173;Translate a normal terms agg into one that follows the rollup conventions._Notably, it adds metadata to the terms, and a Sum metric to calculate the doc_count_in each bucket.__E.g. this terms agg:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_terms": {_"terms" : {_"field" : "foo"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_terms" : {_"terms" : {_"field" : "foo.terms.value"__"aggregations" : {_"the_terms._count" : {_"sum" : { "field" : "foo.terms._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source terms agg</li>_<li>Field: `{field name}.terms.value`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent terms name}._count`</li>_<li>Field: `{field name}.terms._count`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,_                                                           List<QueryBuilder> filterConditions,_                                                           NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            TermsAggregationBuilder rolledTerms_                    = new TermsAggregationBuilder(source.getName(), source.valueType())__            rolledTerms.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledTerms.includeExclude(source.includeExclude())__            if (source.collectMode() != null) {_                rolledTerms.collectMode(source.collectMode())__            }_            rolledTerms.minDocCount(source.minDocCount())__            rolledTerms.executionHint(source.executionHint())__            if (source.order() != null) {_                rolledTerms.order(source.order())__            }_            rolledTerms.shardMinDocCount(source.shardMinDocCount())__            if (source.shardSize() > 0) {_                rolledTerms.shardSize(source.shardSize())__            }_            rolledTerms.showTermDocCountError(source.showTermDocCountError())__            rolledTerms.size(source.size())__            return rolledTerms__        })__    };translate,a,normal,terms,agg,into,one,that,follows,the,rollup,conventions,notably,it,adds,metadata,to,the,terms,and,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,terms,agg,pre,code,post,foo,aggregations,terms,field,foo,pre,is,translated,into,pre,code,post,aggregations,terms,field,foo,terms,value,aggregations,sum,field,foo,terms,pre,the,conventions,are,ul,li,named,same,as,the,source,terms,agg,li,li,field,field,name,terms,value,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,terms,name,li,li,field,field,name,terms,li,ul,li,ul;private,static,list,aggregation,builder,translate,terms,terms,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,terms,aggregation,builder,rolled,terms,new,terms,aggregation,builder,source,get,name,source,value,type,rolled,terms,field,rollup,field,format,field,name,source,rollup,field,value,rolled,terms,include,exclude,source,include,exclude,if,source,collect,mode,null,rolled,terms,collect,mode,source,collect,mode,rolled,terms,min,doc,count,source,min,doc,count,rolled,terms,execution,hint,source,execution,hint,if,source,order,null,rolled,terms,order,source,order,rolled,terms,shard,min,doc,count,source,shard,min,doc,count,if,source,shard,size,0,rolled,terms,shard,size,source,shard,size,rolled,terms,show,term,doc,count,error,source,show,term,doc,count,error,rolled,terms,size,source,size,return,rolled,terms
RollupRequestTranslator -> private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,                                                            List<QueryBuilder> filterConditions,                                                            NamedWriteableRegistry registry);1532434432;Translate a normal terms agg into one that follows the rollup conventions._Notably, it adds metadata to the terms, and a Sum metric to calculate the doc_count_in each bucket.__E.g. this terms agg:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_terms": {_"terms" : {_"field" : "foo"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_terms" : {_"terms" : {_"field" : "foo.terms.value"__"aggregations" : {_"the_terms._count" : {_"sum" : { "field" : "foo.terms._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source terms agg</li>_<li>Field: `{field name}.terms.value`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent terms name}._count`</li>_<li>Field: `{field name}.terms._count`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,_                                                           List<QueryBuilder> filterConditions,_                                                           NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            TermsAggregationBuilder rolledTerms_                    = new TermsAggregationBuilder(source.getName(), source.valueType())__            rolledTerms.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledTerms.includeExclude(source.includeExclude())__            if (source.collectMode() != null) {_                rolledTerms.collectMode(source.collectMode())__            }_            rolledTerms.minDocCount(source.minDocCount())__            rolledTerms.executionHint(source.executionHint())__            if (source.order() != null) {_                rolledTerms.order(source.order())__            }_            rolledTerms.shardMinDocCount(source.shardMinDocCount())__            if (source.shardSize() > 0) {_                rolledTerms.shardSize(source.shardSize())__            }_            rolledTerms.showTermDocCountError(source.showTermDocCountError())__            rolledTerms.size(source.size())__            return rolledTerms__        })__    };translate,a,normal,terms,agg,into,one,that,follows,the,rollup,conventions,notably,it,adds,metadata,to,the,terms,and,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,terms,agg,pre,code,post,foo,aggregations,terms,field,foo,pre,is,translated,into,pre,code,post,aggregations,terms,field,foo,terms,value,aggregations,sum,field,foo,terms,pre,the,conventions,are,ul,li,named,same,as,the,source,terms,agg,li,li,field,field,name,terms,value,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,terms,name,li,li,field,field,name,terms,li,ul,li,ul;private,static,list,aggregation,builder,translate,terms,terms,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,terms,aggregation,builder,rolled,terms,new,terms,aggregation,builder,source,get,name,source,value,type,rolled,terms,field,rollup,field,format,field,name,source,rollup,field,value,rolled,terms,include,exclude,source,include,exclude,if,source,collect,mode,null,rolled,terms,collect,mode,source,collect,mode,rolled,terms,min,doc,count,source,min,doc,count,rolled,terms,execution,hint,source,execution,hint,if,source,order,null,rolled,terms,order,source,order,rolled,terms,shard,min,doc,count,source,shard,min,doc,count,if,source,shard,size,0,rolled,terms,shard,size,source,shard,size,rolled,terms,show,term,doc,count,error,source,show,term,doc,count,error,rolled,terms,size,source,size,return,rolled,terms
RollupRequestTranslator -> private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,                                                            List<QueryBuilder> filterConditions,                                                            NamedWriteableRegistry registry);1533319589;Translate a normal terms agg into one that follows the rollup conventions._Notably, it adds metadata to the terms, and a Sum metric to calculate the doc_count_in each bucket.__E.g. this terms agg:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_terms": {_"terms" : {_"field" : "foo"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_terms" : {_"terms" : {_"field" : "foo.terms.value"__"aggregations" : {_"the_terms._count" : {_"sum" : { "field" : "foo.terms._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source terms agg</li>_<li>Field: `{field name}.terms.value`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent terms name}._count`</li>_<li>Field: `{field name}.terms._count`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,_                                                           List<QueryBuilder> filterConditions,_                                                           NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            TermsAggregationBuilder rolledTerms_                    = new TermsAggregationBuilder(source.getName(), source.valueType())__            rolledTerms.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledTerms.includeExclude(source.includeExclude())__            if (source.collectMode() != null) {_                rolledTerms.collectMode(source.collectMode())__            }_            rolledTerms.minDocCount(source.minDocCount())__            rolledTerms.executionHint(source.executionHint())__            if (source.order() != null) {_                rolledTerms.order(source.order())__            }_            rolledTerms.shardMinDocCount(source.shardMinDocCount())__            if (source.shardSize() > 0) {_                rolledTerms.shardSize(source.shardSize())__            }_            rolledTerms.showTermDocCountError(source.showTermDocCountError())__            rolledTerms.size(source.size())__            return rolledTerms__        })__    };translate,a,normal,terms,agg,into,one,that,follows,the,rollup,conventions,notably,it,adds,metadata,to,the,terms,and,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,terms,agg,pre,code,post,foo,aggregations,terms,field,foo,pre,is,translated,into,pre,code,post,aggregations,terms,field,foo,terms,value,aggregations,sum,field,foo,terms,pre,the,conventions,are,ul,li,named,same,as,the,source,terms,agg,li,li,field,field,name,terms,value,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,terms,name,li,li,field,field,name,terms,li,ul,li,ul;private,static,list,aggregation,builder,translate,terms,terms,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,terms,aggregation,builder,rolled,terms,new,terms,aggregation,builder,source,get,name,source,value,type,rolled,terms,field,rollup,field,format,field,name,source,rollup,field,value,rolled,terms,include,exclude,source,include,exclude,if,source,collect,mode,null,rolled,terms,collect,mode,source,collect,mode,rolled,terms,min,doc,count,source,min,doc,count,rolled,terms,execution,hint,source,execution,hint,if,source,order,null,rolled,terms,order,source,order,rolled,terms,shard,min,doc,count,source,shard,min,doc,count,if,source,shard,size,0,rolled,terms,shard,size,source,shard,size,rolled,terms,show,term,doc,count,error,source,show,term,doc,count,error,rolled,terms,size,source,size,return,rolled,terms
RollupRequestTranslator -> private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,                                                            List<QueryBuilder> filterConditions,                                                            NamedWriteableRegistry registry);1536314350;Translate a normal terms agg into one that follows the rollup conventions._Notably, it adds metadata to the terms, and a Sum metric to calculate the doc_count_in each bucket.__E.g. this terms agg:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_terms": {_"terms" : {_"field" : "foo"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_terms" : {_"terms" : {_"field" : "foo.terms.value"__"aggregations" : {_"the_terms._count" : {_"sum" : { "field" : "foo.terms._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source terms agg</li>_<li>Field: `{field name}.terms.value`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent terms name}._count`</li>_<li>Field: `{field name}.terms._count`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,_                                                           List<QueryBuilder> filterConditions,_                                                           NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            TermsAggregationBuilder rolledTerms_                    = new TermsAggregationBuilder(source.getName(), source.valueType())__            rolledTerms.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledTerms.includeExclude(source.includeExclude())__            if (source.collectMode() != null) {_                rolledTerms.collectMode(source.collectMode())__            }_            rolledTerms.minDocCount(source.minDocCount())__            rolledTerms.executionHint(source.executionHint())__            if (source.order() != null) {_                rolledTerms.order(source.order())__            }_            rolledTerms.shardMinDocCount(source.shardMinDocCount())__            if (source.shardSize() > 0) {_                rolledTerms.shardSize(source.shardSize())__            }_            rolledTerms.showTermDocCountError(source.showTermDocCountError())__            rolledTerms.size(source.size())__            return rolledTerms__        })__    };translate,a,normal,terms,agg,into,one,that,follows,the,rollup,conventions,notably,it,adds,metadata,to,the,terms,and,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,terms,agg,pre,code,post,foo,aggregations,terms,field,foo,pre,is,translated,into,pre,code,post,aggregations,terms,field,foo,terms,value,aggregations,sum,field,foo,terms,pre,the,conventions,are,ul,li,named,same,as,the,source,terms,agg,li,li,field,field,name,terms,value,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,terms,name,li,li,field,field,name,terms,li,ul,li,ul;private,static,list,aggregation,builder,translate,terms,terms,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,terms,aggregation,builder,rolled,terms,new,terms,aggregation,builder,source,get,name,source,value,type,rolled,terms,field,rollup,field,format,field,name,source,rollup,field,value,rolled,terms,include,exclude,source,include,exclude,if,source,collect,mode,null,rolled,terms,collect,mode,source,collect,mode,rolled,terms,min,doc,count,source,min,doc,count,rolled,terms,execution,hint,source,execution,hint,if,source,order,null,rolled,terms,order,source,order,rolled,terms,shard,min,doc,count,source,shard,min,doc,count,if,source,shard,size,0,rolled,terms,shard,size,source,shard,size,rolled,terms,show,term,doc,count,error,source,show,term,doc,count,error,rolled,terms,size,source,size,return,rolled,terms
RollupRequestTranslator -> private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,                                                            List<QueryBuilder> filterConditions,                                                            NamedWriteableRegistry registry);1539951844;Translate a normal terms agg into one that follows the rollup conventions._Notably, it adds metadata to the terms, and a Sum metric to calculate the doc_count_in each bucket.__E.g. this terms agg:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_terms": {_"terms" : {_"field" : "foo"_____}</pre>__is translated into:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"the_terms" : {_"terms" : {_"field" : "foo.terms.value"__"aggregations" : {_"the_terms._count" : {_"sum" : { "field" : "foo.terms._count" }______}</pre>__The conventions are:_<ul>_<li>Named: same as the source terms agg</li>_<li>Field: `{field name}.terms.value`</li>_<li>Add a SumAggregation to each bucket:</li>_<li>_<ul>_<li>Named: `{parent terms name}._count`</li>_<li>Field: `{field name}.terms._count`</li>_</ul>_</li>_</ul>;private static List<AggregationBuilder> translateTerms(TermsAggregationBuilder source,_                                                           List<QueryBuilder> filterConditions,_                                                           NamedWriteableRegistry registry) {__        return translateVSAggBuilder(source, filterConditions, registry, () -> {_            TermsAggregationBuilder rolledTerms_                    = new TermsAggregationBuilder(source.getName(), source.valueType())__            rolledTerms.field(RollupField.formatFieldName(source, RollupField.VALUE))__            rolledTerms.includeExclude(source.includeExclude())__            if (source.collectMode() != null) {_                rolledTerms.collectMode(source.collectMode())__            }_            rolledTerms.minDocCount(source.minDocCount())__            rolledTerms.executionHint(source.executionHint())__            if (source.order() != null) {_                rolledTerms.order(source.order())__            }_            rolledTerms.shardMinDocCount(source.shardMinDocCount())__            if (source.shardSize() > 0) {_                rolledTerms.shardSize(source.shardSize())__            }_            rolledTerms.showTermDocCountError(source.showTermDocCountError())__            rolledTerms.size(source.size())__            return rolledTerms__        })__    };translate,a,normal,terms,agg,into,one,that,follows,the,rollup,conventions,notably,it,adds,metadata,to,the,terms,and,a,sum,metric,to,calculate,the,in,each,bucket,e,g,this,terms,agg,pre,code,post,foo,aggregations,terms,field,foo,pre,is,translated,into,pre,code,post,aggregations,terms,field,foo,terms,value,aggregations,sum,field,foo,terms,pre,the,conventions,are,ul,li,named,same,as,the,source,terms,agg,li,li,field,field,name,terms,value,li,li,add,a,sum,aggregation,to,each,bucket,li,li,ul,li,named,parent,terms,name,li,li,field,field,name,terms,li,ul,li,ul;private,static,list,aggregation,builder,translate,terms,terms,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,return,translate,vsagg,builder,source,filter,conditions,registry,terms,aggregation,builder,rolled,terms,new,terms,aggregation,builder,source,get,name,source,value,type,rolled,terms,field,rollup,field,format,field,name,source,rollup,field,value,rolled,terms,include,exclude,source,include,exclude,if,source,collect,mode,null,rolled,terms,collect,mode,source,collect,mode,rolled,terms,min,doc,count,source,min,doc,count,rolled,terms,execution,hint,source,execution,hint,if,source,order,null,rolled,terms,order,source,order,rolled,terms,shard,min,doc,count,source,shard,min,doc,count,if,source,shard,size,0,rolled,terms,shard,size,source,shard,size,rolled,terms,show,term,doc,count,error,source,show,term,doc,count,error,rolled,terms,size,source,size,return,rolled,terms
RollupRequestTranslator -> private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>         translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,                           NamedWriteableRegistry registry, Supplier<T> factory);1524684173;The generic method that does most of the actual heavy-lifting when translating a multi-bucket_ValueSourceBuilder.  This method is called by all the agg-specific methods (e.g. translateDateHistogram())__@param source The source aggregation that we wish to translate_@param filterConditions A list of existing filter conditions, in case we need to add some_for this particular agg_@param registry Named registry for serializing leaf metrics.  Not actually used by this method,_but is passed downwards for leaf usage_@param factory A factory closure that generates a new shallow clone of the `source`. E.g. if `source` is_a date_histogram, the factory will take return a new DateHistogramAggBUilder with matching_parameters.  It is not a deep clone however_ the returned object won't have children_set._@param <T> The type of ValueSourceAggBuilder that we are working with_@return the translated multi-bucket ValueSourceAggBuilder;private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>_        translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,_                          NamedWriteableRegistry registry, Supplier<T> factory) {__        T rolled = factory.get()___        _        _        for (AggregationBuilder subAgg : source.getSubAggregations()) {_            List<AggregationBuilder> translated = translateAggregation(subAgg, filterConditions, registry)__            for (AggregationBuilder t : translated) {_                rolled.subAggregation(t)__            }_        }__        _        _        rolled.subAggregation(new SumAggregationBuilder(RollupField.formatCountAggName(source.getName()))_                .field(RollupField.formatFieldName(source, RollupField.COUNT_FIELD)))___        return Collections.singletonList(rolled)__    };the,generic,method,that,does,most,of,the,actual,heavy,lifting,when,translating,a,multi,bucket,value,source,builder,this,method,is,called,by,all,the,agg,specific,methods,e,g,translate,date,histogram,param,source,the,source,aggregation,that,we,wish,to,translate,param,filter,conditions,a,list,of,existing,filter,conditions,in,case,we,need,to,add,some,for,this,particular,agg,param,registry,named,registry,for,serializing,leaf,metrics,not,actually,used,by,this,method,but,is,passed,downwards,for,leaf,usage,param,factory,a,factory,closure,that,generates,a,new,shallow,clone,of,the,source,e,g,if,source,is,a,the,factory,will,take,return,a,new,date,histogram,agg,builder,with,matching,parameters,it,is,not,a,deep,clone,however,the,returned,object,won,t,have,children,set,param,t,the,type,of,value,source,agg,builder,that,we,are,working,with,return,the,translated,multi,bucket,value,source,agg,builder;private,static,t,extends,values,source,aggregation,builder,list,aggregation,builder,translate,vsagg,builder,values,source,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,supplier,t,factory,t,rolled,factory,get,for,aggregation,builder,sub,agg,source,get,sub,aggregations,list,aggregation,builder,translated,translate,aggregation,sub,agg,filter,conditions,registry,for,aggregation,builder,t,translated,rolled,sub,aggregation,t,rolled,sub,aggregation,new,sum,aggregation,builder,rollup,field,format,count,agg,name,source,get,name,field,rollup,field,format,field,name,source,rollup,field,return,collections,singleton,list,rolled
RollupRequestTranslator -> private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>         translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,                           NamedWriteableRegistry registry, Supplier<T> factory);1532434432;The generic method that does most of the actual heavy-lifting when translating a multi-bucket_ValueSourceBuilder.  This method is called by all the agg-specific methods (e.g. translateDateHistogram())__@param source The source aggregation that we wish to translate_@param filterConditions A list of existing filter conditions, in case we need to add some_for this particular agg_@param registry Named registry for serializing leaf metrics.  Not actually used by this method,_but is passed downwards for leaf usage_@param factory A factory closure that generates a new shallow clone of the `source`. E.g. if `source` is_a date_histogram, the factory will take return a new DateHistogramAggBUilder with matching_parameters.  It is not a deep clone however_ the returned object won't have children_set._@param <T> The type of ValueSourceAggBuilder that we are working with_@return the translated multi-bucket ValueSourceAggBuilder;private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>_        translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,_                          NamedWriteableRegistry registry, Supplier<T> factory) {__        T rolled = factory.get()___        _        _        for (AggregationBuilder subAgg : source.getSubAggregations()) {_            List<AggregationBuilder> translated = translateAggregation(subAgg, filterConditions, registry)__            for (AggregationBuilder t : translated) {_                rolled.subAggregation(t)__            }_        }__        _        _        rolled.subAggregation(new SumAggregationBuilder(RollupField.formatCountAggName(source.getName()))_                .field(RollupField.formatFieldName(source, RollupField.COUNT_FIELD)))___        return Collections.singletonList(rolled)__    };the,generic,method,that,does,most,of,the,actual,heavy,lifting,when,translating,a,multi,bucket,value,source,builder,this,method,is,called,by,all,the,agg,specific,methods,e,g,translate,date,histogram,param,source,the,source,aggregation,that,we,wish,to,translate,param,filter,conditions,a,list,of,existing,filter,conditions,in,case,we,need,to,add,some,for,this,particular,agg,param,registry,named,registry,for,serializing,leaf,metrics,not,actually,used,by,this,method,but,is,passed,downwards,for,leaf,usage,param,factory,a,factory,closure,that,generates,a,new,shallow,clone,of,the,source,e,g,if,source,is,a,the,factory,will,take,return,a,new,date,histogram,agg,builder,with,matching,parameters,it,is,not,a,deep,clone,however,the,returned,object,won,t,have,children,set,param,t,the,type,of,value,source,agg,builder,that,we,are,working,with,return,the,translated,multi,bucket,value,source,agg,builder;private,static,t,extends,values,source,aggregation,builder,list,aggregation,builder,translate,vsagg,builder,values,source,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,supplier,t,factory,t,rolled,factory,get,for,aggregation,builder,sub,agg,source,get,sub,aggregations,list,aggregation,builder,translated,translate,aggregation,sub,agg,filter,conditions,registry,for,aggregation,builder,t,translated,rolled,sub,aggregation,t,rolled,sub,aggregation,new,sum,aggregation,builder,rollup,field,format,count,agg,name,source,get,name,field,rollup,field,format,field,name,source,rollup,field,return,collections,singleton,list,rolled
RollupRequestTranslator -> private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>         translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,                           NamedWriteableRegistry registry, Supplier<T> factory);1533319589;The generic method that does most of the actual heavy-lifting when translating a multi-bucket_ValueSourceBuilder.  This method is called by all the agg-specific methods (e.g. translateDateHistogram())__@param source The source aggregation that we wish to translate_@param filterConditions A list of existing filter conditions, in case we need to add some_for this particular agg_@param registry Named registry for serializing leaf metrics.  Not actually used by this method,_but is passed downwards for leaf usage_@param factory A factory closure that generates a new shallow clone of the `source`. E.g. if `source` is_a date_histogram, the factory will take return a new DateHistogramAggBUilder with matching_parameters.  It is not a deep clone however_ the returned object won't have children_set._@param <T> The type of ValueSourceAggBuilder that we are working with_@return the translated multi-bucket ValueSourceAggBuilder;private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>_        translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,_                          NamedWriteableRegistry registry, Supplier<T> factory) {__        T rolled = factory.get()___        _        _        for (AggregationBuilder subAgg : source.getSubAggregations()) {_            List<AggregationBuilder> translated = translateAggregation(subAgg, filterConditions, registry)__            for (AggregationBuilder t : translated) {_                rolled.subAggregation(t)__            }_        }__        _        _        rolled.subAggregation(new SumAggregationBuilder(RollupField.formatCountAggName(source.getName()))_                .field(RollupField.formatFieldName(source, RollupField.COUNT_FIELD)))___        return Collections.singletonList(rolled)__    };the,generic,method,that,does,most,of,the,actual,heavy,lifting,when,translating,a,multi,bucket,value,source,builder,this,method,is,called,by,all,the,agg,specific,methods,e,g,translate,date,histogram,param,source,the,source,aggregation,that,we,wish,to,translate,param,filter,conditions,a,list,of,existing,filter,conditions,in,case,we,need,to,add,some,for,this,particular,agg,param,registry,named,registry,for,serializing,leaf,metrics,not,actually,used,by,this,method,but,is,passed,downwards,for,leaf,usage,param,factory,a,factory,closure,that,generates,a,new,shallow,clone,of,the,source,e,g,if,source,is,a,the,factory,will,take,return,a,new,date,histogram,agg,builder,with,matching,parameters,it,is,not,a,deep,clone,however,the,returned,object,won,t,have,children,set,param,t,the,type,of,value,source,agg,builder,that,we,are,working,with,return,the,translated,multi,bucket,value,source,agg,builder;private,static,t,extends,values,source,aggregation,builder,list,aggregation,builder,translate,vsagg,builder,values,source,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,supplier,t,factory,t,rolled,factory,get,for,aggregation,builder,sub,agg,source,get,sub,aggregations,list,aggregation,builder,translated,translate,aggregation,sub,agg,filter,conditions,registry,for,aggregation,builder,t,translated,rolled,sub,aggregation,t,rolled,sub,aggregation,new,sum,aggregation,builder,rollup,field,format,count,agg,name,source,get,name,field,rollup,field,format,field,name,source,rollup,field,return,collections,singleton,list,rolled
RollupRequestTranslator -> private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>         translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,                           NamedWriteableRegistry registry, Supplier<T> factory);1536314350;The generic method that does most of the actual heavy-lifting when translating a multi-bucket_ValueSourceBuilder.  This method is called by all the agg-specific methods (e.g. translateDateHistogram())__@param source The source aggregation that we wish to translate_@param filterConditions A list of existing filter conditions, in case we need to add some_for this particular agg_@param registry Named registry for serializing leaf metrics.  Not actually used by this method,_but is passed downwards for leaf usage_@param factory A factory closure that generates a new shallow clone of the `source`. E.g. if `source` is_a date_histogram, the factory will take return a new DateHistogramAggBUilder with matching_parameters.  It is not a deep clone however_ the returned object won't have children_set._@param <T> The type of ValueSourceAggBuilder that we are working with_@return the translated multi-bucket ValueSourceAggBuilder;private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>_        translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,_                          NamedWriteableRegistry registry, Supplier<T> factory) {__        T rolled = factory.get()___        _        _        for (AggregationBuilder subAgg : source.getSubAggregations()) {_            List<AggregationBuilder> translated = translateAggregation(subAgg, filterConditions, registry)__            for (AggregationBuilder t : translated) {_                rolled.subAggregation(t)__            }_        }__        _        _        rolled.subAggregation(new SumAggregationBuilder(RollupField.formatCountAggName(source.getName()))_                .field(RollupField.formatFieldName(source, RollupField.COUNT_FIELD)))___        return Collections.singletonList(rolled)__    };the,generic,method,that,does,most,of,the,actual,heavy,lifting,when,translating,a,multi,bucket,value,source,builder,this,method,is,called,by,all,the,agg,specific,methods,e,g,translate,date,histogram,param,source,the,source,aggregation,that,we,wish,to,translate,param,filter,conditions,a,list,of,existing,filter,conditions,in,case,we,need,to,add,some,for,this,particular,agg,param,registry,named,registry,for,serializing,leaf,metrics,not,actually,used,by,this,method,but,is,passed,downwards,for,leaf,usage,param,factory,a,factory,closure,that,generates,a,new,shallow,clone,of,the,source,e,g,if,source,is,a,the,factory,will,take,return,a,new,date,histogram,agg,builder,with,matching,parameters,it,is,not,a,deep,clone,however,the,returned,object,won,t,have,children,set,param,t,the,type,of,value,source,agg,builder,that,we,are,working,with,return,the,translated,multi,bucket,value,source,agg,builder;private,static,t,extends,values,source,aggregation,builder,list,aggregation,builder,translate,vsagg,builder,values,source,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,supplier,t,factory,t,rolled,factory,get,for,aggregation,builder,sub,agg,source,get,sub,aggregations,list,aggregation,builder,translated,translate,aggregation,sub,agg,filter,conditions,registry,for,aggregation,builder,t,translated,rolled,sub,aggregation,t,rolled,sub,aggregation,new,sum,aggregation,builder,rollup,field,format,count,agg,name,source,get,name,field,rollup,field,format,field,name,source,rollup,field,return,collections,singleton,list,rolled
RollupRequestTranslator -> private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>         translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,                           NamedWriteableRegistry registry, Supplier<T> factory);1539951844;The generic method that does most of the actual heavy-lifting when translating a multi-bucket_ValueSourceBuilder.  This method is called by all the agg-specific methods (e.g. translateDateHistogram())__@param source The source aggregation that we wish to translate_@param filterConditions A list of existing filter conditions, in case we need to add some_for this particular agg_@param registry Named registry for serializing leaf metrics.  Not actually used by this method,_but is passed downwards for leaf usage_@param factory A factory closure that generates a new shallow clone of the `source`. E.g. if `source` is_a date_histogram, the factory will take return a new DateHistogramAggBUilder with matching_parameters.  It is not a deep clone however_ the returned object won't have children_set._@param <T> The type of ValueSourceAggBuilder that we are working with_@return the translated multi-bucket ValueSourceAggBuilder;private static <T extends ValuesSourceAggregationBuilder> List<AggregationBuilder>_        translateVSAggBuilder(ValuesSourceAggregationBuilder source, List<QueryBuilder> filterConditions,_                          NamedWriteableRegistry registry, Supplier<T> factory) {__        T rolled = factory.get()___        _        _        for (AggregationBuilder subAgg : source.getSubAggregations()) {_            List<AggregationBuilder> translated = translateAggregation(subAgg, filterConditions, registry)__            for (AggregationBuilder t : translated) {_                rolled.subAggregation(t)__            }_        }__        _        _        rolled.subAggregation(new SumAggregationBuilder(RollupField.formatCountAggName(source.getName()))_                .field(RollupField.formatFieldName(source, RollupField.COUNT_FIELD)))___        return Collections.singletonList(rolled)__    };the,generic,method,that,does,most,of,the,actual,heavy,lifting,when,translating,a,multi,bucket,value,source,builder,this,method,is,called,by,all,the,agg,specific,methods,e,g,translate,date,histogram,param,source,the,source,aggregation,that,we,wish,to,translate,param,filter,conditions,a,list,of,existing,filter,conditions,in,case,we,need,to,add,some,for,this,particular,agg,param,registry,named,registry,for,serializing,leaf,metrics,not,actually,used,by,this,method,but,is,passed,downwards,for,leaf,usage,param,factory,a,factory,closure,that,generates,a,new,shallow,clone,of,the,source,e,g,if,source,is,a,the,factory,will,take,return,a,new,date,histogram,agg,builder,with,matching,parameters,it,is,not,a,deep,clone,however,the,returned,object,won,t,have,children,set,param,t,the,type,of,value,source,agg,builder,that,we,are,working,with,return,the,translated,multi,bucket,value,source,agg,builder;private,static,t,extends,values,source,aggregation,builder,list,aggregation,builder,translate,vsagg,builder,values,source,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,supplier,t,factory,t,rolled,factory,get,for,aggregation,builder,sub,agg,source,get,sub,aggregations,list,aggregation,builder,translated,translate,aggregation,sub,agg,filter,conditions,registry,for,aggregation,builder,t,translated,rolled,sub,aggregation,t,rolled,sub,aggregation,new,sum,aggregation,builder,rollup,field,format,count,agg,name,source,get,name,field,rollup,field,format,field,name,source,rollup,field,return,collections,singleton,list,rolled
RollupRequestTranslator -> private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,                                                             NamedWriteableRegistry registry);1524684173;Translates leaf aggs (min/max/sum/etc) into their rollup version.  For simple aggs like `min`,_this is nearly a 1:1 copy.  The source is deserialized into a new object, and the field is adjusted_according to convention.  E.g. for a `min` agg:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field" } }__}</pre>__the translation would be:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field.min.value" }}__}</pre>__However, for `avg` metrics (and potentially others in the future), the agg is translated into_a sum + sum aggs_ one for count and one for sum.  When unrolling these will be combined back into_a single avg.  Note that we also have to rename the avg agg name to distinguish it from empty_buckets.  E.g. for an `avg` agg:__<pre>{@code__"the_avg":{ "avg" : { "field" : "some_field" }}__}</pre>__the translation would be:__<pre>{@code___"the_avg.value": {_"sum" : { "field" : "some_field.avg.value" }}___"the_avg._count": { "sum" : { "field" : "some_field.avg._count" }}___}</pre>__The conventions are:_<ul>_<li>Agg type: same as source agg</li>_<li>Named: same as the source agg</li>_<li>Field: `{agg_type}.{field_name}.value`</li>_</ul>__IF the agg is an AvgAgg, the following additional conventions are added:_<ul>_<li>Agg type: becomes SumAgg, instead of AvgAgg</li>_<li>Named: {source name}.value</li>_<li>Additionally, an extra SumAgg is added:</li>_<li>_<ul>_<li>Named: `{source name}._count`</li>_<li>Field: `{field name}.{agg type}._count`</li>_</ul>_</li>_</ul>___@param metric  The source leaf aggregation we wish to translate_@param registry A registry of NamedWriteable's so we can do a simple serialize/deserialize for_most of the leafs to easily clone them_@return The translated leaf aggregation;private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,_                                                            NamedWriteableRegistry registry) {__        List<AggregationBuilder> rolledMetrics___        _        if (metric instanceof AvgAggregationBuilder) {_            rolledMetrics = new ArrayList<>(2)___            _            _            _            SumAggregationBuilder value = new SumAggregationBuilder(RollupField.formatValueAggName(metric.getName()))__            value.field(RollupField.formatFieldName(metric, RollupField.VALUE))__            rolledMetrics.add(value)___            _            _            rolledMetrics.add(new SumAggregationBuilder(RollupField.formatCountAggName(metric.getName()))_                    .field(RollupField.formatFieldName(metric, RollupField.COUNT_FIELD)))___            return rolledMetrics__        }__        _        _        try (BytesStreamOutput output = new BytesStreamOutput()) {_            try {_                output.writeString(metric.getType())__                metric.writeTo(output)__                try (StreamInput stream = output.bytes().streamInput()__                     NamedWriteableAwareStreamInput in =_                             new NamedWriteableAwareStreamInput(stream, registry)) {__                    ValuesSourceAggregationBuilder serialized_                            = ((ValuesSourceAggregationBuilder)in.readNamedWriteable(AggregationBuilder.class))_                            .field(RollupField.formatFieldName(metric, RollupField.VALUE))___                    return Collections.singletonList(serialized)__                }_            } catch (Exception e) {_                throw new RuntimeException(e)__            }_        }_    };translates,leaf,aggs,min,max,sum,etc,into,their,rollup,version,for,simple,aggs,like,min,this,is,nearly,a,1,1,copy,the,source,is,deserialized,into,a,new,object,and,the,field,is,adjusted,according,to,convention,e,g,for,a,min,agg,pre,code,min,field,pre,the,translation,would,be,pre,code,min,field,min,value,pre,however,for,avg,metrics,and,potentially,others,in,the,future,the,agg,is,translated,into,a,sum,sum,aggs,one,for,count,and,one,for,sum,when,unrolling,these,will,be,combined,back,into,a,single,avg,note,that,we,also,have,to,rename,the,avg,agg,name,to,distinguish,it,from,empty,buckets,e,g,for,an,avg,agg,pre,code,avg,field,pre,the,translation,would,be,pre,code,value,sum,field,avg,value,sum,field,avg,pre,the,conventions,are,ul,li,agg,type,same,as,source,agg,li,li,named,same,as,the,source,agg,li,li,field,value,li,ul,if,the,agg,is,an,avg,agg,the,following,additional,conventions,are,added,ul,li,agg,type,becomes,sum,agg,instead,of,avg,agg,li,li,named,source,name,value,li,li,additionally,an,extra,sum,agg,is,added,li,li,ul,li,named,source,name,li,li,field,field,name,agg,type,li,ul,li,ul,param,metric,the,source,leaf,aggregation,we,wish,to,translate,param,registry,a,registry,of,named,writeable,s,so,we,can,do,a,simple,serialize,deserialize,for,most,of,the,leafs,to,easily,clone,them,return,the,translated,leaf,aggregation;private,static,list,aggregation,builder,translate,vsleaf,values,source,aggregation,builder,leaf,only,metric,named,writeable,registry,registry,list,aggregation,builder,rolled,metrics,if,metric,instanceof,avg,aggregation,builder,rolled,metrics,new,array,list,2,sum,aggregation,builder,value,new,sum,aggregation,builder,rollup,field,format,value,agg,name,metric,get,name,value,field,rollup,field,format,field,name,metric,rollup,field,value,rolled,metrics,add,value,rolled,metrics,add,new,sum,aggregation,builder,rollup,field,format,count,agg,name,metric,get,name,field,rollup,field,format,field,name,metric,rollup,field,return,rolled,metrics,try,bytes,stream,output,output,new,bytes,stream,output,try,output,write,string,metric,get,type,metric,write,to,output,try,stream,input,stream,output,bytes,stream,input,named,writeable,aware,stream,input,in,new,named,writeable,aware,stream,input,stream,registry,values,source,aggregation,builder,serialized,values,source,aggregation,builder,in,read,named,writeable,aggregation,builder,class,field,rollup,field,format,field,name,metric,rollup,field,value,return,collections,singleton,list,serialized,catch,exception,e,throw,new,runtime,exception,e
RollupRequestTranslator -> private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,                                                             NamedWriteableRegistry registry);1532434432;Translates leaf aggs (min/max/sum/etc) into their rollup version.  For simple aggs like `min`,_this is nearly a 1:1 copy.  The source is deserialized into a new object, and the field is adjusted_according to convention.  E.g. for a `min` agg:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field" } }__}</pre>__the translation would be:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field.min.value" }}__}</pre>__However, for `avg` metrics (and potentially others in the future), the agg is translated into_a sum + sum aggs_ one for count and one for sum.  When unrolling these will be combined back into_a single avg.  Note that we also have to rename the avg agg name to distinguish it from empty_buckets.  E.g. for an `avg` agg:__<pre>{@code__"the_avg":{ "avg" : { "field" : "some_field" }}__}</pre>__the translation would be:__<pre>{@code___"the_avg.value": {_"sum" : { "field" : "some_field.avg.value" }}___"the_avg._count": { "sum" : { "field" : "some_field.avg._count" }}___}</pre>__The conventions are:_<ul>_<li>Agg type: same as source agg</li>_<li>Named: same as the source agg</li>_<li>Field: `{agg_type}.{field_name}.value`</li>_</ul>__IF the agg is an AvgAgg, the following additional conventions are added:_<ul>_<li>Agg type: becomes SumAgg, instead of AvgAgg</li>_<li>Named: {source name}.value</li>_<li>Additionally, an extra SumAgg is added:</li>_<li>_<ul>_<li>Named: `{source name}._count`</li>_<li>Field: `{field name}.{agg type}._count`</li>_</ul>_</li>_</ul>___@param metric  The source leaf aggregation we wish to translate_@param registry A registry of NamedWriteable's so we can do a simple serialize/deserialize for_most of the leafs to easily clone them_@return The translated leaf aggregation;private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,_                                                            NamedWriteableRegistry registry) {__        List<AggregationBuilder> rolledMetrics___        _        if (metric instanceof AvgAggregationBuilder) {_            rolledMetrics = new ArrayList<>(2)___            _            _            _            SumAggregationBuilder value = new SumAggregationBuilder(RollupField.formatValueAggName(metric.getName()))__            value.field(RollupField.formatFieldName(metric, RollupField.VALUE))__            rolledMetrics.add(value)___            _            _            rolledMetrics.add(new SumAggregationBuilder(RollupField.formatCountAggName(metric.getName()))_                    .field(RollupField.formatFieldName(metric, RollupField.COUNT_FIELD)))___            return rolledMetrics__        }__        _        _        try (BytesStreamOutput output = new BytesStreamOutput()) {_            try {_                output.writeString(metric.getType())__                metric.writeTo(output)__                try (StreamInput stream = output.bytes().streamInput()__                     NamedWriteableAwareStreamInput in =_                             new NamedWriteableAwareStreamInput(stream, registry)) {__                    ValuesSourceAggregationBuilder serialized_                            = ((ValuesSourceAggregationBuilder)in.readNamedWriteable(AggregationBuilder.class))_                            .field(RollupField.formatFieldName(metric, RollupField.VALUE))___                    return Collections.singletonList(serialized)__                }_            } catch (Exception e) {_                throw new RuntimeException(e)__            }_        }_    };translates,leaf,aggs,min,max,sum,etc,into,their,rollup,version,for,simple,aggs,like,min,this,is,nearly,a,1,1,copy,the,source,is,deserialized,into,a,new,object,and,the,field,is,adjusted,according,to,convention,e,g,for,a,min,agg,pre,code,min,field,pre,the,translation,would,be,pre,code,min,field,min,value,pre,however,for,avg,metrics,and,potentially,others,in,the,future,the,agg,is,translated,into,a,sum,sum,aggs,one,for,count,and,one,for,sum,when,unrolling,these,will,be,combined,back,into,a,single,avg,note,that,we,also,have,to,rename,the,avg,agg,name,to,distinguish,it,from,empty,buckets,e,g,for,an,avg,agg,pre,code,avg,field,pre,the,translation,would,be,pre,code,value,sum,field,avg,value,sum,field,avg,pre,the,conventions,are,ul,li,agg,type,same,as,source,agg,li,li,named,same,as,the,source,agg,li,li,field,value,li,ul,if,the,agg,is,an,avg,agg,the,following,additional,conventions,are,added,ul,li,agg,type,becomes,sum,agg,instead,of,avg,agg,li,li,named,source,name,value,li,li,additionally,an,extra,sum,agg,is,added,li,li,ul,li,named,source,name,li,li,field,field,name,agg,type,li,ul,li,ul,param,metric,the,source,leaf,aggregation,we,wish,to,translate,param,registry,a,registry,of,named,writeable,s,so,we,can,do,a,simple,serialize,deserialize,for,most,of,the,leafs,to,easily,clone,them,return,the,translated,leaf,aggregation;private,static,list,aggregation,builder,translate,vsleaf,values,source,aggregation,builder,leaf,only,metric,named,writeable,registry,registry,list,aggregation,builder,rolled,metrics,if,metric,instanceof,avg,aggregation,builder,rolled,metrics,new,array,list,2,sum,aggregation,builder,value,new,sum,aggregation,builder,rollup,field,format,value,agg,name,metric,get,name,value,field,rollup,field,format,field,name,metric,rollup,field,value,rolled,metrics,add,value,rolled,metrics,add,new,sum,aggregation,builder,rollup,field,format,count,agg,name,metric,get,name,field,rollup,field,format,field,name,metric,rollup,field,return,rolled,metrics,try,bytes,stream,output,output,new,bytes,stream,output,try,output,write,string,metric,get,type,metric,write,to,output,try,stream,input,stream,output,bytes,stream,input,named,writeable,aware,stream,input,in,new,named,writeable,aware,stream,input,stream,registry,values,source,aggregation,builder,serialized,values,source,aggregation,builder,in,read,named,writeable,aggregation,builder,class,field,rollup,field,format,field,name,metric,rollup,field,value,return,collections,singleton,list,serialized,catch,exception,e,throw,new,runtime,exception,e
RollupRequestTranslator -> private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,                                                             NamedWriteableRegistry registry);1533319589;Translates leaf aggs (min/max/sum/etc) into their rollup version.  For simple aggs like `min`,_this is nearly a 1:1 copy.  The source is deserialized into a new object, and the field is adjusted_according to convention.  E.g. for a `min` agg:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field" } }__}</pre>__the translation would be:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field.min.value" }}__}</pre>__However, for `avg` metrics (and potentially others in the future), the agg is translated into_a sum + sum aggs_ one for count and one for sum.  When unrolling these will be combined back into_a single avg.  Note that we also have to rename the avg agg name to distinguish it from empty_buckets.  E.g. for an `avg` agg:__<pre>{@code__"the_avg":{ "avg" : { "field" : "some_field" }}__}</pre>__the translation would be:__<pre>{@code___"the_avg.value": {_"sum" : { "field" : "some_field.avg.value" }}___"the_avg._count": { "sum" : { "field" : "some_field.avg._count" }}___}</pre>__The conventions are:_<ul>_<li>Agg type: same as source agg</li>_<li>Named: same as the source agg</li>_<li>Field: `{agg_type}.{field_name}.value`</li>_</ul>__IF the agg is an AvgAgg, the following additional conventions are added:_<ul>_<li>Agg type: becomes SumAgg, instead of AvgAgg</li>_<li>Named: {source name}.value</li>_<li>Additionally, an extra SumAgg is added:</li>_<li>_<ul>_<li>Named: `{source name}._count`</li>_<li>Field: `{field name}.{agg type}._count`</li>_</ul>_</li>_</ul>___@param metric  The source leaf aggregation we wish to translate_@param registry A registry of NamedWriteable's so we can do a simple serialize/deserialize for_most of the leafs to easily clone them_@return The translated leaf aggregation;private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,_                                                            NamedWriteableRegistry registry) {__        List<AggregationBuilder> rolledMetrics___        _        if (metric instanceof AvgAggregationBuilder) {_            rolledMetrics = new ArrayList<>(2)___            _            _            _            SumAggregationBuilder value = new SumAggregationBuilder(RollupField.formatValueAggName(metric.getName()))__            value.field(RollupField.formatFieldName(metric, RollupField.VALUE))__            rolledMetrics.add(value)___            _            _            rolledMetrics.add(new SumAggregationBuilder(RollupField.formatCountAggName(metric.getName()))_                    .field(RollupField.formatFieldName(metric, RollupField.COUNT_FIELD)))___            return rolledMetrics__        }__        _        _        try (BytesStreamOutput output = new BytesStreamOutput()) {_            try {_                output.writeString(metric.getType())__                metric.writeTo(output)__                try (StreamInput stream = output.bytes().streamInput()__                     NamedWriteableAwareStreamInput in =_                             new NamedWriteableAwareStreamInput(stream, registry)) {__                    ValuesSourceAggregationBuilder serialized_                            = ((ValuesSourceAggregationBuilder)in.readNamedWriteable(AggregationBuilder.class))_                            .field(RollupField.formatFieldName(metric, RollupField.VALUE))___                    return Collections.singletonList(serialized)__                }_            } catch (Exception e) {_                throw new RuntimeException(e)__            }_        }_    };translates,leaf,aggs,min,max,sum,etc,into,their,rollup,version,for,simple,aggs,like,min,this,is,nearly,a,1,1,copy,the,source,is,deserialized,into,a,new,object,and,the,field,is,adjusted,according,to,convention,e,g,for,a,min,agg,pre,code,min,field,pre,the,translation,would,be,pre,code,min,field,min,value,pre,however,for,avg,metrics,and,potentially,others,in,the,future,the,agg,is,translated,into,a,sum,sum,aggs,one,for,count,and,one,for,sum,when,unrolling,these,will,be,combined,back,into,a,single,avg,note,that,we,also,have,to,rename,the,avg,agg,name,to,distinguish,it,from,empty,buckets,e,g,for,an,avg,agg,pre,code,avg,field,pre,the,translation,would,be,pre,code,value,sum,field,avg,value,sum,field,avg,pre,the,conventions,are,ul,li,agg,type,same,as,source,agg,li,li,named,same,as,the,source,agg,li,li,field,value,li,ul,if,the,agg,is,an,avg,agg,the,following,additional,conventions,are,added,ul,li,agg,type,becomes,sum,agg,instead,of,avg,agg,li,li,named,source,name,value,li,li,additionally,an,extra,sum,agg,is,added,li,li,ul,li,named,source,name,li,li,field,field,name,agg,type,li,ul,li,ul,param,metric,the,source,leaf,aggregation,we,wish,to,translate,param,registry,a,registry,of,named,writeable,s,so,we,can,do,a,simple,serialize,deserialize,for,most,of,the,leafs,to,easily,clone,them,return,the,translated,leaf,aggregation;private,static,list,aggregation,builder,translate,vsleaf,values,source,aggregation,builder,leaf,only,metric,named,writeable,registry,registry,list,aggregation,builder,rolled,metrics,if,metric,instanceof,avg,aggregation,builder,rolled,metrics,new,array,list,2,sum,aggregation,builder,value,new,sum,aggregation,builder,rollup,field,format,value,agg,name,metric,get,name,value,field,rollup,field,format,field,name,metric,rollup,field,value,rolled,metrics,add,value,rolled,metrics,add,new,sum,aggregation,builder,rollup,field,format,count,agg,name,metric,get,name,field,rollup,field,format,field,name,metric,rollup,field,return,rolled,metrics,try,bytes,stream,output,output,new,bytes,stream,output,try,output,write,string,metric,get,type,metric,write,to,output,try,stream,input,stream,output,bytes,stream,input,named,writeable,aware,stream,input,in,new,named,writeable,aware,stream,input,stream,registry,values,source,aggregation,builder,serialized,values,source,aggregation,builder,in,read,named,writeable,aggregation,builder,class,field,rollup,field,format,field,name,metric,rollup,field,value,return,collections,singleton,list,serialized,catch,exception,e,throw,new,runtime,exception,e
RollupRequestTranslator -> private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,                                                             NamedWriteableRegistry registry);1536314350;Translates leaf aggs (min/max/sum/etc) into their rollup version.  For simple aggs like `min`,_this is nearly a 1:1 copy.  The source is deserialized into a new object, and the field is adjusted_according to convention.  E.g. for a `min` agg:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field" } }__}</pre>__the translation would be:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field.min.value" }}__}</pre>__However, for `avg` metrics (and potentially others in the future), the agg is translated into_a sum + sum aggs_ one for count and one for sum.  When unrolling these will be combined back into_a single avg.  Note that we also have to rename the avg agg name to distinguish it from empty_buckets.  E.g. for an `avg` agg:__<pre>{@code__"the_avg":{ "avg" : { "field" : "some_field" }}__}</pre>__the translation would be:__<pre>{@code___"the_avg.value": {_"sum" : { "field" : "some_field.avg.value" }}___"the_avg._count": { "sum" : { "field" : "some_field.avg._count" }}___}</pre>__The conventions are:_<ul>_<li>Agg type: same as source agg</li>_<li>Named: same as the source agg</li>_<li>Field: `{agg_type}.{field_name}.value`</li>_</ul>__IF the agg is an AvgAgg, the following additional conventions are added:_<ul>_<li>Agg type: becomes SumAgg, instead of AvgAgg</li>_<li>Named: {source name}.value</li>_<li>Additionally, an extra SumAgg is added:</li>_<li>_<ul>_<li>Named: `{source name}._count`</li>_<li>Field: `{field name}.{agg type}._count`</li>_</ul>_</li>_</ul>___@param metric  The source leaf aggregation we wish to translate_@param registry A registry of NamedWriteable's so we can do a simple serialize/deserialize for_most of the leafs to easily clone them_@return The translated leaf aggregation;private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,_                                                            NamedWriteableRegistry registry) {__        List<AggregationBuilder> rolledMetrics___        _        if (metric instanceof AvgAggregationBuilder) {_            rolledMetrics = new ArrayList<>(2)___            _            _            _            SumAggregationBuilder value = new SumAggregationBuilder(RollupField.formatValueAggName(metric.getName()))__            value.field(RollupField.formatFieldName(metric, RollupField.VALUE))__            rolledMetrics.add(value)___            _            _            rolledMetrics.add(new SumAggregationBuilder(RollupField.formatCountAggName(metric.getName()))_                    .field(RollupField.formatFieldName(metric, RollupField.COUNT_FIELD)))___            return rolledMetrics__        }__        _        _        try (BytesStreamOutput output = new BytesStreamOutput()) {_            try {_                output.writeString(metric.getType())__                metric.writeTo(output)__                try (StreamInput stream = output.bytes().streamInput()__                     NamedWriteableAwareStreamInput in =_                             new NamedWriteableAwareStreamInput(stream, registry)) {__                    ValuesSourceAggregationBuilder serialized_                            = ((ValuesSourceAggregationBuilder)in.readNamedWriteable(AggregationBuilder.class))_                            .field(RollupField.formatFieldName(metric, RollupField.VALUE))___                    return Collections.singletonList(serialized)__                }_            } catch (Exception e) {_                throw new RuntimeException(e)__            }_        }_    };translates,leaf,aggs,min,max,sum,etc,into,their,rollup,version,for,simple,aggs,like,min,this,is,nearly,a,1,1,copy,the,source,is,deserialized,into,a,new,object,and,the,field,is,adjusted,according,to,convention,e,g,for,a,min,agg,pre,code,min,field,pre,the,translation,would,be,pre,code,min,field,min,value,pre,however,for,avg,metrics,and,potentially,others,in,the,future,the,agg,is,translated,into,a,sum,sum,aggs,one,for,count,and,one,for,sum,when,unrolling,these,will,be,combined,back,into,a,single,avg,note,that,we,also,have,to,rename,the,avg,agg,name,to,distinguish,it,from,empty,buckets,e,g,for,an,avg,agg,pre,code,avg,field,pre,the,translation,would,be,pre,code,value,sum,field,avg,value,sum,field,avg,pre,the,conventions,are,ul,li,agg,type,same,as,source,agg,li,li,named,same,as,the,source,agg,li,li,field,value,li,ul,if,the,agg,is,an,avg,agg,the,following,additional,conventions,are,added,ul,li,agg,type,becomes,sum,agg,instead,of,avg,agg,li,li,named,source,name,value,li,li,additionally,an,extra,sum,agg,is,added,li,li,ul,li,named,source,name,li,li,field,field,name,agg,type,li,ul,li,ul,param,metric,the,source,leaf,aggregation,we,wish,to,translate,param,registry,a,registry,of,named,writeable,s,so,we,can,do,a,simple,serialize,deserialize,for,most,of,the,leafs,to,easily,clone,them,return,the,translated,leaf,aggregation;private,static,list,aggregation,builder,translate,vsleaf,values,source,aggregation,builder,leaf,only,metric,named,writeable,registry,registry,list,aggregation,builder,rolled,metrics,if,metric,instanceof,avg,aggregation,builder,rolled,metrics,new,array,list,2,sum,aggregation,builder,value,new,sum,aggregation,builder,rollup,field,format,value,agg,name,metric,get,name,value,field,rollup,field,format,field,name,metric,rollup,field,value,rolled,metrics,add,value,rolled,metrics,add,new,sum,aggregation,builder,rollup,field,format,count,agg,name,metric,get,name,field,rollup,field,format,field,name,metric,rollup,field,return,rolled,metrics,try,bytes,stream,output,output,new,bytes,stream,output,try,output,write,string,metric,get,type,metric,write,to,output,try,stream,input,stream,output,bytes,stream,input,named,writeable,aware,stream,input,in,new,named,writeable,aware,stream,input,stream,registry,values,source,aggregation,builder,serialized,values,source,aggregation,builder,in,read,named,writeable,aggregation,builder,class,field,rollup,field,format,field,name,metric,rollup,field,value,return,collections,singleton,list,serialized,catch,exception,e,throw,new,runtime,exception,e
RollupRequestTranslator -> private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,                                                             NamedWriteableRegistry registry);1539951844;Translates leaf aggs (min/max/sum/etc) into their rollup version.  For simple aggs like `min`,_this is nearly a 1:1 copy.  The source is deserialized into a new object, and the field is adjusted_according to convention.  E.g. for a `min` agg:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field" } }__}</pre>__the translation would be:__<pre>{@code__"the_min":{ "min" : { "field" : "some_field.min.value" }}__}</pre>__However, for `avg` metrics (and potentially others in the future), the agg is translated into_a sum + sum aggs_ one for count and one for sum.  When unrolling these will be combined back into_a single avg.  Note that we also have to rename the avg agg name to distinguish it from empty_buckets.  E.g. for an `avg` agg:__<pre>{@code__"the_avg":{ "avg" : { "field" : "some_field" }}__}</pre>__the translation would be:__<pre>{@code___"the_avg.value": {_"sum" : { "field" : "some_field.avg.value" }}___"the_avg._count": { "sum" : { "field" : "some_field.avg._count" }}___}</pre>__The conventions are:_<ul>_<li>Agg type: same as source agg</li>_<li>Named: same as the source agg</li>_<li>Field: `{agg_type}.{field_name}.value`</li>_</ul>__IF the agg is an AvgAgg, the following additional conventions are added:_<ul>_<li>Agg type: becomes SumAgg, instead of AvgAgg</li>_<li>Named: {source name}.value</li>_<li>Additionally, an extra SumAgg is added:</li>_<li>_<ul>_<li>Named: `{source name}._count`</li>_<li>Field: `{field name}.{agg type}._count`</li>_</ul>_</li>_</ul>___@param metric  The source leaf aggregation we wish to translate_@param registry A registry of NamedWriteable's so we can do a simple serialize/deserialize for_most of the leafs to easily clone them_@return The translated leaf aggregation;private static List<AggregationBuilder> translateVSLeaf(ValuesSourceAggregationBuilder.LeafOnly metric,_                                                            NamedWriteableRegistry registry) {__        List<AggregationBuilder> rolledMetrics___        _        if (metric instanceof AvgAggregationBuilder) {_            rolledMetrics = new ArrayList<>(2)___            _            _            _            SumAggregationBuilder value = new SumAggregationBuilder(RollupField.formatValueAggName(metric.getName()))__            value.field(RollupField.formatFieldName(metric, RollupField.VALUE))__            rolledMetrics.add(value)___            _            _            rolledMetrics.add(new SumAggregationBuilder(RollupField.formatCountAggName(metric.getName()))_                    .field(RollupField.formatFieldName(metric, RollupField.COUNT_FIELD)))___            return rolledMetrics__        }__        _        _        try (BytesStreamOutput output = new BytesStreamOutput()) {_            try {_                output.writeString(metric.getType())__                metric.writeTo(output)__                try (StreamInput stream = output.bytes().streamInput()__                     NamedWriteableAwareStreamInput in =_                             new NamedWriteableAwareStreamInput(stream, registry)) {__                    ValuesSourceAggregationBuilder serialized_                            = ((ValuesSourceAggregationBuilder)in.readNamedWriteable(AggregationBuilder.class))_                            .field(RollupField.formatFieldName(metric, RollupField.VALUE))___                    return Collections.singletonList(serialized)__                }_            } catch (Exception e) {_                throw new RuntimeException(e)__            }_        }_    };translates,leaf,aggs,min,max,sum,etc,into,their,rollup,version,for,simple,aggs,like,min,this,is,nearly,a,1,1,copy,the,source,is,deserialized,into,a,new,object,and,the,field,is,adjusted,according,to,convention,e,g,for,a,min,agg,pre,code,min,field,pre,the,translation,would,be,pre,code,min,field,min,value,pre,however,for,avg,metrics,and,potentially,others,in,the,future,the,agg,is,translated,into,a,sum,sum,aggs,one,for,count,and,one,for,sum,when,unrolling,these,will,be,combined,back,into,a,single,avg,note,that,we,also,have,to,rename,the,avg,agg,name,to,distinguish,it,from,empty,buckets,e,g,for,an,avg,agg,pre,code,avg,field,pre,the,translation,would,be,pre,code,value,sum,field,avg,value,sum,field,avg,pre,the,conventions,are,ul,li,agg,type,same,as,source,agg,li,li,named,same,as,the,source,agg,li,li,field,value,li,ul,if,the,agg,is,an,avg,agg,the,following,additional,conventions,are,added,ul,li,agg,type,becomes,sum,agg,instead,of,avg,agg,li,li,named,source,name,value,li,li,additionally,an,extra,sum,agg,is,added,li,li,ul,li,named,source,name,li,li,field,field,name,agg,type,li,ul,li,ul,param,metric,the,source,leaf,aggregation,we,wish,to,translate,param,registry,a,registry,of,named,writeable,s,so,we,can,do,a,simple,serialize,deserialize,for,most,of,the,leafs,to,easily,clone,them,return,the,translated,leaf,aggregation;private,static,list,aggregation,builder,translate,vsleaf,values,source,aggregation,builder,leaf,only,metric,named,writeable,registry,registry,list,aggregation,builder,rolled,metrics,if,metric,instanceof,avg,aggregation,builder,rolled,metrics,new,array,list,2,sum,aggregation,builder,value,new,sum,aggregation,builder,rollup,field,format,value,agg,name,metric,get,name,value,field,rollup,field,format,field,name,metric,rollup,field,value,rolled,metrics,add,value,rolled,metrics,add,new,sum,aggregation,builder,rollup,field,format,count,agg,name,metric,get,name,field,rollup,field,format,field,name,metric,rollup,field,return,rolled,metrics,try,bytes,stream,output,output,new,bytes,stream,output,try,output,write,string,metric,get,type,metric,write,to,output,try,stream,input,stream,output,bytes,stream,input,named,writeable,aware,stream,input,in,new,named,writeable,aware,stream,input,stream,registry,values,source,aggregation,builder,serialized,values,source,aggregation,builder,in,read,named,writeable,aggregation,builder,class,field,rollup,field,format,field,name,metric,rollup,field,value,return,collections,singleton,list,serialized,catch,exception,e,throw,new,runtime,exception,e
RollupRequestTranslator -> public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,                                                                 List<QueryBuilder> filterConditions,                                                                 NamedWriteableRegistry registry);1524684173;Translates a non-rollup aggregation tree into a rollup-enabled agg tree.  For example, the_source aggregation may look like this:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "1d"__"aggs": {_"the_max": {_"max": {_"field": "foo"_______}</pre>__Which is then translated into an aggregation looking like this:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"filter_histo" : {_"filter" : {_"bool" : {_"must" : [_{ "term" : { "_rollup.version" : 1   } },_{ "term": {  "ts.date_histogram.interval" : "1d"  } }____"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "1d"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }__"the_max" : {_"max" : { "field" : "foo.max.value" }________}</pre>__The various conventions that are applied during the translation are elucidated in the comments of the_relevant method below.__@param source           The source aggregation to translate into rollup-enabled version_@param filterConditions A list used to track any filter conditions that sub-aggs may_require._@param registry  Registry containing the various aggregations so that we can easily_deserialize into a stream for cloning_@return  Returns the fully translated aggregation tree. Note that it returns a list instead_of a single AggBuilder, since some aggregations (e.g. avg) may result in two_translated aggs (sum + count);public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,_                                                                List<QueryBuilder> filterConditions,_                                                                NamedWriteableRegistry registry) {__        if (source.getWriteableName().equals(DateHistogramAggregationBuilder.NAME)) {_            return translateDateHistogram((DateHistogramAggregationBuilder) source, filterConditions, registry)__        } else if (source.getWriteableName().equals(HistogramAggregationBuilder.NAME)) {_            return translateHistogram((HistogramAggregationBuilder) source, filterConditions, registry)__        } else if (RollupField.SUPPORTED_METRICS.contains(source.getWriteableName())) {_            return translateVSLeaf((ValuesSourceAggregationBuilder.LeafOnly)source, registry)__        } else if (source.getWriteableName().equals(TermsAggregationBuilder.NAME)) {_            return translateTerms((TermsAggregationBuilder)source, filterConditions, registry)__        } else {_            throw new IllegalArgumentException("Unable to translate aggregation tree into Rollup.  Aggregation ["_                    + source.getName() + "] is of type [" + source.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };translates,a,non,rollup,aggregation,tree,into,a,rollup,enabled,agg,tree,for,example,the,source,aggregation,may,look,like,this,pre,code,post,foo,aggregations,field,ts,interval,1d,aggs,max,field,foo,pre,which,is,then,translated,into,an,aggregation,looking,like,this,pre,code,post,aggregations,filter,bool,must,term,version,1,term,ts,interval,1d,aggregations,field,ts,timestamp,interval,1d,aggregations,sum,field,ts,max,field,foo,max,value,pre,the,various,conventions,that,are,applied,during,the,translation,are,elucidated,in,the,comments,of,the,relevant,method,below,param,source,the,source,aggregation,to,translate,into,rollup,enabled,version,param,filter,conditions,a,list,used,to,track,any,filter,conditions,that,sub,aggs,may,require,param,registry,registry,containing,the,various,aggregations,so,that,we,can,easily,deserialize,into,a,stream,for,cloning,return,returns,the,fully,translated,aggregation,tree,note,that,it,returns,a,list,instead,of,a,single,agg,builder,since,some,aggregations,e,g,avg,may,result,in,two,translated,aggs,sum,count;public,static,list,aggregation,builder,translate,aggregation,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,if,source,get,writeable,name,equals,date,histogram,aggregation,builder,name,return,translate,date,histogram,date,histogram,aggregation,builder,source,filter,conditions,registry,else,if,source,get,writeable,name,equals,histogram,aggregation,builder,name,return,translate,histogram,histogram,aggregation,builder,source,filter,conditions,registry,else,if,rollup,field,contains,source,get,writeable,name,return,translate,vsleaf,values,source,aggregation,builder,leaf,only,source,registry,else,if,source,get,writeable,name,equals,terms,aggregation,builder,name,return,translate,terms,terms,aggregation,builder,source,filter,conditions,registry,else,throw,new,illegal,argument,exception,unable,to,translate,aggregation,tree,into,rollup,aggregation,source,get,name,is,of,type,source,get,class,get,simple,name,which,is,currently,unsupported
RollupRequestTranslator -> public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,                                                                 List<QueryBuilder> filterConditions,                                                                 NamedWriteableRegistry registry);1532434432;Translates a non-rollup aggregation tree into a rollup-enabled agg tree.  For example, the_source aggregation may look like this:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "1d"__"aggs": {_"the_max": {_"max": {_"field": "foo"_______}</pre>__Which is then translated into an aggregation looking like this:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"filter_histo" : {_"filter" : {_"bool" : {_"must" : [_{ "term" : { "_rollup.version" : 1   } },_{ "term": {  "ts.date_histogram.interval" : "1d"  } }____"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "1d"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }__"the_max" : {_"max" : { "field" : "foo.max.value" }________}</pre>__The various conventions that are applied during the translation are elucidated in the comments of the_relevant method below.__@param source           The source aggregation to translate into rollup-enabled version_@param filterConditions A list used to track any filter conditions that sub-aggs may_require._@param registry  Registry containing the various aggregations so that we can easily_deserialize into a stream for cloning_@return  Returns the fully translated aggregation tree. Note that it returns a list instead_of a single AggBuilder, since some aggregations (e.g. avg) may result in two_translated aggs (sum + count);public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,_                                                                List<QueryBuilder> filterConditions,_                                                                NamedWriteableRegistry registry) {__        if (source.getWriteableName().equals(DateHistogramAggregationBuilder.NAME)) {_            return translateDateHistogram((DateHistogramAggregationBuilder) source, filterConditions, registry)__        } else if (source.getWriteableName().equals(HistogramAggregationBuilder.NAME)) {_            return translateHistogram((HistogramAggregationBuilder) source, filterConditions, registry)__        } else if (RollupField.SUPPORTED_METRICS.contains(source.getWriteableName())) {_            return translateVSLeaf((ValuesSourceAggregationBuilder.LeafOnly)source, registry)__        } else if (source.getWriteableName().equals(TermsAggregationBuilder.NAME)) {_            return translateTerms((TermsAggregationBuilder)source, filterConditions, registry)__        } else {_            throw new IllegalArgumentException("Unable to translate aggregation tree into Rollup.  Aggregation ["_                    + source.getName() + "] is of type [" + source.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };translates,a,non,rollup,aggregation,tree,into,a,rollup,enabled,agg,tree,for,example,the,source,aggregation,may,look,like,this,pre,code,post,foo,aggregations,field,ts,interval,1d,aggs,max,field,foo,pre,which,is,then,translated,into,an,aggregation,looking,like,this,pre,code,post,aggregations,filter,bool,must,term,version,1,term,ts,interval,1d,aggregations,field,ts,timestamp,interval,1d,aggregations,sum,field,ts,max,field,foo,max,value,pre,the,various,conventions,that,are,applied,during,the,translation,are,elucidated,in,the,comments,of,the,relevant,method,below,param,source,the,source,aggregation,to,translate,into,rollup,enabled,version,param,filter,conditions,a,list,used,to,track,any,filter,conditions,that,sub,aggs,may,require,param,registry,registry,containing,the,various,aggregations,so,that,we,can,easily,deserialize,into,a,stream,for,cloning,return,returns,the,fully,translated,aggregation,tree,note,that,it,returns,a,list,instead,of,a,single,agg,builder,since,some,aggregations,e,g,avg,may,result,in,two,translated,aggs,sum,count;public,static,list,aggregation,builder,translate,aggregation,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,if,source,get,writeable,name,equals,date,histogram,aggregation,builder,name,return,translate,date,histogram,date,histogram,aggregation,builder,source,filter,conditions,registry,else,if,source,get,writeable,name,equals,histogram,aggregation,builder,name,return,translate,histogram,histogram,aggregation,builder,source,filter,conditions,registry,else,if,rollup,field,contains,source,get,writeable,name,return,translate,vsleaf,values,source,aggregation,builder,leaf,only,source,registry,else,if,source,get,writeable,name,equals,terms,aggregation,builder,name,return,translate,terms,terms,aggregation,builder,source,filter,conditions,registry,else,throw,new,illegal,argument,exception,unable,to,translate,aggregation,tree,into,rollup,aggregation,source,get,name,is,of,type,source,get,class,get,simple,name,which,is,currently,unsupported
RollupRequestTranslator -> public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,                                                                 List<QueryBuilder> filterConditions,                                                                 NamedWriteableRegistry registry);1533319589;Translates a non-rollup aggregation tree into a rollup-enabled agg tree.  For example, the_source aggregation may look like this:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "1d"__"aggs": {_"the_max": {_"max": {_"field": "foo"_______}</pre>__Which is then translated into an aggregation looking like this:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"filter_histo" : {_"filter" : {_"bool" : {_"must" : [_{ "term" : { "_rollup.version" : 1   } },_{ "term": {  "ts.date_histogram.interval" : "1d"  } }____"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "1d"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }__"the_max" : {_"max" : { "field" : "foo.max.value" }________}</pre>__The various conventions that are applied during the translation are elucidated in the comments of the_relevant method below.__@param source           The source aggregation to translate into rollup-enabled version_@param filterConditions A list used to track any filter conditions that sub-aggs may_require._@param registry  Registry containing the various aggregations so that we can easily_deserialize into a stream for cloning_@return  Returns the fully translated aggregation tree. Note that it returns a list instead_of a single AggBuilder, since some aggregations (e.g. avg) may result in two_translated aggs (sum + count);public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,_                                                                List<QueryBuilder> filterConditions,_                                                                NamedWriteableRegistry registry) {__        if (source.getWriteableName().equals(DateHistogramAggregationBuilder.NAME)) {_            return translateDateHistogram((DateHistogramAggregationBuilder) source, filterConditions, registry)__        } else if (source.getWriteableName().equals(HistogramAggregationBuilder.NAME)) {_            return translateHistogram((HistogramAggregationBuilder) source, filterConditions, registry)__        } else if (RollupField.SUPPORTED_METRICS.contains(source.getWriteableName())) {_            return translateVSLeaf((ValuesSourceAggregationBuilder.LeafOnly)source, registry)__        } else if (source.getWriteableName().equals(TermsAggregationBuilder.NAME)) {_            return translateTerms((TermsAggregationBuilder)source, filterConditions, registry)__        } else {_            throw new IllegalArgumentException("Unable to translate aggregation tree into Rollup.  Aggregation ["_                    + source.getName() + "] is of type [" + source.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };translates,a,non,rollup,aggregation,tree,into,a,rollup,enabled,agg,tree,for,example,the,source,aggregation,may,look,like,this,pre,code,post,foo,aggregations,field,ts,interval,1d,aggs,max,field,foo,pre,which,is,then,translated,into,an,aggregation,looking,like,this,pre,code,post,aggregations,filter,bool,must,term,version,1,term,ts,interval,1d,aggregations,field,ts,timestamp,interval,1d,aggregations,sum,field,ts,max,field,foo,max,value,pre,the,various,conventions,that,are,applied,during,the,translation,are,elucidated,in,the,comments,of,the,relevant,method,below,param,source,the,source,aggregation,to,translate,into,rollup,enabled,version,param,filter,conditions,a,list,used,to,track,any,filter,conditions,that,sub,aggs,may,require,param,registry,registry,containing,the,various,aggregations,so,that,we,can,easily,deserialize,into,a,stream,for,cloning,return,returns,the,fully,translated,aggregation,tree,note,that,it,returns,a,list,instead,of,a,single,agg,builder,since,some,aggregations,e,g,avg,may,result,in,two,translated,aggs,sum,count;public,static,list,aggregation,builder,translate,aggregation,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,if,source,get,writeable,name,equals,date,histogram,aggregation,builder,name,return,translate,date,histogram,date,histogram,aggregation,builder,source,filter,conditions,registry,else,if,source,get,writeable,name,equals,histogram,aggregation,builder,name,return,translate,histogram,histogram,aggregation,builder,source,filter,conditions,registry,else,if,rollup,field,contains,source,get,writeable,name,return,translate,vsleaf,values,source,aggregation,builder,leaf,only,source,registry,else,if,source,get,writeable,name,equals,terms,aggregation,builder,name,return,translate,terms,terms,aggregation,builder,source,filter,conditions,registry,else,throw,new,illegal,argument,exception,unable,to,translate,aggregation,tree,into,rollup,aggregation,source,get,name,is,of,type,source,get,class,get,simple,name,which,is,currently,unsupported
RollupRequestTranslator -> public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,                                                                 List<QueryBuilder> filterConditions,                                                                 NamedWriteableRegistry registry);1536314350;Translates a non-rollup aggregation tree into a rollup-enabled agg tree.  For example, the_source aggregation may look like this:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "1d"__"aggs": {_"the_max": {_"max": {_"field": "foo"_______}</pre>__Which is then translated into an aggregation looking like this:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"filter_histo" : {_"filter" : {_"bool" : {_"must" : [_{ "term" : { "_rollup.version" : 1   } },_{ "term": {  "ts.date_histogram.interval" : "1d"  } }____"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "1d"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }__"the_max" : {_"max" : { "field" : "foo.max.value" }________}</pre>__The various conventions that are applied during the translation are elucidated in the comments of the_relevant method below.__@param source           The source aggregation to translate into rollup-enabled version_@param filterConditions A list used to track any filter conditions that sub-aggs may_require._@param registry  Registry containing the various aggregations so that we can easily_deserialize into a stream for cloning_@return  Returns the fully translated aggregation tree. Note that it returns a list instead_of a single AggBuilder, since some aggregations (e.g. avg) may result in two_translated aggs (sum + count);public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,_                                                                List<QueryBuilder> filterConditions,_                                                                NamedWriteableRegistry registry) {__        if (source.getWriteableName().equals(DateHistogramAggregationBuilder.NAME)) {_            return translateDateHistogram((DateHistogramAggregationBuilder) source, filterConditions, registry)__        } else if (source.getWriteableName().equals(HistogramAggregationBuilder.NAME)) {_            return translateHistogram((HistogramAggregationBuilder) source, filterConditions, registry)__        } else if (RollupField.SUPPORTED_METRICS.contains(source.getWriteableName())) {_            return translateVSLeaf((ValuesSourceAggregationBuilder.LeafOnly)source, registry)__        } else if (source.getWriteableName().equals(TermsAggregationBuilder.NAME)) {_            return translateTerms((TermsAggregationBuilder)source, filterConditions, registry)__        } else {_            throw new IllegalArgumentException("Unable to translate aggregation tree into Rollup.  Aggregation ["_                    + source.getName() + "] is of type [" + source.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };translates,a,non,rollup,aggregation,tree,into,a,rollup,enabled,agg,tree,for,example,the,source,aggregation,may,look,like,this,pre,code,post,foo,aggregations,field,ts,interval,1d,aggs,max,field,foo,pre,which,is,then,translated,into,an,aggregation,looking,like,this,pre,code,post,aggregations,filter,bool,must,term,version,1,term,ts,interval,1d,aggregations,field,ts,timestamp,interval,1d,aggregations,sum,field,ts,max,field,foo,max,value,pre,the,various,conventions,that,are,applied,during,the,translation,are,elucidated,in,the,comments,of,the,relevant,method,below,param,source,the,source,aggregation,to,translate,into,rollup,enabled,version,param,filter,conditions,a,list,used,to,track,any,filter,conditions,that,sub,aggs,may,require,param,registry,registry,containing,the,various,aggregations,so,that,we,can,easily,deserialize,into,a,stream,for,cloning,return,returns,the,fully,translated,aggregation,tree,note,that,it,returns,a,list,instead,of,a,single,agg,builder,since,some,aggregations,e,g,avg,may,result,in,two,translated,aggs,sum,count;public,static,list,aggregation,builder,translate,aggregation,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,if,source,get,writeable,name,equals,date,histogram,aggregation,builder,name,return,translate,date,histogram,date,histogram,aggregation,builder,source,filter,conditions,registry,else,if,source,get,writeable,name,equals,histogram,aggregation,builder,name,return,translate,histogram,histogram,aggregation,builder,source,filter,conditions,registry,else,if,rollup,field,contains,source,get,writeable,name,return,translate,vsleaf,values,source,aggregation,builder,leaf,only,source,registry,else,if,source,get,writeable,name,equals,terms,aggregation,builder,name,return,translate,terms,terms,aggregation,builder,source,filter,conditions,registry,else,throw,new,illegal,argument,exception,unable,to,translate,aggregation,tree,into,rollup,aggregation,source,get,name,is,of,type,source,get,class,get,simple,name,which,is,currently,unsupported
RollupRequestTranslator -> public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,                                                                 List<QueryBuilder> filterConditions,                                                                 NamedWriteableRegistry registry);1539951844;Translates a non-rollup aggregation tree into a rollup-enabled agg tree.  For example, the_source aggregation may look like this:__<pre>{@code_POST /foo/_rollup_search__"aggregations": {_"the_histo": {_"date_histogram" : {_"field" : "ts",_"interval" : "1d"__"aggs": {_"the_max": {_"max": {_"field": "foo"_______}</pre>__Which is then translated into an aggregation looking like this:__<pre>{@code_POST /rolled_foo/_search__"aggregations" : {_"filter_histo" : {_"filter" : {_"bool" : {_"must" : [_{ "term" : { "_rollup.version" : 1   } },_{ "term": {  "ts.date_histogram.interval" : "1d"  } }____"aggregations" : {_"the_histo" : {_"date_histogram" : {_"field" : "ts.date_histogram.timestamp",_"interval" : "1d"__"aggregations" : {_"the_histo._count" : {_"sum" : { "field" : "ts.date_histogram._count" }__"the_max" : {_"max" : { "field" : "foo.max.value" }________}</pre>__The various conventions that are applied during the translation are elucidated in the comments of the_relevant method below.__@param source           The source aggregation to translate into rollup-enabled version_@param filterConditions A list used to track any filter conditions that sub-aggs may_require._@param registry  Registry containing the various aggregations so that we can easily_deserialize into a stream for cloning_@return  Returns the fully translated aggregation tree. Note that it returns a list instead_of a single AggBuilder, since some aggregations (e.g. avg) may result in two_translated aggs (sum + count);public static List<AggregationBuilder> translateAggregation(AggregationBuilder source,_                                                                List<QueryBuilder> filterConditions,_                                                                NamedWriteableRegistry registry) {__        if (source.getWriteableName().equals(DateHistogramAggregationBuilder.NAME)) {_            return translateDateHistogram((DateHistogramAggregationBuilder) source, filterConditions, registry)__        } else if (source.getWriteableName().equals(HistogramAggregationBuilder.NAME)) {_            return translateHistogram((HistogramAggregationBuilder) source, filterConditions, registry)__        } else if (RollupField.SUPPORTED_METRICS.contains(source.getWriteableName())) {_            return translateVSLeaf((ValuesSourceAggregationBuilder.LeafOnly)source, registry)__        } else if (source.getWriteableName().equals(TermsAggregationBuilder.NAME)) {_            return translateTerms((TermsAggregationBuilder)source, filterConditions, registry)__        } else {_            throw new IllegalArgumentException("Unable to translate aggregation tree into Rollup.  Aggregation ["_                    + source.getName() + "] is of type [" + source.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };translates,a,non,rollup,aggregation,tree,into,a,rollup,enabled,agg,tree,for,example,the,source,aggregation,may,look,like,this,pre,code,post,foo,aggregations,field,ts,interval,1d,aggs,max,field,foo,pre,which,is,then,translated,into,an,aggregation,looking,like,this,pre,code,post,aggregations,filter,bool,must,term,version,1,term,ts,interval,1d,aggregations,field,ts,timestamp,interval,1d,aggregations,sum,field,ts,max,field,foo,max,value,pre,the,various,conventions,that,are,applied,during,the,translation,are,elucidated,in,the,comments,of,the,relevant,method,below,param,source,the,source,aggregation,to,translate,into,rollup,enabled,version,param,filter,conditions,a,list,used,to,track,any,filter,conditions,that,sub,aggs,may,require,param,registry,registry,containing,the,various,aggregations,so,that,we,can,easily,deserialize,into,a,stream,for,cloning,return,returns,the,fully,translated,aggregation,tree,note,that,it,returns,a,list,instead,of,a,single,agg,builder,since,some,aggregations,e,g,avg,may,result,in,two,translated,aggs,sum,count;public,static,list,aggregation,builder,translate,aggregation,aggregation,builder,source,list,query,builder,filter,conditions,named,writeable,registry,registry,if,source,get,writeable,name,equals,date,histogram,aggregation,builder,name,return,translate,date,histogram,date,histogram,aggregation,builder,source,filter,conditions,registry,else,if,source,get,writeable,name,equals,histogram,aggregation,builder,name,return,translate,histogram,histogram,aggregation,builder,source,filter,conditions,registry,else,if,rollup,field,contains,source,get,writeable,name,return,translate,vsleaf,values,source,aggregation,builder,leaf,only,source,registry,else,if,source,get,writeable,name,equals,terms,aggregation,builder,name,return,translate,terms,terms,aggregation,builder,source,filter,conditions,registry,else,throw,new,illegal,argument,exception,unable,to,translate,aggregation,tree,into,rollup,aggregation,source,get,name,is,of,type,source,get,class,get,simple,name,which,is,currently,unsupported
