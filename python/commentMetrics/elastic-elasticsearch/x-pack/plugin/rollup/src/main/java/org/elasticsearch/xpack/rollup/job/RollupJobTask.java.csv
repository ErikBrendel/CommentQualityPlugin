commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;13;;@Override protected void nodeOperation(AllocatedPersistentTask task, @Nullable RollupJob params, PersistentTaskState state) {     RollupJobTask rollupJobTask = (RollupJobTask) task.     SchedulerEngine.Job schedulerJob = new SchedulerEngine.Job(SCHEDULE_NAME + "_" + params.getConfig().getId(), new CronSchedule(params.getConfig().getCron())).     // Note that while the task is added to the scheduler here, the internal state will prevent     // it from doing any work until the task is "started" via the StartJob api     schedulerEngine.register(rollupJobTask).     schedulerEngine.add(schedulerJob).     logger.info("Rollup job [" + params.getConfig().getId() + "] created."). }
false;protected;6;7;;@Override protected AllocatedPersistentTask createTask(long id, String type, String action, TaskId parentTaskId, PersistentTasksCustomMetaData.PersistentTask<RollupJob> persistentTask, Map<String, String> headers) {     return new RollupJobTask(id, type, action, parentTaskId, persistentTask.getParams(), (RollupJobStatus) persistentTask.getState(), client, schedulerEngine, threadPool, headers). }
false;protected;2;5;;@Override protected void doNextSearch(SearchRequest request, ActionListener<SearchResponse> nextPhase) {     ClientHelper.executeWithHeadersAsync(job.getHeaders(), ClientHelper.ROLLUP_ORIGIN, client, SearchAction.INSTANCE, request, nextPhase). }
false;protected;2;5;;@Override protected void doNextBulk(BulkRequest request, ActionListener<BulkResponse> nextPhase) {     ClientHelper.executeWithHeadersAsync(job.getHeaders(), ClientHelper.ROLLUP_ORIGIN, client, BulkAction.INSTANCE, request, nextPhase). }
false;protected;3;19;;@Override protected void doSaveState(IndexerState indexerState, Map<String, Object> position, Runnable next) {     if (indexerState.equals(IndexerState.ABORTING)) {         // If we're aborting, just invoke `next` (which is likely an onFailure handler)         next.run().     } else {         // Otherwise, attempt to persist our state         // Upgrade to the new ID scheme while we are at it         boolean oldState = upgradedDocumentID.getAndSet(true).         final RollupJobStatus state = new RollupJobStatus(indexerState, getPosition(), upgradedDocumentID.get()).         logger.debug("Updating persistent state of job [" + job.getConfig().getId() + "] to [" + indexerState.toString() + "]").         updatePersistentTaskState(state, ActionListener.wrap(task -> next.run(), exc -> {             // We failed to update the persistent task for some reason,             // set our flag back to what it was before             upgradedDocumentID.set(oldState).             next.run().         })).     } }
false;protected;0;4;;@Override protected void onFinish() {     logger.debug("Finished indexing for job [" + job.getConfig().getId() + "]"). }
false;protected;1;4;;@Override protected void onFailure(Exception exc) {     logger.warn("Rollup job [" + job.getConfig().getId() + "] failed with an exception: ", exc). }
false;protected;0;4;;@Override protected void onAbort() {     shutdown(). }
false;public;0;4;;@Override public Status getStatus() {     return new RollupJobStatus(indexer.getState(), indexer.getPosition(), upgradedDocumentID.get()). }
true;public;0;3;/**  * Gets the stats for this task.  * @return The stats of this task  */ ;/**  * Gets the stats for this task.  * @return The stats of this task  */ public RollupIndexerJobStats getStats() {     return indexer.getStats(). }
true;public;0;3;/**  * The config of this task  * @return The config for this task  */ ;/**  * The config of this task  * @return The config for this task  */ public RollupJobConfig getConfig() {     return job.getConfig(). }
true;public,synchronized;1;38;/**  * Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail.  * Otherwise, the persistent task's status will be updated to reflect the change.  *  * Note that while the job is started, the indexer will not necessarily run immediately.  That  * will only occur when the scheduler triggers it based on the cron  *  * @param listener The listener that started the action, so that we can signal completion/failure  */ ;/**  * Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail.  * Otherwise, the persistent task's status will be updated to reflect the change.  *  * Note that while the job is started, the indexer will not necessarily run immediately.  That  * will only occur when the scheduler triggers it based on the cron  *  * @param listener The listener that started the action, so that we can signal completion/failure  */ public synchronized void start(ActionListener<StartRollupJobAction.Response> listener) {     final IndexerState prevState = indexer.getState().     if (prevState != IndexerState.STOPPED) {         // fails if the task is not STOPPED         listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because" + " state was [" + prevState + "]")).         return.     }     final IndexerState newState = indexer.start().     if (newState != IndexerState.STARTED) {         listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because" + " state was [" + newState + "]")).         return.     }     final RollupJobStatus state = new RollupJobStatus(IndexerState.STARTED, indexer.getPosition(), upgradedDocumentID.get()).     logger.debug("Updating state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "][" + state.getPosition() + "]").     updatePersistentTaskState(state, ActionListener.wrap((task) -> {         logger.debug("Successfully updated state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "][" + state.getPosition() + "]").         listener.onResponse(new StartRollupJobAction.Response(true)).     }, (exc) -> {         // We were unable to update the persistent status, so we need to shutdown the indexer too.         indexer.stop().         listener.onFailure(new ElasticsearchException("Error while updating state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "].", exc)).     })). }
true;public,synchronized;1;36;/**  * Attempt to stop the indexer if it is idle or actively indexing.  * If the indexer is aborted this will fail with an exception.  *  * Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated  * task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).  *  * This method will, however, return as soon as the persistent task has acknowledge the status update.  *  * @param listener The listener that is requesting the stop, so that we can signal completion/failure  */ ;/**  * Attempt to stop the indexer if it is idle or actively indexing.  * If the indexer is aborted this will fail with an exception.  *  * Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated  * task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).  *  * This method will, however, return as soon as the persistent task has acknowledge the status update.  *  * @param listener The listener that is requesting the stop, so that we can signal completion/failure  */ public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener) {     final IndexerState newState = indexer.stop().     switch(newState) {         case STOPPED:             listener.onResponse(new StopRollupJobAction.Response(true)).             break.         case STOPPING:             // update the persistent state to STOPPED.  There are two scenarios and both are safe:             // 1. we persist STOPPED now, indexer continues a bit then sees the flag and checkpoints another             // STOPPED with the more recent position.  That will also upgrade the ID scheme             // 2. we persist STOPPED now, indexer continues a bit but then dies.  When/if we resume we'll pick up             // at last checkpoint, overwrite some docs and eventually checkpoint.  At that time we'll also             // upgrade the ID scheme             RollupJobStatus state = new RollupJobStatus(IndexerState.STOPPED, indexer.getPosition(), upgradedDocumentID.get()).             updatePersistentTaskState(state, ActionListener.wrap((task) -> {                 logger.debug("Successfully updated state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "]").                 listener.onResponse(new StopRollupJobAction.Response(true)).             }, (exc) -> {                 listener.onFailure(new ElasticsearchException("Error while updating state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "].", exc)).             })).             break.         default:             listener.onFailure(new ElasticsearchException("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because" + " state was [" + newState + "]")).             break.     } }
true;synchronized;0;11;/**  * Attempt to gracefully cleanup the rollup job so it can be terminated.  * This tries to remove the job from the scheduler, and potentially any other  * cleanup operations in the future  */ ;/**  * Attempt to gracefully cleanup the rollup job so it can be terminated.  * This tries to remove the job from the scheduler, and potentially any other  * cleanup operations in the future  */ synchronized void shutdown() {     try {         logger.info("Rollup indexer [" + job.getConfig().getId() + "] received abort request, stopping indexer.").         schedulerEngine.remove(SCHEDULE_NAME + "_" + job.getConfig().getId()).         schedulerEngine.unregister(this).     } catch (Exception e) {         markAsFailed(e).         return.     }     markAsCompleted(). }
true;public,synchronized;0;8;/**  * This is called when the persistent task signals that the allocated task should be terminated.  * Termination in the task framework is essentially voluntary, as the allocated task can only be  * shut down from the inside.  */ ;/**  * This is called when the persistent task signals that the allocated task should be terminated.  * Termination in the task framework is essentially voluntary, as the allocated task can only be  * shut down from the inside.  */ @Override public synchronized void onCancelled() {     logger.info("Received cancellation request for Rollup job [" + job.getConfig().getId() + "], state: [" + indexer.getState() + "]").     if (indexer.abort()) {         // there is no background job running, we can shutdown safely         shutdown().     } }
true;public,synchronized;1;9;/**  * This is called by the ScheduleEngine when the cron triggers.  *  * @param event The event that caused the trigger  */ ;/**  * This is called by the ScheduleEngine when the cron triggers.  *  * @param event The event that caused the trigger  */ @Override public synchronized void triggered(SchedulerEngine.Event event) {     // Note that the status of the indexer is checked in the indexer itself     if (event.getJobName().equals(SCHEDULE_NAME + "_" + job.getConfig().getId())) {         logger.debug("Rollup indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]").         indexer.maybeTriggerAsyncJob(System.currentTimeMillis()).     } }
