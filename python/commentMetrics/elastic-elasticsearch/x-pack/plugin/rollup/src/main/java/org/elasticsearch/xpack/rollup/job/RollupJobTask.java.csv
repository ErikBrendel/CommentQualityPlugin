# id;timestamp;commentText;codeText;commentWords;codeWords
RollupJobTask -> public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener);1524684173;Attempt to stop the indexer if it is idle or actively indexing._If the indexer is aborted this will fail with an exception.__Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated_task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).__This method will, however, return as soon as the persistent task has acknowledge the status update.__@param listener The listener that is requesting the stop, so that we can signal completion/failure;public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener) {_        final IndexerState newState = indexer.stop()__        switch (newState) {_            case STOPPED:_                listener.onResponse(new StopRollupJobAction.Response(true))__                break___            case STOPPING:_                _                _                RollupJobStatus status = new RollupJobStatus(IndexerState.STOPPED, indexer.getPosition())__                updatePersistentStatus(status,_                        ActionListener.wrap(_                                (task) -> {_                                    logger.debug("Succesfully updated status for rollup job [" + job.getConfig().getId()_                                            + "] to [" + status.getState() + "]")__                                    listener.onResponse(new StopRollupJobAction.Response(true))__                                },_                                (exc) -> {_                                    listener.onFailure(new ElasticsearchException("Error while updating status for rollup job ["_                                            + job.getConfig().getId() + "] to [" + status.getState() + "].", exc))__                                })_                )__                break___            default:_                listener.onFailure(new ElasticsearchException("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because"_                        + " state was [" + newState + "]"))__                break__        }_    };attempt,to,stop,the,indexer,if,it,is,idle,or,actively,indexing,if,the,indexer,is,aborted,this,will,fail,with,an,exception,note,that,stopping,the,job,is,not,immediate,it,updates,the,persistent,task,s,status,but,then,the,allocated,task,has,to,notice,and,stop,itself,which,may,take,some,time,depending,on,where,in,the,indexing,cycle,it,is,this,method,will,however,return,as,soon,as,the,persistent,task,has,acknowledge,the,status,update,param,listener,the,listener,that,is,requesting,the,stop,so,that,we,can,signal,completion,failure;public,synchronized,void,stop,action,listener,stop,rollup,job,action,response,listener,final,indexer,state,new,state,indexer,stop,switch,new,state,case,stopped,listener,on,response,new,stop,rollup,job,action,response,true,break,case,stopping,rollup,job,status,status,new,rollup,job,status,indexer,state,stopped,indexer,get,position,update,persistent,status,status,action,listener,wrap,task,logger,debug,succesfully,updated,status,for,rollup,job,job,get,config,get,id,to,status,get,state,listener,on,response,new,stop,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,status,for,rollup,job,job,get,config,get,id,to,status,get,state,exc,break,default,listener,on,failure,new,elasticsearch,exception,cannot,stop,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,break
RollupJobTask -> public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener);1526467406;Attempt to stop the indexer if it is idle or actively indexing._If the indexer is aborted this will fail with an exception.__Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated_task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).__This method will, however, return as soon as the persistent task has acknowledge the status update.__@param listener The listener that is requesting the stop, so that we can signal completion/failure;public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener) {_        final IndexerState newState = indexer.stop()__        switch (newState) {_            case STOPPED:_                listener.onResponse(new StopRollupJobAction.Response(true))__                break___            case STOPPING:_                _                _                RollupJobStatus status = new RollupJobStatus(IndexerState.STOPPED, indexer.getPosition())__                updatePersistentStatus(status,_                        ActionListener.wrap(_                                (task) -> {_                                    logger.debug("Succesfully updated status for rollup job [" + job.getConfig().getId()_                                            + "] to [" + status.getState() + "]")__                                    listener.onResponse(new StopRollupJobAction.Response(true))__                                },_                                (exc) -> {_                                    listener.onFailure(new ElasticsearchException("Error while updating status for rollup job ["_                                            + job.getConfig().getId() + "] to [" + status.getState() + "].", exc))__                                })_                )__                break___            default:_                listener.onFailure(new ElasticsearchException("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because"_                        + " state was [" + newState + "]"))__                break__        }_    };attempt,to,stop,the,indexer,if,it,is,idle,or,actively,indexing,if,the,indexer,is,aborted,this,will,fail,with,an,exception,note,that,stopping,the,job,is,not,immediate,it,updates,the,persistent,task,s,status,but,then,the,allocated,task,has,to,notice,and,stop,itself,which,may,take,some,time,depending,on,where,in,the,indexing,cycle,it,is,this,method,will,however,return,as,soon,as,the,persistent,task,has,acknowledge,the,status,update,param,listener,the,listener,that,is,requesting,the,stop,so,that,we,can,signal,completion,failure;public,synchronized,void,stop,action,listener,stop,rollup,job,action,response,listener,final,indexer,state,new,state,indexer,stop,switch,new,state,case,stopped,listener,on,response,new,stop,rollup,job,action,response,true,break,case,stopping,rollup,job,status,status,new,rollup,job,status,indexer,state,stopped,indexer,get,position,update,persistent,status,status,action,listener,wrap,task,logger,debug,succesfully,updated,status,for,rollup,job,job,get,config,get,id,to,status,get,state,listener,on,response,new,stop,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,status,for,rollup,job,job,get,config,get,id,to,status,get,state,exc,break,default,listener,on,failure,new,elasticsearch,exception,cannot,stop,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,break
RollupJobTask -> public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener);1529076503;Attempt to stop the indexer if it is idle or actively indexing._If the indexer is aborted this will fail with an exception.__Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated_task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).__This method will, however, return as soon as the persistent task has acknowledge the status update.__@param listener The listener that is requesting the stop, so that we can signal completion/failure;public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener) {_        final IndexerState newState = indexer.stop()__        switch (newState) {_            case STOPPED:_                listener.onResponse(new StopRollupJobAction.Response(true))__                break___            case STOPPING:_                _                _                RollupJobStatus state = new RollupJobStatus(IndexerState.STOPPED, indexer.getPosition())__                updatePersistentTaskState(state,_                        ActionListener.wrap(_                                (task) -> {_                                    logger.debug("Succesfully updated state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "]")__                                    listener.onResponse(new StopRollupJobAction.Response(true))__                                },_                                (exc) -> {_                                    listener.onFailure(new ElasticsearchException("Error while updating state for rollup job ["_                                            + job.getConfig().getId() + "] to [" + state.getIndexerState() + "].", exc))__                                })_                )__                break___            default:_                listener.onFailure(new ElasticsearchException("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because"_                        + " state was [" + newState + "]"))__                break__        }_    };attempt,to,stop,the,indexer,if,it,is,idle,or,actively,indexing,if,the,indexer,is,aborted,this,will,fail,with,an,exception,note,that,stopping,the,job,is,not,immediate,it,updates,the,persistent,task,s,status,but,then,the,allocated,task,has,to,notice,and,stop,itself,which,may,take,some,time,depending,on,where,in,the,indexing,cycle,it,is,this,method,will,however,return,as,soon,as,the,persistent,task,has,acknowledge,the,status,update,param,listener,the,listener,that,is,requesting,the,stop,so,that,we,can,signal,completion,failure;public,synchronized,void,stop,action,listener,stop,rollup,job,action,response,listener,final,indexer,state,new,state,indexer,stop,switch,new,state,case,stopped,listener,on,response,new,stop,rollup,job,action,response,true,break,case,stopping,rollup,job,status,state,new,rollup,job,status,indexer,state,stopped,indexer,get,position,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,succesfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,listener,on,response,new,stop,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc,break,default,listener,on,failure,new,elasticsearch,exception,cannot,stop,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,break
RollupJobTask -> public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener);1533319589;Attempt to stop the indexer if it is idle or actively indexing._If the indexer is aborted this will fail with an exception.__Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated_task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).__This method will, however, return as soon as the persistent task has acknowledge the status update.__@param listener The listener that is requesting the stop, so that we can signal completion/failure;public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener) {__        final IndexerState newState = indexer.stop()__        switch (newState) {_            case STOPPED:_                listener.onResponse(new StopRollupJobAction.Response(true))__                break___            case STOPPING:_                _                _                _                _                _                _                RollupJobStatus state = new RollupJobStatus(IndexerState.STOPPED, indexer.getPosition(), upgradedDocumentID.get())__                updatePersistentTaskState(state,_                        ActionListener.wrap(_                                (task) -> {_                                    logger.debug("Succesfully updated state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "]")__                                    listener.onResponse(new StopRollupJobAction.Response(true))__                                },_                                (exc) -> {_                                    listener.onFailure(new ElasticsearchException("Error while updating state for rollup job ["_                                            + job.getConfig().getId() + "] to [" + state.getIndexerState() + "].", exc))__                                })_                )__                break___            default:_                listener.onFailure(new ElasticsearchException("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because"_                        + " state was [" + newState + "]"))__                break__        }_    };attempt,to,stop,the,indexer,if,it,is,idle,or,actively,indexing,if,the,indexer,is,aborted,this,will,fail,with,an,exception,note,that,stopping,the,job,is,not,immediate,it,updates,the,persistent,task,s,status,but,then,the,allocated,task,has,to,notice,and,stop,itself,which,may,take,some,time,depending,on,where,in,the,indexing,cycle,it,is,this,method,will,however,return,as,soon,as,the,persistent,task,has,acknowledge,the,status,update,param,listener,the,listener,that,is,requesting,the,stop,so,that,we,can,signal,completion,failure;public,synchronized,void,stop,action,listener,stop,rollup,job,action,response,listener,final,indexer,state,new,state,indexer,stop,switch,new,state,case,stopped,listener,on,response,new,stop,rollup,job,action,response,true,break,case,stopping,rollup,job,status,state,new,rollup,job,status,indexer,state,stopped,indexer,get,position,upgraded,document,id,get,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,succesfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,listener,on,response,new,stop,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc,break,default,listener,on,failure,new,elasticsearch,exception,cannot,stop,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,break
RollupJobTask -> public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener);1535666657;Attempt to stop the indexer if it is idle or actively indexing._If the indexer is aborted this will fail with an exception.__Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated_task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).__This method will, however, return as soon as the persistent task has acknowledge the status update.__@param listener The listener that is requesting the stop, so that we can signal completion/failure;public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener) {__        final IndexerState newState = indexer.stop()__        switch (newState) {_            case STOPPED:_                listener.onResponse(new StopRollupJobAction.Response(true))__                break___            case STOPPING:_                _                _                _                _                _                _                RollupJobStatus state = new RollupJobStatus(IndexerState.STOPPED, indexer.getPosition(), upgradedDocumentID.get())__                updatePersistentTaskState(state,_                        ActionListener.wrap(_                                (task) -> {_                                    logger.debug("Succesfully updated state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "]")__                                    listener.onResponse(new StopRollupJobAction.Response(true))__                                },_                                (exc) -> {_                                    listener.onFailure(new ElasticsearchException("Error while updating state for rollup job ["_                                            + job.getConfig().getId() + "] to [" + state.getIndexerState() + "].", exc))__                                })_                )__                break___            default:_                listener.onFailure(new ElasticsearchException("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because"_                        + " state was [" + newState + "]"))__                break__        }_    };attempt,to,stop,the,indexer,if,it,is,idle,or,actively,indexing,if,the,indexer,is,aborted,this,will,fail,with,an,exception,note,that,stopping,the,job,is,not,immediate,it,updates,the,persistent,task,s,status,but,then,the,allocated,task,has,to,notice,and,stop,itself,which,may,take,some,time,depending,on,where,in,the,indexing,cycle,it,is,this,method,will,however,return,as,soon,as,the,persistent,task,has,acknowledge,the,status,update,param,listener,the,listener,that,is,requesting,the,stop,so,that,we,can,signal,completion,failure;public,synchronized,void,stop,action,listener,stop,rollup,job,action,response,listener,final,indexer,state,new,state,indexer,stop,switch,new,state,case,stopped,listener,on,response,new,stop,rollup,job,action,response,true,break,case,stopping,rollup,job,status,state,new,rollup,job,status,indexer,state,stopped,indexer,get,position,upgraded,document,id,get,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,succesfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,listener,on,response,new,stop,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc,break,default,listener,on,failure,new,elasticsearch,exception,cannot,stop,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,break
RollupJobTask -> public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener);1539615817;Attempt to stop the indexer if it is idle or actively indexing._If the indexer is aborted this will fail with an exception.__Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated_task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).__This method will, however, return as soon as the persistent task has acknowledge the status update.__@param listener The listener that is requesting the stop, so that we can signal completion/failure;public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener) {__        final IndexerState newState = indexer.stop()__        switch (newState) {_            case STOPPED:_                listener.onResponse(new StopRollupJobAction.Response(true))__                break___            case STOPPING:_                _                _                _                _                _                _                RollupJobStatus state = new RollupJobStatus(IndexerState.STOPPED, indexer.getPosition(), upgradedDocumentID.get())__                updatePersistentTaskState(state,_                        ActionListener.wrap(_                                (task) -> {_                                    logger.debug("Successfully updated state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "]")__                                    listener.onResponse(new StopRollupJobAction.Response(true))__                                },_                                (exc) -> {_                                    listener.onFailure(new ElasticsearchException("Error while updating state for rollup job ["_                                            + job.getConfig().getId() + "] to [" + state.getIndexerState() + "].", exc))__                                })_                )__                break___            default:_                listener.onFailure(new ElasticsearchException("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because"_                        + " state was [" + newState + "]"))__                break__        }_    };attempt,to,stop,the,indexer,if,it,is,idle,or,actively,indexing,if,the,indexer,is,aborted,this,will,fail,with,an,exception,note,that,stopping,the,job,is,not,immediate,it,updates,the,persistent,task,s,status,but,then,the,allocated,task,has,to,notice,and,stop,itself,which,may,take,some,time,depending,on,where,in,the,indexing,cycle,it,is,this,method,will,however,return,as,soon,as,the,persistent,task,has,acknowledge,the,status,update,param,listener,the,listener,that,is,requesting,the,stop,so,that,we,can,signal,completion,failure;public,synchronized,void,stop,action,listener,stop,rollup,job,action,response,listener,final,indexer,state,new,state,indexer,stop,switch,new,state,case,stopped,listener,on,response,new,stop,rollup,job,action,response,true,break,case,stopping,rollup,job,status,state,new,rollup,job,status,indexer,state,stopped,indexer,get,position,upgraded,document,id,get,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,successfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,listener,on,response,new,stop,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc,break,default,listener,on,failure,new,elasticsearch,exception,cannot,stop,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,break
RollupJobTask -> public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener);1540313026;Attempt to stop the indexer if it is idle or actively indexing._If the indexer is aborted this will fail with an exception.__Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated_task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).__This method will, however, return as soon as the persistent task has acknowledge the status update.__@param listener The listener that is requesting the stop, so that we can signal completion/failure;public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener) {__        final IndexerState newState = indexer.stop()__        switch (newState) {_            case STOPPED:_                listener.onResponse(new StopRollupJobAction.Response(true))__                break___            case STOPPING:_                _                _                _                _                _                _                RollupJobStatus state = new RollupJobStatus(IndexerState.STOPPED, indexer.getPosition(), upgradedDocumentID.get())__                updatePersistentTaskState(state,_                        ActionListener.wrap(_                                (task) -> {_                                    logger.debug("Successfully updated state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "]")__                                    listener.onResponse(new StopRollupJobAction.Response(true))__                                },_                                (exc) -> {_                                    listener.onFailure(new ElasticsearchException("Error while updating state for rollup job ["_                                            + job.getConfig().getId() + "] to [" + state.getIndexerState() + "].", exc))__                                })_                )__                break___            default:_                listener.onFailure(new ElasticsearchException("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because"_                        + " state was [" + newState + "]"))__                break__        }_    };attempt,to,stop,the,indexer,if,it,is,idle,or,actively,indexing,if,the,indexer,is,aborted,this,will,fail,with,an,exception,note,that,stopping,the,job,is,not,immediate,it,updates,the,persistent,task,s,status,but,then,the,allocated,task,has,to,notice,and,stop,itself,which,may,take,some,time,depending,on,where,in,the,indexing,cycle,it,is,this,method,will,however,return,as,soon,as,the,persistent,task,has,acknowledge,the,status,update,param,listener,the,listener,that,is,requesting,the,stop,so,that,we,can,signal,completion,failure;public,synchronized,void,stop,action,listener,stop,rollup,job,action,response,listener,final,indexer,state,new,state,indexer,stop,switch,new,state,case,stopped,listener,on,response,new,stop,rollup,job,action,response,true,break,case,stopping,rollup,job,status,state,new,rollup,job,status,indexer,state,stopped,indexer,get,position,upgraded,document,id,get,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,successfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,listener,on,response,new,stop,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc,break,default,listener,on,failure,new,elasticsearch,exception,cannot,stop,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,break
RollupJobTask -> public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener);1541092382;Attempt to stop the indexer if it is idle or actively indexing._If the indexer is aborted this will fail with an exception.__Note that stopping the job is not immediate.  It updates the persistent task's status, but then the allocated_task has to notice and stop itself (which may take some time, depending on where in the indexing cycle it is).__This method will, however, return as soon as the persistent task has acknowledge the status update.__@param listener The listener that is requesting the stop, so that we can signal completion/failure;public synchronized void stop(ActionListener<StopRollupJobAction.Response> listener) {__        final IndexerState newState = indexer.stop()__        switch (newState) {_            case STOPPED:_                listener.onResponse(new StopRollupJobAction.Response(true))__                break___            case STOPPING:_                _                _                _                _                _                _                RollupJobStatus state = new RollupJobStatus(IndexerState.STOPPED, indexer.getPosition(), upgradedDocumentID.get())__                updatePersistentTaskState(state,_                        ActionListener.wrap(_                                (task) -> {_                                    logger.debug("Successfully updated state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "]")__                                    listener.onResponse(new StopRollupJobAction.Response(true))__                                },_                                (exc) -> {_                                    listener.onFailure(new ElasticsearchException("Error while updating state for rollup job ["_                                            + job.getConfig().getId() + "] to [" + state.getIndexerState() + "].", exc))__                                })_                )__                break___            default:_                listener.onFailure(new ElasticsearchException("Cannot stop task for Rollup Job [" + job.getConfig().getId() + "] because"_                        + " state was [" + newState + "]"))__                break__        }_    };attempt,to,stop,the,indexer,if,it,is,idle,or,actively,indexing,if,the,indexer,is,aborted,this,will,fail,with,an,exception,note,that,stopping,the,job,is,not,immediate,it,updates,the,persistent,task,s,status,but,then,the,allocated,task,has,to,notice,and,stop,itself,which,may,take,some,time,depending,on,where,in,the,indexing,cycle,it,is,this,method,will,however,return,as,soon,as,the,persistent,task,has,acknowledge,the,status,update,param,listener,the,listener,that,is,requesting,the,stop,so,that,we,can,signal,completion,failure;public,synchronized,void,stop,action,listener,stop,rollup,job,action,response,listener,final,indexer,state,new,state,indexer,stop,switch,new,state,case,stopped,listener,on,response,new,stop,rollup,job,action,response,true,break,case,stopping,rollup,job,status,state,new,rollup,job,status,indexer,state,stopped,indexer,get,position,upgraded,document,id,get,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,successfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,listener,on,response,new,stop,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc,break,default,listener,on,failure,new,elasticsearch,exception,cannot,stop,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,break
RollupJobTask -> @Override     public synchronized void triggered(SchedulerEngine.Event event);1524684173;This is called by the ScheduleEngine when the cron triggers.__@param event The event that caused the trigger;@Override_    public synchronized void triggered(SchedulerEngine.Event event) {_        _        _        if (event.getJobName().equals(SCHEDULE_NAME + "_" + job.getConfig().getId())) {_            logger.debug("Rollup indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]")__            indexer.maybeTriggerAsyncJob(System.currentTimeMillis())__        }_    };this,is,called,by,the,schedule,engine,when,the,cron,triggers,param,event,the,event,that,caused,the,trigger;override,public,synchronized,void,triggered,scheduler,engine,event,event,if,event,get,job,name,equals,job,get,config,get,id,logger,debug,rollup,indexer,event,get,job,name,schedule,has,triggered,state,indexer,get,state,indexer,maybe,trigger,async,job,system,current,time,millis
RollupJobTask -> @Override     public synchronized void triggered(SchedulerEngine.Event event);1526467406;This is called by the ScheduleEngine when the cron triggers.__@param event The event that caused the trigger;@Override_    public synchronized void triggered(SchedulerEngine.Event event) {_        _        _        if (event.getJobName().equals(SCHEDULE_NAME + "_" + job.getConfig().getId())) {_            logger.debug("Rollup indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]")__            indexer.maybeTriggerAsyncJob(System.currentTimeMillis())__        }_    };this,is,called,by,the,schedule,engine,when,the,cron,triggers,param,event,the,event,that,caused,the,trigger;override,public,synchronized,void,triggered,scheduler,engine,event,event,if,event,get,job,name,equals,job,get,config,get,id,logger,debug,rollup,indexer,event,get,job,name,schedule,has,triggered,state,indexer,get,state,indexer,maybe,trigger,async,job,system,current,time,millis
RollupJobTask -> @Override     public synchronized void triggered(SchedulerEngine.Event event);1529076503;This is called by the ScheduleEngine when the cron triggers.__@param event The event that caused the trigger;@Override_    public synchronized void triggered(SchedulerEngine.Event event) {_        _        _        if (event.getJobName().equals(SCHEDULE_NAME + "_" + job.getConfig().getId())) {_            logger.debug("Rollup indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]")__            indexer.maybeTriggerAsyncJob(System.currentTimeMillis())__        }_    };this,is,called,by,the,schedule,engine,when,the,cron,triggers,param,event,the,event,that,caused,the,trigger;override,public,synchronized,void,triggered,scheduler,engine,event,event,if,event,get,job,name,equals,job,get,config,get,id,logger,debug,rollup,indexer,event,get,job,name,schedule,has,triggered,state,indexer,get,state,indexer,maybe,trigger,async,job,system,current,time,millis
RollupJobTask -> @Override     public synchronized void triggered(SchedulerEngine.Event event);1533319589;This is called by the ScheduleEngine when the cron triggers.__@param event The event that caused the trigger;@Override_    public synchronized void triggered(SchedulerEngine.Event event) {_        _        _        if (event.getJobName().equals(SCHEDULE_NAME + "_" + job.getConfig().getId())) {_            logger.debug("Rollup indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]")__            indexer.maybeTriggerAsyncJob(System.currentTimeMillis())__        }_    };this,is,called,by,the,schedule,engine,when,the,cron,triggers,param,event,the,event,that,caused,the,trigger;override,public,synchronized,void,triggered,scheduler,engine,event,event,if,event,get,job,name,equals,job,get,config,get,id,logger,debug,rollup,indexer,event,get,job,name,schedule,has,triggered,state,indexer,get,state,indexer,maybe,trigger,async,job,system,current,time,millis
RollupJobTask -> @Override     public synchronized void triggered(SchedulerEngine.Event event);1535666657;This is called by the ScheduleEngine when the cron triggers.__@param event The event that caused the trigger;@Override_    public synchronized void triggered(SchedulerEngine.Event event) {_        _        _        if (event.getJobName().equals(SCHEDULE_NAME + "_" + job.getConfig().getId())) {_            logger.debug("Rollup indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]")__            indexer.maybeTriggerAsyncJob(System.currentTimeMillis())__        }_    };this,is,called,by,the,schedule,engine,when,the,cron,triggers,param,event,the,event,that,caused,the,trigger;override,public,synchronized,void,triggered,scheduler,engine,event,event,if,event,get,job,name,equals,job,get,config,get,id,logger,debug,rollup,indexer,event,get,job,name,schedule,has,triggered,state,indexer,get,state,indexer,maybe,trigger,async,job,system,current,time,millis
RollupJobTask -> @Override     public synchronized void triggered(SchedulerEngine.Event event);1539615817;This is called by the ScheduleEngine when the cron triggers.__@param event The event that caused the trigger;@Override_    public synchronized void triggered(SchedulerEngine.Event event) {_        _        _        if (event.getJobName().equals(SCHEDULE_NAME + "_" + job.getConfig().getId())) {_            logger.debug("Rollup indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]")__            indexer.maybeTriggerAsyncJob(System.currentTimeMillis())__        }_    };this,is,called,by,the,schedule,engine,when,the,cron,triggers,param,event,the,event,that,caused,the,trigger;override,public,synchronized,void,triggered,scheduler,engine,event,event,if,event,get,job,name,equals,job,get,config,get,id,logger,debug,rollup,indexer,event,get,job,name,schedule,has,triggered,state,indexer,get,state,indexer,maybe,trigger,async,job,system,current,time,millis
RollupJobTask -> @Override     public synchronized void triggered(SchedulerEngine.Event event);1540313026;This is called by the ScheduleEngine when the cron triggers.__@param event The event that caused the trigger;@Override_    public synchronized void triggered(SchedulerEngine.Event event) {_        _        _        if (event.getJobName().equals(SCHEDULE_NAME + "_" + job.getConfig().getId())) {_            logger.debug("Rollup indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]")__            indexer.maybeTriggerAsyncJob(System.currentTimeMillis())__        }_    };this,is,called,by,the,schedule,engine,when,the,cron,triggers,param,event,the,event,that,caused,the,trigger;override,public,synchronized,void,triggered,scheduler,engine,event,event,if,event,get,job,name,equals,job,get,config,get,id,logger,debug,rollup,indexer,event,get,job,name,schedule,has,triggered,state,indexer,get,state,indexer,maybe,trigger,async,job,system,current,time,millis
RollupJobTask -> @Override     public synchronized void triggered(SchedulerEngine.Event event);1541092382;This is called by the ScheduleEngine when the cron triggers.__@param event The event that caused the trigger;@Override_    public synchronized void triggered(SchedulerEngine.Event event) {_        _        _        if (event.getJobName().equals(SCHEDULE_NAME + "_" + job.getConfig().getId())) {_            logger.debug("Rollup indexer [" + event.getJobName() + "] schedule has triggered, state: [" + indexer.getState() + "]")__            indexer.maybeTriggerAsyncJob(System.currentTimeMillis())__        }_    };this,is,called,by,the,schedule,engine,when,the,cron,triggers,param,event,the,event,that,caused,the,trigger;override,public,synchronized,void,triggered,scheduler,engine,event,event,if,event,get,job,name,equals,job,get,config,get,id,logger,debug,rollup,indexer,event,get,job,name,schedule,has,triggered,state,indexer,get,state,indexer,maybe,trigger,async,job,system,current,time,millis
RollupJobTask -> @Override     public synchronized void onCancelled();1540313026;This is called when the persistent task signals that the allocated task should be terminated._Termination in the task framework is essentially voluntary, as the allocated task can only be_shut down from the inside.;@Override_    public synchronized void onCancelled() {_        logger.info("Received cancellation request for Rollup job [" + job.getConfig().getId() + "], state: [" + indexer.getState() + "]")__        if (indexer.abort()) {_            _            shutdown()__        }_    };this,is,called,when,the,persistent,task,signals,that,the,allocated,task,should,be,terminated,termination,in,the,task,framework,is,essentially,voluntary,as,the,allocated,task,can,only,be,shut,down,from,the,inside;override,public,synchronized,void,on,cancelled,logger,info,received,cancellation,request,for,rollup,job,job,get,config,get,id,state,indexer,get,state,if,indexer,abort,shutdown
RollupJobTask -> @Override     public synchronized void onCancelled();1541092382;This is called when the persistent task signals that the allocated task should be terminated._Termination in the task framework is essentially voluntary, as the allocated task can only be_shut down from the inside.;@Override_    public synchronized void onCancelled() {_        logger.info("Received cancellation request for Rollup job [" + job.getConfig().getId() + "], state: [" + indexer.getState() + "]")__        if (indexer.abort()) {_            _            shutdown()__        }_    };this,is,called,when,the,persistent,task,signals,that,the,allocated,task,should,be,terminated,termination,in,the,task,framework,is,essentially,voluntary,as,the,allocated,task,can,only,be,shut,down,from,the,inside;override,public,synchronized,void,on,cancelled,logger,info,received,cancellation,request,for,rollup,job,job,get,config,get,id,state,indexer,get,state,if,indexer,abort,shutdown
RollupJobTask -> public synchronized void start(ActionListener<StartRollupJobAction.Response> listener);1524684173;Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail._Otherwise, the persistent task's status will be updated to reflect the change.__Note that while the job is started, the indexer will not necessarily run immediately.  That_will only occur when the scheduler triggers it based on the cron__@param listener The listener that started the action, so that we can signal completion/failure;public synchronized void start(ActionListener<StartRollupJobAction.Response> listener) {_        final IndexerState prevState = indexer.getState()__        if (prevState != IndexerState.STOPPED) {_            _            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + prevState + "]"))__            return__        }_        final IndexerState newState = indexer.start()__        if (newState != IndexerState.STARTED) {_            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + newState + "]"))__            return__        }_        final RollupJobStatus status = new RollupJobStatus(IndexerState.STARTED, indexer.getPosition())__        logger.debug("Updating status for rollup job [" + job.getConfig().getId() + "] to [" + status.getState() + "][" +_                status.getPosition() + "]")__        updatePersistentStatus(status,_                ActionListener.wrap(_                        (task) -> {_                            logger.debug("Succesfully updated status for rollup job [" + job.getConfig().getId() + "] to ["_                                    + status.getState() + "][" + status.getPosition() + "]")__                            listener.onResponse(new StartRollupJobAction.Response(true))__                        },_                        (exc) -> {_                            listener.onFailure(_                                    new ElasticsearchException("Error while updating status for rollup job [" + job.getConfig().getId()_                                            + "] to [" + status.getState() + "].", exc)_                            )__                        }_                )_        )__    };attempt,to,start,the,indexer,if,the,state,is,anything,other,than,stopped,this,will,fail,otherwise,the,persistent,task,s,status,will,be,updated,to,reflect,the,change,note,that,while,the,job,is,started,the,indexer,will,not,necessarily,run,immediately,that,will,only,occur,when,the,scheduler,triggers,it,based,on,the,cron,param,listener,the,listener,that,started,the,action,so,that,we,can,signal,completion,failure;public,synchronized,void,start,action,listener,start,rollup,job,action,response,listener,final,indexer,state,prev,state,indexer,get,state,if,prev,state,indexer,state,stopped,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,prev,state,return,final,indexer,state,new,state,indexer,start,if,new,state,indexer,state,started,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,return,final,rollup,job,status,status,new,rollup,job,status,indexer,state,started,indexer,get,position,logger,debug,updating,status,for,rollup,job,job,get,config,get,id,to,status,get,state,status,get,position,update,persistent,status,status,action,listener,wrap,task,logger,debug,succesfully,updated,status,for,rollup,job,job,get,config,get,id,to,status,get,state,status,get,position,listener,on,response,new,start,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,status,for,rollup,job,job,get,config,get,id,to,status,get,state,exc
RollupJobTask -> public synchronized void start(ActionListener<StartRollupJobAction.Response> listener);1526467406;Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail._Otherwise, the persistent task's status will be updated to reflect the change.__Note that while the job is started, the indexer will not necessarily run immediately.  That_will only occur when the scheduler triggers it based on the cron__@param listener The listener that started the action, so that we can signal completion/failure;public synchronized void start(ActionListener<StartRollupJobAction.Response> listener) {_        final IndexerState prevState = indexer.getState()__        if (prevState != IndexerState.STOPPED) {_            _            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + prevState + "]"))__            return__        }_        final IndexerState newState = indexer.start()__        if (newState != IndexerState.STARTED) {_            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + newState + "]"))__            return__        }_        final RollupJobStatus status = new RollupJobStatus(IndexerState.STARTED, indexer.getPosition())__        logger.debug("Updating status for rollup job [" + job.getConfig().getId() + "] to [" + status.getState() + "][" +_                status.getPosition() + "]")__        updatePersistentStatus(status,_                ActionListener.wrap(_                        (task) -> {_                            logger.debug("Succesfully updated status for rollup job [" + job.getConfig().getId() + "] to ["_                                    + status.getState() + "][" + status.getPosition() + "]")__                            listener.onResponse(new StartRollupJobAction.Response(true))__                        },_                        (exc) -> {_                            listener.onFailure(_                                    new ElasticsearchException("Error while updating status for rollup job [" + job.getConfig().getId()_                                            + "] to [" + status.getState() + "].", exc)_                            )__                        }_                )_        )__    };attempt,to,start,the,indexer,if,the,state,is,anything,other,than,stopped,this,will,fail,otherwise,the,persistent,task,s,status,will,be,updated,to,reflect,the,change,note,that,while,the,job,is,started,the,indexer,will,not,necessarily,run,immediately,that,will,only,occur,when,the,scheduler,triggers,it,based,on,the,cron,param,listener,the,listener,that,started,the,action,so,that,we,can,signal,completion,failure;public,synchronized,void,start,action,listener,start,rollup,job,action,response,listener,final,indexer,state,prev,state,indexer,get,state,if,prev,state,indexer,state,stopped,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,prev,state,return,final,indexer,state,new,state,indexer,start,if,new,state,indexer,state,started,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,return,final,rollup,job,status,status,new,rollup,job,status,indexer,state,started,indexer,get,position,logger,debug,updating,status,for,rollup,job,job,get,config,get,id,to,status,get,state,status,get,position,update,persistent,status,status,action,listener,wrap,task,logger,debug,succesfully,updated,status,for,rollup,job,job,get,config,get,id,to,status,get,state,status,get,position,listener,on,response,new,start,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,status,for,rollup,job,job,get,config,get,id,to,status,get,state,exc
RollupJobTask -> public synchronized void start(ActionListener<StartRollupJobAction.Response> listener);1529076503;Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail._Otherwise, the persistent task's status will be updated to reflect the change.__Note that while the job is started, the indexer will not necessarily run immediately.  That_will only occur when the scheduler triggers it based on the cron__@param listener The listener that started the action, so that we can signal completion/failure;public synchronized void start(ActionListener<StartRollupJobAction.Response> listener) {_        final IndexerState prevState = indexer.getState()__        if (prevState != IndexerState.STOPPED) {_            _            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + prevState + "]"))__            return__        }_        final IndexerState newState = indexer.start()__        if (newState != IndexerState.STARTED) {_            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + newState + "]"))__            return__        }_        final RollupJobStatus state = new RollupJobStatus(IndexerState.STARTED, indexer.getPosition())__        logger.debug("Updating state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "][" +_                state.getPosition() + "]")__        updatePersistentTaskState(state,_                ActionListener.wrap(_                        (task) -> {_                            logger.debug("Succesfully updated state for rollup job [" + job.getConfig().getId() + "] to ["_                                    + state.getIndexerState() + "][" + state.getPosition() + "]")__                            listener.onResponse(new StartRollupJobAction.Response(true))__                        },_                        (exc) -> {_                            listener.onFailure(_                                    new ElasticsearchException("Error while updating state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "].", exc)_                            )__                        }_                )_        )__    };attempt,to,start,the,indexer,if,the,state,is,anything,other,than,stopped,this,will,fail,otherwise,the,persistent,task,s,status,will,be,updated,to,reflect,the,change,note,that,while,the,job,is,started,the,indexer,will,not,necessarily,run,immediately,that,will,only,occur,when,the,scheduler,triggers,it,based,on,the,cron,param,listener,the,listener,that,started,the,action,so,that,we,can,signal,completion,failure;public,synchronized,void,start,action,listener,start,rollup,job,action,response,listener,final,indexer,state,prev,state,indexer,get,state,if,prev,state,indexer,state,stopped,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,prev,state,return,final,indexer,state,new,state,indexer,start,if,new,state,indexer,state,started,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,return,final,rollup,job,status,state,new,rollup,job,status,indexer,state,started,indexer,get,position,logger,debug,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,succesfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,listener,on,response,new,start,rollup,job,action,response,true,exc,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc
RollupJobTask -> public synchronized void start(ActionListener<StartRollupJobAction.Response> listener);1533319589;Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail._Otherwise, the persistent task's status will be updated to reflect the change.__Note that while the job is started, the indexer will not necessarily run immediately.  That_will only occur when the scheduler triggers it based on the cron__@param listener The listener that started the action, so that we can signal completion/failure;public synchronized void start(ActionListener<StartRollupJobAction.Response> listener) {_        final IndexerState prevState = indexer.getState()__        if (prevState != IndexerState.STOPPED) {_            _            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + prevState + "]"))__            return__        }__        final IndexerState newState = indexer.start()__        if (newState != IndexerState.STARTED) {_            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + newState + "]"))__            return__        }___        final RollupJobStatus state = new RollupJobStatus(IndexerState.STARTED, indexer.getPosition(), upgradedDocumentID.get())__        logger.debug("Updating state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "][" +_                state.getPosition() + "]")__        updatePersistentTaskState(state,_                ActionListener.wrap(_                        (task) -> {_                            logger.debug("Succesfully updated state for rollup job [" + job.getConfig().getId() + "] to ["_                                    + state.getIndexerState() + "][" + state.getPosition() + "]")__                            listener.onResponse(new StartRollupJobAction.Response(true))__                        },_                        (exc) -> {_                            _                            indexer.stop()__                            listener.onFailure(_                                    new ElasticsearchException("Error while updating state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "].", exc)_                            )__                        }_                )_        )__    };attempt,to,start,the,indexer,if,the,state,is,anything,other,than,stopped,this,will,fail,otherwise,the,persistent,task,s,status,will,be,updated,to,reflect,the,change,note,that,while,the,job,is,started,the,indexer,will,not,necessarily,run,immediately,that,will,only,occur,when,the,scheduler,triggers,it,based,on,the,cron,param,listener,the,listener,that,started,the,action,so,that,we,can,signal,completion,failure;public,synchronized,void,start,action,listener,start,rollup,job,action,response,listener,final,indexer,state,prev,state,indexer,get,state,if,prev,state,indexer,state,stopped,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,prev,state,return,final,indexer,state,new,state,indexer,start,if,new,state,indexer,state,started,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,return,final,rollup,job,status,state,new,rollup,job,status,indexer,state,started,indexer,get,position,upgraded,document,id,get,logger,debug,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,succesfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,listener,on,response,new,start,rollup,job,action,response,true,exc,indexer,stop,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc
RollupJobTask -> public synchronized void start(ActionListener<StartRollupJobAction.Response> listener);1535666657;Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail._Otherwise, the persistent task's status will be updated to reflect the change.__Note that while the job is started, the indexer will not necessarily run immediately.  That_will only occur when the scheduler triggers it based on the cron__@param listener The listener that started the action, so that we can signal completion/failure;public synchronized void start(ActionListener<StartRollupJobAction.Response> listener) {_        final IndexerState prevState = indexer.getState()__        if (prevState != IndexerState.STOPPED) {_            _            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + prevState + "]"))__            return__        }__        final IndexerState newState = indexer.start()__        if (newState != IndexerState.STARTED) {_            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + newState + "]"))__            return__        }___        final RollupJobStatus state = new RollupJobStatus(IndexerState.STARTED, indexer.getPosition(), upgradedDocumentID.get())__        logger.debug("Updating state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "][" +_                state.getPosition() + "]")__        updatePersistentTaskState(state,_                ActionListener.wrap(_                        (task) -> {_                            logger.debug("Succesfully updated state for rollup job [" + job.getConfig().getId() + "] to ["_                                    + state.getIndexerState() + "][" + state.getPosition() + "]")__                            listener.onResponse(new StartRollupJobAction.Response(true))__                        },_                        (exc) -> {_                            _                            indexer.stop()__                            listener.onFailure(_                                    new ElasticsearchException("Error while updating state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "].", exc)_                            )__                        }_                )_        )__    };attempt,to,start,the,indexer,if,the,state,is,anything,other,than,stopped,this,will,fail,otherwise,the,persistent,task,s,status,will,be,updated,to,reflect,the,change,note,that,while,the,job,is,started,the,indexer,will,not,necessarily,run,immediately,that,will,only,occur,when,the,scheduler,triggers,it,based,on,the,cron,param,listener,the,listener,that,started,the,action,so,that,we,can,signal,completion,failure;public,synchronized,void,start,action,listener,start,rollup,job,action,response,listener,final,indexer,state,prev,state,indexer,get,state,if,prev,state,indexer,state,stopped,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,prev,state,return,final,indexer,state,new,state,indexer,start,if,new,state,indexer,state,started,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,return,final,rollup,job,status,state,new,rollup,job,status,indexer,state,started,indexer,get,position,upgraded,document,id,get,logger,debug,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,succesfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,listener,on,response,new,start,rollup,job,action,response,true,exc,indexer,stop,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc
RollupJobTask -> public synchronized void start(ActionListener<StartRollupJobAction.Response> listener);1539615817;Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail._Otherwise, the persistent task's status will be updated to reflect the change.__Note that while the job is started, the indexer will not necessarily run immediately.  That_will only occur when the scheduler triggers it based on the cron__@param listener The listener that started the action, so that we can signal completion/failure;public synchronized void start(ActionListener<StartRollupJobAction.Response> listener) {_        final IndexerState prevState = indexer.getState()__        if (prevState != IndexerState.STOPPED) {_            _            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + prevState + "]"))__            return__        }__        final IndexerState newState = indexer.start()__        if (newState != IndexerState.STARTED) {_            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + newState + "]"))__            return__        }___        final RollupJobStatus state = new RollupJobStatus(IndexerState.STARTED, indexer.getPosition(), upgradedDocumentID.get())__        logger.debug("Updating state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "][" +_                state.getPosition() + "]")__        updatePersistentTaskState(state,_                ActionListener.wrap(_                        (task) -> {_                            logger.debug("Successfully updated state for rollup job [" + job.getConfig().getId() + "] to ["_                                    + state.getIndexerState() + "][" + state.getPosition() + "]")__                            listener.onResponse(new StartRollupJobAction.Response(true))__                        },_                        (exc) -> {_                            _                            indexer.stop()__                            listener.onFailure(_                                    new ElasticsearchException("Error while updating state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "].", exc)_                            )__                        }_                )_        )__    };attempt,to,start,the,indexer,if,the,state,is,anything,other,than,stopped,this,will,fail,otherwise,the,persistent,task,s,status,will,be,updated,to,reflect,the,change,note,that,while,the,job,is,started,the,indexer,will,not,necessarily,run,immediately,that,will,only,occur,when,the,scheduler,triggers,it,based,on,the,cron,param,listener,the,listener,that,started,the,action,so,that,we,can,signal,completion,failure;public,synchronized,void,start,action,listener,start,rollup,job,action,response,listener,final,indexer,state,prev,state,indexer,get,state,if,prev,state,indexer,state,stopped,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,prev,state,return,final,indexer,state,new,state,indexer,start,if,new,state,indexer,state,started,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,return,final,rollup,job,status,state,new,rollup,job,status,indexer,state,started,indexer,get,position,upgraded,document,id,get,logger,debug,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,successfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,listener,on,response,new,start,rollup,job,action,response,true,exc,indexer,stop,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc
RollupJobTask -> public synchronized void start(ActionListener<StartRollupJobAction.Response> listener);1540313026;Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail._Otherwise, the persistent task's status will be updated to reflect the change.__Note that while the job is started, the indexer will not necessarily run immediately.  That_will only occur when the scheduler triggers it based on the cron__@param listener The listener that started the action, so that we can signal completion/failure;public synchronized void start(ActionListener<StartRollupJobAction.Response> listener) {_        final IndexerState prevState = indexer.getState()__        if (prevState != IndexerState.STOPPED) {_            _            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + prevState + "]"))__            return__        }__        final IndexerState newState = indexer.start()__        if (newState != IndexerState.STARTED) {_            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + newState + "]"))__            return__        }___        final RollupJobStatus state = new RollupJobStatus(IndexerState.STARTED, indexer.getPosition(), upgradedDocumentID.get())__        logger.debug("Updating state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "][" +_                state.getPosition() + "]")__        updatePersistentTaskState(state,_                ActionListener.wrap(_                        (task) -> {_                            logger.debug("Successfully updated state for rollup job [" + job.getConfig().getId() + "] to ["_                                    + state.getIndexerState() + "][" + state.getPosition() + "]")__                            listener.onResponse(new StartRollupJobAction.Response(true))__                        },_                        (exc) -> {_                            _                            indexer.stop()__                            listener.onFailure(_                                    new ElasticsearchException("Error while updating state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "].", exc)_                            )__                        }_                )_        )__    };attempt,to,start,the,indexer,if,the,state,is,anything,other,than,stopped,this,will,fail,otherwise,the,persistent,task,s,status,will,be,updated,to,reflect,the,change,note,that,while,the,job,is,started,the,indexer,will,not,necessarily,run,immediately,that,will,only,occur,when,the,scheduler,triggers,it,based,on,the,cron,param,listener,the,listener,that,started,the,action,so,that,we,can,signal,completion,failure;public,synchronized,void,start,action,listener,start,rollup,job,action,response,listener,final,indexer,state,prev,state,indexer,get,state,if,prev,state,indexer,state,stopped,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,prev,state,return,final,indexer,state,new,state,indexer,start,if,new,state,indexer,state,started,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,return,final,rollup,job,status,state,new,rollup,job,status,indexer,state,started,indexer,get,position,upgraded,document,id,get,logger,debug,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,successfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,listener,on,response,new,start,rollup,job,action,response,true,exc,indexer,stop,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc
RollupJobTask -> public synchronized void start(ActionListener<StartRollupJobAction.Response> listener);1541092382;Attempt to start the indexer.  If the state is anything other than STOPPED, this will fail._Otherwise, the persistent task's status will be updated to reflect the change.__Note that while the job is started, the indexer will not necessarily run immediately.  That_will only occur when the scheduler triggers it based on the cron__@param listener The listener that started the action, so that we can signal completion/failure;public synchronized void start(ActionListener<StartRollupJobAction.Response> listener) {_        final IndexerState prevState = indexer.getState()__        if (prevState != IndexerState.STOPPED) {_            _            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + prevState + "]"))__            return__        }__        final IndexerState newState = indexer.start()__        if (newState != IndexerState.STARTED) {_            listener.onFailure(new ElasticsearchException("Cannot start task for Rollup Job [" + job.getConfig().getId() + "] because"_                    + " state was [" + newState + "]"))__            return__        }___        final RollupJobStatus state = new RollupJobStatus(IndexerState.STARTED, indexer.getPosition(), upgradedDocumentID.get())__        logger.debug("Updating state for rollup job [" + job.getConfig().getId() + "] to [" + state.getIndexerState() + "][" +_                state.getPosition() + "]")__        updatePersistentTaskState(state,_                ActionListener.wrap(_                        (task) -> {_                            logger.debug("Successfully updated state for rollup job [" + job.getConfig().getId() + "] to ["_                                    + state.getIndexerState() + "][" + state.getPosition() + "]")__                            listener.onResponse(new StartRollupJobAction.Response(true))__                        },_                        (exc) -> {_                            _                            indexer.stop()__                            listener.onFailure(_                                    new ElasticsearchException("Error while updating state for rollup job [" + job.getConfig().getId()_                                            + "] to [" + state.getIndexerState() + "].", exc)_                            )__                        }_                )_        )__    };attempt,to,start,the,indexer,if,the,state,is,anything,other,than,stopped,this,will,fail,otherwise,the,persistent,task,s,status,will,be,updated,to,reflect,the,change,note,that,while,the,job,is,started,the,indexer,will,not,necessarily,run,immediately,that,will,only,occur,when,the,scheduler,triggers,it,based,on,the,cron,param,listener,the,listener,that,started,the,action,so,that,we,can,signal,completion,failure;public,synchronized,void,start,action,listener,start,rollup,job,action,response,listener,final,indexer,state,prev,state,indexer,get,state,if,prev,state,indexer,state,stopped,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,prev,state,return,final,indexer,state,new,state,indexer,start,if,new,state,indexer,state,started,listener,on,failure,new,elasticsearch,exception,cannot,start,task,for,rollup,job,job,get,config,get,id,because,state,was,new,state,return,final,rollup,job,status,state,new,rollup,job,status,indexer,state,started,indexer,get,position,upgraded,document,id,get,logger,debug,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,update,persistent,task,state,state,action,listener,wrap,task,logger,debug,successfully,updated,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,state,get,position,listener,on,response,new,start,rollup,job,action,response,true,exc,indexer,stop,listener,on,failure,new,elasticsearch,exception,error,while,updating,state,for,rollup,job,job,get,config,get,id,to,state,get,indexer,state,exc
RollupJobTask -> synchronized void shutdown();1524684173;Attempt to gracefully cleanup the rollup job so it can be terminated._This tries to remove the job from the scheduler, and potentially any other_cleanup operations in the future;synchronized void shutdown() {_        try {_            logger.info("Rollup indexer [" + job.getConfig().getId() + "] received abort request, stopping indexer.")__            schedulerEngine.remove(SCHEDULE_NAME + "_" + job.getConfig().getId())__            schedulerEngine.unregister(this)__        } catch (Exception e) {_            markAsFailed(e)__            return__        }_        markAsCompleted()__    };attempt,to,gracefully,cleanup,the,rollup,job,so,it,can,be,terminated,this,tries,to,remove,the,job,from,the,scheduler,and,potentially,any,other,cleanup,operations,in,the,future;synchronized,void,shutdown,try,logger,info,rollup,indexer,job,get,config,get,id,received,abort,request,stopping,indexer,scheduler,engine,remove,job,get,config,get,id,scheduler,engine,unregister,this,catch,exception,e,mark,as,failed,e,return,mark,as,completed
RollupJobTask -> synchronized void shutdown();1526467406;Attempt to gracefully cleanup the rollup job so it can be terminated._This tries to remove the job from the scheduler, and potentially any other_cleanup operations in the future;synchronized void shutdown() {_        try {_            logger.info("Rollup indexer [" + job.getConfig().getId() + "] received abort request, stopping indexer.")__            schedulerEngine.remove(SCHEDULE_NAME + "_" + job.getConfig().getId())__            schedulerEngine.unregister(this)__        } catch (Exception e) {_            markAsFailed(e)__            return__        }_        markAsCompleted()__    };attempt,to,gracefully,cleanup,the,rollup,job,so,it,can,be,terminated,this,tries,to,remove,the,job,from,the,scheduler,and,potentially,any,other,cleanup,operations,in,the,future;synchronized,void,shutdown,try,logger,info,rollup,indexer,job,get,config,get,id,received,abort,request,stopping,indexer,scheduler,engine,remove,job,get,config,get,id,scheduler,engine,unregister,this,catch,exception,e,mark,as,failed,e,return,mark,as,completed
RollupJobTask -> synchronized void shutdown();1529076503;Attempt to gracefully cleanup the rollup job so it can be terminated._This tries to remove the job from the scheduler, and potentially any other_cleanup operations in the future;synchronized void shutdown() {_        try {_            logger.info("Rollup indexer [" + job.getConfig().getId() + "] received abort request, stopping indexer.")__            schedulerEngine.remove(SCHEDULE_NAME + "_" + job.getConfig().getId())__            schedulerEngine.unregister(this)__        } catch (Exception e) {_            markAsFailed(e)__            return__        }_        markAsCompleted()__    };attempt,to,gracefully,cleanup,the,rollup,job,so,it,can,be,terminated,this,tries,to,remove,the,job,from,the,scheduler,and,potentially,any,other,cleanup,operations,in,the,future;synchronized,void,shutdown,try,logger,info,rollup,indexer,job,get,config,get,id,received,abort,request,stopping,indexer,scheduler,engine,remove,job,get,config,get,id,scheduler,engine,unregister,this,catch,exception,e,mark,as,failed,e,return,mark,as,completed
RollupJobTask -> synchronized void shutdown();1533319589;Attempt to gracefully cleanup the rollup job so it can be terminated._This tries to remove the job from the scheduler, and potentially any other_cleanup operations in the future;synchronized void shutdown() {_        try {_            logger.info("Rollup indexer [" + job.getConfig().getId() + "] received abort request, stopping indexer.")__            schedulerEngine.remove(SCHEDULE_NAME + "_" + job.getConfig().getId())__            schedulerEngine.unregister(this)__        } catch (Exception e) {_            markAsFailed(e)__            return__        }_        markAsCompleted()__    };attempt,to,gracefully,cleanup,the,rollup,job,so,it,can,be,terminated,this,tries,to,remove,the,job,from,the,scheduler,and,potentially,any,other,cleanup,operations,in,the,future;synchronized,void,shutdown,try,logger,info,rollup,indexer,job,get,config,get,id,received,abort,request,stopping,indexer,scheduler,engine,remove,job,get,config,get,id,scheduler,engine,unregister,this,catch,exception,e,mark,as,failed,e,return,mark,as,completed
RollupJobTask -> synchronized void shutdown();1535666657;Attempt to gracefully cleanup the rollup job so it can be terminated._This tries to remove the job from the scheduler, and potentially any other_cleanup operations in the future;synchronized void shutdown() {_        try {_            logger.info("Rollup indexer [" + job.getConfig().getId() + "] received abort request, stopping indexer.")__            schedulerEngine.remove(SCHEDULE_NAME + "_" + job.getConfig().getId())__            schedulerEngine.unregister(this)__        } catch (Exception e) {_            markAsFailed(e)__            return__        }_        markAsCompleted()__    };attempt,to,gracefully,cleanup,the,rollup,job,so,it,can,be,terminated,this,tries,to,remove,the,job,from,the,scheduler,and,potentially,any,other,cleanup,operations,in,the,future;synchronized,void,shutdown,try,logger,info,rollup,indexer,job,get,config,get,id,received,abort,request,stopping,indexer,scheduler,engine,remove,job,get,config,get,id,scheduler,engine,unregister,this,catch,exception,e,mark,as,failed,e,return,mark,as,completed
RollupJobTask -> synchronized void shutdown();1539615817;Attempt to gracefully cleanup the rollup job so it can be terminated._This tries to remove the job from the scheduler, and potentially any other_cleanup operations in the future;synchronized void shutdown() {_        try {_            logger.info("Rollup indexer [" + job.getConfig().getId() + "] received abort request, stopping indexer.")__            schedulerEngine.remove(SCHEDULE_NAME + "_" + job.getConfig().getId())__            schedulerEngine.unregister(this)__        } catch (Exception e) {_            markAsFailed(e)__            return__        }_        markAsCompleted()__    };attempt,to,gracefully,cleanup,the,rollup,job,so,it,can,be,terminated,this,tries,to,remove,the,job,from,the,scheduler,and,potentially,any,other,cleanup,operations,in,the,future;synchronized,void,shutdown,try,logger,info,rollup,indexer,job,get,config,get,id,received,abort,request,stopping,indexer,scheduler,engine,remove,job,get,config,get,id,scheduler,engine,unregister,this,catch,exception,e,mark,as,failed,e,return,mark,as,completed
RollupJobTask -> synchronized void shutdown();1540313026;Attempt to gracefully cleanup the rollup job so it can be terminated._This tries to remove the job from the scheduler, and potentially any other_cleanup operations in the future;synchronized void shutdown() {_        try {_            logger.info("Rollup indexer [" + job.getConfig().getId() + "] received abort request, stopping indexer.")__            schedulerEngine.remove(SCHEDULE_NAME + "_" + job.getConfig().getId())__            schedulerEngine.unregister(this)__        } catch (Exception e) {_            markAsFailed(e)__            return__        }_        markAsCompleted()__    };attempt,to,gracefully,cleanup,the,rollup,job,so,it,can,be,terminated,this,tries,to,remove,the,job,from,the,scheduler,and,potentially,any,other,cleanup,operations,in,the,future;synchronized,void,shutdown,try,logger,info,rollup,indexer,job,get,config,get,id,received,abort,request,stopping,indexer,scheduler,engine,remove,job,get,config,get,id,scheduler,engine,unregister,this,catch,exception,e,mark,as,failed,e,return,mark,as,completed
RollupJobTask -> synchronized void shutdown();1541092382;Attempt to gracefully cleanup the rollup job so it can be terminated._This tries to remove the job from the scheduler, and potentially any other_cleanup operations in the future;synchronized void shutdown() {_        try {_            logger.info("Rollup indexer [" + job.getConfig().getId() + "] received abort request, stopping indexer.")__            schedulerEngine.remove(SCHEDULE_NAME + "_" + job.getConfig().getId())__            schedulerEngine.unregister(this)__        } catch (Exception e) {_            markAsFailed(e)__            return__        }_        markAsCompleted()__    };attempt,to,gracefully,cleanup,the,rollup,job,so,it,can,be,terminated,this,tries,to,remove,the,job,from,the,scheduler,and,potentially,any,other,cleanup,operations,in,the,future;synchronized,void,shutdown,try,logger,info,rollup,indexer,job,get,config,get,id,received,abort,request,stopping,indexer,scheduler,engine,remove,job,get,config,get,id,scheduler,engine,unregister,this,catch,exception,e,mark,as,failed,e,return,mark,as,completed
RollupJobTask -> @Override     protected synchronized void onCancelled();1524684173;This is called when the persistent task signals that the allocated task should be terminated._Termination in the task framework is essentially voluntary, as the allocated task can only be_shut down from the inside.;@Override_    protected synchronized void onCancelled() {_        logger.info("Received cancellation request for Rollup job [" + job.getConfig().getId() + "], state: [" + indexer.getState() + "]")__        if (indexer.abort()) {_            _            shutdown()__        }_    };this,is,called,when,the,persistent,task,signals,that,the,allocated,task,should,be,terminated,termination,in,the,task,framework,is,essentially,voluntary,as,the,allocated,task,can,only,be,shut,down,from,the,inside;override,protected,synchronized,void,on,cancelled,logger,info,received,cancellation,request,for,rollup,job,job,get,config,get,id,state,indexer,get,state,if,indexer,abort,shutdown
RollupJobTask -> @Override     protected synchronized void onCancelled();1526467406;This is called when the persistent task signals that the allocated task should be terminated._Termination in the task framework is essentially voluntary, as the allocated task can only be_shut down from the inside.;@Override_    protected synchronized void onCancelled() {_        logger.info("Received cancellation request for Rollup job [" + job.getConfig().getId() + "], state: [" + indexer.getState() + "]")__        if (indexer.abort()) {_            _            shutdown()__        }_    };this,is,called,when,the,persistent,task,signals,that,the,allocated,task,should,be,terminated,termination,in,the,task,framework,is,essentially,voluntary,as,the,allocated,task,can,only,be,shut,down,from,the,inside;override,protected,synchronized,void,on,cancelled,logger,info,received,cancellation,request,for,rollup,job,job,get,config,get,id,state,indexer,get,state,if,indexer,abort,shutdown
RollupJobTask -> @Override     protected synchronized void onCancelled();1529076503;This is called when the persistent task signals that the allocated task should be terminated._Termination in the task framework is essentially voluntary, as the allocated task can only be_shut down from the inside.;@Override_    protected synchronized void onCancelled() {_        logger.info("Received cancellation request for Rollup job [" + job.getConfig().getId() + "], state: [" + indexer.getState() + "]")__        if (indexer.abort()) {_            _            shutdown()__        }_    };this,is,called,when,the,persistent,task,signals,that,the,allocated,task,should,be,terminated,termination,in,the,task,framework,is,essentially,voluntary,as,the,allocated,task,can,only,be,shut,down,from,the,inside;override,protected,synchronized,void,on,cancelled,logger,info,received,cancellation,request,for,rollup,job,job,get,config,get,id,state,indexer,get,state,if,indexer,abort,shutdown
RollupJobTask -> @Override     protected synchronized void onCancelled();1533319589;This is called when the persistent task signals that the allocated task should be terminated._Termination in the task framework is essentially voluntary, as the allocated task can only be_shut down from the inside.;@Override_    protected synchronized void onCancelled() {_        logger.info("Received cancellation request for Rollup job [" + job.getConfig().getId() + "], state: [" + indexer.getState() + "]")__        if (indexer.abort()) {_            _            shutdown()__        }_    };this,is,called,when,the,persistent,task,signals,that,the,allocated,task,should,be,terminated,termination,in,the,task,framework,is,essentially,voluntary,as,the,allocated,task,can,only,be,shut,down,from,the,inside;override,protected,synchronized,void,on,cancelled,logger,info,received,cancellation,request,for,rollup,job,job,get,config,get,id,state,indexer,get,state,if,indexer,abort,shutdown
RollupJobTask -> @Override     protected synchronized void onCancelled();1535666657;This is called when the persistent task signals that the allocated task should be terminated._Termination in the task framework is essentially voluntary, as the allocated task can only be_shut down from the inside.;@Override_    protected synchronized void onCancelled() {_        logger.info("Received cancellation request for Rollup job [" + job.getConfig().getId() + "], state: [" + indexer.getState() + "]")__        if (indexer.abort()) {_            _            shutdown()__        }_    };this,is,called,when,the,persistent,task,signals,that,the,allocated,task,should,be,terminated,termination,in,the,task,framework,is,essentially,voluntary,as,the,allocated,task,can,only,be,shut,down,from,the,inside;override,protected,synchronized,void,on,cancelled,logger,info,received,cancellation,request,for,rollup,job,job,get,config,get,id,state,indexer,get,state,if,indexer,abort,shutdown
RollupJobTask -> @Override     protected synchronized void onCancelled();1539615817;This is called when the persistent task signals that the allocated task should be terminated._Termination in the task framework is essentially voluntary, as the allocated task can only be_shut down from the inside.;@Override_    protected synchronized void onCancelled() {_        logger.info("Received cancellation request for Rollup job [" + job.getConfig().getId() + "], state: [" + indexer.getState() + "]")__        if (indexer.abort()) {_            _            shutdown()__        }_    };this,is,called,when,the,persistent,task,signals,that,the,allocated,task,should,be,terminated,termination,in,the,task,framework,is,essentially,voluntary,as,the,allocated,task,can,only,be,shut,down,from,the,inside;override,protected,synchronized,void,on,cancelled,logger,info,received,cancellation,request,for,rollup,job,job,get,config,get,id,state,indexer,get,state,if,indexer,abort,shutdown
RollupJobTask -> public RollupIndexerJobStats getStats();1535666657;Gets the stats for this task._@return The stats of this task;public RollupIndexerJobStats getStats() {_        return indexer.getStats()__    };gets,the,stats,for,this,task,return,the,stats,of,this,task;public,rollup,indexer,job,stats,get,stats,return,indexer,get,stats
RollupJobTask -> public RollupIndexerJobStats getStats();1539615817;Gets the stats for this task._@return The stats of this task;public RollupIndexerJobStats getStats() {_        return indexer.getStats()__    };gets,the,stats,for,this,task,return,the,stats,of,this,task;public,rollup,indexer,job,stats,get,stats,return,indexer,get,stats
RollupJobTask -> public RollupIndexerJobStats getStats();1540313026;Gets the stats for this task._@return The stats of this task;public RollupIndexerJobStats getStats() {_        return indexer.getStats()__    };gets,the,stats,for,this,task,return,the,stats,of,this,task;public,rollup,indexer,job,stats,get,stats,return,indexer,get,stats
RollupJobTask -> public RollupIndexerJobStats getStats();1541092382;Gets the stats for this task._@return The stats of this task;public RollupIndexerJobStats getStats() {_        return indexer.getStats()__    };gets,the,stats,for,this,task,return,the,stats,of,this,task;public,rollup,indexer,job,stats,get,stats,return,indexer,get,stats
RollupJobTask -> public RollupJobStats getStats();1524684173;Gets the stats for this task._@return The stats of this task;public RollupJobStats getStats() {_        return indexer.getStats()__    };gets,the,stats,for,this,task,return,the,stats,of,this,task;public,rollup,job,stats,get,stats,return,indexer,get,stats
RollupJobTask -> public RollupJobStats getStats();1526467406;Gets the stats for this task._@return The stats of this task;public RollupJobStats getStats() {_        return indexer.getStats()__    };gets,the,stats,for,this,task,return,the,stats,of,this,task;public,rollup,job,stats,get,stats,return,indexer,get,stats
RollupJobTask -> public RollupJobStats getStats();1529076503;Gets the stats for this task._@return The stats of this task;public RollupJobStats getStats() {_        return indexer.getStats()__    };gets,the,stats,for,this,task,return,the,stats,of,this,task;public,rollup,job,stats,get,stats,return,indexer,get,stats
RollupJobTask -> public RollupJobStats getStats();1533319589;Gets the stats for this task._@return The stats of this task;public RollupJobStats getStats() {_        return indexer.getStats()__    };gets,the,stats,for,this,task,return,the,stats,of,this,task;public,rollup,job,stats,get,stats,return,indexer,get,stats
RollupJobTask -> public RollupJobConfig getConfig();1524684173;The config of this task_@return The config for this task;public RollupJobConfig getConfig() {_        return job.getConfig()__    };the,config,of,this,task,return,the,config,for,this,task;public,rollup,job,config,get,config,return,job,get,config
RollupJobTask -> public RollupJobConfig getConfig();1526467406;The config of this task_@return The config for this task;public RollupJobConfig getConfig() {_        return job.getConfig()__    };the,config,of,this,task,return,the,config,for,this,task;public,rollup,job,config,get,config,return,job,get,config
RollupJobTask -> public RollupJobConfig getConfig();1529076503;The config of this task_@return The config for this task;public RollupJobConfig getConfig() {_        return job.getConfig()__    };the,config,of,this,task,return,the,config,for,this,task;public,rollup,job,config,get,config,return,job,get,config
RollupJobTask -> public RollupJobConfig getConfig();1533319589;The config of this task_@return The config for this task;public RollupJobConfig getConfig() {_        return job.getConfig()__    };the,config,of,this,task,return,the,config,for,this,task;public,rollup,job,config,get,config,return,job,get,config
RollupJobTask -> public RollupJobConfig getConfig();1535666657;The config of this task_@return The config for this task;public RollupJobConfig getConfig() {_        return job.getConfig()__    };the,config,of,this,task,return,the,config,for,this,task;public,rollup,job,config,get,config,return,job,get,config
RollupJobTask -> public RollupJobConfig getConfig();1539615817;The config of this task_@return The config for this task;public RollupJobConfig getConfig() {_        return job.getConfig()__    };the,config,of,this,task,return,the,config,for,this,task;public,rollup,job,config,get,config,return,job,get,config
RollupJobTask -> public RollupJobConfig getConfig();1540313026;The config of this task_@return The config for this task;public RollupJobConfig getConfig() {_        return job.getConfig()__    };the,config,of,this,task,return,the,config,for,this,task;public,rollup,job,config,get,config,return,job,get,config
RollupJobTask -> public RollupJobConfig getConfig();1541092382;The config of this task_@return The config for this task;public RollupJobConfig getConfig() {_        return job.getConfig()__    };the,config,of,this,task,return,the,config,for,this,task;public,rollup,job,config,get,config,return,job,get,config
