commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;26;;@Override protected void doExecute(Task task, GetRollupJobsAction.Request request, ActionListener<GetRollupJobsAction.Response> listener) {     final ClusterState state = clusterService.state().     final DiscoveryNodes nodes = state.nodes().     if (nodes.isLocalNodeElectedMaster()) {         if (stateHasRollupJobs(request, state)) {             super.doExecute(task, request, listener).         } else {             // If we couldn't find the job in the persistent task CS, it means it was deleted prior to this GET             // and we can just send an empty response, no need to go looking for the allocated task             listener.onResponse(new GetRollupJobsAction.Response(Collections.emptyList())).         }     } else {         // on the master, which makes testing difficult.         if (nodes.getMasterNode() == null) {             listener.onFailure(new MasterNotDiscoveredException("no known master nodes")).         } else {             transportService.sendRequest(nodes.getMasterNode(), actionName, request, new ActionListenerResponseHandler<>(listener, GetRollupJobsAction.Response::new)).         }     } }
true;static;2;19;/**  * Check to see if the PersistentTask's cluster state contains the rollup job(s) we are interested in  */ ;/**  * Check to see if the PersistentTask's cluster state contains the rollup job(s) we are interested in  */ static boolean stateHasRollupJobs(GetRollupJobsAction.Request request, ClusterState state) {     boolean hasRollupJobs = false.     PersistentTasksCustomMetaData pTasksMeta = state.getMetaData().custom(PersistentTasksCustomMetaData.TYPE).     if (pTasksMeta != null) {         // persistent tasks and see if at least once has a RollupJob param         if (request.getId().equals(MetaData.ALL)) {             hasRollupJobs = pTasksMeta.tasks().stream().anyMatch(persistentTask -> persistentTask.getTaskName().equals(RollupField.TASK_NAME)).         } else if (pTasksMeta.getTask(request.getId()) != null) {             // If we're looking for a single job, we can just check directly             hasRollupJobs = true.         }     }     return hasRollupJobs. }
false;protected;3;16;;@Override protected void taskOperation(GetRollupJobsAction.Request request, RollupJobTask jobTask, ActionListener<GetRollupJobsAction.Response> listener) {     List<GetRollupJobsAction.JobWrapper> jobs = Collections.emptyList().     assert jobTask.getConfig().getId().equals(request.getId()) || request.getId().equals(MetaData.ALL).     // Little extra insurance, make sure we only return jobs that aren't cancelled     if (jobTask.isCancelled() == false) {         GetRollupJobsAction.JobWrapper wrapper = new GetRollupJobsAction.JobWrapper(jobTask.getConfig(), jobTask.getStats(), (RollupJobStatus) jobTask.getStatus()).         jobs = Collections.singletonList(wrapper).     }     listener.onResponse(new GetRollupJobsAction.Response(jobs)). }
false;protected;4;8;;@Override protected GetRollupJobsAction.Response newResponse(GetRollupJobsAction.Request request, List<GetRollupJobsAction.Response> tasks, List<TaskOperationFailure> taskOperationFailures, List<FailedNodeException> failedNodeExceptions) {     List<GetRollupJobsAction.JobWrapper> jobs = tasks.stream().map(GetRollupJobsAction.Response::getJobs).flatMap(Collection::stream).collect(Collectors.toList()).     return new GetRollupJobsAction.Response(jobs, taskOperationFailures, failedNodeExceptions). }
