# id;timestamp;commentText;codeText;commentWords;codeWords
RollupResponseTranslator -> public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,                                                  InternalAggregation.ReduceContext reduceContext);1524684173;Translates a rollup-only search response back into the expected convention.  Similar to_{@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} except it only_has to deal with the rollup response (no live response)__See {@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} for more details_on the translation conventions;public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,_                                                 InternalAggregation.ReduceContext reduceContext) {__        List<SearchResponse> responses = Arrays.stream(rolledMsearch)_                .map(item -> {_                    if (item.isFailure()) {_                        throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                    }_                    return item.getResponse()__                }).collect(Collectors.toList())___        return doCombineResponse(null, responses, reduceContext)__    };translates,a,rollup,only,search,response,back,into,the,expected,convention,similar,to,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,except,it,only,has,to,deal,with,the,rollup,response,no,live,response,see,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,for,more,details,on,the,translation,conventions;public,static,search,response,translate,response,multi,search,response,item,rolled,msearch,internal,aggregation,reduce,context,reduce,context,list,search,response,responses,arrays,stream,rolled,msearch,map,item,if,item,is,failure,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,item,get,response,collect,collectors,to,list,return,do,combine,response,null,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,                                                  InternalAggregation.ReduceContext reduceContext);1528762805;Translates a rollup-only search response back into the expected convention.  Similar to_{@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} except it only_has to deal with the rollup response (no live response)__See {@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} for more details_on the translation conventions;public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,_                                                 InternalAggregation.ReduceContext reduceContext) {__        List<SearchResponse> responses = Arrays.stream(rolledMsearch)_                .map(item -> {_                    if (item.isFailure()) {_                        throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                    }_                    return item.getResponse()__                }).collect(Collectors.toList())___        return doCombineResponse(null, responses, reduceContext)__    };translates,a,rollup,only,search,response,back,into,the,expected,convention,similar,to,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,except,it,only,has,to,deal,with,the,rollup,response,no,live,response,see,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,for,more,details,on,the,translation,conventions;public,static,search,response,translate,response,multi,search,response,item,rolled,msearch,internal,aggregation,reduce,context,reduce,context,list,search,response,responses,arrays,stream,rolled,msearch,map,item,if,item,is,failure,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,item,get,response,collect,collectors,to,list,return,do,combine,response,null,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,                                                  InternalAggregation.ReduceContext reduceContext);1531729807;Translates a rollup-only search response back into the expected convention.  Similar to_{@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} except it only_has to deal with the rollup response (no live response)__See {@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} for more details_on the translation conventions;public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,_                                                 InternalAggregation.ReduceContext reduceContext) {__        List<SearchResponse> responses = Arrays.stream(rolledMsearch)_                .map(item -> {_                    if (item.isFailure()) {_                        throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                    }_                    return item.getResponse()__                }).collect(Collectors.toList())___        return doCombineResponse(null, responses, reduceContext)__    };translates,a,rollup,only,search,response,back,into,the,expected,convention,similar,to,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,except,it,only,has,to,deal,with,the,rollup,response,no,live,response,see,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,for,more,details,on,the,translation,conventions;public,static,search,response,translate,response,multi,search,response,item,rolled,msearch,internal,aggregation,reduce,context,reduce,context,list,search,response,responses,arrays,stream,rolled,msearch,map,item,if,item,is,failure,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,item,get,response,collect,collectors,to,list,return,do,combine,response,null,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,                                                  InternalAggregation.ReduceContext reduceContext);1535057785;Translates a rollup-only search response back into the expected convention.  Similar to_{@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} except it only_has to deal with the rollup response (no live response)__See {@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} for more details_on the translation conventions;public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,_                                                 InternalAggregation.ReduceContext reduceContext) {__        List<SearchResponse> responses = Arrays.stream(rolledMsearch)_                .map(item -> {_                    if (item.isFailure()) {_                        throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                    }_                    return item.getResponse()__                }).collect(Collectors.toList())___        return doCombineResponse(null, responses, reduceContext)__    };translates,a,rollup,only,search,response,back,into,the,expected,convention,similar,to,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,except,it,only,has,to,deal,with,the,rollup,response,no,live,response,see,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,for,more,details,on,the,translation,conventions;public,static,search,response,translate,response,multi,search,response,item,rolled,msearch,internal,aggregation,reduce,context,reduce,context,list,search,response,responses,arrays,stream,rolled,msearch,map,item,if,item,is,failure,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,item,get,response,collect,collectors,to,list,return,do,combine,response,null,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,                                                  InternalAggregation.ReduceContext reduceContext);1536314350;Translates a rollup-only search response back into the expected convention.  Similar to_{@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} except it only_has to deal with the rollup response (no live response)__See {@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} for more details_on the translation conventions;public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,_                                                 InternalAggregation.ReduceContext reduceContext) {__        List<SearchResponse> responses = Arrays.stream(rolledMsearch)_                .map(item -> {_                    if (item.isFailure()) {_                        throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                    }_                    return item.getResponse()__                }).collect(Collectors.toList())___        return doCombineResponse(null, responses, reduceContext)__    };translates,a,rollup,only,search,response,back,into,the,expected,convention,similar,to,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,except,it,only,has,to,deal,with,the,rollup,response,no,live,response,see,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,for,more,details,on,the,translation,conventions;public,static,search,response,translate,response,multi,search,response,item,rolled,msearch,internal,aggregation,reduce,context,reduce,context,list,search,response,responses,arrays,stream,rolled,msearch,map,item,if,item,is,failure,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,item,get,response,collect,collectors,to,list,return,do,combine,response,null,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,                                                  InternalAggregation.ReduceContext reduceContext);1539951844;Translates a rollup-only search response back into the expected convention.  Similar to_{@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} except it only_has to deal with the rollup response (no live response)__See {@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} for more details_on the translation conventions;public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,_                                                 InternalAggregation.ReduceContext reduceContext) {__        List<SearchResponse> responses = Arrays.stream(rolledMsearch)_                .map(item -> {_                    if (item.isFailure()) {_                        throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                    }_                    return item.getResponse()__                }).collect(Collectors.toList())___        return doCombineResponse(null, responses, reduceContext)__    };translates,a,rollup,only,search,response,back,into,the,expected,convention,similar,to,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,except,it,only,has,to,deal,with,the,rollup,response,no,live,response,see,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,for,more,details,on,the,translation,conventions;public,static,search,response,translate,response,multi,search,response,item,rolled,msearch,internal,aggregation,reduce,context,reduce,context,list,search,response,responses,arrays,stream,rolled,msearch,map,item,if,item,is,failure,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,item,get,response,collect,collectors,to,list,return,do,combine,response,null,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,                                                  InternalAggregation.ReduceContext reduceContext);1540847035;Translates a rollup-only search response back into the expected convention.  Similar to_{@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} except it only_has to deal with the rollup response (no live response)__See {@link #combineResponses(MultiSearchResponse.Item[], InternalAggregation.ReduceContext)} for more details_on the translation conventions;public static SearchResponse translateResponse(MultiSearchResponse.Item[] rolledMsearch,_                                                 InternalAggregation.ReduceContext reduceContext) {__        List<SearchResponse> responses = Arrays.stream(rolledMsearch)_                .map(item -> {_                    if (item.isFailure()) {_                        throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                    }_                    return item.getResponse()__                }).collect(Collectors.toList())___        return doCombineResponse(null, responses, reduceContext)__    };translates,a,rollup,only,search,response,back,into,the,expected,convention,similar,to,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,except,it,only,has,to,deal,with,the,rollup,response,no,live,response,see,link,combine,responses,multi,search,response,item,internal,aggregation,reduce,context,for,more,details,on,the,translation,conventions;public,static,search,response,translate,response,multi,search,response,item,rolled,msearch,internal,aggregation,reduce,context,reduce,context,list,search,response,responses,arrays,stream,rolled,msearch,map,item,if,item,is,failure,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,item,get,response,collect,collectors,to,list,return,do,combine,response,null,responses,reduce,context
RollupResponseTranslator -> private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,                                                        InternalAggregations currentTree);1524684173;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree___@param rolled   The rollup aggregation that we wish to unroll_@param original The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation__@return An unrolled aggregation that mimics the structure of `base`, allowing reduction;private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,_                                                       InternalAggregations currentTree) {_        return rolled.asList().stream()_                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(agg -> {_                    _                    _                    _                    _                    _                    _                    _                    _                    long count = -1__                    if (agg instanceof InternalMultiBucketAggregation == false) {_                        count = getAggCount(agg, rolled.getAsMap())__                    }__                    return unrollAgg((InternalAggregation)agg, original.get(agg.getName()), currentTree.get(agg.getName()), count)__                }).collect(Collectors.toList())__    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;private,static,list,internal,aggregation,unroll,agg,internal,aggregations,rolled,internal,aggregations,original,internal,aggregations,current,tree,return,rolled,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,agg,long,count,1,if,agg,instanceof,internal,multi,bucket,aggregation,false,count,get,agg,count,agg,rolled,get,as,map,return,unroll,agg,internal,aggregation,agg,original,get,agg,get,name,current,tree,get,agg,get,name,count,collect,collectors,to,list
RollupResponseTranslator -> private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,                                                        InternalAggregations currentTree);1528762805;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree___@param rolled   The rollup aggregation that we wish to unroll_@param original The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation__@return An unrolled aggregation that mimics the structure of `base`, allowing reduction;private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,_                                                       InternalAggregations currentTree) {_        return rolled.asList().stream()_                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(agg -> {_                    _                    _                    _                    _                    _                    _                    _                    _                    long count = -1__                    if (agg instanceof InternalMultiBucketAggregation == false) {_                        count = getAggCount(agg, rolled.getAsMap())__                    }__                    return unrollAgg((InternalAggregation)agg, original.get(agg.getName()), currentTree.get(agg.getName()), count)__                }).collect(Collectors.toList())__    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;private,static,list,internal,aggregation,unroll,agg,internal,aggregations,rolled,internal,aggregations,original,internal,aggregations,current,tree,return,rolled,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,agg,long,count,1,if,agg,instanceof,internal,multi,bucket,aggregation,false,count,get,agg,count,agg,rolled,get,as,map,return,unroll,agg,internal,aggregation,agg,original,get,agg,get,name,current,tree,get,agg,get,name,count,collect,collectors,to,list
RollupResponseTranslator -> private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,                                                        InternalAggregations currentTree);1531729807;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree___@param rolled   The rollup aggregation that we wish to unroll_@param original The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation__@return An unrolled aggregation that mimics the structure of `base`, allowing reduction;private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,_                                                       InternalAggregations currentTree) {_        return rolled.asList().stream()_                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(agg -> {_                    _                    _                    _                    _                    _                    _                    _                    _                    long count = -1__                    if (agg instanceof InternalMultiBucketAggregation == false) {_                        count = getAggCount(agg, rolled.getAsMap())__                    }__                    return unrollAgg((InternalAggregation)agg, original.get(agg.getName()), currentTree.get(agg.getName()), count)__                }).collect(Collectors.toList())__    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;private,static,list,internal,aggregation,unroll,agg,internal,aggregations,rolled,internal,aggregations,original,internal,aggregations,current,tree,return,rolled,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,agg,long,count,1,if,agg,instanceof,internal,multi,bucket,aggregation,false,count,get,agg,count,agg,rolled,get,as,map,return,unroll,agg,internal,aggregation,agg,original,get,agg,get,name,current,tree,get,agg,get,name,count,collect,collectors,to,list
RollupResponseTranslator -> private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,                                                        InternalAggregations currentTree);1535057785;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree___@param rolled   The rollup aggregation that we wish to unroll_@param original The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation__@return An unrolled aggregation that mimics the structure of `base`, allowing reduction;private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,_                                                       InternalAggregations currentTree) {_        return rolled.asList().stream()_                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(agg -> {_                    _                    _                    _                    _                    _                    _                    _                    _                    long count = -1__                    if (agg instanceof InternalMultiBucketAggregation == false) {_                        count = getAggCount(agg, rolled.getAsMap())__                    }__                    return unrollAgg((InternalAggregation)agg, original.get(agg.getName()), currentTree.get(agg.getName()), count)__                }).collect(Collectors.toList())__    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;private,static,list,internal,aggregation,unroll,agg,internal,aggregations,rolled,internal,aggregations,original,internal,aggregations,current,tree,return,rolled,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,agg,long,count,1,if,agg,instanceof,internal,multi,bucket,aggregation,false,count,get,agg,count,agg,rolled,get,as,map,return,unroll,agg,internal,aggregation,agg,original,get,agg,get,name,current,tree,get,agg,get,name,count,collect,collectors,to,list
RollupResponseTranslator -> private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,                                                        InternalAggregations currentTree);1536314350;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree___@param rolled   The rollup aggregation that we wish to unroll_@param original The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation__@return An unrolled aggregation that mimics the structure of `base`, allowing reduction;private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,_                                                       InternalAggregations currentTree) {_        return rolled.asList().stream()_                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(agg -> {_                    _                    _                    _                    _                    _                    _                    _                    _                    long count = -1__                    if (agg instanceof InternalMultiBucketAggregation == false) {_                        count = getAggCount(agg, rolled.getAsMap())__                    }__                    return unrollAgg((InternalAggregation)agg, original.get(agg.getName()), currentTree.get(agg.getName()), count)__                }).collect(Collectors.toList())__    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;private,static,list,internal,aggregation,unroll,agg,internal,aggregations,rolled,internal,aggregations,original,internal,aggregations,current,tree,return,rolled,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,agg,long,count,1,if,agg,instanceof,internal,multi,bucket,aggregation,false,count,get,agg,count,agg,rolled,get,as,map,return,unroll,agg,internal,aggregation,agg,original,get,agg,get,name,current,tree,get,agg,get,name,count,collect,collectors,to,list
RollupResponseTranslator -> private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,                                                        InternalAggregations currentTree);1539951844;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree___@param rolled   The rollup aggregation that we wish to unroll_@param original The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation__@return An unrolled aggregation that mimics the structure of `base`, allowing reduction;private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,_                                                       InternalAggregations currentTree) {_        return rolled.asList().stream()_                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(agg -> {_                    _                    _                    _                    _                    _                    _                    _                    _                    long count = -1__                    if (agg instanceof InternalMultiBucketAggregation == false) {_                        count = getAggCount(agg, rolled.getAsMap())__                    }__                    return unrollAgg((InternalAggregation)agg, original.get(agg.getName()), currentTree.get(agg.getName()), count)__                }).collect(Collectors.toList())__    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;private,static,list,internal,aggregation,unroll,agg,internal,aggregations,rolled,internal,aggregations,original,internal,aggregations,current,tree,return,rolled,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,agg,long,count,1,if,agg,instanceof,internal,multi,bucket,aggregation,false,count,get,agg,count,agg,rolled,get,as,map,return,unroll,agg,internal,aggregation,agg,original,get,agg,get,name,current,tree,get,agg,get,name,count,collect,collectors,to,list
RollupResponseTranslator -> private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,                                                        InternalAggregations currentTree);1540847035;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree___@param rolled   The rollup aggregation that we wish to unroll_@param original The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation__@return An unrolled aggregation that mimics the structure of `base`, allowing reduction;private static List<InternalAggregation> unrollAgg(InternalAggregations rolled, InternalAggregations original,_                                                       InternalAggregations currentTree) {_        return rolled.asList().stream()_                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(agg -> {_                    _                    _                    _                    _                    _                    _                    _                    _                    long count = -1__                    if (agg instanceof InternalMultiBucketAggregation == false) {_                        count = getAggCount(agg, rolled.getAsMap())__                    }__                    return unrollAgg((InternalAggregation)agg, original.get(agg.getName()), currentTree.get(agg.getName()), count)__                }).collect(Collectors.toList())__    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;private,static,list,internal,aggregation,unroll,agg,internal,aggregations,rolled,internal,aggregations,original,internal,aggregations,current,tree,return,rolled,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,agg,long,count,1,if,agg,instanceof,internal,multi,bucket,aggregation,false,count,get,agg,count,agg,rolled,get,as,map,return,unroll,agg,internal,aggregation,agg,original,get,agg,get,name,current,tree,get,agg,get,name,count,collect,collectors,to,list
RollupResponseTranslator -> protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,                                                    InternalAggregation currentTree, long count);1524684173;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree__@param rolled      The rollup aggregation that we wish to unroll_@param originalAgg The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation_@param count       The doc_count for `rolled`, required by some aggs (e.g. avg)__@return An unrolled aggregation that mimics the structure of base, allowing reduction;protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,_                                                   InternalAggregation currentTree, long count) {__        if (rolled instanceof InternalMultiBucketAggregation) {_            return unrollMultiBucket((InternalMultiBucketAggregation) rolled, (InternalMultiBucketAggregation) originalAgg,_                    (InternalMultiBucketAggregation) currentTree)__        } else if (rolled instanceof SingleValue) {_            return unrollMetric((SingleValue) rolled, count)__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,agg,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,param,count,the,for,rolled,required,by,some,aggs,e,g,avg,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;protected,static,internal,aggregation,unroll,agg,internal,aggregation,rolled,internal,aggregation,original,agg,internal,aggregation,current,tree,long,count,if,rolled,instanceof,internal,multi,bucket,aggregation,return,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,agg,internal,multi,bucket,aggregation,current,tree,else,if,rolled,instanceof,single,value,return,unroll,metric,single,value,rolled,count,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,                                                    InternalAggregation currentTree, long count);1528762805;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree__@param rolled      The rollup aggregation that we wish to unroll_@param originalAgg The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation_@param count       The doc_count for `rolled`, required by some aggs (e.g. avg)__@return An unrolled aggregation that mimics the structure of base, allowing reduction;protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,_                                                   InternalAggregation currentTree, long count) {__        if (rolled instanceof InternalMultiBucketAggregation) {_            return unrollMultiBucket((InternalMultiBucketAggregation) rolled, (InternalMultiBucketAggregation) originalAgg,_                    (InternalMultiBucketAggregation) currentTree)__        } else if (rolled instanceof SingleValue) {_            return unrollMetric((SingleValue) rolled, count)__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,agg,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,param,count,the,for,rolled,required,by,some,aggs,e,g,avg,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;protected,static,internal,aggregation,unroll,agg,internal,aggregation,rolled,internal,aggregation,original,agg,internal,aggregation,current,tree,long,count,if,rolled,instanceof,internal,multi,bucket,aggregation,return,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,agg,internal,multi,bucket,aggregation,current,tree,else,if,rolled,instanceof,single,value,return,unroll,metric,single,value,rolled,count,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,                                                    InternalAggregation currentTree, long count);1531729807;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree__@param rolled      The rollup aggregation that we wish to unroll_@param originalAgg The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation_@param count       The doc_count for `rolled`, required by some aggs (e.g. avg)__@return An unrolled aggregation that mimics the structure of base, allowing reduction;protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,_                                                   InternalAggregation currentTree, long count) {__        if (rolled instanceof InternalMultiBucketAggregation) {_            return unrollMultiBucket((InternalMultiBucketAggregation) rolled, (InternalMultiBucketAggregation) originalAgg,_                    (InternalMultiBucketAggregation) currentTree)__        } else if (rolled instanceof SingleValue) {_            return unrollMetric((SingleValue) rolled, count)__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,agg,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,param,count,the,for,rolled,required,by,some,aggs,e,g,avg,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;protected,static,internal,aggregation,unroll,agg,internal,aggregation,rolled,internal,aggregation,original,agg,internal,aggregation,current,tree,long,count,if,rolled,instanceof,internal,multi,bucket,aggregation,return,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,agg,internal,multi,bucket,aggregation,current,tree,else,if,rolled,instanceof,single,value,return,unroll,metric,single,value,rolled,count,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,                                                    InternalAggregation currentTree, long count);1535057785;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree__@param rolled      The rollup aggregation that we wish to unroll_@param originalAgg The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation_@param count       The doc_count for `rolled`, required by some aggs (e.g. avg)__@return An unrolled aggregation that mimics the structure of base, allowing reduction;protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,_                                                   InternalAggregation currentTree, long count) {__        if (rolled instanceof InternalMultiBucketAggregation) {_            return unrollMultiBucket((InternalMultiBucketAggregation) rolled, (InternalMultiBucketAggregation) originalAgg,_                    (InternalMultiBucketAggregation) currentTree)__        } else if (rolled instanceof SingleValue) {_            return unrollMetric((SingleValue) rolled, count)__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,agg,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,param,count,the,for,rolled,required,by,some,aggs,e,g,avg,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;protected,static,internal,aggregation,unroll,agg,internal,aggregation,rolled,internal,aggregation,original,agg,internal,aggregation,current,tree,long,count,if,rolled,instanceof,internal,multi,bucket,aggregation,return,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,agg,internal,multi,bucket,aggregation,current,tree,else,if,rolled,instanceof,single,value,return,unroll,metric,single,value,rolled,count,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,                                                    InternalAggregation currentTree, long count);1536314350;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree__@param rolled      The rollup aggregation that we wish to unroll_@param originalAgg The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation_@param count       The doc_count for `rolled`, required by some aggs (e.g. avg)__@return An unrolled aggregation that mimics the structure of base, allowing reduction;protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,_                                                   InternalAggregation currentTree, long count) {__        if (rolled instanceof InternalMultiBucketAggregation) {_            return unrollMultiBucket((InternalMultiBucketAggregation) rolled, (InternalMultiBucketAggregation) originalAgg,_                    (InternalMultiBucketAggregation) currentTree)__        } else if (rolled instanceof SingleValue) {_            return unrollMetric((SingleValue) rolled, count)__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,agg,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,param,count,the,for,rolled,required,by,some,aggs,e,g,avg,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;protected,static,internal,aggregation,unroll,agg,internal,aggregation,rolled,internal,aggregation,original,agg,internal,aggregation,current,tree,long,count,if,rolled,instanceof,internal,multi,bucket,aggregation,return,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,agg,internal,multi,bucket,aggregation,current,tree,else,if,rolled,instanceof,single,value,return,unroll,metric,single,value,rolled,count,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,                                                    InternalAggregation currentTree, long count);1539951844;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree__@param rolled      The rollup aggregation that we wish to unroll_@param originalAgg The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation_@param count       The doc_count for `rolled`, required by some aggs (e.g. avg)__@return An unrolled aggregation that mimics the structure of base, allowing reduction;protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,_                                                   InternalAggregation currentTree, long count) {__        if (rolled instanceof InternalMultiBucketAggregation) {_            return unrollMultiBucket((InternalMultiBucketAggregation) rolled, (InternalMultiBucketAggregation) originalAgg,_                    (InternalMultiBucketAggregation) currentTree)__        } else if (rolled instanceof SingleValue) {_            return unrollMetric((SingleValue) rolled, count)__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,agg,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,param,count,the,for,rolled,required,by,some,aggs,e,g,avg,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;protected,static,internal,aggregation,unroll,agg,internal,aggregation,rolled,internal,aggregation,original,agg,internal,aggregation,current,tree,long,count,if,rolled,instanceof,internal,multi,bucket,aggregation,return,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,agg,internal,multi,bucket,aggregation,current,tree,else,if,rolled,instanceof,single,value,return,unroll,metric,single,value,rolled,count,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,                                                    InternalAggregation currentTree, long count);1540847035;Takes an aggregation with rollup conventions and unrolls into a "normal" agg tree__@param rolled      The rollup aggregation that we wish to unroll_@param originalAgg The unrolled, "live" aggregation (if it exists) that matches the current rolled aggregation_@param count       The doc_count for `rolled`, required by some aggs (e.g. avg)__@return An unrolled aggregation that mimics the structure of base, allowing reduction;protected static InternalAggregation unrollAgg(InternalAggregation rolled, InternalAggregation originalAgg,_                                                   InternalAggregation currentTree, long count) {__        if (rolled instanceof InternalMultiBucketAggregation) {_            return unrollMultiBucket((InternalMultiBucketAggregation) rolled, (InternalMultiBucketAggregation) originalAgg,_                    (InternalMultiBucketAggregation) currentTree)__        } else if (rolled instanceof SingleValue) {_            return unrollMetric((SingleValue) rolled, count)__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }_    };takes,an,aggregation,with,rollup,conventions,and,unrolls,into,a,normal,agg,tree,param,rolled,the,rollup,aggregation,that,we,wish,to,unroll,param,original,agg,the,unrolled,live,aggregation,if,it,exists,that,matches,the,current,rolled,aggregation,param,count,the,for,rolled,required,by,some,aggs,e,g,avg,return,an,unrolled,aggregation,that,mimics,the,structure,of,base,allowing,reduction;protected,static,internal,aggregation,unroll,agg,internal,aggregation,rolled,internal,aggregation,original,agg,internal,aggregation,current,tree,long,count,if,rolled,instanceof,internal,multi,bucket,aggregation,return,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,agg,internal,multi,bucket,aggregation,current,tree,else,if,rolled,instanceof,single,value,return,unroll,metric,single,value,rolled,count,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse);1524684173;Verifies a live-only search response.  Essentially just checks for failure then returns_the response since we have no work to do;public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse) {_        if (normalResponse.isFailure()) {_            throw new RuntimeException(normalResponse.getFailureMessage(), normalResponse.getFailure())__        }_        return normalResponse.getResponse()__    };verifies,a,live,only,search,response,essentially,just,checks,for,failure,then,returns,the,response,since,we,have,no,work,to,do;public,static,search,response,verify,response,multi,search,response,item,normal,response,if,normal,response,is,failure,throw,new,runtime,exception,normal,response,get,failure,message,normal,response,get,failure,return,normal,response,get,response
RollupResponseTranslator -> public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse);1528762805;Verifies a live-only search response.  Essentially just checks for failure then returns_the response since we have no work to do;public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse) {_        if (normalResponse.isFailure()) {_            throw new RuntimeException(normalResponse.getFailureMessage(), normalResponse.getFailure())__        }_        return normalResponse.getResponse()__    };verifies,a,live,only,search,response,essentially,just,checks,for,failure,then,returns,the,response,since,we,have,no,work,to,do;public,static,search,response,verify,response,multi,search,response,item,normal,response,if,normal,response,is,failure,throw,new,runtime,exception,normal,response,get,failure,message,normal,response,get,failure,return,normal,response,get,response
RollupResponseTranslator -> public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse);1531729807;Verifies a live-only search response.  Essentially just checks for failure then returns_the response since we have no work to do;public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse) {_        if (normalResponse.isFailure()) {_            throw new RuntimeException(normalResponse.getFailureMessage(), normalResponse.getFailure())__        }_        return normalResponse.getResponse()__    };verifies,a,live,only,search,response,essentially,just,checks,for,failure,then,returns,the,response,since,we,have,no,work,to,do;public,static,search,response,verify,response,multi,search,response,item,normal,response,if,normal,response,is,failure,throw,new,runtime,exception,normal,response,get,failure,message,normal,response,get,failure,return,normal,response,get,response
RollupResponseTranslator -> public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse);1535057785;Verifies a live-only search response.  Essentially just checks for failure then returns_the response since we have no work to do;public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse) {_        if (normalResponse.isFailure()) {_            throw new RuntimeException(normalResponse.getFailureMessage(), normalResponse.getFailure())__        }_        return normalResponse.getResponse()__    };verifies,a,live,only,search,response,essentially,just,checks,for,failure,then,returns,the,response,since,we,have,no,work,to,do;public,static,search,response,verify,response,multi,search,response,item,normal,response,if,normal,response,is,failure,throw,new,runtime,exception,normal,response,get,failure,message,normal,response,get,failure,return,normal,response,get,response
RollupResponseTranslator -> public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse);1536314350;Verifies a live-only search response.  Essentially just checks for failure then returns_the response since we have no work to do;public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse) {_        if (normalResponse.isFailure()) {_            throw new RuntimeException(normalResponse.getFailureMessage(), normalResponse.getFailure())__        }_        return normalResponse.getResponse()__    };verifies,a,live,only,search,response,essentially,just,checks,for,failure,then,returns,the,response,since,we,have,no,work,to,do;public,static,search,response,verify,response,multi,search,response,item,normal,response,if,normal,response,is,failure,throw,new,runtime,exception,normal,response,get,failure,message,normal,response,get,failure,return,normal,response,get,response
RollupResponseTranslator -> public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse);1539951844;Verifies a live-only search response.  Essentially just checks for failure then returns_the response since we have no work to do;public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse) {_        if (normalResponse.isFailure()) {_            throw new RuntimeException(normalResponse.getFailureMessage(), normalResponse.getFailure())__        }_        return normalResponse.getResponse()__    };verifies,a,live,only,search,response,essentially,just,checks,for,failure,then,returns,the,response,since,we,have,no,work,to,do;public,static,search,response,verify,response,multi,search,response,item,normal,response,if,normal,response,is,failure,throw,new,runtime,exception,normal,response,get,failure,message,normal,response,get,failure,return,normal,response,get,response
RollupResponseTranslator -> public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse);1540847035;Verifies a live-only search response.  Essentially just checks for failure then returns_the response since we have no work to do;public static SearchResponse verifyResponse(MultiSearchResponse.Item normalResponse) {_        if (normalResponse.isFailure()) {_            throw new RuntimeException(normalResponse.getFailureMessage(), normalResponse.getFailure())__        }_        return normalResponse.getResponse()__    };verifies,a,live,only,search,response,essentially,just,checks,for,failure,then,returns,the,response,since,we,have,no,work,to,do;public,static,search,response,verify,response,multi,search,response,item,normal,response,if,normal,response,is,failure,throw,new,runtime,exception,normal,response,get,failure,message,normal,response,get,failure,return,normal,response,get,response
RollupResponseTranslator -> public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,                                                   InternalAggregation.ReduceContext reduceContext);1524684173;Combines an msearch with rollup + live aggregations into a SearchResponse_representing the union of the two responses.  The response format is identical to_a non-rollup search response (aka a "normal aggregation" response).__If the MSearch Response returns the following:__<pre>{@code___"took":228,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"histo":{_"buckets":[__"key_as_string":"2017-05-15T00:00:00.000Z",_"key":1494806400000,_"doc_count":1,_"the_max":{_"value":1.0________"took":205,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"filter_histo":{_"doc_count":1,_"histo":{_"buckets":[__"key_as_string":"2017-05-14T00:00:00.000Z",_"key":1494720000000,_"doc_count":1,_"the_max":{_"value":19995.0__"histo._count":{_"value":1.0E9________}</pre>__It would be collapsed into:__<pre>{@code__"took": 228,_"timed_out": false,_"_shards": {...},_"hits": {...},_"aggregations": {_"histo": {_"buckets": [__"key_as_string": "2017-05-14T00:00:00.000Z",_"key": 1494720000000,_"doc_count": 1000000000,_"the_max": {_"value": 19995____"key_as_string": "2017-05-15T00:00:00.000Z",_"key": 1494806400000,_"doc_count": 1,_"the_max": {_"value": 1_______}</pre>__It essentially takes the conventions listed in {@link RollupRequestTranslator} and processes them_so that the final product looks like a regular aggregation response, allowing it to be_reduced/merged into the response from the un-rolled index__@param msearchResponses The responses from the msearch, where the first response is the live-index response;public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,_                                                  InternalAggregation.ReduceContext reduceContext) {_        boolean liveMissing = false__        assert msearchResponses.length >= 2___        _        MultiSearchResponse.Item liveResponse = msearchResponses[0]__        if (liveResponse.isFailure()) {_            Exception e = liveResponse.getFailure()__            _            if (e instanceof IndexNotFoundException) {_                logger.warn("\"Live\" index not found during rollup search.", e)__                liveMissing = true__            } else {_                throw new RuntimeException(liveResponse.getFailureMessage(), liveResponse.getFailure())__            }_        }_        List<SearchResponse> rolledResponses = Arrays.stream(msearchResponses)_                .skip(1)_                .map(item -> {_                    if (item.isFailure()) {_                        Exception e = item.getFailure()__                        _                        _                        if (e instanceof IndexNotFoundException) {_                            logger.warn("Rollup index not found during rollup search.", e)__                        } else {_                            throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                        }_                        return null__                    } else {_                        return item.getResponse()__                    }_                }).filter(Objects::nonNull).collect(Collectors.toList())___        _        if (rolledResponses.isEmpty() && liveMissing == false) {_            return verifyResponse(liveResponse)__        } else if (rolledResponses.isEmpty() && liveMissing) {_            throw new RuntimeException("No indices (live or rollup) found during rollup search")__        }__        return doCombineResponse(liveResponse.getResponse(), rolledResponses, reduceContext)__    };combines,an,msearch,with,rollup,live,aggregations,into,a,search,response,representing,the,union,of,the,two,responses,the,response,format,is,identical,to,a,non,rollup,search,response,aka,a,normal,aggregation,response,if,the,msearch,response,returns,the,following,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,0,took,205,false,hits,aggregations,1,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1,value,19995,0,histo,value,1,0e9,pre,it,would,be,collapsed,into,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1000000000,value,19995,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,pre,it,essentially,takes,the,conventions,listed,in,link,rollup,request,translator,and,processes,them,so,that,the,final,product,looks,like,a,regular,aggregation,response,allowing,it,to,be,reduced,merged,into,the,response,from,the,un,rolled,index,param,msearch,responses,the,responses,from,the,msearch,where,the,first,response,is,the,live,index,response;public,static,search,response,combine,responses,multi,search,response,item,msearch,responses,internal,aggregation,reduce,context,reduce,context,boolean,live,missing,false,assert,msearch,responses,length,2,multi,search,response,item,live,response,msearch,responses,0,if,live,response,is,failure,exception,e,live,response,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,live,index,not,found,during,rollup,search,e,live,missing,true,else,throw,new,runtime,exception,live,response,get,failure,message,live,response,get,failure,list,search,response,rolled,responses,arrays,stream,msearch,responses,skip,1,map,item,if,item,is,failure,exception,e,item,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,rollup,index,not,found,during,rollup,search,e,else,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,null,else,return,item,get,response,filter,objects,non,null,collect,collectors,to,list,if,rolled,responses,is,empty,live,missing,false,return,verify,response,live,response,else,if,rolled,responses,is,empty,live,missing,throw,new,runtime,exception,no,indices,live,or,rollup,found,during,rollup,search,return,do,combine,response,live,response,get,response,rolled,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,                                                   InternalAggregation.ReduceContext reduceContext);1528762805;Combines an msearch with rollup + live aggregations into a SearchResponse_representing the union of the two responses.  The response format is identical to_a non-rollup search response (aka a "normal aggregation" response).__If the MSearch Response returns the following:__<pre>{@code___"took":228,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"histo":{_"buckets":[__"key_as_string":"2017-05-15T00:00:00.000Z",_"key":1494806400000,_"doc_count":1,_"the_max":{_"value":1.0________"took":205,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"filter_histo":{_"doc_count":1,_"histo":{_"buckets":[__"key_as_string":"2017-05-14T00:00:00.000Z",_"key":1494720000000,_"doc_count":1,_"the_max":{_"value":19995.0__"histo._count":{_"value":1.0E9________}</pre>__It would be collapsed into:__<pre>{@code__"took": 228,_"timed_out": false,_"_shards": {...},_"hits": {...},_"aggregations": {_"histo": {_"buckets": [__"key_as_string": "2017-05-14T00:00:00.000Z",_"key": 1494720000000,_"doc_count": 1000000000,_"the_max": {_"value": 19995____"key_as_string": "2017-05-15T00:00:00.000Z",_"key": 1494806400000,_"doc_count": 1,_"the_max": {_"value": 1_______}</pre>__It essentially takes the conventions listed in {@link RollupRequestTranslator} and processes them_so that the final product looks like a regular aggregation response, allowing it to be_reduced/merged into the response from the un-rolled index__@param msearchResponses The responses from the msearch, where the first response is the live-index response;public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,_                                                  InternalAggregation.ReduceContext reduceContext) {_        boolean liveMissing = false__        assert msearchResponses.length >= 2___        _        MultiSearchResponse.Item liveResponse = msearchResponses[0]__        if (liveResponse.isFailure()) {_            Exception e = liveResponse.getFailure()__            _            if (e instanceof IndexNotFoundException) {_                logger.warn("\"Live\" index not found during rollup search.", e)__                liveMissing = true__            } else {_                throw new RuntimeException(liveResponse.getFailureMessage(), liveResponse.getFailure())__            }_        }_        List<SearchResponse> rolledResponses = Arrays.stream(msearchResponses)_                .skip(1)_                .map(item -> {_                    if (item.isFailure()) {_                        Exception e = item.getFailure()__                        _                        _                        if (e instanceof IndexNotFoundException) {_                            logger.warn("Rollup index not found during rollup search.", e)__                        } else {_                            throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                        }_                        return null__                    } else {_                        return item.getResponse()__                    }_                }).filter(Objects::nonNull).collect(Collectors.toList())___        _        if (rolledResponses.isEmpty() && liveMissing == false) {_            return verifyResponse(liveResponse)__        } else if (rolledResponses.isEmpty() && liveMissing) {_            throw new RuntimeException("No indices (live or rollup) found during rollup search")__        }__        return doCombineResponse(liveResponse.getResponse(), rolledResponses, reduceContext)__    };combines,an,msearch,with,rollup,live,aggregations,into,a,search,response,representing,the,union,of,the,two,responses,the,response,format,is,identical,to,a,non,rollup,search,response,aka,a,normal,aggregation,response,if,the,msearch,response,returns,the,following,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,0,took,205,false,hits,aggregations,1,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1,value,19995,0,histo,value,1,0e9,pre,it,would,be,collapsed,into,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1000000000,value,19995,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,pre,it,essentially,takes,the,conventions,listed,in,link,rollup,request,translator,and,processes,them,so,that,the,final,product,looks,like,a,regular,aggregation,response,allowing,it,to,be,reduced,merged,into,the,response,from,the,un,rolled,index,param,msearch,responses,the,responses,from,the,msearch,where,the,first,response,is,the,live,index,response;public,static,search,response,combine,responses,multi,search,response,item,msearch,responses,internal,aggregation,reduce,context,reduce,context,boolean,live,missing,false,assert,msearch,responses,length,2,multi,search,response,item,live,response,msearch,responses,0,if,live,response,is,failure,exception,e,live,response,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,live,index,not,found,during,rollup,search,e,live,missing,true,else,throw,new,runtime,exception,live,response,get,failure,message,live,response,get,failure,list,search,response,rolled,responses,arrays,stream,msearch,responses,skip,1,map,item,if,item,is,failure,exception,e,item,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,rollup,index,not,found,during,rollup,search,e,else,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,null,else,return,item,get,response,filter,objects,non,null,collect,collectors,to,list,if,rolled,responses,is,empty,live,missing,false,return,verify,response,live,response,else,if,rolled,responses,is,empty,live,missing,throw,new,runtime,exception,no,indices,live,or,rollup,found,during,rollup,search,return,do,combine,response,live,response,get,response,rolled,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,                                                   InternalAggregation.ReduceContext reduceContext);1531729807;Combines an msearch with rollup + live aggregations into a SearchResponse_representing the union of the two responses.  The response format is identical to_a non-rollup search response (aka a "normal aggregation" response).__If the MSearch Response returns the following:__<pre>{@code___"took":228,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"histo":{_"buckets":[__"key_as_string":"2017-05-15T00:00:00.000Z",_"key":1494806400000,_"doc_count":1,_"the_max":{_"value":1.0________"took":205,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"filter_histo":{_"doc_count":1,_"histo":{_"buckets":[__"key_as_string":"2017-05-14T00:00:00.000Z",_"key":1494720000000,_"doc_count":1,_"the_max":{_"value":19995.0__"histo._count":{_"value":1.0E9________}</pre>__It would be collapsed into:__<pre>{@code__"took": 228,_"timed_out": false,_"_shards": {...},_"hits": {...},_"aggregations": {_"histo": {_"buckets": [__"key_as_string": "2017-05-14T00:00:00.000Z",_"key": 1494720000000,_"doc_count": 1000000000,_"the_max": {_"value": 19995____"key_as_string": "2017-05-15T00:00:00.000Z",_"key": 1494806400000,_"doc_count": 1,_"the_max": {_"value": 1_______}</pre>__It essentially takes the conventions listed in {@link RollupRequestTranslator} and processes them_so that the final product looks like a regular aggregation response, allowing it to be_reduced/merged into the response from the un-rolled index__@param msearchResponses The responses from the msearch, where the first response is the live-index response;public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,_                                                  InternalAggregation.ReduceContext reduceContext) {_        boolean liveMissing = false__        assert msearchResponses.length >= 2___        _        MultiSearchResponse.Item liveResponse = msearchResponses[0]__        if (liveResponse.isFailure()) {_            Exception e = liveResponse.getFailure()__            _            if (e instanceof IndexNotFoundException) {_                logger.warn("\"Live\" index not found during rollup search.", e)__                liveMissing = true__            } else {_                throw new RuntimeException(liveResponse.getFailureMessage(), liveResponse.getFailure())__            }_        }_        List<SearchResponse> rolledResponses = Arrays.stream(msearchResponses)_                .skip(1)_                .map(item -> {_                    if (item.isFailure()) {_                        Exception e = item.getFailure()__                        _                        _                        if (e instanceof IndexNotFoundException) {_                            logger.warn("Rollup index not found during rollup search.", e)__                        } else {_                            throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                        }_                        return null__                    } else {_                        return item.getResponse()__                    }_                }).filter(Objects::nonNull).collect(Collectors.toList())___        _        if (rolledResponses.isEmpty() && liveMissing == false) {_            return verifyResponse(liveResponse)__        } else if (rolledResponses.isEmpty() && liveMissing) {_            throw new RuntimeException("No indices (live or rollup) found during rollup search")__        }__        return doCombineResponse(liveResponse.getResponse(), rolledResponses, reduceContext)__    };combines,an,msearch,with,rollup,live,aggregations,into,a,search,response,representing,the,union,of,the,two,responses,the,response,format,is,identical,to,a,non,rollup,search,response,aka,a,normal,aggregation,response,if,the,msearch,response,returns,the,following,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,0,took,205,false,hits,aggregations,1,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1,value,19995,0,histo,value,1,0e9,pre,it,would,be,collapsed,into,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1000000000,value,19995,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,pre,it,essentially,takes,the,conventions,listed,in,link,rollup,request,translator,and,processes,them,so,that,the,final,product,looks,like,a,regular,aggregation,response,allowing,it,to,be,reduced,merged,into,the,response,from,the,un,rolled,index,param,msearch,responses,the,responses,from,the,msearch,where,the,first,response,is,the,live,index,response;public,static,search,response,combine,responses,multi,search,response,item,msearch,responses,internal,aggregation,reduce,context,reduce,context,boolean,live,missing,false,assert,msearch,responses,length,2,multi,search,response,item,live,response,msearch,responses,0,if,live,response,is,failure,exception,e,live,response,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,live,index,not,found,during,rollup,search,e,live,missing,true,else,throw,new,runtime,exception,live,response,get,failure,message,live,response,get,failure,list,search,response,rolled,responses,arrays,stream,msearch,responses,skip,1,map,item,if,item,is,failure,exception,e,item,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,rollup,index,not,found,during,rollup,search,e,else,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,null,else,return,item,get,response,filter,objects,non,null,collect,collectors,to,list,if,rolled,responses,is,empty,live,missing,false,return,verify,response,live,response,else,if,rolled,responses,is,empty,live,missing,throw,new,runtime,exception,no,indices,live,or,rollup,found,during,rollup,search,return,do,combine,response,live,response,get,response,rolled,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,                                                   InternalAggregation.ReduceContext reduceContext);1535057785;Combines an msearch with rollup + live aggregations into a SearchResponse_representing the union of the two responses.  The response format is identical to_a non-rollup search response (aka a "normal aggregation" response).__If the MSearch Response returns the following:__<pre>{@code___"took":228,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"histo":{_"buckets":[__"key_as_string":"2017-05-15T00:00:00.000Z",_"key":1494806400000,_"doc_count":1,_"the_max":{_"value":1.0________"took":205,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"filter_histo":{_"doc_count":1,_"histo":{_"buckets":[__"key_as_string":"2017-05-14T00:00:00.000Z",_"key":1494720000000,_"doc_count":1,_"the_max":{_"value":19995.0__"histo._count":{_"value":1.0E9________}</pre>__It would be collapsed into:__<pre>{@code__"took": 228,_"timed_out": false,_"_shards": {...},_"hits": {...},_"aggregations": {_"histo": {_"buckets": [__"key_as_string": "2017-05-14T00:00:00.000Z",_"key": 1494720000000,_"doc_count": 1000000000,_"the_max": {_"value": 19995____"key_as_string": "2017-05-15T00:00:00.000Z",_"key": 1494806400000,_"doc_count": 1,_"the_max": {_"value": 1_______}</pre>__It essentially takes the conventions listed in {@link RollupRequestTranslator} and processes them_so that the final product looks like a regular aggregation response, allowing it to be_reduced/merged into the response from the un-rolled index__@param msearchResponses The responses from the msearch, where the first response is the live-index response;public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,_                                                  InternalAggregation.ReduceContext reduceContext) {_        boolean liveMissing = false__        assert msearchResponses.length >= 2___        _        MultiSearchResponse.Item liveResponse = msearchResponses[0]__        if (liveResponse.isFailure()) {_            Exception e = liveResponse.getFailure()__            _            if (e instanceof IndexNotFoundException) {_                logger.warn("\"Live\" index not found during rollup search.", e)__                liveMissing = true__            } else {_                throw new RuntimeException(liveResponse.getFailureMessage(), liveResponse.getFailure())__            }_        }_        List<SearchResponse> rolledResponses = Arrays.stream(msearchResponses)_                .skip(1)_                .map(item -> {_                    if (item.isFailure()) {_                        Exception e = item.getFailure()__                        _                        _                        if (e instanceof IndexNotFoundException) {_                            logger.warn("Rollup index not found during rollup search.", e)__                        } else {_                            throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                        }_                        return null__                    } else {_                        return item.getResponse()__                    }_                }).filter(Objects::nonNull).collect(Collectors.toList())___        _        if (rolledResponses.isEmpty() && liveMissing == false) {_            return verifyResponse(liveResponse)__        } else if (rolledResponses.isEmpty() && liveMissing) {_            throw new RuntimeException("No indices (live or rollup) found during rollup search")__        }__        return doCombineResponse(liveResponse.getResponse(), rolledResponses, reduceContext)__    };combines,an,msearch,with,rollup,live,aggregations,into,a,search,response,representing,the,union,of,the,two,responses,the,response,format,is,identical,to,a,non,rollup,search,response,aka,a,normal,aggregation,response,if,the,msearch,response,returns,the,following,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,0,took,205,false,hits,aggregations,1,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1,value,19995,0,histo,value,1,0e9,pre,it,would,be,collapsed,into,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1000000000,value,19995,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,pre,it,essentially,takes,the,conventions,listed,in,link,rollup,request,translator,and,processes,them,so,that,the,final,product,looks,like,a,regular,aggregation,response,allowing,it,to,be,reduced,merged,into,the,response,from,the,un,rolled,index,param,msearch,responses,the,responses,from,the,msearch,where,the,first,response,is,the,live,index,response;public,static,search,response,combine,responses,multi,search,response,item,msearch,responses,internal,aggregation,reduce,context,reduce,context,boolean,live,missing,false,assert,msearch,responses,length,2,multi,search,response,item,live,response,msearch,responses,0,if,live,response,is,failure,exception,e,live,response,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,live,index,not,found,during,rollup,search,e,live,missing,true,else,throw,new,runtime,exception,live,response,get,failure,message,live,response,get,failure,list,search,response,rolled,responses,arrays,stream,msearch,responses,skip,1,map,item,if,item,is,failure,exception,e,item,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,rollup,index,not,found,during,rollup,search,e,else,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,null,else,return,item,get,response,filter,objects,non,null,collect,collectors,to,list,if,rolled,responses,is,empty,live,missing,false,return,verify,response,live,response,else,if,rolled,responses,is,empty,live,missing,throw,new,runtime,exception,no,indices,live,or,rollup,found,during,rollup,search,return,do,combine,response,live,response,get,response,rolled,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,                                                   InternalAggregation.ReduceContext reduceContext);1536314350;Combines an msearch with rollup + live aggregations into a SearchResponse_representing the union of the two responses.  The response format is identical to_a non-rollup search response (aka a "normal aggregation" response).__If the MSearch Response returns the following:__<pre>{@code___"took":228,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"histo":{_"buckets":[__"key_as_string":"2017-05-15T00:00:00.000Z",_"key":1494806400000,_"doc_count":1,_"the_max":{_"value":1.0________"took":205,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"filter_histo":{_"doc_count":1,_"histo":{_"buckets":[__"key_as_string":"2017-05-14T00:00:00.000Z",_"key":1494720000000,_"doc_count":1,_"the_max":{_"value":19995.0__"histo._count":{_"value":1.0E9________}</pre>__It would be collapsed into:__<pre>{@code__"took": 228,_"timed_out": false,_"_shards": {...},_"hits": {...},_"aggregations": {_"histo": {_"buckets": [__"key_as_string": "2017-05-14T00:00:00.000Z",_"key": 1494720000000,_"doc_count": 1000000000,_"the_max": {_"value": 19995____"key_as_string": "2017-05-15T00:00:00.000Z",_"key": 1494806400000,_"doc_count": 1,_"the_max": {_"value": 1_______}</pre>__It essentially takes the conventions listed in {@link RollupRequestTranslator} and processes them_so that the final product looks like a regular aggregation response, allowing it to be_reduced/merged into the response from the un-rolled index__@param msearchResponses The responses from the msearch, where the first response is the live-index response;public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,_                                                  InternalAggregation.ReduceContext reduceContext) {_        boolean liveMissing = false__        assert msearchResponses.length >= 2___        _        MultiSearchResponse.Item liveResponse = msearchResponses[0]__        if (liveResponse.isFailure()) {_            Exception e = liveResponse.getFailure()__            _            if (e instanceof IndexNotFoundException) {_                logger.warn("\"Live\" index not found during rollup search.", e)__                liveMissing = true__            } else {_                throw new RuntimeException(liveResponse.getFailureMessage(), liveResponse.getFailure())__            }_        }_        List<SearchResponse> rolledResponses = Arrays.stream(msearchResponses)_                .skip(1)_                .map(item -> {_                    if (item.isFailure()) {_                        Exception e = item.getFailure()__                        _                        _                        if (e instanceof IndexNotFoundException) {_                            logger.warn("Rollup index not found during rollup search.", e)__                        } else {_                            throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                        }_                        return null__                    } else {_                        return item.getResponse()__                    }_                }).filter(Objects::nonNull).collect(Collectors.toList())___        _        if (rolledResponses.isEmpty() && liveMissing == false) {_            return verifyResponse(liveResponse)__        } else if (rolledResponses.isEmpty() && liveMissing) {_            throw new RuntimeException("No indices (live or rollup) found during rollup search")__        }__        return doCombineResponse(liveResponse.getResponse(), rolledResponses, reduceContext)__    };combines,an,msearch,with,rollup,live,aggregations,into,a,search,response,representing,the,union,of,the,two,responses,the,response,format,is,identical,to,a,non,rollup,search,response,aka,a,normal,aggregation,response,if,the,msearch,response,returns,the,following,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,0,took,205,false,hits,aggregations,1,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1,value,19995,0,histo,value,1,0e9,pre,it,would,be,collapsed,into,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1000000000,value,19995,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,pre,it,essentially,takes,the,conventions,listed,in,link,rollup,request,translator,and,processes,them,so,that,the,final,product,looks,like,a,regular,aggregation,response,allowing,it,to,be,reduced,merged,into,the,response,from,the,un,rolled,index,param,msearch,responses,the,responses,from,the,msearch,where,the,first,response,is,the,live,index,response;public,static,search,response,combine,responses,multi,search,response,item,msearch,responses,internal,aggregation,reduce,context,reduce,context,boolean,live,missing,false,assert,msearch,responses,length,2,multi,search,response,item,live,response,msearch,responses,0,if,live,response,is,failure,exception,e,live,response,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,live,index,not,found,during,rollup,search,e,live,missing,true,else,throw,new,runtime,exception,live,response,get,failure,message,live,response,get,failure,list,search,response,rolled,responses,arrays,stream,msearch,responses,skip,1,map,item,if,item,is,failure,exception,e,item,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,rollup,index,not,found,during,rollup,search,e,else,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,null,else,return,item,get,response,filter,objects,non,null,collect,collectors,to,list,if,rolled,responses,is,empty,live,missing,false,return,verify,response,live,response,else,if,rolled,responses,is,empty,live,missing,throw,new,runtime,exception,no,indices,live,or,rollup,found,during,rollup,search,return,do,combine,response,live,response,get,response,rolled,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,                                                   InternalAggregation.ReduceContext reduceContext);1539951844;Combines an msearch with rollup + live aggregations into a SearchResponse_representing the union of the two responses.  The response format is identical to_a non-rollup search response (aka a "normal aggregation" response).__If the MSearch Response returns the following:__<pre>{@code___"took":228,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"histo":{_"buckets":[__"key_as_string":"2017-05-15T00:00:00.000Z",_"key":1494806400000,_"doc_count":1,_"the_max":{_"value":1.0________"took":205,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"filter_histo":{_"doc_count":1,_"histo":{_"buckets":[__"key_as_string":"2017-05-14T00:00:00.000Z",_"key":1494720000000,_"doc_count":1,_"the_max":{_"value":19995.0__"histo._count":{_"value":1.0E9________}</pre>__It would be collapsed into:__<pre>{@code__"took": 228,_"timed_out": false,_"_shards": {...},_"hits": {...},_"aggregations": {_"histo": {_"buckets": [__"key_as_string": "2017-05-14T00:00:00.000Z",_"key": 1494720000000,_"doc_count": 1000000000,_"the_max": {_"value": 19995____"key_as_string": "2017-05-15T00:00:00.000Z",_"key": 1494806400000,_"doc_count": 1,_"the_max": {_"value": 1_______}</pre>__It essentially takes the conventions listed in {@link RollupRequestTranslator} and processes them_so that the final product looks like a regular aggregation response, allowing it to be_reduced/merged into the response from the un-rolled index__@param msearchResponses The responses from the msearch, where the first response is the live-index response;public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,_                                                  InternalAggregation.ReduceContext reduceContext) {_        boolean liveMissing = false__        assert msearchResponses.length >= 2___        _        MultiSearchResponse.Item liveResponse = msearchResponses[0]__        if (liveResponse.isFailure()) {_            Exception e = liveResponse.getFailure()__            _            if (e instanceof IndexNotFoundException) {_                logger.warn("\"Live\" index not found during rollup search.", e)__                liveMissing = true__            } else {_                throw new RuntimeException(liveResponse.getFailureMessage(), liveResponse.getFailure())__            }_        }_        List<SearchResponse> rolledResponses = Arrays.stream(msearchResponses)_                .skip(1)_                .map(item -> {_                    if (item.isFailure()) {_                        Exception e = item.getFailure()__                        _                        _                        if (e instanceof IndexNotFoundException) {_                            logger.warn("Rollup index not found during rollup search.", e)__                        } else {_                            throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                        }_                        return null__                    } else {_                        return item.getResponse()__                    }_                }).filter(Objects::nonNull).collect(Collectors.toList())___        _        if (rolledResponses.isEmpty() && liveMissing == false) {_            return verifyResponse(liveResponse)__        } else if (rolledResponses.isEmpty() && liveMissing) {_            throw new RuntimeException("No indices (live or rollup) found during rollup search")__        }__        return doCombineResponse(liveResponse.getResponse(), rolledResponses, reduceContext)__    };combines,an,msearch,with,rollup,live,aggregations,into,a,search,response,representing,the,union,of,the,two,responses,the,response,format,is,identical,to,a,non,rollup,search,response,aka,a,normal,aggregation,response,if,the,msearch,response,returns,the,following,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,0,took,205,false,hits,aggregations,1,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1,value,19995,0,histo,value,1,0e9,pre,it,would,be,collapsed,into,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1000000000,value,19995,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,pre,it,essentially,takes,the,conventions,listed,in,link,rollup,request,translator,and,processes,them,so,that,the,final,product,looks,like,a,regular,aggregation,response,allowing,it,to,be,reduced,merged,into,the,response,from,the,un,rolled,index,param,msearch,responses,the,responses,from,the,msearch,where,the,first,response,is,the,live,index,response;public,static,search,response,combine,responses,multi,search,response,item,msearch,responses,internal,aggregation,reduce,context,reduce,context,boolean,live,missing,false,assert,msearch,responses,length,2,multi,search,response,item,live,response,msearch,responses,0,if,live,response,is,failure,exception,e,live,response,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,live,index,not,found,during,rollup,search,e,live,missing,true,else,throw,new,runtime,exception,live,response,get,failure,message,live,response,get,failure,list,search,response,rolled,responses,arrays,stream,msearch,responses,skip,1,map,item,if,item,is,failure,exception,e,item,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,rollup,index,not,found,during,rollup,search,e,else,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,null,else,return,item,get,response,filter,objects,non,null,collect,collectors,to,list,if,rolled,responses,is,empty,live,missing,false,return,verify,response,live,response,else,if,rolled,responses,is,empty,live,missing,throw,new,runtime,exception,no,indices,live,or,rollup,found,during,rollup,search,return,do,combine,response,live,response,get,response,rolled,responses,reduce,context
RollupResponseTranslator -> public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,                                                   InternalAggregation.ReduceContext reduceContext);1540847035;Combines an msearch with rollup + live aggregations into a SearchResponse_representing the union of the two responses.  The response format is identical to_a non-rollup search response (aka a "normal aggregation" response).__If the MSearch Response returns the following:__<pre>{@code___"took":228,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"histo":{_"buckets":[__"key_as_string":"2017-05-15T00:00:00.000Z",_"key":1494806400000,_"doc_count":1,_"the_max":{_"value":1.0________"took":205,_"timed_out":false,_"_shards":{...},_"hits":{...},_"aggregations":{_"filter_histo":{_"doc_count":1,_"histo":{_"buckets":[__"key_as_string":"2017-05-14T00:00:00.000Z",_"key":1494720000000,_"doc_count":1,_"the_max":{_"value":19995.0__"histo._count":{_"value":1.0E9________}</pre>__It would be collapsed into:__<pre>{@code__"took": 228,_"timed_out": false,_"_shards": {...},_"hits": {...},_"aggregations": {_"histo": {_"buckets": [__"key_as_string": "2017-05-14T00:00:00.000Z",_"key": 1494720000000,_"doc_count": 1000000000,_"the_max": {_"value": 19995____"key_as_string": "2017-05-15T00:00:00.000Z",_"key": 1494806400000,_"doc_count": 1,_"the_max": {_"value": 1_______}</pre>__It essentially takes the conventions listed in {@link RollupRequestTranslator} and processes them_so that the final product looks like a regular aggregation response, allowing it to be_reduced/merged into the response from the un-rolled index__@param msearchResponses The responses from the msearch, where the first response is the live-index response;public static SearchResponse combineResponses(MultiSearchResponse.Item[] msearchResponses,_                                                  InternalAggregation.ReduceContext reduceContext) {_        boolean liveMissing = false__        assert msearchResponses.length >= 2___        _        MultiSearchResponse.Item liveResponse = msearchResponses[0]__        if (liveResponse.isFailure()) {_            Exception e = liveResponse.getFailure()__            _            if (e instanceof IndexNotFoundException) {_                logger.warn("\"Live\" index not found during rollup search.", e)__                liveMissing = true__            } else {_                throw new RuntimeException(liveResponse.getFailureMessage(), liveResponse.getFailure())__            }_        }_        List<SearchResponse> rolledResponses = Arrays.stream(msearchResponses)_                .skip(1)_                .map(item -> {_                    if (item.isFailure()) {_                        Exception e = item.getFailure()__                        _                        _                        if (e instanceof IndexNotFoundException) {_                            logger.warn("Rollup index not found during rollup search.", e)__                        } else {_                            throw new RuntimeException(item.getFailureMessage(), item.getFailure())__                        }_                        return null__                    } else {_                        return item.getResponse()__                    }_                }).filter(Objects::nonNull).collect(Collectors.toList())___        _        if (rolledResponses.isEmpty() && liveMissing == false) {_            return verifyResponse(liveResponse)__        } else if (rolledResponses.isEmpty() && liveMissing) {_            throw new RuntimeException("No indices (live or rollup) found during rollup search")__        }__        return doCombineResponse(liveResponse.getResponse(), rolledResponses, reduceContext)__    };combines,an,msearch,with,rollup,live,aggregations,into,a,search,response,representing,the,union,of,the,two,responses,the,response,format,is,identical,to,a,non,rollup,search,response,aka,a,normal,aggregation,response,if,the,msearch,response,returns,the,following,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,0,took,205,false,hits,aggregations,1,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1,value,19995,0,histo,value,1,0e9,pre,it,would,be,collapsed,into,pre,code,took,228,false,hits,aggregations,histo,buckets,2017,05,14t00,00,00,000z,key,1494720000000,1000000000,value,19995,2017,05,15t00,00,00,000z,key,1494806400000,1,value,1,pre,it,essentially,takes,the,conventions,listed,in,link,rollup,request,translator,and,processes,them,so,that,the,final,product,looks,like,a,regular,aggregation,response,allowing,it,to,be,reduced,merged,into,the,response,from,the,un,rolled,index,param,msearch,responses,the,responses,from,the,msearch,where,the,first,response,is,the,live,index,response;public,static,search,response,combine,responses,multi,search,response,item,msearch,responses,internal,aggregation,reduce,context,reduce,context,boolean,live,missing,false,assert,msearch,responses,length,2,multi,search,response,item,live,response,msearch,responses,0,if,live,response,is,failure,exception,e,live,response,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,live,index,not,found,during,rollup,search,e,live,missing,true,else,throw,new,runtime,exception,live,response,get,failure,message,live,response,get,failure,list,search,response,rolled,responses,arrays,stream,msearch,responses,skip,1,map,item,if,item,is,failure,exception,e,item,get,failure,if,e,instanceof,index,not,found,exception,logger,warn,rollup,index,not,found,during,rollup,search,e,else,throw,new,runtime,exception,item,get,failure,message,item,get,failure,return,null,else,return,item,get,response,filter,objects,non,null,collect,collectors,to,list,if,rolled,responses,is,empty,live,missing,false,return,verify,response,live,response,else,if,rolled,responses,is,empty,live,missing,throw,new,runtime,exception,no,indices,live,or,rollup,found,during,rollup,search,return,do,combine,response,live,response,get,response,rolled,responses,reduce,context
RollupResponseTranslator -> private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree);1524684173;Generic method to help iterate over sub-aggregation buckets and recursively unroll__@param bucket The current bucket that we wish to unroll;private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree) {_        _        return new InternalAggregations(bucket.getAggregations()_                .asList().stream()_                _                _                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(subAgg -> {__                    long count = getAggCount(subAgg, bucket.getAggregations().asMap())___                    InternalAggregation originalSubAgg = null__                    if (original != null && original.getAggregations() != null) {_                        originalSubAgg = original.getAggregations().get(subAgg.getName())__                    }__                    InternalAggregation currentSubAgg = null__                    if (currentTree != null && currentTree.getAggregations() != null) {_                        currentSubAgg = currentTree.getAggregations().get(subAgg.getName())__                    }__                    return unrollAgg((InternalAggregation) subAgg, originalSubAgg, currentSubAgg, count)__                }).collect(Collectors.toList()))__    };generic,method,to,help,iterate,over,sub,aggregation,buckets,and,recursively,unroll,param,bucket,the,current,bucket,that,we,wish,to,unroll;private,static,internal,aggregations,unroll,sub,aggs,from,multi,internal,bucket,bucket,internal,bucket,original,internal,bucket,current,tree,return,new,internal,aggregations,bucket,get,aggregations,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,sub,agg,long,count,get,agg,count,sub,agg,bucket,get,aggregations,as,map,internal,aggregation,original,sub,agg,null,if,original,null,original,get,aggregations,null,original,sub,agg,original,get,aggregations,get,sub,agg,get,name,internal,aggregation,current,sub,agg,null,if,current,tree,null,current,tree,get,aggregations,null,current,sub,agg,current,tree,get,aggregations,get,sub,agg,get,name,return,unroll,agg,internal,aggregation,sub,agg,original,sub,agg,current,sub,agg,count,collect,collectors,to,list
RollupResponseTranslator -> private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree);1528762805;Generic method to help iterate over sub-aggregation buckets and recursively unroll__@param bucket The current bucket that we wish to unroll;private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree) {_        _        return new InternalAggregations(bucket.getAggregations()_                .asList().stream()_                _                _                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(subAgg -> {__                    long count = getAggCount(subAgg, bucket.getAggregations().asMap())___                    InternalAggregation originalSubAgg = null__                    if (original != null && original.getAggregations() != null) {_                        originalSubAgg = original.getAggregations().get(subAgg.getName())__                    }__                    InternalAggregation currentSubAgg = null__                    if (currentTree != null && currentTree.getAggregations() != null) {_                        currentSubAgg = currentTree.getAggregations().get(subAgg.getName())__                    }__                    return unrollAgg((InternalAggregation) subAgg, originalSubAgg, currentSubAgg, count)__                }).collect(Collectors.toList()))__    };generic,method,to,help,iterate,over,sub,aggregation,buckets,and,recursively,unroll,param,bucket,the,current,bucket,that,we,wish,to,unroll;private,static,internal,aggregations,unroll,sub,aggs,from,multi,internal,bucket,bucket,internal,bucket,original,internal,bucket,current,tree,return,new,internal,aggregations,bucket,get,aggregations,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,sub,agg,long,count,get,agg,count,sub,agg,bucket,get,aggregations,as,map,internal,aggregation,original,sub,agg,null,if,original,null,original,get,aggregations,null,original,sub,agg,original,get,aggregations,get,sub,agg,get,name,internal,aggregation,current,sub,agg,null,if,current,tree,null,current,tree,get,aggregations,null,current,sub,agg,current,tree,get,aggregations,get,sub,agg,get,name,return,unroll,agg,internal,aggregation,sub,agg,original,sub,agg,current,sub,agg,count,collect,collectors,to,list
RollupResponseTranslator -> private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree);1531729807;Generic method to help iterate over sub-aggregation buckets and recursively unroll__@param bucket The current bucket that we wish to unroll;private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree) {_        _        return new InternalAggregations(bucket.getAggregations()_                .asList().stream()_                _                _                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(subAgg -> {__                    long count = getAggCount(subAgg, bucket.getAggregations().asMap())___                    InternalAggregation originalSubAgg = null__                    if (original != null && original.getAggregations() != null) {_                        originalSubAgg = original.getAggregations().get(subAgg.getName())__                    }__                    InternalAggregation currentSubAgg = null__                    if (currentTree != null && currentTree.getAggregations() != null) {_                        currentSubAgg = currentTree.getAggregations().get(subAgg.getName())__                    }__                    return unrollAgg((InternalAggregation) subAgg, originalSubAgg, currentSubAgg, count)__                }).collect(Collectors.toList()))__    };generic,method,to,help,iterate,over,sub,aggregation,buckets,and,recursively,unroll,param,bucket,the,current,bucket,that,we,wish,to,unroll;private,static,internal,aggregations,unroll,sub,aggs,from,multi,internal,bucket,bucket,internal,bucket,original,internal,bucket,current,tree,return,new,internal,aggregations,bucket,get,aggregations,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,sub,agg,long,count,get,agg,count,sub,agg,bucket,get,aggregations,as,map,internal,aggregation,original,sub,agg,null,if,original,null,original,get,aggregations,null,original,sub,agg,original,get,aggregations,get,sub,agg,get,name,internal,aggregation,current,sub,agg,null,if,current,tree,null,current,tree,get,aggregations,null,current,sub,agg,current,tree,get,aggregations,get,sub,agg,get,name,return,unroll,agg,internal,aggregation,sub,agg,original,sub,agg,current,sub,agg,count,collect,collectors,to,list
RollupResponseTranslator -> private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree);1535057785;Generic method to help iterate over sub-aggregation buckets and recursively unroll__@param bucket The current bucket that we wish to unroll;private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree) {_        _        return new InternalAggregations(bucket.getAggregations()_                .asList().stream()_                _                _                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(subAgg -> {__                    long count = getAggCount(subAgg, bucket.getAggregations().asMap())___                    InternalAggregation originalSubAgg = null__                    if (original != null && original.getAggregations() != null) {_                        originalSubAgg = original.getAggregations().get(subAgg.getName())__                    }__                    InternalAggregation currentSubAgg = null__                    if (currentTree != null && currentTree.getAggregations() != null) {_                        currentSubAgg = currentTree.getAggregations().get(subAgg.getName())__                    }__                    return unrollAgg((InternalAggregation) subAgg, originalSubAgg, currentSubAgg, count)__                }).collect(Collectors.toList()))__    };generic,method,to,help,iterate,over,sub,aggregation,buckets,and,recursively,unroll,param,bucket,the,current,bucket,that,we,wish,to,unroll;private,static,internal,aggregations,unroll,sub,aggs,from,multi,internal,bucket,bucket,internal,bucket,original,internal,bucket,current,tree,return,new,internal,aggregations,bucket,get,aggregations,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,sub,agg,long,count,get,agg,count,sub,agg,bucket,get,aggregations,as,map,internal,aggregation,original,sub,agg,null,if,original,null,original,get,aggregations,null,original,sub,agg,original,get,aggregations,get,sub,agg,get,name,internal,aggregation,current,sub,agg,null,if,current,tree,null,current,tree,get,aggregations,null,current,sub,agg,current,tree,get,aggregations,get,sub,agg,get,name,return,unroll,agg,internal,aggregation,sub,agg,original,sub,agg,current,sub,agg,count,collect,collectors,to,list
RollupResponseTranslator -> private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree);1536314350;Generic method to help iterate over sub-aggregation buckets and recursively unroll__@param bucket The current bucket that we wish to unroll;private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree) {_        _        return new InternalAggregations(bucket.getAggregations()_                .asList().stream()_                _                _                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(subAgg -> {__                    long count = getAggCount(subAgg, bucket.getAggregations().asMap())___                    InternalAggregation originalSubAgg = null__                    if (original != null && original.getAggregations() != null) {_                        originalSubAgg = original.getAggregations().get(subAgg.getName())__                    }__                    InternalAggregation currentSubAgg = null__                    if (currentTree != null && currentTree.getAggregations() != null) {_                        currentSubAgg = currentTree.getAggregations().get(subAgg.getName())__                    }__                    return unrollAgg((InternalAggregation) subAgg, originalSubAgg, currentSubAgg, count)__                }).collect(Collectors.toList()))__    };generic,method,to,help,iterate,over,sub,aggregation,buckets,and,recursively,unroll,param,bucket,the,current,bucket,that,we,wish,to,unroll;private,static,internal,aggregations,unroll,sub,aggs,from,multi,internal,bucket,bucket,internal,bucket,original,internal,bucket,current,tree,return,new,internal,aggregations,bucket,get,aggregations,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,sub,agg,long,count,get,agg,count,sub,agg,bucket,get,aggregations,as,map,internal,aggregation,original,sub,agg,null,if,original,null,original,get,aggregations,null,original,sub,agg,original,get,aggregations,get,sub,agg,get,name,internal,aggregation,current,sub,agg,null,if,current,tree,null,current,tree,get,aggregations,null,current,sub,agg,current,tree,get,aggregations,get,sub,agg,get,name,return,unroll,agg,internal,aggregation,sub,agg,original,sub,agg,current,sub,agg,count,collect,collectors,to,list
RollupResponseTranslator -> private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree);1539951844;Generic method to help iterate over sub-aggregation buckets and recursively unroll__@param bucket The current bucket that we wish to unroll;private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree) {_        _        return new InternalAggregations(bucket.getAggregations()_                .asList().stream()_                _                _                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(subAgg -> {__                    long count = getAggCount(subAgg, bucket.getAggregations().asMap())___                    InternalAggregation originalSubAgg = null__                    if (original != null && original.getAggregations() != null) {_                        originalSubAgg = original.getAggregations().get(subAgg.getName())__                    }__                    InternalAggregation currentSubAgg = null__                    if (currentTree != null && currentTree.getAggregations() != null) {_                        currentSubAgg = currentTree.getAggregations().get(subAgg.getName())__                    }__                    return unrollAgg((InternalAggregation) subAgg, originalSubAgg, currentSubAgg, count)__                }).collect(Collectors.toList()))__    };generic,method,to,help,iterate,over,sub,aggregation,buckets,and,recursively,unroll,param,bucket,the,current,bucket,that,we,wish,to,unroll;private,static,internal,aggregations,unroll,sub,aggs,from,multi,internal,bucket,bucket,internal,bucket,original,internal,bucket,current,tree,return,new,internal,aggregations,bucket,get,aggregations,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,sub,agg,long,count,get,agg,count,sub,agg,bucket,get,aggregations,as,map,internal,aggregation,original,sub,agg,null,if,original,null,original,get,aggregations,null,original,sub,agg,original,get,aggregations,get,sub,agg,get,name,internal,aggregation,current,sub,agg,null,if,current,tree,null,current,tree,get,aggregations,null,current,sub,agg,current,tree,get,aggregations,get,sub,agg,get,name,return,unroll,agg,internal,aggregation,sub,agg,original,sub,agg,current,sub,agg,count,collect,collectors,to,list
RollupResponseTranslator -> private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree);1540847035;Generic method to help iterate over sub-aggregation buckets and recursively unroll__@param bucket The current bucket that we wish to unroll;private static InternalAggregations unrollSubAggsFromMulti(InternalBucket bucket, InternalBucket original, InternalBucket currentTree) {_        _        return new InternalAggregations(bucket.getAggregations()_                .asList().stream()_                _                _                .filter(subAgg -> !subAgg.getName().endsWith("." + RollupField.COUNT_FIELD))_                .map(subAgg -> {__                    long count = getAggCount(subAgg, bucket.getAggregations().asMap())___                    InternalAggregation originalSubAgg = null__                    if (original != null && original.getAggregations() != null) {_                        originalSubAgg = original.getAggregations().get(subAgg.getName())__                    }__                    InternalAggregation currentSubAgg = null__                    if (currentTree != null && currentTree.getAggregations() != null) {_                        currentSubAgg = currentTree.getAggregations().get(subAgg.getName())__                    }__                    return unrollAgg((InternalAggregation) subAgg, originalSubAgg, currentSubAgg, count)__                }).collect(Collectors.toList()))__    };generic,method,to,help,iterate,over,sub,aggregation,buckets,and,recursively,unroll,param,bucket,the,current,bucket,that,we,wish,to,unroll;private,static,internal,aggregations,unroll,sub,aggs,from,multi,internal,bucket,bucket,internal,bucket,original,internal,bucket,current,tree,return,new,internal,aggregations,bucket,get,aggregations,as,list,stream,filter,sub,agg,sub,agg,get,name,ends,with,rollup,field,map,sub,agg,long,count,get,agg,count,sub,agg,bucket,get,aggregations,as,map,internal,aggregation,original,sub,agg,null,if,original,null,original,get,aggregations,null,original,sub,agg,original,get,aggregations,get,sub,agg,get,name,internal,aggregation,current,sub,agg,null,if,current,tree,null,current,tree,get,aggregations,null,current,sub,agg,current,tree,get,aggregations,get,sub,agg,get,name,return,unroll,agg,internal,aggregation,sub,agg,original,sub,agg,current,sub,agg,count,collect,collectors,to,list
RollupResponseTranslator -> private static <A  extends InternalMultiBucketAggregation,                     B extends InternalBucket,                     T extends InternalMultiBucketAggregation<A, B>>     InternalAggregation unrollMultiBucket(T source, T original, T currentTree,                                           TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory);1524684173;Helper method which unrolls a generic multibucket agg. Prefer to use the other overload_as a consumer of the API__@param source The rolled aggregation that we wish to unroll_@param bucketFactory A Trifunction which generates new buckets for the given type of multibucket;private static <A  extends InternalMultiBucketAggregation,_                    B extends InternalBucket,_                    T extends InternalMultiBucketAggregation<A, B>>_    InternalAggregation unrollMultiBucket(T source, T original, T currentTree,_                                          TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory) {__        Map<Object, InternalBucket> originalKeys = new HashMap<>()__        Map<Object, InternalBucket> currentKeys = new HashMap<>()___        if (original != null) {_            original.getBuckets().forEach(b -> originalKeys.put(b.getKey(), b))__        }__        if (currentTree != null) {_            currentTree.getBuckets().forEach(b -> currentKeys.put(b.getKey(), b))__        }__        _        List<B> buckets = source.getBuckets()_                .stream()_                .filter(b -> originalKeys.containsKey(b.getKey()) == false) _                .map(bucket -> {__                    _                    long bucketCount = getAggCount(source, bucket.getAggregations().getAsMap())___                    _                    if (bucketCount == 0) {_                        return null__                    }__                    _                    if (currentKeys.containsKey(bucket.getKey()) && currentKeys.get(bucket.getKey()).getDocCount() != 0) {_                        _                        _                        bucketCount = 0__                    }__                    _                    InternalAggregations subAggs = unrollSubAggsFromMulti(bucket, originalKeys.get(bucket.getKey()),_                            currentKeys.get(bucket.getKey()))___                    return bucketFactory.apply(bucket, bucketCount, subAggs)__                })_                .filter(Objects::nonNull)_                .collect(Collectors.toList())__        return source.create(buckets)__    };helper,method,which,unrolls,a,generic,multibucket,agg,prefer,to,use,the,other,overload,as,a,consumer,of,the,api,param,source,the,rolled,aggregation,that,we,wish,to,unroll,param,bucket,factory,a,trifunction,which,generates,new,buckets,for,the,given,type,of,multibucket;private,static,a,extends,internal,multi,bucket,aggregation,b,extends,internal,bucket,t,extends,internal,multi,bucket,aggregation,a,b,internal,aggregation,unroll,multi,bucket,t,source,t,original,t,current,tree,tri,function,internal,bucket,long,internal,aggregations,b,bucket,factory,map,object,internal,bucket,original,keys,new,hash,map,map,object,internal,bucket,current,keys,new,hash,map,if,original,null,original,get,buckets,for,each,b,original,keys,put,b,get,key,b,if,current,tree,null,current,tree,get,buckets,for,each,b,current,keys,put,b,get,key,b,list,b,buckets,source,get,buckets,stream,filter,b,original,keys,contains,key,b,get,key,false,map,bucket,long,bucket,count,get,agg,count,source,bucket,get,aggregations,get,as,map,if,bucket,count,0,return,null,if,current,keys,contains,key,bucket,get,key,current,keys,get,bucket,get,key,get,doc,count,0,bucket,count,0,internal,aggregations,sub,aggs,unroll,sub,aggs,from,multi,bucket,original,keys,get,bucket,get,key,current,keys,get,bucket,get,key,return,bucket,factory,apply,bucket,bucket,count,sub,aggs,filter,objects,non,null,collect,collectors,to,list,return,source,create,buckets
RollupResponseTranslator -> private static <A  extends InternalMultiBucketAggregation,                     B extends InternalBucket,                     T extends InternalMultiBucketAggregation<A, B>>     InternalAggregation unrollMultiBucket(T source, T original, T currentTree,                                           TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory);1528762805;Helper method which unrolls a generic multibucket agg. Prefer to use the other overload_as a consumer of the API__@param source The rolled aggregation that we wish to unroll_@param bucketFactory A Trifunction which generates new buckets for the given type of multibucket;private static <A  extends InternalMultiBucketAggregation,_                    B extends InternalBucket,_                    T extends InternalMultiBucketAggregation<A, B>>_    InternalAggregation unrollMultiBucket(T source, T original, T currentTree,_                                          TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory) {__        Map<Object, InternalBucket> originalKeys = new HashMap<>()__        Map<Object, InternalBucket> currentKeys = new HashMap<>()___        if (original != null) {_            original.getBuckets().forEach(b -> originalKeys.put(b.getKey(), b))__        }__        if (currentTree != null) {_            currentTree.getBuckets().forEach(b -> currentKeys.put(b.getKey(), b))__        }__        _        List<B> buckets = source.getBuckets()_                .stream()_                .filter(b -> originalKeys.containsKey(b.getKey()) == false) _                .map(bucket -> {__                    _                    long bucketCount = getAggCount(source, bucket.getAggregations().getAsMap())___                    _                    if (bucketCount == 0) {_                        return null__                    }__                    _                    if (currentKeys.containsKey(bucket.getKey()) && currentKeys.get(bucket.getKey()).getDocCount() != 0) {_                        _                        _                        bucketCount = 0__                    }__                    _                    InternalAggregations subAggs = unrollSubAggsFromMulti(bucket, originalKeys.get(bucket.getKey()),_                            currentKeys.get(bucket.getKey()))___                    return bucketFactory.apply(bucket, bucketCount, subAggs)__                })_                .filter(Objects::nonNull)_                .collect(Collectors.toList())__        return source.create(buckets)__    };helper,method,which,unrolls,a,generic,multibucket,agg,prefer,to,use,the,other,overload,as,a,consumer,of,the,api,param,source,the,rolled,aggregation,that,we,wish,to,unroll,param,bucket,factory,a,trifunction,which,generates,new,buckets,for,the,given,type,of,multibucket;private,static,a,extends,internal,multi,bucket,aggregation,b,extends,internal,bucket,t,extends,internal,multi,bucket,aggregation,a,b,internal,aggregation,unroll,multi,bucket,t,source,t,original,t,current,tree,tri,function,internal,bucket,long,internal,aggregations,b,bucket,factory,map,object,internal,bucket,original,keys,new,hash,map,map,object,internal,bucket,current,keys,new,hash,map,if,original,null,original,get,buckets,for,each,b,original,keys,put,b,get,key,b,if,current,tree,null,current,tree,get,buckets,for,each,b,current,keys,put,b,get,key,b,list,b,buckets,source,get,buckets,stream,filter,b,original,keys,contains,key,b,get,key,false,map,bucket,long,bucket,count,get,agg,count,source,bucket,get,aggregations,get,as,map,if,bucket,count,0,return,null,if,current,keys,contains,key,bucket,get,key,current,keys,get,bucket,get,key,get,doc,count,0,bucket,count,0,internal,aggregations,sub,aggs,unroll,sub,aggs,from,multi,bucket,original,keys,get,bucket,get,key,current,keys,get,bucket,get,key,return,bucket,factory,apply,bucket,bucket,count,sub,aggs,filter,objects,non,null,collect,collectors,to,list,return,source,create,buckets
RollupResponseTranslator -> private static <A  extends InternalMultiBucketAggregation,                     B extends InternalBucket,                     T extends InternalMultiBucketAggregation<A, B>>     InternalAggregation unrollMultiBucket(T source, T original, T currentTree,                                           TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory);1531729807;Helper method which unrolls a generic multibucket agg. Prefer to use the other overload_as a consumer of the API__@param source The rolled aggregation that we wish to unroll_@param bucketFactory A Trifunction which generates new buckets for the given type of multibucket;private static <A  extends InternalMultiBucketAggregation,_                    B extends InternalBucket,_                    T extends InternalMultiBucketAggregation<A, B>>_    InternalAggregation unrollMultiBucket(T source, T original, T currentTree,_                                          TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory) {__        Map<Object, InternalBucket> originalKeys = new HashMap<>()__        Map<Object, InternalBucket> currentKeys = new HashMap<>()___        if (original != null) {_            original.getBuckets().forEach(b -> originalKeys.put(b.getKey(), b))__        }__        if (currentTree != null) {_            currentTree.getBuckets().forEach(b -> currentKeys.put(b.getKey(), b))__        }__        _        List<B> buckets = source.getBuckets()_                .stream()_                .filter(b -> originalKeys.containsKey(b.getKey()) == false) _                .map(bucket -> {__                    _                    long bucketCount = getAggCount(source, bucket.getAggregations().getAsMap())___                    _                    if (bucketCount == 0) {_                        return null__                    }__                    _                    if (currentKeys.containsKey(bucket.getKey()) && currentKeys.get(bucket.getKey()).getDocCount() != 0) {_                        _                        _                        bucketCount = 0__                    }__                    _                    InternalAggregations subAggs = unrollSubAggsFromMulti(bucket, originalKeys.get(bucket.getKey()),_                            currentKeys.get(bucket.getKey()))___                    return bucketFactory.apply(bucket, bucketCount, subAggs)__                })_                .filter(Objects::nonNull)_                .collect(Collectors.toList())__        return source.create(buckets)__    };helper,method,which,unrolls,a,generic,multibucket,agg,prefer,to,use,the,other,overload,as,a,consumer,of,the,api,param,source,the,rolled,aggregation,that,we,wish,to,unroll,param,bucket,factory,a,trifunction,which,generates,new,buckets,for,the,given,type,of,multibucket;private,static,a,extends,internal,multi,bucket,aggregation,b,extends,internal,bucket,t,extends,internal,multi,bucket,aggregation,a,b,internal,aggregation,unroll,multi,bucket,t,source,t,original,t,current,tree,tri,function,internal,bucket,long,internal,aggregations,b,bucket,factory,map,object,internal,bucket,original,keys,new,hash,map,map,object,internal,bucket,current,keys,new,hash,map,if,original,null,original,get,buckets,for,each,b,original,keys,put,b,get,key,b,if,current,tree,null,current,tree,get,buckets,for,each,b,current,keys,put,b,get,key,b,list,b,buckets,source,get,buckets,stream,filter,b,original,keys,contains,key,b,get,key,false,map,bucket,long,bucket,count,get,agg,count,source,bucket,get,aggregations,get,as,map,if,bucket,count,0,return,null,if,current,keys,contains,key,bucket,get,key,current,keys,get,bucket,get,key,get,doc,count,0,bucket,count,0,internal,aggregations,sub,aggs,unroll,sub,aggs,from,multi,bucket,original,keys,get,bucket,get,key,current,keys,get,bucket,get,key,return,bucket,factory,apply,bucket,bucket,count,sub,aggs,filter,objects,non,null,collect,collectors,to,list,return,source,create,buckets
RollupResponseTranslator -> private static <A  extends InternalMultiBucketAggregation,                     B extends InternalBucket,                     T extends InternalMultiBucketAggregation<A, B>>     InternalAggregation unrollMultiBucket(T source, T original, T currentTree,                                           TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory);1535057785;Helper method which unrolls a generic multibucket agg. Prefer to use the other overload_as a consumer of the API__@param source The rolled aggregation that we wish to unroll_@param bucketFactory A Trifunction which generates new buckets for the given type of multibucket;private static <A  extends InternalMultiBucketAggregation,_                    B extends InternalBucket,_                    T extends InternalMultiBucketAggregation<A, B>>_    InternalAggregation unrollMultiBucket(T source, T original, T currentTree,_                                          TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory) {__        Map<Object, InternalBucket> originalKeys = new HashMap<>()__        Map<Object, InternalBucket> currentKeys = new HashMap<>()___        if (original != null) {_            original.getBuckets().forEach(b -> originalKeys.put(b.getKey(), b))__        }__        if (currentTree != null) {_            currentTree.getBuckets().forEach(b -> currentKeys.put(b.getKey(), b))__        }__        _        List<B> buckets = source.getBuckets()_                .stream()_                .filter(b -> originalKeys.containsKey(b.getKey()) == false) _                .map(bucket -> {__                    _                    long bucketCount = getAggCount(source, bucket.getAggregations().getAsMap())___                    _                    if (bucketCount == 0) {_                        return null__                    }__                    _                    if (currentKeys.containsKey(bucket.getKey()) && currentKeys.get(bucket.getKey()).getDocCount() != 0) {_                        _                        _                        bucketCount = 0__                    }__                    _                    InternalAggregations subAggs = unrollSubAggsFromMulti(bucket, originalKeys.get(bucket.getKey()),_                            currentKeys.get(bucket.getKey()))___                    return bucketFactory.apply(bucket, bucketCount, subAggs)__                })_                .filter(Objects::nonNull)_                .collect(Collectors.toList())__        return source.create(buckets)__    };helper,method,which,unrolls,a,generic,multibucket,agg,prefer,to,use,the,other,overload,as,a,consumer,of,the,api,param,source,the,rolled,aggregation,that,we,wish,to,unroll,param,bucket,factory,a,trifunction,which,generates,new,buckets,for,the,given,type,of,multibucket;private,static,a,extends,internal,multi,bucket,aggregation,b,extends,internal,bucket,t,extends,internal,multi,bucket,aggregation,a,b,internal,aggregation,unroll,multi,bucket,t,source,t,original,t,current,tree,tri,function,internal,bucket,long,internal,aggregations,b,bucket,factory,map,object,internal,bucket,original,keys,new,hash,map,map,object,internal,bucket,current,keys,new,hash,map,if,original,null,original,get,buckets,for,each,b,original,keys,put,b,get,key,b,if,current,tree,null,current,tree,get,buckets,for,each,b,current,keys,put,b,get,key,b,list,b,buckets,source,get,buckets,stream,filter,b,original,keys,contains,key,b,get,key,false,map,bucket,long,bucket,count,get,agg,count,source,bucket,get,aggregations,get,as,map,if,bucket,count,0,return,null,if,current,keys,contains,key,bucket,get,key,current,keys,get,bucket,get,key,get,doc,count,0,bucket,count,0,internal,aggregations,sub,aggs,unroll,sub,aggs,from,multi,bucket,original,keys,get,bucket,get,key,current,keys,get,bucket,get,key,return,bucket,factory,apply,bucket,bucket,count,sub,aggs,filter,objects,non,null,collect,collectors,to,list,return,source,create,buckets
RollupResponseTranslator -> private static <A  extends InternalMultiBucketAggregation,                     B extends InternalBucket,                     T extends InternalMultiBucketAggregation<A, B>>     InternalAggregation unrollMultiBucket(T source, T original, T currentTree,                                           TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory);1536314350;Helper method which unrolls a generic multibucket agg. Prefer to use the other overload_as a consumer of the API__@param source The rolled aggregation that we wish to unroll_@param bucketFactory A Trifunction which generates new buckets for the given type of multibucket;private static <A  extends InternalMultiBucketAggregation,_                    B extends InternalBucket,_                    T extends InternalMultiBucketAggregation<A, B>>_    InternalAggregation unrollMultiBucket(T source, T original, T currentTree,_                                          TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory) {__        Map<Object, InternalBucket> originalKeys = new HashMap<>()__        Map<Object, InternalBucket> currentKeys = new HashMap<>()___        if (original != null) {_            original.getBuckets().forEach(b -> originalKeys.put(b.getKey(), b))__        }__        if (currentTree != null) {_            currentTree.getBuckets().forEach(b -> currentKeys.put(b.getKey(), b))__        }__        _        List<B> buckets = source.getBuckets()_                .stream()_                .filter(b -> originalKeys.containsKey(b.getKey()) == false) _                .map(bucket -> {__                    _                    long bucketCount = getAggCount(source, bucket.getAggregations().getAsMap())___                    _                    if (bucketCount == 0) {_                        return null__                    }__                    _                    if (currentKeys.containsKey(bucket.getKey()) && currentKeys.get(bucket.getKey()).getDocCount() != 0) {_                        _                        _                        bucketCount = 0__                    }__                    _                    InternalAggregations subAggs = unrollSubAggsFromMulti(bucket, originalKeys.get(bucket.getKey()),_                            currentKeys.get(bucket.getKey()))___                    return bucketFactory.apply(bucket, bucketCount, subAggs)__                })_                .filter(Objects::nonNull)_                .collect(Collectors.toList())__        return source.create(buckets)__    };helper,method,which,unrolls,a,generic,multibucket,agg,prefer,to,use,the,other,overload,as,a,consumer,of,the,api,param,source,the,rolled,aggregation,that,we,wish,to,unroll,param,bucket,factory,a,trifunction,which,generates,new,buckets,for,the,given,type,of,multibucket;private,static,a,extends,internal,multi,bucket,aggregation,b,extends,internal,bucket,t,extends,internal,multi,bucket,aggregation,a,b,internal,aggregation,unroll,multi,bucket,t,source,t,original,t,current,tree,tri,function,internal,bucket,long,internal,aggregations,b,bucket,factory,map,object,internal,bucket,original,keys,new,hash,map,map,object,internal,bucket,current,keys,new,hash,map,if,original,null,original,get,buckets,for,each,b,original,keys,put,b,get,key,b,if,current,tree,null,current,tree,get,buckets,for,each,b,current,keys,put,b,get,key,b,list,b,buckets,source,get,buckets,stream,filter,b,original,keys,contains,key,b,get,key,false,map,bucket,long,bucket,count,get,agg,count,source,bucket,get,aggregations,get,as,map,if,bucket,count,0,return,null,if,current,keys,contains,key,bucket,get,key,current,keys,get,bucket,get,key,get,doc,count,0,bucket,count,0,internal,aggregations,sub,aggs,unroll,sub,aggs,from,multi,bucket,original,keys,get,bucket,get,key,current,keys,get,bucket,get,key,return,bucket,factory,apply,bucket,bucket,count,sub,aggs,filter,objects,non,null,collect,collectors,to,list,return,source,create,buckets
RollupResponseTranslator -> private static <A  extends InternalMultiBucketAggregation,                     B extends InternalBucket,                     T extends InternalMultiBucketAggregation<A, B>>     InternalAggregation unrollMultiBucket(T source, T original, T currentTree,                                           TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory);1539951844;Helper method which unrolls a generic multibucket agg. Prefer to use the other overload_as a consumer of the API__@param source The rolled aggregation that we wish to unroll_@param bucketFactory A Trifunction which generates new buckets for the given type of multibucket;private static <A  extends InternalMultiBucketAggregation,_                    B extends InternalBucket,_                    T extends InternalMultiBucketAggregation<A, B>>_    InternalAggregation unrollMultiBucket(T source, T original, T currentTree,_                                          TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory) {__        Map<Object, InternalBucket> originalKeys = new HashMap<>()__        Map<Object, InternalBucket> currentKeys = new HashMap<>()___        if (original != null) {_            original.getBuckets().forEach(b -> originalKeys.put(b.getKey(), b))__        }__        if (currentTree != null) {_            currentTree.getBuckets().forEach(b -> currentKeys.put(b.getKey(), b))__        }__        _        List<B> buckets = source.getBuckets()_                .stream()_                .filter(b -> originalKeys.containsKey(b.getKey()) == false) _                .map(bucket -> {__                    _                    long bucketCount = getAggCount(source, bucket.getAggregations().getAsMap())___                    _                    if (bucketCount == 0) {_                        return null__                    }__                    _                    if (currentKeys.containsKey(bucket.getKey()) && currentKeys.get(bucket.getKey()).getDocCount() != 0) {_                        _                        _                        bucketCount = 0__                    }__                    _                    InternalAggregations subAggs = unrollSubAggsFromMulti(bucket, originalKeys.get(bucket.getKey()),_                            currentKeys.get(bucket.getKey()))___                    return bucketFactory.apply(bucket, bucketCount, subAggs)__                })_                .filter(Objects::nonNull)_                .collect(Collectors.toList())__        return source.create(buckets)__    };helper,method,which,unrolls,a,generic,multibucket,agg,prefer,to,use,the,other,overload,as,a,consumer,of,the,api,param,source,the,rolled,aggregation,that,we,wish,to,unroll,param,bucket,factory,a,trifunction,which,generates,new,buckets,for,the,given,type,of,multibucket;private,static,a,extends,internal,multi,bucket,aggregation,b,extends,internal,bucket,t,extends,internal,multi,bucket,aggregation,a,b,internal,aggregation,unroll,multi,bucket,t,source,t,original,t,current,tree,tri,function,internal,bucket,long,internal,aggregations,b,bucket,factory,map,object,internal,bucket,original,keys,new,hash,map,map,object,internal,bucket,current,keys,new,hash,map,if,original,null,original,get,buckets,for,each,b,original,keys,put,b,get,key,b,if,current,tree,null,current,tree,get,buckets,for,each,b,current,keys,put,b,get,key,b,list,b,buckets,source,get,buckets,stream,filter,b,original,keys,contains,key,b,get,key,false,map,bucket,long,bucket,count,get,agg,count,source,bucket,get,aggregations,get,as,map,if,bucket,count,0,return,null,if,current,keys,contains,key,bucket,get,key,current,keys,get,bucket,get,key,get,doc,count,0,bucket,count,0,internal,aggregations,sub,aggs,unroll,sub,aggs,from,multi,bucket,original,keys,get,bucket,get,key,current,keys,get,bucket,get,key,return,bucket,factory,apply,bucket,bucket,count,sub,aggs,filter,objects,non,null,collect,collectors,to,list,return,source,create,buckets
RollupResponseTranslator -> private static <A  extends InternalMultiBucketAggregation,                     B extends InternalBucket,                     T extends InternalMultiBucketAggregation<A, B>>     InternalAggregation unrollMultiBucket(T source, T original, T currentTree,                                           TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory);1540847035;Helper method which unrolls a generic multibucket agg. Prefer to use the other overload_as a consumer of the API__@param source The rolled aggregation that we wish to unroll_@param bucketFactory A Trifunction which generates new buckets for the given type of multibucket;private static <A  extends InternalMultiBucketAggregation,_                    B extends InternalBucket,_                    T extends InternalMultiBucketAggregation<A, B>>_    InternalAggregation unrollMultiBucket(T source, T original, T currentTree,_                                          TriFunction<InternalBucket, Long, InternalAggregations, B> bucketFactory) {__        Map<Object, InternalBucket> originalKeys = new HashMap<>()__        Map<Object, InternalBucket> currentKeys = new HashMap<>()___        if (original != null) {_            original.getBuckets().forEach(b -> originalKeys.put(b.getKey(), b))__        }__        if (currentTree != null) {_            currentTree.getBuckets().forEach(b -> currentKeys.put(b.getKey(), b))__        }__        _        List<B> buckets = source.getBuckets()_                .stream()_                .filter(b -> originalKeys.containsKey(b.getKey()) == false) _                .map(bucket -> {__                    _                    long bucketCount = getAggCount(source, bucket.getAggregations().getAsMap())___                    _                    if (bucketCount == 0) {_                        return null__                    }__                    _                    if (currentKeys.containsKey(bucket.getKey()) && currentKeys.get(bucket.getKey()).getDocCount() != 0) {_                        _                        _                        bucketCount = 0__                    }__                    _                    InternalAggregations subAggs = unrollSubAggsFromMulti(bucket, originalKeys.get(bucket.getKey()),_                            currentKeys.get(bucket.getKey()))___                    return bucketFactory.apply(bucket, bucketCount, subAggs)__                })_                .filter(Objects::nonNull)_                .collect(Collectors.toList())__        return source.create(buckets)__    };helper,method,which,unrolls,a,generic,multibucket,agg,prefer,to,use,the,other,overload,as,a,consumer,of,the,api,param,source,the,rolled,aggregation,that,we,wish,to,unroll,param,bucket,factory,a,trifunction,which,generates,new,buckets,for,the,given,type,of,multibucket;private,static,a,extends,internal,multi,bucket,aggregation,b,extends,internal,bucket,t,extends,internal,multi,bucket,aggregation,a,b,internal,aggregation,unroll,multi,bucket,t,source,t,original,t,current,tree,tri,function,internal,bucket,long,internal,aggregations,b,bucket,factory,map,object,internal,bucket,original,keys,new,hash,map,map,object,internal,bucket,current,keys,new,hash,map,if,original,null,original,get,buckets,for,each,b,original,keys,put,b,get,key,b,if,current,tree,null,current,tree,get,buckets,for,each,b,current,keys,put,b,get,key,b,list,b,buckets,source,get,buckets,stream,filter,b,original,keys,contains,key,b,get,key,false,map,bucket,long,bucket,count,get,agg,count,source,bucket,get,aggregations,get,as,map,if,bucket,count,0,return,null,if,current,keys,contains,key,bucket,get,key,current,keys,get,bucket,get,key,get,doc,count,0,bucket,count,0,internal,aggregations,sub,aggs,unroll,sub,aggs,from,multi,bucket,original,keys,get,bucket,get,key,current,keys,get,bucket,get,key,return,bucket,factory,apply,bucket,bucket,count,sub,aggs,filter,objects,non,null,collect,collectors,to,list,return,source,create,buckets
RollupResponseTranslator -> @SuppressWarnings("unchecked")     private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,                                                          InternalMultiBucketAggregation currentTree);1524684173;Unrolls Multibucket aggregations (e.g. terms, histograms, etc).  This overload signature should be_called by other internal methods in this class, rather than directly calling the per-type methods.;@SuppressWarnings("unchecked")_    private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,_                                                         InternalMultiBucketAggregation currentTree) {__        _        _        _        _        if (rolled instanceof InternalDateHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalDateHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalDateHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalDateHistogram.Bucket(key, bucketCount,_                        ((InternalDateHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof InternalHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalHistogram.Bucket(key, bucketCount, ((InternalHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof StringTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                BytesRef key = new BytesRef(bucket.getKeyAsString().getBytes(StandardCharsets.UTF_8))__                assert bucketCount >= 0__                _                return new StringTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else if (rolled instanceof LongTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = (long)bucket.getKey()__                assert bucketCount >= 0__                _                return new LongTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }__    };unrolls,multibucket,aggregations,e,g,terms,histograms,etc,this,overload,signature,should,be,called,by,other,internal,methods,in,this,class,rather,than,directly,calling,the,per,type,methods;suppress,warnings,unchecked,private,static,internal,aggregation,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,internal,multi,bucket,aggregation,current,tree,if,rolled,instanceof,internal,date,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,date,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,date,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,date,histogram,bucket,key,bucket,count,internal,date,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,internal,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,histogram,bucket,key,bucket,count,internal,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,string,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,bytes,ref,key,new,bytes,ref,bucket,get,key,as,string,get,bytes,standard,charsets,assert,bucket,count,0,return,new,string,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,if,rolled,instanceof,long,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,long,bucket,get,key,assert,bucket,count,0,return,new,long,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> @SuppressWarnings("unchecked")     private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,                                                          InternalMultiBucketAggregation currentTree);1528762805;Unrolls Multibucket aggregations (e.g. terms, histograms, etc).  This overload signature should be_called by other internal methods in this class, rather than directly calling the per-type methods.;@SuppressWarnings("unchecked")_    private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,_                                                         InternalMultiBucketAggregation currentTree) {__        _        _        _        _        if (rolled instanceof InternalDateHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalDateHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalDateHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalDateHistogram.Bucket(key, bucketCount,_                        ((InternalDateHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof InternalHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalHistogram.Bucket(key, bucketCount, ((InternalHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof StringTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                BytesRef key = new BytesRef(bucket.getKeyAsString().getBytes(StandardCharsets.UTF_8))__                assert bucketCount >= 0__                _                return new StringTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else if (rolled instanceof LongTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = (long)bucket.getKey()__                assert bucketCount >= 0__                _                return new LongTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }__    };unrolls,multibucket,aggregations,e,g,terms,histograms,etc,this,overload,signature,should,be,called,by,other,internal,methods,in,this,class,rather,than,directly,calling,the,per,type,methods;suppress,warnings,unchecked,private,static,internal,aggregation,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,internal,multi,bucket,aggregation,current,tree,if,rolled,instanceof,internal,date,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,date,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,date,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,date,histogram,bucket,key,bucket,count,internal,date,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,internal,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,histogram,bucket,key,bucket,count,internal,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,string,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,bytes,ref,key,new,bytes,ref,bucket,get,key,as,string,get,bytes,standard,charsets,assert,bucket,count,0,return,new,string,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,if,rolled,instanceof,long,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,long,bucket,get,key,assert,bucket,count,0,return,new,long,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> @SuppressWarnings("unchecked")     private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,                                                          InternalMultiBucketAggregation currentTree);1531729807;Unrolls Multibucket aggregations (e.g. terms, histograms, etc).  This overload signature should be_called by other internal methods in this class, rather than directly calling the per-type methods.;@SuppressWarnings("unchecked")_    private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,_                                                         InternalMultiBucketAggregation currentTree) {__        _        _        _        _        if (rolled instanceof InternalDateHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalDateHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalDateHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalDateHistogram.Bucket(key, bucketCount,_                        ((InternalDateHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof InternalHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalHistogram.Bucket(key, bucketCount, ((InternalHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof StringTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {__                BytesRef key = new BytesRef(bucket.getKeyAsString().getBytes(StandardCharsets.UTF_8))__                assert bucketCount >= 0__                _                return new StringTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else if (rolled instanceof LongTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = (long)bucket.getKey()__                assert bucketCount >= 0__                _                return new LongTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }__    };unrolls,multibucket,aggregations,e,g,terms,histograms,etc,this,overload,signature,should,be,called,by,other,internal,methods,in,this,class,rather,than,directly,calling,the,per,type,methods;suppress,warnings,unchecked,private,static,internal,aggregation,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,internal,multi,bucket,aggregation,current,tree,if,rolled,instanceof,internal,date,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,date,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,date,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,date,histogram,bucket,key,bucket,count,internal,date,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,internal,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,histogram,bucket,key,bucket,count,internal,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,string,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,bytes,ref,key,new,bytes,ref,bucket,get,key,as,string,get,bytes,standard,charsets,assert,bucket,count,0,return,new,string,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,if,rolled,instanceof,long,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,long,bucket,get,key,assert,bucket,count,0,return,new,long,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> @SuppressWarnings("unchecked")     private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,                                                          InternalMultiBucketAggregation currentTree);1535057785;Unrolls Multibucket aggregations (e.g. terms, histograms, etc).  This overload signature should be_called by other internal methods in this class, rather than directly calling the per-type methods.;@SuppressWarnings("unchecked")_    private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,_                                                         InternalMultiBucketAggregation currentTree) {__        _        _        _        _        if (rolled instanceof InternalDateHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalDateHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalDateHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalDateHistogram.Bucket(key, bucketCount,_                        ((InternalDateHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof InternalHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalHistogram.Bucket(key, bucketCount, ((InternalHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof StringTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {__                BytesRef key = new BytesRef(bucket.getKeyAsString().getBytes(StandardCharsets.UTF_8))__                assert bucketCount >= 0__                _                return new StringTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else if (rolled instanceof LongTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = (long)bucket.getKey()__                assert bucketCount >= 0__                _                return new LongTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }__    };unrolls,multibucket,aggregations,e,g,terms,histograms,etc,this,overload,signature,should,be,called,by,other,internal,methods,in,this,class,rather,than,directly,calling,the,per,type,methods;suppress,warnings,unchecked,private,static,internal,aggregation,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,internal,multi,bucket,aggregation,current,tree,if,rolled,instanceof,internal,date,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,date,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,date,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,date,histogram,bucket,key,bucket,count,internal,date,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,internal,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,histogram,bucket,key,bucket,count,internal,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,string,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,bytes,ref,key,new,bytes,ref,bucket,get,key,as,string,get,bytes,standard,charsets,assert,bucket,count,0,return,new,string,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,if,rolled,instanceof,long,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,long,bucket,get,key,assert,bucket,count,0,return,new,long,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> @SuppressWarnings("unchecked")     private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,                                                          InternalMultiBucketAggregation currentTree);1536314350;Unrolls Multibucket aggregations (e.g. terms, histograms, etc).  This overload signature should be_called by other internal methods in this class, rather than directly calling the per-type methods.;@SuppressWarnings("unchecked")_    private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,_                                                         InternalMultiBucketAggregation currentTree) {__        _        _        _        _        if (rolled instanceof InternalDateHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalDateHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalDateHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalDateHistogram.Bucket(key, bucketCount,_                        ((InternalDateHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof InternalHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalHistogram.Bucket(key, bucketCount, ((InternalHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof StringTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {__                BytesRef key = new BytesRef(bucket.getKeyAsString().getBytes(StandardCharsets.UTF_8))__                assert bucketCount >= 0__                _                return new StringTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else if (rolled instanceof LongTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = (long)bucket.getKey()__                assert bucketCount >= 0__                _                return new LongTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }__    };unrolls,multibucket,aggregations,e,g,terms,histograms,etc,this,overload,signature,should,be,called,by,other,internal,methods,in,this,class,rather,than,directly,calling,the,per,type,methods;suppress,warnings,unchecked,private,static,internal,aggregation,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,internal,multi,bucket,aggregation,current,tree,if,rolled,instanceof,internal,date,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,date,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,date,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,date,histogram,bucket,key,bucket,count,internal,date,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,internal,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,histogram,bucket,key,bucket,count,internal,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,string,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,bytes,ref,key,new,bytes,ref,bucket,get,key,as,string,get,bytes,standard,charsets,assert,bucket,count,0,return,new,string,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,if,rolled,instanceof,long,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,long,bucket,get,key,assert,bucket,count,0,return,new,long,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> @SuppressWarnings("unchecked")     private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,                                                          InternalMultiBucketAggregation currentTree);1539951844;Unrolls Multibucket aggregations (e.g. terms, histograms, etc).  This overload signature should be_called by other internal methods in this class, rather than directly calling the per-type methods.;@SuppressWarnings("unchecked")_    private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,_                                                         InternalMultiBucketAggregation currentTree) {__        _        _        _        _        if (rolled instanceof InternalDateHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalDateHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalDateHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalDateHistogram.Bucket(key, bucketCount,_                        ((InternalDateHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof InternalHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalHistogram.Bucket(key, bucketCount, ((InternalHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof StringTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {__                BytesRef key = new BytesRef(bucket.getKeyAsString().getBytes(StandardCharsets.UTF_8))__                assert bucketCount >= 0__                _                return new StringTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else if (rolled instanceof LongTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = (long)bucket.getKey()__                assert bucketCount >= 0__                _                return new LongTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }__    };unrolls,multibucket,aggregations,e,g,terms,histograms,etc,this,overload,signature,should,be,called,by,other,internal,methods,in,this,class,rather,than,directly,calling,the,per,type,methods;suppress,warnings,unchecked,private,static,internal,aggregation,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,internal,multi,bucket,aggregation,current,tree,if,rolled,instanceof,internal,date,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,date,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,date,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,date,histogram,bucket,key,bucket,count,internal,date,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,internal,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,histogram,bucket,key,bucket,count,internal,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,string,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,bytes,ref,key,new,bytes,ref,bucket,get,key,as,string,get,bytes,standard,charsets,assert,bucket,count,0,return,new,string,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,if,rolled,instanceof,long,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,long,bucket,get,key,assert,bucket,count,0,return,new,long,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
RollupResponseTranslator -> @SuppressWarnings("unchecked")     private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,                                                          InternalMultiBucketAggregation currentTree);1540847035;Unrolls Multibucket aggregations (e.g. terms, histograms, etc).  This overload signature should be_called by other internal methods in this class, rather than directly calling the per-type methods.;@SuppressWarnings("unchecked")_    private static InternalAggregation unrollMultiBucket(InternalMultiBucketAggregation rolled, InternalMultiBucketAggregation original,_                                                         InternalMultiBucketAggregation currentTree) {__        _        _        _        _        if (rolled instanceof InternalDateHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalDateHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalDateHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalDateHistogram.Bucket(key, bucketCount,_                        ((InternalDateHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof InternalHistogram) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = ((InternalHistogram) rolled).getKey(bucket).longValue()__                DocValueFormat formatter = ((InternalHistogram.Bucket)bucket).getFormatter()__                assert bucketCount >= 0__                return new InternalHistogram.Bucket(key, bucketCount, ((InternalHistogram.Bucket) bucket).getKeyed(), formatter, subAggs)__            })__        } else if (rolled instanceof StringTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {__                BytesRef key = new BytesRef(bucket.getKeyAsString().getBytes(StandardCharsets.UTF_8))__                assert bucketCount >= 0__                _                return new StringTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else if (rolled instanceof LongTerms) {_            return unrollMultiBucket(rolled, original, currentTree, (bucket, bucketCount, subAggs) -> {_                long key = (long)bucket.getKey()__                assert bucketCount >= 0__                _                return new LongTerms.Bucket(key, bucketCount, subAggs, false, 0, DocValueFormat.RAW)__            })__        } else {_            throw new RuntimeException("Unable to unroll aggregation tree.  Aggregation ["_                    + rolled.getName() + "] is of type [" + rolled.getClass().getSimpleName() + "] which is " +_                    "currently unsupported.")__        }__    };unrolls,multibucket,aggregations,e,g,terms,histograms,etc,this,overload,signature,should,be,called,by,other,internal,methods,in,this,class,rather,than,directly,calling,the,per,type,methods;suppress,warnings,unchecked,private,static,internal,aggregation,unroll,multi,bucket,internal,multi,bucket,aggregation,rolled,internal,multi,bucket,aggregation,original,internal,multi,bucket,aggregation,current,tree,if,rolled,instanceof,internal,date,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,date,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,date,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,date,histogram,bucket,key,bucket,count,internal,date,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,internal,histogram,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,internal,histogram,rolled,get,key,bucket,long,value,doc,value,format,formatter,internal,histogram,bucket,bucket,get,formatter,assert,bucket,count,0,return,new,internal,histogram,bucket,key,bucket,count,internal,histogram,bucket,bucket,get,keyed,formatter,sub,aggs,else,if,rolled,instanceof,string,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,bytes,ref,key,new,bytes,ref,bucket,get,key,as,string,get,bytes,standard,charsets,assert,bucket,count,0,return,new,string,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,if,rolled,instanceof,long,terms,return,unroll,multi,bucket,rolled,original,current,tree,bucket,bucket,count,sub,aggs,long,key,long,bucket,get,key,assert,bucket,count,0,return,new,long,terms,bucket,key,bucket,count,sub,aggs,false,0,doc,value,format,raw,else,throw,new,runtime,exception,unable,to,unroll,aggregation,tree,aggregation,rolled,get,name,is,of,type,rolled,get,class,get,simple,name,which,is,currently,unsupported
