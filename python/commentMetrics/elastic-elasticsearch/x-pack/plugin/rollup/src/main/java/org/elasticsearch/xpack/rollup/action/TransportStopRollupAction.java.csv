commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;4;;@Override protected void processTasks(StopRollupJobAction.Request request, Consumer<RollupJobTask> operation) {     TransportTaskHelper.doProcessTasks(request.getId(), operation, taskManager). }
false;protected;3;4;;@Override protected void doExecute(Task task, StopRollupJobAction.Request request, ActionListener<StopRollupJobAction.Response> listener) {     super.doExecute(task, request, listener). }
false;protected;3;10;;@Override protected void taskOperation(StopRollupJobAction.Request request, RollupJobTask jobTask, ActionListener<StopRollupJobAction.Response> listener) {     if (jobTask.getConfig().getId().equals(request.getId())) {         jobTask.stop(maybeWrapWithBlocking(request, jobTask, listener, threadPool)).     } else {         listener.onFailure(new RuntimeException("ID of rollup task [" + jobTask.getConfig().getId() + "] does not match request's ID [" + request.getId() + "]")).     } }
false;private,static;4;41;;private static ActionListener<StopRollupJobAction.Response> maybeWrapWithBlocking(StopRollupJobAction.Request request, RollupJobTask jobTask, ActionListener<StopRollupJobAction.Response> listener, ThreadPool threadPool) {     if (request.waitForCompletion()) {         return ActionListener.wrap(response -> {             if (response.isStopped()) {                 // The Task acknowledged that it is stopped/stopping... wait until the status actually                 // changes over before returning.  Switch over to Generic threadpool so                 // we don't block the network thread                 threadPool.generic().execute(() -> {                     try {                         boolean stopped = awaitBusy(() -> ((RollupJobStatus) jobTask.getStatus()).getIndexerState().equals(IndexerState.STOPPED), request.timeout()).                         if (stopped) {                             // We have successfully confirmed a stop, send back the response                             listener.onResponse(response).                         } else {                             listener.onFailure(new ElasticsearchTimeoutException("Timed out after [" + request.timeout().getStringRep() + "] while waiting for rollup job [" + request.getId() + "] to stop. State was [" + ((RollupJobStatus) jobTask.getStatus()).getIndexerState() + "]")).                         }                     } catch (InterruptedException e) {                         listener.onFailure(e).                     } catch (Exception e) {                         listener.onFailure(new ElasticsearchTimeoutException("Encountered unexpected error while waiting for " + "rollup job [" + request.getId() + "] to stop.  State was [" + ((RollupJobStatus) jobTask.getStatus()).getIndexerState() + "].", e)).                     }                 }).             } else {                 // Did not acknowledge stop, just return the response                 listener.onResponse(response).             }         }, listener::onFailure).     }     // No request to block, execute async     return listener. }
true;private,static;2;16;/**  * Lifted from ESTestCase, must stay private and do not reuse!  This is temporary until  * the Rollup state refactor makes it unnecessary to await on a status change  */ ;/**  * Lifted from ESTestCase, must stay private and do not reuse!  This is temporary until  * the Rollup state refactor makes it unnecessary to await on a status change  */ private static boolean awaitBusy(BooleanSupplier breakSupplier, TimeValue maxWaitTime) throws InterruptedException {     long maxTimeInMillis = maxWaitTime.getMillis().     long timeInMillis = 1.     long sum = 0.     while (sum + timeInMillis < maxTimeInMillis) {         if (breakSupplier.getAsBoolean()) {             return true.         }         Thread.sleep(timeInMillis).         sum += timeInMillis.         timeInMillis = Math.min(1000L, timeInMillis * 2).     }     timeInMillis = maxTimeInMillis - sum.     Thread.sleep(Math.max(timeInMillis, 0)).     return breakSupplier.getAsBoolean(). }
false;protected;4;24;;@Override protected StopRollupJobAction.Response newResponse(StopRollupJobAction.Request request, List<StopRollupJobAction.Response> tasks, List<TaskOperationFailure> taskOperationFailures, List<FailedNodeException> failedNodeExceptions) {     if (taskOperationFailures.isEmpty() == false) {         throw org.elasticsearch.ExceptionsHelper.convertToElastic(taskOperationFailures.get(0).getCause()).     } else if (failedNodeExceptions.isEmpty() == false) {         throw org.elasticsearch.ExceptionsHelper.convertToElastic(failedNodeExceptions.get(0)).     }     // In either case, let the user know     if (tasks.size() == 0) {         throw new ResourceNotFoundException("Task for Rollup Job [" + request.getId() + "] not found").     }     assert tasks.size() == 1.     boolean allStopped = tasks.stream().allMatch(StopRollupJobAction.Response::isStopped).     return new StopRollupJobAction.Response(allStopped). }
