commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public void testDefault() throws Exception {     MonthlySchedule schedule = new MonthlySchedule().     String[] crons = expressions(schedule).     assertThat(crons, arrayWithSize(1)).     assertThat(crons, arrayContaining("0 0 0 1 * ?")). }
false;public;0;13;;public void testSingleTime() throws Exception {     MonthTimes time = validMonthTime().     MonthlySchedule schedule = new MonthlySchedule(time).     String[] crons = expressions(schedule).     assertThat(crons, arrayWithSize(time.times().length)).     for (DayTimes dayTimes : time.times()) {         String minStr = join(",", dayTimes.minute()).         String hrStr = join(",", dayTimes.hour()).         String dayStr = join(",", time.days()).         dayStr = dayStr.replace("32", "L").         assertThat(crons, hasItemInArray("0 " + minStr + " " + hrStr + " " + dayStr + " * ?")).     } }
false;public;0;19;;public void testMultipleTimes() throws Exception {     MonthTimes[] times = validMonthTimes().     MonthlySchedule schedule = new MonthlySchedule(times).     String[] crons = expressions(schedule).     int count = 0.     for (MonthTimes time : times) {         count += time.times().length.     }     assertThat(crons, arrayWithSize(count)).     for (MonthTimes monthTimes : times) {         for (DayTimes dayTimes : monthTimes.times()) {             String minStr = join(",", dayTimes.minute()).             String hrStr = join(",", dayTimes.hour()).             String dayStr = join(",", monthTimes.days()).             dayStr = dayStr.replace("32", "L").             assertThat(crons, hasItemInArray("0 " + minStr + " " + hrStr + " " + dayStr + " * ?")).         }     } }
false;public;0;10;;public void testParserEmpty() throws Exception {     XContentBuilder builder = jsonBuilder().startObject().endObject().     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     MonthlySchedule schedule = new MonthlySchedule.Parser().parse(parser).     assertThat(schedule, notNullValue()).     assertThat(schedule.times().length, is(1)).     assertThat(schedule.times()[0], is(new MonthTimes())). }
false;public;0;22;;public void testParserSingleTime() throws Exception {     DayTimes time = validDayTime().     Object day = randomDayOfMonth().     XContentBuilder builder = jsonBuilder().startObject().field("on", day).startObject("at").array("hour", time.hour()).array("minute", time.minute()).endObject().endObject().     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     MonthlySchedule schedule = new MonthlySchedule.Parser().parse(parser).     assertThat(schedule, notNullValue()).     assertThat(schedule.times().length, is(1)).     assertThat(schedule.times()[0].days().length, is(1)).     assertThat(schedule.times()[0].days()[0], is(dayOfMonthToInt(day))).     assertThat(schedule.times()[0].times(), arrayWithSize(1)).     assertThat(schedule.times()[0].times(), hasItemInArray(time)). }
false;public;0;20;;public void testParserSingleTimeInvalid() throws Exception {     HourAndMinute time = invalidDayTime().     XContentBuilder builder = jsonBuilder().startObject().field("on", randomBoolean() ? invalidDayOfMonth() : randomDayOfMonth()).startObject("at").field("hour", time.hour).field("minute", time.minute).endObject().endObject().     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     try {         new MonthlySchedule.Parser().parse(parser).         fail("Expected ElasticsearchParseException").     } catch (ElasticsearchParseException e) {         assertThat(e.getMessage(), is("could not parse [monthly] schedule. invalid month times")).     } }
false;public;0;13;;public void testParserMultipleTimes() throws Exception {     MonthTimes[] times = validMonthTimes().     XContentBuilder builder = jsonBuilder().value(times).     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     MonthlySchedule schedule = new MonthlySchedule.Parser().parse(parser).     assertThat(schedule, notNullValue()).     assertThat(schedule.times().length, is(times.length)).     for (MonthTimes time : times) {         assertThat(schedule.times(), hasItemInArray(time)).     } }
false;public;0;17;;public void testParserMultipleTimesInvalid() throws Exception {     HourAndMinute[] times = invalidDayTimes().     XContentBuilder builder = jsonBuilder().startObject().field("on", randomDayOfMonth()).array("at", (Object[]) times).endObject().     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     try {         new MonthlySchedule.Parser().parse(parser).         fail("Expected ElasticsearchParseException").     } catch (ElasticsearchParseException e) {         assertThat(e.getMessage(), is("could not parse [monthly] schedule. invalid month times")).     } }
