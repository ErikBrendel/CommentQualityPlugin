commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void configureMockClient() {     when(client.settings()).thenReturn(Settings.EMPTY).     ThreadPool threadPool = mock(ThreadPool.class).     when(client.threadPool()).thenReturn(threadPool).     when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY)). }
false;;0;3;;@Override void stopExecutor() { }
false;public;0;24;;public void testValidateStartWithClosedIndex() {     TriggerService triggerService = mock(TriggerService.class).     TriggeredWatchStore triggeredWatchStore = mock(TriggeredWatchStore.class).     ExecutionService executionService = mock(ExecutionService.class).     WatchParser parser = mock(WatchParser.class).     WatcherService service = new WatcherService(Settings.EMPTY, triggerService, triggeredWatchStore, executionService, parser, client, executorService) {          @Override         void stopExecutor() {         }     }.     ClusterState.Builder csBuilder = new ClusterState.Builder(new ClusterName("_name")).     MetaData.Builder metaDataBuilder = MetaData.builder().     Settings indexSettings = settings(Version.CURRENT).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build().     metaDataBuilder.put(IndexMetaData.builder(Watch.INDEX).state(IndexMetaData.State.CLOSE).settings(indexSettings)).     csBuilder.metaData(metaDataBuilder).     assertThat(service.validate(csBuilder.build()), is(false)). }
false;;0;3;;@Override void stopExecutor() { }
false;public;0;104;;public void testLoadOnlyActiveWatches() throws Exception {     TriggerService triggerService = mock(TriggerService.class).     TriggeredWatchStore triggeredWatchStore = mock(TriggeredWatchStore.class).     ExecutionService executionService = mock(ExecutionService.class).     WatchParser parser = mock(WatchParser.class).     WatcherService service = new WatcherService(Settings.EMPTY, triggerService, triggeredWatchStore, executionService, parser, client, executorService) {          @Override         void stopExecutor() {         }     }.     // cluster state setup, with one node, one shard     ClusterState.Builder csBuilder = new ClusterState.Builder(new ClusterName("_name")).     MetaData.Builder metaDataBuilder = MetaData.builder().     Settings indexSettings = settings(Version.CURRENT).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build().     metaDataBuilder.put(IndexMetaData.builder(Watch.INDEX).settings(indexSettings)).     csBuilder.metaData(metaDataBuilder).     Index watchIndex = new Index(Watch.INDEX, "uuid").     ShardId shardId = new ShardId(watchIndex, 0).     IndexShardRoutingTable indexShardRoutingTable = new IndexShardRoutingTable.Builder(shardId).addShard(TestShardRouting.newShardRouting(shardId, "node", true, ShardRoutingState.STARTED)).build().     IndexRoutingTable indexRoutingTable = IndexRoutingTable.builder(watchIndex).addIndexShard(indexShardRoutingTable).build().     RoutingTable routingTable = RoutingTable.builder().add(indexRoutingTable).build().     csBuilder.routingTable(routingTable).     csBuilder.nodes(new DiscoveryNodes.Builder().masterNodeId("node").localNodeId("node").add(newNode())).     ClusterState clusterState = csBuilder.build().     // response setup, successful refresh response     RefreshResponse refreshResponse = mock(RefreshResponse.class).     when(refreshResponse.getSuccessfulShards()).thenReturn(clusterState.getMetaData().getIndices().get(Watch.INDEX).getNumberOfShards()).     doAnswer(invocation -> {         ActionListener<RefreshResponse> listener = (ActionListener<RefreshResponse>) invocation.getArguments()[2].         listener.onResponse(refreshResponse).         return null.     }).when(client).execute(eq(RefreshAction.INSTANCE), any(RefreshRequest.class), any(ActionListener.class)).     // empty scroll response, no further scrolling needed     SearchResponseSections scrollSearchSections = new SearchResponseSections(SearchHits.empty(), null, null, false, false, null, 1).     SearchResponse scrollSearchResponse = new SearchResponse(scrollSearchSections, "scrollId", 1, 1, 0, 10, ShardSearchFailure.EMPTY_ARRAY, SearchResponse.Clusters.EMPTY).     doAnswer(invocation -> {         ActionListener<SearchResponse> listener = (ActionListener<SearchResponse>) invocation.getArguments()[2].         listener.onResponse(scrollSearchResponse).         return null.     }).when(client).execute(eq(SearchScrollAction.INSTANCE), any(SearchScrollRequest.class), any(ActionListener.class)).     // one search response containing active and inactive watches     int count = randomIntBetween(2, 200).     int activeWatchCount = 0.     SearchHit[] hits = new SearchHit[count].     for (int i = 0. i < count. i++) {         String id = String.valueOf(i).         SearchHit hit = new SearchHit(1, id, new Text("watch"), Collections.emptyMap()).         hit.version(1L).         hit.shard(new SearchShardTarget("nodeId", new ShardId(watchIndex, 0), "whatever", OriginalIndices.NONE)).         hits[i] = hit.         boolean active = randomBoolean().         if (active) {             activeWatchCount++.         }         WatchStatus.State state = new WatchStatus.State(active, ZonedDateTime.now(ZoneOffset.UTC)).         WatchStatus watchStatus = mock(WatchStatus.class).         Watch watch = mock(Watch.class).         when(watchStatus.state()).thenReturn(state).         when(watch.status()).thenReturn(watchStatus).         when(parser.parse(eq(id), eq(true), any(), eq(XContentType.JSON), anyLong(), anyLong())).thenReturn(watch).     }     SearchHits searchHits = new SearchHits(hits, new TotalHits(count, TotalHits.Relation.EQUAL_TO), 1.0f).     SearchResponseSections sections = new SearchResponseSections(searchHits, null, null, false, false, null, 1).     SearchResponse searchResponse = new SearchResponse(sections, "scrollId", 1, 1, 0, 10, ShardSearchFailure.EMPTY_ARRAY, SearchResponse.Clusters.EMPTY).     doAnswer(invocation -> {         ActionListener<SearchResponse> listener = (ActionListener<SearchResponse>) invocation.getArguments()[2].         listener.onResponse(searchResponse).         return null.     }).when(client).execute(eq(SearchAction.INSTANCE), any(SearchRequest.class), any(ActionListener.class)).     doAnswer(invocation -> {         ActionListener<ClearScrollResponse> listener = (ActionListener<ClearScrollResponse>) invocation.getArguments()[2].         listener.onResponse(new ClearScrollResponse(true, 1)).         return null.     }).when(client).execute(eq(ClearScrollAction.INSTANCE), any(ClearScrollRequest.class), any(ActionListener.class)).     service.start(clusterState, () -> {     }).     ArgumentCaptor<List> captor = ArgumentCaptor.forClass(List.class).     verify(triggerService).start(captor.capture()).     List<Watch> watches = captor.getValue().     watches.forEach(watch -> assertThat(watch.status().state().isActive(), is(true))).     assertThat(watches, hasSize(activeWatchCount)). }
false;;0;3;;@Override void stopExecutor() { }
false;public;0;31;;public void testPausingWatcherServiceAlsoPausesTriggerService() {     String engineType = "foo".     TriggerEngine triggerEngine = mock(TriggerEngine.class).     when(triggerEngine.type()).thenReturn(engineType).     TriggerService triggerService = new TriggerService(Collections.singleton(triggerEngine)).     Trigger trigger = mock(Trigger.class).     when(trigger.type()).thenReturn(engineType).     final String id = randomAlphaOfLengthBetween(3, 12).     Watch watch = mock(Watch.class).     when(watch.trigger()).thenReturn(trigger).     when(watch.id()).thenReturn(id).     when(watch.condition()).thenReturn(InternalAlwaysCondition.INSTANCE).     ExecutableNoneInput noneInput = new ExecutableNoneInput().     when(watch.input()).thenReturn(noneInput).     triggerService.add(watch).     assertThat(triggerService.count(), is(1L)).     WatcherService service = new WatcherService(Settings.EMPTY, triggerService, mock(TriggeredWatchStore.class), mock(ExecutionService.class), mock(WatchParser.class), client, executorService) {          @Override         void stopExecutor() {         }     }.     service.pauseExecution("pausing").     assertThat(triggerService.count(), is(0L)).     verify(triggerEngine).pauseExecution(). }
false;;0;3;;@Override void stopExecutor() { }
true;public;0;18;// result in missing executions ;// if we have to reload the watcher service, the execution service should not be paused, as this might // result in missing executions public void testReloadingWatcherDoesNotPauseExecutionService() {     ExecutionService executionService = mock(ExecutionService.class).     TriggerService triggerService = mock(TriggerService.class).     WatcherService service = new WatcherService(Settings.EMPTY, triggerService, mock(TriggeredWatchStore.class), executionService, mock(WatchParser.class), client, executorService) {          @Override         void stopExecutor() {         }     }.     ClusterState.Builder csBuilder = new ClusterState.Builder(new ClusterName("_name")).     csBuilder.metaData(MetaData.builder()).     service.reload(csBuilder.build(), "whatever").     verify(executionService).clearExecutionsAndQueue().     verify(executionService, never()).pause().     verify(triggerService).pauseExecution(). }
false;private,static;0;4;;private static DiscoveryNode newNode() {     return new DiscoveryNode("node", ESTestCase.buildNewFakeTransportAddress(), Collections.emptyMap(), new HashSet<>(asList(DiscoveryNode.Role.values())), Version.CURRENT). }
