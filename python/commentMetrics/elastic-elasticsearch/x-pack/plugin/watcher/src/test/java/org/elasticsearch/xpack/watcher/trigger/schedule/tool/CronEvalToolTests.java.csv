commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Command newCommand() {     return new CronEvalTool(). }
false;public;0;6;;public void testParse() throws Exception {     String countOption = randomBoolean() ? "-c" : "--count".     int count = randomIntBetween(1, 100).     String output = execute(countOption, Integer.toString(count), "0 0 0 1-6 * ?").     assertThat(output, containsString("Here are the next " + count + " times this cron expression will trigger")). }
false;public;0;20;;public void testGetNextValidTimes() throws Exception {     final int year = Calendar.getInstance(TimeZone.getTimeZone("UTC"), Locale.ROOT).get(Calendar.YEAR) + 1.     {         String output = execute("0 3 23 8 9 ? " + year).         assertThat(output, containsString("Here are the next 10 times this cron expression will trigger:")).         assertThat(output, not(containsString("ERROR"))).         assertThat(output, not(containsString("2.\t"))).     }     {         String output = execute("0 3 23 */4 9 ? " + year).         assertThat(output, containsString("Here are the next 10 times this cron expression will trigger:")).         assertThat(output, not(containsString("ERROR"))).     }     {         Exception expectThrows = expectThrows(Exception.class, () -> execute("0 3 23 */4 9 ? 2017")).         String message = expectThrows.getMessage().         assertThat(message, containsString("Could not compute future times since")).         assertThat(message, containsString("(perhaps the cron expression only points to times in the past?)")).     } }
true;public;0;15;// we always have to output in standard locale and independent from timezone ;// randomized testing sets arbitrary locales and timezones, and we do not care // we always have to output in standard locale and independent from timezone public void testEnsureDateIsShownInRootLocale() throws Exception {     String output = execute("-c", "1", "0 0 11 ? * MON-SAT 2040").     if (ZoneId.systemDefault().equals(ZoneOffset.UTC)) {         assertThat(output, not(containsString("local time is"))).         long linesStartingWithOne = Arrays.stream(output.split("\n")).filter(s -> s.startsWith("\t")).count().         assertThat(linesStartingWithOne, is(0L)).     } else {         // check for header line         assertThat(output, containsString("] in UTC, local time is")).         assertThat(output, containsString("Mon, 2 Jan 2040 11:00:00")).         logger.info(output).         long linesStartingWithOne = Arrays.stream(output.split("\n")).filter(s -> s.startsWith("\t")).count().         assertThat(linesStartingWithOne, is(1L)).     } }
