commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void init() throws IOException {     actionLogger = mock(Logger.class).     level = randomFrom(LoggingLevel.values()).     engine = mock(TextTemplateEngine.class). }
false;public;0;37;;public void testExecute() throws Exception {     final ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC).     JodaCompatibleZonedDateTime jodaJavaNow = new JodaCompatibleZonedDateTime(now.toInstant(), ZoneOffset.UTC).     WatchExecutionContext ctx = WatcherTestUtils.mockExecutionContextBuilder("_watch_id").time("_watch_id", now).buildMock().     Map<String, Object> triggerModel = new HashMap<>().     triggerModel.put("scheduled_time", jodaJavaNow).     triggerModel.put("triggered_time", jodaJavaNow).     Map<String, Object> ctxModel = new HashMap<>().     ctxModel.put("id", ctx.id().value()).     ctxModel.put("watch_id", "_watch_id").     ctxModel.put("execution_time", jodaJavaNow).     ctxModel.put("payload", emptyMap()).     ctxModel.put("metadata", emptyMap()).     ctxModel.put("vars", emptyMap()).     ctxModel.put("trigger", triggerModel).     Map<String, Object> expectedModel = singletonMap("ctx", ctxModel).     String text = randomAlphaOfLength(10).     TextTemplate template = new TextTemplate(text).     LoggingAction action = new LoggingAction(template, level, "_category").     ExecutableLoggingAction executable = new ExecutableLoggingAction(action, logger, actionLogger, engine).     when(engine.render(template, expectedModel)).thenReturn(text).     Action.Result result = executable.execute("_id", ctx, new Payload.Simple()).     verifyLogger(actionLogger, level, text).     assertThat(result, notNullValue()).     assertThat(result.status(), is(Action.Result.Status.SUCCESS)).     assertThat(result, instanceOf(LoggingAction.Result.Success.class)).     assertThat(((LoggingAction.Result.Success) result).loggedText(), is(text)). }
false;public;0;32;;public void testParser() throws Exception {     LoggingActionFactory parser = new LoggingActionFactory(engine).     String text = randomAlphaOfLength(10).     TextTemplate template = new TextTemplate(text).     XContentBuilder builder = jsonBuilder().startObject().     builder.field("text", template).     String category = null.     if (randomBoolean()) {         category = randomAlphaOfLength(10).         builder.field("category", category).     }     LoggingLevel level = null.     if (randomBoolean()) {         level = randomFrom(LoggingLevel.values()).         builder.field("level", level).     }     builder.endObject().     XContentParser xContentParser = createParser(builder).     xContentParser.nextToken().     ExecutableLoggingAction executable = parser.parseExecutable(randomAlphaOfLength(5), randomAlphaOfLength(3), xContentParser).     assertThat(executable, notNullValue()).     assertThat(executable.action().category, is(category)).     assertThat(executable.action().level, level == null ? is(LoggingLevel.INFO) : is(level)).     assertThat(executable.textLogger(), notNullValue()).     assertThat(executable.action().text, notNullValue()).     assertThat(executable.action().text, is(template)). }
false;public;0;18;;public void testParserSelfGenerated() throws Exception {     LoggingActionFactory parser = new LoggingActionFactory(engine).     String text = randomAlphaOfLength(10).     TextTemplate template = new TextTemplate(text).     String category = randomAlphaOfLength(10).     LoggingAction action = new LoggingAction(template, level, category).     ExecutableLoggingAction executable = new ExecutableLoggingAction(action, logger, engine).     XContentBuilder builder = jsonBuilder().     executable.toXContent(builder, Attachment.XContent.EMPTY_PARAMS).     XContentParser xContentParser = createParser(builder).     xContentParser.nextToken().     ExecutableLoggingAction parsedAction = parser.parseExecutable(randomAlphaOfLength(5), randomAlphaOfLength(5), xContentParser).     assertThat(parsedAction, equalTo(executable)). }
false;public;0;24;;public void testParserBuilder() throws Exception {     LoggingActionFactory parser = new LoggingActionFactory(engine).     String text = randomAlphaOfLength(10).     TextTemplate template = new TextTemplate(text).     LoggingAction.Builder actionBuilder = loggingAction(template).     if (randomBoolean()) {         actionBuilder.setCategory(randomAlphaOfLength(10)).     }     if (randomBoolean()) {         actionBuilder.setLevel(randomFrom(LoggingLevel.values())).     }     LoggingAction action = actionBuilder.build().     XContentBuilder builder = jsonBuilder().value(action).     XContentParser xContentParser = createParser(builder).     assertThat(xContentParser.nextToken(), is(XContentParser.Token.START_OBJECT)).     ExecutableLoggingAction executable = parser.parseExecutable(randomAlphaOfLength(4), randomAlphaOfLength(5), xContentParser).     assertThat(executable, notNullValue()).     assertThat(executable.action(), is(action)).     assertThat(executable.action(), is(action)).     assertThat(executable.action(), is(action)). }
false;public;0;16;;public void testParserFailure() throws Exception {     LoggingActionFactory parser = new LoggingActionFactory(engine).     XContentBuilder builder = jsonBuilder().startObject().endObject().     XContentParser xContentParser = createParser(builder).     xContentParser.nextToken().     try {         parser.parseExecutable(randomAlphaOfLength(5), randomAlphaOfLength(5), xContentParser).         fail("Expected failure as there's no text").     } catch (ElasticsearchParseException e) {         assertThat(e.getMessage(), containsString("missing required [text] field")).     } }
false;static;3;22;;@SuppressLoggerChecks(reason = "mock usage") static void verifyLogger(Logger logger, LoggingLevel level, String text) {     switch(level) {         case ERROR:             verify(logger, times(1)).error(text).             break.         case WARN:             verify(logger, times(1)).warn(text).             break.         case INFO:             verify(logger, times(1)).info(text).             break.         case DEBUG:             verify(logger, times(1)).debug(text).             break.         case TRACE:             verify(logger, times(1)).trace(text).             break.         default:             fail("unhandled logging level [" + level.name() + "]").     } }
