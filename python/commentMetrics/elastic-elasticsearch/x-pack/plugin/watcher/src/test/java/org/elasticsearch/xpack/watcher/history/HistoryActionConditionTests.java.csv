commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;6;;@Override protected List<Class<? extends Plugin>> pluginTypes() {     List<Class<? extends Plugin>> types = super.pluginTypes().     types.add(CustomScriptPlugin.class).     return types. }
false;protected;0;12;;@Override protected Map<String, Function<Map<String, Object>, Object>> pluginScripts() {     Map<String, Function<Map<String, Object>, Object>> scripts = new HashMap<>().     scripts.put("return true.", vars -> true).     scripts.put("return false.", vars -> false).     scripts.put("throw new IllegalStateException('failed').", vars -> {         throw new IllegalStateException("[expected] failed hard").     }).     return scripts. }
true;public;0;47;/**  * A hard failure is where an exception is thrown by the script condition.  */ ;/**  * A hard failure is where an exception is thrown by the script condition.  */ @SuppressWarnings("unchecked") public void testActionConditionWithHardFailures() throws Exception {     final String id = "testActionConditionWithHardFailures".     final ExecutableCondition scriptConditionFailsHard = mockScriptCondition("throw new IllegalStateException('failed').").     final List<ExecutableCondition> actionConditionsWithFailure = Arrays.asList(scriptConditionFailsHard, conditionPasses, InternalAlwaysCondition.INSTANCE).     Collections.shuffle(actionConditionsWithFailure, random()).     final int failedIndex = actionConditionsWithFailure.indexOf(scriptConditionFailsHard).     putAndTriggerWatch(id, input, actionConditionsWithFailure.toArray(new Condition[actionConditionsWithFailure.size()])).     flush().     assertWatchWithMinimumActionsCount(id, ExecutionState.EXECUTED, 1).     // only one action should have failed via condition     final SearchResponse response = searchHistory(SearchSourceBuilder.searchSource().query(termQuery("watch_id", id))).     assertThat(response.getHits().getTotalHits().value, is(1L)).     final SearchHit hit = response.getHits().getAt(0).     final List<Object> actions = getActionsFromHit(hit.getSourceAsMap()).     for (int i = 0. i < actionConditionsWithFailure.size(). ++i) {         final Map<String, Object> action = (Map<String, Object>) actions.get(i).         final Map<String, Object> condition = (Map<String, Object>) action.get("condition").         final Map<String, Object> logging = (Map<String, Object>) action.get("logging").         assertThat(action.get("id"), is("action" + i)).         if (i == failedIndex) {             assertThat(action.get("status"), is("condition_failed")).             assertThat(action.get("reason"), is("condition failed. skipping: [expected] failed hard")).             assertThat(condition, nullValue()).             assertThat(logging, nullValue()).         } else {             assertThat(condition.get("type"), is(actionConditionsWithFailure.get(i).type())).             assertThat(action.get("status"), is("success")).             assertThat(condition.get("met"), is(true)).             assertThat(action.get("reason"), nullValue()).             assertThat(logging.get("logged_text"), is(Integer.toString(i))).         }     } }
false;public;0;43;;@SuppressWarnings("unchecked") public void testActionConditionWithFailures() throws Exception {     final String id = "testActionConditionWithFailures".     final ExecutableCondition[] actionConditionsWithFailure = new ExecutableCondition[] { conditionFails, conditionPasses, InternalAlwaysCondition.INSTANCE }.     Collections.shuffle(Arrays.asList(actionConditionsWithFailure), random()).     final int failedIndex = Arrays.asList(actionConditionsWithFailure).indexOf(conditionFails).     putAndTriggerWatch(id, input, actionConditionsWithFailure).     assertWatchWithMinimumActionsCount(id, ExecutionState.EXECUTED, 1).     // only one action should have failed via condition     final SearchResponse response = searchHistory(SearchSourceBuilder.searchSource().query(termQuery("watch_id", id))).     assertThat(response.getHits().getTotalHits().value, is(1L)).     final SearchHit hit = response.getHits().getAt(0).     final List<Object> actions = getActionsFromHit(hit.getSourceAsMap()).     for (int i = 0. i < actionConditionsWithFailure.length. ++i) {         final Map<String, Object> action = (Map<String, Object>) actions.get(i).         final Map<String, Object> condition = (Map<String, Object>) action.get("condition").         final Map<String, Object> logging = (Map<String, Object>) action.get("logging").         assertThat(action.get("id"), is("action" + i)).         assertThat(condition.get("type"), is(actionConditionsWithFailure[i].type())).         if (i == failedIndex) {             assertThat(action.get("status"), is("condition_failed")).             assertThat(condition.get("met"), is(false)).             assertThat(action.get("reason"), is("condition not met. skipping")).             assertThat(logging, nullValue()).         } else {             assertThat(action.get("status"), is("success")).             assertThat(condition.get("met"), is(true)).             assertThat(action.get("reason"), nullValue()).             assertThat(logging.get("logged_text"), is(Integer.toString(i))).         }     } }
false;public;0;41;;@SuppressWarnings("unchecked") public void testActionCondition() throws Exception {     final String id = "testActionCondition".     final List<ExecutableCondition> actionConditions = new ArrayList<>().     // actionConditions.add(conditionPasses).     actionConditions.add(InternalAlwaysCondition.INSTANCE).     /*         if (randomBoolean()) {             actionConditions.add(InternalAlwaysCondition.INSTANCE).         }          Collections.shuffle(actionConditions, random()).         */     putAndTriggerWatch(id, input, actionConditions.toArray(new Condition[actionConditions.size()])).     flush().     assertWatchWithMinimumActionsCount(id, ExecutionState.EXECUTED, 1).     // all actions should be successful     final SearchResponse response = searchHistory(SearchSourceBuilder.searchSource().query(termQuery("watch_id", id))).     assertThat(response.getHits().getTotalHits().value, is(1L)).     final SearchHit hit = response.getHits().getAt(0).     final List<Object> actions = getActionsFromHit(hit.getSourceAsMap()).     for (int i = 0. i < actionConditions.size(). ++i) {         final Map<String, Object> action = (Map<String, Object>) actions.get(i).         final Map<String, Object> condition = (Map<String, Object>) action.get("condition").         final Map<String, Object> logging = (Map<String, Object>) action.get("logging").         assertThat(action.get("id"), is("action" + i)).         assertThat(action.get("status"), is("success")).         assertThat(condition.get("type"), is(actionConditions.get(i).type())).         assertThat(condition.get("met"), is(true)).         assertThat(action.get("reason"), nullValue()).         assertThat(logging.get("logged_text"), is(Integer.toString(i))).     } }
true;private;1;6;/**  * Get the "actions" from the Watch History hit.  *  * @param source The hit's source.  * @return The list of "actions"  */ ;/**  * Get the "actions" from the Watch History hit.  *  * @param source The hit's source.  * @return The list of "actions"  */ @SuppressWarnings("unchecked") private List<Object> getActionsFromHit(final Map<String, Object> source) {     final Map<String, Object> result = (Map<String, Object>) source.get("result").     return (List<Object>) result.get("actions"). }
true;private;3;16;/**  * Create a Watch with the specified {@code id} and {@code input}.  * <p>  * The {@code actionConditions} are  *  * @param id The ID of the Watch  * @param input The input to use for the Watch  * @param actionConditions The conditions to add to the Watch  */ ;/**  * Create a Watch with the specified {@code id} and {@code input}.  * <p>  * The {@code actionConditions} are  *  * @param id The ID of the Watch  * @param input The input to use for the Watch  * @param actionConditions The conditions to add to the Watch  */ private void putAndTriggerWatch(final String id, final Input input, final Condition... actionConditions) {     WatchSourceBuilder source = watchBuilder().trigger(schedule(interval("5s"))).input(input).condition(InternalAlwaysCondition.INSTANCE).     for (int i = 0. i < actionConditions.length. ++i) {         source.addAction("action" + i, actionConditions[i], loggingAction(Integer.toString(i))).     }     PutWatchResponse putWatchResponse = watcherClient().preparePutWatch(id).setSource(source).get().     assertThat(putWatchResponse.isCreated(), is(true)).     timeWarp().trigger(id). }
true;private,static;1;4;/**  * Create an inline script using the {@link CustomScriptPlugin}.  *  * @param inlineScript The script to "compile" and run  * @return Never {@code null}  */ ;/**  * Create an inline script using the {@link CustomScriptPlugin}.  *  * @param inlineScript The script to "compile" and run  * @return Never {@code null}  */ private static ExecutableCondition mockScriptCondition(String inlineScript) {     Script script = new Script(ScriptType.INLINE, MockScriptPlugin.NAME, inlineScript, Collections.emptyMap()).     return new ScriptCondition(script). }
