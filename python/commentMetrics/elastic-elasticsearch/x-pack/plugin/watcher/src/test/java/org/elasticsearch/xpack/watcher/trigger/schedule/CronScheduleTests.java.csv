commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;public void testInvalid() throws Exception {     try {         new CronSchedule("0 * * *").         fail("expecting a validation error to be thrown when creating a cron schedule with invalid cron expression").     } catch (IllegalArgumentException e) {         assertThat(e.getMessage(), is("invalid cron expression [0 * * *]")).     } }
false;public;0;9;;public void testParseSingle() throws Exception {     XContentBuilder builder = jsonBuilder().value("0 0/5 * * * ?").     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     parser.nextToken().     CronSchedule schedule = new CronSchedule.Parser().parse(parser).     assertThat(schedule.crons(), arrayWithSize(1)).     assertThat(schedule.crons()[0].expression(), is("0 0/5 * * * ?")). }
false;public;0;16;;public void testParseMultiple() throws Exception {     XContentBuilder builder = jsonBuilder().value(new String[] { "0 0/1 * * * ?", "0 0/2 * * * ?", "0 0/3 * * * ?" }).     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     parser.nextToken().     CronSchedule schedule = new CronSchedule.Parser().parse(parser).     String[] crons = expressions(schedule).     assertThat(crons, arrayWithSize(3)).     assertThat(crons, hasItemInArray("0 0/1 * * * ?")).     assertThat(crons, hasItemInArray("0 0/2 * * * ?")).     assertThat(crons, hasItemInArray("0 0/3 * * * ?")). }
false;public;0;11;;public void testMultipleCronsNextScheduledAfter() {     CronSchedule schedule = new CronSchedule("0 5 9 1 1 ? 2019", "0 5 9 1 1 ? 2020", "0 5 9 1 1 ? 2017").     ZonedDateTime start2019 = ZonedDateTime.of(2019, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC).     ZonedDateTime start2020 = ZonedDateTime.of(2020, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC).     long firstSchedule = schedule.nextScheduledTimeAfter(0, start2019.toInstant().toEpochMilli()).     long secondSchedule = schedule.nextScheduledTimeAfter(0, start2020.toInstant().toEpochMilli()).     assertThat(firstSchedule, is(not(-1L))).     assertThat(secondSchedule, is(not(-1L))).     assertThat(firstSchedule, is(not(secondSchedule))). }
false;public;0;8;;public void testParseInvalidBadExpression() throws Exception {     XContentBuilder builder = jsonBuilder().value("0 0/5 * * ?").     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     parser.nextToken().     ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> new CronSchedule.Parser().parse(parser)).     assertThat(e.getCause(), instanceOf(IllegalArgumentException.class)). }
false;public;0;13;;public void testParseInvalidEmpty() throws Exception {     XContentBuilder builder = jsonBuilder().     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     parser.nextToken().     try {         new CronSchedule.Parser().parse(parser).         fail("Expected ElasticsearchParseException").     } catch (ElasticsearchParseException e) {         assertThat(e.getMessage(), is("could not parse [cron] schedule. expected either a cron string value or an array of cron " + "string values, but found [null]")).     } }
false;public;0;13;;public void testParseInvalidObject() throws Exception {     XContentBuilder builder = jsonBuilder().startObject().endObject().     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     parser.nextToken().     try {         new CronSchedule.Parser().parse(parser).         fail("Expected ElasticsearchParseException").     } catch (ElasticsearchParseException e) {         assertThat(e.getMessage(), is("could not parse [cron] schedule. expected either a cron string value or an array of cron " + "string values, but found [START_OBJECT]")).     } }
false;public;0;12;;public void testParseInvalidEmptyArray() throws Exception {     XContentBuilder builder = jsonBuilder().value(new String[0]).     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     parser.nextToken().     try {         new CronSchedule.Parser().parse(parser).         fail("Expected ElasticsearchParseException").     } catch (ElasticsearchParseException e) {         assertThat(e.getMessage(), is("could not parse [cron] schedule. no cron expression found in cron array")).     } }
