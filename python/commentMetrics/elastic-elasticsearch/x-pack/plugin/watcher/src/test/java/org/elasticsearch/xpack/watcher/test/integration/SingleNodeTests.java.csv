commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean timeWarped() {     return false. }
true;public;0;24;// the watch should be executed properly, despite the index being created and the cluster state listener being reloaded ;// this is the standard setup when starting watcher in a regular cluster // the index does not exist, a watch gets added // the watch should be executed properly, despite the index being created and the cluster state listener being reloaded public void testThatLoadingWithNonExistingIndexWorks() throws Exception {     stopWatcher().     ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get().     IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, clusterStateResponse.getState().metaData()).     String watchIndexName = metaData.getIndex().getName().     assertAcked(client().admin().indices().prepareDelete(watchIndexName)).     startWatcher().     String watchId = randomAlphaOfLength(20).     // now we start with an empty set up, store a watch and expected it to be executed     PutWatchResponse putWatchResponse = watcherClient().preparePutWatch(watchId).setSource(watchBuilder().trigger(schedule(interval(1, IntervalSchedule.Interval.Unit.SECONDS))).input(simpleInput()).addAction("_logger", loggingAction("logging of watch _name"))).get().     assertThat(putWatchResponse.isCreated(), is(true)).     assertBusy(() -> {         client().admin().indices().prepareRefresh(".watcher-history*").         SearchResponse searchResponse = client().prepareSearch(".watcher-history*").setSize(0).get().         assertThat(searchResponse.getHits().getTotalHits().value, is(greaterThanOrEqualTo(1L))).     }, 5, TimeUnit.SECONDS). }
