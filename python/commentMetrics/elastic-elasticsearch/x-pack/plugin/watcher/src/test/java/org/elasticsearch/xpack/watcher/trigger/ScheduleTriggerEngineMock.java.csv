commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public ScheduleTrigger parseTrigger(String context, XContentParser parser) throws IOException {     return new ScheduleTrigger(scheduleRegistry.parse(context, parser)). }
false;public;4;5;;@Override public ScheduleTriggerEvent parseTriggerEvent(TriggerService service, String watchId, String context, XContentParser parser) throws IOException {     return ScheduleTriggerEvent.parse(parser, watchId, context, clock). }
false;public;1;4;;@Override public void start(Collection<Watch> jobs) {     jobs.forEach(this::add). }
false;public;0;4;;@Override public void stop() {     watches.clear(). }
false;public;1;5;;@Override public void add(Watch watch) {     logger.debug("adding watch [{}]", watch.id()).     watches.put(watch.id(), watch). }
false;public;0;4;;@Override public void pauseExecution() {     watches.clear(). }
false;public;1;4;;@Override public boolean remove(String jobId) {     return watches.remove(jobId) != null. }
false;public;1;3;;public boolean trigger(String jobName) {     return trigger(jobName, 1, null). }
false;public;3;25;;public boolean trigger(String jobName, int times, TimeValue interval) {     if (watches.containsKey(jobName) == false) {         return false.     }     for (int i = 0. i < times. i++) {         ZonedDateTime now = ZonedDateTime.now(clock).         logger.debug("firing watch [{}] at [{}]", jobName, now).         ScheduleTriggerEvent event = new ScheduleTriggerEvent(jobName, now, now).         consumers.forEach(consumer -> consumer.accept(Collections.singletonList(event))).         if (interval != null) {             if (clock instanceof ClockMock) {                 ((ClockMock) clock).fastForward(interval).             } else {                 try {                     Thread.sleep(interval.millis()).                 } catch (InterruptedException ie) {                     Thread.currentThread().interrupt().                 }             }         }     }     return true. }
