commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;14;;@Override protected Settings nodeSettings(int nodeOrdinal) {     return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(XPackSettings.MONITORING_ENABLED.getKey(), false).put(XPackSettings.SECURITY_ENABLED.getKey(), false).put(LicenseService.SELF_GENERATED_LICENSE_TYPE.getKey(), "trial").put("index.store.mock.check_index_on_close", false).put("xpack.watcher.execution.scroll.size", randomIntBetween(1, 100)).put("xpack.watcher.watch.scroll.size", randomIntBetween(1, 100)).build(). }
false;protected;0;8;;@Override protected Settings transportClientSettings() {     return Settings.builder().put("client.transport.sniff", false).put(NetworkModule.TRANSPORT_TYPE_KEY, SecurityField.NAME4).put(NetworkModule.HTTP_TYPE_KEY, SecurityField.NAME4).build(). }
false;protected;0;6;;@Override protected Set<String> excludeTemplates() {     Set<String> excludes = new HashSet<>().     excludes.addAll(Arrays.asList(WatcherIndexTemplateRegistryField.TEMPLATE_NAMES)).     return Collections.unmodifiableSet(excludes). }
false;protected;0;11;;@Override protected Collection<Class<? extends Plugin>> getMockPlugins() {     Set<Class<? extends Plugin>> plugins = new HashSet<>(super.getMockPlugins()).     // security has its own transport service     plugins.remove(MockTransportService.TestPlugin.class).     // security has its own transport     // we have to explicitly add it otherwise we will fail to set the check_index_on_close setting     plugins.add(MockFSIndexStore.TestPlugin.class).     plugins.add(MockMustacheScriptEngine.TestPlugin.class).     return plugins. }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return pluginTypes(). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> transportClientPlugins() {     return nodePlugins(). }
false;protected;0;14;;protected List<Class<? extends Plugin>> pluginTypes() {     List<Class<? extends Plugin>> types = new ArrayList<>().     if (timeWarped()) {         types.add(TimeWarpedWatcher.class).     } else {         types.add(LocalStateWatcher.class).     }     types.add(CommonAnalysisPlugin.class).     // ILM is required for watcher template index settings     types.add(IndexLifecycle.class).     return types. }
true;protected;0;3;/**  * @return  whether the test suite should run in time warp mode. By default this will be determined globally  *          to all test suites based on {@code -Dtests.timewarp} system property (when missing, defaults to  *          {@code true}). If a test suite requires to force the mode or force not running under this mode  *          this method can be overridden.  */ ;/**  * @return  whether the test suite should run in time warp mode. By default this will be determined globally  *          to all test suites based on {@code -Dtests.timewarp} system property (when missing, defaults to  *          {@code true}). If a test suite requires to force the mode or force not running under this mode  *          this method can be overridden.  */ protected boolean timeWarped() {     return true. }
false;public;0;22;;@Before public void _setup() throws Exception {     if (timeWarped()) {         timeWarp = new TimeWarp(internalCluster().getInstances(ScheduleTriggerEngineMock.class), (ClockMock) getInstanceFromMaster(Clock.class)).     }     if (internalCluster().size() > 0) {         ensureLicenseEnabled().         if (timeWarped()) {             // now that the license is enabled and valid we can freeze all nodes clocks             logger.info("[{}#{}]: freezing time on nodes", getTestClass().getSimpleName(), getTestName()).             TimeFreezeDisruption ice = new TimeFreezeDisruption().             internalCluster().setDisruptionScheme(ice).             ice.startDisrupting().         }         createWatcherIndicesOrAliases().         startWatcher().     } }
false;public;0;6;;@After public void _cleanup() throws Exception {     // Clear all internal watcher state for the next test method:     logger.info("[#{}]: clearing watcher state", getTestName()).     stopWatcher(). }
true;private;0;43;/**  * In order to test, that .watches and .triggered-watches indices can also point to an alias, we will rarely create those  * after starting watcher  *  * The idea behind this is the possible use of the migration helper for upgrades, see  * https://github.com/elastic/elasticsearch-migration/  */ ;/**  * In order to test, that .watches and .triggered-watches indices can also point to an alias, we will rarely create those  * after starting watcher  *  * The idea behind this is the possible use of the migration helper for upgrades, see  * https://github.com/elastic/elasticsearch-migration/  */ private void createWatcherIndicesOrAliases() throws Exception {     if (internalCluster().size() > 0) {         ensureWatcherTemplatesAdded().         // alias for .watches, setting the index template to the same as well         String watchIndexName.         String triggeredWatchIndexName.         if (rarely()) {             watchIndexName = ".watches-alias-index".             CreateIndexResponse response = client().admin().indices().prepareCreate(watchIndexName).setCause("Index to test aliases with .watches index").addAlias(new Alias(Watch.INDEX)).get().             assertAcked(response).             logger.info("set alias for .watches index to [{}]", watchIndexName).         } else {             watchIndexName = Watch.INDEX.             Settings.Builder builder = Settings.builder().             if (randomBoolean()) {                 builder.put("index.number_of_shards", scaledRandomIntBetween(1, 5)).             }             assertAcked(client().admin().indices().prepareCreate(watchIndexName).setSettings(builder)).         }         // alias for .triggered-watches, ensuring the index template is set appropriately         if (rarely()) {             triggeredWatchIndexName = ".triggered_watches-alias-index".             CreateIndexResponse response = client().admin().indices().prepareCreate(triggeredWatchIndexName).setCause("Index to test aliases with .triggered-watches index").addAlias(new Alias(TriggeredWatchStoreField.INDEX_NAME)).get().             assertAcked(response).             logger.info("set alias for .triggered-watches index to [{}]", triggeredWatchIndexName).         } else {             triggeredWatchIndexName = TriggeredWatchStoreField.INDEX_NAME.             assertAcked(client().admin().indices().prepareCreate(triggeredWatchIndexName)).         }         String historyIndex = HistoryStoreField.getHistoryIndexNameForTime(ZonedDateTime.now(ZoneOffset.UTC)).         assertAcked(client().admin().indices().prepareCreate(historyIndex)).         logger.info("creating watch history index [{}]", historyIndex).         ensureGreen(historyIndex, watchIndexName, triggeredWatchIndexName).     } }
false;protected;0;4;;protected TimeWarp timeWarp() {     assert timeWarped() : "cannot access TimeWarp when test context is not time warped".     return timeWarp. }
false;public;0;3;;public boolean randomizeNumberOfShardsAndReplicas() {     return false. }
false;protected;3;4;;protected long docCount(String index, String type, QueryBuilder query) {     refresh().     return docCount(index, type, SearchSourceBuilder.searchSource().query(query)). }
false;protected;1;5;;protected long watchRecordCount(QueryBuilder query) {     refresh().     return docCount(HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*", HistoryStore.DOC_TYPE, SearchSourceBuilder.searchSource().query(query)). }
false;protected;3;7;;protected long docCount(String index, String type, SearchSourceBuilder source) {     SearchRequestBuilder builder = client().prepareSearch(index).setSource(source).setSize(0).     if (type != null) {         builder.setTypes(type).     }     return builder.get().getHits().getTotalHits().value. }
false;protected;1;3;;protected SearchResponse searchHistory(SearchSourceBuilder builder) {     return client().prepareSearch(HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").setSource(builder).get(). }
false;protected;1;3;;protected <T> T getInstanceFromMaster(Class<T> type) {     return internalCluster().getInstance(type, internalCluster().getMasterName()). }
false;protected;0;3;;protected WatchParser watchParser() {     return getInstanceFromMaster(WatchParser.class). }
false;protected;0;3;;protected WatcherClient watcherClient() {     return randomBoolean() ? new XPackClient(client()).watcher() : new WatcherClient(client()). }
false;private;0;3;;private IndexNameExpressionResolver indexNameExpressionResolver() {     return internalCluster().getInstance(IndexNameExpressionResolver.class). }
false;protected;3;3;;protected void assertValue(XContentSource source, String path, Matcher<?> matcher) {     assertThat(source.getValue(path), (Matcher<Object>) matcher). }
false;protected;2;4;;protected void assertWatchWithMinimumPerformedActionsCount(final String watchName, final long minimumExpectedWatchActionsWithActionPerformed) throws Exception {     assertWatchWithMinimumPerformedActionsCount(watchName, minimumExpectedWatchActionsWithActionPerformed, true). }
true;protected;3;40;// TODO remove this shitty method... the `assertConditionMet` is bogus ;// TODO remove this shitty method... the `assertConditionMet` is bogus protected void assertWatchWithMinimumPerformedActionsCount(final String watchName, final long minimumExpectedWatchActionsWithActionPerformed, final boolean assertConditionMet) throws Exception {     final AtomicReference<SearchResponse> lastResponse = new AtomicReference<>().     try {         assertBusy(() -> {             ClusterState state = client().admin().cluster().prepareState().get().getState().             String[] watchHistoryIndices = indexNameExpressionResolver().concreteIndexNames(state, IndicesOptions.lenientExpandOpen(), HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").             assertThat(watchHistoryIndices, not(emptyArray())).             for (String index : watchHistoryIndices) {                 IndexRoutingTable routingTable = state.getRoutingTable().index(index).                 assertThat(routingTable, notNullValue()).                 assertThat(routingTable.allPrimaryShardsActive(), is(true)).             }             refresh().             SearchResponse searchResponse = client().prepareSearch(HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").setIndicesOptions(IndicesOptions.lenientExpandOpen()).setQuery(boolQuery().must(matchQuery("watch_id", watchName)).must(matchQuery("state", ExecutionState.EXECUTED.id()))).get().             lastResponse.set(searchResponse).             assertThat("could not find executed watch record for watch " + watchName, searchResponse.getHits().getTotalHits().value, greaterThanOrEqualTo(minimumExpectedWatchActionsWithActionPerformed)).             if (assertConditionMet) {                 assertThat((Integer) XContentMapValues.extractValue("result.input.payload.hits.total", searchResponse.getHits().getAt(0).getSourceAsMap()), greaterThanOrEqualTo(1)).             }         }).     } catch (AssertionError error) {         SearchResponse searchResponse = lastResponse.get().         logger.info("Found [{}] records for watch [{}]", searchResponse.getHits().getTotalHits().value, watchName).         int counter = 1.         for (SearchHit hit : searchResponse.getHits().getHits()) {             logger.info("hit [{}]=\n {}", counter++, XContentHelper.convertToJson(hit.getSourceRef(), true, true)).         }         throw error.     } }
false;protected;1;6;;protected SearchResponse searchWatchRecords(Consumer<SearchRequestBuilder> requestBuilderCallback) {     SearchRequestBuilder builder = client().prepareSearch(HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").setTypes(HistoryStore.DOC_TYPE).     requestBuilderCallback.accept(builder).     return builder.get(). }
false;protected;1;8;;protected long findNumberOfPerformedActions(String watchName) {     refresh().     SearchResponse searchResponse = client().prepareSearch(HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").setIndicesOptions(IndicesOptions.lenientExpandOpen()).setQuery(boolQuery().must(matchQuery("watch_id", watchName)).must(matchQuery("state", ExecutionState.EXECUTED.id()))).get().     return searchResponse.getHits().getTotalHits().value. }
false;protected;2;35;;protected void assertWatchWithNoActionNeeded(final String watchName, final long expectedWatchActionsWithNoActionNeeded) throws Exception {     final AtomicReference<SearchResponse> lastResponse = new AtomicReference<>().     try {         assertBusy(() -> {             // The watch_history index gets created in the background when the first watch is triggered             // so we to check first is this index is created and shards are started             ClusterState state = client().admin().cluster().prepareState().get().getState().             String[] watchHistoryIndices = indexNameExpressionResolver().concreteIndexNames(state, IndicesOptions.lenientExpandOpen(), HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").             assertThat(watchHistoryIndices, not(emptyArray())).             for (String index : watchHistoryIndices) {                 IndexRoutingTable routingTable = state.getRoutingTable().index(index).                 assertThat(routingTable, notNullValue()).                 assertThat(routingTable.allPrimaryShardsActive(), is(true)).             }             refresh().             SearchResponse searchResponse = client().prepareSearch(HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").setIndicesOptions(IndicesOptions.lenientExpandOpen()).setQuery(boolQuery().must(matchQuery("watch_id", watchName)).must(matchQuery("state", ExecutionState.EXECUTION_NOT_NEEDED.id()))).get().             lastResponse.set(searchResponse).             assertThat(searchResponse.getHits().getTotalHits().value, greaterThanOrEqualTo(expectedWatchActionsWithNoActionNeeded)).         }).     } catch (AssertionError error) {         SearchResponse searchResponse = lastResponse.get().         logger.info("Found [{}] records for watch [{}]", searchResponse.getHits().getTotalHits().value, watchName).         int counter = 1.         for (SearchHit hit : searchResponse.getHits().getHits()) {             logger.info("hit [{}]=\n {}", counter++, XContentHelper.convertToJson(hit.getSourceRef(), true, true)).         }         throw error.     } }
false;protected;3;22;;protected void assertWatchWithMinimumActionsCount(final String watchName, final ExecutionState recordState, final long recordCount) throws Exception {     assertBusy(() -> {         ClusterState state = client().admin().cluster().prepareState().get().getState().         String[] watchHistoryIndices = indexNameExpressionResolver().concreteIndexNames(state, IndicesOptions.lenientExpandOpen(), HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").         assertThat(watchHistoryIndices, not(emptyArray())).         for (String index : watchHistoryIndices) {             IndexRoutingTable routingTable = state.getRoutingTable().index(index).             assertThat(routingTable, notNullValue()).             assertThat(routingTable.allPrimaryShardsActive(), is(true)).         }         refresh().         SearchResponse searchResponse = client().prepareSearch(HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").setIndicesOptions(IndicesOptions.lenientExpandOpen()).setQuery(boolQuery().must(matchQuery("watch_id", watchName)).must(matchQuery("state", recordState.id()))).get().         assertThat("could not find executed watch record", searchResponse.getHits().getTotalHits().value, greaterThanOrEqualTo(recordCount)).     }). }
false;private;0;11;;private void ensureWatcherTemplatesAdded() throws Exception {     // Verify that the index templates exist:     assertBusy(() -> {         GetIndexTemplatesResponse response = client().admin().indices().prepareGetTemplates(HISTORY_TEMPLATE_NAME).get().         assertThat("[" + HISTORY_TEMPLATE_NAME + "] is missing", response.getIndexTemplates().size(), equalTo(1)).         response = client().admin().indices().prepareGetTemplates(TRIGGERED_TEMPLATE_NAME).get().         assertThat("[" + TRIGGERED_TEMPLATE_NAME + "] is missing", response.getIndexTemplates().size(), equalTo(1)).         response = client().admin().indices().prepareGetTemplates(WATCHES_TEMPLATE_NAME).get().         assertThat("[" + WATCHES_TEMPLATE_NAME + "] is missing", response.getIndexTemplates().size(), equalTo(1)).     }). }
false;protected;0;35;;protected void startWatcher() throws Exception {     assertBusy(() -> {         WatcherStatsResponse watcherStatsResponse = watcherClient().prepareWatcherStats().get().         assertThat(watcherStatsResponse.hasFailures(), is(false)).         List<Tuple<String, WatcherState>> currentStatesFromStatsRequest = watcherStatsResponse.getNodes().stream().map(response -> Tuple.tuple(response.getNode().getName(), response.getWatcherState())).collect(Collectors.toList()).         List<WatcherState> states = currentStatesFromStatsRequest.stream().map(Tuple::v2).collect(Collectors.toList()).         logger.info("waiting to start watcher, current states {}", currentStatesFromStatsRequest).         boolean isAllStateStarted = states.stream().allMatch(w -> w == WatcherState.STARTED).         if (isAllStateStarted) {             return.         }         boolean isAnyStopping = states.stream().anyMatch(w -> w == WatcherState.STOPPING).         if (isAnyStopping) {             throw new AssertionError("at least one node is in state stopping, waiting to be stopped").         }         boolean isAllStateStopped = states.stream().allMatch(w -> w == WatcherState.STOPPED).         if (isAllStateStopped) {             assertAcked(watcherClient().prepareWatchService().start().get()).             throw new AssertionError("all nodes are stopped, restarting").         }         boolean isAnyStarting = states.stream().anyMatch(w -> w == WatcherState.STARTING).         if (isAnyStarting) {             throw new AssertionError("at least one node is in state starting, waiting to be stopped").         }         throw new AssertionError("unexpected state, retrying with next run").     }, 30, TimeUnit.SECONDS). }
false;protected;0;7;;protected void ensureLicenseEnabled() throws Exception {     assertBusy(() -> {         for (XPackLicenseState licenseState : internalCluster().getInstances(XPackLicenseState.class)) {             assertThat(licenseState.isWatcherAllowed(), is(true)).         }     }). }
false;protected;0;35;;protected void stopWatcher() throws Exception {     assertBusy(() -> {         WatcherStatsResponse watcherStatsResponse = watcherClient().prepareWatcherStats().get().         assertThat(watcherStatsResponse.hasFailures(), is(false)).         List<Tuple<String, WatcherState>> currentStatesFromStatsRequest = watcherStatsResponse.getNodes().stream().map(response -> Tuple.tuple(response.getNode().getName(), response.getWatcherState())).collect(Collectors.toList()).         List<WatcherState> states = currentStatesFromStatsRequest.stream().map(Tuple::v2).collect(Collectors.toList()).         logger.info("waiting to stop watcher, current states {}", currentStatesFromStatsRequest).         boolean isAllStateStarted = states.stream().allMatch(w -> w == WatcherState.STARTED).         if (isAllStateStarted) {             assertAcked(watcherClient().prepareWatchService().stop().get()).             throw new AssertionError("all nodes are started, stopping").         }         boolean isAnyStopping = states.stream().anyMatch(w -> w == WatcherState.STOPPING).         if (isAnyStopping) {             throw new AssertionError("at least one node is in state stopping, waiting to be stopped").         }         boolean isAllStateStopped = states.stream().allMatch(w -> w == WatcherState.STOPPED).         if (isAllStateStopped) {             return.         }         boolean isAnyStarting = states.stream().anyMatch(w -> w == WatcherState.STARTING).         if (isAnyStarting) {             throw new AssertionError("at least one node is in state starting, waiting to be started before stopping").         }         throw new AssertionError("unexpected state, retrying with next run").     }). }
false;public;4;4;;@Override public EmailSent send(Email email, Authentication auth, Profile profile, String accountName) {     return new EmailSent(accountName, email). }
false;public;1;3;;public void trigger(String jobName) {     trigger(jobName, 1, null). }
false;public;0;3;;public ClockMock clock() {     return clock. }
false;public;3;5;;public void trigger(String watchId, int times, TimeValue timeValue) {     boolean isTriggered = schedulers.stream().anyMatch(scheduler -> scheduler.trigger(watchId, times, timeValue)).     String msg = String.format(Locale.ROOT, "could not find watch [%s] to trigger", watchId).     assertThat(msg, isTriggered, is(true)). }
false;public;1;4;;@Override public void applyToCluster(InternalTestCluster cluster) {     this.cluster = cluster. }
false;public;1;4;;@Override public void removeFromCluster(InternalTestCluster cluster) {     stopDisrupting(). }
false;public;1;4;;@Override public void removeAndEnsureHealthy(InternalTestCluster cluster) {     stopDisrupting(). }
false;public,synchronized;2;6;;@Override public synchronized void applyToNode(String node, InternalTestCluster cluster) {     if (frozen) {         ((ClockMock) cluster.getInstance(Clock.class, node)).freeze().     } }
false;public;2;4;;@Override public void removeFromNode(String node, InternalTestCluster cluster) {     ((ClockMock) cluster.getInstance(Clock.class, node)).unfreeze(). }
false;public,synchronized;0;7;;@Override public synchronized void startDisrupting() {     frozen = true.     for (String node : cluster.getNodeNames()) {         applyToNode(node, cluster).     } }
false;public;0;7;;@Override public void stopDisrupting() {     frozen = false.     for (String node : cluster.getNodeNames()) {         removeFromNode(node, cluster).     } }
false;public;0;3;;@Override public void testClusterClosed() { }
false;public;0;4;;@Override public TimeValue expectedTimeToHeal() {     return TimeValue.ZERO. }
false;public;0;4;;@Override public String toString() {     return "time frozen". }
