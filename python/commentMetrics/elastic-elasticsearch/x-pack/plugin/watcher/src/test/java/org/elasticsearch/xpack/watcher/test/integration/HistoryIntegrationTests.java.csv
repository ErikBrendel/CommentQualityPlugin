commented;modifiers;parameterAmount;loc;comment;code
true;public;0;23;// issue: https://github.com/elastic/x-plugins/issues/2338 ;// issue: https://github.com/elastic/x-plugins/issues/2338 public void testThatHistoryIsWrittenWithChainedInput() throws Exception {     XContentBuilder xContentBuilder = jsonBuilder().startObject().startObject("inner").field("date", "2015-06-06").endObject().endObject().     index("foo", "bar", "1", xContentBuilder).     refresh().     WatchSourceBuilder builder = watchBuilder().trigger(schedule(interval("10s"))).addAction("logging", loggingAction("foo")).     builder.input(chainInput().add("first", searchInput(templateRequest(searchSource().sort(SortBuilders.fieldSort("inner.date").order(SortOrder.DESC)), "foo")))).     PutWatchResponse response = watcherClient().preparePutWatch("test_watch").setSource(builder).get().     assertThat(response.isCreated(), is(true)).     watcherClient().prepareExecuteWatch("test_watch").setRecordExecution(true).get().     flushAndRefresh(".watcher-history-*").     SearchResponse searchResponse = client().prepareSearch(".watcher-history-*").get().     assertHitCount(searchResponse, 1). }
true;public;0;42;// See https://github.com/elastic/x-plugins/issues/2913 ;// See https://github.com/elastic/x-plugins/issues/2913 public void testFailedInputResultWithDotsInFieldNameGetsStored() throws Exception {     WatcherSearchTemplateRequest request = templateRequest(searchSource().query(matchAllQuery()).sort("trigger_event.triggered_time", SortOrder.DESC).size(1), "non-existing-index").     // The result of the search input will be a failure, because a missing index does not exist when     // the query is executed     Input.Builder input = searchInput(request).     // wrapping this randomly into a chained input to test this as well     boolean useChained = randomBoolean().     if (useChained) {         input = chainInput().add("chained", input).     }     watcherClient().preparePutWatch("test_watch").setSource(watchBuilder().trigger(schedule(interval(5, IntervalSchedule.Interval.Unit.HOURS))).input(input).addAction("_logger", loggingAction("#### randomLogging"))).get().     watcherClient().prepareExecuteWatch("test_watch").setRecordExecution(true).get().     refresh(".watcher-history*").     SearchResponse searchResponse = client().prepareSearch(".watcher-history*").setSize(0).get().     assertHitCount(searchResponse, 1).     // as fields with dots are allowed in 5.0 again, the mapping must be checked in addition     GetMappingsResponse response = client().admin().indices().prepareGetMappings(".watcher-history*").addTypes("doc").get().     byte[] bytes = response.getMappings().values().iterator().next().value.get("doc").source().uncompressed().     XContentSource source = new XContentSource(new BytesArray(bytes), XContentType.JSON).     // lets make sure the body fields are disabled     if (useChained) {         String chainedPath = "doc.properties.result.properties.input.properties.chain.properties.chained.properties.search" + ".properties.request.properties.body.enabled".         assertThat(source.getValue(chainedPath), is(false)).     } else {         String path = "doc.properties.result.properties.input.properties.search.properties.request.properties.body.enabled".         assertThat(source.getValue(path), is(false)).     } }
true;public;0;36;// See https://github.com/elastic/x-plugins/issues/2913 ;// See https://github.com/elastic/x-plugins/issues/2913 public void testPayloadInputWithDotsInFieldNameWorks() throws Exception {     Input.Builder input = simpleInput("foo.bar", "bar").     // wrapping this randomly into a chained input to test this as well     boolean useChained = randomBoolean().     if (useChained) {         input = chainInput().add("chained", input).     }     watcherClient().preparePutWatch("test_watch").setSource(watchBuilder().trigger(schedule(interval(5, IntervalSchedule.Interval.Unit.HOURS))).input(input).addAction("_logger", loggingAction("#### randomLogging"))).get().     watcherClient().prepareExecuteWatch("test_watch").setRecordExecution(true).get().     refresh(".watcher-history*").     SearchResponse searchResponse = client().prepareSearch(".watcher-history*").setSize(0).get().     assertHitCount(searchResponse, 1).     // as fields with dots are allowed in 5.0 again, the mapping must be checked in addition     GetMappingsResponse response = client().admin().indices().prepareGetMappings(".watcher-history*").addTypes("doc").get().     byte[] bytes = response.getMappings().values().iterator().next().value.get("doc").source().uncompressed().     XContentSource source = new XContentSource(new BytesArray(bytes), XContentType.JSON).     // lets make sure the body fields are disabled     if (useChained) {         String path = "doc.properties.result.properties.input.properties.chain.properties.chained.properties.payload.enabled".         assertThat(source.getValue(path), is(false)).     } else {         String path = "doc.properties.result.properties.input.properties.payload.enabled".         assertThat(source.getValue(path), is(false)).     } }
false;public;0;49;;public void testThatHistoryContainsStatus() throws Exception {     watcherClient().preparePutWatch("test_watch").setSource(watchBuilder().trigger(schedule(interval(5, IntervalSchedule.Interval.Unit.HOURS))).input(simpleInput("foo", "bar")).addAction("_logger", loggingAction("#### randomLogging"))).get().     watcherClient().prepareExecuteWatch("test_watch").setRecordExecution(true).get().     WatchStatus status = watcherClient().prepareGetWatch("test_watch").get().getStatus().     refresh(".watcher-history*").     SearchResponse searchResponse = client().prepareSearch(".watcher-history*").setSize(1).get().     assertHitCount(searchResponse, 1).     SearchHit hit = searchResponse.getHits().getAt(0).     XContentSource source = new XContentSource(hit.getSourceRef(), XContentType.JSON).     Boolean active = source.getValue("status.state.active").     assertThat(active, is(status.state().isActive())).     String timestamp = source.getValue("status.state.timestamp").     assertThat(timestamp, WatcherTestUtils.isSameDate(status.state().getTimestamp())).     String lastChecked = source.getValue("status.last_checked").     assertThat(lastChecked, WatcherTestUtils.isSameDate(status.lastChecked())).     String lastMetCondition = source.getValue("status.last_met_condition").     assertThat(lastMetCondition, WatcherTestUtils.isSameDate(status.lastMetCondition())).     Integer version = source.getValue("status.version").     int expectedVersion = (int) (status.version() - 1).     assertThat(version, is(expectedVersion)).     ActionStatus actionStatus = status.actionStatus("_logger").     String ackStatusState = source.getValue("status.actions._logger.ack.state").toString().toUpperCase(Locale.ROOT).     assertThat(ackStatusState, is(actionStatus.ackStatus().state().toString())).     Boolean lastExecutionSuccesful = source.getValue("status.actions._logger.last_execution.successful").     assertThat(lastExecutionSuccesful, is(actionStatus.lastExecution().successful())).     // also ensure that the status field is disabled in the watch history     GetMappingsResponse response = client().admin().indices().prepareGetMappings(".watcher-history*").addTypes("doc").get().     byte[] bytes = response.getMappings().values().iterator().next().value.get("doc").source().uncompressed().     XContentSource mappingSource = new XContentSource(new BytesArray(bytes), XContentType.JSON).     assertThat(mappingSource.getValue("doc.properties.status.enabled"), is(false)).     assertThat(mappingSource.getValue("doc.properties.status.properties.status"), is(nullValue())).     assertThat(mappingSource.getValue("doc.properties.status.properties.status.properties.active"), is(nullValue())). }
