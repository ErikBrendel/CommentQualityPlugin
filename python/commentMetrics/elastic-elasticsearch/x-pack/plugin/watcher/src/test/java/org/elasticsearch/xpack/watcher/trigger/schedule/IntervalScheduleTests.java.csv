commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;public void testParseNumber() throws Exception {     long value = randomIntBetween(0, Integer.MAX_VALUE).     XContentBuilder builder = jsonBuilder().value(value).     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     IntervalSchedule schedule = new IntervalSchedule.Parser().parse(parser).     assertThat(schedule, notNullValue()).     assertThat(schedule.interval().seconds(), is(value)). }
false;public;0;14;;public void testParseNegativeNumber() throws Exception {     long value = randomIntBetween(Integer.MIN_VALUE, 0).     XContentBuilder builder = jsonBuilder().value(value).     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     try {         new IntervalSchedule.Parser().parse(parser).         fail("exception expected, because interval is negative").     } catch (ElasticsearchParseException e) {         assertThat(e.getCause(), instanceOf(IllegalArgumentException.class)).         assertThat(e.getCause().getMessage(), containsString("interval can't be lower than 1000 ms, but")).     } }
false;public;0;10;;public void testParseString() throws Exception {     IntervalSchedule.Interval value = randomTimeInterval().     XContentBuilder builder = jsonBuilder().value(value).     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     IntervalSchedule schedule = new IntervalSchedule.Parser().parse(parser).     assertThat(schedule, notNullValue()).     assertThat(schedule.interval(), is(value)). }
false;public;0;12;;public void testParseInvalidString() throws Exception {     XContentBuilder builder = jsonBuilder().value("43S").     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     try {         new IntervalSchedule.Parser().parse(parser).         fail("Expected ElasticsearchParseException").     } catch (ElasticsearchParseException e) {         assertThat(e.getMessage(), containsString("unrecognized interval format [43S]")).     } }
false;public;0;13;;public void testParseInvalidObject() throws Exception {     XContentBuilder builder = jsonBuilder().startObject().endObject().     BytesReference bytes = BytesReference.bytes(builder).     XContentParser parser = createParser(JsonXContent.jsonXContent, bytes).     // advancing to the start object     parser.nextToken().     try {         new IntervalSchedule.Parser().parse(parser).     } catch (ElasticsearchParseException e) {         assertThat(e.getMessage(), containsString("expected either a numeric value (millis) or a string value representing time value")).         assertThat(e.getMessage(), containsString("found [START_OBJECT]")).     } }
false;private,static;0;5;;private static IntervalSchedule.Interval randomTimeInterval() {     int randomSize = randomIntBetween(0, IntervalSchedule.Interval.Unit.values().length - 1).     IntervalSchedule.Interval.Unit unit = IntervalSchedule.Interval.Unit.values()[randomSize].     return new IntervalSchedule.Interval(randomIntBetween(1, 100), unit). }
