commented;modifiers;parameterAmount;loc;comment;code
true;public;0;41;/* note, first line does not need to be parsed     "chain" : {       "inputs" : [         { "first" : { "simple" : { "foo" : "bar" } } },         { "second" : { "simple" : { "spam" : "eggs" } } }       ]     }      */ ;/* note, first line does not need to be parsed     "chain" : {       "inputs" : [         { "first" : { "simple" : { "foo" : "bar" } } },         { "second" : { "simple" : { "spam" : "eggs" } } }       ]     }      */ public void testThatExecutionWorks() throws Exception {     Map<String, InputFactory> factories = new HashMap<>().     factories.put("simple", new SimpleInputFactory()).     // hackedy hack...     InputRegistry inputRegistry = new InputRegistry(factories).     ChainInputFactory chainInputFactory = new ChainInputFactory(inputRegistry).     factories.put("chain", chainInputFactory).     XContentBuilder builder = jsonBuilder().startObject().startArray("inputs").startObject().startObject("first").startObject("simple").field("foo", "bar").endObject().endObject().endObject().startObject().startObject("second").startObject("simple").field("spam", "eggs").endObject().endObject().endObject().endArray().endObject().     // first pass JSON and check for correct inputs     XContentParser parser = createParser(builder).     parser.nextToken().     ChainInput chainInput = chainInputFactory.parseInput("test", parser).     assertThat(chainInput.getInputs(), hasSize(2)).     assertThat(chainInput.getInputs().get(0).v1(), is("first")).     assertThat(chainInput.getInputs().get(0).v2(), instanceOf(SimpleInput.class)).     assertThat(chainInput.getInputs().get(1).v1(), is("second")).     assertThat(chainInput.getInputs().get(1).v2(), instanceOf(SimpleInput.class)).     // now execute     ExecutableChainInput executableChainInput = chainInputFactory.createExecutable(chainInput).     WatchExecutionContext ctx = WatcherTestUtils.createWatchExecutionContext().     ChainInput.Result result = executableChainInput.execute(ctx, new Payload.Simple()).     Payload payload = result.payload().     assertThat(payload.data(), hasKey("first")).     assertThat(payload.data(), hasKey("second")).     assertThat(payload.data().get("first"), instanceOf(Map.class)).     assertThat(payload.data().get("second"), instanceOf(Map.class)).     // final payload check     Map<String, Object> firstPayload = (Map<String, Object>) payload.data().get("first").     Map<String, Object> secondPayload = (Map<String, Object>) payload.data().get("second").     assertThat(firstPayload, hasEntry("foo", "bar")).     assertThat(secondPayload, hasEntry("spam", "eggs")). }
false;public;0;29;;public void testToXContent() throws Exception {     ChainInput chainedInput = chainInput().add("first", simpleInput("foo", "bar")).add("second", simpleInput("spam", "eggs")).build().     XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).     chainedInput.toXContent(builder, ToXContent.EMPTY_PARAMS).     assertThat(BytesReference.bytes(builder).utf8ToString(), is("{\"inputs\":[{\"first\":{\"simple\":{\"foo\":\"bar\"}}},{\"second\":{\"simple\":{\"spam\":\"eggs\"}}}]}")).     // parsing it back as well!     Map<String, InputFactory> factories = new HashMap<>().     factories.put("simple", new SimpleInputFactory()).     InputRegistry inputRegistry = new InputRegistry(factories).     ChainInputFactory chainInputFactory = new ChainInputFactory(inputRegistry).     factories.put("chain", chainInputFactory).     XContentParser parser = createParser(builder).     parser.nextToken().     ChainInput parsedChainInput = ChainInput.parse("testWatchId", parser, inputRegistry).     assertThat(parsedChainInput.getInputs(), hasSize(2)).     assertThat(parsedChainInput.getInputs().get(0).v1(), is("first")).     assertThat(parsedChainInput.getInputs().get(0).v2(), is(instanceOf(SimpleInput.class))).     assertThat(parsedChainInput.getInputs().get(1).v1(), is("second")).     assertThat(parsedChainInput.getInputs().get(1).v2(), is(instanceOf(SimpleInput.class))). }
false;public;0;21;;public void testThatWatchSourceBuilderWorksWithChainInput() throws Exception {     XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).     HttpInput.Builder httpInputBuilder = httpInput(HttpRequestTemplate.builder("theHost", 1234).path("/index/_search").body(Strings.toString(jsonBuilder().startObject().field("size", 1).endObject())).auth(new BasicAuth("test", SecuritySettingsSourceField.TEST_PASSWORD.toCharArray()))).     ChainInput.Builder chainedInputBuilder = chainInput().add("foo", httpInputBuilder).add("bar", simpleInput("spam", "eggs")).     watchBuilder().trigger(schedule(interval("5s"))).input(chainedInputBuilder).condition(new ScriptCondition(mockScript("ctx.payload.hits.total.value == 1"))).addAction("_id", loggingAction("watch [{{ctx.watch_id}}] matched")).toXContent(builder, ToXContent.EMPTY_PARAMS). // no exception means all good }
false;public;0;8;;public void testThatSerializationOfFailedInputWorks() throws Exception {     ChainInput.Result chainedResult = new ChainInput.Result(new ElasticsearchException("foo")).     XContentBuilder builder = jsonBuilder().     chainedResult.toXContent(builder, ToXContent.EMPTY_PARAMS).     assertThat(BytesReference.bytes(builder).utf8ToString(), containsString("\"type\":\"exception\"")).     assertThat(BytesReference.bytes(builder).utf8ToString(), containsString("\"reason\":\"foo\"")). }
true;public;0;20;/* https://github.com/elastic/x-plugins/issues/3736        the issue here is, that first/second in this setup do not have a guaranteed order, so we have to throw an exception     {       "inputs" : [         {           "first" : { "simple" : { "foo" : "bar" } },           "second" : { "simple" : { "spam" : "eggs" } }         }       ]     }      */ ;/* https://github.com/elastic/x-plugins/issues/3736        the issue here is, that first/second in this setup do not have a guaranteed order, so we have to throw an exception     {       "inputs" : [         {           "first" : { "simple" : { "foo" : "bar" } },           "second" : { "simple" : { "spam" : "eggs" } }         }       ]     }      */ public void testParsingShouldBeStrictWhenClosingInputs() throws Exception {     Map<String, InputFactory> factories = new HashMap<>().     factories.put("simple", new SimpleInputFactory()).     InputRegistry inputRegistry = new InputRegistry(factories).     ChainInputFactory chainInputFactory = new ChainInputFactory(inputRegistry).     factories.put("chain", chainInputFactory).     XContentBuilder builder = jsonBuilder().startObject().startArray("inputs").startObject().startObject("first").startObject("simple").field("foo", "bar").endObject().endObject().startObject("second").startObject("simple").field("spam", "eggs").endObject().endObject().endObject().endArray().endObject().     XContentParser parser = createParser(builder).     parser.nextToken().     ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> chainInputFactory.parseInput("test", parser)).     assertThat(e.getMessage(), containsString("Expected closing JSON object after parsing input [simple] named [first] in watch [test]")). }
true;public;0;20;/* https://github.com/elastic/x-plugins/issues/3736        make sure that after the name of a chained input there is always an object     {       "inputs" : [         { "first" : [ { "simple" : { "foo" : "bar" } } ] }       ]     }      */ ;/* https://github.com/elastic/x-plugins/issues/3736        make sure that after the name of a chained input there is always an object     {       "inputs" : [         { "first" : [ { "simple" : { "foo" : "bar" } } ] }       ]     }      */ public void testParsingShouldBeStrictWhenStartingInputs() throws Exception {     Map<String, InputFactory> factories = new HashMap<>().     factories.put("simple", new SimpleInputFactory()).     InputRegistry inputRegistry = new InputRegistry(factories).     ChainInputFactory chainInputFactory = new ChainInputFactory(inputRegistry).     factories.put("chain", chainInputFactory).     XContentBuilder builder = jsonBuilder().startObject().startArray("inputs").startObject().startArray("first").startObject().startObject("simple").field("foo", "bar").endObject().endObject().endArray().endObject().endArray().endObject().     XContentParser parser = createParser(builder).     parser.nextToken().     ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> chainInputFactory.parseInput("test", parser)).     assertThat(e.getMessage(), containsString("Expected starting JSON object after [first] in watch [test]")). }
false;public;0;4;;@Override public String type() {     return "test". }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) {     assertThat(params, sameInstance(randomParams)).     return builder. }
false;public;0;19;;public void testThatXContentParametersArePassedToInputs() throws Exception {     ToXContent.Params randomParams = new ToXContent.MapParams(Collections.singletonMap(randomAlphaOfLength(5), randomAlphaOfLength(5))).     ChainInput chainInput = new ChainInput(Collections.singletonList(Tuple.tuple("whatever", new Input() {          @Override         public String type() {             return "test".         }          @Override         public XContentBuilder toXContent(XContentBuilder builder, Params params) {             assertThat(params, sameInstance(randomParams)).             return builder.         }     }))).     try (XContentBuilder builder = jsonBuilder()) {         chainInput.toXContent(builder, randomParams).     } }
