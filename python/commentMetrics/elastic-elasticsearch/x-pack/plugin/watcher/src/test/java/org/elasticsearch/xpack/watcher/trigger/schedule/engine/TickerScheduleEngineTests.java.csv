commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void init() throws Exception {     engine = createEngine(). }
false;private;0;8;;private TickerScheduleTriggerEngine createEngine() {     Settings settings = Settings.EMPTY.     // having a low value here speeds up the tests tremendously, we still want to run with the defaults every now and then     if (usually()) {         settings = Settings.builder().put(TickerScheduleTriggerEngine.TICKER_INTERVAL_SETTING.getKey(), "10ms").build().     }     return new TickerScheduleTriggerEngine(settings, mock(ScheduleRegistry.class), clock). }
false;private;1;3;;private void advanceClockIfNeeded(ZonedDateTime newCurrentDateTime) {     clock.setTime(newCurrentDateTime). }
false;public;0;4;;@After public void cleanup() throws Exception {     engine.stop(). }
false;public;1;14;;@Override public void accept(Iterable<TriggerEvent> events) {     for (TriggerEvent event : events) {         int index = Integer.parseInt(event.jobName()).         if (!bits.get(index)) {             logger.info("job [{}] first fire", index).             bits.set(index).             firstLatch.countDown().         } else {             logger.info("job [{}] second fire", index).             secondLatch.countDown().         }     } }
false;public;0;40;;public void testStart() throws Exception {     int count = randomIntBetween(2, 5).     final CountDownLatch firstLatch = new CountDownLatch(count).     final CountDownLatch secondLatch = new CountDownLatch(count).     List<Watch> watches = new ArrayList<>().     for (int i = 0. i < count. i++) {         watches.add(createWatch(String.valueOf(i), interval("1s"))).     }     final BitSet bits = new BitSet(count).     engine.register(new Consumer<Iterable<TriggerEvent>>() {          @Override         public void accept(Iterable<TriggerEvent> events) {             for (TriggerEvent event : events) {                 int index = Integer.parseInt(event.jobName()).                 if (!bits.get(index)) {                     logger.info("job [{}] first fire", index).                     bits.set(index).                     firstLatch.countDown().                 } else {                     logger.info("job [{}] second fire", index).                     secondLatch.countDown().                 }             }         }     }).     engine.start(watches).     advanceClockIfNeeded(clock.instant().plusMillis(1100).atZone(ZoneOffset.UTC)).     if (!firstLatch.await(3 * count, TimeUnit.SECONDS)) {         fail("waiting too long for all watches to be triggered").     }     advanceClockIfNeeded(clock.instant().plusMillis(1100).atZone(ZoneOffset.UTC)).     if (!secondLatch.await(3 * count, TimeUnit.SECONDS)) {         fail("waiting too long for all watches to be triggered").     }     engine.stop().     assertThat(bits.cardinality(), is(count)). }
false;public;1;8;;@Override public void accept(Iterable<TriggerEvent> events) {     for (TriggerEvent event : events) {         assertThat(event.jobName(), is(name)).         logger.info("triggered job on [{}]", clock).     }     latch.countDown(). }
false;public;0;33;;public void testAddHourly() throws Exception {     final String name = "job_name".     final CountDownLatch latch = new CountDownLatch(1).     engine.start(Collections.emptySet()).     engine.register(new Consumer<Iterable<TriggerEvent>>() {          @Override         public void accept(Iterable<TriggerEvent> events) {             for (TriggerEvent event : events) {                 assertThat(event.jobName(), is(name)).                 logger.info("triggered job on [{}]", clock).             }             latch.countDown().         }     }).     int randomMinute = randomIntBetween(0, 59).     ZonedDateTime testNowTime = clock.instant().atZone(ZoneOffset.UTC).with(ChronoField.MINUTE_OF_HOUR, randomMinute).with(ChronoField.SECOND_OF_MINUTE, 59).     ZonedDateTime scheduledTime = testNowTime.plusSeconds(2).     logger.info("Setting current time to [{}], job execution time [{}]", testNowTime, scheduledTime).     clock.setTime(testNowTime).     engine.add(createWatch(name, daily().at(scheduledTime.getHour(), scheduledTime.getMinute()).build())).     advanceClockIfNeeded(scheduledTime).     if (!latch.await(5, TimeUnit.SECONDS)) {         fail("waiting too long for all watches to be triggered").     } }
false;public;1;8;;@Override public void accept(Iterable<TriggerEvent> events) {     for (TriggerEvent event : events) {         assertThat(event.jobName(), is(name)).         logger.info("triggered job on [{}]", clock.instant().atZone(ZoneOffset.UTC)).         latch.countDown().     } }
false;public;0;36;;public void testAddDaily() throws Exception {     final String name = "job_name".     final CountDownLatch latch = new CountDownLatch(1).     engine.start(Collections.emptySet()).     engine.register(new Consumer<Iterable<TriggerEvent>>() {          @Override         public void accept(Iterable<TriggerEvent> events) {             for (TriggerEvent event : events) {                 assertThat(event.jobName(), is(name)).                 logger.info("triggered job on [{}]", clock.instant().atZone(ZoneOffset.UTC)).                 latch.countDown().             }         }     }).     int randomHour = randomIntBetween(0, 23).     int randomMinute = randomIntBetween(0, 59).     ZonedDateTime testNowTime = clock.instant().atZone(ZoneOffset.UTC).with(ChronoField.HOUR_OF_DAY, randomHour).with(ChronoField.MINUTE_OF_HOUR, randomMinute).with(ChronoField.SECOND_OF_MINUTE, 59).     ZonedDateTime scheduledTime = testNowTime.plusSeconds(2).     logger.info("Setting current time to [{}], job execution time [{}]", testNowTime, scheduledTime).     clock.setTime(testNowTime).     engine.add(createWatch(name, daily().at(scheduledTime.getHour(), scheduledTime.getMinute()).build())).     advanceClockIfNeeded(scheduledTime).     if (!latch.await(5, TimeUnit.SECONDS)) {         fail("waiting too long for all watches to be triggered").     } }
false;public;1;8;;@Override public void accept(Iterable<TriggerEvent> events) {     for (TriggerEvent event : events) {         assertThat(event.jobName(), is(name)).         logger.info("triggered job").     }     latch.countDown(). }
false;public;0;44;;public void testAddWeekly() throws Exception {     final String name = "job_name".     final CountDownLatch latch = new CountDownLatch(1).     engine.start(Collections.emptySet()).     engine.register(new Consumer<Iterable<TriggerEvent>>() {          @Override         public void accept(Iterable<TriggerEvent> events) {             for (TriggerEvent event : events) {                 assertThat(event.jobName(), is(name)).                 logger.info("triggered job").             }             latch.countDown().         }     }).     int randomHour = randomIntBetween(0, 23).     int randomMinute = randomIntBetween(0, 59).     int randomDay = randomIntBetween(1, 7).     ZonedDateTime testNowTime = clock.instant().atZone(ZoneOffset.UTC).with(ChronoField.DAY_OF_WEEK, randomDay).with(ChronoField.HOUR_OF_DAY, randomHour).with(ChronoField.MINUTE_OF_HOUR, randomMinute).with(ChronoField.SECOND_OF_MINUTE, 59).     ZonedDateTime scheduledTime = testNowTime.plusSeconds(2).     logger.info("Setting current time to [{}], job execution time [{}]", testNowTime, scheduledTime).     clock.setTime(testNowTime).     // fun part here (aka WTF): DayOfWeek with Joda is MON-SUN, starting at 1     // DayOfWeek with Watcher is SUN-SAT, starting at 1     int watcherDay = (scheduledTime.getDayOfWeek().getValue() % 7) + 1.     engine.add(createWatch(name, weekly().time(WeekTimes.builder().on(DayOfWeek.resolve(watcherDay)).at(scheduledTime.getHour(), scheduledTime.getMinute()).build()).build())).     advanceClockIfNeeded(scheduledTime).     if (!latch.await(5, TimeUnit.SECONDS)) {         fail("waiting too long for all watches to be triggered").     } }
false;public;1;10;;@Override public void accept(Iterable<TriggerEvent> events) {     events.forEach(event -> {         if (counter.getAndIncrement() == 0) {             firstLatch.countDown().         } else {             secondLatch.countDown().         }     }). }
false;public;0;37;;public void testAddSameJobSeveralTimesAndExecutedOnce() throws InterruptedException {     engine.start(Collections.emptySet()).     final CountDownLatch firstLatch = new CountDownLatch(1).     final CountDownLatch secondLatch = new CountDownLatch(1).     AtomicInteger counter = new AtomicInteger(0).     engine.register(new Consumer<Iterable<TriggerEvent>>() {          @Override         public void accept(Iterable<TriggerEvent> events) {             events.forEach(event -> {                 if (counter.getAndIncrement() == 0) {                     firstLatch.countDown().                 } else {                     secondLatch.countDown().                 }             }).         }     }).     int times = scaledRandomIntBetween(3, 30).     for (int i = 0. i < times. i++) {         engine.add(createWatch("_id", interval("1s"))).     }     advanceClockIfNeeded(clock.instant().plusMillis(1100).atZone(ZoneOffset.UTC)).     if (!firstLatch.await(3, TimeUnit.SECONDS)) {         fail("waiting too long for all watches to be triggered").     }     advanceClockIfNeeded(clock.instant().plusMillis(1100).atZone(ZoneOffset.UTC)).     if (!secondLatch.await(3, TimeUnit.SECONDS)) {         fail("waiting too long for all watches to be triggered").     }     // ensure job was only called twice independent from its name     assertThat(counter.get(), is(2)). }
false;public;0;15;;public void testAddOnlyWithNewSchedule() {     engine.start(Collections.emptySet()).     // add watch with schedule     Watch oncePerSecondWatch = createWatch("_id", interval("1s")).     engine.add(oncePerSecondWatch).     TickerScheduleTriggerEngine.ActiveSchedule activeSchedule = engine.getSchedules().get("_id").     engine.add(oncePerSecondWatch).     assertThat(engine.getSchedules().get("_id"), is(activeSchedule)).     // add watch with same id but different watch     Watch oncePerMinuteWatch = createWatch("_id", interval("1m")).     engine.add(oncePerMinuteWatch).     assertThat(engine.getSchedules().get("_id"), not(is(activeSchedule))). }
false;private;2;5;;private Watch createWatch(String name, Schedule schedule) {     return new Watch(name, new ScheduleTrigger(schedule), new ExecutableNoneInput(), InternalAlwaysCondition.INSTANCE, null, null, Collections.emptyList(), null, null, SequenceNumbers.UNASSIGNED_SEQ_NO, SequenceNumbers.UNASSIGNED_PRIMARY_TERM). }
