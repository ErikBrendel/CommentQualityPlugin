commented;modifiers;parameterAmount;loc;comment;code
true;public;0;47;// The mock webserver does not support count down latches, so we have to use sleep - sorry! ;// This is a special case, since locking is removed // Deleting a watch while it is being executed is possible now // This test ensures that there are no leftovers, like a watch status without a watch in the watch store // Also the watch history is checked, that the error has been marked as deleted // The mock webserver does not support count down latches, so we have to use sleep - sorry! public void testWatchDeletionDuringExecutionWorks() throws Exception {     MockResponse response = new MockResponse().     response.setBody("foo").     response.setResponseCode(200).     response.setBodyDelay(TimeValue.timeValueSeconds(5)).     try (MockWebServer server = new MockWebServer()) {         server.enqueue(response).         server.start().         HttpRequestTemplate template = HttpRequestTemplate.builder(server.getHostName(), server.getPort()).path("/").build().         PutWatchResponse responseFuture = watcherClient().preparePutWatch("_name").setSource(watchBuilder().trigger(schedule(interval("6h"))).input(httpInput(template)).addAction("_action1", loggingAction("anything"))).get().         assertThat(responseFuture.isCreated(), is(true)).         ActionFuture<ExecuteWatchResponse> executeWatchFuture = watcherClient().prepareExecuteWatch("_name").setRecordExecution(true).execute().         // without this sleep the delete operation might overtake the watch execution         sleep(1000).         DeleteWatchResponse deleteWatchResponse = watcherClient().prepareDeleteWatch("_name").get().         assertThat(deleteWatchResponse.isFound(), is(true)).         executeWatchFuture.get().         // the watch is gone, no leftovers         GetWatchResponse getWatchResponse = watcherClient().prepareGetWatch("_name").get().         assertThat(getWatchResponse.isFound(), is(false)).         // the watch history shows a successful execution, even though the watch was deleted         // during execution         refresh(HistoryStoreField.INDEX_PREFIX + "*").         SearchResponse searchResponse = client().prepareSearch(HistoryStoreField.INDEX_PREFIX + "*").setQuery(matchAllQuery()).get().         assertHitCount(searchResponse, 1).         Map<String, Object> source = searchResponse.getHits().getAt(0).getSourceAsMap().         // watch has been executed successfully         String state = ObjectPath.eval("state", source).         assertThat(state, is("executed")).         // no exception occurred         assertThat(source, not(hasKey("exception"))).     } }
