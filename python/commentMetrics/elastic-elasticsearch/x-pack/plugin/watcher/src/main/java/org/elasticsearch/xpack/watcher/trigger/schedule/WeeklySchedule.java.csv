commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;0;3;;public WeekTimes[] times() {     return times. }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (params.paramAsBoolean("normalize", false) && times.length == 1) {         return times[0].toXContent(builder, params).     }     builder.startArray().     for (WeekTimes weekTimes : times) {         weekTimes.toXContent(builder, params).     }     return builder.endArray(). }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;static;1;8;;static String[] crons(WeekTimes[] times) {     assert times.length > 0 : "at least one time must be defined".     List<String> crons = new ArrayList<>(times.length).     for (WeekTimes time : times) {         crons.addAll(time.crons()).     }     return crons.toArray(new String[crons.size()]). }
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;1;24;;@Override public WeeklySchedule parse(XContentParser parser) throws IOException {     if (parser.currentToken() == XContentParser.Token.START_OBJECT) {         try {             return new WeeklySchedule(WeekTimes.parse(parser, parser.currentToken())).         } catch (ElasticsearchParseException pe) {             throw new ElasticsearchParseException("could not parse [{}] schedule. invalid weekly times", pe, TYPE).         }     }     if (parser.currentToken() == XContentParser.Token.START_ARRAY) {         List<WeekTimes> times = new ArrayList<>().         XContentParser.Token token.         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {             try {                 times.add(WeekTimes.parse(parser, token)).             } catch (ElasticsearchParseException pe) {                 throw new ElasticsearchParseException("could not parse [{}] schedule. invalid weekly times", pe, TYPE).             }         }         return times.isEmpty() ? new WeeklySchedule() : new WeeklySchedule(times.toArray(new WeekTimes[times.size()])).     }     throw new ElasticsearchParseException("could not parse [{}] schedule. expected either an object or an array " + "of objects representing weekly times, but found [{}] instead", TYPE, parser.currentToken()). }
false;public;1;4;;public Builder time(WeekTimes time) {     times.add(time).     return this. }
false;public;1;3;;public Builder time(WeekTimes.Builder time) {     return time(time.build()). }
false;public;0;3;;public WeeklySchedule build() {     return times.isEmpty() ? new WeeklySchedule() : new WeeklySchedule(times.toArray(new WeekTimes[times.size()])). }
