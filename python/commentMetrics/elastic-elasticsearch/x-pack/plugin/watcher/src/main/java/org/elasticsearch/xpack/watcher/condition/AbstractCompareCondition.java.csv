commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;6;;@Override public final Result execute(WatchExecutionContext ctx) {     Map<String, Object> resolvedValues = new HashMap<>().     Map<String, Object> model = Variables.createCtxParamsMap(ctx, ctx.payload()).     return doExecute(model, resolvedValues). }
false;protected;3;21;;protected Object resolveConfiguredValue(Map<String, Object> resolvedValues, Map<String, Object> model, Object configuredValue) {     if (configuredValue instanceof String) {         // checking if the given value is a date math expression         Matcher matcher = DATE_MATH_PATTERN.matcher((String) configuredValue).         if (matcher.matches()) {             String dateMath = matcher.group(1).             configuredValue = WatcherDateTimeUtils.parseDateMath(dateMath, ZoneOffset.UTC, clock).             resolvedValues.put(dateMath, WatcherDateTimeUtils.formatDate((ZonedDateTime) configuredValue)).         } else {             // checking if the given value is a path expression             matcher = PATH_PATTERN.matcher((String) configuredValue).             if (matcher.matches()) {                 String configuredPath = matcher.group(1).                 configuredValue = ObjectPath.eval(configuredPath, model).                 resolvedValues.put(configuredPath, configuredValue).             }         }     }     return configuredValue. }
false;protected,abstract;2;1;;protected abstract Result doExecute(Map<String, Object> model, Map<String, Object> resolvedValues).
false;public;0;4;;@Override public String type() {     return type. }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.startObject().endObject(). }
