commented;modifiers;parameterAmount;loc;comment;code
true;public;2;13;/**  * Tries to put an watch execution class for a watch in the current executions  *  * @param id        The id of the watch  * @param execution The watch execution class  * @return          Returns true if watch with id already is in the current executions class, false otherwise  */ ;/**  * Tries to put an watch execution class for a watch in the current executions  *  * @param id        The id of the watch  * @param execution The watch execution class  * @return          Returns true if watch with id already is in the current executions class, false otherwise  */ public boolean put(String id, ExecutionService.WatchExecution execution) {     lock.lock().     try {         if (seal.get() != null) {             // We shouldn't get here, because, ExecutionService#started should have been set to false             throw illegalState("could not register execution [{}]. current executions are sealed and forbid registrations of " + "additional executions.", id).         }         return currentExecutions.putIfAbsent(id, execution) != null.     } finally {         lock.unlock().     } }
false;public;1;11;;public void remove(String id) {     lock.lock().     try {         currentExecutions.remove(id).         if (currentExecutions.isEmpty()) {             empty.signal().         }     } finally {         lock.unlock().     } }
true;;1;19;/**  * Calling this method makes the class stop accepting new executions and throws and exception instead.  * In addition it waits for a certain amount of time for current executions to finish before returning  *  * @param maxStopTimeout    The maximum wait time to wait to current executions to finish  */ ;/**  * Calling this method makes the class stop accepting new executions and throws and exception instead.  * In addition it waits for a certain amount of time for current executions to finish before returning  *  * @param maxStopTimeout    The maximum wait time to wait to current executions to finish  */ void sealAndAwaitEmpty(TimeValue maxStopTimeout) {     lock.lock().     // (we always first store the watch record and then remove the triggered watch)     try {         seal.set(true).         while (currentExecutions.size() > 0) {             empty.await(maxStopTimeout.millis(), TimeUnit.MILLISECONDS).         }     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } finally {         lock.unlock().     } }
false;public;0;4;;@Override public Iterator<ExecutionService.WatchExecution> iterator() {     return currentExecutions.values().iterator(). }
