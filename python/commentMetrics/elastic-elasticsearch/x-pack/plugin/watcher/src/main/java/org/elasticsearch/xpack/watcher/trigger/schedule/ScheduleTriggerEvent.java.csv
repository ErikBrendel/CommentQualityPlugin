commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return ScheduleTrigger.TYPE. }
false;public;0;3;;public ZonedDateTime scheduledTime() {     return scheduledTime. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     WatcherDateTimeUtils.writeDate(Field.TRIGGERED_TIME.getPreferredName(), builder, triggeredTime).     WatcherDateTimeUtils.writeDate(Field.SCHEDULED_TIME.getPreferredName(), builder, scheduledTime).     return builder.endObject(). }
false;public;2;6;;@Override public void recordDataXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(ScheduleTrigger.TYPE).     WatcherDateTimeUtils.writeDate(Field.SCHEDULED_TIME.getPreferredName(), builder, scheduledTime).     builder.endObject(). }
false;public,static;4;34;;public static ScheduleTriggerEvent parse(XContentParser parser, String watchId, String context, Clock clock) throws IOException {     ZonedDateTime triggeredTime = null.     ZonedDateTime scheduledTime = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.TRIGGERED_TIME.match(currentFieldName, parser.getDeprecationHandler())) {             try {                 triggeredTime = WatcherDateTimeUtils.parseDateMath(currentFieldName, parser, ZoneOffset.UTC, clock).             } catch (ElasticsearchParseException pe) {                 // Failed to parse as a date try datemath parsing                 throw new ElasticsearchParseException("could not parse [{}] trigger event for [{}] for watch [{}]. failed to parse " + "date field [{}]", pe, ScheduleTriggerEngine.TYPE, context, watchId, currentFieldName).             }         } else if (Field.SCHEDULED_TIME.match(currentFieldName, parser.getDeprecationHandler())) {             try {                 scheduledTime = WatcherDateTimeUtils.parseDateMath(currentFieldName, parser, ZoneOffset.UTC, clock).             } catch (ElasticsearchParseException pe) {                 throw new ElasticsearchParseException("could not parse [{}] trigger event for [{}] for watch [{}]. failed to parse " + "date field [{}]", pe, ScheduleTriggerEngine.TYPE, context, watchId, currentFieldName).             }         } else {             throw new ElasticsearchParseException("could not parse trigger event for [{}] for watch [{}]. unexpected token [{}]", context, watchId, token).         }     }     // should never be, it's fully controlled internally (not coming from the user)     assert triggeredTime != null && scheduledTime != null.     return new ScheduleTriggerEvent(triggeredTime, scheduledTime). }
