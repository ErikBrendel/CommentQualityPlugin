commented;modifiers;parameterAmount;loc;comment;code
false;protected,synchronized;1;7;;protected synchronized void clusterSettingsConsumer(Settings settings) {     // update cached cluster settings     this.cachedClusterSettings = settings.     // use these new dynamic cluster settings together with the previously cached     // secure settings     buildAccounts(). }
false;public,synchronized;1;13;;public synchronized void reload(Settings settings) {     // whenever dynamic cluster settings change and we have to rebuild the accounts     try {         this.cachedSecureSettings = extractSecureSettings(settings, pluginSecureSettings).     } catch (GeneralSecurityException e) {         logger.error("Keystore exception while reloading watcher notification service", e).         return.     }     // use these new secure settings together with the previously cached dynamic     // cluster settings     buildAccounts(). }
false;private;0;15;;private void buildAccounts() {     // build complete settings combining cluster and secure settings     final Settings.Builder completeSettingsBuilder = Settings.builder().put(bootSettings, false).     if (this.cachedClusterSettings != null) {         completeSettingsBuilder.put(this.cachedClusterSettings, false).     }     if (this.cachedSecureSettings != null) {         completeSettingsBuilder.setSecureSettings(this.cachedSecureSettings).     }     final Settings completeSettings = completeSettingsBuilder.build().     // obtain account names and create accounts     final Set<String> accountNames = getAccountNames(completeSettings).     this.accounts = createAccounts(completeSettings, accountNames, this::createAccount).     this.defaultAccount = findDefaultAccountOrNull(completeSettings, this.accounts). }
false;protected,abstract;2;1;;protected abstract Account createAccount(String name, Settings accountSettings).
false;public;1;19;;public Account getAccount(String name) {     // note this is not final since we mock it in tests and that causes     // trouble since final methods can't be mocked...     final Map<String, LazyInitializable<Account, SettingsException>> accounts.     final LazyInitializable<Account, SettingsException> defaultAccount.     synchronized (this) {         // must read under sync block otherwise it might be inconsistent         accounts = this.accounts.         defaultAccount = this.defaultAccount.     }     LazyInitializable<Account, SettingsException> theAccount = accounts.getOrDefault(name, defaultAccount).     if (theAccount == null && name == null) {         throw new IllegalArgumentException("no accounts of type [" + type + "] configured. " + "Please set up an account using the [xpack.notification." + type + "] settings").     }     if (theAccount == null) {         throw new IllegalArgumentException("no account found for name: [" + name + "]").     }     return theAccount.getOrCompute(). }
false;private;0;3;;private String getNotificationsAccountPrefix() {     return "xpack.notification." + type + ".account.". }
false;private;1;3;;private Set<String> getAccountNames(Settings settings) {     return settings.getByPrefix(getNotificationsAccountPrefix()).names(). }
false;private;1;3;;@Nullable private String getDefaultAccountName(Settings settings) {     return settings.get("xpack.notification." + type + ".default_account"). }
false;private;3;11;;private Map<String, LazyInitializable<Account, SettingsException>> createAccounts(Settings settings, Set<String> accountNames, BiFunction<String, Settings, Account> accountFactory) {     final Map<String, LazyInitializable<Account, SettingsException>> accounts = new HashMap<>().     for (final String accountName : accountNames) {         final Settings accountSettings = settings.getAsSettings(getNotificationsAccountPrefix() + accountName).         accounts.put(accountName, new LazyInitializable<>(() -> {             return accountFactory.apply(accountName, accountSettings).         })).     }     return Collections.unmodifiableMap(accounts). }
false;private;2;17;;@Nullable private LazyInitializable<Account, SettingsException> findDefaultAccountOrNull(Settings settings, Map<String, LazyInitializable<Account, SettingsException>> accounts) {     final String defaultAccountName = getDefaultAccountName(settings).     if (defaultAccountName == null) {         if (accounts.isEmpty()) {             return null.         } else {             return accounts.values().iterator().next().         }     } else {         final LazyInitializable<Account, SettingsException> account = accounts.get(defaultAccountName).         if (account == null) {             throw new SettingsException("could not find default account [" + defaultAccountName + "]").         }         return account.     } }
false;public;0;4;;@Override public boolean isLoaded() {     return true. }
false;public;1;4;;@Override public SecureString getString(String setting) throws GeneralSecurityException {     return cache.get(setting). }
false;public;0;4;;@Override public Set<String> getSettingNames() {     return cache.keySet(). }
false;public;1;4;;@Override public InputStream getFile(String setting) throws GeneralSecurityException {     throw new IllegalStateException("A NotificationService setting cannot be File."). }
false;public;0;3;;@Override public void close() throws IOException { }
true;private,static;2;42;/**  * Extracts the {@link SecureSettings}` out of the passed in {@link Settings} object. The {@code Setting} argument has to have the  * {@code SecureSettings} open/available. Normally {@code SecureSettings} are available only under specific callstacks (eg. during node  * initialization or during a `reload` call). The returned copy can be reused freely as it will never be closed (this is a bit of  * cheating, but it is necessary in this specific circumstance). Only works for secure settings of type string (not file).  *  * @param source  *            A {@code Settings} object with its {@code SecureSettings} open/available.  * @param securePluginSettings  *            The list of settings to copy.  * @return A copy of the {@code SecureSettings} of the passed in {@code Settings} argument.  */ ;/**  * Extracts the {@link SecureSettings}` out of the passed in {@link Settings} object. The {@code Setting} argument has to have the  * {@code SecureSettings} open/available. Normally {@code SecureSettings} are available only under specific callstacks (eg. during node  * initialization or during a `reload` call). The returned copy can be reused freely as it will never be closed (this is a bit of  * cheating, but it is necessary in this specific circumstance). Only works for secure settings of type string (not file).  *  * @param source  *            A {@code Settings} object with its {@code SecureSettings} open/available.  * @param securePluginSettings  *            The list of settings to copy.  * @return A copy of the {@code SecureSettings} of the passed in {@code Settings} argument.  */ private static SecureSettings extractSecureSettings(Settings source, List<Setting<?>> securePluginSettings) throws GeneralSecurityException {     // get the secure settings out     final SecureSettings sourceSecureSettings = Settings.builder().put(source, true).getSecureSettings().     // filter and cache them...     final Map<String, SecureString> cache = new HashMap<>().     if (sourceSecureSettings != null && securePluginSettings != null) {         for (final String settingKey : sourceSecureSettings.getSettingNames()) {             for (final Setting<?> secureSetting : securePluginSettings) {                 if (secureSetting.match(settingKey)) {                     cache.put(settingKey, sourceSecureSettings.getString(settingKey)).                 }             }         }     }     return new SecureSettings() {          @Override         public boolean isLoaded() {             return true.         }          @Override         public SecureString getString(String setting) throws GeneralSecurityException {             return cache.get(setting).         }          @Override         public Set<String> getSettingNames() {             return cache.keySet().         }          @Override         public InputStream getFile(String setting) throws GeneralSecurityException {             throw new IllegalStateException("A NotificationService setting cannot be File.").         }          @Override         public void close() throws IOException {         }     }. }
