commented;modifiers;parameterAmount;loc;comment;code
false;public;2;23;;@Override public SearchTransform.Result execute(WatchExecutionContext ctx, Payload payload) {     WatcherSearchTemplateRequest request = null.     try {         Script template = transform.getRequest().getOrCreateTemplate().         String renderedTemplate = searchTemplateService.renderTemplate(template, ctx, payload).         // We need to make a copy, so that we don't modify the original instance that we keep around in a watch:         request = new WatcherSearchTemplateRequest(transform.getRequest(), new BytesArray(renderedTemplate)).         SearchRequest searchRequest = searchTemplateService.toSearchRequest(request).         SearchResponse resp = ClientHelper.executeWithHeaders(ctx.watch().status().getHeaders(), ClientHelper.WATCHER_ORIGIN, client, () -> client.search(searchRequest).actionGet(timeout)).         final Params params.         if (request.isRestTotalHitsAsint()) {             params = new MapParams(Collections.singletonMap("rest_total_hits_as_int", "true")).         } else {             params = EMPTY_PARAMS.         }         return new SearchTransform.Result(request, new Payload.XContent(resp, params)).     } catch (Exception e) {         logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to execute [{}] transform for [{}]", TYPE, ctx.id()), e).         return new SearchTransform.Result(request, e).     } }
