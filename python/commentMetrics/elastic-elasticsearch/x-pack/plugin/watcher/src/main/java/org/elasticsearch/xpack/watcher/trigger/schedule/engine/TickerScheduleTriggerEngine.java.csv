commented;modifiers;parameterAmount;loc;comment;code
false;public,synchronized;1;21;;@Override public synchronized void start(Collection<Watch> jobs) {     long startTime = clock.millis().     Map<String, ActiveSchedule> startingSchedules = new HashMap<>(jobs.size()).     for (Watch job : jobs) {         if (job.trigger() instanceof ScheduleTrigger) {             ScheduleTrigger trigger = (ScheduleTrigger) job.trigger().             startingSchedules.put(job.id(), new ActiveSchedule(job.id(), trigger.getSchedule(), startTime)).         }     }     // why are we calling putAll() here instead of assigning a brand     // new concurrent hash map you may ask yourself over here     // This requires some explanation how TriggerEngine.start() is     // invoked, when a reload due to the cluster state listener is done     // If the watches index does not exist, and new document is stored,     // then the creation of that index will trigger a reload which calls     // this method. The index operation however will run at the same time     // as the reload, so if we clean out the old data structure here,     // that can lead to that one watch not being triggered     this.schedules.putAll(startingSchedules). }
false;public;0;5;;@Override public void stop() {     schedules.clear().     ticker.close(). }
false;public,synchronized;0;4;;@Override public synchronized void pauseExecution() {     schedules.clear(). }
false;public;1;13;;@Override public void add(Watch watch) {     assert watch.trigger() instanceof ScheduleTrigger.     ScheduleTrigger trigger = (ScheduleTrigger) watch.trigger().     ActiveSchedule currentSchedule = schedules.get(watch.id()).     // this also means that updating an existing watch would not retrigger the schedule time, if it remains the same schedule     if (currentSchedule == null || currentSchedule.schedule.equals(trigger.getSchedule()) == false) {         schedules.put(watch.id(), new ActiveSchedule(watch.id(), trigger.getSchedule(), clock.millis())).     } }
false;public;1;4;;@Override public boolean remove(String jobId) {     return schedules.remove(jobId) != null. }
false;;0;21;;void checkJobs() {     long triggeredTime = clock.millis().     List<TriggerEvent> events = new ArrayList<>().     for (ActiveSchedule schedule : schedules.values()) {         long scheduledTime = schedule.check(triggeredTime).         if (scheduledTime > 0) {             ZonedDateTime triggeredDateTime = utcDateTimeAtEpochMillis(triggeredTime).             ZonedDateTime scheduledDateTime = utcDateTimeAtEpochMillis(scheduledTime).             logger.debug("triggered job [{}] at [{}] (scheduled time was [{}])", schedule.name, triggeredDateTime, scheduledDateTime).             events.add(new ScheduleTriggerEvent(schedule.name, triggeredDateTime, scheduledDateTime)).             if (events.size() >= 1000) {                 notifyListeners(events).                 events.clear().             }         }     }     if (events.isEmpty() == false) {         notifyListeners(events).     } }
false;private;1;3;;private ZonedDateTime utcDateTimeAtEpochMillis(long triggeredTime) {     return Instant.ofEpochMilli(triggeredTime).atZone(ZoneOffset.UTC). }
true;;0;3;// visible for testing ;// visible for testing Map<String, ActiveSchedule> getSchedules() {     return Collections.unmodifiableMap(schedules). }
false;protected;1;3;;protected void notifyListeners(List<TriggerEvent> events) {     consumers.forEach(consumer -> consumer.accept(events)). }
true;public;1;8;/**  * Checks whether the given time is the same or after the scheduled time of this schedule. If so, the scheduled time is  * returned a new scheduled time is computed and set. Otherwise (the given time is before the scheduled time), {@code -1}  * is returned.  */ ;/**  * Checks whether the given time is the same or after the scheduled time of this schedule. If so, the scheduled time is  * returned a new scheduled time is computed and set. Otherwise (the given time is before the scheduled time), {@code -1}  * is returned.  */ public long check(long time) {     if (time < scheduledTime) {         return -1.     }     long prevScheduledTime = scheduledTime == 0 ? time : scheduledTime.     scheduledTime = schedule.nextScheduledTimeAfter(startTime, time).     return prevScheduledTime. }
false;public;0;13;;@Override public void run() {     while (active) {         logger.trace("checking jobs [{}]", clock.instant().atZone(ZoneOffset.UTC)).         checkJobs().         try {             sleep(tickInterval.millis()).         } catch (InterruptedException e) {             Thread.currentThread().interrupt().         }     }     closeLatch.countDown(). }
false;public;0;13;;public void close() {     if (isDataNode) {         logger.trace("stopping ticker thread").         active = false.         try {             closeLatch.await().         } catch (InterruptedException e) {             logger.warn("caught an interrupted exception when waiting while closing ticker thread", e).             Thread.currentThread().interrupt().         }         logger.trace("ticker thread stopped").     } }
