commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getArrayPath() {     return arrayPath. }
false;public;0;3;;public String getPath() {     return path. }
false;public;0;3;;public ArrayCompareCondition.Op getOp() {     return op. }
false;public;0;3;;public Object getValue() {     return value. }
false;public;0;3;;public ArrayCompareCondition.Quantifier getQuantifier() {     return quantifier. }
false;public,static;3;88;;public static ArrayCompareCondition parse(Clock clock, String watchId, XContentParser parser) throws IOException {     if (parser.currentToken() != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected an object but found [{}] " + "instead", TYPE, watchId, parser.currentToken()).     }     String arrayPath = null.     String path = null.     Op op = null.     Object value = null.     Quantifier quantifier = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             arrayPath = parser.currentName().         } else if (arrayPath == null) {             throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected a field indicating the " + "compared path, but found [{}] instead", TYPE, watchId, token).         } else if (token == XContentParser.Token.START_OBJECT) {             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     if (parser.currentName().equals("path")) {                         parser.nextToken().                         path = parser.text().                     } else {                         try {                             op = Op.resolve(parser.currentName()).                         } catch (IllegalArgumentException iae) {                             throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. unknown comparison " + "operator [{}]", TYPE, watchId, parser.currentName(), iae).                         }                         token = parser.nextToken().                         if (token == XContentParser.Token.START_OBJECT) {                             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                                 if (token == XContentParser.Token.FIELD_NAME) {                                     if (parser.currentName().equals("value")) {                                         token = parser.nextToken().                                         if (!op.supportsStructures() && !token.isValue() && token != XContentParser.Token.VALUE_NULL) {                                             throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. " + "compared value for [{}] with operation [{}] must either be a numeric, string, " + "boolean or null value, but found [{}] instead", TYPE, watchId, path, op.name().toLowerCase(Locale.ROOT), token).                                         }                                         value = XContentUtils.readValue(parser, token).                                     } else if (parser.currentName().equals("quantifier")) {                                         parser.nextToken().                                         try {                                             quantifier = Quantifier.resolve(parser.text()).                                         } catch (IllegalArgumentException iae) {                                             throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. " + "unknown comparison quantifier [{}]", TYPE, watchId, parser.text(), iae).                                         }                                     } else {                                         throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. " + "expected a field indicating the comparison value or comparison quantifier, but found" + " [{}] instead", TYPE, watchId, parser.currentName()).                                     }                                 } else {                                     throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected a " + "field indicating the comparison value or comparison quantifier, but found [{}] instead", TYPE, watchId, token).                                 }                             }                         } else {                             throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected an object " + "for field [{}] but found [{}] instead", TYPE, watchId, op.id(), token).                         }                     }                 } else {                     throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected a field indicating" + " the compared path or a comparison operator, but found [{}] instead", TYPE, watchId, token).                 }             }         } else {             throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected an object for field [{}] " + "but found [{}] instead", TYPE, watchId, path, token).         }     }     if (path == null) {         path = "".     }     if (quantifier == null) {         quantifier = Quantifier.SOME.     }     return new ArrayCompareCondition(arrayPath, path, op, value, quantifier, clock). }
false;public;2;20;;public Result doExecute(Map<String, Object> model, Map<String, Object> resolvedValues) {     Object configuredValue = resolveConfiguredValue(resolvedValues, model, value).     Object object = ObjectPath.eval(arrayPath, model).     if (object != null && !(object instanceof List)) {         throw new IllegalStateException("array path " + arrayPath + " did not evaluate to array, was " + object).     }     @SuppressWarnings("unchecked")     List<Object> resolvedArray = object != null ? (List<Object>) object : Collections.emptyList().     List<Object> resolvedValue = new ArrayList<>(resolvedArray.size()).     for (int i = 0. i < resolvedArray.size(). i++) {         resolvedValue.add(ObjectPath.eval(path, resolvedArray.get(i))).     }     resolvedValues.put(arrayPath, resolvedArray).     return new Result(resolvedValues, TYPE, quantifier.eval(resolvedValue, configuredValue, op)). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ArrayCompareCondition that = (ArrayCompareCondition) o.     return Objects.equals(getArrayPath(), that.getArrayPath()) && Objects.equals(getPath(), that.getPath()) && Objects.equals(getOp(), that.getOp()) && Objects.equals(getValue(), that.getValue()) && Objects.equals(getQuantifier(), that.getQuantifier()). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(arrayPath, path, op, value, quantifier). }
false;public;2;12;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.startObject().startObject(arrayPath).field("path", path).startObject(op.id()).field("value", value).field("quantifier", quantifier.id()).endObject().endObject().endObject(). }
false;public;1;4;;@Override public boolean comparison(int x) {     return x == 0. }
false;public;0;4;;@Override public boolean supportsStructures() {     return true. }
false;public;1;4;;@Override public boolean comparison(int x) {     return x != 0. }
false;public;0;4;;@Override public boolean supportsStructures() {     return true. }
false;public;1;4;;@Override public boolean comparison(int x) {     return x >= 0. }
false;public;1;4;;@Override public boolean comparison(int x) {     return x > 0. }
false;public;1;4;;@Override public boolean comparison(int x) {     return x <= 0. }
false;public;1;4;;@Override public boolean comparison(int x) {     return x < 0. }
false;public,abstract;1;1;;public abstract boolean comparison(int x).
false;public;0;3;;public boolean supportsStructures() {     return false. }
false;public;0;3;;public String id() {     return name().toLowerCase(Locale.ROOT). }
false;public,static;1;3;;public static Op resolve(String id) {     return Op.valueOf(id.toUpperCase(Locale.ROOT)). }
false;public;3;11;;@Override public boolean eval(List<Object> values, Object configuredValue, Op op) {     for (Object value : values) {         Integer compare = LenientCompare.compare(value, configuredValue).         boolean comparison = compare != null && op.comparison(compare).         if (!comparison) {             return false.         }     }     return true. }
false;public;3;11;;@Override public boolean eval(List<Object> values, Object configuredValue, Op op) {     for (Object value : values) {         Integer compare = LenientCompare.compare(value, configuredValue).         boolean comparison = compare != null && op.comparison(compare).         if (comparison) {             return true.         }     }     return false. }
false;public,abstract;3;1;;public abstract boolean eval(List<Object> values, Object configuredValue, Op op).
false;public,static;1;3;;public static Quantifier resolve(String id) {     return Quantifier.valueOf(id.toUpperCase(Locale.ROOT)). }
false;public;0;3;;public String id() {     return name().toLowerCase(Locale.ROOT). }
