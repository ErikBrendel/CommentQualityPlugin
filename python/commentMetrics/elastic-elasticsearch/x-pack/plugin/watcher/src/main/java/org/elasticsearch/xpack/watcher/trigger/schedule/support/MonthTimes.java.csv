commented;modifiers;parameterAmount;loc;comment;code
false;;0;10;;void validate() {     for (int day : days) {         if (day < 1 || day > 32) {             // 32 represents the last day of the month             throw illegalArgument("invalid month day [{}]", day).         }     }     for (DayTimes dayTimes : times) {         dayTimes.validate().     } }
false;public;0;3;;public int[] days() {     return days. }
false;public;0;3;;public DayTimes[] times() {     return times. }
false;public;0;11;;public Set<String> crons() {     Set<String> crons = new HashSet<>().     for (DayTimes times : this.times) {         String hrsStr = join(",", times.hour).         String minsStr = join(",", times.minute).         String daysStr = join(",", this.days).         daysStr = daysStr.replace("32", "L").         crons.add("0 " + minsStr + " " + hrsStr + " " + daysStr + " * ?").     }     return crons. }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     MonthTimes that = (MonthTimes) o.     if (!Arrays.equals(days, that.days))         return false.     // order doesn't matter     if (!newHashSet(times).equals(newHashSet(that.times)))         return false.     return true. }
false;public;0;6;;@Override public int hashCode() {     int result = Arrays.hashCode(days).     result = 31 * result + Arrays.hashCode(times).     return result. }
false;public;0;9;;@Override public String toString() {     return String.format(Locale.ROOT, "days [%s], times [%s]", join(",", days), Strings.arrayToCommaDelimitedString(times)). }
false;public;2;11;;public boolean contains(int day, DayTimes dayTimes) {     if (Arrays.binarySearch(days, day) == -1) {         // days are already sorted         return false.     }     for (DayTimes dayTimes1 : this.times()) {         if (dayTimes.equals(dayTimes1)) {             return true.         }     }     return false. }
false;public;1;10;;public boolean intersects(MonthTimes testTimes) {     for (int day : testTimes.days()) {         for (DayTimes dayTimes : testTimes.times()) {             if (contains(day, dayTimes)) {                 return true.             }         }     }     return false. }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.array(DAY_FIELD.getPreferredName(), days).     builder.startArray(TIME_FIELD.getPreferredName()).     for (DayTimes dayTimes : times) {         dayTimes.toXContent(builder, params).     }     builder.endArray().     return builder.endObject(). }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public,static;2;43;;public static MonthTimes parse(XContentParser parser, XContentParser.Token token) throws IOException, ElasticsearchParseException {     if (token != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("could not parse month times. expected an object, but found [{}]", token).     }     Set<Integer> daysSet = new HashSet<>().     Set<DayTimes> timesSet = new HashSet<>().     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (DAY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 daysSet.add(parseDayValue(parser, token)).             } else if (token == XContentParser.Token.START_ARRAY) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     daysSet.add(parseDayValue(parser, token)).                 }             } else {                 throw new ElasticsearchParseException("invalid month day value for [{}] field. expected string/number value or an " + "array of string/number values, but found [{}]", currentFieldName, token).             }         } else if (TIME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             if (token != XContentParser.Token.START_ARRAY) {                 try {                     timesSet.add(DayTimes.parse(parser, token)).                 } catch (ElasticsearchParseException pe) {                     throw new ElasticsearchParseException("invalid time value for field [{}] - [{}]", pe, currentFieldName, token).                 }             } else {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     try {                         timesSet.add(DayTimes.parse(parser, token)).                     } catch (ElasticsearchParseException pe) {                         throw new ElasticsearchParseException("invalid time value for field [{}] - [{}]", pe, currentFieldName, token).                     }                 }             }         }     }     int[] days = daysSet.isEmpty() ? DEFAULT_DAYS : CollectionUtils.toArray(daysSet).     DayTimes[] times = timesSet.isEmpty() ? new DayTimes[] { new DayTimes(0, 0) } : timesSet.toArray(new DayTimes[timesSet.size()]).     return new MonthTimes(days, times). }
false;static;2;20;;static int parseDayValue(XContentParser parser, XContentParser.Token token) throws IOException {     if (token == XContentParser.Token.VALUE_STRING) {         String value = parser.text().toLowerCase(Locale.ROOT).         if (LAST.equals(value)) {             return 32.         }         if (FIRST.equals(value)) {             return 1.         }         try {             return Integer.parseInt(value).         } catch (NumberFormatException nfe) {             throw new ElasticsearchParseException("invalid month day value. string value [{}] cannot be", value).         }     }     if (token == XContentParser.Token.VALUE_NUMBER) {         return parser.intValue().     }     throw new ElasticsearchParseException("invalid month day value. expected a string or a number value, but found [{}]", token). }
false;public;1;4;;public Builder on(int... days) {     Arrays.stream(days).forEach(this.days::add).     return this. }
false;public;2;4;;public Builder at(int hour, int minute) {     times.add(new DayTimes(hour, minute)).     return this. }
false;public;1;4;;public Builder atRoundHour(int... hours) {     times.add(new DayTimes(hours, new int[] { 0 })).     return this. }
false;public;0;4;;public Builder atNoon() {     times.add(DayTimes.NOON).     return this. }
false;public;0;4;;public Builder atMidnight() {     times.add(DayTimes.MIDNIGHT).     return this. }
false;public;0;3;;public MonthTimes build() {     return new MonthTimes(CollectionUtils.toArray(days), times.toArray(new DayTimes[times.size()])). }
