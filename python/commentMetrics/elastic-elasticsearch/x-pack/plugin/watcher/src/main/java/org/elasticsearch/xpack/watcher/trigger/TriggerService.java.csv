commented;modifiers;parameterAmount;loc;comment;code
false;public,synchronized;1;6;;public synchronized void start(Collection<Watch> watches) {     for (TriggerEngine engine : engines.values()) {         engine.start(watches).     }     watches.forEach(this::addToStats). }
false;public,synchronized;0;6;;public synchronized void stop() {     for (TriggerEngine engine : engines.values()) {         engine.stop().     }     perWatchStats.clear(). }
true;public,synchronized;0;4;/**  * Stop execution/triggering of watches on this node, do not try to reload anything, just sit still  */ ;/**  * Stop execution/triggering of watches on this node, do not try to reload anything, just sit still  */ public synchronized void pauseExecution() {     engines.values().forEach(TriggerEngine::pauseExecution).     perWatchStats.clear(). }
true;private;1;4;/**  * create statistics for a single watch, and store it in a local map  * allowing for easy deletion in case the watch gets removed from the trigger service  */ ;/**  * create statistics for a single watch, and store it in a local map  * allowing for easy deletion in case the watch gets removed from the trigger service  */ private void addToStats(Watch watch) {     TriggerWatchStats watchStats = TriggerWatchStats.create(watch).     perWatchStats.put(watch.id(), watchStats). }
true;public;0;60;/**  * Returns some statistics about the watches loaded in the trigger service  * @return a set of counters containing statistics  */ ;/**  * Returns some statistics about the watches loaded in the trigger service  * @return a set of counters containing statistics  */ public Counters stats() {     Counters counters = new Counters().     // for bwc reasons, active/total contain the same values     int watchCount = perWatchStats.size().     counters.inc("count.active", watchCount).     counters.inc("count.total", watchCount).     counters.inc("watch.trigger._all.active", watchCount).     counters.inc("watch.trigger._all.total", watchCount).     counters.inc("watch.input._all.total", watchCount).     counters.inc("watch.input._all.active", watchCount).     perWatchStats.values().forEach(stats -> {         if (stats.metadata) {             counters.inc("watch.metadata.active").             counters.inc("watch.metadata.total").         }         counters.inc("watch.trigger." + stats.triggerType + ".total").         counters.inc("watch.trigger." + stats.triggerType + ".active").         if (Strings.isNullOrEmpty(stats.scheduleType) == false) {             counters.inc("watch.trigger.schedule." + stats.scheduleType + ".total").             counters.inc("watch.trigger.schedule." + stats.scheduleType + ".active").             counters.inc("watch.trigger.schedule._all.total").             counters.inc("watch.trigger.schedule._all.active").         }         counters.inc("watch.input." + stats.inputType + ".active").         counters.inc("watch.input." + stats.inputType + ".total").         counters.inc("watch.condition." + stats.conditionType + ".active").         counters.inc("watch.condition." + stats.conditionType + ".total").         counters.inc("watch.condition._all.total").         counters.inc("watch.condition._all.active").         if (Strings.isNullOrEmpty(stats.transformType) == false) {             counters.inc("watch.transform." + stats.transformType + ".active").             counters.inc("watch.transform." + stats.transformType + ".total").             counters.inc("watch.transform._all.active").             counters.inc("watch.transform._all.total").         }         for (TriggerWatchStats.ActionStats action : stats.actions) {             counters.inc("watch.action." + action.actionType + ".active").             counters.inc("watch.action." + action.actionType + ".total").             counters.inc("watch.action._all.active").             counters.inc("watch.action._all.total").             if (Strings.isNullOrEmpty(action.conditionType) == false) {                 counters.inc("watch.action.condition." + action.conditionType + ".active").                 counters.inc("watch.action.condition." + action.conditionType + ".total").                 counters.inc("watch.action.condition._all.active").                 counters.inc("watch.action.condition._all.total").             }             if (Strings.isNullOrEmpty(action.transformType) == false) {                 counters.inc("watch.action.transform." + action.transformType + ".active").                 counters.inc("watch.action.transform." + action.transformType + ".total").                 counters.inc("watch.action.transform._all.active").                 counters.inc("watch.action.transform._all.total").             }         }     }).     return counters. }
true;public;1;4;/**  * Adds the given job to the trigger service. If there is already a registered job in this service with the  * same job ID, the newly added job will replace the old job (the old job will not be triggered anymore)  *  * @param watch   The new watch  */ ;/**  * Adds the given job to the trigger service. If there is already a registered job in this service with the  * same job ID, the newly added job will replace the old job (the old job will not be triggered anymore)  *  * @param watch   The new watch  */ public void add(Watch watch) {     engines.get(watch.trigger().type()).add(watch).     addToStats(watch). }
true;public;1;9;/**  * Removes the job associated with the given name from this trigger service.  *  * @param jobName   The name of the job to remove  * @return          {@code true} if the job existed and removed, {@code false} otherwise.  */ ;/**  * Removes the job associated with the given name from this trigger service.  *  * @param jobName   The name of the job to remove  * @return          {@code true} if the job existed and removed, {@code false} otherwise.  */ public boolean remove(String jobName) {     perWatchStats.remove(jobName).     for (TriggerEngine engine : engines.values()) {         if (engine.remove(jobName)) {             return true.         }     }     return false. }
false;public;1;3;;public void register(Consumer<Iterable<TriggerEvent>> consumer) {     this.consumer.add(consumer). }
false;public;3;7;;public TriggerEvent simulateEvent(String type, String jobId, Map<String, Object> data) {     TriggerEngine engine = engines.get(type).     if (engine == null) {         throw illegalArgument("could not simulate trigger event. unknown trigger type [{}]", type).     }     return engine.simulateEvent(jobId, data, this). }
false;public;2;22;;public Trigger parseTrigger(String jobName, XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     assert token == XContentParser.Token.START_OBJECT.     token = parser.nextToken().     if (token != XContentParser.Token.FIELD_NAME) {         throw new ElasticsearchParseException("could not parse trigger for [{}]. expected trigger type string field, but found [{}]", jobName, token).     }     String type = parser.currentName().     token = parser.nextToken().     if (token != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("could not parse trigger [{}] for [{}]. expected trigger an object as the trigger body," + " but found [{}]", type, jobName, token).     }     Trigger trigger = parseTrigger(jobName, type, parser).     token = parser.nextToken().     if (token != XContentParser.Token.END_OBJECT) {         throw new ElasticsearchParseException("could not parse trigger [{}] for [{}]. expected [END_OBJECT] token, but found [{}]", type, jobName, token).     }     return trigger. }
false;public;3;7;;public Trigger parseTrigger(String jobName, String type, XContentParser parser) throws IOException {     TriggerEngine engine = engines.get(type).     if (engine == null) {         throw new ElasticsearchParseException("could not parse trigger [{}] for [{}]. unknown trigger type [{}]", type, jobName, type).     }     return engine.parseTrigger(jobName, parser). }
false;public;3;22;;public TriggerEvent parseTriggerEvent(String watchId, String context, XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     assert token == XContentParser.Token.START_OBJECT.     token = parser.nextToken().     if (token != XContentParser.Token.FIELD_NAME) {         throw new ElasticsearchParseException("could not parse trigger event for [{}] for watch [{}]. expected trigger type string " + "field, but found [{}]", context, watchId, token).     }     String type = parser.currentName().     token = parser.nextToken().     if (token != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("could not parse trigger event for [{}] for watch [{}]. expected trigger an object as " + "the trigger body, but found [{}]", context, watchId, token).     }     TriggerEvent trigger = parseTriggerEvent(watchId, context, type, parser).     token = parser.nextToken().     if (token != XContentParser.Token.END_OBJECT) {         throw new ElasticsearchParseException("could not parse trigger [{}] for [{}]. expected [END_OBJECT] token, but found [{}]", type, context, token).     }     return trigger. }
false;public;4;7;;public TriggerEvent parseTriggerEvent(String watchId, String context, String type, XContentParser parser) throws IOException {     TriggerEngine engine = engines.get(type).     if (engine == null) {         throw new ElasticsearchParseException("Unknown trigger type [{}]", type).     }     return engine.parseTriggerEvent(this, watchId, context, parser). }
false;public;0;3;;public long count() {     return perWatchStats.size(). }
false;public;1;3;;public void add(Consumer<Iterable<TriggerEvent>> consumer) {     consumers.add(consumer). }
false;public;1;4;;@Override public void accept(Iterable<TriggerEvent> events) {     consumers.forEach(c -> c.accept(events)). }
