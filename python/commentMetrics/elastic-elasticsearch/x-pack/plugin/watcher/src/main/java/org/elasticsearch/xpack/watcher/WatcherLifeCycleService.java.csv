commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void beforeStop() {     shutDown(). }
false;synchronized;0;7;;synchronized void shutDown() {     this.state.set(WatcherState.STOPPING).     shutDown = true.     clearAllocationIds().     watcherService.shutDown().     this.state.set(WatcherState.STOPPED). }
true;public;1;84;/**  * @param event The event of containing the new cluster state  *  * stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting  * note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!  * this means, only certain components can be stopped  */ ;/**  * @param event The event of containing the new cluster state  *  * stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting  * note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!  * this means, only certain components can be stopped  */ @Override public void clusterChanged(ClusterChangedEvent event) {     if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || shutDown) {         clearAllocationIds().         // a .triggered_watches index, but they may not have been restored from the cluster state on disk         return.     }     if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId())) {         pauseExecution("no master node").         return.     }     if (event.state().getBlocks().hasGlobalBlockWithLevel(ClusterBlockLevel.WRITE)) {         pauseExecution("write level cluster block").         return.     }     boolean isWatcherStoppedManually = isWatcherStoppedManually(event.state()).     // if this is not a data node, we need to start it ourselves possibly     if (event.state().nodes().getLocalNode().isDataNode() == false && isWatcherStoppedManually == false && this.state.get() == WatcherState.STOPPED) {         this.state.set(WatcherState.STARTING).         watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED)).         return.     }     if (isWatcherStoppedManually) {         if (this.state.get() == WatcherState.STARTED) {             clearAllocationIds().             watcherService.stop("watcher manually marked to shutdown by cluster state update").             this.state.set(WatcherState.STOPPED).         }         return.     }     DiscoveryNode localNode = event.state().nodes().getLocalNode().     RoutingNode routingNode = event.state().getRoutingNodes().node(localNode.getId()).     if (routingNode == null) {         pauseExecution("routing node in cluster state undefined. network issue?").         return.     }     IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData()).     if (watcherIndexMetaData == null) {         pauseExecution("no watcher index found").         return.     }     String watchIndex = watcherIndexMetaData.getIndex().getName().     List<ShardRouting> localShards = routingNode.shardsWithState(watchIndex, RELOCATING, STARTED).     // no local shards, empty out watcher and dont waste resources!     if (localShards.isEmpty()) {         pauseExecution("no local watcher shards found").         return.     }     // also check if non local shards have changed, as loosing a shard on a     // remote node or adding a replica on a remote node needs to trigger a reload too     Set<ShardId> localShardIds = localShards.stream().map(ShardRouting::shardId).collect(Collectors.toSet()).     List<ShardRouting> allShards = event.state().routingTable().index(watchIndex).shardsWithState(STARTED).     allShards.addAll(event.state().routingTable().index(watchIndex).shardsWithState(RELOCATING)).     List<ShardRouting> localAffectedShardRoutings = allShards.stream().filter(shardRouting -> localShardIds.contains(shardRouting.shardId())).sorted(Comparator.comparing(ShardRouting::hashCode)).collect(Collectors.toList()).     if (previousShardRoutings.get().equals(localAffectedShardRoutings) == false) {         if (watcherService.validate(event.state())) {             previousShardRoutings.set(localAffectedShardRoutings).             if (state.get() == WatcherState.STARTED) {                 watcherService.reload(event.state(), "new local watcher shard allocation ids").             } else if (state.get() == WatcherState.STOPPED) {                 this.state.set(WatcherState.STARTING).                 watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED)).             }         } else {             clearAllocationIds().             this.state.set(WatcherState.STOPPED).         }     } }
false;private;1;6;;private void pauseExecution(String reason) {     if (clearAllocationIds()) {         watcherService.pauseExecution(reason).     }     this.state.set(WatcherState.STARTED). }
true;private;1;4;/**  * check if watcher has been stopped manually via the stop API  */ ;/**  * check if watcher has been stopped manually via the stop API  */ private boolean isWatcherStoppedManually(ClusterState state) {     WatcherMetaData watcherMetaData = state.getMetaData().custom(WatcherMetaData.TYPE).     return watcherMetaData != null && watcherMetaData.manuallyStopped(). }
true;private;0;4;/**  *    /**  * clear out current allocation ids if not already happened  * @return true, if existing allocation ids were cleaned out, false otherwise  */ ;/**  *    /**  * clear out current allocation ids if not already happened  * @return true, if existing allocation ids were cleaned out, false otherwise  */ private boolean clearAllocationIds() {     List<ShardRouting> previousIds = previousShardRoutings.getAndSet(Collections.emptyList()).     return previousIds.isEmpty() == false. }
true;;0;3;// for testing purposes only ;// for testing purposes only List<ShardRouting> shardRoutings() {     return previousShardRoutings.get(). }
false;public;0;3;;public WatcherState getState() {     return state.get(). }
