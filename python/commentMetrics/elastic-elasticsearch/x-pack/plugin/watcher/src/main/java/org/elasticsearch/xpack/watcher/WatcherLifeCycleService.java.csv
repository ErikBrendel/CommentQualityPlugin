# id;timestamp;commentText;codeText;commentWords;codeWords
WatcherLifeCycleService -> private boolean isWatcherStoppedManually(ClusterState state);1524684173;check if watcher has been stopped manually via the stop API;private boolean isWatcherStoppedManually(ClusterState state) {_        WatcherMetaData watcherMetaData = state.getMetaData().custom(WatcherMetaData.TYPE)__        return watcherMetaData != null && watcherMetaData.manuallyStopped()__    };check,if,watcher,has,been,stopped,manually,via,the,stop,api;private,boolean,is,watcher,stopped,manually,cluster,state,state,watcher,meta,data,watcher,meta,data,state,get,meta,data,custom,watcher,meta,data,type,return,watcher,meta,data,null,watcher,meta,data,manually,stopped
WatcherLifeCycleService -> private boolean isWatcherStoppedManually(ClusterState state);1525334055;check if watcher has been stopped manually via the stop API;private boolean isWatcherStoppedManually(ClusterState state) {_        WatcherMetaData watcherMetaData = state.getMetaData().custom(WatcherMetaData.TYPE)__        return watcherMetaData != null && watcherMetaData.manuallyStopped()__    };check,if,watcher,has,been,stopped,manually,via,the,stop,api;private,boolean,is,watcher,stopped,manually,cluster,state,state,watcher,meta,data,watcher,meta,data,state,get,meta,data,custom,watcher,meta,data,type,return,watcher,meta,data,null,watcher,meta,data,manually,stopped
WatcherLifeCycleService -> private boolean isWatcherStoppedManually(ClusterState state);1525798021;check if watcher has been stopped manually via the stop API;private boolean isWatcherStoppedManually(ClusterState state) {_        WatcherMetaData watcherMetaData = state.getMetaData().custom(WatcherMetaData.TYPE)__        return watcherMetaData != null && watcherMetaData.manuallyStopped()__    };check,if,watcher,has,been,stopped,manually,via,the,stop,api;private,boolean,is,watcher,stopped,manually,cluster,state,state,watcher,meta,data,watcher,meta,data,state,get,meta,data,custom,watcher,meta,data,type,return,watcher,meta,data,null,watcher,meta,data,manually,stopped
WatcherLifeCycleService -> private boolean isWatcherStoppedManually(ClusterState state);1535666657;check if watcher has been stopped manually via the stop API;private boolean isWatcherStoppedManually(ClusterState state) {_        WatcherMetaData watcherMetaData = state.getMetaData().custom(WatcherMetaData.TYPE)__        return watcherMetaData != null && watcherMetaData.manuallyStopped()__    };check,if,watcher,has,been,stopped,manually,via,the,stop,api;private,boolean,is,watcher,stopped,manually,cluster,state,state,watcher,meta,data,watcher,meta,data,state,get,meta,data,custom,watcher,meta,data,type,return,watcher,meta,data,null,watcher,meta,data,manually,stopped
WatcherLifeCycleService -> private boolean isWatcherStoppedManually(ClusterState state);1539723533;check if watcher has been stopped manually via the stop API;private boolean isWatcherStoppedManually(ClusterState state) {_        WatcherMetaData watcherMetaData = state.getMetaData().custom(WatcherMetaData.TYPE)__        return watcherMetaData != null && watcherMetaData.manuallyStopped()__    };check,if,watcher,has,been,stopped,manually,via,the,stop,api;private,boolean,is,watcher,stopped,manually,cluster,state,state,watcher,meta,data,watcher,meta,data,state,get,meta,data,custom,watcher,meta,data,type,return,watcher,meta,data,null,watcher,meta,data,manually,stopped
WatcherLifeCycleService -> private boolean isWatcherStoppedManually(ClusterState state);1541092382;check if watcher has been stopped manually via the stop API;private boolean isWatcherStoppedManually(ClusterState state) {_        WatcherMetaData watcherMetaData = state.getMetaData().custom(WatcherMetaData.TYPE)__        return watcherMetaData != null && watcherMetaData.manuallyStopped()__    };check,if,watcher,has,been,stopped,manually,via,the,stop,api;private,boolean,is,watcher,stopped,manually,cluster,state,state,watcher,meta,data,watcher,meta,data,state,get,meta,data,custom,watcher,meta,data,type,return,watcher,meta,data,null,watcher,meta,data,manually,stopped
WatcherLifeCycleService -> private boolean isWatcherStoppedManually(ClusterState state);1543343306;check if watcher has been stopped manually via the stop API;private boolean isWatcherStoppedManually(ClusterState state) {_        WatcherMetaData watcherMetaData = state.getMetaData().custom(WatcherMetaData.TYPE)__        return watcherMetaData != null && watcherMetaData.manuallyStopped()__    };check,if,watcher,has,been,stopped,manually,via,the,stop,api;private,boolean,is,watcher,stopped,manually,cluster,state,state,watcher,meta,data,watcher,meta,data,state,get,meta,data,custom,watcher,meta,data,type,return,watcher,meta,data,null,watcher,meta,data,manually,stopped
WatcherLifeCycleService -> private boolean isWatcherStoppedManually(ClusterState state);1546850547;check if watcher has been stopped manually via the stop API;private boolean isWatcherStoppedManually(ClusterState state) {_        WatcherMetaData watcherMetaData = state.getMetaData().custom(WatcherMetaData.TYPE)__        return watcherMetaData != null && watcherMetaData.manuallyStopped()__    };check,if,watcher,has,been,stopped,manually,via,the,stop,api;private,boolean,is,watcher,stopped,manually,cluster,state,state,watcher,meta,data,watcher,meta,data,state,get,meta,data,custom,watcher,meta,data,type,return,watcher,meta,data,null,watcher,meta,data,manually,stopped
WatcherLifeCycleService -> private boolean clearAllocationIds();1524684173;clear out current allocation ids if not already happened_@return true, if existing allocation ids were cleaned out, false otherwise;private boolean clearAllocationIds() {_        List<String> previousIds = previousAllocationIds.getAndSet(Collections.emptyList())__        return previousIds.equals(Collections.emptyList()) == false__    };clear,out,current,allocation,ids,if,not,already,happened,return,true,if,existing,allocation,ids,were,cleaned,out,false,otherwise;private,boolean,clear,allocation,ids,list,string,previous,ids,previous,allocation,ids,get,and,set,collections,empty,list,return,previous,ids,equals,collections,empty,list,false
WatcherLifeCycleService -> private boolean clearAllocationIds();1525334055;/**_clear out current allocation ids if not already happened_@return true, if existing allocation ids were cleaned out, false otherwise;private boolean clearAllocationIds() {_        List<String> previousIds = previousAllocationIds.getAndSet(Collections.emptyList())__        return previousIds.equals(Collections.emptyList()) == false__    };clear,out,current,allocation,ids,if,not,already,happened,return,true,if,existing,allocation,ids,were,cleaned,out,false,otherwise;private,boolean,clear,allocation,ids,list,string,previous,ids,previous,allocation,ids,get,and,set,collections,empty,list,return,previous,ids,equals,collections,empty,list,false
WatcherLifeCycleService -> private boolean clearAllocationIds();1525798021;/**_clear out current allocation ids if not already happened_@return true, if existing allocation ids were cleaned out, false otherwise;private boolean clearAllocationIds() {_        List<String> previousIds = previousAllocationIds.getAndSet(Collections.emptyList())__        return previousIds.equals(Collections.emptyList()) == false__    };clear,out,current,allocation,ids,if,not,already,happened,return,true,if,existing,allocation,ids,were,cleaned,out,false,otherwise;private,boolean,clear,allocation,ids,list,string,previous,ids,previous,allocation,ids,get,and,set,collections,empty,list,return,previous,ids,equals,collections,empty,list,false
WatcherLifeCycleService -> private boolean clearAllocationIds();1535666657;/**_clear out current allocation ids if not already happened_@return true, if existing allocation ids were cleaned out, false otherwise;private boolean clearAllocationIds() {_        List<ShardRouting> previousIds = previousShardRoutings.getAndSet(Collections.emptyList())__        return previousIds.isEmpty() == false__    };clear,out,current,allocation,ids,if,not,already,happened,return,true,if,existing,allocation,ids,were,cleaned,out,false,otherwise;private,boolean,clear,allocation,ids,list,shard,routing,previous,ids,previous,shard,routings,get,and,set,collections,empty,list,return,previous,ids,is,empty,false
WatcherLifeCycleService -> private boolean clearAllocationIds();1539723533;/**_clear out current allocation ids if not already happened_@return true, if existing allocation ids were cleaned out, false otherwise;private boolean clearAllocationIds() {_        List<ShardRouting> previousIds = previousShardRoutings.getAndSet(Collections.emptyList())__        return previousIds.isEmpty() == false__    };clear,out,current,allocation,ids,if,not,already,happened,return,true,if,existing,allocation,ids,were,cleaned,out,false,otherwise;private,boolean,clear,allocation,ids,list,shard,routing,previous,ids,previous,shard,routings,get,and,set,collections,empty,list,return,previous,ids,is,empty,false
WatcherLifeCycleService -> private boolean clearAllocationIds();1541092382;/**_clear out current allocation ids if not already happened_@return true, if existing allocation ids were cleaned out, false otherwise;private boolean clearAllocationIds() {_        List<ShardRouting> previousIds = previousShardRoutings.getAndSet(Collections.emptyList())__        return previousIds.isEmpty() == false__    };clear,out,current,allocation,ids,if,not,already,happened,return,true,if,existing,allocation,ids,were,cleaned,out,false,otherwise;private,boolean,clear,allocation,ids,list,shard,routing,previous,ids,previous,shard,routings,get,and,set,collections,empty,list,return,previous,ids,is,empty,false
WatcherLifeCycleService -> private boolean clearAllocationIds();1543343306;/**_clear out current allocation ids if not already happened_@return true, if existing allocation ids were cleaned out, false otherwise;private boolean clearAllocationIds() {_        List<ShardRouting> previousIds = previousShardRoutings.getAndSet(Collections.emptyList())__        return previousIds.isEmpty() == false__    };clear,out,current,allocation,ids,if,not,already,happened,return,true,if,existing,allocation,ids,were,cleaned,out,false,otherwise;private,boolean,clear,allocation,ids,list,shard,routing,previous,ids,previous,shard,routings,get,and,set,collections,empty,list,return,previous,ids,is,empty,false
WatcherLifeCycleService -> private boolean clearAllocationIds();1546850547;/**_clear out current allocation ids if not already happened_@return true, if existing allocation ids were cleaned out, false otherwise;private boolean clearAllocationIds() {_        List<ShardRouting> previousIds = previousShardRoutings.getAndSet(Collections.emptyList())__        return previousIds.isEmpty() == false__    };clear,out,current,allocation,ids,if,not,already,happened,return,true,if,existing,allocation,ids,were,cleaned,out,false,otherwise;private,boolean,clear,allocation,ids,list,shard,routing,previous,ids,previous,shard,routings,get,and,set,collections,empty,list,return,previous,ids,is,empty,false
WatcherLifeCycleService -> @Override     public void clusterChanged(ClusterChangedEvent event);1524684173;@param event The event of containing the new cluster state__stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting_note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!_this means, only certain components can be stopped;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || shutDown) {_            clearAllocationIds()__            _            _            return__        }__        _        WatcherMetaData watcherMetaData = event.state().getMetaData().custom(WatcherMetaData.TYPE)__        if (watcherMetaData == null && requireManualStart) {_            clearAllocationIds()__            return__        }__        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId())) {_            clearAllocationIds()__            executor.execute(() -> this.stop("no master node"))__            return__        }__        if (event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            clearAllocationIds()__            executor.execute(() -> this.stop("write level cluster block"))__            return__        }__        if (isWatcherStoppedManually(event.state())) {_            clearAllocationIds()__            executor.execute(() -> this.stop("watcher manually marked to shutdown by cluster state update"))__        } else {_            final WatcherState watcherState = watcherService.state()__            if (watcherState == WatcherState.STARTED && event.state().nodes().getLocalNode().isDataNode()) {_                checkAndSetAllocationIds(event.state(), true)__            } else if (watcherState != WatcherState.STARTED && watcherState != WatcherState.STARTING) {_                IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_                        event.state().metaData())__                boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_                        UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__                boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_                        UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__                if (isIndexInternalFormatTriggeredWatchIndex && isIndexInternalFormatWatchIndex) {_                    checkAndSetAllocationIds(event.state(), false)__                    executor.execute(() -> start(event.state()))__                } else {_                    logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                            isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__                }_            }_        }_    };param,event,the,event,of,containing,the,new,cluster,state,stop,certain,parts,of,watcher,when,there,are,no,watcher,indices,on,this,node,by,checking,the,shardrouting,note,that,this,is,not,easily,possible,because,of,the,execute,watch,api,that,needs,to,be,able,to,execute,anywhere,this,means,only,certain,components,can,be,stopped;override,public,void,cluster,changed,cluster,changed,event,event,if,event,state,blocks,has,global,block,gateway,service,shut,down,clear,allocation,ids,return,watcher,meta,data,watcher,meta,data,event,state,get,meta,data,custom,watcher,meta,data,type,if,watcher,meta,data,null,require,manual,start,clear,allocation,ids,return,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,clear,allocation,ids,executor,execute,this,stop,no,master,node,return,if,event,state,get,blocks,has,global,block,cluster,block,level,write,clear,allocation,ids,executor,execute,this,stop,write,level,cluster,block,return,if,is,watcher,stopped,manually,event,state,clear,allocation,ids,executor,execute,this,stop,watcher,manually,marked,to,shutdown,by,cluster,state,update,else,final,watcher,state,watcher,state,watcher,service,state,if,watcher,state,watcher,state,started,event,state,nodes,get,local,node,is,data,node,check,and,set,allocation,ids,event,state,true,else,if,watcher,state,watcher,state,started,watcher,state,watcher,state,starting,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,event,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,is,index,internal,format,watch,index,check,and,set,allocation,ids,event,state,false,executor,execute,start,event,state,else,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index
WatcherLifeCycleService -> @Override     public void clusterChanged(ClusterChangedEvent event);1525334055;@param event The event of containing the new cluster state__stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting_note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!_this means, only certain components can be stopped;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || shutDown) {_            clearAllocationIds()__            _            _            return__        }__        _        WatcherMetaData watcherMetaData = event.state().getMetaData().custom(WatcherMetaData.TYPE)__        if (watcherMetaData == null && requireManualStart) {_            clearAllocationIds()__            return__        }__        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId())) {_            pauseExecution("no master node")__            return__        }__        if (event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            pauseExecution("write level cluster block")__            return__        }__        boolean isWatcherStoppedManually = isWatcherStoppedManually(event.state())__        _        if (event.state().nodes().getLocalNode().isDataNode() == false &&_            isWatcherStoppedManually == false && this.state.get() == WatcherState.STOPPED) {_            watcherService.start(event.state())__            this.state.set(WatcherState.STARTED)__            return__        }__        if (isWatcherStoppedManually) {_            if (this.state.get() == WatcherState.STARTED) {_                clearAllocationIds()__                watcherService.stop("watcher manually marked to shutdown by cluster state update")__                this.state.set(WatcherState.STOPPED)__            }_            return__        }__        DiscoveryNode localNode = event.state().nodes().getLocalNode()__        RoutingNode routingNode = event.state().getRoutingNodes().node(localNode.getId())__        if (routingNode == null) {_            pauseExecution("routing node in cluster state undefined. network issue?")__            return__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__        if (watcherIndexMetaData == null) {_            pauseExecution("no watcher index found")__            return__        }__        String watchIndex = watcherIndexMetaData.getIndex().getName()__        List<ShardRouting> localShards = routingNode.shardsWithState(watchIndex, RELOCATING, STARTED)__        _        if (localShards.isEmpty()) {_            pauseExecution("no local watcher shards found")__            return__        }__        List<String> currentAllocationIds = localShards.stream()_            .map(ShardRouting::allocationId)_            .map(AllocationId::getId)_            .sorted()_            .collect(Collectors.toList())___        if (previousAllocationIds.get().equals(currentAllocationIds) == false) {_            if (watcherService.validate(event.state())) {_                previousAllocationIds.set(Collections.unmodifiableList(currentAllocationIds))__                if (state.get() == WatcherState.STARTED) {_                    watcherService.reload(event.state(), "new local watcher shard allocation ids")__                } else if (state.get() == WatcherState.STOPPED) {_                    watcherService.start(event.state())__                    this.state.set(WatcherState.STARTED)__                }_            } else {_                clearAllocationIds()__                this.state.set(WatcherState.STOPPED)__            }_        }_    };param,event,the,event,of,containing,the,new,cluster,state,stop,certain,parts,of,watcher,when,there,are,no,watcher,indices,on,this,node,by,checking,the,shardrouting,note,that,this,is,not,easily,possible,because,of,the,execute,watch,api,that,needs,to,be,able,to,execute,anywhere,this,means,only,certain,components,can,be,stopped;override,public,void,cluster,changed,cluster,changed,event,event,if,event,state,blocks,has,global,block,gateway,service,shut,down,clear,allocation,ids,return,watcher,meta,data,watcher,meta,data,event,state,get,meta,data,custom,watcher,meta,data,type,if,watcher,meta,data,null,require,manual,start,clear,allocation,ids,return,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,pause,execution,no,master,node,return,if,event,state,get,blocks,has,global,block,cluster,block,level,write,pause,execution,write,level,cluster,block,return,boolean,is,watcher,stopped,manually,is,watcher,stopped,manually,event,state,if,event,state,nodes,get,local,node,is,data,node,false,is,watcher,stopped,manually,false,this,state,get,watcher,state,stopped,watcher,service,start,event,state,this,state,set,watcher,state,started,return,if,is,watcher,stopped,manually,if,this,state,get,watcher,state,started,clear,allocation,ids,watcher,service,stop,watcher,manually,marked,to,shutdown,by,cluster,state,update,this,state,set,watcher,state,stopped,return,discovery,node,local,node,event,state,nodes,get,local,node,routing,node,routing,node,event,state,get,routing,nodes,node,local,node,get,id,if,routing,node,null,pause,execution,routing,node,in,cluster,state,undefined,network,issue,return,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,watcher,index,meta,data,null,pause,execution,no,watcher,index,found,return,string,watch,index,watcher,index,meta,data,get,index,get,name,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,relocating,started,if,local,shards,is,empty,pause,execution,no,local,watcher,shards,found,return,list,string,current,allocation,ids,local,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,sorted,collect,collectors,to,list,if,previous,allocation,ids,get,equals,current,allocation,ids,false,if,watcher,service,validate,event,state,previous,allocation,ids,set,collections,unmodifiable,list,current,allocation,ids,if,state,get,watcher,state,started,watcher,service,reload,event,state,new,local,watcher,shard,allocation,ids,else,if,state,get,watcher,state,stopped,watcher,service,start,event,state,this,state,set,watcher,state,started,else,clear,allocation,ids,this,state,set,watcher,state,stopped
WatcherLifeCycleService -> @Override     public void clusterChanged(ClusterChangedEvent event);1525798021;@param event The event of containing the new cluster state__stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting_note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!_this means, only certain components can be stopped;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || shutDown) {_            clearAllocationIds()__            _            _            return__        }__        _        WatcherMetaData watcherMetaData = event.state().getMetaData().custom(WatcherMetaData.TYPE)__        if (watcherMetaData == null && requireManualStart) {_            clearAllocationIds()__            return__        }__        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId())) {_            pauseExecution("no master node")__            return__        }__        if (event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            pauseExecution("write level cluster block")__            return__        }__        boolean isWatcherStoppedManually = isWatcherStoppedManually(event.state())__        _        if (event.state().nodes().getLocalNode().isDataNode() == false &&_            isWatcherStoppedManually == false && this.state.get() == WatcherState.STOPPED) {_            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__            return__        }__        if (isWatcherStoppedManually) {_            if (this.state.get() == WatcherState.STARTED) {_                clearAllocationIds()__                watcherService.stop("watcher manually marked to shutdown by cluster state update")__                this.state.set(WatcherState.STOPPED)__            }_            return__        }__        DiscoveryNode localNode = event.state().nodes().getLocalNode()__        RoutingNode routingNode = event.state().getRoutingNodes().node(localNode.getId())__        if (routingNode == null) {_            pauseExecution("routing node in cluster state undefined. network issue?")__            return__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__        if (watcherIndexMetaData == null) {_            pauseExecution("no watcher index found")__            return__        }__        String watchIndex = watcherIndexMetaData.getIndex().getName()__        List<ShardRouting> localShards = routingNode.shardsWithState(watchIndex, RELOCATING, STARTED)__        _        if (localShards.isEmpty()) {_            pauseExecution("no local watcher shards found")__            return__        }__        List<String> currentAllocationIds = localShards.stream()_            .map(ShardRouting::allocationId)_            .map(AllocationId::getId)_            .sorted()_            .collect(Collectors.toList())___        if (previousAllocationIds.get().equals(currentAllocationIds) == false) {_            if (watcherService.validate(event.state())) {_                previousAllocationIds.set(Collections.unmodifiableList(currentAllocationIds))__                if (state.get() == WatcherState.STARTED) {_                    watcherService.reload(event.state(), "new local watcher shard allocation ids")__                } else if (state.get() == WatcherState.STOPPED) {_                    this.state.set(WatcherState.STARTING)__                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__                }_            } else {_                clearAllocationIds()__                this.state.set(WatcherState.STOPPED)__            }_        }_    };param,event,the,event,of,containing,the,new,cluster,state,stop,certain,parts,of,watcher,when,there,are,no,watcher,indices,on,this,node,by,checking,the,shardrouting,note,that,this,is,not,easily,possible,because,of,the,execute,watch,api,that,needs,to,be,able,to,execute,anywhere,this,means,only,certain,components,can,be,stopped;override,public,void,cluster,changed,cluster,changed,event,event,if,event,state,blocks,has,global,block,gateway,service,shut,down,clear,allocation,ids,return,watcher,meta,data,watcher,meta,data,event,state,get,meta,data,custom,watcher,meta,data,type,if,watcher,meta,data,null,require,manual,start,clear,allocation,ids,return,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,pause,execution,no,master,node,return,if,event,state,get,blocks,has,global,block,cluster,block,level,write,pause,execution,write,level,cluster,block,return,boolean,is,watcher,stopped,manually,is,watcher,stopped,manually,event,state,if,event,state,nodes,get,local,node,is,data,node,false,is,watcher,stopped,manually,false,this,state,get,watcher,state,stopped,watcher,service,start,event,state,this,state,set,watcher,state,started,return,if,is,watcher,stopped,manually,if,this,state,get,watcher,state,started,clear,allocation,ids,watcher,service,stop,watcher,manually,marked,to,shutdown,by,cluster,state,update,this,state,set,watcher,state,stopped,return,discovery,node,local,node,event,state,nodes,get,local,node,routing,node,routing,node,event,state,get,routing,nodes,node,local,node,get,id,if,routing,node,null,pause,execution,routing,node,in,cluster,state,undefined,network,issue,return,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,watcher,index,meta,data,null,pause,execution,no,watcher,index,found,return,string,watch,index,watcher,index,meta,data,get,index,get,name,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,relocating,started,if,local,shards,is,empty,pause,execution,no,local,watcher,shards,found,return,list,string,current,allocation,ids,local,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,sorted,collect,collectors,to,list,if,previous,allocation,ids,get,equals,current,allocation,ids,false,if,watcher,service,validate,event,state,previous,allocation,ids,set,collections,unmodifiable,list,current,allocation,ids,if,state,get,watcher,state,started,watcher,service,reload,event,state,new,local,watcher,shard,allocation,ids,else,if,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,else,clear,allocation,ids,this,state,set,watcher,state,stopped
WatcherLifeCycleService -> @Override     public void clusterChanged(ClusterChangedEvent event);1535666657;@param event The event of containing the new cluster state__stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting_note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!_this means, only certain components can be stopped;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || shutDown) {_            clearAllocationIds()__            _            _            return__        }__        _        WatcherMetaData watcherMetaData = event.state().getMetaData().custom(WatcherMetaData.TYPE)__        if (watcherMetaData == null && requireManualStart) {_            clearAllocationIds()__            return__        }__        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId())) {_            pauseExecution("no master node")__            return__        }__        if (event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            pauseExecution("write level cluster block")__            return__        }__        boolean isWatcherStoppedManually = isWatcherStoppedManually(event.state())__        _        if (event.state().nodes().getLocalNode().isDataNode() == false &&_            isWatcherStoppedManually == false && this.state.get() == WatcherState.STOPPED) {_            this.state.set(WatcherState.STARTING)__            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__            return__        }__        if (isWatcherStoppedManually) {_            if (this.state.get() == WatcherState.STARTED) {_                clearAllocationIds()__                watcherService.stop("watcher manually marked to shutdown by cluster state update")__                this.state.set(WatcherState.STOPPED)__            }_            return__        }__        DiscoveryNode localNode = event.state().nodes().getLocalNode()__        RoutingNode routingNode = event.state().getRoutingNodes().node(localNode.getId())__        if (routingNode == null) {_            pauseExecution("routing node in cluster state undefined. network issue?")__            return__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__        if (watcherIndexMetaData == null) {_            pauseExecution("no watcher index found")__            return__        }__        String watchIndex = watcherIndexMetaData.getIndex().getName()__        List<ShardRouting> localShards = routingNode.shardsWithState(watchIndex, RELOCATING, STARTED)__        _        if (localShards.isEmpty()) {_            pauseExecution("no local watcher shards found")__            return__        }__        _        _        Set<ShardId> localShardIds = localShards.stream().map(ShardRouting::shardId).collect(Collectors.toSet())__        List<ShardRouting> allShards = event.state().routingTable().index(watchIndex).shardsWithState(STARTED)__        allShards.addAll(event.state().routingTable().index(watchIndex).shardsWithState(RELOCATING))__        List<ShardRouting> localAffectedShardRoutings = allShards.stream()_            .filter(shardRouting -> localShardIds.contains(shardRouting.shardId()))_            _            .sorted(Comparator.comparing(ShardRouting::hashCode))_            .collect(Collectors.toList())___        if (previousShardRoutings.get().equals(localAffectedShardRoutings) == false) {_            if (watcherService.validate(event.state())) {_                previousShardRoutings.set(localAffectedShardRoutings)__                if (state.get() == WatcherState.STARTED) {_                    watcherService.reload(event.state(), "new local watcher shard allocation ids")__                } else if (state.get() == WatcherState.STOPPED) {_                    this.state.set(WatcherState.STARTING)__                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__                }_            } else {_                clearAllocationIds()__                this.state.set(WatcherState.STOPPED)__            }_        }_    };param,event,the,event,of,containing,the,new,cluster,state,stop,certain,parts,of,watcher,when,there,are,no,watcher,indices,on,this,node,by,checking,the,shardrouting,note,that,this,is,not,easily,possible,because,of,the,execute,watch,api,that,needs,to,be,able,to,execute,anywhere,this,means,only,certain,components,can,be,stopped;override,public,void,cluster,changed,cluster,changed,event,event,if,event,state,blocks,has,global,block,gateway,service,shut,down,clear,allocation,ids,return,watcher,meta,data,watcher,meta,data,event,state,get,meta,data,custom,watcher,meta,data,type,if,watcher,meta,data,null,require,manual,start,clear,allocation,ids,return,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,pause,execution,no,master,node,return,if,event,state,get,blocks,has,global,block,cluster,block,level,write,pause,execution,write,level,cluster,block,return,boolean,is,watcher,stopped,manually,is,watcher,stopped,manually,event,state,if,event,state,nodes,get,local,node,is,data,node,false,is,watcher,stopped,manually,false,this,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,return,if,is,watcher,stopped,manually,if,this,state,get,watcher,state,started,clear,allocation,ids,watcher,service,stop,watcher,manually,marked,to,shutdown,by,cluster,state,update,this,state,set,watcher,state,stopped,return,discovery,node,local,node,event,state,nodes,get,local,node,routing,node,routing,node,event,state,get,routing,nodes,node,local,node,get,id,if,routing,node,null,pause,execution,routing,node,in,cluster,state,undefined,network,issue,return,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,watcher,index,meta,data,null,pause,execution,no,watcher,index,found,return,string,watch,index,watcher,index,meta,data,get,index,get,name,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,relocating,started,if,local,shards,is,empty,pause,execution,no,local,watcher,shards,found,return,set,shard,id,local,shard,ids,local,shards,stream,map,shard,routing,shard,id,collect,collectors,to,set,list,shard,routing,all,shards,event,state,routing,table,index,watch,index,shards,with,state,started,all,shards,add,all,event,state,routing,table,index,watch,index,shards,with,state,relocating,list,shard,routing,local,affected,shard,routings,all,shards,stream,filter,shard,routing,local,shard,ids,contains,shard,routing,shard,id,sorted,comparator,comparing,shard,routing,hash,code,collect,collectors,to,list,if,previous,shard,routings,get,equals,local,affected,shard,routings,false,if,watcher,service,validate,event,state,previous,shard,routings,set,local,affected,shard,routings,if,state,get,watcher,state,started,watcher,service,reload,event,state,new,local,watcher,shard,allocation,ids,else,if,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,else,clear,allocation,ids,this,state,set,watcher,state,stopped
WatcherLifeCycleService -> @Override     public void clusterChanged(ClusterChangedEvent event);1539723533;@param event The event of containing the new cluster state__stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting_note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!_this means, only certain components can be stopped;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || shutDown) {_            clearAllocationIds()__            _            _            return__        }__        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId())) {_            pauseExecution("no master node")__            return__        }__        if (event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            pauseExecution("write level cluster block")__            return__        }__        boolean isWatcherStoppedManually = isWatcherStoppedManually(event.state())__        _        if (event.state().nodes().getLocalNode().isDataNode() == false &&_            isWatcherStoppedManually == false && this.state.get() == WatcherState.STOPPED) {_            this.state.set(WatcherState.STARTING)__            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__            return__        }__        if (isWatcherStoppedManually) {_            if (this.state.get() == WatcherState.STARTED) {_                clearAllocationIds()__                watcherService.stop("watcher manually marked to shutdown by cluster state update")__                this.state.set(WatcherState.STOPPED)__            }_            return__        }__        DiscoveryNode localNode = event.state().nodes().getLocalNode()__        RoutingNode routingNode = event.state().getRoutingNodes().node(localNode.getId())__        if (routingNode == null) {_            pauseExecution("routing node in cluster state undefined. network issue?")__            return__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__        if (watcherIndexMetaData == null) {_            pauseExecution("no watcher index found")__            return__        }__        String watchIndex = watcherIndexMetaData.getIndex().getName()__        List<ShardRouting> localShards = routingNode.shardsWithState(watchIndex, RELOCATING, STARTED)__        _        if (localShards.isEmpty()) {_            pauseExecution("no local watcher shards found")__            return__        }__        _        _        Set<ShardId> localShardIds = localShards.stream().map(ShardRouting::shardId).collect(Collectors.toSet())__        List<ShardRouting> allShards = event.state().routingTable().index(watchIndex).shardsWithState(STARTED)__        allShards.addAll(event.state().routingTable().index(watchIndex).shardsWithState(RELOCATING))__        List<ShardRouting> localAffectedShardRoutings = allShards.stream()_            .filter(shardRouting -> localShardIds.contains(shardRouting.shardId()))_            _            .sorted(Comparator.comparing(ShardRouting::hashCode))_            .collect(Collectors.toList())___        if (previousShardRoutings.get().equals(localAffectedShardRoutings) == false) {_            if (watcherService.validate(event.state())) {_                previousShardRoutings.set(localAffectedShardRoutings)__                if (state.get() == WatcherState.STARTED) {_                    watcherService.reload(event.state(), "new local watcher shard allocation ids")__                } else if (state.get() == WatcherState.STOPPED) {_                    this.state.set(WatcherState.STARTING)__                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__                }_            } else {_                clearAllocationIds()__                this.state.set(WatcherState.STOPPED)__            }_        }_    };param,event,the,event,of,containing,the,new,cluster,state,stop,certain,parts,of,watcher,when,there,are,no,watcher,indices,on,this,node,by,checking,the,shardrouting,note,that,this,is,not,easily,possible,because,of,the,execute,watch,api,that,needs,to,be,able,to,execute,anywhere,this,means,only,certain,components,can,be,stopped;override,public,void,cluster,changed,cluster,changed,event,event,if,event,state,blocks,has,global,block,gateway,service,shut,down,clear,allocation,ids,return,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,pause,execution,no,master,node,return,if,event,state,get,blocks,has,global,block,cluster,block,level,write,pause,execution,write,level,cluster,block,return,boolean,is,watcher,stopped,manually,is,watcher,stopped,manually,event,state,if,event,state,nodes,get,local,node,is,data,node,false,is,watcher,stopped,manually,false,this,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,return,if,is,watcher,stopped,manually,if,this,state,get,watcher,state,started,clear,allocation,ids,watcher,service,stop,watcher,manually,marked,to,shutdown,by,cluster,state,update,this,state,set,watcher,state,stopped,return,discovery,node,local,node,event,state,nodes,get,local,node,routing,node,routing,node,event,state,get,routing,nodes,node,local,node,get,id,if,routing,node,null,pause,execution,routing,node,in,cluster,state,undefined,network,issue,return,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,watcher,index,meta,data,null,pause,execution,no,watcher,index,found,return,string,watch,index,watcher,index,meta,data,get,index,get,name,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,relocating,started,if,local,shards,is,empty,pause,execution,no,local,watcher,shards,found,return,set,shard,id,local,shard,ids,local,shards,stream,map,shard,routing,shard,id,collect,collectors,to,set,list,shard,routing,all,shards,event,state,routing,table,index,watch,index,shards,with,state,started,all,shards,add,all,event,state,routing,table,index,watch,index,shards,with,state,relocating,list,shard,routing,local,affected,shard,routings,all,shards,stream,filter,shard,routing,local,shard,ids,contains,shard,routing,shard,id,sorted,comparator,comparing,shard,routing,hash,code,collect,collectors,to,list,if,previous,shard,routings,get,equals,local,affected,shard,routings,false,if,watcher,service,validate,event,state,previous,shard,routings,set,local,affected,shard,routings,if,state,get,watcher,state,started,watcher,service,reload,event,state,new,local,watcher,shard,allocation,ids,else,if,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,else,clear,allocation,ids,this,state,set,watcher,state,stopped
WatcherLifeCycleService -> @Override     public void clusterChanged(ClusterChangedEvent event);1541092382;@param event The event of containing the new cluster state__stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting_note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!_this means, only certain components can be stopped;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || shutDown) {_            clearAllocationIds()__            _            _            return__        }__        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId())) {_            pauseExecution("no master node")__            return__        }__        if (event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            pauseExecution("write level cluster block")__            return__        }__        boolean isWatcherStoppedManually = isWatcherStoppedManually(event.state())__        _        if (event.state().nodes().getLocalNode().isDataNode() == false &&_            isWatcherStoppedManually == false && this.state.get() == WatcherState.STOPPED) {_            this.state.set(WatcherState.STARTING)__            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__            return__        }__        if (isWatcherStoppedManually) {_            if (this.state.get() == WatcherState.STARTED) {_                clearAllocationIds()__                watcherService.stop("watcher manually marked to shutdown by cluster state update")__                this.state.set(WatcherState.STOPPED)__            }_            return__        }__        DiscoveryNode localNode = event.state().nodes().getLocalNode()__        RoutingNode routingNode = event.state().getRoutingNodes().node(localNode.getId())__        if (routingNode == null) {_            pauseExecution("routing node in cluster state undefined. network issue?")__            return__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__        if (watcherIndexMetaData == null) {_            pauseExecution("no watcher index found")__            return__        }__        String watchIndex = watcherIndexMetaData.getIndex().getName()__        List<ShardRouting> localShards = routingNode.shardsWithState(watchIndex, RELOCATING, STARTED)__        _        if (localShards.isEmpty()) {_            pauseExecution("no local watcher shards found")__            return__        }__        _        _        Set<ShardId> localShardIds = localShards.stream().map(ShardRouting::shardId).collect(Collectors.toSet())__        List<ShardRouting> allShards = event.state().routingTable().index(watchIndex).shardsWithState(STARTED)__        allShards.addAll(event.state().routingTable().index(watchIndex).shardsWithState(RELOCATING))__        List<ShardRouting> localAffectedShardRoutings = allShards.stream()_            .filter(shardRouting -> localShardIds.contains(shardRouting.shardId()))_            _            .sorted(Comparator.comparing(ShardRouting::hashCode))_            .collect(Collectors.toList())___        if (previousShardRoutings.get().equals(localAffectedShardRoutings) == false) {_            if (watcherService.validate(event.state())) {_                previousShardRoutings.set(localAffectedShardRoutings)__                if (state.get() == WatcherState.STARTED) {_                    watcherService.reload(event.state(), "new local watcher shard allocation ids")__                } else if (state.get() == WatcherState.STOPPED) {_                    this.state.set(WatcherState.STARTING)__                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__                }_            } else {_                clearAllocationIds()__                this.state.set(WatcherState.STOPPED)__            }_        }_    };param,event,the,event,of,containing,the,new,cluster,state,stop,certain,parts,of,watcher,when,there,are,no,watcher,indices,on,this,node,by,checking,the,shardrouting,note,that,this,is,not,easily,possible,because,of,the,execute,watch,api,that,needs,to,be,able,to,execute,anywhere,this,means,only,certain,components,can,be,stopped;override,public,void,cluster,changed,cluster,changed,event,event,if,event,state,blocks,has,global,block,gateway,service,shut,down,clear,allocation,ids,return,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,pause,execution,no,master,node,return,if,event,state,get,blocks,has,global,block,cluster,block,level,write,pause,execution,write,level,cluster,block,return,boolean,is,watcher,stopped,manually,is,watcher,stopped,manually,event,state,if,event,state,nodes,get,local,node,is,data,node,false,is,watcher,stopped,manually,false,this,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,return,if,is,watcher,stopped,manually,if,this,state,get,watcher,state,started,clear,allocation,ids,watcher,service,stop,watcher,manually,marked,to,shutdown,by,cluster,state,update,this,state,set,watcher,state,stopped,return,discovery,node,local,node,event,state,nodes,get,local,node,routing,node,routing,node,event,state,get,routing,nodes,node,local,node,get,id,if,routing,node,null,pause,execution,routing,node,in,cluster,state,undefined,network,issue,return,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,watcher,index,meta,data,null,pause,execution,no,watcher,index,found,return,string,watch,index,watcher,index,meta,data,get,index,get,name,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,relocating,started,if,local,shards,is,empty,pause,execution,no,local,watcher,shards,found,return,set,shard,id,local,shard,ids,local,shards,stream,map,shard,routing,shard,id,collect,collectors,to,set,list,shard,routing,all,shards,event,state,routing,table,index,watch,index,shards,with,state,started,all,shards,add,all,event,state,routing,table,index,watch,index,shards,with,state,relocating,list,shard,routing,local,affected,shard,routings,all,shards,stream,filter,shard,routing,local,shard,ids,contains,shard,routing,shard,id,sorted,comparator,comparing,shard,routing,hash,code,collect,collectors,to,list,if,previous,shard,routings,get,equals,local,affected,shard,routings,false,if,watcher,service,validate,event,state,previous,shard,routings,set,local,affected,shard,routings,if,state,get,watcher,state,started,watcher,service,reload,event,state,new,local,watcher,shard,allocation,ids,else,if,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,else,clear,allocation,ids,this,state,set,watcher,state,stopped
WatcherLifeCycleService -> @Override     public void clusterChanged(ClusterChangedEvent event);1543343306;@param event The event of containing the new cluster state__stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting_note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!_this means, only certain components can be stopped;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || shutDown) {_            clearAllocationIds()__            _            _            return__        }__        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId())) {_            pauseExecution("no master node")__            return__        }__        if (event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            pauseExecution("write level cluster block")__            return__        }__        boolean isWatcherStoppedManually = isWatcherStoppedManually(event.state())__        _        if (event.state().nodes().getLocalNode().isDataNode() == false &&_            isWatcherStoppedManually == false && this.state.get() == WatcherState.STOPPED) {_            this.state.set(WatcherState.STARTING)__            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__            return__        }__        if (isWatcherStoppedManually) {_            if (this.state.get() == WatcherState.STARTED) {_                clearAllocationIds()__                watcherService.stop("watcher manually marked to shutdown by cluster state update")__                this.state.set(WatcherState.STOPPED)__            }_            return__        }__        DiscoveryNode localNode = event.state().nodes().getLocalNode()__        RoutingNode routingNode = event.state().getRoutingNodes().node(localNode.getId())__        if (routingNode == null) {_            pauseExecution("routing node in cluster state undefined. network issue?")__            return__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__        if (watcherIndexMetaData == null) {_            pauseExecution("no watcher index found")__            return__        }__        String watchIndex = watcherIndexMetaData.getIndex().getName()__        List<ShardRouting> localShards = routingNode.shardsWithState(watchIndex, RELOCATING, STARTED)__        _        if (localShards.isEmpty()) {_            pauseExecution("no local watcher shards found")__            return__        }__        _        _        Set<ShardId> localShardIds = localShards.stream().map(ShardRouting::shardId).collect(Collectors.toSet())__        List<ShardRouting> allShards = event.state().routingTable().index(watchIndex).shardsWithState(STARTED)__        allShards.addAll(event.state().routingTable().index(watchIndex).shardsWithState(RELOCATING))__        List<ShardRouting> localAffectedShardRoutings = allShards.stream()_            .filter(shardRouting -> localShardIds.contains(shardRouting.shardId()))_            _            .sorted(Comparator.comparing(ShardRouting::hashCode))_            .collect(Collectors.toList())___        if (previousShardRoutings.get().equals(localAffectedShardRoutings) == false) {_            if (watcherService.validate(event.state())) {_                previousShardRoutings.set(localAffectedShardRoutings)__                if (state.get() == WatcherState.STARTED) {_                    watcherService.reload(event.state(), "new local watcher shard allocation ids")__                } else if (state.get() == WatcherState.STOPPED) {_                    this.state.set(WatcherState.STARTING)__                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__                }_            } else {_                clearAllocationIds()__                this.state.set(WatcherState.STOPPED)__            }_        }_    };param,event,the,event,of,containing,the,new,cluster,state,stop,certain,parts,of,watcher,when,there,are,no,watcher,indices,on,this,node,by,checking,the,shardrouting,note,that,this,is,not,easily,possible,because,of,the,execute,watch,api,that,needs,to,be,able,to,execute,anywhere,this,means,only,certain,components,can,be,stopped;override,public,void,cluster,changed,cluster,changed,event,event,if,event,state,blocks,has,global,block,gateway,service,shut,down,clear,allocation,ids,return,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,pause,execution,no,master,node,return,if,event,state,get,blocks,has,global,block,cluster,block,level,write,pause,execution,write,level,cluster,block,return,boolean,is,watcher,stopped,manually,is,watcher,stopped,manually,event,state,if,event,state,nodes,get,local,node,is,data,node,false,is,watcher,stopped,manually,false,this,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,return,if,is,watcher,stopped,manually,if,this,state,get,watcher,state,started,clear,allocation,ids,watcher,service,stop,watcher,manually,marked,to,shutdown,by,cluster,state,update,this,state,set,watcher,state,stopped,return,discovery,node,local,node,event,state,nodes,get,local,node,routing,node,routing,node,event,state,get,routing,nodes,node,local,node,get,id,if,routing,node,null,pause,execution,routing,node,in,cluster,state,undefined,network,issue,return,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,watcher,index,meta,data,null,pause,execution,no,watcher,index,found,return,string,watch,index,watcher,index,meta,data,get,index,get,name,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,relocating,started,if,local,shards,is,empty,pause,execution,no,local,watcher,shards,found,return,set,shard,id,local,shard,ids,local,shards,stream,map,shard,routing,shard,id,collect,collectors,to,set,list,shard,routing,all,shards,event,state,routing,table,index,watch,index,shards,with,state,started,all,shards,add,all,event,state,routing,table,index,watch,index,shards,with,state,relocating,list,shard,routing,local,affected,shard,routings,all,shards,stream,filter,shard,routing,local,shard,ids,contains,shard,routing,shard,id,sorted,comparator,comparing,shard,routing,hash,code,collect,collectors,to,list,if,previous,shard,routings,get,equals,local,affected,shard,routings,false,if,watcher,service,validate,event,state,previous,shard,routings,set,local,affected,shard,routings,if,state,get,watcher,state,started,watcher,service,reload,event,state,new,local,watcher,shard,allocation,ids,else,if,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,else,clear,allocation,ids,this,state,set,watcher,state,stopped
WatcherLifeCycleService -> @Override     public void clusterChanged(ClusterChangedEvent event);1546850547;@param event The event of containing the new cluster state__stop certain parts of watcher, when there are no watcher indices on this node by checking the shardrouting_note that this is not easily possible, because of the execute watch api, that needs to be able to execute anywhere!_this means, only certain components can be stopped;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || shutDown) {_            clearAllocationIds()__            _            _            return__        }__        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId())) {_            pauseExecution("no master node")__            return__        }__        if (event.state().getBlocks().hasGlobalBlockWithLevel(ClusterBlockLevel.WRITE)) {_            pauseExecution("write level cluster block")__            return__        }__        boolean isWatcherStoppedManually = isWatcherStoppedManually(event.state())__        _        if (event.state().nodes().getLocalNode().isDataNode() == false &&_            isWatcherStoppedManually == false && this.state.get() == WatcherState.STOPPED) {_            this.state.set(WatcherState.STARTING)__            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__            return__        }__        if (isWatcherStoppedManually) {_            if (this.state.get() == WatcherState.STARTED) {_                clearAllocationIds()__                watcherService.stop("watcher manually marked to shutdown by cluster state update")__                this.state.set(WatcherState.STOPPED)__            }_            return__        }__        DiscoveryNode localNode = event.state().nodes().getLocalNode()__        RoutingNode routingNode = event.state().getRoutingNodes().node(localNode.getId())__        if (routingNode == null) {_            pauseExecution("routing node in cluster state undefined. network issue?")__            return__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__        if (watcherIndexMetaData == null) {_            pauseExecution("no watcher index found")__            return__        }__        String watchIndex = watcherIndexMetaData.getIndex().getName()__        List<ShardRouting> localShards = routingNode.shardsWithState(watchIndex, RELOCATING, STARTED)__        _        if (localShards.isEmpty()) {_            pauseExecution("no local watcher shards found")__            return__        }__        _        _        Set<ShardId> localShardIds = localShards.stream().map(ShardRouting::shardId).collect(Collectors.toSet())__        List<ShardRouting> allShards = event.state().routingTable().index(watchIndex).shardsWithState(STARTED)__        allShards.addAll(event.state().routingTable().index(watchIndex).shardsWithState(RELOCATING))__        List<ShardRouting> localAffectedShardRoutings = allShards.stream()_            .filter(shardRouting -> localShardIds.contains(shardRouting.shardId()))_            _            .sorted(Comparator.comparing(ShardRouting::hashCode))_            .collect(Collectors.toList())___        if (previousShardRoutings.get().equals(localAffectedShardRoutings) == false) {_            if (watcherService.validate(event.state())) {_                previousShardRoutings.set(localAffectedShardRoutings)__                if (state.get() == WatcherState.STARTED) {_                    watcherService.reload(event.state(), "new local watcher shard allocation ids")__                } else if (state.get() == WatcherState.STOPPED) {_                    this.state.set(WatcherState.STARTING)__                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED))__                }_            } else {_                clearAllocationIds()__                this.state.set(WatcherState.STOPPED)__            }_        }_    };param,event,the,event,of,containing,the,new,cluster,state,stop,certain,parts,of,watcher,when,there,are,no,watcher,indices,on,this,node,by,checking,the,shardrouting,note,that,this,is,not,easily,possible,because,of,the,execute,watch,api,that,needs,to,be,able,to,execute,anywhere,this,means,only,certain,components,can,be,stopped;override,public,void,cluster,changed,cluster,changed,event,event,if,event,state,blocks,has,global,block,gateway,service,shut,down,clear,allocation,ids,return,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,pause,execution,no,master,node,return,if,event,state,get,blocks,has,global,block,with,level,cluster,block,level,write,pause,execution,write,level,cluster,block,return,boolean,is,watcher,stopped,manually,is,watcher,stopped,manually,event,state,if,event,state,nodes,get,local,node,is,data,node,false,is,watcher,stopped,manually,false,this,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,return,if,is,watcher,stopped,manually,if,this,state,get,watcher,state,started,clear,allocation,ids,watcher,service,stop,watcher,manually,marked,to,shutdown,by,cluster,state,update,this,state,set,watcher,state,stopped,return,discovery,node,local,node,event,state,nodes,get,local,node,routing,node,routing,node,event,state,get,routing,nodes,node,local,node,get,id,if,routing,node,null,pause,execution,routing,node,in,cluster,state,undefined,network,issue,return,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,watcher,index,meta,data,null,pause,execution,no,watcher,index,found,return,string,watch,index,watcher,index,meta,data,get,index,get,name,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,relocating,started,if,local,shards,is,empty,pause,execution,no,local,watcher,shards,found,return,set,shard,id,local,shard,ids,local,shards,stream,map,shard,routing,shard,id,collect,collectors,to,set,list,shard,routing,all,shards,event,state,routing,table,index,watch,index,shards,with,state,started,all,shards,add,all,event,state,routing,table,index,watch,index,shards,with,state,relocating,list,shard,routing,local,affected,shard,routings,all,shards,stream,filter,shard,routing,local,shard,ids,contains,shard,routing,shard,id,sorted,comparator,comparing,shard,routing,hash,code,collect,collectors,to,list,if,previous,shard,routings,get,equals,local,affected,shard,routings,false,if,watcher,service,validate,event,state,previous,shard,routings,set,local,affected,shard,routings,if,state,get,watcher,state,started,watcher,service,reload,event,state,new,local,watcher,shard,allocation,ids,else,if,state,get,watcher,state,stopped,this,state,set,watcher,state,starting,watcher,service,start,event,state,this,state,set,watcher,state,started,else,clear,allocation,ids,this,state,set,watcher,state,stopped
