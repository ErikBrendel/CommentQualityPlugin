commented;modifiers;parameterAmount;loc;comment;code
false;public;1;25;;@Override public void clusterChanged(ClusterChangedEvent event) {     ClusterState state = event.state().     if (state.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {         // while they actually do exist         return.     }     // no master node, exit immediately     DiscoveryNode masterNode = event.state().getNodes().getMasterNode().     if (masterNode == null) {         return.     }     // if this node is newer than the master node, we probably need to add the history template, which might be newer than the     // history template the master node has, so we need potentially add new templates despite being not the master node     DiscoveryNode localNode = event.state().getNodes().getLocalNode().     boolean localNodeVersionAfterMaster = localNode.getVersion().after(masterNode.getVersion()).     if (event.localNodeMaster() || localNodeVersionAfterMaster) {         addTemplatesIfMissing(state).         addIndexLifecyclePolicyIfMissing(state).     } }
false;private;1;17;;private void addTemplatesIfMissing(ClusterState state) {     boolean ilmSupported = XPackSettings.INDEX_LIFECYCLE_ENABLED.get(state.metaData().settings()).     final TemplateConfig[] indexTemplates = ilmSupported ? TEMPLATE_CONFIGS : TEMPLATE_CONFIGS_NO_ILM.     for (TemplateConfig template : indexTemplates) {         final String templateName = template.getTemplateName().         final AtomicBoolean creationCheck = templateCreationsInProgress.computeIfAbsent(templateName, key -> new AtomicBoolean(false)).         if (creationCheck.compareAndSet(false, true)) {             if (!state.metaData().getTemplates().containsKey(templateName)) {                 logger.debug("adding index template [{}], because it doesn't exist", templateName).                 putTemplate(template, creationCheck).             } else {                 creationCheck.set(false).                 logger.trace("not adding index template [{}], because it already exists", templateName).             }         }     } }
false;public;1;7;;@Override public void onResponse(AcknowledgedResponse response) {     creationCheck.set(false).     if (response.isAcknowledged() == false) {         logger.error("Error adding watcher template [{}], request was not acknowledged", templateName).     } }
false;public;1;5;;@Override public void onFailure(Exception e) {     creationCheck.set(false).     logger.error(new ParameterizedMessage("Error adding watcher template [{}]", templateName), e). }
false;private;2;25;;private void putTemplate(final TemplateConfig config, final AtomicBoolean creationCheck) {     final Executor executor = threadPool.generic().     executor.execute(() -> {         final String templateName = config.getTemplateName().         PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName).source(config.load(), XContentType.JSON).         request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).         executeAsyncWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN, request, new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse response) {                 creationCheck.set(false).                 if (response.isAcknowledged() == false) {                     logger.error("Error adding watcher template [{}], request was not acknowledged", templateName).                 }             }              @Override             public void onFailure(Exception e) {                 creationCheck.set(false).                 logger.error(new ParameterizedMessage("Error adding watcher template [{}]", templateName), e).             }         }, client.admin().indices()::putTemplate).     }). }
true;;0;3;// Package visible for testing ;// Package visible for testing LifecyclePolicy loadWatcherHistoryPolicy() {     return LifecyclePolicyUtils.loadPolicy(POLICY_WATCH_HISTORY.policyName, POLICY_WATCH_HISTORY.fileName, xContentRegistry). }
false;private;1;17;;private void addIndexLifecyclePolicyIfMissing(ClusterState state) {     boolean ilmSupported = XPackSettings.INDEX_LIFECYCLE_ENABLED.get(state.metaData().settings()).     if (ilmSupported && historyPolicyCreationInProgress.compareAndSet(false, true)) {         final LifecyclePolicy policyOnDisk = loadWatcherHistoryPolicy().         Optional<IndexLifecycleMetadata> maybeMeta = Optional.ofNullable(state.metaData().custom(IndexLifecycleMetadata.TYPE)).         final boolean needsUpdating = maybeMeta.flatMap(ilmMeta -> Optional.ofNullable(ilmMeta.getPolicies().get(policyOnDisk.getName()))).isPresent() == // If there is no policy then one needs to be put.         false.         if (needsUpdating) {             putPolicy(policyOnDisk, historyPolicyCreationInProgress).         } else {             historyPolicyCreationInProgress.set(false).         }     } }
false;public;1;8;;@Override public void onResponse(PutLifecycleAction.Response response) {     creationCheck.set(false).     if (response.isAcknowledged() == false) {         logger.error("error adding watcher index lifecycle policy [{}], request was not acknowledged", policy.getName()).     } }
false;public;1;6;;@Override public void onFailure(Exception e) {     creationCheck.set(false).     logger.error(new ParameterizedMessage("error adding watcher index lifecycle policy [{}]", policy.getName()), e). }
false;private;2;25;;private void putPolicy(final LifecyclePolicy policy, final AtomicBoolean creationCheck) {     final Executor executor = threadPool.generic().     executor.execute(() -> {         PutLifecycleAction.Request request = new PutLifecycleAction.Request(policy).         request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).         executeAsyncWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN, request, new ActionListener<PutLifecycleAction.Response>() {              @Override             public void onResponse(PutLifecycleAction.Response response) {                 creationCheck.set(false).                 if (response.isAcknowledged() == false) {                     logger.error("error adding watcher index lifecycle policy [{}], request was not acknowledged", policy.getName()).                 }             }              @Override             public void onFailure(Exception e) {                 creationCheck.set(false).                 logger.error(new ParameterizedMessage("error adding watcher index lifecycle policy [{}]", policy.getName()), e).             }         }, (req, listener) -> new XPackClient(client).ilmClient().putLifecyclePolicy(req, listener)).     }). }
false;public,static;1;5;;public static boolean validate(ClusterState state) {     return state.getMetaData().getTemplates().containsKey(WatcherIndexTemplateRegistryField.HISTORY_TEMPLATE_NAME) && state.getMetaData().getTemplates().containsKey(WatcherIndexTemplateRegistryField.TRIGGERED_TEMPLATE_NAME) && state.getMetaData().getTemplates().containsKey(WatcherIndexTemplateRegistryField.WATCHES_TEMPLATE_NAME). }
false;public;0;3;;public String getFileName() {     return fileName. }
false;public;0;3;;public String getTemplateName() {     return templateName. }
false;public;0;6;;public byte[] load() {     String template = TemplateUtils.loadTemplate("/" + fileName + ".json", WatcherIndexTemplateRegistryField.INDEX_TEMPLATE_VERSION, Pattern.quote("${xpack.watcher.template.version}")).     assert template != null && template.length() > 0.     return template.getBytes(StandardCharsets.UTF_8). }
