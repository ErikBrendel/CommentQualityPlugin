commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     SearchInput that = (SearchInput) o.     if (request != null ? !request.equals(that.request) : that.request != null)         return false.     if (extractKeys != null ? !extractKeys.equals(that.extractKeys) : that.extractKeys != null)         return false.     if (timeout != null ? !timeout.equals(that.timeout) : that.timeout != null)         return false.     return !(dynamicNameTimeZone != null ? !dynamicNameTimeZone.equals(that.dynamicNameTimeZone) : that.dynamicNameTimeZone != null). }
false;public;0;8;;@Override public int hashCode() {     int result = request != null ? request.hashCode() : 0.     result = 31 * result + (extractKeys != null ? extractKeys.hashCode() : 0).     result = 31 * result + (timeout != null ? timeout.hashCode() : 0).     result = 31 * result + (dynamicNameTimeZone != null ? dynamicNameTimeZone.hashCode() : 0).     return result. }
false;public;0;3;;public WatcherSearchTemplateRequest getRequest() {     return request. }
false;public;0;3;;public Set<String> getExtractKeys() {     return extractKeys. }
false;public;0;3;;public TimeValue getTimeout() {     return timeout. }
false;public;0;3;;public ZoneId getDynamicNameTimeZone() {     return dynamicNameTimeZone. }
false;public;2;18;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (request != null) {         builder.field(Field.REQUEST.getPreferredName(), request).     }     if (extractKeys != null) {         builder.field(Field.EXTRACT.getPreferredName(), extractKeys).     }     if (timeout != null) {         builder.humanReadableField(Field.TIMEOUT.getPreferredName(), Field.TIMEOUT_HUMAN.getPreferredName(), timeout).     }     if (dynamicNameTimeZone != null) {         builder.field(Field.DYNAMIC_NAME_TIMEZONE.getPreferredName(), dynamicNameTimeZone).     }     builder.endObject().     return builder. }
false;public,static;2;57;;public static SearchInput parse(String watchId, XContentParser parser) throws IOException {     WatcherSearchTemplateRequest request = null.     Set<String> extract = null.     TimeValue timeout = null.     ZoneId dynamicNameTimeZone = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.REQUEST.match(currentFieldName, parser.getDeprecationHandler())) {             try {                 request = WatcherSearchTemplateRequest.fromXContent(parser, ExecutableSearchInput.DEFAULT_SEARCH_TYPE).             } catch (ElasticsearchParseException srpe) {                 throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. failed to parse [{}]", srpe, TYPE, watchId, currentFieldName).             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (Field.EXTRACT.match(currentFieldName, parser.getDeprecationHandler())) {                 extract = new HashSet<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token == XContentParser.Token.VALUE_STRING) {                         extract.add(parser.text()).                     } else {                         throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. expected a string value in " + "[{}] array, but found [{}] instead", TYPE, watchId, currentFieldName, token).                     }                 }             } else {                 throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. unexpected array field [{}]", TYPE, watchId, currentFieldName).             }         } else if (Field.TIMEOUT.match(currentFieldName, parser.getDeprecationHandler())) {             timeout = timeValueMillis(parser.longValue()).         } else if (Field.TIMEOUT_HUMAN.match(currentFieldName, parser.getDeprecationHandler())) {             // Parser for human specified timeouts and 2.x compatibility             timeout = WatcherDateTimeUtils.parseTimeValue(parser, Field.TIMEOUT_HUMAN.toString()).         } else if (Field.DYNAMIC_NAME_TIMEZONE.match(currentFieldName, parser.getDeprecationHandler())) {             if (token == XContentParser.Token.VALUE_STRING) {                 dynamicNameTimeZone = DateUtils.of(parser.text()).             } else {                 throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. failed to parse [{}]. must be a " + "string value (e.g. 'UTC' or '+01:00').", TYPE, watchId, currentFieldName).             }         } else {             throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. unexpected token [{}]", TYPE, watchId, token).         }     }     if (request == null) {         throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. missing required [{}] field", TYPE, watchId, Field.REQUEST.getPreferredName()).     }     return new SearchInput(request, extract, timeout, dynamicNameTimeZone). }
false;public,static;1;3;;public static Builder builder(WatcherSearchTemplateRequest request) {     return new Builder(request). }
false;public;0;3;;public WatcherSearchTemplateRequest executedRequest() {     return request. }
false;protected;2;9;;@Override protected XContentBuilder typeXContent(XContentBuilder builder, Params params) throws IOException {     if (request == null) {         return builder.     }     builder.startObject(type).     builder.field(Field.REQUEST.getPreferredName(), request).     return builder.endObject(). }
false;public;1;4;;public Builder extractKeys(Collection<String> keys) {     extractKeys.addAll(keys).     return this. }
false;public;1;4;;public Builder extractKeys(String... keys) {     Collections.addAll(extractKeys, keys).     return this. }
false;public;1;4;;public Builder timeout(TimeValue readTimeout) {     this.timeout = readTimeout.     return this. }
false;public;1;4;;public Builder dynamicNameTimeZone(ZoneId dynamicNameTimeZone) {     this.dynamicNameTimeZone = dynamicNameTimeZone.     return this. }
false;public;0;4;;@Override public SearchInput build() {     return new SearchInput(request, extractKeys.isEmpty() ? null : unmodifiableSet(extractKeys), timeout, dynamicNameTimeZone). }
