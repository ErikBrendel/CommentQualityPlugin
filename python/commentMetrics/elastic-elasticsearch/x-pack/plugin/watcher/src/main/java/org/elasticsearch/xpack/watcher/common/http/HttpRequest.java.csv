commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Scheme scheme() {     return scheme. }
false;public;0;3;;public String host() {     return host. }
false;public;0;3;;public int port() {     return port. }
false;public;0;3;;public HttpMethod method() {     return method. }
false;public;0;3;;public String path() {     return path. }
false;public;0;3;;public Map<String, String> params() {     return params. }
false;public;0;3;;public Map<String, String> headers() {     return headers. }
false;public;0;3;;public BasicAuth auth() {     return auth. }
false;public;0;3;;public boolean hasBody() {     return body != null. }
false;public;0;3;;public String body() {     return body. }
false;public;0;3;;public TimeValue connectionTimeout() {     return connectionTimeout. }
false;public;0;3;;public TimeValue readTimeout() {     return readTimeout. }
false;public;0;3;;public HttpProxy proxy() {     return proxy. }
false;public,static;1;7;;public static String encodeUrl(String text) {     try {         return URLEncoder.encode(text, "UTF-8").     } catch (UnsupportedEncodingException e) {         throw new IllegalArgumentException("failed to URL encode text [" + text + "]", e).     } }
false;public,static;1;7;;public static String decodeUrl(String text) {     try {         return URLDecoder.decode(text, "UTF-8").     } catch (UnsupportedEncodingException e) {         throw new IllegalArgumentException("failed to URL decode text [" + text + "]", e).     } }
false;public;2;41;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params toXContentParams) throws IOException {     builder.startObject().     builder.field(Field.HOST.getPreferredName(), host).     builder.field(Field.PORT.getPreferredName(), port).     builder.field(Field.SCHEME.getPreferredName(), scheme.value()).     builder.field(Field.METHOD.getPreferredName(), method.value()).     if (path != null) {         builder.field(Field.PATH.getPreferredName(), path).     }     if (this.params.isEmpty() == false) {         builder.field(Field.PARAMS.getPreferredName(), this.params).     }     if (headers.isEmpty() == false) {         if (WatcherParams.hideSecrets(toXContentParams)) {             builder.field(Field.HEADERS.getPreferredName(), sanitizeHeaders(headers)).         } else {             builder.field(Field.HEADERS.getPreferredName(), headers).         }     }     if (auth != null) {         builder.startObject(Field.AUTH.getPreferredName()).field(BasicAuth.TYPE, auth, toXContentParams).endObject().     }     if (body != null) {         builder.field(Field.BODY.getPreferredName(), body).     }     if (connectionTimeout != null) {         builder.humanReadableField(HttpRequest.Field.CONNECTION_TIMEOUT.getPreferredName(), HttpRequest.Field.CONNECTION_TIMEOUT_HUMAN.getPreferredName(), connectionTimeout).     }     if (readTimeout != null) {         builder.humanReadableField(HttpRequest.Field.READ_TIMEOUT.getPreferredName(), HttpRequest.Field.READ_TIMEOUT_HUMAN.getPreferredName(), readTimeout).     }     if (proxy != null) {         proxy.toXContent(builder, toXContentParams).     }     return builder.endObject(). }
false;private;1;8;;private Map<String, String> sanitizeHeaders(Map<String, String> headers) {     if (headers.containsKey("Authorization") == false) {         return headers.     }     Map<String, String> sanitizedHeaders = new HashMap<>(headers).     sanitizedHeaders.put("Authorization", WatcherXContentParser.REDACTED_PASSWORD).     return sanitizedHeaders. }
false;public;1;21;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     HttpRequest that = (HttpRequest) o.     if (port != that.port)         return false.     if (!host.equals(that.host))         return false.     if (scheme != that.scheme)         return false.     if (method != that.method)         return false.     if (path != null ? !path.equals(that.path) : that.path != null)         return false.     if (!params.equals(that.params))         return false.     if (!headers.equals(that.headers))         return false.     if (auth != null ? !auth.equals(that.auth) : that.auth != null)         return false.     if (connectionTimeout != null ? !connectionTimeout.equals(that.connectionTimeout) : that.connectionTimeout != null)         return false.     if (readTimeout != null ? !readTimeout.equals(that.readTimeout) : that.readTimeout != null)         return false.     if (proxy != null ? !proxy.equals(that.proxy) : that.proxy != null)         return false.     return !(body != null ? !body.equals(that.body) : that.body != null). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(host, port, scheme, method, path, params, headers, auth, connectionTimeout, readTimeout, body, proxy). }
false;public;0;24;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     sb.append("method=[").append(method).append("], ").     sb.append("scheme=[").append(scheme).append("], ").     sb.append("host=[").append(host).append("], ").     sb.append("port=[").append(port).append("], ").     sb.append("path=[").append(path).append("], ").     if (!headers.isEmpty()) {         sb.append(sanitizeHeaders(headers).entrySet().stream().map(header -> header.getKey() + ": " + header.getValue()).collect(Collectors.joining(", ", "headers=[", "], "))).     }     if (auth != null) {         sb.append("auth=[").append(BasicAuth.TYPE).append("], ").     }     sb.append("connection_timeout=[").append(connectionTimeout).append("], ").     sb.append("read_timeout=[").append(readTimeout).append("], ").     if (proxy != null) {         sb.append("proxy=[").append(proxy).append("], ").     }     sb.append("body=[").append(body).append("], ").     return sb.toString(). }
false;public,static;2;3;;public static Builder builder(String host, int port) {     return new Builder(host, port). }
false;static;0;3;;static Builder builder() {     return new Builder(). }
false;public,static;1;88;;public static HttpRequest parse(XContentParser parser) throws IOException {     Builder builder = new Builder().     XContentParser.Token token.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.PROXY.match(currentFieldName, parser.getDeprecationHandler())) {             try {                 builder.proxy(HttpProxy.parse(parser)).             } catch (Exception e) {                 throw new ElasticsearchParseException("could not parse http request. could not parse [{}] field", currentFieldName).             }         } else if (Field.AUTH.match(currentFieldName, parser.getDeprecationHandler())) {             builder.auth(BasicAuth.parse(parser)).         } else if (HttpRequest.Field.CONNECTION_TIMEOUT.match(currentFieldName, parser.getDeprecationHandler())) {             builder.connectionTimeout(TimeValue.timeValueMillis(parser.longValue())).         } else if (HttpRequest.Field.CONNECTION_TIMEOUT_HUMAN.match(currentFieldName, parser.getDeprecationHandler())) {             // Users and 2.x specify the timeout this way             try {                 builder.connectionTimeout(WatcherDateTimeUtils.parseTimeValue(parser, HttpRequest.Field.CONNECTION_TIMEOUT.toString())).             } catch (ElasticsearchParseException pe) {                 throw new ElasticsearchParseException("could not parse http request template. invalid time value for [{}] field", pe, currentFieldName).             }         } else if (HttpRequest.Field.READ_TIMEOUT.match(currentFieldName, parser.getDeprecationHandler())) {             builder.readTimeout(TimeValue.timeValueMillis(parser.longValue())).         } else if (HttpRequest.Field.READ_TIMEOUT_HUMAN.match(currentFieldName, parser.getDeprecationHandler())) {             // Users and 2.x specify the timeout this way             try {                 builder.readTimeout(WatcherDateTimeUtils.parseTimeValue(parser, HttpRequest.Field.READ_TIMEOUT.toString())).             } catch (ElasticsearchParseException pe) {                 throw new ElasticsearchParseException("could not parse http request template. invalid time value for [{}] field", pe, currentFieldName).             }         } else if (token == XContentParser.Token.START_OBJECT) {             if (Field.HEADERS.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.setHeaders((Map) WatcherUtils.flattenModel(parser.map())).             } else if (Field.PARAMS.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.setParams((Map) WatcherUtils.flattenModel(parser.map())).             } else if (Field.BODY.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.body(parser.text()).             } else {                 throw new ElasticsearchParseException("could not parse http request. unexpected object field [{}]", currentFieldName).             }         } else if (token == XContentParser.Token.VALUE_STRING) {             if (Field.SCHEME.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.scheme(Scheme.parse(parser.text())).             } else if (Field.METHOD.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.method(HttpMethod.parse(parser.text())).             } else if (Field.HOST.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.host = parser.text().             } else if (Field.PATH.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.path(parser.text()).             } else if (Field.BODY.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.body(parser.text()).             } else if (Field.URL.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.fromUrl(parser.text()).             } else {                 throw new ElasticsearchParseException("could not parse http request. unexpected string field [{}]", currentFieldName).             }         } else if (token == XContentParser.Token.VALUE_NUMBER) {             if (Field.PORT.match(currentFieldName, parser.getDeprecationHandler())) {                 builder.port = parser.intValue().             } else {                 throw new ElasticsearchParseException("could not parse http request. unexpected numeric field [{}]", currentFieldName).             }         } else {             throw new ElasticsearchParseException("could not parse http request. unexpected token [{}]", token).         }     }     if (builder.host == null) {         throw new ElasticsearchParseException("could not parse http request. missing required [{}] field", Field.HOST.getPreferredName()).     }     if (builder.port < 0) {         throw new ElasticsearchParseException("could not parse http request. missing required [{}] field", Field.PORT.getPreferredName()).     }     return builder.build(). }
false;public;1;4;;public Builder scheme(Scheme scheme) {     this.scheme = scheme.     return this. }
false;public;1;4;;public Builder method(HttpMethod method) {     this.method = method.     return this. }
false;public;1;4;;public Builder path(String path) {     this.path = path.     return this. }
false;public;1;7;;public Builder setParams(Map<String, String> params) {     if (this.params == null) {         throw new IllegalStateException("Request has already been built!").     }     this.params.putAll(params).     return this. }
false;public;2;7;;public Builder setParam(String key, String value) {     if (params == null) {         throw new IllegalStateException("Request has already been built!").     }     this.params.put(key, value).     return this. }
false;public;1;7;;public Builder setHeaders(Map<String, String> headers) {     if (this.headers == null) {         throw new IllegalStateException("Request has already been built!").     }     this.headers.putAll(headers).     return this. }
false;public;2;7;;public Builder setHeader(String key, String value) {     if (headers == null) {         throw new IllegalStateException("Request has already been built!").     }     this.headers.put(key, value).     return this. }
false;public;1;4;;public Builder auth(BasicAuth auth) {     this.auth = auth.     return this. }
false;public;1;4;;public Builder body(String body) {     this.body = body.     return this. }
false;public;1;3;;public Builder jsonBody(ToXContent xContent) {     return body(Strings.toString(xContent)).setHeader("Content-Type", XContentType.JSON.mediaType()). }
false;public;1;4;;public Builder connectionTimeout(TimeValue timeout) {     this.connectionTimeout = timeout.     return this. }
false;public;1;4;;public Builder readTimeout(TimeValue timeout) {     this.readTimeout = timeout.     return this. }
false;public;1;4;;public Builder proxy(HttpProxy proxy) {     this.proxy = proxy.     return this. }
false;public;0;7;;public HttpRequest build() {     HttpRequest request = new HttpRequest(host, port, scheme, method, path, unmodifiableMap(params), unmodifiableMap(headers), auth, body, connectionTimeout, readTimeout, proxy).     params = null.     headers = null.     return request. }
false;public;1;25;;public Builder fromUrl(String supposedUrl) {     if (Strings.hasLength(supposedUrl) == false) {         throw new ElasticsearchParseException("Configured URL is empty, please configure a valid URL").     }     try {         URI uri = new URI(supposedUrl).         if (Strings.hasLength(uri.getScheme()) == false) {             throw new ElasticsearchParseException("URL [{}] does not contain a scheme", uri).         }         scheme = Scheme.parse(uri.getScheme()).         port = uri.getPort() > 0 ? uri.getPort() : scheme.defaultPort().         host = uri.getHost().         if (Strings.hasLength(uri.getRawPath())) {             path = uri.getRawPath().         }         String rawQuery = uri.getRawQuery().         if (Strings.hasLength(rawQuery)) {             RestUtils.decodeQueryString(rawQuery, 0, params).         }     } catch (URISyntaxException e) {         throw new ElasticsearchParseException("Malformed URL [{}]", supposedUrl).     }     return this. }
true;public,static;4;10;/**  * Write a request via toXContent, but filter certain parts of it - this is needed to not expose secrets  *  * @param request        The HttpRequest object to serialize  * @param xContent       The xContent from the parent outputstream builder  * @param params         The ToXContentParams from the parent write  * @param excludeField   The field to exclude  * @return               A bytearrayinputstream that contains the serialized request  * @throws IOException   if an IOException is triggered in the underlying toXContent method  */ ;/**  * Write a request via toXContent, but filter certain parts of it - this is needed to not expose secrets  *  * @param request        The HttpRequest object to serialize  * @param xContent       The xContent from the parent outputstream builder  * @param params         The ToXContentParams from the parent write  * @param excludeField   The field to exclude  * @return               A bytearrayinputstream that contains the serialized request  * @throws IOException   if an IOException is triggered in the underlying toXContent method  */ public static InputStream filterToXContent(HttpRequest request, XContent xContent, ToXContent.Params params, String excludeField) throws IOException {     try (ByteArrayOutputStream bos = new ByteArrayOutputStream().         XContentBuilder filteredBuilder = new XContentBuilder(xContent, bos, Collections.emptySet(), Collections.singleton(excludeField))) {         request.toXContent(filteredBuilder, params).         filteredBuilder.flush().         return new ByteArrayInputStream(bos.toByteArray()).     } }
