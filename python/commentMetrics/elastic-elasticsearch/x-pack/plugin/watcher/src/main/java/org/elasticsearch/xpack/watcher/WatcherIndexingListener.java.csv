# id;timestamp;commentText;codeText;commentWords;codeWords
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1524684173;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1525334055;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1531179852;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1539615817;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1541092382;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1543343306;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1546850547;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1548897299;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1549289311;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1549608646;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state);1549960939;Check if the routing table has changed and local shards are affected__@param watchIndex Name of the concrete watches index pointing_@param state      The new cluster state_@return           true if the routing tables has changed and local shards are affected;private boolean hasShardAllocationIdChanged(String watchIndex, ClusterState state) {_        List<ShardRouting> allStartedRelocatedShards = state.getRoutingTable().index(watchIndex).shardsWithState(STARTED)__        allStartedRelocatedShards.addAll(state.getRoutingTable().index(watchIndex).shardsWithState(RELOCATING))___        _        if (allStartedRelocatedShards.isEmpty() == false && configuration == INACTIVE) {_            return true__        }__        _        String localNodeId = state.nodes().getLocalNodeId()__        Set<ShardId> clusterStateLocalShardIds = state.getRoutingNodes().node(localNodeId)_                .shardsWithState(watchIndex, STARTED, RELOCATING).stream()_                .map(ShardRouting::shardId)_                .collect(Collectors.toSet())__        Set<ShardId> configuredLocalShardIds = new HashSet<>(configuration.localShards.keySet())__        Set<ShardId> differenceSet = Sets.difference(clusterStateLocalShardIds, configuredLocalShardIds)__        if (differenceSet.isEmpty() == false) {_            return true__        }__        Map<ShardId, List<String>> shards = allStartedRelocatedShards.stream()_                .collect(Collectors.groupingBy(ShardRouting::shardId,_                        Collectors.mapping(sr -> sr.allocationId().getId(),_                        Collectors.toCollection(ArrayList::new))))___        _        shards.values().forEach(Collections::sort)___        _        for (Map.Entry<ShardId, ShardAllocationConfiguration> entry : configuration.localShards.entrySet()) {_            if (shards.containsKey(entry.getKey()) == false) {_                return true__            }__            Collection<String> allocationIds = shards.get(entry.getKey())__            if (allocationIds.equals(entry.getValue().allocationIds) == false) {_                return true__            }_        }__        return false__    };check,if,the,routing,table,has,changed,and,local,shards,are,affected,param,watch,index,name,of,the,concrete,watches,index,pointing,param,state,the,new,cluster,state,return,true,if,the,routing,tables,has,changed,and,local,shards,are,affected;private,boolean,has,shard,allocation,id,changed,string,watch,index,cluster,state,state,list,shard,routing,all,started,relocated,shards,state,get,routing,table,index,watch,index,shards,with,state,started,all,started,relocated,shards,add,all,state,get,routing,table,index,watch,index,shards,with,state,relocating,if,all,started,relocated,shards,is,empty,false,configuration,inactive,return,true,string,local,node,id,state,nodes,get,local,node,id,set,shard,id,cluster,state,local,shard,ids,state,get,routing,nodes,node,local,node,id,shards,with,state,watch,index,started,relocating,stream,map,shard,routing,shard,id,collect,collectors,to,set,set,shard,id,configured,local,shard,ids,new,hash,set,configuration,local,shards,key,set,set,shard,id,difference,set,sets,difference,cluster,state,local,shard,ids,configured,local,shard,ids,if,difference,set,is,empty,false,return,true,map,shard,id,list,string,shards,all,started,relocated,shards,stream,collect,collectors,grouping,by,shard,routing,shard,id,collectors,mapping,sr,sr,allocation,id,get,id,collectors,to,collection,array,list,new,shards,values,for,each,collections,sort,for,map,entry,shard,id,shard,allocation,configuration,entry,configuration,local,shards,entry,set,if,shards,contains,key,entry,get,key,false,return,true,collection,string,allocation,ids,shards,get,entry,get,key,if,allocation,ids,equals,entry,get,value,allocation,ids,false,return,true,return,false
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1524684173;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1525334055;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1531179852;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1539615817;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1541092382;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1543343306;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1546850547;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1548897299;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1549289311;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1549608646;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,                                      ClusterChangedEvent event);1549960939;Reload the configuration if the alias pointing to the watch index was changed or_the index routing table for an index was changed__@param watchIndex        Name of the concrete watches index pointing_@param localShardRouting List of local shards of that index_@param event             The cluster changed event containing the new cluster state;private void reloadConfiguration(String watchIndex, List<ShardRouting> localShardRouting,_                                     ClusterChangedEvent event) {_        _        boolean isAliasChanged = watchIndex.equals(configuration.index) == false__        if (isAliasChanged || hasShardAllocationIdChanged(watchIndex, event.state())) {_            IndexRoutingTable watchIndexRoutingTable = event.state().routingTable().index(watchIndex)__            Map<ShardId, ShardAllocationConfiguration> ids = getLocalShardAllocationIds(localShardRouting, watchIndexRoutingTable)__            configuration = new Configuration(watchIndex, ids)__        }_    };reload,the,configuration,if,the,alias,pointing,to,the,watch,index,was,changed,or,the,index,routing,table,for,an,index,was,changed,param,watch,index,name,of,the,concrete,watches,index,pointing,param,local,shard,routing,list,of,local,shards,of,that,index,param,event,the,cluster,changed,event,containing,the,new,cluster,state;private,void,reload,configuration,string,watch,index,list,shard,routing,local,shard,routing,cluster,changed,event,event,boolean,is,alias,changed,watch,index,equals,configuration,index,false,if,is,alias,changed,has,shard,allocation,id,changed,watch,index,event,state,index,routing,table,watch,index,routing,table,event,state,routing,table,index,watch,index,map,shard,id,shard,allocation,configuration,ids,get,local,shard,allocation,ids,local,shard,routing,watch,index,routing,table,configuration,new,configuration,watch,index,ids
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1524684173;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            DateTime now = new DateTime(clock.millis(), UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON)__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                _                _                _                _                boolean isWatchExecutionOperation = watch.status().version() != -1__                if (isWatchExecutionOperation) {_                    logger.debug("not updating trigger for watch [{}], watch has been updated as part of an execution", watch.id())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,date,time,now,new,date,time,clock,millis,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,is,watch,execution,operation,watch,status,version,1,if,is,watch,execution,operation,logger,debug,not,updating,trigger,for,watch,watch,has,been,updated,as,part,of,an,execution,watch,id,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1525334055;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            DateTime now = new DateTime(clock.millis(), UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON)__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                _                _                _                _                boolean isWatchExecutionOperation = watch.status().version() != -1__                if (isWatchExecutionOperation) {_                    logger.debug("not updating trigger for watch [{}], watch has been updated as part of an execution", watch.id())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,date,time,now,new,date,time,clock,millis,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,is,watch,execution,operation,watch,status,version,1,if,is,watch,execution,operation,logger,debug,not,updating,trigger,for,watch,watch,has,been,updated,as,part,of,an,execution,watch,id,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1531179852;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            DateTime now = new DateTime(clock.millis(), UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON)__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,date,time,now,new,date,time,clock,millis,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1539615817;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            DateTime now = new DateTime(clock.millis(), UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON)__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,date,time,now,new,date,time,clock,millis,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1541092382;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            DateTime now = new DateTime(clock.millis(), UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON)__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,date,time,now,new,date,time,clock,millis,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1543343306;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            DateTime now = new DateTime(clock.millis(), UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON)__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,date,time,now,new,date,time,clock,millis,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1546850547;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            DateTime now = new DateTime(clock.millis(), UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON)__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,date,time,now,new,date,time,clock,millis,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1548897299;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            DateTime now = new DateTime(clock.millis(), UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON,_                    operation.getIfSeqNo(), operation.getIfPrimaryTerm())__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,date,time,now,new,date,time,clock,millis,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,operation,get,if,seq,no,operation,get,if,primary,term,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1549289311;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            ZonedDateTime now = Instant.ofEpochMilli(clock.millis()).atZone(ZoneOffset.UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON,_                    operation.getIfSeqNo(), operation.getIfPrimaryTerm())__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,zoned,date,time,now,instant,of,epoch,milli,clock,millis,at,zone,zone,offset,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,operation,get,if,seq,no,operation,get,if,primary,term,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1549608646;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            ZonedDateTime now = clock.instant().atZone(ZoneOffset.UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON,_                    operation.getIfSeqNo(), operation.getIfPrimaryTerm())__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,zoned,date,time,now,clock,instant,at,zone,zone,offset,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,operation,get,if,seq,no,operation,get,if,primary,term,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> @Override     public Engine.Index preIndex(ShardId shardId, Engine.Index operation);1549960939;single watch operations that check if the local trigger service should trigger for this_concrete watch__Watch parsing could be optimized, so that parsing only happens on primary and where the_shard is supposed to be put into the trigger service at some point, right no we dont care__Note, we have to parse on the primary, because otherwise a failure on the replica when_parsing the watch would result in failing_the replica__@param shardId   The shard id object of the document being processed_@param operation The index operation_@return          The index operation;@Override_    public Engine.Index preIndex(ShardId shardId, Engine.Index operation) {_        if (isWatchDocument(shardId.getIndexName(), operation.type())) {_            ZonedDateTime now = Instant.ofEpochMilli(clock.millis()).atZone(ZoneOffset.UTC)__            try {_                Watch watch = parser.parseWithSecrets(operation.id(), true, operation.source(), now, XContentType.JSON,_                    operation.getIfSeqNo(), operation.getIfPrimaryTerm())__                ShardAllocationConfiguration shardAllocationConfiguration = configuration.localShards.get(shardId)__                if (shardAllocationConfiguration == null) {_                    logger.debug("no distributed watch execution info found for watch [{}] on shard [{}], got configuration for {}",_                            watch.id(), shardId, configuration.localShards.keySet())__                    return operation__                }__                boolean shouldBeTriggered = shardAllocationConfiguration.shouldBeTriggered(watch.id())__                if (shouldBeTriggered) {_                    if (watch.status().state().isActive()) {_                        logger.debug("adding watch [{}] to trigger service", watch.id())__                        triggerService.add(watch)__                    } else {_                        logger.debug("removing watch [{}] to trigger service", watch.id())__                        triggerService.remove(watch.id())__                    }_                } else {_                    logger.debug("watch [{}] should not be triggered", watch.id())__                }_            } catch (IOException e) {_                throw new ElasticsearchParseException("Could not parse watch with id [{}]", e, operation.id())__            }__        }__        return operation__    };single,watch,operations,that,check,if,the,local,trigger,service,should,trigger,for,this,concrete,watch,watch,parsing,could,be,optimized,so,that,parsing,only,happens,on,primary,and,where,the,shard,is,supposed,to,be,put,into,the,trigger,service,at,some,point,right,no,we,dont,care,note,we,have,to,parse,on,the,primary,because,otherwise,a,failure,on,the,replica,when,parsing,the,watch,would,result,in,failing,the,replica,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,operation,the,index,operation,return,the,index,operation;override,public,engine,index,pre,index,shard,id,shard,id,engine,index,operation,if,is,watch,document,shard,id,get,index,name,operation,type,zoned,date,time,now,instant,of,epoch,milli,clock,millis,at,zone,zone,offset,utc,try,watch,watch,parser,parse,with,secrets,operation,id,true,operation,source,now,xcontent,type,json,operation,get,if,seq,no,operation,get,if,primary,term,shard,allocation,configuration,shard,allocation,configuration,configuration,local,shards,get,shard,id,if,shard,allocation,configuration,null,logger,debug,no,distributed,watch,execution,info,found,for,watch,on,shard,got,configuration,for,watch,id,shard,id,configuration,local,shards,key,set,return,operation,boolean,should,be,triggered,shard,allocation,configuration,should,be,triggered,watch,id,if,should,be,triggered,if,watch,status,state,is,active,logger,debug,adding,watch,to,trigger,service,watch,id,trigger,service,add,watch,else,logger,debug,removing,watch,to,trigger,service,watch,id,trigger,service,remove,watch,id,else,logger,debug,watch,should,not,be,triggered,watch,id,catch,ioexception,e,throw,new,elasticsearch,parse,exception,could,not,parse,watch,with,id,e,operation,id,return,operation
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1524684173;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1525334055;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1531179852;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1539615817;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1541092382;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1543343306;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1546850547;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1548897299;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1549289311;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1549608646;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> private boolean isWatchDocument(String index, String docType);1549960939;Check if a supplied index and document matches the current configuration for watcher__@param index   The index to check for_@param docType The document type_@return true if this is a watch in the active watcher index, false otherwise;private boolean isWatchDocument(String index, String docType) {_        return configuration.isIndexAndActive(index) && docType.equals(Watch.DOC_TYPE)__    };check,if,a,supplied,index,and,document,matches,the,current,configuration,for,watcher,param,index,the,index,to,check,for,param,doc,type,the,document,type,return,true,if,this,is,a,watch,in,the,active,watcher,index,false,otherwise;private,boolean,is,watch,document,string,index,string,doc,type,return,configuration,is,index,and,active,index,doc,type,equals,watch
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1524684173;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1525334055;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1531179852;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1539615817;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1541092382;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1543343306;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1546850547;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1548897299;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1549289311;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1549608646;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete);1549960939;If the index operation happened on a watcher shard and is of doc type watcher, we will_remove the watch id from the trigger service__@param shardId   The shard id object of the document being processed_@param delete    The delete operation_@return          The delete operation;@Override_    public Engine.Delete preDelete(ShardId shardId, Engine.Delete delete) {_        if (isWatchDocument(shardId.getIndexName(), delete.type())) {_            triggerService.remove(delete.id())__        }__        return delete__    };if,the,index,operation,happened,on,a,watcher,shard,and,is,of,doc,type,watcher,we,will,remove,the,watch,id,from,the,trigger,service,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,delete,the,delete,operation,return,the,delete,operation;override,public,engine,delete,pre,delete,shard,id,shard,id,engine,delete,delete,if,is,watch,document,shard,id,get,index,name,delete,type,trigger,service,remove,delete,id,return,delete
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1524684173;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1525334055;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1531179852;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1539615817;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1541092382;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1543343306;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlock(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1546850547;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlockWithLevel(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,with,level,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1548897299;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlockWithLevel(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,with,level,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1549289311;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlockWithLevel(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,with,level,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1549608646;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlockWithLevel(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,with,level,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void clusterChanged(ClusterChangedEvent event);1549960939;Listen for cluster state changes. This method will start, stop or reload the watcher_service based on cluster state information._The method checks, if there are local watch indices up and running.__@param event The ClusterChangedEvent class containing the current and new cluster state;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        _        _        if (Strings.isNullOrEmpty(event.state().nodes().getMasterNodeId()) ||_                event.state().getBlocks().hasGlobalBlockWithLevel(ClusterBlockLevel.WRITE)) {_            configuration = INACTIVE__            return__        }__        if (event.state().nodes().getLocalNode().isDataNode() && event.metaDataChanged()) {_            try {_                IndexMetaData metaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, event.state().metaData())__                if (metaData == null) {_                    configuration = INACTIVE__                } else {_                    checkWatchIndexHasChanged(metaData, event)__                }_            } catch (IllegalStateException e) {_                logger.error("error loading watches index: [{}]", e.getMessage())__                configuration = INACTIVE__            }_        }_    };listen,for,cluster,state,changes,this,method,will,start,stop,or,reload,the,watcher,service,based,on,cluster,state,information,the,method,checks,if,there,are,local,watch,indices,up,and,running,param,event,the,cluster,changed,event,class,containing,the,current,and,new,cluster,state;override,public,void,cluster,changed,cluster,changed,event,event,if,strings,is,null,or,empty,event,state,nodes,get,master,node,id,event,state,get,blocks,has,global,block,with,level,cluster,block,level,write,configuration,inactive,return,if,event,state,nodes,get,local,node,is,data,node,event,meta,data,changed,try,index,meta,data,meta,data,watch,store,utils,get,concrete,index,watch,index,event,state,meta,data,if,meta,data,null,configuration,inactive,else,check,watch,index,has,changed,meta,data,event,catch,illegal,state,exception,e,logger,error,error,loading,watches,index,e,get,message,configuration,inactive
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1524684173;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occured during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occured,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1525334055;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occured during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occured,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1531179852;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occured during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occured,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1539615817;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occurred during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occurred,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1541092382;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occurred during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occurred,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1543343306;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occurred during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occurred,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1546850547;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occurred during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occurred,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1548897299;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occurred during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occurred,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1549289311;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occurred during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occurred,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1549608646;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occurred during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occurred,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> @Override     public void postIndex(ShardId shardId, Engine.Index index, Exception ex);1549960939;In case of an error, we have to ensure that the triggerservice does not leave anything behind__TODO: If the configuration changes between preindex and postindex methods and we add a_watch, that could not be indexed_TODO: this watch might not be deleted from the triggerservice. Are we willing to accept this?_TODO: This could be circumvented by using a threadlocal  in preIndex(), that contains the_watch and is cleared afterwards__@param shardId   The shard id object of the document being processed_@param index     The index operation_@param ex        The exception occurred during indexing;@Override_    public void postIndex(ShardId shardId, Engine.Index index, Exception ex) {_        if (isWatchDocument(shardId.getIndexName(), index.type())) {_            logger.debug(() -> new ParameterizedMessage("removing watch [{}] from trigger", index.id()), ex)__            triggerService.remove(index.id())__        }_    };in,case,of,an,error,we,have,to,ensure,that,the,triggerservice,does,not,leave,anything,behind,todo,if,the,configuration,changes,between,preindex,and,postindex,methods,and,we,add,a,watch,that,could,not,be,indexed,todo,this,watch,might,not,be,deleted,from,the,triggerservice,are,we,willing,to,accept,this,todo,this,could,be,circumvented,by,using,a,threadlocal,in,pre,index,that,contains,the,watch,and,is,cleared,afterwards,param,shard,id,the,shard,id,object,of,the,document,being,processed,param,index,the,index,operation,param,ex,the,exception,occurred,during,indexing;override,public,void,post,index,shard,id,shard,id,engine,index,index,exception,ex,if,is,watch,document,shard,id,get,index,name,index,type,logger,debug,new,parameterized,message,removing,watch,from,trigger,index,id,ex,trigger,service,remove,index,id
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1524684173;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1525334055;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1531179852;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1539615817;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1541092382;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1543343306;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1546850547;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1548897299;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1549289311;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1549608646;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable);1549960939;This returns a mapping of the shard it to the index of the shard allocation ids in that_list. The idea here is to have a basis for consistent hashing in order to decide if a_watch needs to be triggered locally or on another system, when it is being indexed_as a single watch action.__Example:_- ShardId(".watch", 0)_- all allocation ids sorted (in the cluster): [ "a", "b", "c", "d"]_- local allocation id: b (index position 1)_- then store the size of the allocation ids and the index position_data.put(ShardId(".watch", 0), new Tuple(1, 4));Map<ShardId, ShardAllocationConfiguration> getLocalShardAllocationIds(List<ShardRouting> localShards, IndexRoutingTable routingTable) {_        Map<ShardId, ShardAllocationConfiguration> data = new HashMap<>(localShards.size())___        for (ShardRouting shardRouting : localShards) {_            ShardId shardId = shardRouting.shardId()___            _            List<String> allocationIds = routingTable.shard(shardId.getId()).getActiveShards()_                    .stream()_                    .map(ShardRouting::allocationId)_                    .map(AllocationId::getId)_                    .collect(Collectors.toList())___            _            Collections.sort(allocationIds)___            String allocationId = shardRouting.allocationId().getId()__            int idx = allocationIds.indexOf(allocationId)__            data.put(shardId, new ShardAllocationConfiguration(idx, allocationIds.size(), allocationIds))__        }__        return data__    };this,returns,a,mapping,of,the,shard,it,to,the,index,of,the,shard,allocation,ids,in,that,list,the,idea,here,is,to,have,a,basis,for,consistent,hashing,in,order,to,decide,if,a,watch,needs,to,be,triggered,locally,or,on,another,system,when,it,is,being,indexed,as,a,single,watch,action,example,shard,id,watch,0,all,allocation,ids,sorted,in,the,cluster,a,b,c,d,local,allocation,id,b,index,position,1,then,store,the,size,of,the,allocation,ids,and,the,index,position,data,put,shard,id,watch,0,new,tuple,1,4;map,shard,id,shard,allocation,configuration,get,local,shard,allocation,ids,list,shard,routing,local,shards,index,routing,table,routing,table,map,shard,id,shard,allocation,configuration,data,new,hash,map,local,shards,size,for,shard,routing,shard,routing,local,shards,shard,id,shard,id,shard,routing,shard,id,list,string,allocation,ids,routing,table,shard,shard,id,get,id,get,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,list,collections,sort,allocation,ids,string,allocation,id,shard,routing,allocation,id,get,id,int,idx,allocation,ids,index,of,allocation,id,data,put,shard,id,new,shard,allocation,configuration,idx,allocation,ids,size,allocation,ids,return,data
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1524684173;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1525334055;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1531179852;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1539615817;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1541092382;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1543343306;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1546850547;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1548897299;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1549289311;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1549608646;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
WatcherIndexingListener -> Configuration -> public boolean isIndexAndActive(String index);1549960939;Find out, if the supplied index matches the current watcher configuration and the_current state is active__@param index The name of the index to compare with_@return false if watcher is not active or the passed index is not the watcher index;public boolean isIndexAndActive(String index) {_            return active == true && index.equals(this.index)__        };find,out,if,the,supplied,index,matches,the,current,watcher,configuration,and,the,current,state,is,active,param,index,the,name,of,the,index,to,compare,with,return,false,if,watcher,is,not,active,or,the,passed,index,is,not,the,watcher,index;public,boolean,is,index,and,active,string,index,return,active,true,index,equals,this,index
