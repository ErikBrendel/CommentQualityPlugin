commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;37;;@Override protected void doExecute(GetWatchRequest request, ActionListener<GetWatchResponse> listener) {     GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, request.getId()).preference(Preference.LOCAL.type()).realtime(true).     executeAsyncWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(getResponse -> {         if (getResponse.isExists()) {             try (XContentBuilder builder = jsonBuilder()) {                 // When we return the watch via the Get Watch REST API, we want to return the watch as was specified in                 // the put api, we don't include the status in the watch source itself, but as a separate top level field,                 // so that it indicates the the status is managed by watcher itself.                 ZonedDateTime now = clock.instant().atZone(ZoneOffset.UTC).                 Watch watch = parser.parseWithSecrets(request.getId(), true, getResponse.getSourceAsBytesRef(), now, XContentType.JSON, getResponse.getSeqNo(), getResponse.getPrimaryTerm()).                 watch.toXContent(builder, WatcherParams.builder().hideSecrets(true).includeStatus(false).build()).                 watch.status().version(getResponse.getVersion()).                 listener.onResponse(new GetWatchResponse(watch.id(), getResponse.getVersion(), watch.getSourceSeqNo(), watch.getSourcePrimaryTerm(), watch.status(), new XContentSource(BytesReference.bytes(builder), XContentType.JSON))).             }         } else {             listener.onResponse(new GetWatchResponse(request.getId())).         }     }, e -> {         // it should respond with the watch not being found         if (e instanceof IndexNotFoundException) {             listener.onResponse(new GetWatchResponse(request.getId())).         } else {             listener.onFailure(e).         }     }), client::get). }
