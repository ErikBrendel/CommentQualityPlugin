# id;timestamp;commentText;codeText;commentWords;codeWords
WatcherService -> private synchronized void reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches);1525334055;reload the watches and start scheduling them;private synchronized void reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {_        _        if (processedClusterStateVersion.get() != state.getVersion()) {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__        }__        Collection<Watch> watches = loadWatches(state)__        Collection<TriggeredWatch> triggeredWatches = Collections.emptyList()__        if (loadTriggeredWatches) {_            triggeredWatches = triggeredWatchStore.findTriggeredWatches(watches, state)__        }__        _        _        if (processedClusterStateVersion.get() == state.getVersion()) {_            executionService.unPause()__            triggerService.start(watches)__            if (triggeredWatches.isEmpty() == false) {_                executionService.executeTriggeredWatches(triggeredWatches)__            }_            logger.debug("watch service has been reloaded, reason [{}]", reason)__        } else {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__        }_    };reload,the,watches,and,start,scheduling,them;private,synchronized,void,reload,inner,cluster,state,state,string,reason,boolean,load,triggered,watches,if,processed,cluster,state,version,get,state,get,version,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,collection,watch,watches,load,watches,state,collection,triggered,watch,triggered,watches,collections,empty,list,if,load,triggered,watches,triggered,watches,triggered,watch,store,find,triggered,watches,watches,state,if,processed,cluster,state,version,get,state,get,version,execution,service,un,pause,trigger,service,start,watches,if,triggered,watches,is,empty,false,execution,service,execute,triggered,watches,triggered,watches,logger,debug,watch,service,has,been,reloaded,reason,reason,else,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get
WatcherService -> private synchronized void reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches);1525645056;reload the watches and start scheduling them;private synchronized void reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {_        _        if (processedClusterStateVersion.get() != state.getVersion()) {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__        }__        Collection<Watch> watches = loadWatches(state)__        Collection<TriggeredWatch> triggeredWatches = Collections.emptyList()__        if (loadTriggeredWatches) {_            triggeredWatches = triggeredWatchStore.findTriggeredWatches(watches, state)__        }__        _        _        if (processedClusterStateVersion.get() == state.getVersion()) {_            executionService.unPause()__            triggerService.start(watches)__            if (triggeredWatches.isEmpty() == false) {_                executionService.executeTriggeredWatches(triggeredWatches)__            }_            logger.debug("watch service has been reloaded, reason [{}]", reason)__        } else {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__        }_    };reload,the,watches,and,start,scheduling,them;private,synchronized,void,reload,inner,cluster,state,state,string,reason,boolean,load,triggered,watches,if,processed,cluster,state,version,get,state,get,version,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,collection,watch,watches,load,watches,state,collection,triggered,watch,triggered,watches,collections,empty,list,if,load,triggered,watches,triggered,watches,triggered,watch,store,find,triggered,watches,watches,state,if,processed,cluster,state,version,get,state,get,version,execution,service,un,pause,trigger,service,start,watches,if,triggered,watches,is,empty,false,execution,service,execute,triggered,watches,triggered,watches,logger,debug,watch,service,has,been,reloaded,reason,reason,else,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get
WatcherService -> void shutDown();1525334055;shuts down the trigger service as well to make sure there are no lingering threads_also no need to check anything, as this is final, we just can go to status STOPPED;void shutDown() {_        logger.info("stopping watch service, reason [shutdown initiated]")__        executionService.pause()__        triggerService.stop()__        stopExecutor()__        logger.debug("watch service has stopped")__    };shuts,down,the,trigger,service,as,well,to,make,sure,there,are,no,lingering,threads,also,no,need,to,check,anything,as,this,is,final,we,just,can,go,to,status,stopped;void,shut,down,logger,info,stopping,watch,service,reason,shutdown,initiated,execution,service,pause,trigger,service,stop,stop,executor,logger,debug,watch,service,has,stopped
WatcherService -> void shutDown();1525645056;shuts down the trigger service as well to make sure there are no lingering threads_also no need to check anything, as this is final, we just can go to status STOPPED;void shutDown() {_        logger.info("stopping watch service, reason [shutdown initiated]")__        executionService.pause()__        triggerService.stop()__        stopExecutor()__        logger.debug("watch service has stopped")__    };shuts,down,the,trigger,service,as,well,to,make,sure,there,are,no,lingering,threads,also,no,need,to,check,anything,as,this,is,final,we,just,can,go,to,status,stopped;void,shut,down,logger,info,stopping,watch,service,reason,shutdown,initiated,execution,service,pause,trigger,service,stop,stop,executor,logger,debug,watch,service,has,stopped
WatcherService -> void shutDown();1525798021;shuts down the trigger service as well to make sure there are no lingering threads_also no need to check anything, as this is final, we just can go to status STOPPED;void shutDown() {_        logger.info("stopping watch service, reason [shutdown initiated]")__        executionService.pause()__        triggerService.stop()__        stopExecutor()__        logger.debug("watch service has stopped")__    };shuts,down,the,trigger,service,as,well,to,make,sure,there,are,no,lingering,threads,also,no,need,to,check,anything,as,this,is,final,we,just,can,go,to,status,stopped;void,shut,down,logger,info,stopping,watch,service,reason,shutdown,initiated,execution,service,pause,trigger,service,stop,stop,executor,logger,debug,watch,service,has,stopped
WatcherService -> void shutDown();1535666657;shuts down the trigger service as well to make sure there are no lingering threads_also no need to check anything, as this is final, we just can go to status STOPPED;void shutDown() {_        logger.info("stopping watch service, reason [shutdown initiated]")__        executionService.pause()__        triggerService.stop()__        stopExecutor()__        logger.debug("watch service has stopped")__    };shuts,down,the,trigger,service,as,well,to,make,sure,there,are,no,lingering,threads,also,no,need,to,check,anything,as,this,is,final,we,just,can,go,to,status,stopped;void,shut,down,logger,info,stopping,watch,service,reason,shutdown,initiated,execution,service,pause,trigger,service,stop,stop,executor,logger,debug,watch,service,has,stopped
WatcherService -> void shutDown();1537806831;shuts down the trigger service as well to make sure there are no lingering threads_also no need to check anything, as this is final, we just can go to status STOPPED;void shutDown() {_        logger.info("stopping watch service, reason [shutdown initiated]")__        executionService.pause()__        triggerService.stop()__        stopExecutor()__        logger.debug("watch service has stopped")__    };shuts,down,the,trigger,service,as,well,to,make,sure,there,are,no,lingering,threads,also,no,need,to,check,anything,as,this,is,final,we,just,can,go,to,status,stopped;void,shut,down,logger,info,stopping,watch,service,reason,shutdown,initiated,execution,service,pause,trigger,service,stop,stop,executor,logger,debug,watch,service,has,stopped
WatcherService -> void shutDown();1541092382;shuts down the trigger service as well to make sure there are no lingering threads_also no need to check anything, as this is final, we just can go to status STOPPED;void shutDown() {_        logger.info("stopping watch service, reason [shutdown initiated]")__        executionService.pause()__        triggerService.stop()__        stopExecutor()__        logger.debug("watch service has stopped")__    };shuts,down,the,trigger,service,as,well,to,make,sure,there,are,no,lingering,threads,also,no,need,to,check,anything,as,this,is,final,we,just,can,go,to,status,stopped;void,shut,down,logger,info,stopping,watch,service,reason,shutdown,initiated,execution,service,pause,trigger,service,stop,stop,executor,logger,debug,watch,service,has,stopped
WatcherService -> void shutDown();1543343306;shuts down the trigger service as well to make sure there are no lingering threads_also no need to check anything, as this is final, we just can go to status STOPPED;void shutDown() {_        logger.info("stopping watch service, reason [shutdown initiated]")__        executionService.pause()__        triggerService.stop()__        stopExecutor()__        logger.debug("watch service has stopped")__    };shuts,down,the,trigger,service,as,well,to,make,sure,there,are,no,lingering,threads,also,no,need,to,check,anything,as,this,is,final,we,just,can,go,to,status,stopped;void,shut,down,logger,info,stopping,watch,service,reason,shutdown,initiated,execution,service,pause,trigger,service,stop,stop,executor,logger,debug,watch,service,has,stopped
WatcherService -> void shutDown();1544035746;shuts down the trigger service as well to make sure there are no lingering threads_also no need to check anything, as this is final, we just can go to status STOPPED;void shutDown() {_        logger.info("stopping watch service, reason [shutdown initiated]")__        executionService.pause()__        triggerService.stop()__        stopExecutor()__        logger.debug("watch service has stopped")__    };shuts,down,the,trigger,service,as,well,to,make,sure,there,are,no,lingering,threads,also,no,need,to,check,anything,as,this,is,final,we,just,can,go,to,status,stopped;void,shut,down,logger,info,stopping,watch,service,reason,shutdown,initiated,execution,service,pause,trigger,service,stop,stop,executor,logger,debug,watch,service,has,stopped
WatcherService -> void shutDown();1548897299;shuts down the trigger service as well to make sure there are no lingering threads_also no need to check anything, as this is final, we just can go to status STOPPED;void shutDown() {_        logger.info("stopping watch service, reason [shutdown initiated]")__        executionService.pause()__        triggerService.stop()__        stopExecutor()__        logger.debug("watch service has stopped")__    };shuts,down,the,trigger,service,as,well,to,make,sure,there,are,no,lingering,threads,also,no,need,to,check,anything,as,this,is,final,we,just,can,go,to,status,stopped;void,shut,down,logger,info,stopping,watch,service,reason,shutdown,initiated,execution,service,pause,trigger,service,stop,stop,executor,logger,debug,watch,service,has,stopped
WatcherService -> public void pauseExecution(String reason);1524684173;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        int cancelledTaskCount = executionService.pauseExecution()__        triggerService.pauseExecution()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,int,cancelled,task,count,execution,service,pause,execution,trigger,service,pause,execution,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> public void pauseExecution(String reason);1525334055;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        int cancelledTaskCount = executionService.pause()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,int,cancelled,task,count,execution,service,pause,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> public void pauseExecution(String reason);1525645056;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.pause()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,trigger,service,pause,execution,int,cancelled,task,count,execution,service,pause,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> public void pauseExecution(String reason);1525798021;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.pause()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,trigger,service,pause,execution,int,cancelled,task,count,execution,service,pause,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> public void pauseExecution(String reason);1535666657;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.pause()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,trigger,service,pause,execution,int,cancelled,task,count,execution,service,pause,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> public void pauseExecution(String reason);1537806831;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.pause()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,trigger,service,pause,execution,int,cancelled,task,count,execution,service,pause,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> public void pauseExecution(String reason);1541092382;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.pause()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,trigger,service,pause,execution,int,cancelled,task,count,execution,service,pause,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> public void pauseExecution(String reason);1543343306;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.pause()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,trigger,service,pause,execution,int,cancelled,task,count,execution,service,pause,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> public void pauseExecution(String reason);1544035746;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.pause()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,trigger,service,pause,execution,int,cancelled,task,count,execution,service,pause,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> public void pauseExecution(String reason);1548897299;Stop execution of watches on this node, do not try to reload anything, but still allow_manual watch execution, i.e. via the execute watch API;public void pauseExecution(String reason) {_        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.pause()__        logger.info("paused watch execution, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)__    };stop,execution,of,watches,on,this,node,do,not,try,to,reload,anything,but,still,allow,manual,watch,execution,i,e,via,the,execute,watch,api;public,void,pause,execution,string,reason,trigger,service,pause,execution,int,cancelled,task,count,execution,service,pause,logger,info,paused,watch,execution,reason,cancelled,queued,tasks,reason,cancelled,task,count
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1524684173;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1525334055;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1525645056;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1525798021;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1535666657;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1537806831;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1541092382;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1543343306;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1544035746;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private boolean parseWatchOnThisNode(String id, int totalShardCount, int index);1548897299;Find out if the watch with this id, should be parsed and triggered on this node__@param id              The id of the watch_@param totalShardCount The count of all primary shards of the current watches index_@param index           The index of the local shard_@return true if the we should parse the watch on this node, false otherwise;private boolean parseWatchOnThisNode(String id, int totalShardCount, int index) {_        int hash = Murmur3HashFunction.hash(id)__        int shardIndex = Math.floorMod(hash, totalShardCount)__        return shardIndex == index__    };find,out,if,the,watch,with,this,id,should,be,parsed,and,triggered,on,this,node,param,id,the,id,of,the,watch,param,total,shard,count,the,count,of,all,primary,shards,of,the,current,watches,index,param,index,the,index,of,the,local,shard,return,true,if,the,we,should,parse,the,watch,on,this,node,false,otherwise;private,boolean,parse,watch,on,this,node,string,id,int,total,shard,count,int,index,int,hash,murmur3hash,function,hash,id,int,shard,index,math,floor,mod,hash,total,shard,count,return,shard,index,index
WatcherService -> private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches);1525798021;reload watches and start scheduling them__@param state                 the current cluster state_@param reason                the reason for reloading, will be logged_@param loadTriggeredWatches  should triggered watches be loaded in this run, not needed for reloading, only for starting_@return                      true if no other loading of a newer cluster state happened in parallel, false otherwise;private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {_        _        if (processedClusterStateVersion.get() != state.getVersion()) {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__        }__        Collection<Watch> watches = loadWatches(state)__        Collection<TriggeredWatch> triggeredWatches = Collections.emptyList()__        if (loadTriggeredWatches) {_            triggeredWatches = triggeredWatchStore.findTriggeredWatches(watches, state)__        }__        _        _        if (processedClusterStateVersion.get() == state.getVersion()) {_            executionService.unPause()__            triggerService.start(watches)__            if (triggeredWatches.isEmpty() == false) {_                executionService.executeTriggeredWatches(triggeredWatches)__            }_            logger.debug("watch service has been reloaded, reason [{}]", reason)__            return true__        } else {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }_    };reload,watches,and,start,scheduling,them,param,state,the,current,cluster,state,param,reason,the,reason,for,reloading,will,be,logged,param,load,triggered,watches,should,triggered,watches,be,loaded,in,this,run,not,needed,for,reloading,only,for,starting,return,true,if,no,other,loading,of,a,newer,cluster,state,happened,in,parallel,false,otherwise;private,synchronized,boolean,reload,inner,cluster,state,state,string,reason,boolean,load,triggered,watches,if,processed,cluster,state,version,get,state,get,version,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,collection,watch,watches,load,watches,state,collection,triggered,watch,triggered,watches,collections,empty,list,if,load,triggered,watches,triggered,watches,triggered,watch,store,find,triggered,watches,watches,state,if,processed,cluster,state,version,get,state,get,version,execution,service,un,pause,trigger,service,start,watches,if,triggered,watches,is,empty,false,execution,service,execute,triggered,watches,triggered,watches,logger,debug,watch,service,has,been,reloaded,reason,reason,return,true,else,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false
WatcherService -> private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches);1535666657;reload watches and start scheduling them__@param state                 the current cluster state_@param reason                the reason for reloading, will be logged_@param loadTriggeredWatches  should triggered watches be loaded in this run, not needed for reloading, only for starting_@return                      true if no other loading of a newer cluster state happened in parallel, false otherwise;private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {_        _        if (processedClusterStateVersion.get() != state.getVersion()) {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }__        Collection<Watch> watches = loadWatches(state)__        Collection<TriggeredWatch> triggeredWatches = Collections.emptyList()__        if (loadTriggeredWatches) {_            triggeredWatches = triggeredWatchStore.findTriggeredWatches(watches, state)__        }__        _        _        _        _        if (processedClusterStateVersion.get() == state.getVersion()) {_            triggerService.pauseExecution()__            int cancelledTaskCount = executionService.clearExecutionsAndQueue()__            logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)___            executionService.unPause()__            triggerService.start(watches)__            if (triggeredWatches.isEmpty() == false) {_                executionService.executeTriggeredWatches(triggeredWatches)__            }_            logger.debug("watch service has been reloaded, reason [{}]", reason)__            return true__        } else {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }_    };reload,watches,and,start,scheduling,them,param,state,the,current,cluster,state,param,reason,the,reason,for,reloading,will,be,logged,param,load,triggered,watches,should,triggered,watches,be,loaded,in,this,run,not,needed,for,reloading,only,for,starting,return,true,if,no,other,loading,of,a,newer,cluster,state,happened,in,parallel,false,otherwise;private,synchronized,boolean,reload,inner,cluster,state,state,string,reason,boolean,load,triggered,watches,if,processed,cluster,state,version,get,state,get,version,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false,collection,watch,watches,load,watches,state,collection,triggered,watch,triggered,watches,collections,empty,list,if,load,triggered,watches,triggered,watches,triggered,watch,store,find,triggered,watches,watches,state,if,processed,cluster,state,version,get,state,get,version,trigger,service,pause,execution,int,cancelled,task,count,execution,service,clear,executions,and,queue,logger,info,reloading,watcher,reason,cancelled,queued,tasks,reason,cancelled,task,count,execution,service,un,pause,trigger,service,start,watches,if,triggered,watches,is,empty,false,execution,service,execute,triggered,watches,triggered,watches,logger,debug,watch,service,has,been,reloaded,reason,reason,return,true,else,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false
WatcherService -> private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches);1537806831;reload watches and start scheduling them__@param state                 the current cluster state_@param reason                the reason for reloading, will be logged_@param loadTriggeredWatches  should triggered watches be loaded in this run, not needed for reloading, only for starting_@return                      true if no other loading of a newer cluster state happened in parallel, false otherwise;private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {_        _        if (processedClusterStateVersion.get() != state.getVersion()) {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }__        Collection<Watch> watches = loadWatches(state)__        Collection<TriggeredWatch> triggeredWatches = Collections.emptyList()__        if (loadTriggeredWatches) {_            triggeredWatches = triggeredWatchStore.findTriggeredWatches(watches, state)__        }__        _        _        _        _        if (processedClusterStateVersion.get() == state.getVersion()) {_            executionService.unPause()__            triggerService.start(watches)__            if (triggeredWatches.isEmpty() == false) {_                executionService.executeTriggeredWatches(triggeredWatches)__            }_            logger.debug("watch service has been reloaded, reason [{}]", reason)__            return true__        } else {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }_    };reload,watches,and,start,scheduling,them,param,state,the,current,cluster,state,param,reason,the,reason,for,reloading,will,be,logged,param,load,triggered,watches,should,triggered,watches,be,loaded,in,this,run,not,needed,for,reloading,only,for,starting,return,true,if,no,other,loading,of,a,newer,cluster,state,happened,in,parallel,false,otherwise;private,synchronized,boolean,reload,inner,cluster,state,state,string,reason,boolean,load,triggered,watches,if,processed,cluster,state,version,get,state,get,version,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false,collection,watch,watches,load,watches,state,collection,triggered,watch,triggered,watches,collections,empty,list,if,load,triggered,watches,triggered,watches,triggered,watch,store,find,triggered,watches,watches,state,if,processed,cluster,state,version,get,state,get,version,execution,service,un,pause,trigger,service,start,watches,if,triggered,watches,is,empty,false,execution,service,execute,triggered,watches,triggered,watches,logger,debug,watch,service,has,been,reloaded,reason,reason,return,true,else,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false
WatcherService -> private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches);1541092382;reload watches and start scheduling them__@param state                 the current cluster state_@param reason                the reason for reloading, will be logged_@param loadTriggeredWatches  should triggered watches be loaded in this run, not needed for reloading, only for starting_@return                      true if no other loading of a newer cluster state happened in parallel, false otherwise;private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {_        _        if (processedClusterStateVersion.get() != state.getVersion()) {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }__        Collection<Watch> watches = loadWatches(state)__        Collection<TriggeredWatch> triggeredWatches = Collections.emptyList()__        if (loadTriggeredWatches) {_            triggeredWatches = triggeredWatchStore.findTriggeredWatches(watches, state)__        }__        _        _        _        _        if (processedClusterStateVersion.get() == state.getVersion()) {_            executionService.unPause()__            triggerService.start(watches)__            if (triggeredWatches.isEmpty() == false) {_                executionService.executeTriggeredWatches(triggeredWatches)__            }_            logger.debug("watch service has been reloaded, reason [{}]", reason)__            return true__        } else {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }_    };reload,watches,and,start,scheduling,them,param,state,the,current,cluster,state,param,reason,the,reason,for,reloading,will,be,logged,param,load,triggered,watches,should,triggered,watches,be,loaded,in,this,run,not,needed,for,reloading,only,for,starting,return,true,if,no,other,loading,of,a,newer,cluster,state,happened,in,parallel,false,otherwise;private,synchronized,boolean,reload,inner,cluster,state,state,string,reason,boolean,load,triggered,watches,if,processed,cluster,state,version,get,state,get,version,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false,collection,watch,watches,load,watches,state,collection,triggered,watch,triggered,watches,collections,empty,list,if,load,triggered,watches,triggered,watches,triggered,watch,store,find,triggered,watches,watches,state,if,processed,cluster,state,version,get,state,get,version,execution,service,un,pause,trigger,service,start,watches,if,triggered,watches,is,empty,false,execution,service,execute,triggered,watches,triggered,watches,logger,debug,watch,service,has,been,reloaded,reason,reason,return,true,else,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false
WatcherService -> private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches);1543343306;reload watches and start scheduling them__@param state                 the current cluster state_@param reason                the reason for reloading, will be logged_@param loadTriggeredWatches  should triggered watches be loaded in this run, not needed for reloading, only for starting_@return                      true if no other loading of a newer cluster state happened in parallel, false otherwise;private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {_        _        if (processedClusterStateVersion.get() != state.getVersion()) {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }__        Collection<Watch> watches = loadWatches(state)__        Collection<TriggeredWatch> triggeredWatches = Collections.emptyList()__        if (loadTriggeredWatches) {_            triggeredWatches = triggeredWatchStore.findTriggeredWatches(watches, state)__        }__        _        _        _        _        if (processedClusterStateVersion.get() == state.getVersion()) {_            executionService.unPause()__            triggerService.start(watches)__            if (triggeredWatches.isEmpty() == false) {_                executionService.executeTriggeredWatches(triggeredWatches)__            }_            logger.debug("watch service has been reloaded, reason [{}]", reason)__            return true__        } else {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }_    };reload,watches,and,start,scheduling,them,param,state,the,current,cluster,state,param,reason,the,reason,for,reloading,will,be,logged,param,load,triggered,watches,should,triggered,watches,be,loaded,in,this,run,not,needed,for,reloading,only,for,starting,return,true,if,no,other,loading,of,a,newer,cluster,state,happened,in,parallel,false,otherwise;private,synchronized,boolean,reload,inner,cluster,state,state,string,reason,boolean,load,triggered,watches,if,processed,cluster,state,version,get,state,get,version,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false,collection,watch,watches,load,watches,state,collection,triggered,watch,triggered,watches,collections,empty,list,if,load,triggered,watches,triggered,watches,triggered,watch,store,find,triggered,watches,watches,state,if,processed,cluster,state,version,get,state,get,version,execution,service,un,pause,trigger,service,start,watches,if,triggered,watches,is,empty,false,execution,service,execute,triggered,watches,triggered,watches,logger,debug,watch,service,has,been,reloaded,reason,reason,return,true,else,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false
WatcherService -> private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches);1544035746;reload watches and start scheduling them__@param state                 the current cluster state_@param reason                the reason for reloading, will be logged_@param loadTriggeredWatches  should triggered watches be loaded in this run, not needed for reloading, only for starting_@return                      true if no other loading of a newer cluster state happened in parallel, false otherwise;private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {_        _        if (processedClusterStateVersion.get() != state.getVersion()) {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }__        Collection<Watch> watches = loadWatches(state)__        Collection<TriggeredWatch> triggeredWatches = Collections.emptyList()__        if (loadTriggeredWatches) {_            triggeredWatches = triggeredWatchStore.findTriggeredWatches(watches, state)__        }__        _        _        _        _        if (processedClusterStateVersion.get() == state.getVersion()) {_            executionService.unPause()__            triggerService.start(watches)__            if (triggeredWatches.isEmpty() == false) {_                executionService.executeTriggeredWatches(triggeredWatches)__            }_            logger.debug("watch service has been reloaded, reason [{}]", reason)__            return true__        } else {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }_    };reload,watches,and,start,scheduling,them,param,state,the,current,cluster,state,param,reason,the,reason,for,reloading,will,be,logged,param,load,triggered,watches,should,triggered,watches,be,loaded,in,this,run,not,needed,for,reloading,only,for,starting,return,true,if,no,other,loading,of,a,newer,cluster,state,happened,in,parallel,false,otherwise;private,synchronized,boolean,reload,inner,cluster,state,state,string,reason,boolean,load,triggered,watches,if,processed,cluster,state,version,get,state,get,version,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false,collection,watch,watches,load,watches,state,collection,triggered,watch,triggered,watches,collections,empty,list,if,load,triggered,watches,triggered,watches,triggered,watch,store,find,triggered,watches,watches,state,if,processed,cluster,state,version,get,state,get,version,execution,service,un,pause,trigger,service,start,watches,if,triggered,watches,is,empty,false,execution,service,execute,triggered,watches,triggered,watches,logger,debug,watch,service,has,been,reloaded,reason,reason,return,true,else,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false
WatcherService -> private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches);1548897299;reload watches and start scheduling them__@param state                 the current cluster state_@param reason                the reason for reloading, will be logged_@param loadTriggeredWatches  should triggered watches be loaded in this run, not needed for reloading, only for starting_@return                      true if no other loading of a newer cluster state happened in parallel, false otherwise;private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {_        _        if (processedClusterStateVersion.get() != state.getVersion()) {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }__        Collection<Watch> watches = loadWatches(state)__        Collection<TriggeredWatch> triggeredWatches = Collections.emptyList()__        if (loadTriggeredWatches) {_            triggeredWatches = triggeredWatchStore.findTriggeredWatches(watches, state)__        }__        _        _        _        _        if (processedClusterStateVersion.get() == state.getVersion()) {_            executionService.unPause()__            triggerService.start(watches)__            if (triggeredWatches.isEmpty() == false) {_                executionService.executeTriggeredWatches(triggeredWatches)__            }_            logger.debug("watch service has been reloaded, reason [{}]", reason)__            return true__        } else {_            logger.debug("watch service has not been reloaded for state [{}], another reload for state [{}] in progress",_                state.getVersion(), processedClusterStateVersion.get())__            return false__        }_    };reload,watches,and,start,scheduling,them,param,state,the,current,cluster,state,param,reason,the,reason,for,reloading,will,be,logged,param,load,triggered,watches,should,triggered,watches,be,loaded,in,this,run,not,needed,for,reloading,only,for,starting,return,true,if,no,other,loading,of,a,newer,cluster,state,happened,in,parallel,false,otherwise;private,synchronized,boolean,reload,inner,cluster,state,state,string,reason,boolean,load,triggered,watches,if,processed,cluster,state,version,get,state,get,version,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false,collection,watch,watches,load,watches,state,collection,triggered,watch,triggered,watches,collections,empty,list,if,load,triggered,watches,triggered,watches,triggered,watch,store,find,triggered,watches,watches,state,if,processed,cluster,state,version,get,state,get,version,execution,service,un,pause,trigger,service,start,watches,if,triggered,watches,is,empty,false,execution,service,execute,triggered,watches,triggered,watches,logger,debug,watch,service,has,been,reloaded,reason,reason,return,true,else,logger,debug,watch,service,has,not,been,reloaded,for,state,another,reload,for,state,in,progress,state,get,version,processed,cluster,state,version,get,return,false
WatcherService -> public void stop(String reason);1524684173;Stops the watcher service and it's subservices. Should only be called, when watcher is stopped manually;public void stop(String reason) {_        WatcherState currentState = state.get()__        if (currentState == WatcherState.STOPPING || currentState == WatcherState.STOPPED) {_            logger.trace("watcher is already in state [{}] not stopping", currentState)__        } else {_            try {_                if (state.compareAndSet(WatcherState.STARTED, WatcherState.STOPPING)) {_                    logger.info("stopping watch service, reason [{}]", reason)__                    triggerService.stop()__                    executionService.stop()__                    state.set(WatcherState.STOPPED)__                    logger.debug("watch service has stopped")__                } else {_                    logger.debug("could not transition state from started to stopping, current state [{}]", state.get())__                }_            } catch (Exception e) {_                state.set(WatcherState.STOPPED)__                logger.error("Error stopping watcher", e)__            }_        }_    };stops,the,watcher,service,and,it,s,subservices,should,only,be,called,when,watcher,is,stopped,manually;public,void,stop,string,reason,watcher,state,current,state,state,get,if,current,state,watcher,state,stopping,current,state,watcher,state,stopped,logger,trace,watcher,is,already,in,state,not,stopping,current,state,else,try,if,state,compare,and,set,watcher,state,started,watcher,state,stopping,logger,info,stopping,watch,service,reason,reason,trigger,service,stop,execution,service,stop,state,set,watcher,state,stopped,logger,debug,watch,service,has,stopped,else,logger,debug,could,not,transition,state,from,started,to,stopping,current,state,state,get,catch,exception,e,state,set,watcher,state,stopped,logger,error,error,stopping,watcher,e
WatcherService -> public void stop(String reason);1525334055;Stops the watcher service and marks its services as paused;public void stop(String reason) {_        logger.info("stopping watch service, reason [{}]", reason)__        executionService.pause()__        triggerService.pauseExecution()__    };stops,the,watcher,service,and,marks,its,services,as,paused;public,void,stop,string,reason,logger,info,stopping,watch,service,reason,reason,execution,service,pause,trigger,service,pause,execution
WatcherService -> public void stop(String reason);1525645056;Stops the watcher service and marks its services as paused;public void stop(String reason) {_        logger.info("stopping watch service, reason [{}]", reason)__        executionService.pause()__        triggerService.pauseExecution()__    };stops,the,watcher,service,and,marks,its,services,as,paused;public,void,stop,string,reason,logger,info,stopping,watch,service,reason,reason,execution,service,pause,trigger,service,pause,execution
WatcherService -> public void stop(String reason);1525798021;Stops the watcher service and marks its services as paused;public void stop(String reason) {_        logger.info("stopping watch service, reason [{}]", reason)__        executionService.pause()__        triggerService.pauseExecution()__    };stops,the,watcher,service,and,marks,its,services,as,paused;public,void,stop,string,reason,logger,info,stopping,watch,service,reason,reason,execution,service,pause,trigger,service,pause,execution
WatcherService -> public void stop(String reason);1535666657;Stops the watcher service and marks its services as paused;public void stop(String reason) {_        logger.info("stopping watch service, reason [{}]", reason)__        executionService.pause()__        triggerService.pauseExecution()__    };stops,the,watcher,service,and,marks,its,services,as,paused;public,void,stop,string,reason,logger,info,stopping,watch,service,reason,reason,execution,service,pause,trigger,service,pause,execution
WatcherService -> public void stop(String reason);1537806831;Stops the watcher service and marks its services as paused;public void stop(String reason) {_        logger.info("stopping watch service, reason [{}]", reason)__        executionService.pause()__        triggerService.pauseExecution()__    };stops,the,watcher,service,and,marks,its,services,as,paused;public,void,stop,string,reason,logger,info,stopping,watch,service,reason,reason,execution,service,pause,trigger,service,pause,execution
WatcherService -> public void stop(String reason);1541092382;Stops the watcher service and marks its services as paused;public void stop(String reason) {_        logger.info("stopping watch service, reason [{}]", reason)__        executionService.pause()__        triggerService.pauseExecution()__    };stops,the,watcher,service,and,marks,its,services,as,paused;public,void,stop,string,reason,logger,info,stopping,watch,service,reason,reason,execution,service,pause,trigger,service,pause,execution
WatcherService -> public void stop(String reason);1543343306;Stops the watcher service and marks its services as paused;public void stop(String reason) {_        logger.info("stopping watch service, reason [{}]", reason)__        executionService.pause()__        triggerService.pauseExecution()__    };stops,the,watcher,service,and,marks,its,services,as,paused;public,void,stop,string,reason,logger,info,stopping,watch,service,reason,reason,execution,service,pause,trigger,service,pause,execution
WatcherService -> public void stop(String reason);1544035746;Stops the watcher service and marks its services as paused;public void stop(String reason) {_        logger.info("stopping watch service, reason [{}]", reason)__        executionService.pause()__        triggerService.pauseExecution()__    };stops,the,watcher,service,and,marks,its,services,as,paused;public,void,stop,string,reason,logger,info,stopping,watch,service,reason,reason,execution,service,pause,trigger,service,pause,execution
WatcherService -> public void stop(String reason);1548897299;Stops the watcher service and marks its services as paused;public void stop(String reason) {_        logger.info("stopping watch service, reason [{}]", reason)__        executionService.pause()__        triggerService.pauseExecution()__    };stops,the,watcher,service,and,marks,its,services,as,paused;public,void,stop,string,reason,logger,info,stopping,watch,service,reason,reason,execution,service,pause,trigger,service,pause,execution
WatcherService -> public boolean validate(ClusterState state);1524684173;Ensure that watcher can be started, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        boolean executionServiceValid = executionService.validate(state)__        if (executionServiceValid) {_            try {_                IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__                _                if (indexMetaData == null) {_                    return true__                } else {_                    if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                        logger.debug("watch index [{}] is marked as closed, watcher cannot be started", indexMetaData.getIndex().getName())__                        return false__                    } else {_                        return state.routingTable().index(indexMetaData.getIndex()).allPrimaryShardsActive()__                    }_                }_            } catch (IllegalStateException e) {_                logger.trace((Supplier<?>) () -> new ParameterizedMessage("error getting index meta data [{}]: ", Watch.INDEX), e)__                return false__            }_        }__        return false__    };ensure,that,watcher,can,be,started,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,execution,service,valid,execution,service,validate,state,if,execution,service,valid,try,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,if,index,meta,data,null,return,true,else,if,index,meta,data,get,state,index,meta,data,state,close,logger,debug,watch,index,is,marked,as,closed,watcher,cannot,be,started,index,meta,data,get,index,get,name,return,false,else,return,state,routing,table,index,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,trace,supplier,new,parameterized,message,error,getting,index,meta,data,watch,index,e,return,false,return,false
WatcherService -> public boolean validate(ClusterState state);1525334055;Ensure that watcher can be reloaded, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        _        boolean hasValidWatcherTemplates = WatcherIndexTemplateRegistry.validate(state)__        if (hasValidWatcherTemplates == false) {_            logger.debug("missing watcher index templates, not starting watcher service")__            return false__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__        IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_            state.metaData())__        boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__        boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__        if (isIndexInternalFormatTriggeredWatchIndex == false || isIndexInternalFormatWatchIndex == false) {_            logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__            return false__        }__        try {_            boolean storesValid = TriggeredWatchStore.validate(state) && HistoryStore.validate(state)__            if (storesValid == false) {_                return false__            }__            return watcherIndexMetaData == null || (watcherIndexMetaData.getState() == IndexMetaData.State.OPEN &&_                state.routingTable().index(watcherIndexMetaData.getIndex()).allPrimaryShardsActive())__        } catch (IllegalStateException e) {_            logger.debug("error validating to start watcher", e)__            return false__        }_    };ensure,that,watcher,can,be,reloaded,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,has,valid,watcher,templates,watcher,index,template,registry,validate,state,if,has,valid,watcher,templates,false,logger,debug,missing,watcher,index,templates,not,starting,watcher,service,return,false,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,false,is,index,internal,format,watch,index,false,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index,return,false,try,boolean,stores,valid,triggered,watch,store,validate,state,history,store,validate,state,if,stores,valid,false,return,false,return,watcher,index,meta,data,null,watcher,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,watcher,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,debug,error,validating,to,start,watcher,e,return,false
WatcherService -> public boolean validate(ClusterState state);1525645056;Ensure that watcher can be reloaded, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        _        boolean hasValidWatcherTemplates = WatcherIndexTemplateRegistry.validate(state)__        if (hasValidWatcherTemplates == false) {_            logger.debug("missing watcher index templates, not starting watcher service")__            return false__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__        IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_            state.metaData())__        boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__        boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__        if (isIndexInternalFormatTriggeredWatchIndex == false || isIndexInternalFormatWatchIndex == false) {_            logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__            return false__        }__        try {_            boolean storesValid = TriggeredWatchStore.validate(state) && HistoryStore.validate(state)__            if (storesValid == false) {_                return false__            }__            return watcherIndexMetaData == null || (watcherIndexMetaData.getState() == IndexMetaData.State.OPEN &&_                state.routingTable().index(watcherIndexMetaData.getIndex()).allPrimaryShardsActive())__        } catch (IllegalStateException e) {_            logger.debug("error validating to start watcher", e)__            return false__        }_    };ensure,that,watcher,can,be,reloaded,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,has,valid,watcher,templates,watcher,index,template,registry,validate,state,if,has,valid,watcher,templates,false,logger,debug,missing,watcher,index,templates,not,starting,watcher,service,return,false,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,false,is,index,internal,format,watch,index,false,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index,return,false,try,boolean,stores,valid,triggered,watch,store,validate,state,history,store,validate,state,if,stores,valid,false,return,false,return,watcher,index,meta,data,null,watcher,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,watcher,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,debug,error,validating,to,start,watcher,e,return,false
WatcherService -> public boolean validate(ClusterState state);1525798021;Ensure that watcher can be reloaded, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        _        boolean hasValidWatcherTemplates = WatcherIndexTemplateRegistry.validate(state)__        if (hasValidWatcherTemplates == false) {_            logger.debug("missing watcher index templates, not starting watcher service")__            return false__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__        IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_            state.metaData())__        boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__        boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__        if (isIndexInternalFormatTriggeredWatchIndex == false || isIndexInternalFormatWatchIndex == false) {_            logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__            return false__        }__        try {_            boolean storesValid = TriggeredWatchStore.validate(state) && HistoryStore.validate(state)__            if (storesValid == false) {_                return false__            }__            return watcherIndexMetaData == null || (watcherIndexMetaData.getState() == IndexMetaData.State.OPEN &&_                state.routingTable().index(watcherIndexMetaData.getIndex()).allPrimaryShardsActive())__        } catch (IllegalStateException e) {_            logger.debug("error validating to start watcher", e)__            return false__        }_    };ensure,that,watcher,can,be,reloaded,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,has,valid,watcher,templates,watcher,index,template,registry,validate,state,if,has,valid,watcher,templates,false,logger,debug,missing,watcher,index,templates,not,starting,watcher,service,return,false,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,false,is,index,internal,format,watch,index,false,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index,return,false,try,boolean,stores,valid,triggered,watch,store,validate,state,history,store,validate,state,if,stores,valid,false,return,false,return,watcher,index,meta,data,null,watcher,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,watcher,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,debug,error,validating,to,start,watcher,e,return,false
WatcherService -> public boolean validate(ClusterState state);1535666657;Ensure that watcher can be reloaded, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        _        boolean hasValidWatcherTemplates = WatcherIndexTemplateRegistry.validate(state)__        if (hasValidWatcherTemplates == false) {_            logger.debug("missing watcher index templates, not starting watcher service")__            return false__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__        IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_            state.metaData())__        boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__        boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__        if (isIndexInternalFormatTriggeredWatchIndex == false || isIndexInternalFormatWatchIndex == false) {_            logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__            return false__        }__        try {_            boolean storesValid = TriggeredWatchStore.validate(state) && HistoryStore.validate(state)__            if (storesValid == false) {_                return false__            }__            return watcherIndexMetaData == null || (watcherIndexMetaData.getState() == IndexMetaData.State.OPEN &&_                state.routingTable().index(watcherIndexMetaData.getIndex()).allPrimaryShardsActive())__        } catch (IllegalStateException e) {_            logger.debug("error validating to start watcher", e)__            return false__        }_    };ensure,that,watcher,can,be,reloaded,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,has,valid,watcher,templates,watcher,index,template,registry,validate,state,if,has,valid,watcher,templates,false,logger,debug,missing,watcher,index,templates,not,starting,watcher,service,return,false,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,false,is,index,internal,format,watch,index,false,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index,return,false,try,boolean,stores,valid,triggered,watch,store,validate,state,history,store,validate,state,if,stores,valid,false,return,false,return,watcher,index,meta,data,null,watcher,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,watcher,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,debug,error,validating,to,start,watcher,e,return,false
WatcherService -> public boolean validate(ClusterState state);1537806831;Ensure that watcher can be reloaded, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        _        boolean hasValidWatcherTemplates = WatcherIndexTemplateRegistry.validate(state)__        if (hasValidWatcherTemplates == false) {_            logger.debug("missing watcher index templates, not starting watcher service")__            return false__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__        IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_            state.metaData())__        boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__        boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__        if (isIndexInternalFormatTriggeredWatchIndex == false || isIndexInternalFormatWatchIndex == false) {_            logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__            return false__        }__        try {_            boolean storesValid = TriggeredWatchStore.validate(state) && HistoryStore.validate(state)__            if (storesValid == false) {_                return false__            }__            return watcherIndexMetaData == null || (watcherIndexMetaData.getState() == IndexMetaData.State.OPEN &&_                state.routingTable().index(watcherIndexMetaData.getIndex()).allPrimaryShardsActive())__        } catch (IllegalStateException e) {_            logger.debug("error validating to start watcher", e)__            return false__        }_    };ensure,that,watcher,can,be,reloaded,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,has,valid,watcher,templates,watcher,index,template,registry,validate,state,if,has,valid,watcher,templates,false,logger,debug,missing,watcher,index,templates,not,starting,watcher,service,return,false,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,false,is,index,internal,format,watch,index,false,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index,return,false,try,boolean,stores,valid,triggered,watch,store,validate,state,history,store,validate,state,if,stores,valid,false,return,false,return,watcher,index,meta,data,null,watcher,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,watcher,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,debug,error,validating,to,start,watcher,e,return,false
WatcherService -> public boolean validate(ClusterState state);1541092382;Ensure that watcher can be reloaded, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        _        boolean hasValidWatcherTemplates = WatcherIndexTemplateRegistry.validate(state)__        if (hasValidWatcherTemplates == false) {_            logger.debug("missing watcher index templates, not starting watcher service")__            return false__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__        IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_            state.metaData())__        boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__        boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__        if (isIndexInternalFormatTriggeredWatchIndex == false || isIndexInternalFormatWatchIndex == false) {_            logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__            return false__        }__        try {_            boolean storesValid = TriggeredWatchStore.validate(state) && HistoryStore.validate(state)__            if (storesValid == false) {_                return false__            }__            return watcherIndexMetaData == null || (watcherIndexMetaData.getState() == IndexMetaData.State.OPEN &&_                state.routingTable().index(watcherIndexMetaData.getIndex()).allPrimaryShardsActive())__        } catch (IllegalStateException e) {_            logger.debug("error validating to start watcher", e)__            return false__        }_    };ensure,that,watcher,can,be,reloaded,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,has,valid,watcher,templates,watcher,index,template,registry,validate,state,if,has,valid,watcher,templates,false,logger,debug,missing,watcher,index,templates,not,starting,watcher,service,return,false,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,false,is,index,internal,format,watch,index,false,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index,return,false,try,boolean,stores,valid,triggered,watch,store,validate,state,history,store,validate,state,if,stores,valid,false,return,false,return,watcher,index,meta,data,null,watcher,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,watcher,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,debug,error,validating,to,start,watcher,e,return,false
WatcherService -> public boolean validate(ClusterState state);1543343306;Ensure that watcher can be reloaded, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        _        boolean hasValidWatcherTemplates = WatcherIndexTemplateRegistry.validate(state)__        if (hasValidWatcherTemplates == false) {_            logger.debug("missing watcher index templates, not starting watcher service")__            return false__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__        IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_            state.metaData())__        boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__        boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__        if (isIndexInternalFormatTriggeredWatchIndex == false || isIndexInternalFormatWatchIndex == false) {_            logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__            return false__        }__        try {_            boolean storesValid = TriggeredWatchStore.validate(state) && HistoryStore.validate(state)__            if (storesValid == false) {_                return false__            }__            return watcherIndexMetaData == null || (watcherIndexMetaData.getState() == IndexMetaData.State.OPEN &&_                state.routingTable().index(watcherIndexMetaData.getIndex()).allPrimaryShardsActive())__        } catch (IllegalStateException e) {_            logger.debug("error validating to start watcher", e)__            return false__        }_    };ensure,that,watcher,can,be,reloaded,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,has,valid,watcher,templates,watcher,index,template,registry,validate,state,if,has,valid,watcher,templates,false,logger,debug,missing,watcher,index,templates,not,starting,watcher,service,return,false,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,false,is,index,internal,format,watch,index,false,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index,return,false,try,boolean,stores,valid,triggered,watch,store,validate,state,history,store,validate,state,if,stores,valid,false,return,false,return,watcher,index,meta,data,null,watcher,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,watcher,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,debug,error,validating,to,start,watcher,e,return,false
WatcherService -> public boolean validate(ClusterState state);1544035746;Ensure that watcher can be reloaded, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        _        boolean hasValidWatcherTemplates = WatcherIndexTemplateRegistry.validate(state)__        if (hasValidWatcherTemplates == false) {_            logger.debug("missing watcher index templates, not starting watcher service")__            return false__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__        IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_            state.metaData())__        boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__        boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__        if (isIndexInternalFormatTriggeredWatchIndex == false || isIndexInternalFormatWatchIndex == false) {_            logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__            return false__        }__        try {_            boolean storesValid = TriggeredWatchStore.validate(state) && HistoryStore.validate(state)__            if (storesValid == false) {_                return false__            }__            return watcherIndexMetaData == null || (watcherIndexMetaData.getState() == IndexMetaData.State.OPEN &&_                state.routingTable().index(watcherIndexMetaData.getIndex()).allPrimaryShardsActive())__        } catch (IllegalStateException e) {_            logger.debug("error validating to start watcher", e)__            return false__        }_    };ensure,that,watcher,can,be,reloaded,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,has,valid,watcher,templates,watcher,index,template,registry,validate,state,if,has,valid,watcher,templates,false,logger,debug,missing,watcher,index,templates,not,starting,watcher,service,return,false,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,false,is,index,internal,format,watch,index,false,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index,return,false,try,boolean,stores,valid,triggered,watch,store,validate,state,history,store,validate,state,if,stores,valid,false,return,false,return,watcher,index,meta,data,null,watcher,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,watcher,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,debug,error,validating,to,start,watcher,e,return,false
WatcherService -> public boolean validate(ClusterState state);1548897299;Ensure that watcher can be reloaded, by checking if all indices are marked as up and ready in the cluster state_@param state The current cluster state_@return true if everything is good to go, so that the service can be started;public boolean validate(ClusterState state) {_        _        boolean hasValidWatcherTemplates = WatcherIndexTemplateRegistry.validate(state)__        if (hasValidWatcherTemplates == false) {_            logger.debug("missing watcher index templates, not starting watcher service")__            return false__        }__        IndexMetaData watcherIndexMetaData = WatchStoreUtils.getConcreteIndex(Watch.INDEX, state.metaData())__        IndexMetaData triggeredWatchesIndexMetaData = WatchStoreUtils.getConcreteIndex(TriggeredWatchStoreField.INDEX_NAME,_            state.metaData())__        boolean isIndexInternalFormatWatchIndex = watcherIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(watcherIndexMetaData)__        boolean isIndexInternalFormatTriggeredWatchIndex = triggeredWatchesIndexMetaData == null ||_            UpgradeField.checkInternalIndexFormat(triggeredWatchesIndexMetaData)__        if (isIndexInternalFormatTriggeredWatchIndex == false || isIndexInternalFormatWatchIndex == false) {_            logger.warn("not starting watcher, upgrade API run required: .watches[{}], .triggered_watches[{}]",_                isIndexInternalFormatWatchIndex, isIndexInternalFormatTriggeredWatchIndex)__            return false__        }__        try {_            boolean storesValid = TriggeredWatchStore.validate(state) && HistoryStore.validate(state)__            if (storesValid == false) {_                return false__            }__            return watcherIndexMetaData == null || (watcherIndexMetaData.getState() == IndexMetaData.State.OPEN &&_                state.routingTable().index(watcherIndexMetaData.getIndex()).allPrimaryShardsActive())__        } catch (IllegalStateException e) {_            logger.debug("error validating to start watcher", e)__            return false__        }_    };ensure,that,watcher,can,be,reloaded,by,checking,if,all,indices,are,marked,as,up,and,ready,in,the,cluster,state,param,state,the,current,cluster,state,return,true,if,everything,is,good,to,go,so,that,the,service,can,be,started;public,boolean,validate,cluster,state,state,boolean,has,valid,watcher,templates,watcher,index,template,registry,validate,state,if,has,valid,watcher,templates,false,logger,debug,missing,watcher,index,templates,not,starting,watcher,service,return,false,index,meta,data,watcher,index,meta,data,watch,store,utils,get,concrete,index,watch,index,state,meta,data,index,meta,data,triggered,watches,index,meta,data,watch,store,utils,get,concrete,index,triggered,watch,store,field,state,meta,data,boolean,is,index,internal,format,watch,index,watcher,index,meta,data,null,upgrade,field,check,internal,index,format,watcher,index,meta,data,boolean,is,index,internal,format,triggered,watch,index,triggered,watches,index,meta,data,null,upgrade,field,check,internal,index,format,triggered,watches,index,meta,data,if,is,index,internal,format,triggered,watch,index,false,is,index,internal,format,watch,index,false,logger,warn,not,starting,watcher,upgrade,api,run,required,watches,is,index,internal,format,watch,index,is,index,internal,format,triggered,watch,index,return,false,try,boolean,stores,valid,triggered,watch,store,validate,state,history,store,validate,state,if,stores,valid,false,return,false,return,watcher,index,meta,data,null,watcher,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,watcher,index,meta,data,get,index,all,primary,shards,active,catch,illegal,state,exception,e,logger,debug,error,validating,to,start,watcher,e,return,false
WatcherService -> void reload(ClusterState state, String reason);1525334055;Reload the watcher service, does not switch the state from stopped to started, just keep going_@param state cluster state, which is needed to find out about local shards;void reload(ClusterState state, String reason) {_        _        _        _        _        _        _        _        _        _        processedClusterStateVersion.set(state.getVersion())__        pauseExecution(reason)__        triggerService.pauseExecution()___        executor.execute(wrapWatcherService(() -> reloadInner(state, reason, false),_            e -> logger.error("error reloading watcher", e)))__    };reload,the,watcher,service,does,not,switch,the,state,from,stopped,to,started,just,keep,going,param,state,cluster,state,which,is,needed,to,find,out,about,local,shards;void,reload,cluster,state,state,string,reason,processed,cluster,state,version,set,state,get,version,pause,execution,reason,trigger,service,pause,execution,executor,execute,wrap,watcher,service,reload,inner,state,reason,false,e,logger,error,error,reloading,watcher,e
WatcherService -> void reload(ClusterState state, String reason);1525645056;Reload the watcher service, does not switch the state from stopped to started, just keep going_@param state cluster state, which is needed to find out about local shards;void reload(ClusterState state, String reason) {_        _        _        _        _        _        _        _        _        _        processedClusterStateVersion.set(state.getVersion())__        pauseExecution(reason)__        triggerService.pauseExecution()___        executor.execute(wrapWatcherService(() -> reloadInner(state, reason, false),_            e -> logger.error("error reloading watcher", e)))__    };reload,the,watcher,service,does,not,switch,the,state,from,stopped,to,started,just,keep,going,param,state,cluster,state,which,is,needed,to,find,out,about,local,shards;void,reload,cluster,state,state,string,reason,processed,cluster,state,version,set,state,get,version,pause,execution,reason,trigger,service,pause,execution,executor,execute,wrap,watcher,service,reload,inner,state,reason,false,e,logger,error,error,reloading,watcher,e
WatcherService -> void reload(ClusterState state, String reason);1525798021;Reload the watcher service, does not switch the state from stopped to started, just keep going_@param state cluster state, which is needed to find out about local shards;void reload(ClusterState state, String reason) {_        _        _        _        _        _        _        _        _        _        processedClusterStateVersion.set(state.getVersion())__        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.clearExecutionsAndQueue()__        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)___        executor.execute(wrapWatcherService(() -> reloadInner(state, reason, false),_            e -> logger.error("error reloading watcher", e)))__    };reload,the,watcher,service,does,not,switch,the,state,from,stopped,to,started,just,keep,going,param,state,cluster,state,which,is,needed,to,find,out,about,local,shards;void,reload,cluster,state,state,string,reason,processed,cluster,state,version,set,state,get,version,trigger,service,pause,execution,int,cancelled,task,count,execution,service,clear,executions,and,queue,logger,info,reloading,watcher,reason,cancelled,queued,tasks,reason,cancelled,task,count,executor,execute,wrap,watcher,service,reload,inner,state,reason,false,e,logger,error,error,reloading,watcher,e
WatcherService -> void reload(ClusterState state, String reason);1535666657;Reload the watcher service, does not switch the state from stopped to started, just keep going_@param state cluster state, which is needed to find out about local shards;void reload(ClusterState state, String reason) {_        _        _        _        _        _        _        _        _        _        processedClusterStateVersion.set(state.getVersion())___        executor.execute(wrapWatcherService(() -> reloadInner(state, reason, false),_            e -> logger.error("error reloading watcher", e)))__    };reload,the,watcher,service,does,not,switch,the,state,from,stopped,to,started,just,keep,going,param,state,cluster,state,which,is,needed,to,find,out,about,local,shards;void,reload,cluster,state,state,string,reason,processed,cluster,state,version,set,state,get,version,executor,execute,wrap,watcher,service,reload,inner,state,reason,false,e,logger,error,error,reloading,watcher,e
WatcherService -> void reload(ClusterState state, String reason);1537806831;Reload the watcher service, does not switch the state from stopped to started, just keep going_@param state cluster state, which is needed to find out about local shards;void reload(ClusterState state, String reason) {_        _        _        _        _        _        _        _        _        _        processedClusterStateVersion.set(state.getVersion())___        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.clearExecutionsAndQueue()__        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)___        executor.execute(wrapWatcherService(() -> reloadInner(state, reason, false),_            e -> logger.error("error reloading watcher", e)))__    };reload,the,watcher,service,does,not,switch,the,state,from,stopped,to,started,just,keep,going,param,state,cluster,state,which,is,needed,to,find,out,about,local,shards;void,reload,cluster,state,state,string,reason,processed,cluster,state,version,set,state,get,version,trigger,service,pause,execution,int,cancelled,task,count,execution,service,clear,executions,and,queue,logger,info,reloading,watcher,reason,cancelled,queued,tasks,reason,cancelled,task,count,executor,execute,wrap,watcher,service,reload,inner,state,reason,false,e,logger,error,error,reloading,watcher,e
WatcherService -> void reload(ClusterState state, String reason);1541092382;Reload the watcher service, does not switch the state from stopped to started, just keep going_@param state cluster state, which is needed to find out about local shards;void reload(ClusterState state, String reason) {_        _        _        _        _        _        _        _        _        _        processedClusterStateVersion.set(state.getVersion())___        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.clearExecutionsAndQueue()__        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)___        executor.execute(wrapWatcherService(() -> reloadInner(state, reason, false),_            e -> logger.error("error reloading watcher", e)))__    };reload,the,watcher,service,does,not,switch,the,state,from,stopped,to,started,just,keep,going,param,state,cluster,state,which,is,needed,to,find,out,about,local,shards;void,reload,cluster,state,state,string,reason,processed,cluster,state,version,set,state,get,version,trigger,service,pause,execution,int,cancelled,task,count,execution,service,clear,executions,and,queue,logger,info,reloading,watcher,reason,cancelled,queued,tasks,reason,cancelled,task,count,executor,execute,wrap,watcher,service,reload,inner,state,reason,false,e,logger,error,error,reloading,watcher,e
WatcherService -> void reload(ClusterState state, String reason);1543343306;Reload the watcher service, does not switch the state from stopped to started, just keep going_@param state cluster state, which is needed to find out about local shards;void reload(ClusterState state, String reason) {_        _        _        _        _        _        _        _        _        _        processedClusterStateVersion.set(state.getVersion())___        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.clearExecutionsAndQueue()__        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)___        executor.execute(wrapWatcherService(() -> reloadInner(state, reason, false),_            e -> logger.error("error reloading watcher", e)))__    };reload,the,watcher,service,does,not,switch,the,state,from,stopped,to,started,just,keep,going,param,state,cluster,state,which,is,needed,to,find,out,about,local,shards;void,reload,cluster,state,state,string,reason,processed,cluster,state,version,set,state,get,version,trigger,service,pause,execution,int,cancelled,task,count,execution,service,clear,executions,and,queue,logger,info,reloading,watcher,reason,cancelled,queued,tasks,reason,cancelled,task,count,executor,execute,wrap,watcher,service,reload,inner,state,reason,false,e,logger,error,error,reloading,watcher,e
WatcherService -> void reload(ClusterState state, String reason);1544035746;Reload the watcher service, does not switch the state from stopped to started, just keep going_@param state cluster state, which is needed to find out about local shards;void reload(ClusterState state, String reason) {_        _        _        _        _        _        _        _        _        _        processedClusterStateVersion.set(state.getVersion())___        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.clearExecutionsAndQueue()__        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)___        executor.execute(wrapWatcherService(() -> reloadInner(state, reason, false),_            e -> logger.error("error reloading watcher", e)))__    };reload,the,watcher,service,does,not,switch,the,state,from,stopped,to,started,just,keep,going,param,state,cluster,state,which,is,needed,to,find,out,about,local,shards;void,reload,cluster,state,state,string,reason,processed,cluster,state,version,set,state,get,version,trigger,service,pause,execution,int,cancelled,task,count,execution,service,clear,executions,and,queue,logger,info,reloading,watcher,reason,cancelled,queued,tasks,reason,cancelled,task,count,executor,execute,wrap,watcher,service,reload,inner,state,reason,false,e,logger,error,error,reloading,watcher,e
WatcherService -> void reload(ClusterState state, String reason);1548897299;Reload the watcher service, does not switch the state from stopped to started, just keep going_@param state cluster state, which is needed to find out about local shards;void reload(ClusterState state, String reason) {_        _        _        _        _        _        _        _        _        _        processedClusterStateVersion.set(state.getVersion())___        triggerService.pauseExecution()__        int cancelledTaskCount = executionService.clearExecutionsAndQueue()__        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount)___        executor.execute(wrapWatcherService(() -> reloadInner(state, reason, false),_            e -> logger.error("error reloading watcher", e)))__    };reload,the,watcher,service,does,not,switch,the,state,from,stopped,to,started,just,keep,going,param,state,cluster,state,which,is,needed,to,find,out,about,local,shards;void,reload,cluster,state,state,string,reason,processed,cluster,state,version,set,state,get,version,trigger,service,pause,execution,int,cancelled,task,count,execution,service,clear,executions,and,queue,logger,info,reloading,watcher,reason,cancelled,queued,tasks,reason,cancelled,task,count,executor,execute,wrap,watcher,service,reload,inner,state,reason,false,e,logger,error,error,reloading,watcher,e
WatcherService -> private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer);1525334055;Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas_This ensures that the uncaught exception handler in the executing threadpool does not get called__@param run                 The code to be executed in the runnable_@param exceptionConsumer   The exception handling code to be executed, if the runnable fails_@return                    The AbstractRunnable instance to pass to the executor;private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {_        return new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                exceptionConsumer.accept(e)__            }__            @Override_            protected void doRun() throws Exception {_                run.run()__            }_        }__    };wraps,an,abstract,runnable,to,easier,supply,on,failure,and,do,run,methods,via,lambdas,this,ensures,that,the,uncaught,exception,handler,in,the,executing,threadpool,does,not,get,called,param,run,the,code,to,be,executed,in,the,runnable,param,exception,consumer,the,exception,handling,code,to,be,executed,if,the,runnable,fails,return,the,abstract,runnable,instance,to,pass,to,the,executor;private,static,abstract,runnable,wrap,watcher,service,runnable,run,consumer,exception,exception,consumer,return,new,abstract,runnable,override,public,void,on,failure,exception,e,exception,consumer,accept,e,override,protected,void,do,run,throws,exception,run,run
WatcherService -> private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer);1525645056;Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas_This ensures that the uncaught exception handler in the executing threadpool does not get called__@param run                 The code to be executed in the runnable_@param exceptionConsumer   The exception handling code to be executed, if the runnable fails_@return                    The AbstractRunnable instance to pass to the executor;private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {_        return new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                exceptionConsumer.accept(e)__            }__            @Override_            protected void doRun() throws Exception {_                run.run()__            }_        }__    };wraps,an,abstract,runnable,to,easier,supply,on,failure,and,do,run,methods,via,lambdas,this,ensures,that,the,uncaught,exception,handler,in,the,executing,threadpool,does,not,get,called,param,run,the,code,to,be,executed,in,the,runnable,param,exception,consumer,the,exception,handling,code,to,be,executed,if,the,runnable,fails,return,the,abstract,runnable,instance,to,pass,to,the,executor;private,static,abstract,runnable,wrap,watcher,service,runnable,run,consumer,exception,exception,consumer,return,new,abstract,runnable,override,public,void,on,failure,exception,e,exception,consumer,accept,e,override,protected,void,do,run,throws,exception,run,run
WatcherService -> private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer);1525798021;Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas_This ensures that the uncaught exception handler in the executing threadpool does not get called__@param run                 The code to be executed in the runnable_@param exceptionConsumer   The exception handling code to be executed, if the runnable fails_@return                    The AbstractRunnable instance to pass to the executor;private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {_        return new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                exceptionConsumer.accept(e)__            }__            @Override_            protected void doRun() throws Exception {_                run.run()__            }_        }__    };wraps,an,abstract,runnable,to,easier,supply,on,failure,and,do,run,methods,via,lambdas,this,ensures,that,the,uncaught,exception,handler,in,the,executing,threadpool,does,not,get,called,param,run,the,code,to,be,executed,in,the,runnable,param,exception,consumer,the,exception,handling,code,to,be,executed,if,the,runnable,fails,return,the,abstract,runnable,instance,to,pass,to,the,executor;private,static,abstract,runnable,wrap,watcher,service,runnable,run,consumer,exception,exception,consumer,return,new,abstract,runnable,override,public,void,on,failure,exception,e,exception,consumer,accept,e,override,protected,void,do,run,throws,exception,run,run
WatcherService -> private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer);1535666657;Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas_This ensures that the uncaught exception handler in the executing threadpool does not get called__@param run                 The code to be executed in the runnable_@param exceptionConsumer   The exception handling code to be executed, if the runnable fails_@return                    The AbstractRunnable instance to pass to the executor;private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {_        return new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                exceptionConsumer.accept(e)__            }__            @Override_            protected void doRun() throws Exception {_                run.run()__            }_        }__    };wraps,an,abstract,runnable,to,easier,supply,on,failure,and,do,run,methods,via,lambdas,this,ensures,that,the,uncaught,exception,handler,in,the,executing,threadpool,does,not,get,called,param,run,the,code,to,be,executed,in,the,runnable,param,exception,consumer,the,exception,handling,code,to,be,executed,if,the,runnable,fails,return,the,abstract,runnable,instance,to,pass,to,the,executor;private,static,abstract,runnable,wrap,watcher,service,runnable,run,consumer,exception,exception,consumer,return,new,abstract,runnable,override,public,void,on,failure,exception,e,exception,consumer,accept,e,override,protected,void,do,run,throws,exception,run,run
WatcherService -> private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer);1537806831;Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas_This ensures that the uncaught exception handler in the executing threadpool does not get called__@param run                 The code to be executed in the runnable_@param exceptionConsumer   The exception handling code to be executed, if the runnable fails_@return                    The AbstractRunnable instance to pass to the executor;private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {_        return new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                exceptionConsumer.accept(e)__            }__            @Override_            protected void doRun() throws Exception {_                run.run()__            }_        }__    };wraps,an,abstract,runnable,to,easier,supply,on,failure,and,do,run,methods,via,lambdas,this,ensures,that,the,uncaught,exception,handler,in,the,executing,threadpool,does,not,get,called,param,run,the,code,to,be,executed,in,the,runnable,param,exception,consumer,the,exception,handling,code,to,be,executed,if,the,runnable,fails,return,the,abstract,runnable,instance,to,pass,to,the,executor;private,static,abstract,runnable,wrap,watcher,service,runnable,run,consumer,exception,exception,consumer,return,new,abstract,runnable,override,public,void,on,failure,exception,e,exception,consumer,accept,e,override,protected,void,do,run,throws,exception,run,run
WatcherService -> private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer);1541092382;Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas_This ensures that the uncaught exception handler in the executing threadpool does not get called__@param run                 The code to be executed in the runnable_@param exceptionConsumer   The exception handling code to be executed, if the runnable fails_@return                    The AbstractRunnable instance to pass to the executor;private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {_        return new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                exceptionConsumer.accept(e)__            }__            @Override_            protected void doRun() throws Exception {_                run.run()__            }_        }__    };wraps,an,abstract,runnable,to,easier,supply,on,failure,and,do,run,methods,via,lambdas,this,ensures,that,the,uncaught,exception,handler,in,the,executing,threadpool,does,not,get,called,param,run,the,code,to,be,executed,in,the,runnable,param,exception,consumer,the,exception,handling,code,to,be,executed,if,the,runnable,fails,return,the,abstract,runnable,instance,to,pass,to,the,executor;private,static,abstract,runnable,wrap,watcher,service,runnable,run,consumer,exception,exception,consumer,return,new,abstract,runnable,override,public,void,on,failure,exception,e,exception,consumer,accept,e,override,protected,void,do,run,throws,exception,run,run
WatcherService -> private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer);1543343306;Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas_This ensures that the uncaught exception handler in the executing threadpool does not get called__@param run                 The code to be executed in the runnable_@param exceptionConsumer   The exception handling code to be executed, if the runnable fails_@return                    The AbstractRunnable instance to pass to the executor;private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {_        return new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                exceptionConsumer.accept(e)__            }__            @Override_            protected void doRun() throws Exception {_                run.run()__            }_        }__    };wraps,an,abstract,runnable,to,easier,supply,on,failure,and,do,run,methods,via,lambdas,this,ensures,that,the,uncaught,exception,handler,in,the,executing,threadpool,does,not,get,called,param,run,the,code,to,be,executed,in,the,runnable,param,exception,consumer,the,exception,handling,code,to,be,executed,if,the,runnable,fails,return,the,abstract,runnable,instance,to,pass,to,the,executor;private,static,abstract,runnable,wrap,watcher,service,runnable,run,consumer,exception,exception,consumer,return,new,abstract,runnable,override,public,void,on,failure,exception,e,exception,consumer,accept,e,override,protected,void,do,run,throws,exception,run,run
WatcherService -> private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer);1544035746;Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas_This ensures that the uncaught exception handler in the executing threadpool does not get called__@param run                 The code to be executed in the runnable_@param exceptionConsumer   The exception handling code to be executed, if the runnable fails_@return                    The AbstractRunnable instance to pass to the executor;private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {_        return new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                exceptionConsumer.accept(e)__            }__            @Override_            protected void doRun() throws Exception {_                run.run()__            }_        }__    };wraps,an,abstract,runnable,to,easier,supply,on,failure,and,do,run,methods,via,lambdas,this,ensures,that,the,uncaught,exception,handler,in,the,executing,threadpool,does,not,get,called,param,run,the,code,to,be,executed,in,the,runnable,param,exception,consumer,the,exception,handling,code,to,be,executed,if,the,runnable,fails,return,the,abstract,runnable,instance,to,pass,to,the,executor;private,static,abstract,runnable,wrap,watcher,service,runnable,run,consumer,exception,exception,consumer,return,new,abstract,runnable,override,public,void,on,failure,exception,e,exception,consumer,accept,e,override,protected,void,do,run,throws,exception,run,run
WatcherService -> private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer);1548897299;Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas_This ensures that the uncaught exception handler in the executing threadpool does not get called__@param run                 The code to be executed in the runnable_@param exceptionConsumer   The exception handling code to be executed, if the runnable fails_@return                    The AbstractRunnable instance to pass to the executor;private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {_        return new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                exceptionConsumer.accept(e)__            }__            @Override_            protected void doRun() throws Exception {_                run.run()__            }_        }__    };wraps,an,abstract,runnable,to,easier,supply,on,failure,and,do,run,methods,via,lambdas,this,ensures,that,the,uncaught,exception,handler,in,the,executing,threadpool,does,not,get,called,param,run,the,code,to,be,executed,in,the,runnable,param,exception,consumer,the,exception,handling,code,to,be,executed,if,the,runnable,fails,return,the,abstract,runnable,instance,to,pass,to,the,executor;private,static,abstract,runnable,wrap,watcher,service,runnable,run,consumer,exception,exception,consumer,return,new,abstract,runnable,override,public,void,on,failure,exception,e,exception,consumer,accept,e,override,protected,void,do,run,throws,exception,run,run
WatcherService -> public void start(ClusterState state, Runnable postWatchesLoadedCallback);1525798021;start the watcher service, load watches in the background__@param state                     the current cluster state_@param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully;public void start(ClusterState state, Runnable postWatchesLoadedCallback) {_        executionService.unPause()__        processedClusterStateVersion.set(state.getVersion())__        executor.execute(wrapWatcherService(() -> {_                if (reloadInner(state, "starting", true)) {_                    postWatchesLoadedCallback.run()__                }_            },_            e -> logger.error("error starting watcher", e)))__    };start,the,watcher,service,load,watches,in,the,background,param,state,the,current,cluster,state,param,post,watches,loaded,callback,the,callback,to,be,triggered,when,watches,where,loaded,successfully;public,void,start,cluster,state,state,runnable,post,watches,loaded,callback,execution,service,un,pause,processed,cluster,state,version,set,state,get,version,executor,execute,wrap,watcher,service,if,reload,inner,state,starting,true,post,watches,loaded,callback,run,e,logger,error,error,starting,watcher,e
WatcherService -> public void start(ClusterState state, Runnable postWatchesLoadedCallback);1535666657;start the watcher service, load watches in the background__@param state                     the current cluster state_@param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully;public void start(ClusterState state, Runnable postWatchesLoadedCallback) {_        executionService.unPause()__        processedClusterStateVersion.set(state.getVersion())__        executor.execute(wrapWatcherService(() -> {_                if (reloadInner(state, "starting", true)) {_                    postWatchesLoadedCallback.run()__                }_            },_            e -> logger.error("error starting watcher", e)))__    };start,the,watcher,service,load,watches,in,the,background,param,state,the,current,cluster,state,param,post,watches,loaded,callback,the,callback,to,be,triggered,when,watches,where,loaded,successfully;public,void,start,cluster,state,state,runnable,post,watches,loaded,callback,execution,service,un,pause,processed,cluster,state,version,set,state,get,version,executor,execute,wrap,watcher,service,if,reload,inner,state,starting,true,post,watches,loaded,callback,run,e,logger,error,error,starting,watcher,e
WatcherService -> public void start(ClusterState state, Runnable postWatchesLoadedCallback);1537806831;start the watcher service, load watches in the background__@param state                     the current cluster state_@param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully;public void start(ClusterState state, Runnable postWatchesLoadedCallback) {_        executionService.unPause()__        processedClusterStateVersion.set(state.getVersion())__        executor.execute(wrapWatcherService(() -> {_                if (reloadInner(state, "starting", true)) {_                    postWatchesLoadedCallback.run()__                }_            },_            e -> logger.error("error starting watcher", e)))__    };start,the,watcher,service,load,watches,in,the,background,param,state,the,current,cluster,state,param,post,watches,loaded,callback,the,callback,to,be,triggered,when,watches,where,loaded,successfully;public,void,start,cluster,state,state,runnable,post,watches,loaded,callback,execution,service,un,pause,processed,cluster,state,version,set,state,get,version,executor,execute,wrap,watcher,service,if,reload,inner,state,starting,true,post,watches,loaded,callback,run,e,logger,error,error,starting,watcher,e
WatcherService -> public void start(ClusterState state, Runnable postWatchesLoadedCallback);1541092382;start the watcher service, load watches in the background__@param state                     the current cluster state_@param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully;public void start(ClusterState state, Runnable postWatchesLoadedCallback) {_        executionService.unPause()__        processedClusterStateVersion.set(state.getVersion())__        executor.execute(wrapWatcherService(() -> {_                if (reloadInner(state, "starting", true)) {_                    postWatchesLoadedCallback.run()__                }_            },_            e -> logger.error("error starting watcher", e)))__    };start,the,watcher,service,load,watches,in,the,background,param,state,the,current,cluster,state,param,post,watches,loaded,callback,the,callback,to,be,triggered,when,watches,where,loaded,successfully;public,void,start,cluster,state,state,runnable,post,watches,loaded,callback,execution,service,un,pause,processed,cluster,state,version,set,state,get,version,executor,execute,wrap,watcher,service,if,reload,inner,state,starting,true,post,watches,loaded,callback,run,e,logger,error,error,starting,watcher,e
WatcherService -> public void start(ClusterState state, Runnable postWatchesLoadedCallback);1543343306;start the watcher service, load watches in the background__@param state                     the current cluster state_@param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully;public void start(ClusterState state, Runnable postWatchesLoadedCallback) {_        executionService.unPause()__        processedClusterStateVersion.set(state.getVersion())__        executor.execute(wrapWatcherService(() -> {_                if (reloadInner(state, "starting", true)) {_                    postWatchesLoadedCallback.run()__                }_            },_            e -> logger.error("error starting watcher", e)))__    };start,the,watcher,service,load,watches,in,the,background,param,state,the,current,cluster,state,param,post,watches,loaded,callback,the,callback,to,be,triggered,when,watches,where,loaded,successfully;public,void,start,cluster,state,state,runnable,post,watches,loaded,callback,execution,service,un,pause,processed,cluster,state,version,set,state,get,version,executor,execute,wrap,watcher,service,if,reload,inner,state,starting,true,post,watches,loaded,callback,run,e,logger,error,error,starting,watcher,e
WatcherService -> public void start(ClusterState state, Runnable postWatchesLoadedCallback);1544035746;start the watcher service, load watches in the background__@param state                     the current cluster state_@param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully;public void start(ClusterState state, Runnable postWatchesLoadedCallback) {_        executionService.unPause()__        processedClusterStateVersion.set(state.getVersion())__        executor.execute(wrapWatcherService(() -> {_                if (reloadInner(state, "starting", true)) {_                    postWatchesLoadedCallback.run()__                }_            },_            e -> logger.error("error starting watcher", e)))__    };start,the,watcher,service,load,watches,in,the,background,param,state,the,current,cluster,state,param,post,watches,loaded,callback,the,callback,to,be,triggered,when,watches,where,loaded,successfully;public,void,start,cluster,state,state,runnable,post,watches,loaded,callback,execution,service,un,pause,processed,cluster,state,version,set,state,get,version,executor,execute,wrap,watcher,service,if,reload,inner,state,starting,true,post,watches,loaded,callback,run,e,logger,error,error,starting,watcher,e
WatcherService -> public void start(ClusterState state, Runnable postWatchesLoadedCallback);1548897299;start the watcher service, load watches in the background__@param state                     the current cluster state_@param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully;public void start(ClusterState state, Runnable postWatchesLoadedCallback) {_        executionService.unPause()__        processedClusterStateVersion.set(state.getVersion())__        executor.execute(wrapWatcherService(() -> {_                if (reloadInner(state, "starting", true)) {_                    postWatchesLoadedCallback.run()__                }_            },_            e -> logger.error("error starting watcher", e)))__    };start,the,watcher,service,load,watches,in,the,background,param,state,the,current,cluster,state,param,post,watches,loaded,callback,the,callback,to,be,triggered,when,watches,where,loaded,successfully;public,void,start,cluster,state,state,runnable,post,watches,loaded,callback,execution,service,un,pause,processed,cluster,state,version,set,state,get,version,executor,execute,wrap,watcher,service,if,reload,inner,state,starting,true,post,watches,loaded,callback,run,e,logger,error,error,starting,watcher,e
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1524684173;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                    .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                    .scroll(scrollTimeout)_                    .preference(Preference.ONLY_LOCAL.toString())_                    .source(new SearchSourceBuilder()_                            .size(scrollSize)_                            .sort(SortBuilders.fieldSort("_doc"))_                            .version(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits() == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                        .filter(sr -> localShardRouting.getId() == sr.getId())_                        .map(ShardRouting::allocationId).filter(Objects::nonNull)_                        .map(AllocationId::getId).filter(Objects::nonNull)_                        .sorted()_                        .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                            .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                            .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON)__                        watch.version(hit.getVersion())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((Supplier<?>) () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_                    ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                    clearScrollRequest.addScrollId(response.getScrollId())__                    client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__                }_            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,version,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,watch,version,hit,get,version,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1525334055;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                .scroll(scrollTimeout)_                .preference(Preference.ONLY_LOCAL.toString())_                .source(new SearchSourceBuilder()_                    .size(scrollSize)_                    .sort(SortBuilders.fieldSort("_doc"))_                    .version(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits() == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                    .filter(sr -> localShardRouting.getId() == sr.getId())_                    .map(ShardRouting::allocationId).filter(Objects::nonNull)_                    .map(AllocationId::getId).filter(Objects::nonNull)_                    .sorted()_                    .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                        .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                        .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON)__                        watch.version(hit.getVersion())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((org.apache.logging.log4j.util.Supplier<?>)_                            () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_                    ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                    clearScrollRequest.addScrollId(response.getScrollId())__                    client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__                }_            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,version,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,watch,version,hit,get,version,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,org,apache,logging,log4j,util,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1525645056;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                .scroll(scrollTimeout)_                .preference(Preference.ONLY_LOCAL.toString())_                .source(new SearchSourceBuilder()_                    .size(scrollSize)_                    .sort(SortBuilders.fieldSort("_doc"))_                    .version(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits() == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                    .filter(sr -> localShardRouting.getId() == sr.getId())_                    .map(ShardRouting::allocationId).filter(Objects::nonNull)_                    .map(AllocationId::getId).filter(Objects::nonNull)_                    .sorted()_                    .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                        .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                        .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON)__                        watch.version(hit.getVersion())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((org.apache.logging.log4j.util.Supplier<?>)_                            () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_                    ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                    clearScrollRequest.addScrollId(response.getScrollId())__                    client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__                }_            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,version,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,watch,version,hit,get,version,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,org,apache,logging,log4j,util,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1525798021;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                .scroll(scrollTimeout)_                .preference(Preference.ONLY_LOCAL.toString())_                .source(new SearchSourceBuilder()_                    .size(scrollSize)_                    .sort(SortBuilders.fieldSort("_doc"))_                    .version(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits() == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                    .filter(sr -> localShardRouting.getId() == sr.getId())_                    .map(ShardRouting::allocationId).filter(Objects::nonNull)_                    .map(AllocationId::getId).filter(Objects::nonNull)_                    .sorted()_                    .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                        .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                        .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON)__                        watch.version(hit.getVersion())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((org.apache.logging.log4j.util.Supplier<?>)_                            () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_                    ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                    clearScrollRequest.addScrollId(response.getScrollId())__                    client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__                }_            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,version,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,watch,version,hit,get,version,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,org,apache,logging,log4j,util,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1535666657;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                .scroll(scrollTimeout)_                .preference(Preference.ONLY_LOCAL.toString())_                .source(new SearchSourceBuilder()_                    .size(scrollSize)_                    .sort(SortBuilders.fieldSort("_doc"))_                    .version(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits() == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                    .filter(sr -> localShardRouting.getId() == sr.getId())_                    .map(ShardRouting::allocationId).filter(Objects::nonNull)_                    .map(AllocationId::getId).filter(Objects::nonNull)_                    .sorted()_                    .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                        .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                        .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON)__                        watch.version(hit.getVersion())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((org.apache.logging.log4j.util.Supplier<?>)_                            () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_                    ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                    clearScrollRequest.addScrollId(response.getScrollId())__                    client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__                }_            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,version,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,watch,version,hit,get,version,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,org,apache,logging,log4j,util,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1537806831;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                .scroll(scrollTimeout)_                .preference(Preference.ONLY_LOCAL.toString())_                .source(new SearchSourceBuilder()_                    .size(scrollSize)_                    .sort(SortBuilders.fieldSort("_doc"))_                    .version(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits() == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                    .filter(sr -> localShardRouting.getId() == sr.getId())_                    .map(ShardRouting::allocationId).filter(Objects::nonNull)_                    .map(AllocationId::getId).filter(Objects::nonNull)_                    .sorted()_                    .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                        .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                        .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON)__                        watch.version(hit.getVersion())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((org.apache.logging.log4j.util.Supplier<?>)_                            () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                clearScrollRequest.addScrollId(response.getScrollId())__                client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,version,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,watch,version,hit,get,version,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,org,apache,logging,log4j,util,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1541092382;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                .scroll(scrollTimeout)_                .preference(Preference.ONLY_LOCAL.toString())_                .source(new SearchSourceBuilder()_                    .size(scrollSize)_                    .sort(SortBuilders.fieldSort("_doc"))_                    .version(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits() == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                    .filter(sr -> localShardRouting.getId() == sr.getId())_                    .map(ShardRouting::allocationId).filter(Objects::nonNull)_                    .map(AllocationId::getId).filter(Objects::nonNull)_                    .sorted()_                    .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                        .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                        .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON)__                        watch.version(hit.getVersion())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((org.apache.logging.log4j.util.Supplier<?>)_                            () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                clearScrollRequest.addScrollId(response.getScrollId())__                client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,version,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,watch,version,hit,get,version,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,org,apache,logging,log4j,util,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1543343306;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                .scroll(scrollTimeout)_                .preference(Preference.ONLY_LOCAL.toString())_                .source(new SearchSourceBuilder()_                    .size(scrollSize)_                    .sort(SortBuilders.fieldSort("_doc"))_                    .version(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits() == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                    .filter(sr -> localShardRouting.getId() == sr.getId())_                    .map(ShardRouting::allocationId).filter(Objects::nonNull)_                    .map(AllocationId::getId).filter(Objects::nonNull)_                    .sorted()_                    .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                        .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                        .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON)__                        watch.version(hit.getVersion())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((org.apache.logging.log4j.util.Supplier<?>)_                            () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                clearScrollRequest.addScrollId(response.getScrollId())__                client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,version,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,watch,version,hit,get,version,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,org,apache,logging,log4j,util,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1544035746;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                .scroll(scrollTimeout)_                .preference(Preference.ONLY_LOCAL.toString())_                .source(new SearchSourceBuilder()_                    .size(scrollSize)_                    .sort(SortBuilders.fieldSort("_doc"))_                    .version(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits().value == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                    .filter(sr -> localShardRouting.getId() == sr.getId())_                    .map(ShardRouting::allocationId).filter(Objects::nonNull)_                    .map(AllocationId::getId).filter(Objects::nonNull)_                    .sorted()_                    .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                        .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                        .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON)__                        watch.version(hit.getVersion())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((org.apache.logging.log4j.util.Supplier<?>)_                            () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                clearScrollRequest.addScrollId(response.getScrollId())__                client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,version,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,value,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,watch,version,hit,get,version,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,org,apache,logging,log4j,util,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
WatcherService -> private Collection<Watch> loadWatches(ClusterState clusterState);1548897299;This reads all watches from the .watches index/alias and puts them into memory for a short period of time,_before they are fed into the trigger service.;private Collection<Watch> loadWatches(ClusterState clusterState) {_        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData())__        _        if (indexMetaData == null) {_            return Collections.emptyList()__        }__        SearchResponse response = null__        List<Watch> watches = new ArrayList<>()__        try {_            RefreshResponse refreshResponse = client.admin().indices().refresh(new RefreshRequest(INDEX))_                .actionGet(TimeValue.timeValueSeconds(5))__            if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {_                throw illegalState("not all required shards have been refreshed")__            }__            _            String watchIndexName = indexMetaData.getIndex().getName()__            RoutingNode routingNode = clusterState.getRoutingNodes().node(clusterState.nodes().getLocalNodeId())__            _            if (routingNode == null) {_                return Collections.emptyList()__            }_            List<ShardRouting> localShards = routingNode.shardsWithState(watchIndexName, RELOCATING, STARTED)___            _            List<ShardRouting> watchIndexShardRoutings = clusterState.getRoutingTable().allShards(watchIndexName)___            SearchRequest searchRequest = new SearchRequest(INDEX)_                .scroll(scrollTimeout)_                .preference(Preference.ONLY_LOCAL.toString())_                .source(new SearchSourceBuilder()_                    .size(scrollSize)_                    .sort(SortBuilders.fieldSort("_doc"))_                    .seqNoAndPrimaryTerm(true))__            response = client.search(searchRequest).actionGet(defaultSearchTimeout)___            if (response.getTotalShards() != response.getSuccessfulShards()) {_                throw new ElasticsearchException("Partial response while loading watches")__            }__            if (response.getHits().getTotalHits().value == 0) {_                return Collections.emptyList()__            }__            Map<Integer, List<String>> sortedShards = new HashMap<>(localShards.size())__            for (ShardRouting localShardRouting : localShards) {_                List<String> sortedAllocationIds = watchIndexShardRoutings.stream()_                    .filter(sr -> localShardRouting.getId() == sr.getId())_                    .map(ShardRouting::allocationId).filter(Objects::nonNull)_                    .map(AllocationId::getId).filter(Objects::nonNull)_                    .sorted()_                    .collect(Collectors.toList())___                sortedShards.put(localShardRouting.getId(), sortedAllocationIds)__            }__            while (response.getHits().getHits().length != 0) {_                for (SearchHit hit : response.getHits()) {_                    _                    Optional<ShardRouting> correspondingShardOptional = localShards.stream()_                        .filter(sr -> sr.shardId().equals(hit.getShard().getShardId()))_                        .findFirst()__                    if (correspondingShardOptional.isPresent() == false) {_                        continue__                    }_                    ShardRouting correspondingShard = correspondingShardOptional.get()__                    List<String> shardAllocationIds = sortedShards.get(hit.getShard().getShardId().id())__                    _                    int bucket = shardAllocationIds.indexOf(correspondingShard.allocationId().getId())__                    String id = hit.getId()___                    if (parseWatchOnThisNode(hit.getId(), shardAllocationIds.size(), bucket) == false) {_                        continue__                    }__                    try {_                        Watch watch = parser.parse(id, true, hit.getSourceRef(), XContentType.JSON, hit.getSeqNo(), hit.getPrimaryTerm())__                        if (watch.status().state().isActive()) {_                            watches.add(watch)__                        }_                    } catch (Exception e) {_                        logger.error((org.apache.logging.log4j.util.Supplier<?>)_                            () -> new ParameterizedMessage("couldn't load watch [{}], ignoring it...", id), e)__                    }_                }_                SearchScrollRequest request = new SearchScrollRequest(response.getScrollId())__                request.scroll(scrollTimeout)__                response = client.searchScroll(request).actionGet(defaultSearchTimeout)__            }_        } finally {_            if (response != null) {_                ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                clearScrollRequest.addScrollId(response.getScrollId())__                client.clearScroll(clearScrollRequest).actionGet(scrollTimeout)__            }_        }__        logger.debug("Loaded [{}] watches for execution", watches.size())___        return watches__    };this,reads,all,watches,from,the,watches,index,alias,and,puts,them,into,memory,for,a,short,period,of,time,before,they,are,fed,into,the,trigger,service;private,collection,watch,load,watches,cluster,state,cluster,state,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,index,cluster,state,meta,data,if,index,meta,data,null,return,collections,empty,list,search,response,response,null,list,watch,watches,new,array,list,try,refresh,response,refresh,response,client,admin,indices,refresh,new,refresh,request,index,action,get,time,value,time,value,seconds,5,if,refresh,response,get,successful,shards,index,meta,data,get,number,of,shards,throw,illegal,state,not,all,required,shards,have,been,refreshed,string,watch,index,name,index,meta,data,get,index,get,name,routing,node,routing,node,cluster,state,get,routing,nodes,node,cluster,state,nodes,get,local,node,id,if,routing,node,null,return,collections,empty,list,list,shard,routing,local,shards,routing,node,shards,with,state,watch,index,name,relocating,started,list,shard,routing,watch,index,shard,routings,cluster,state,get,routing,table,all,shards,watch,index,name,search,request,search,request,new,search,request,index,scroll,scroll,timeout,preference,preference,to,string,source,new,search,source,builder,size,scroll,size,sort,sort,builders,field,sort,seq,no,and,primary,term,true,response,client,search,search,request,action,get,default,search,timeout,if,response,get,total,shards,response,get,successful,shards,throw,new,elasticsearch,exception,partial,response,while,loading,watches,if,response,get,hits,get,total,hits,value,0,return,collections,empty,list,map,integer,list,string,sorted,shards,new,hash,map,local,shards,size,for,shard,routing,local,shard,routing,local,shards,list,string,sorted,allocation,ids,watch,index,shard,routings,stream,filter,sr,local,shard,routing,get,id,sr,get,id,map,shard,routing,allocation,id,filter,objects,non,null,map,allocation,id,get,id,filter,objects,non,null,sorted,collect,collectors,to,list,sorted,shards,put,local,shard,routing,get,id,sorted,allocation,ids,while,response,get,hits,get,hits,length,0,for,search,hit,hit,response,get,hits,optional,shard,routing,corresponding,shard,optional,local,shards,stream,filter,sr,sr,shard,id,equals,hit,get,shard,get,shard,id,find,first,if,corresponding,shard,optional,is,present,false,continue,shard,routing,corresponding,shard,corresponding,shard,optional,get,list,string,shard,allocation,ids,sorted,shards,get,hit,get,shard,get,shard,id,id,int,bucket,shard,allocation,ids,index,of,corresponding,shard,allocation,id,get,id,string,id,hit,get,id,if,parse,watch,on,this,node,hit,get,id,shard,allocation,ids,size,bucket,false,continue,try,watch,watch,parser,parse,id,true,hit,get,source,ref,xcontent,type,json,hit,get,seq,no,hit,get,primary,term,if,watch,status,state,is,active,watches,add,watch,catch,exception,e,logger,error,org,apache,logging,log4j,util,supplier,new,parameterized,message,couldn,t,load,watch,ignoring,it,id,e,search,scroll,request,request,new,search,scroll,request,response,get,scroll,id,request,scroll,scroll,timeout,response,client,search,scroll,request,action,get,default,search,timeout,finally,if,response,null,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,get,scroll,timeout,logger,debug,loaded,watches,for,execution,watches,size,return,watches
