commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;70;;@Override protected void doExecute(AckWatchRequest request, ActionListener<AckWatchResponse> listener) {     WatcherStatsRequest watcherStatsRequest = new WatcherStatsRequest().     watcherStatsRequest.includeCurrentWatches(true).     executeAsyncWithOrigin(client, WATCHER_ORIGIN, WatcherStatsAction.INSTANCE, watcherStatsRequest, ActionListener.wrap(response -> {         boolean isWatchRunning = response.getNodes().stream().anyMatch(node -> node.getSnapshots().stream().anyMatch(snapshot -> snapshot.watchId().equals(request.getWatchId()))).         if (isWatchRunning) {             listener.onFailure(new ElasticsearchStatusException("watch[{}] is running currently, cannot ack until finished", RestStatus.CONFLICT, request.getWatchId())).         } else {             GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, request.getWatchId()).preference(Preference.LOCAL.type()).realtime(true).             executeAsyncWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(getResponse -> {                 if (getResponse.isExists() == false) {                     listener.onFailure(new ResourceNotFoundException("Watch with id [{}] does not exist", request.getWatchId())).                 } else {                     ZonedDateTime now = clock.instant().atZone(ZoneOffset.UTC).                     Watch watch = parser.parseWithSecrets(request.getWatchId(), true, getResponse.getSourceAsBytesRef(), now, XContentType.JSON, getResponse.getSeqNo(), getResponse.getPrimaryTerm()).                     watch.status().version(getResponse.getVersion()).                     String[] actionIds = request.getActionIds().                     if (actionIds == null || actionIds.length == 0) {                         actionIds = new String[] { WatchField.ALL_ACTIONS_ID }.                     }                     // exit early in case nothing changes                     boolean isChanged = watch.ack(now, actionIds).                     if (isChanged == false) {                         listener.onResponse(new AckWatchResponse(watch.status())).                         return.                     }                     UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, request.getWatchId()).                     // this may reject this action, but prevents concurrent updates from a watch execution                     updateRequest.setIfSeqNo(getResponse.getSeqNo()).                     updateRequest.setIfPrimaryTerm(getResponse.getPrimaryTerm()).                     updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).                     XContentBuilder builder = jsonBuilder().                     builder.startObject().startObject(WatchField.STATUS.getPreferredName()).startObject("actions").                     List<String> actionIdsAsList = Arrays.asList(actionIds).                     boolean updateAll = actionIdsAsList.contains("_all").                     for (ActionWrapper actionWrapper : watch.actions()) {                         if (updateAll || actionIdsAsList.contains(actionWrapper.id())) {                             builder.startObject(actionWrapper.id()).field("ack", watch.status().actionStatus(actionWrapper.id()).ackStatus(), ToXContent.EMPTY_PARAMS).endObject().                         }                     }                     builder.endObject().endObject().endObject().                     updateRequest.doc(builder).                     executeAsyncWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN, updateRequest, ActionListener.<UpdateResponse>wrap((updateResponse) -> listener.onResponse(new AckWatchResponse(watch.status())), listener::onFailure), client::update).                 }             }, listener::onFailure), client::get).         }     }, listener::onFailure)). }
