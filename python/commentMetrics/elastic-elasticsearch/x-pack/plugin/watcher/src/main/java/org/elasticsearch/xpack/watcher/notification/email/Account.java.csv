commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;1;// exists only to allow ensuring class is initialized ;// exists only to allow ensuring class is initialized public static void init() { }
false;public;0;3;;public String name() {     return config.name. }
false;;0;3;;Config getConfig() {     return config. }
false;public;3;69;;public Email send(Email email, Authentication auth, Profile profile) throws MessagingException {     // applying the defaults on missing emails fields     email = config.defaults.apply(email).     if (email.to == null) {         throw new SettingsException("missing required email [to] field").     }     Transport transport = session.getTransport(SMTP_PROTOCOL).     String user = auth != null ? auth.user() : config.smtp.user.     if (user == null) {         InternetAddress localAddress = InternetAddress.getLocalAddress(session).         // this can happen in wrongly setup linux distributions         if (localAddress != null) {             user = localAddress.getAddress().         }     }     String password = null.     if (auth != null && auth.password() != null) {         password = new String(auth.password().text(cryptoService)).     } else if (config.smtp.password != null) {         password = new String(config.smtp.password.getChars()).     }     if (profile == null) {         profile = config.profile.     }     executeConnect(transport, user, password).     ClassLoader contextClassLoader = null.     try {         MimeMessage message = profile.toMimeMessage(email, session).         String mid = message.getMessageID().         message.saveChanges().         if (mid != null) {             // saveChanges may rewrite/remove the message id, so             // we need to add it back             message.setHeader(Profile.MESSAGE_ID_HEADER, mid).         }         SecurityManager sm = System.getSecurityManager().         if (sm != null) {             // unprivileged code such as scripts do not have SpecialPermission             sm.checkPermission(new SpecialPermission()).         }         contextClassLoader = AccessController.doPrivileged((PrivilegedAction<ClassLoader>) () -> Thread.currentThread().getContextClassLoader()).         // change it back         if (contextClassLoader != null) {             setContextClassLoader(this.getClass().getClassLoader()).         }         transport.sendMessage(message, message.getAllRecipients()).     } finally {         try {             transport.close().         } catch (MessagingException me) {             logger.error("failed to close email transport for account [{}]", config.name).         }         if (contextClassLoader != null) {             setContextClassLoader(contextClassLoader).         }     }     return email. }
false;private;3;11;;private void executeConnect(Transport transport, String user, String password) throws MessagingException {     SpecialPermission.check().     try {         AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {             transport.connect(config.smtp.host, config.smtp.port, user, password).             return null.         }).     } catch (PrivilegedActionException e) {         throw (MessagingException) e.getCause().     } }
false;private;1;11;;private void setContextClassLoader(final ClassLoader classLoader) {     SecurityManager sm = System.getSecurityManager().     if (sm != null) {         // unprivileged code such as scripts do not have SpecialPermission         sm.checkPermission(new SpecialPermission()).     }     AccessController.doPrivileged((PrivilegedAction<Void>) () -> {         Thread.currentThread().setContextClassLoader(classLoader).         return null.     }). }
false;public;0;3;;public Session createSession() {     return Session.getInstance(smtp.properties). }
true;private,static;2;8;/**  * Finds a setting, and then a secure setting if the setting is null, or returns null if one does not exist. This differs  * from other getSetting calls in that it allows for null whereas the other methods throw an exception.  *  * Note: if your setting was not previously secure, than the string reference that is in the setting object is still  * insecure. This is only constructing a new SecureString with the char[] of the insecure setting.  */ ;/**  * Finds a setting, and then a secure setting if the setting is null, or returns null if one does not exist. This differs  * from other getSetting calls in that it allows for null whereas the other methods throw an exception.  *  * Note: if your setting was not previously secure, than the string reference that is in the setting object is still  * insecure. This is only constructing a new SecureString with the char[] of the insecure setting.  */ private static SecureString getSecureSetting(Settings settings, Setting<SecureString> secureSetting) {     SecureString secureString = secureSetting.get(settings).     if (secureString != null && secureString.length() > 0) {         return secureString.     } else {         return null.     } }
true;static;1;20;/**  * loads the standard Java Mail properties as settings from the given account settings.  * The standard settings are not that readable, therefore we enabled the user to configure  * those in a readable way... this method first loads the smtp settings (which corresponds to  * all Java Mail {@code mail.smtp.*} settings), and then replaces the readable keys to the official  * "unreadable" keys. We'll then use these settings when crea  */ ;/**  * loads the standard Java Mail properties as settings from the given account settings.  * The standard settings are not that readable, therefore we enabled the user to configure  * those in a readable way... this method first loads the smtp settings (which corresponds to  * all Java Mail {@code mail.smtp.*} settings), and then replaces the readable keys to the official  * "unreadable" keys. We'll then use these settings when crea  */ static Properties loadSmtpProperties(Settings settings) {     Settings.Builder builder = Settings.builder().put(DEFAULT_SMTP_TIMEOUT_SETTINGS).put(settings).     replaceTimeValue(builder, "connection_timeout", "connectiontimeout").     replaceTimeValue(builder, "write_timeout", "writetimeout").     replaceTimeValue(builder, "timeout", "timeout").     replace(builder, "local_address", "localaddress").     replace(builder, "local_port", "localport").     replace(builder, "send_partial", "sendpartial").     replace(builder, "wait_on_quit", "quitwait").     settings = builder.build().     Properties props = new Properties().     // Secure strings can not be retreived out of a settings object and should be handled differently     Set<String> insecureSettings = settings.filter(s -> s.startsWith("secure_") == false).keySet().     for (String key : insecureSettings) {         props.setProperty(SMTP_SETTINGS_PREFIX + key, settings.get(key)).     }     return props. }
false;static;3;6;;static void replace(Settings.Builder settings, String currentKey, String newKey) {     String value = settings.remove(currentKey).     if (value != null) {         settings.put(newKey, value).     } }
false;static;3;6;;static void replaceTimeValue(Settings.Builder settings, String currentKey, String newKey) {     String value = settings.remove(currentKey).     if (value != null) {         settings.put(newKey, TimeValue.parseTimeValue(value, currentKey).millis()).     } }
false;;1;25;;Email apply(Email email) {     Email.Builder builder = Email.builder().copyFrom(email).     if (email.from == null) {         builder.from(from).     }     if (email.replyTo == null) {         builder.replyTo(replyTo).     }     if (email.priority == null) {         builder.priority(priority).     }     if (email.to == null) {         builder.to(to).     }     if (email.cc == null) {         builder.cc(cc).     }     if (email.bcc == null) {         builder.bcc(bcc).     }     if (email.subject == null) {         builder.subject(subject).     }     return builder.build(). }
false;public;1;17;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     EmailDefaults that = (EmailDefaults) o.     if (bcc != null ? !bcc.equals(that.bcc) : that.bcc != null)         return false.     if (cc != null ? !cc.equals(that.cc) : that.cc != null)         return false.     if (from != null ? !from.equals(that.from) : that.from != null)         return false.     if (priority != that.priority)         return false.     if (replyTo != null ? !replyTo.equals(that.replyTo) : that.replyTo != null)         return false.     if (subject != null ? !subject.equals(that.subject) : that.subject != null)         return false.     if (to != null ? !to.equals(that.to) : that.to != null)         return false.     return true. }
false;public;0;11;;@Override public int hashCode() {     int result = from != null ? from.hashCode() : 0.     result = 31 * result + (replyTo != null ? replyTo.hashCode() : 0).     result = 31 * result + (priority != null ? priority.hashCode() : 0).     result = 31 * result + (to != null ? to.hashCode() : 0).     result = 31 * result + (cc != null ? cc.hashCode() : 0).     result = 31 * result + (bcc != null ? bcc.hashCode() : 0).     result = 31 * result + (subject != null ? subject.hashCode() : 0).     return result. }
