commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String id() {     return id. }
false;public;0;3;;public Address from() {     return from. }
false;public;0;3;;public AddressList replyTo() {     return replyTo. }
false;public;0;3;;public Priority priority() {     return priority. }
false;public;0;3;;public ZonedDateTime sentDate() {     return sentDate. }
false;public;0;3;;public AddressList to() {     return to. }
false;public;0;3;;public AddressList cc() {     return cc. }
false;public;0;3;;public AddressList bcc() {     return bcc. }
false;public;0;3;;public String subject() {     return subject. }
false;public;0;3;;public String textBody() {     return textBody. }
false;public;0;3;;public String htmlBody() {     return htmlBody. }
false;public;0;3;;public Map<String, Attachment> attachments() {     return attachments. }
false;public;2;36;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(Field.ID.getPreferredName(), id).     if (from != null) {         builder.field(Field.FROM.getPreferredName(), from.toUnicodeString()).     }     if (replyTo != null) {         builder.field(Field.REPLY_TO.getPreferredName(), replyTo, params).     }     if (priority != null) {         builder.field(Field.PRIORITY.getPreferredName(), priority.value()).     }     builder.timeField(Field.SENT_DATE.getPreferredName(), sentDate).     if (to != null) {         builder.field(Field.TO.getPreferredName(), to, params).     }     if (cc != null) {         builder.field(Field.CC.getPreferredName(), cc, params).     }     if (bcc != null) {         builder.field(Field.BCC.getPreferredName(), bcc, params).     }     builder.field(Field.SUBJECT.getPreferredName(), subject).     if (textBody != null || htmlBody != null) {         builder.startObject(Field.BODY.getPreferredName()).         if (textBody != null) {             builder.field(Field.BODY_TEXT.getPreferredName(), textBody).         }         if (htmlBody != null) {             builder.field(Field.BODY_HTML.getPreferredName(), htmlBody).         }         builder.endObject().     }     return builder.endObject(). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Email email = (Email) o.     if (!id.equals(email.id))         return false.     return true. }
false;public;0;4;;@Override public int hashCode() {     return id.hashCode(). }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public,static;1;54;;public static Email parse(XContentParser parser) throws IOException {     Builder email = new Builder().     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if ((token.isValue() || token == XContentParser.Token.START_OBJECT || token == XContentParser.Token.START_ARRAY) && currentFieldName != null) {             if (Field.ID.match(currentFieldName, parser.getDeprecationHandler())) {                 email.id(parser.text()).             } else if (Field.FROM.match(currentFieldName, parser.getDeprecationHandler())) {                 email.from(Address.parse(currentFieldName, token, parser)).             } else if (Field.REPLY_TO.match(currentFieldName, parser.getDeprecationHandler())) {                 email.replyTo(AddressList.parse(currentFieldName, token, parser)).             } else if (Field.TO.match(currentFieldName, parser.getDeprecationHandler())) {                 email.to(AddressList.parse(currentFieldName, token, parser)).             } else if (Field.CC.match(currentFieldName, parser.getDeprecationHandler())) {                 email.cc(AddressList.parse(currentFieldName, token, parser)).             } else if (Field.BCC.match(currentFieldName, parser.getDeprecationHandler())) {                 email.bcc(AddressList.parse(currentFieldName, token, parser)).             } else if (Field.PRIORITY.match(currentFieldName, parser.getDeprecationHandler())) {                 email.priority(Email.Priority.resolve(parser.text())).             } else if (Field.SENT_DATE.match(currentFieldName, parser.getDeprecationHandler())) {                 email.sentDate(DateFormatters.from(DATE_TIME_FORMATTER.parse(parser.text()))).             } else if (Field.SUBJECT.match(currentFieldName, parser.getDeprecationHandler())) {                 email.subject(parser.text()).             } else if (Field.BODY.match(currentFieldName, parser.getDeprecationHandler())) {                 String bodyField = currentFieldName.                 if (parser.currentToken() == XContentParser.Token.VALUE_STRING) {                     email.textBody(parser.text()).                 } else if (parser.currentToken() == XContentParser.Token.START_OBJECT) {                     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                         if (token == XContentParser.Token.FIELD_NAME) {                             currentFieldName = parser.currentName().                         } else if (currentFieldName == null) {                             throw new ElasticsearchParseException("could not parse email. empty [{}] field", bodyField).                         } else if (Email.Field.BODY_TEXT.match(currentFieldName, parser.getDeprecationHandler())) {                             email.textBody(parser.text()).                         } else if (Email.Field.BODY_HTML.match(currentFieldName, parser.getDeprecationHandler())) {                             email.htmlBody(parser.text()).                         } else {                             throw new ElasticsearchParseException("could not parse email. unexpected field [{}.{}] field", bodyField, currentFieldName).                         }                     }                 }             } else {                 throw new ElasticsearchParseException("could not parse email. unexpected field [{}]", currentFieldName).             }         }     }     return email.build(). }
false;public;1;15;;public Builder copyFrom(Email email) {     id = email.id.     from = email.from.     replyTo = email.replyTo.     priority = email.priority.     sentDate = email.sentDate.     to = email.to.     cc = email.cc.     bcc = email.bcc.     subject = email.subject.     textBody = email.textBody.     htmlBody = email.htmlBody.     attachments.putAll(email.attachments).     return this. }
false;public;1;4;;public Builder id(String id) {     this.id = id.     return this. }
false;public;1;3;;public Builder from(String address) throws AddressException {     return from(new Address(address)). }
false;public;1;4;;public Builder from(Address from) {     this.from = from.     return this. }
false;public;1;4;;public Builder replyTo(AddressList replyTo) {     this.replyTo = replyTo.     return this. }
false;public;1;3;;public Builder replyTo(String addresses) throws AddressException {     return replyTo(Email.AddressList.parse(addresses)). }
false;public;1;4;;public Builder priority(Priority priority) {     this.priority = priority.     return this. }
false;public;1;4;;public Builder sentDate(ZonedDateTime sentDate) {     this.sentDate = sentDate.     return this. }
false;public;1;3;;public Builder to(String addresses) throws AddressException {     return to(AddressList.parse(addresses)). }
false;public;1;4;;public Builder to(AddressList to) {     this.to = to.     return this. }
false;public;0;3;;public AddressList to() {     return to. }
false;public;1;3;;public Builder cc(String addresses) throws AddressException {     return cc(AddressList.parse(addresses)). }
false;public;1;4;;public Builder cc(AddressList cc) {     this.cc = cc.     return this. }
false;public;1;3;;public Builder bcc(String addresses) throws AddressException {     return bcc(AddressList.parse(addresses)). }
false;public;1;4;;public Builder bcc(AddressList bcc) {     this.bcc = bcc.     return this. }
false;public;1;4;;public Builder subject(String subject) {     this.subject = subject.     return this. }
false;public;1;4;;public Builder textBody(String text) {     this.textBody = text.     return this. }
false;public;1;4;;public Builder htmlBody(String html) {     this.htmlBody = html.     return this. }
false;public;1;7;;public Builder attach(Attachment attachment) {     if (attachments == null) {         throw new IllegalStateException("Email has already been built!").     }     attachments.put(attachment.id(), attachment).     return this. }
true;public;0;7;/**  * Build the email. Note that adding items to attachments or inlines  * after this is called is incorrect.  */ ;/**  * Build the email. Note that adding items to attachments or inlines  * after this is called is incorrect.  */ public Email build() {     assert id != null : "email id should not be null".     Email email = new Email(id, from, replyTo, priority, sentDate, to, cc, bcc, subject, textBody, htmlBody, unmodifiableMap(attachments)).     attachments = null.     return email. }
false;public;1;3;;public void applyTo(MimeMessage message) throws MessagingException {     message.setHeader(HEADER, String.valueOf(value)). }
false;public;0;3;;public String value() {     return name().toLowerCase(Locale.ROOT). }
false;public,static;1;7;;public static Priority resolve(String name) {     Priority priority = resolve(name, null).     if (priority == null) {         throw new IllegalArgumentException("[" + name + "] is not a valid email priority").     }     return priority. }
false;public,static;2;14;;public static Priority resolve(String name, Priority defaultPriority) {     if (name == null) {         return defaultPriority.     }     switch(name.toLowerCase(Locale.ROOT)) {         case "highest":             return HIGHEST.         case "high":             return HIGH.         case "normal":             return NORMAL.         case "low":             return LOW.         case "lowest":             return LOWEST.         default:             return defaultPriority.     } }
false;public,static;2;7;;public static Priority parse(Settings settings, String name) {     String value = settings.get(name).     if (value == null) {         return null.     }     return resolve(value). }
false;public,static;3;43;;public static Address parse(String field, XContentParser.Token token, XContentParser parser) throws IOException {     if (token == XContentParser.Token.VALUE_STRING) {         String text = parser.text().         try {             return new Email.Address(parser.text()).         } catch (AddressException ae) {             String msg = "could not parse [" + text + "] in field [" + field + "] as address. address must be RFC822 encoded".             throw new ElasticsearchParseException(msg, ae).         }     }     if (token == XContentParser.Token.START_OBJECT) {         String email = null.         String name = null.         String currentFieldName = null.         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 currentFieldName = parser.currentName().             } else if (token == XContentParser.Token.VALUE_STRING) {                 if (ADDRESS_EMAIL_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                     email = parser.text().                 } else if (ADDRESS_NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                     name = parser.text().                 } else {                     throw new ElasticsearchParseException("could not parse [" + field + "] object as address. unknown address " + "field [" + currentFieldName + "]").                 }             }         }         if (email == null) {             String msg = "could not parse [" + field + "] as address. address object must define an [email] field".             throw new ElasticsearchParseException(msg).         }         try {             return name != null ? new Email.Address(email, name) : new Email.Address(email).         } catch (AddressException ae) {             throw new ElasticsearchParseException("could not parse [" + field + "] as address", ae).         }     }     throw new ElasticsearchParseException("could not parse [{}] as address. address must either be a string (RFC822 encoded) or " + "an object specifying the address [name] and [email]", field). }
false;public,static;2;8;;public static Address parse(Settings settings, String name) {     String value = settings.get(name).     try {         return value != null ? new Address(value) : null.     } catch (AddressException ae) {         throw new IllegalArgumentException("[" + value + "] is not a valid RFC822 email address", ae).     } }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.value(toString()). }
false;public;0;3;;public boolean isEmpty() {     return addresses.isEmpty(). }
false;public;0;4;;@Override public Iterator<Address> iterator() {     return addresses.iterator(). }
false;public;0;3;;public Address[] toArray() {     return addresses.toArray(new Address[addresses.size()]). }
false;public;0;3;;public int size() {     return addresses.size(). }
false;public;2;8;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startArray().     for (Address address : addresses) {         builder.value(address.toUnicodeString()).     }     return builder.endArray(). }
false;public,static;1;8;;public static AddressList parse(String text) throws AddressException {     InternetAddress[] addresses = InternetAddress.parse(text).     List<Address> list = new ArrayList<>(addresses.length).     for (InternetAddress address : addresses) {         list.add(new Address(address.toUnicodeString())).     }     return new AddressList(list). }
false;public,static;2;15;;public static AddressList parse(Settings settings, String name) {     List<String> addresses = settings.getAsList(name).     if (addresses == null || addresses.isEmpty()) {         return null.     }     try {         List<Address> list = new ArrayList<>(addresses.size()).         for (String address : addresses) {             list.add(new Address(address)).         }         return new AddressList(list).     } catch (AddressException ae) {         throw new IllegalArgumentException("[" + settings.get(name) + "] is not a valid list of RFC822 email addresses", ae).     } }
false;public,static;3;20;;public static Email.AddressList parse(String field, XContentParser.Token token, XContentParser parser) throws IOException {     if (token == XContentParser.Token.VALUE_STRING) {         String text = parser.text().         try {             return parse(parser.text()).         } catch (AddressException ae) {             throw new ElasticsearchParseException("could not parse field [" + field + "] with value [" + text + "] as address " + "list. address(es) must be RFC822 encoded", ae).         }     }     if (token == XContentParser.Token.START_ARRAY) {         List<Email.Address> addresses = new ArrayList<>().         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {             addresses.add(Address.parse(field, token, parser)).         }         return new Email.AddressList(addresses).     }     throw new ElasticsearchParseException("could not parse [" + field + "] as address list. field must either be a string " + "(comma-separated list of RFC822 encoded addresses) or an array of objects representing addresses"). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     AddressList addresses1 = (AddressList) o.     if (!addresses.equals(addresses1.addresses))         return false.     return true. }
false;public;0;4;;@Override public int hashCode() {     return addresses.hashCode(). }
