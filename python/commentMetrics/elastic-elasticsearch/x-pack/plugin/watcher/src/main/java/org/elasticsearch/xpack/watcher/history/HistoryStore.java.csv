# id;timestamp;commentText;codeText;commentWords;codeWords
HistoryStore -> public void forcePut(WatchRecord watchRecord);1524684173;Stores the specified watchRecord._Any existing watchRecord will be overwritten.;public void forcePut(WatchRecord watchRecord) {_        if (!started.get()) {_            throw new IllegalStateException("unable to persist watch record history store is not ready")__        }_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__        putUpdateLock.lock()__        try {_            try (XContentBuilder builder = XContentFactory.jsonBuilder()__                 ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_                watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___                IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value())_                        .source(builder)_                        .opType(IndexRequest.OpType.CREATE)__                client.index(request).get(30, TimeUnit.SECONDS)__                logger.debug("indexed watch history record [{}]", watchRecord.id().value())__            } catch (VersionConflictEngineException vcee) {_                watchRecord = new WatchRecord.MessageWatchRecord(watchRecord, ExecutionState.EXECUTED_MULTIPLE_TIMES,_                        "watch record [{ " + watchRecord.id() + " }] has been stored before, previous state [" + watchRecord.state() + "]")__                try (XContentBuilder xContentBuilder = XContentFactory.jsonBuilder()__                     ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_                    IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value())_                            .source(xContentBuilder.value(watchRecord))__                    client.index(request).get(30, TimeUnit.SECONDS)__                }_                logger.debug("overwrote watch history record [{}]", watchRecord.id().value())__            }_        } catch (InterruptedException | ExecutionException | TimeoutException | IOException ioe) {_            final WatchRecord wr = watchRecord__            logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to persist watch record [{}]", wr), ioe)__        } finally {_            putUpdateLock.unlock()__        }_    };stores,the,specified,watch,record,any,existing,watch,record,will,be,overwritten;public,void,force,put,watch,record,watch,record,if,started,get,throw,new,illegal,state,exception,unable,to,persist,watch,record,history,store,is,not,ready,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,put,update,lock,lock,try,try,xcontent,builder,builder,xcontent,factory,json,builder,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,op,type,index,request,op,type,create,client,index,request,get,30,time,unit,seconds,logger,debug,indexed,watch,history,record,watch,record,id,value,catch,version,conflict,engine,exception,vcee,watch,record,new,watch,record,message,watch,record,watch,record,execution,state,watch,record,watch,record,id,has,been,stored,before,previous,state,watch,record,state,try,xcontent,builder,x,content,builder,xcontent,factory,json,builder,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,index,request,request,new,index,request,index,watch,record,id,value,source,x,content,builder,value,watch,record,client,index,request,get,30,time,unit,seconds,logger,debug,overwrote,watch,history,record,watch,record,id,value,catch,interrupted,exception,execution,exception,timeout,exception,ioexception,ioe,final,watch,record,wr,watch,record,logger,error,supplier,new,parameterized,message,failed,to,persist,watch,record,wr,ioe,finally,put,update,lock,unlock
HistoryStore -> public void forcePut(WatchRecord watchRecord);1525334055;Stores the specified watchRecord._Any existing watchRecord will be overwritten.;public void forcePut(WatchRecord watchRecord) {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__        putUpdateLock.lock()__        try {_            try (XContentBuilder builder = XContentFactory.jsonBuilder()__                 ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_                watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___                IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value())_                    .source(builder)_                    .opType(IndexRequest.OpType.CREATE)__                client.index(request).get(30, TimeUnit.SECONDS)__                logger.debug("indexed watch history record [{}]", watchRecord.id().value())__            } catch (VersionConflictEngineException vcee) {_                watchRecord = new WatchRecord.MessageWatchRecord(watchRecord, ExecutionState.EXECUTED_MULTIPLE_TIMES,_                    "watch record [{ " + watchRecord.id() + " }] has been stored before, previous state [" + watchRecord.state() + "]")__                try (XContentBuilder xContentBuilder = XContentFactory.jsonBuilder()__                     ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_                    IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value())_                        .source(xContentBuilder.value(watchRecord))__                    client.index(request).get(30, TimeUnit.SECONDS)__                }_                logger.debug("overwrote watch history record [{}]", watchRecord.id().value())__            }_        } catch (InterruptedException | ExecutionException | TimeoutException | IOException ioe) {_            final WatchRecord wr = watchRecord__            logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to persist watch record [{}]", wr), ioe)__        } finally {_            putUpdateLock.unlock()__        }_    };stores,the,specified,watch,record,any,existing,watch,record,will,be,overwritten;public,void,force,put,watch,record,watch,record,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,put,update,lock,lock,try,try,xcontent,builder,builder,xcontent,factory,json,builder,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,op,type,index,request,op,type,create,client,index,request,get,30,time,unit,seconds,logger,debug,indexed,watch,history,record,watch,record,id,value,catch,version,conflict,engine,exception,vcee,watch,record,new,watch,record,message,watch,record,watch,record,execution,state,watch,record,watch,record,id,has,been,stored,before,previous,state,watch,record,state,try,xcontent,builder,x,content,builder,xcontent,factory,json,builder,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,index,request,request,new,index,request,index,watch,record,id,value,source,x,content,builder,value,watch,record,client,index,request,get,30,time,unit,seconds,logger,debug,overwrote,watch,history,record,watch,record,id,value,catch,interrupted,exception,execution,exception,timeout,exception,ioexception,ioe,final,watch,record,wr,watch,record,logger,error,supplier,new,parameterized,message,failed,to,persist,watch,record,wr,ioe,finally,put,update,lock,unlock
HistoryStore -> public void forcePut(WatchRecord watchRecord);1537300661;Stores the specified watchRecord._Any existing watchRecord will be overwritten.;public void forcePut(WatchRecord watchRecord) {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___                IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value()).source(builder)__                bulkProcessor.add(request)__        } catch (IOException ioe) {_            final WatchRecord wr = watchRecord__            logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to persist watch record [{}]", wr), ioe)__        }_    };stores,the,specified,watch,record,any,existing,watch,record,will,be,overwritten;public,void,force,put,watch,record,watch,record,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,try,xcontent,builder,builder,xcontent,factory,json,builder,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,bulk,processor,add,request,catch,ioexception,ioe,final,watch,record,wr,watch,record,logger,error,supplier,new,parameterized,message,failed,to,persist,watch,record,wr,ioe
HistoryStore -> public void forcePut(WatchRecord watchRecord);1541092382;Stores the specified watchRecord._Any existing watchRecord will be overwritten.;public void forcePut(WatchRecord watchRecord) {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___                IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value()).source(builder)__                bulkProcessor.add(request)__        } catch (IOException ioe) {_            final WatchRecord wr = watchRecord__            logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to persist watch record [{}]", wr), ioe)__        }_    };stores,the,specified,watch,record,any,existing,watch,record,will,be,overwritten;public,void,force,put,watch,record,watch,record,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,try,xcontent,builder,builder,xcontent,factory,json,builder,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,bulk,processor,add,request,catch,ioexception,ioe,final,watch,record,wr,watch,record,logger,error,supplier,new,parameterized,message,failed,to,persist,watch,record,wr,ioe
HistoryStore -> public void forcePut(WatchRecord watchRecord);1543343306;Stores the specified watchRecord._Any existing watchRecord will be overwritten.;public void forcePut(WatchRecord watchRecord) {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___                IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value()).source(builder)__                bulkProcessor.add(request)__        } catch (IOException ioe) {_            final WatchRecord wr = watchRecord__            logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to persist watch record [{}]", wr), ioe)__        }_    };stores,the,specified,watch,record,any,existing,watch,record,will,be,overwritten;public,void,force,put,watch,record,watch,record,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,try,xcontent,builder,builder,xcontent,factory,json,builder,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,bulk,processor,add,request,catch,ioexception,ioe,final,watch,record,wr,watch,record,logger,error,supplier,new,parameterized,message,failed,to,persist,watch,record,wr,ioe
HistoryStore -> public void forcePut(WatchRecord watchRecord);1549289311;Stores the specified watchRecord._Any existing watchRecord will be overwritten.;public void forcePut(WatchRecord watchRecord) {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___                IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value()).source(builder)__                bulkProcessor.add(request)__        } catch (IOException ioe) {_            final WatchRecord wr = watchRecord__            logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to persist watch record [{}]", wr), ioe)__        }_    };stores,the,specified,watch,record,any,existing,watch,record,will,be,overwritten;public,void,force,put,watch,record,watch,record,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,try,xcontent,builder,builder,xcontent,factory,json,builder,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,bulk,processor,add,request,catch,ioexception,ioe,final,watch,record,wr,watch,record,logger,error,supplier,new,parameterized,message,failed,to,persist,watch,record,wr,ioe
HistoryStore -> public void put(WatchRecord watchRecord) throws Exception;1524684173;Stores the specified watchRecord._If the specified watchRecord already was stored this call will fail with a version conflict.;public void put(WatchRecord watchRecord) throws Exception {_        if (!started.get()) {_            throw new IllegalStateException("unable to persist watch record history store is not ready")__        }_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__        putUpdateLock.lock()__        try (XContentBuilder builder = XContentFactory.jsonBuilder()__             ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___            IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value())_                    .source(builder)_                    .opType(IndexRequest.OpType.CREATE)__            client.index(request).actionGet(30, TimeUnit.SECONDS)__            logger.debug("indexed watch history record [{}]", watchRecord.id().value())__        } catch (IOException ioe) {_            throw ioException("failed to persist watch record [{}]", ioe, watchRecord)__        } finally {_            putUpdateLock.unlock()__        }_    };stores,the,specified,watch,record,if,the,specified,watch,record,already,was,stored,this,call,will,fail,with,a,version,conflict;public,void,put,watch,record,watch,record,throws,exception,if,started,get,throw,new,illegal,state,exception,unable,to,persist,watch,record,history,store,is,not,ready,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,put,update,lock,lock,try,xcontent,builder,builder,xcontent,factory,json,builder,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,op,type,index,request,op,type,create,client,index,request,action,get,30,time,unit,seconds,logger,debug,indexed,watch,history,record,watch,record,id,value,catch,ioexception,ioe,throw,io,exception,failed,to,persist,watch,record,ioe,watch,record,finally,put,update,lock,unlock
HistoryStore -> public void put(WatchRecord watchRecord) throws Exception;1525334055;Stores the specified watchRecord._If the specified watchRecord already was stored this call will fail with a version conflict.;public void put(WatchRecord watchRecord) throws Exception {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__        putUpdateLock.lock()__        try (XContentBuilder builder = XContentFactory.jsonBuilder()__             ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___            IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value())_                .source(builder)_                .opType(IndexRequest.OpType.CREATE)__            client.index(request).actionGet(30, TimeUnit.SECONDS)__            logger.debug("indexed watch history record [{}]", watchRecord.id().value())__        } catch (IOException ioe) {_            throw ioException("failed to persist watch record [{}]", ioe, watchRecord)__        } finally {_            putUpdateLock.unlock()__        }_    };stores,the,specified,watch,record,if,the,specified,watch,record,already,was,stored,this,call,will,fail,with,a,version,conflict;public,void,put,watch,record,watch,record,throws,exception,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,put,update,lock,lock,try,xcontent,builder,builder,xcontent,factory,json,builder,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,op,type,index,request,op,type,create,client,index,request,action,get,30,time,unit,seconds,logger,debug,indexed,watch,history,record,watch,record,id,value,catch,ioexception,ioe,throw,io,exception,failed,to,persist,watch,record,ioe,watch,record,finally,put,update,lock,unlock
HistoryStore -> public void put(WatchRecord watchRecord) throws Exception;1537300661;Stores the specified watchRecord._If the specified watchRecord already was stored this call will fail with a version conflict.;public void put(WatchRecord watchRecord) throws Exception {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___            IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value()).source(builder)__            request.opType(IndexRequest.OpType.CREATE)__            bulkProcessor.add(request)__        } catch (IOException ioe) {_            throw ioException("failed to persist watch record [{}]", ioe, watchRecord)__        }_    };stores,the,specified,watch,record,if,the,specified,watch,record,already,was,stored,this,call,will,fail,with,a,version,conflict;public,void,put,watch,record,watch,record,throws,exception,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,try,xcontent,builder,builder,xcontent,factory,json,builder,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,request,op,type,index,request,op,type,create,bulk,processor,add,request,catch,ioexception,ioe,throw,io,exception,failed,to,persist,watch,record,ioe,watch,record
HistoryStore -> public void put(WatchRecord watchRecord) throws Exception;1541092382;Stores the specified watchRecord._If the specified watchRecord already was stored this call will fail with a version conflict.;public void put(WatchRecord watchRecord) throws Exception {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___            IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value()).source(builder)__            request.opType(IndexRequest.OpType.CREATE)__            bulkProcessor.add(request)__        } catch (IOException ioe) {_            throw ioException("failed to persist watch record [{}]", ioe, watchRecord)__        }_    };stores,the,specified,watch,record,if,the,specified,watch,record,already,was,stored,this,call,will,fail,with,a,version,conflict;public,void,put,watch,record,watch,record,throws,exception,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,try,xcontent,builder,builder,xcontent,factory,json,builder,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,request,op,type,index,request,op,type,create,bulk,processor,add,request,catch,ioexception,ioe,throw,io,exception,failed,to,persist,watch,record,ioe,watch,record
HistoryStore -> public void put(WatchRecord watchRecord) throws Exception;1543343306;Stores the specified watchRecord._If the specified watchRecord already was stored this call will fail with a version conflict.;public void put(WatchRecord watchRecord) throws Exception {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___            IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value()).source(builder)__            request.opType(IndexRequest.OpType.CREATE)__            bulkProcessor.add(request)__        } catch (IOException ioe) {_            throw ioException("failed to persist watch record [{}]", ioe, watchRecord)__        }_    };stores,the,specified,watch,record,if,the,specified,watch,record,already,was,stored,this,call,will,fail,with,a,version,conflict;public,void,put,watch,record,watch,record,throws,exception,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,try,xcontent,builder,builder,xcontent,factory,json,builder,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,request,op,type,index,request,op,type,create,bulk,processor,add,request,catch,ioexception,ioe,throw,io,exception,failed,to,persist,watch,record,ioe,watch,record
HistoryStore -> public void put(WatchRecord watchRecord) throws Exception;1549289311;Stores the specified watchRecord._If the specified watchRecord already was stored this call will fail with a version conflict.;public void put(WatchRecord watchRecord) throws Exception {_        String index = HistoryStoreField.getHistoryIndexNameForTime(watchRecord.triggerEvent().triggeredTime())__        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_            watchRecord.toXContent(builder, WatcherParams.HIDE_SECRETS)___            IndexRequest request = new IndexRequest(index, DOC_TYPE, watchRecord.id().value()).source(builder)__            request.opType(IndexRequest.OpType.CREATE)__            bulkProcessor.add(request)__        } catch (IOException ioe) {_            throw ioException("failed to persist watch record [{}]", ioe, watchRecord)__        }_    };stores,the,specified,watch,record,if,the,specified,watch,record,already,was,stored,this,call,will,fail,with,a,version,conflict;public,void,put,watch,record,watch,record,throws,exception,string,index,history,store,field,get,history,index,name,for,time,watch,record,trigger,event,triggered,time,try,xcontent,builder,builder,xcontent,factory,json,builder,watch,record,to,xcontent,builder,watcher,params,index,request,request,new,index,request,index,watch,record,id,value,source,builder,request,op,type,index,request,op,type,create,bulk,processor,add,request,catch,ioexception,ioe,throw,io,exception,failed,to,persist,watch,record,ioe,watch,record
HistoryStore -> public static boolean validate(ClusterState state);1524684173;Check if everything is set up for the history store to operate fully. Checks for the_current watcher history index and if it is open.__@param state The current cluster state_@return true, if history store is ready to be started;public static boolean validate(ClusterState state) {_        String currentIndex = HistoryStoreField.getHistoryIndexNameForTime(DateTime.now(DateTimeZone.UTC))__        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(currentIndex, state.metaData())__        if (indexMetaData == null) {_            return true__        } else {_            return indexMetaData.getState() == IndexMetaData.State.OPEN &&_                    state.routingTable().index(indexMetaData.getIndex()).allPrimaryShardsActive()__        }_    };check,if,everything,is,set,up,for,the,history,store,to,operate,fully,checks,for,the,current,watcher,history,index,and,if,it,is,open,param,state,the,current,cluster,state,return,true,if,history,store,is,ready,to,be,started;public,static,boolean,validate,cluster,state,state,string,current,index,history,store,field,get,history,index,name,for,time,date,time,now,date,time,zone,utc,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,current,index,state,meta,data,if,index,meta,data,null,return,true,else,return,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,index,meta,data,get,index,all,primary,shards,active
HistoryStore -> public static boolean validate(ClusterState state);1525334055;Check if everything is set up for the history store to operate fully. Checks for the_current watcher history index and if it is open.__@param state The current cluster state_@return true, if history store is ready to be started;public static boolean validate(ClusterState state) {_        String currentIndex = HistoryStoreField.getHistoryIndexNameForTime(DateTime.now(DateTimeZone.UTC))__        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(currentIndex, state.metaData())__        return indexMetaData == null || (indexMetaData.getState() == IndexMetaData.State.OPEN &&_            state.routingTable().index(indexMetaData.getIndex()).allPrimaryShardsActive())__    };check,if,everything,is,set,up,for,the,history,store,to,operate,fully,checks,for,the,current,watcher,history,index,and,if,it,is,open,param,state,the,current,cluster,state,return,true,if,history,store,is,ready,to,be,started;public,static,boolean,validate,cluster,state,state,string,current,index,history,store,field,get,history,index,name,for,time,date,time,now,date,time,zone,utc,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,current,index,state,meta,data,return,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,index,meta,data,get,index,all,primary,shards,active
HistoryStore -> public static boolean validate(ClusterState state);1537300661;Check if everything is set up for the history store to operate fully. Checks for the_current watcher history index and if it is open.__@param state The current cluster state_@return true, if history store is ready to be started;public static boolean validate(ClusterState state) {_        String currentIndex = HistoryStoreField.getHistoryIndexNameForTime(DateTime.now(DateTimeZone.UTC))__        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(currentIndex, state.metaData())__        return indexMetaData == null || (indexMetaData.getState() == IndexMetaData.State.OPEN &&_            state.routingTable().index(indexMetaData.getIndex()).allPrimaryShardsActive())__    };check,if,everything,is,set,up,for,the,history,store,to,operate,fully,checks,for,the,current,watcher,history,index,and,if,it,is,open,param,state,the,current,cluster,state,return,true,if,history,store,is,ready,to,be,started;public,static,boolean,validate,cluster,state,state,string,current,index,history,store,field,get,history,index,name,for,time,date,time,now,date,time,zone,utc,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,current,index,state,meta,data,return,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,index,meta,data,get,index,all,primary,shards,active
HistoryStore -> public static boolean validate(ClusterState state);1541092382;Check if everything is set up for the history store to operate fully. Checks for the_current watcher history index and if it is open.__@param state The current cluster state_@return true, if history store is ready to be started;public static boolean validate(ClusterState state) {_        String currentIndex = HistoryStoreField.getHistoryIndexNameForTime(DateTime.now(DateTimeZone.UTC))__        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(currentIndex, state.metaData())__        return indexMetaData == null || (indexMetaData.getState() == IndexMetaData.State.OPEN &&_            state.routingTable().index(indexMetaData.getIndex()).allPrimaryShardsActive())__    };check,if,everything,is,set,up,for,the,history,store,to,operate,fully,checks,for,the,current,watcher,history,index,and,if,it,is,open,param,state,the,current,cluster,state,return,true,if,history,store,is,ready,to,be,started;public,static,boolean,validate,cluster,state,state,string,current,index,history,store,field,get,history,index,name,for,time,date,time,now,date,time,zone,utc,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,current,index,state,meta,data,return,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,index,meta,data,get,index,all,primary,shards,active
HistoryStore -> public static boolean validate(ClusterState state);1543343306;Check if everything is set up for the history store to operate fully. Checks for the_current watcher history index and if it is open.__@param state The current cluster state_@return true, if history store is ready to be started;public static boolean validate(ClusterState state) {_        String currentIndex = HistoryStoreField.getHistoryIndexNameForTime(DateTime.now(DateTimeZone.UTC))__        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(currentIndex, state.metaData())__        return indexMetaData == null || (indexMetaData.getState() == IndexMetaData.State.OPEN &&_            state.routingTable().index(indexMetaData.getIndex()).allPrimaryShardsActive())__    };check,if,everything,is,set,up,for,the,history,store,to,operate,fully,checks,for,the,current,watcher,history,index,and,if,it,is,open,param,state,the,current,cluster,state,return,true,if,history,store,is,ready,to,be,started;public,static,boolean,validate,cluster,state,state,string,current,index,history,store,field,get,history,index,name,for,time,date,time,now,date,time,zone,utc,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,current,index,state,meta,data,return,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,index,meta,data,get,index,all,primary,shards,active
HistoryStore -> public static boolean validate(ClusterState state);1549289311;Check if everything is set up for the history store to operate fully. Checks for the_current watcher history index and if it is open.__@param state The current cluster state_@return true, if history store is ready to be started;public static boolean validate(ClusterState state) {_        String currentIndex = HistoryStoreField.getHistoryIndexNameForTime(ZonedDateTime.now(ZoneOffset.UTC))__        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(currentIndex, state.metaData())__        return indexMetaData == null || (indexMetaData.getState() == IndexMetaData.State.OPEN &&_            state.routingTable().index(indexMetaData.getIndex()).allPrimaryShardsActive())__    };check,if,everything,is,set,up,for,the,history,store,to,operate,fully,checks,for,the,current,watcher,history,index,and,if,it,is,open,param,state,the,current,cluster,state,return,true,if,history,store,is,ready,to,be,started;public,static,boolean,validate,cluster,state,state,string,current,index,history,store,field,get,history,index,name,for,time,zoned,date,time,now,zone,offset,utc,index,meta,data,index,meta,data,watch,store,utils,get,concrete,index,current,index,state,meta,data,return,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,open,state,routing,table,index,index,meta,data,get,index,all,primary,shards,active
