commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public EnumSet<DayOfWeek> days() {     return days. }
false;public;0;3;;public DayTimes[] times() {     return times. }
false;public;0;10;;public Set<String> crons() {     Set<String> crons = new HashSet<>().     for (DayTimes times : this.times) {         String hrsStr = join(",", times.hour).         String minsStr = join(",", times.minute).         String daysStr = DayOfWeek.cronPart(this.days).         crons.add("0 " + minsStr + " " + hrsStr + " ? * " + daysStr).     }     return crons. }
false;public;1;14;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     WeekTimes that = (WeekTimes) o.     if (!days.equals(that.days))         return false.     // we don't care about order     if (!newHashSet(times).equals(newHashSet(that.times)))         return false.     return true. }
false;public;0;6;;@Override public int hashCode() {     int result = days.hashCode().     result = 31 * result + Arrays.hashCode(times).     return result. }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(DAY_FIELD.getPreferredName(), days).     builder.startArray(TIME_FIELD.getPreferredName()).     for (DayTimes dayTimes : times) {         dayTimes.toXContent(builder, params).     }     builder.endArray().     return builder.endObject(). }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public,static;2;43;;public static WeekTimes parse(XContentParser parser, XContentParser.Token token) throws IOException, ElasticsearchParseException {     if (token != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("could not parse week times. expected an object, but found [{}]", token).     }     Set<DayOfWeek> daysSet = new HashSet<>().     Set<DayTimes> timesSet = new HashSet<>().     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (DAY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 daysSet.add(parseDayValue(parser, token)).             } else if (token == XContentParser.Token.START_ARRAY) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     daysSet.add(parseDayValue(parser, token)).                 }             } else {                 throw new ElasticsearchParseException("invalid week day value for [{}] field. expected string/number value or an " + "array of string/number values, but found [{}]", currentFieldName, token).             }         } else if (TIME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             if (token != XContentParser.Token.START_ARRAY) {                 try {                     timesSet.add(DayTimes.parse(parser, token)).                 } catch (ElasticsearchParseException pe) {                     throw new ElasticsearchParseException("invalid time value for field [{}] - [{}]", pe, currentFieldName, token).                 }             } else {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     try {                         timesSet.add(DayTimes.parse(parser, token)).                     } catch (ElasticsearchParseException pe) {                         throw new ElasticsearchParseException("invalid time value for field [{}] - [{}]", pe, currentFieldName, token).                     }                 }             }         }     }     EnumSet<DayOfWeek> days = daysSet.isEmpty() ? EnumSet.of(DayOfWeek.MONDAY) : EnumSet.copyOf(daysSet).     DayTimes[] times = timesSet.isEmpty() ? new DayTimes[] { new DayTimes(0, 0) } : timesSet.toArray(new DayTimes[timesSet.size()]).     return new WeekTimes(days, times). }
false;static;2;9;;static DayOfWeek parseDayValue(XContentParser parser, XContentParser.Token token) throws IOException {     if (token == XContentParser.Token.VALUE_STRING) {         return DayOfWeek.resolve(parser.text()).     }     if (token == XContentParser.Token.VALUE_NUMBER) {         return DayOfWeek.resolve(parser.intValue()).     }     throw new ElasticsearchParseException("invalid weekly day value. expected a string or a number value, but found [" + token + "]"). }
false;public;1;4;;public Builder on(DayOfWeek... days) {     Collections.addAll(this.days, days).     return this. }
false;public;2;4;;public Builder at(int hour, int minute) {     times.add(new DayTimes(hour, minute)).     return this. }
false;public;1;4;;public Builder atRoundHour(int... hours) {     times.add(new DayTimes(hours, new int[] { 0 })).     return this. }
false;public;0;4;;public Builder atNoon() {     times.add(DayTimes.NOON).     return this. }
false;public;0;4;;public Builder atMidnight() {     times.add(DayTimes.MIDNIGHT).     return this. }
false;public;0;4;;public WeekTimes build() {     EnumSet<DayOfWeek> dow = days.isEmpty() ? WeekTimes.DEFAULT_DAYS : EnumSet.copyOf(days).     return new WeekTimes(dow, times.toArray(new DayTimes[times.size()])). }
