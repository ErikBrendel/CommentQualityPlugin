commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public TimeValue ackTimeout() {     return AcknowledgedRequest.DEFAULT_ACK_TIMEOUT. }
false;public;0;4;;@Override public TimeValue masterNodeTimeout() {     return AcknowledgedRequest.DEFAULT_ACK_TIMEOUT. }
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.MANAGEMENT. }
false;protected;0;4;;@Override protected AcknowledgedResponse newResponse() {     return new AcknowledgedResponse(). }
false;protected;3;12;;@Override protected void masterOperation(WatcherServiceRequest request, ClusterState state, ActionListener<AcknowledgedResponse> listener) {     switch(request.getCommand()) {         case STOP:             setWatcherMetaDataAndWait(true, listener).             break.         case START:             setWatcherMetaDataAndWait(false, listener).             break.     } }
false;protected;1;4;;@Override protected AcknowledgedResponse newResponse(boolean acknowledged) {     return new AcknowledgedResponse(acknowledged). }
false;public;1;17;;@Override public ClusterState execute(ClusterState clusterState) {     XPackPlugin.checkReadyForXPackCustomMetadata(clusterState).     WatcherMetaData newWatcherMetaData = new WatcherMetaData(manuallyStopped).     WatcherMetaData currentMetaData = clusterState.metaData().custom(WatcherMetaData.TYPE).     // adhere to the contract of returning the original state if nothing has changed     if (newWatcherMetaData.equals(currentMetaData)) {         return clusterState.     } else {         ClusterState.Builder builder = new ClusterState.Builder(clusterState).         builder.metaData(MetaData.builder(clusterState.getMetaData()).putCustom(WatcherMetaData.TYPE, newWatcherMetaData)).         return builder.build().     } }
false;public;2;6;;@Override public void onFailure(String source, Exception e) {     logger.error(new ParameterizedMessage("could not update watcher stopped status to [{}], source [{}]", manuallyStopped, source), e).     listener.onFailure(e). }
false;private;2;37;;private void setWatcherMetaDataAndWait(boolean manuallyStopped, final ActionListener<AcknowledgedResponse> listener) {     String source = manuallyStopped ? "update_watcher_manually_stopped" : "update_watcher_manually_started".     clusterService.submitStateUpdateTask(source, new AckedClusterStateUpdateTask<AcknowledgedResponse>(ackedRequest, listener) {          @Override         protected AcknowledgedResponse newResponse(boolean acknowledged) {             return new AcknowledgedResponse(acknowledged).         }          @Override         public ClusterState execute(ClusterState clusterState) {             XPackPlugin.checkReadyForXPackCustomMetadata(clusterState).             WatcherMetaData newWatcherMetaData = new WatcherMetaData(manuallyStopped).             WatcherMetaData currentMetaData = clusterState.metaData().custom(WatcherMetaData.TYPE).             // adhere to the contract of returning the original state if nothing has changed             if (newWatcherMetaData.equals(currentMetaData)) {                 return clusterState.             } else {                 ClusterState.Builder builder = new ClusterState.Builder(clusterState).                 builder.metaData(MetaData.builder(clusterState.getMetaData()).putCustom(WatcherMetaData.TYPE, newWatcherMetaData)).                 return builder.build().             }         }          @Override         public void onFailure(String source, Exception e) {             logger.error(new ParameterizedMessage("could not update watcher stopped status to [{}], source [{}]", manuallyStopped, source), e).             listener.onFailure(e).         }     }). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(WatcherServiceRequest request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
