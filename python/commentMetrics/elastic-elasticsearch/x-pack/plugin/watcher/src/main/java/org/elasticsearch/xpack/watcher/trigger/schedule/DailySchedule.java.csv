commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;0;3;;public DayTimes[] times() {     return times. }
false;public;2;14;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (params.paramAsBoolean("normalize", false) && times.length == 1) {         builder.field(Parser.AT_FIELD.getPreferredName(), times[0], params).     } else {         builder.startArray(Parser.AT_FIELD.getPreferredName()).         for (DayTimes dayTimes : times) {             dayTimes.toXContent(builder, params).         }         builder.endArray().     }     return builder.endObject(). }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;static;1;8;;static String[] crons(DayTimes[] times) {     assert times.length > 0 : "at least one time must be defined".     List<String> crons = new ArrayList<>(times.length).     for (DayTimes time : times) {         crons.add(time.cron()).     }     return crons.toArray(new String[crons.size()]). }
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;1;33;;@Override public DailySchedule parse(XContentParser parser) throws IOException {     List<DayTimes> times = new ArrayList<>().     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (AT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             if (token != XContentParser.Token.START_ARRAY) {                 try {                     times.add(DayTimes.parse(parser, token)).                 } catch (ElasticsearchParseException pe) {                     throw new ElasticsearchParseException("could not parse [{}] schedule. invalid time value for field [{}] - [{}]", pe, TYPE, currentFieldName, token).                 }             } else {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     try {                         times.add(DayTimes.parse(parser, token)).                     } catch (ElasticsearchParseException pe) {                         throw new ElasticsearchParseException("could not parse [{}] schedule. invalid time value for field [{}] -" + " [{}]", pe, TYPE, currentFieldName, token).                     }                 }             }         } else {             throw new ElasticsearchParseException("could not parse [{}] schedule. unexpected field [{}]", TYPE, currentFieldName).         }     }     return times.isEmpty() ? new DailySchedule() : new DailySchedule(times.toArray(new DayTimes[times.size()])). }
false;public;2;4;;public Builder at(int hour, int minute) {     times.add(new DayTimes(hour, minute)).     return this. }
false;public;1;4;;public Builder atRoundHour(int... hours) {     times.add(new DayTimes(hours, new int[] { 0 })).     return this. }
false;public;0;4;;public Builder atNoon() {     times.add(DayTimes.NOON).     return this. }
false;public;0;4;;public Builder atMidnight() {     times.add(DayTimes.MIDNIGHT).     return this. }
false;public;0;3;;public DailySchedule build() {     return times.isEmpty() ? new DailySchedule() : new DailySchedule(times.toArray(new DayTimes[times.size()])). }
