commented;modifiers;parameterAmount;loc;comment;code
false;public;2;11;;public HttpInput.Result execute(WatchExecutionContext ctx, Payload payload) {     HttpRequest request = null.     try {         Map<String, Object> model = Variables.createCtxParamsMap(ctx, payload).         request = input.getRequest().render(templateEngine, model).         return doExecute(ctx, request).     } catch (Exception e) {         logger.error("failed to execute [{}] input for watch [{}], reason [{}]", TYPE, ctx.watch().id(), e.getMessage()).         return new HttpInput.Result(request, e).     } }
false;;2;52;;HttpInput.Result doExecute(WatchExecutionContext ctx, HttpRequest request) throws Exception {     HttpResponse response = client.execute(request).     Map<String, List<String>> headers = response.headers().     Map<String, Object> payloadMap = new HashMap<>().     payloadMap.put("_status_code", response.status()).     if (headers.isEmpty() == false) {         payloadMap.put("_headers", headers).     }     if (!response.hasContent()) {         return new HttpInput.Result(request, response.status(), new Payload.Simple(payloadMap)).     }     final XContentType contentType.     XContentType responseContentType = response.xContentType().     if (input.getExpectedResponseXContentType() == null) {         // Attempt to auto detect content type, if not set in response         contentType = responseContentType != null ? responseContentType : XContentHelper.xContentType(response.body()).     } else {         contentType = input.getExpectedResponseXContentType().contentType().         if (responseContentType != contentType) {             logger.warn("[{}] [{}] input expected content type [{}] but read [{}] from headers, using expected one", type(), ctx.id(), input.getExpectedResponseXContentType(), responseContentType).         }     }     if (contentType != null) {         // EMPTY is safe here because we never use namedObject         try (InputStream stream = response.body().streamInput().             XContentParser parser = contentType.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {             if (input.getExtractKeys() != null) {                 payloadMap.putAll(XContentFilterKeysUtils.filterMapOrdered(input.getExtractKeys(), parser)).             } else {                 // special handling if a list is returned, i.e. JSON like [ {},{} ]                 XContentParser.Token token = parser.nextToken().                 if (token == XContentParser.Token.START_ARRAY) {                     payloadMap.put("data", parser.listOrderedMap()).                 } else {                     payloadMap.putAll(parser.mapOrdered()).                 }             }         } catch (Exception e) {             throw new ElasticsearchParseException("could not parse response body [{}] it does not appear to be [{}]", type(), ctx.id(), response.body().utf8ToString(), contentType.shortName()).         }     } else {         payloadMap.put("_value", response.body().utf8ToString()).     }     return new HttpInput.Result(request, response.status(), new Payload.Simple(payloadMap)). }
