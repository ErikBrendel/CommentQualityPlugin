commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public int status() {     return status. }
false;public;0;3;;public boolean hasContent() {     return body != null. }
false;public;0;3;;public BytesReference body() {     return body. }
true;public;0;7;/**  * Returns all the headers, with keys being lowercased, so they are always consistent  * in the payload  */ ;/**  * Returns all the headers, with keys being lowercased, so they are always consistent  * in the payload  */ public Map<String, List<String>> headers() {     MapBuilder<String, List<String>> builder = MapBuilder.newMapBuilder().     for (Map.Entry<String, String[]> entry : headers.entrySet()) {         builder.put(entry.getKey().toLowerCase(Locale.ROOT), Arrays.asList(entry.getValue())).     }     return builder.immutableMap(). }
false;public;1;3;;public String[] header(String header) {     return headers.get(header.toLowerCase(Locale.ROOT)). }
false;public;0;7;;public String contentType() {     String[] values = header(HttpHeaders.Names.CONTENT_TYPE).     if (values == null || values.length == 0) {         return null.     }     return values[0]. }
false;public;0;7;;public XContentType xContentType() {     String[] values = header(HttpHeaders.Names.CONTENT_TYPE).     if (values == null || values.length == 0) {         return null.     }     return XContentType.fromMediaTypeOrFormat(values[0]). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     HttpResponse that = (HttpResponse) o.     if (status != that.status)         return false.     if (!headers.equals(that.headers))         return false.     return !(body != null ? !body.equals(that.body) : that.body != null). }
false;public;0;7;;@Override public int hashCode() {     int result = status.     result = 31 * result + headers.hashCode().     result = 31 * result + (body != null ? body.hashCode() : 0).     return result. }
false;public;0;21;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     sb.append("status=[").append(status).append("]").     if (!headers.isEmpty()) {         sb.append(", headers=[").         boolean first = true.         for (Map.Entry<String, String[]> header : headers.entrySet()) {             if (!first) {                 sb.append(", ").             }             sb.append("[").append(header.getKey()).append(": ").append(Arrays.toString(header.getValue())).append("]").             first = false.         }         sb.append("]").     }     if (hasContent()) {         sb.append(", body=[").append(body.utf8ToString()).append("]").     }     return sb.toString(). }
false;public;2;18;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder = builder.startObject().field(Field.STATUS.getPreferredName(), status).     if (!headers.isEmpty()) {         builder.startObject(Field.HEADERS.getPreferredName()).         for (Map.Entry<String, String[]> header : headers.entrySet()) {             // in order to prevent dots in field names, that might occur in headers, we simply de_dot those header names             // when writing toXContent             builder.array(header.getKey().replaceAll("\\.", "_"), header.getValue()).         }         builder.endObject().     }     if (hasContent()) {         builder = builder.field(Field.BODY.getPreferredName(), body.utf8ToString()).     }     builder.endObject().     return builder. }
false;public,static;1;60;;public static HttpResponse parse(XContentParser parser) throws IOException {     assert parser.currentToken() == XContentParser.Token.START_OBJECT.     int status = -1.     String body = null.     Map<String, String[]> headers = new HashMap<>().     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (currentFieldName == null) {             throw new ElasticsearchParseException("could not parse http response. expected a field name but found [{}] instead", token).         } else if (token == XContentParser.Token.VALUE_NUMBER) {             if (Field.STATUS.match(currentFieldName, parser.getDeprecationHandler())) {                 status = parser.intValue().             } else {                 throw new ElasticsearchParseException("could not parse http response. unknown numeric field [{}]", currentFieldName).             }         } else if (token == XContentParser.Token.VALUE_STRING) {             if (Field.BODY.match(currentFieldName, parser.getDeprecationHandler())) {                 body = parser.text().             } else {                 throw new ElasticsearchParseException("could not parse http response. unknown string field [{}]", currentFieldName).             }         } else if (token == XContentParser.Token.START_OBJECT) {             String headerName = null.             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     headerName = parser.currentName().                 } else if (headerName == null) {                     throw new ElasticsearchParseException("could not parse http response. expected a header name but found [{}] " + "instead", token).                 } else if (token.isValue()) {                     headers.put(headerName, new String[] { String.valueOf(parser.objectText()) }).                 } else if (token == XContentParser.Token.START_ARRAY) {                     List<String> values = new ArrayList<>().                     while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                         if (!token.isValue()) {                             throw new ElasticsearchParseException("could not parse http response. expected a header value for header " + "[{}] but found [{}] instead", headerName, token).                         } else {                             values.add(String.valueOf(parser.objectText())).                         }                     }                     headers.put(headerName, values.toArray(new String[values.size()])).                 }             }         } else {             throw new ElasticsearchParseException("could not parse http response. unexpected token [{}]", token).         }     }     if (status < 0) {         throw new ElasticsearchParseException("could not parse http response. missing required numeric [{}] field holding the " + "response's http status code", Field.STATUS.getPreferredName()).     }     return new HttpResponse(status, body, unmodifiableMap(headers)). }
