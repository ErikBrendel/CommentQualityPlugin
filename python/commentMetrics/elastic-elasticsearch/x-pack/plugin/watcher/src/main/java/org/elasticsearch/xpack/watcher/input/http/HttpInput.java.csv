commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;0;3;;public HttpRequestTemplate getRequest() {     return request. }
false;public;0;3;;public Set<String> getExtractKeys() {     return extractKeys. }
false;public;0;3;;public HttpContentType getExpectedResponseXContentType() {     return expectedResponseXContentType. }
false;public;2;13;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(Field.REQUEST.getPreferredName(), request, params).     if (extractKeys != null) {         builder.field(Field.EXTRACT.getPreferredName(), extractKeys).     }     if (expectedResponseXContentType != null) {         builder.field(Field.RESPONSE_CONTENT_TYPE.getPreferredName(), expectedResponseXContentType.id()).     }     builder.endObject().     return builder. }
false;public,static;2;61;;public static HttpInput parse(String watchId, XContentParser parser) throws IOException {     Set<String> extract = null.     HttpRequestTemplate request = null.     HttpContentType expectedResponseBodyType = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.REQUEST.match(currentFieldName, parser.getDeprecationHandler())) {             try {                 request = HttpRequestTemplate.Parser.parse(parser).             } catch (ElasticsearchParseException pe) {                 throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. failed to parse http request " + "template", pe, TYPE, watchId).             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (Field.EXTRACT.getPreferredName().equals(currentFieldName)) {                 extract = new HashSet<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token == XContentParser.Token.VALUE_STRING) {                         extract.add(parser.text()).                     } else {                         throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. expected a string value as " + "an [{}] item but found [{}] instead", TYPE, watchId, currentFieldName, token).                     }                 }             } else {                 throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. unexpected array field [{}]", TYPE, watchId, currentFieldName).             }         } else if (token == XContentParser.Token.VALUE_STRING) {             if (Field.RESPONSE_CONTENT_TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                 expectedResponseBodyType = HttpContentType.resolve(parser.text()).                 if (expectedResponseBodyType == null) {                     throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. unknown content type [{}]", TYPE, watchId, parser.text()).                 }             } else {                 throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. unexpected string field [{}]", TYPE, watchId, currentFieldName).             }         } else {             throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. unexpected token [{}]", TYPE, watchId, token).         }     }     if (request == null) {         throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. missing require [{}] field", TYPE, watchId, Field.REQUEST.getPreferredName()).     }     if (expectedResponseBodyType == HttpContentType.TEXT && extract != null) {         throw new ElasticsearchParseException("could not parse [{}] input for watch [{}]. key extraction is not supported for content" + " type [{}]", TYPE, watchId, expectedResponseBodyType).     }     return new HttpInput(request, expectedResponseBodyType, extract). }
false;public,static;1;3;;public static Builder builder(HttpRequestTemplate httpRequest) {     return new Builder(httpRequest). }
false;public;0;3;;public HttpRequest request() {     return request. }
false;protected;2;12;;@Override protected XContentBuilder typeXContent(XContentBuilder builder, Params params) throws IOException {     if (request == null) {         return builder.     }     builder.startObject(type).     builder.field(Field.REQUEST.getPreferredName(), request, params).     if (statusCode > 0) {         builder.field(Field.STATUS_CODE.getPreferredName(), statusCode).     }     return builder.endObject(). }
false;public;1;4;;public Builder extractKeys(Collection<String> keys) {     extractKeys.addAll(keys).     return this. }
false;public;1;4;;public Builder extractKeys(String... keys) {     Collections.addAll(extractKeys, keys).     return this. }
false;public;1;4;;public Builder expectedResponseXContentType(HttpContentType expectedResponseXContentType) {     this.expectedResponseXContentType = expectedResponseXContentType.     return this. }
false;public;0;4;;@Override public HttpInput build() {     return new HttpInput(request, expectedResponseXContentType, extractKeys.isEmpty() ? null : unmodifiableSet(extractKeys)). }
