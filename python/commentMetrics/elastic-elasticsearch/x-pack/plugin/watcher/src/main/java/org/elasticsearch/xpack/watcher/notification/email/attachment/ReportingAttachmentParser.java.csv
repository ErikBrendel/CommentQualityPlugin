commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;2;6;;@Override public ReportingAttachment parse(String id, XContentParser parser) throws IOException {     Builder builder = new Builder(id).     PARSER.parse(parser, builder, new AuthParseContext()).     return builder.build(). }
false;public;3;64;;@Override public Attachment toAttachment(WatchExecutionContext context, Payload payload, ReportingAttachment attachment) throws IOException {     Map<String, Object> model = Variables.createCtxParamsMap(context, payload).     String initialUrl = templateEngine.render(new TextTemplate(attachment.url()), model).     HttpRequestTemplate requestTemplate = HttpRequestTemplate.builder(initialUrl).connectionTimeout(TimeValue.timeValueSeconds(15)).readTimeout(TimeValue.timeValueSeconds(15)).method(HttpMethod.POST).auth(attachment.auth()).proxy(attachment.proxy()).putHeader("kbn-xsrf", new TextTemplate("reporting")).build().     HttpRequest request = requestTemplate.render(templateEngine, model).     HttpResponse reportGenerationResponse = requestReportGeneration(context.watch().id(), attachment.id(), request).     String path = extractIdFromJson(context.watch().id(), attachment.id(), reportGenerationResponse.body()).     HttpRequestTemplate pollingRequestTemplate = HttpRequestTemplate.builder(request.host(), request.port()).connectionTimeout(TimeValue.timeValueSeconds(10)).readTimeout(TimeValue.timeValueSeconds(10)).auth(attachment.auth()).path(path).scheme(request.scheme()).proxy(attachment.proxy()).putHeader("kbn-xsrf", new TextTemplate("reporting")).build().     HttpRequest pollingRequest = pollingRequestTemplate.render(templateEngine, model).     int maxRetries = attachment.retries() != null ? attachment.retries() : this.retries.     long sleepMillis = getSleepMillis(context, attachment).     int retryCount = 0.     while (retryCount < maxRetries) {         retryCount++.         // IMPORTANT NOTE: This is only a temporary solution until we made the execution of watcher more async         // This still blocks other executions on the thread and we have to get away from that         sleep(sleepMillis, context, attachment).         HttpResponse response = httpClient.execute(pollingRequest).         if (response.status() == 503) {             // requires us to interval another run, no action to take, except logging             logger.trace("Watch[{}] reporting[{}] pdf is not ready, polling in [{}] again", context.watch().id(), attachment.id(), TimeValue.timeValueMillis(sleepMillis)).         } else if (response.status() >= 400) {             String body = response.body() != null ? response.body().utf8ToString() : null.             throw new ElasticsearchException("Watch[{}] reporting[{}] Error when polling pdf from host[{}], port[{}], " + "method[{}], path[{}], status[{}], body[{}]", context.watch().id(), attachment.id(), request.host(), request.port(), request.method(), request.path(), response.status(), body).         } else if (response.status() == 200) {             return new Attachment.Bytes(attachment.id(), BytesReference.toBytes(response.body()), response.contentType(), attachment.inline()).         } else {             String body = response.body() != null ? response.body().utf8ToString() : null.             String message = LoggerMessageFormat.format("", "Watch[{}] reporting[{}] Unexpected status code host[{}], port[{}], " + "method[{}], path[{}], status[{}], body[{}]", context.watch().id(), attachment.id(), request.host(), request.port(), request.method(), request.path(), response.status(), body).             throw new IllegalStateException(message).         }     }     throw new ElasticsearchException("Watch[{}] reporting[{}]: Aborting due to maximum number of retries hit [{}]", context.watch().id(), attachment.id(), maxRetries). }
false;private;3;9;;private void sleep(long sleepMillis, WatchExecutionContext context, ReportingAttachment attachment) {     try {         Thread.sleep(sleepMillis).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().         throw new ElasticsearchException("Watch[{}] reporting[{}] thread was interrupted, while waiting for polling. Aborting.", context.watch().id(), attachment.id()).     } }
true;private;2;11;/**  * Use the default time to sleep between polls if it was not set  */ ;/**  * Use the default time to sleep between polls if it was not set  */ private long getSleepMillis(WatchExecutionContext context, ReportingAttachment attachment) {     long sleepMillis.     if (attachment.interval() == null) {         sleepMillis = interval.millis().         logger.trace("Watch[{}] reporting[{}] invalid interval configuration [{}], using configured default [{}]", context.watch().id(), attachment.id(), attachment.interval(), this.interval).     } else {         sleepMillis = attachment.interval().millis().     }     return sleepMillis. }
true;private;3;10;/**  * Trigger the initial report generation and catch possible exceptions  */ ;/**  * Trigger the initial report generation and catch possible exceptions  */ private HttpResponse requestReportGeneration(String watchId, String attachmentId, HttpRequest request) throws IOException {     HttpResponse response = httpClient.execute(request).     if (response.status() != 200) {         throw new ElasticsearchException("Watch[{}] reporting[{}] Error response when trying to trigger reporting generation " + "host[{}], port[{}] method[{}], path[{}], status[{}]", watchId, attachmentId, request.host(), request.port(), request.method(), request.path(), response.status()).     }     return response. }
true;private;3;15;/**  * Extract the id from JSON payload, so we know which ID to poll for  */ ;/**  * Extract the id from JSON payload, so we know which ID to poll for  */ private String extractIdFromJson(String watchId, String attachmentId, BytesReference body) throws IOException {     // EMPTY is safe here becaus we never call namedObject     try (InputStream stream = body.streamInput().         XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {         KibanaReportingPayload payload = new KibanaReportingPayload().         PAYLOAD_PARSER.parse(parser, payload, null).         String path = payload.getPath().         if (Strings.isEmpty(path)) {             throw new ElasticsearchException("Watch[{}] reporting[{}] field path found in JSON payload, payload was {}", watchId, attachmentId, body.utf8ToString()).         }         return path.     } }
false;;1;7;;BasicAuth parseAuth(XContentParser parser) {     try {         return BasicAuth.parse(parser).     } catch (IOException e) {         throw new UncheckedIOException(e).     } }
false;;1;7;;HttpProxy parseProxy(XContentParser parser) {     try {         return HttpProxy.parse(parser).     } catch (IOException e) {         throw new UncheckedIOException(e).     } }
false;public;0;3;;public String getPath() {     return path. }
false;public;1;3;;public void setPath(String path) {     this.path = path. }
false;;1;4;;Builder url(String url) {     this.url = url.     return this. }
true;;1;4;// package protected, so it can be used by the object parser in ReportingAttachmentParser ;// package protected, so it can be used by the object parser in ReportingAttachmentParser Builder interval(String waitTime) {     this.interval = TimeValue.parseTimeValue(waitTime, "attachment.reporting.interval").     return this. }
false;;1;4;;Builder retries(Integer retries) {     this.retries = retries.     return this. }
false;;1;4;;Builder inline(boolean inline) {     this.inline = inline.     return this. }
false;;1;4;;Builder auth(BasicAuth auth) {     this.auth = auth.     return this. }
false;;1;4;;Builder proxy(HttpProxy proxy) {     this.proxy = proxy.     return this. }
false;;0;3;;ReportingAttachment build() {     return new ReportingAttachment(id, url, inline, interval, retries, auth, proxy). }
