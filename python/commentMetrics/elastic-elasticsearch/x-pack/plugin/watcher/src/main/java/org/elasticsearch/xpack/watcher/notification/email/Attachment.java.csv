commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;9;;@Override public final MimeBodyPart bodyPart() throws MessagingException {     MimeBodyPart part = new MimeBodyPart().     part.setContentID(id).     part.setFileName(name).     part.setDisposition(inline ? INLINE : ATTACHMENT).     writeTo(part).     return part. }
false;public,abstract;0;1;;public abstract String type().
false;public;0;3;;public boolean isInline() {     return inline. }
true;public,final;2;9;/**  * intentionally not emitting path as it may come as an information leak  */ ;/**  * intentionally not emitting path as it may come as an information leak  */ @Override public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.startObject().field("type", type()).field("id", id).field("name", name).field("content_type", contentType).endObject(). }
false;protected,abstract;1;1;;protected abstract void writeTo(MimeBodyPart part) throws MessagingException.
false;public;0;3;;public Path path() {     return path. }
false;public;0;3;;public String type() {     return TYPE. }
false;public;1;4;;@Override public void writeTo(MimeBodyPart part) throws MessagingException {     part.setDataHandler(new DataHandler(dataSource)). }
false;public;0;3;;public String type() {     return TYPE. }
false;public;0;3;;public byte[] bytes() {     return bytes. }
false;public;1;6;;@Override public void writeTo(MimeBodyPart part) throws MessagingException {     DataSource dataSource = new ByteArrayDataSource(bytes, contentType).     DataHandler handler = new DataHandler(dataSource).     part.setDataHandler(handler). }
false;public;0;4;;@Override public String type() {     return TYPE. }
false;protected;1;6;;@Override protected void writeTo(MimeBodyPart part) throws MessagingException {     DataSource ds = new StreamDataSource(name, contentType, source).     DataHandler dh = new DataHandler(ds).     part.setDataHandler(dh). }
false;public;0;4;;@Override public InputStream getInputStream() throws IOException {     return source.get(). }
false;public;0;4;;@Override public OutputStream getOutputStream() throws IOException {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public String getContentType() {     return contentType. }
false;public;0;4;;@Override public String getName() {     return name. }
false;static;1;10;;static String mimeType(XContentType type) {     switch(type) {         case JSON:             return "application/json".         case YAML:             return "application/yaml".         case SMILE:             return "application/smile".         case CBOR:             return "application/cbor".         default:             throw new IllegalArgumentException("unsupported xcontent attachment type [" + type.name() + "]").     } }
false;static;3;9;;static byte[] bytes(String name, ToXContent content, XContentType type) {     try {         XContentBuilder builder = XContentBuilder.builder(type.xContent()).prettyPrint().         content.toXContent(builder, ToXContent.EMPTY_PARAMS).         return BytesReference.toBytes(BytesReference.bytes(builder)).     } catch (IOException ioe) {         throw new ElasticsearchException("could not create an xcontent attachment [" + name + "]", ioe).     } }
false;public;0;4;;@Override public String type() {     return "yaml". }
false;public;0;4;;@Override public String type() {     return "json". }
