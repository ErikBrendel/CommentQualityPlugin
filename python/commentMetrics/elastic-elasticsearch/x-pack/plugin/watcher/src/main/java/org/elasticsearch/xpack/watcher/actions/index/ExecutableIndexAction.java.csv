commented;modifiers;parameterAmount;loc;comment;code
false;public;3;50;;@Override public Action.Result execute(String actionId, WatchExecutionContext ctx, Payload payload) throws Exception {     Map<String, Object> data = payload.data().     if (data.containsKey("_doc")) {         Object doc = data.get("_doc").         if (doc instanceof Iterable) {             return indexBulk((Iterable) doc, actionId, ctx).         }         if (doc.getClass().isArray()) {             return indexBulk(new ArrayObjectIterator.Iterable(doc), actionId, ctx).         }         if (doc instanceof Map) {             data = (Map<String, Object>) doc.         } else {             throw illegalState("could not execute action [{}] of watch [{}]. failed to index payload data." + "[_data] field must either hold a Map or an List/Array of Maps", actionId, ctx.watch().id()).         }     }     if (data.containsKey(INDEX_FIELD) || data.containsKey(TYPE_FIELD) || data.containsKey(ID_FIELD)) {         data = mutableMap(data).     }     IndexRequest indexRequest = new IndexRequest().     if (action.refreshPolicy != null) {         indexRequest.setRefreshPolicy(action.refreshPolicy).     }     indexRequest.index(getField(actionId, ctx.id().watchId(), "index", data, INDEX_FIELD, action.index)).     indexRequest.type(getField(actionId, ctx.id().watchId(), "type", data, TYPE_FIELD, action.docType)).     indexRequest.id(getField(actionId, ctx.id().watchId(), "id", data, ID_FIELD, action.docId)).     data = addTimestampToDocument(data, ctx.executionTime()).     BytesReference bytesReference.     try (XContentBuilder builder = jsonBuilder()) {         indexRequest.source(builder.prettyPrint().map(data)).     }     if (ctx.simulateAction(actionId)) {         return new IndexAction.Simulated(indexRequest.index(), indexRequest.type(), indexRequest.id(), action.refreshPolicy, new XContentSource(indexRequest.source(), XContentType.JSON)).     }     IndexResponse response = ClientHelper.executeWithHeaders(ctx.watch().status().getHeaders(), ClientHelper.WATCHER_ORIGIN, client, () -> client.index(indexRequest).actionGet(indexDefaultTimeout)).     try (XContentBuilder builder = jsonBuilder()) {         indexResponseToXContent(builder, response).         bytesReference = BytesReference.bytes(builder).     }     return new IndexAction.Result(Status.SUCCESS, new XContentSource(bytesReference, XContentType.JSON)). }
false;;3;52;;Action.Result indexBulk(Iterable list, String actionId, WatchExecutionContext ctx) throws Exception {     if (action.docId != null) {         throw illegalState("could not execute action [{}] of watch [{}]. [doc_id] cannot be used with bulk [_doc] indexing").     }     BulkRequest bulkRequest = new BulkRequest().     if (action.refreshPolicy != null) {         bulkRequest.setRefreshPolicy(action.refreshPolicy).     }     for (Object item : list) {         if (!(item instanceof Map)) {             throw illegalState("could not execute action [{}] of watch [{}]. failed to index payload data. " + "[_data] field must either hold a Map or an List/Array of Maps", actionId, ctx.watch().id()).         }         Map<String, Object> doc = (Map<String, Object>) item.         if (doc.containsKey(INDEX_FIELD) || doc.containsKey(TYPE_FIELD) || doc.containsKey(ID_FIELD)) {             doc = mutableMap(doc).         }         IndexRequest indexRequest = new IndexRequest().         indexRequest.index(getField(actionId, ctx.id().watchId(), "index", doc, INDEX_FIELD, action.index)).         indexRequest.type(getField(actionId, ctx.id().watchId(), "type", doc, TYPE_FIELD, action.docType)).         indexRequest.id(getField(actionId, ctx.id().watchId(), "id", doc, ID_FIELD, action.docId)).         doc = addTimestampToDocument(doc, ctx.executionTime()).         try (XContentBuilder builder = jsonBuilder()) {             indexRequest.source(builder.prettyPrint().map(doc)).         }         bulkRequest.add(indexRequest).     }     BulkResponse bulkResponse = ClientHelper.executeWithHeaders(ctx.watch().status().getHeaders(), ClientHelper.WATCHER_ORIGIN, client, () -> client.bulk(bulkRequest).actionGet(bulkDefaultTimeout)).     try (XContentBuilder jsonBuilder = jsonBuilder().startArray()) {         for (BulkItemResponse item : bulkResponse) {             itemResponseToXContent(jsonBuilder, item).         }         jsonBuilder.endArray().         // different error states, depending on how successful the bulk operation was         long failures = Stream.of(bulkResponse.getItems()).filter(BulkItemResponse::isFailed).count().         if (failures == 0) {             return new IndexAction.Result(Status.SUCCESS, new XContentSource(BytesReference.bytes(jsonBuilder), XContentType.JSON)).         } else if (failures == bulkResponse.getItems().length) {             return new IndexAction.Result(Status.FAILURE, new XContentSource(BytesReference.bytes(jsonBuilder), XContentType.JSON)).         } else {             return new IndexAction.Result(Status.PARTIAL_FAILURE, new XContentSource(BytesReference.bytes(jsonBuilder), XContentType.JSON)).         }     } }
false;private;2;7;;private Map<String, Object> addTimestampToDocument(Map<String, Object> data, ZonedDateTime executionTime) {     if (action.executionTimeField != null) {         data = mutableMap(data).         data.put(action.executionTimeField, WatcherDateTimeUtils.formatDate(executionTime)).     }     return data. }
true;private;6;14;/**  * Extracts the specified field out of data map, or alternative falls back to the action value  */ ;/**  * Extracts the specified field out of data map, or alternative falls back to the action value  */ private String getField(String actionId, String watchId, String name, Map<String, Object> data, String fieldName, String defaultValue) {     Object obj = data.remove(fieldName).     if (obj != null) {         if (defaultValue != null) {             throw illegalState("could not execute action [{}] of watch [{}]. " + "[ctx.payload.{}] or [ctx.payload._doc.{}] were set together with action [{}] field. Only set one of them", actionId, watchId, fieldName, fieldName, name).         } else {             return obj.toString().         }     }     return defaultValue. }
true;private;1;3;/**  * Guarantees that the {@code data} is mutable for any code that needs to modify the {@linkplain Map} before using it (e.g., from  * singleton, immutable {@code Map}s).  *  * @param data The map to make mutable  * @return Always a {@linkplain HashMap}  */ ;/**  * Guarantees that the {@code data} is mutable for any code that needs to modify the {@linkplain Map} before using it (e.g., from  * singleton, immutable {@code Map}s).  *  * @param data The map to make mutable  * @return Always a {@linkplain HashMap}  */ private Map<String, Object> mutableMap(Map<String, Object> data) {     return data instanceof HashMap ? data : new HashMap<>(data). }
false;private,static;2;13;;private static void itemResponseToXContent(XContentBuilder builder, BulkItemResponse item) throws IOException {     if (item.isFailed()) {         builder.startObject().field("failed", item.isFailed()).field("message", item.getFailureMessage()).field("id", item.getId()).field("type", item.getType()).field("index", item.getIndex()).endObject().     } else {         indexResponseToXContent(builder, item.getResponse()).     } }
false;static;2;10;;static void indexResponseToXContent(XContentBuilder builder, IndexResponse response) throws IOException {     builder.startObject().field("created", response.getResult() == DocWriteResponse.Result.CREATED).field("result", response.getResult().getLowercase()).field("id", response.getId()).field("version", response.getVersion()).field("type", response.getType()).field("index", response.getIndex()).endObject(). }
