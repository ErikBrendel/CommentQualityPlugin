commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;14;;public static Map<String, Object> filterMapOrdered(Set<String> keys, XContentParser parser) throws IOException {     try {         if (parser.currentToken() != null) {             throw new IllegalArgumentException("Parser already started").         }         if (parser.nextToken() != START_OBJECT) {             throw new IllegalArgumentException("Content should start with START_OBJECT").         }         State state = new State(new ArrayList<>(keys)).         return parse(parser, state).     } catch (IOException e) {         throw new IOException("could not build a filtered payload out of xcontent", e).     } }
false;private,static;2;3;;private static Map<String, Object> parse(XContentParser parser, State state) throws IOException {     return parse(parser, state, true). }
false;private,static;3;61;;private static Map<String, Object> parse(XContentParser parser, State state, boolean isOutsideOfArray) throws IOException {     if (state.includeLeaf) {         return parser.map().     }     Map<String, Object> data = new HashMap<>().     for (XContentParser.Token token = parser.nextToken(). token != END_OBJECT. token = parser.nextToken()) {         switch(token) {             case FIELD_NAME:                 state.nextField(parser.currentName()).                 break.             case START_OBJECT:                 if (state.includeKey) {                     String fieldName = state.currentFieldName().                     Map<String, Object> nestedData = parse(parser, state, isOutsideOfArray).                     data.put(fieldName, nestedData).                 } else {                     parser.skipChildren().                 }                 if (isOutsideOfArray) {                     state.previousField().                 }                 break.             case START_ARRAY:                 if (state.includeKey) {                     String fieldName = state.currentFieldName().                     List<Object> arrayData = arrayParsing(parser, state).                     data.put(fieldName, arrayData).                 } else {                     parser.skipChildren().                 }                 state.previousField().                 break.             case VALUE_STRING:                 if (state.includeKey) {                     data.put(state.currentFieldName(), parser.text()).                 }                 if (isOutsideOfArray) {                     state.previousField().                 }                 break.             case VALUE_NUMBER:                 if (state.includeKey) {                     data.put(state.currentFieldName(), parser.numberValue()).                 }                 if (isOutsideOfArray) {                     state.previousField().                 }                 break.             case VALUE_BOOLEAN:                 if (state.includeKey) {                     data.put(state.currentFieldName(), parser.booleanValue()).                 }                 if (isOutsideOfArray) {                     state.previousField().                 }                 break.         }     }     return data. }
false;private,static;2;20;;private static List<Object> arrayParsing(XContentParser parser, State state) throws IOException {     List<Object> values = new ArrayList<>().     for (XContentParser.Token token = parser.nextToken(). token != END_ARRAY. token = parser.nextToken()) {         switch(token) {             case START_OBJECT:                 values.add(parse(parser, state, false)).                 break.             case VALUE_STRING:                 values.add(parser.text()).                 break.             case VALUE_NUMBER:                 values.add(parser.numberValue()).                 break.             case VALUE_BOOLEAN:                 values.add(parser.booleanValue()).                 break.         }     }     return values. }
false;;1;20;;void nextField(String fieldName) {     currentFieldName = fieldName.     if (currentPath.length() != 0) {         currentPath.append('.').     }     currentPath = currentPath.append(fieldName).     final String path = currentPath.toString().     for (String extractPath : extractPaths) {         if (path.equals(extractPath)) {             includeKey = true.             includeLeaf = true.             return.         } else if (extractPath.startsWith(path)) {             includeKey = true.             return.         }     }     includeKey = false.     includeLeaf = false. }
false;;0;3;;String currentFieldName() {     return currentFieldName. }
false;;0;10;;void previousField() {     int start = currentPath.lastIndexOf(currentFieldName).     currentPath = currentPath.delete(start, currentPath.length()).     if (currentPath.length() > 0 && currentPath.charAt(currentPath.length() - 1) == '.') {         currentPath = currentPath.deleteCharAt(currentPath.length() - 1).     }     currentFieldName = currentPath.toString().     includeKey = false.     includeLeaf = false. }
