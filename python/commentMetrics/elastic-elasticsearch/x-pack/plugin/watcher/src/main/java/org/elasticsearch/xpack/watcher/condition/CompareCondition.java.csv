commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getPath() {     return path. }
false;public;0;3;;public Op getOp() {     return op. }
false;public;0;3;;public Object getValue() {     return value. }
false;public,static;3;47;;public static CompareCondition parse(Clock clock, String watchId, XContentParser parser) throws IOException {     if (parser.currentToken() != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected an object but found [{}] " + "instead", TYPE, watchId, parser.currentToken()).     }     String path = null.     Object value = null.     Op op = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             path = parser.currentName().         } else if (path == null) {             throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected a field indicating the " + "compared path, but found [{}] instead", TYPE, watchId, token).         } else if (token == XContentParser.Token.START_OBJECT) {             token = parser.nextToken().             if (token != XContentParser.Token.FIELD_NAME) {                 throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected a field indicating the" + " comparison operator, but found [{}] instead", TYPE, watchId, token).             }             try {                 op = Op.resolve(parser.currentName()).             } catch (IllegalArgumentException iae) {                 throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. unknown comparison operator " + "[{}]", TYPE, watchId, parser.currentName()).             }             token = parser.nextToken().             if (!op.supportsStructures() && !token.isValue() && token != XContentParser.Token.VALUE_NULL) {                 throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. compared value for [{}] with " + "operation [{}] must either be a numeric, string, boolean or null value, but found [{}] instead", TYPE, watchId, path, op.name().toLowerCase(Locale.ROOT), token).             }             value = XContentUtils.readValue(parser, token).             token = parser.nextToken().             if (token != XContentParser.Token.END_OBJECT) {                 throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected end of path object, " + "but found [{}] instead", TYPE, watchId, token).             }         } else {             throw new ElasticsearchParseException("could not parse [{}] condition for watch [{}]. expected an object for field [{}] " + "but found [{}] instead", TYPE, watchId, path, token).         }     }     return new CompareCondition(path, op, value, clock). }
false;protected;2;9;;@Override protected Result doExecute(Map<String, Object> model, Map<String, Object> resolvedValues) {     Object configuredValue = resolveConfiguredValue(resolvedValues, model, value).     Object resolvedValue = ObjectPath.eval(path, model).     resolvedValues.put(path, resolvedValue).     return new Result(resolvedValues, TYPE, op.eval(resolvedValue, configuredValue)). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     CompareCondition condition = (CompareCondition) o.     if (!Objects.equals(path, condition.path))         return false.     if (op != condition.op)         return false.     return Objects.equals(value, condition.value). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(path, op, value). }
false;public;2;8;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.startObject().startObject(path).field(op.id(), value).endObject().endObject(). }
false;public;2;5;;@Override public boolean eval(Object v1, Object v2) {     Integer compVal = LenientCompare.compare(v1, v2).     return compVal != null && compVal == 0. }
false;public;0;4;;@Override public boolean supportsStructures() {     return true. }
false;public;2;5;;@Override public boolean eval(Object v1, Object v2) {     Integer compVal = LenientCompare.compare(v1, v2).     return compVal == null || compVal != 0. }
false;public;0;4;;@Override public boolean supportsStructures() {     return true. }
false;public;2;5;;@Override public boolean eval(Object v1, Object v2) {     Integer compVal = LenientCompare.compare(v1, v2).     return compVal != null && compVal < 0. }
false;public;2;5;;@Override public boolean eval(Object v1, Object v2) {     Integer compVal = LenientCompare.compare(v1, v2).     return compVal != null && compVal <= 0. }
false;public;2;5;;@Override public boolean eval(Object v1, Object v2) {     Integer compVal = LenientCompare.compare(v1, v2).     return compVal != null && compVal > 0. }
false;public;2;5;;@Override public boolean eval(Object v1, Object v2) {     Integer compVal = LenientCompare.compare(v1, v2).     return compVal != null && compVal >= 0. }
false;public,abstract;2;1;;public abstract boolean eval(Object v1, Object v2).
false;public;0;3;;public boolean supportsStructures() {     return false. }
false;public;0;3;;public String id() {     return name().toLowerCase(Locale.ROOT). }
false;public,static;1;3;;public static Op resolve(String id) {     return Op.valueOf(id.toUpperCase(Locale.ROOT)). }
