commented;modifiers;parameterAmount;loc;comment;code
false;public;3;14;;@Override public boolean isRedirected(org.apache.http.HttpRequest request, org.apache.http.HttpResponse response, HttpContext context) throws ProtocolException {     boolean isRedirected = super.isRedirected(request, response, context).     if (isRedirected) {         String host = response.getHeaders("Location")[0].getValue().         if (isWhitelisted(host) == false) {             throw new ElasticsearchException("host [" + host + "] is not whitelisted in setting [" + HttpSettings.HOSTS_WHITELIST.getKey() + "], will not redirect").         }     }     return isRedirected. }
false;private;0;52;;private CloseableHttpClient createHttpClient() {     HttpClientBuilder clientBuilder = HttpClientBuilder.create().     // ssl setup     SSLConfiguration sslConfiguration = sslService.getSSLConfiguration(SETTINGS_SSL_PREFIX).     boolean isHostnameVerificationEnabled = sslConfiguration.verificationMode().isHostnameVerificationEnabled().     HostnameVerifier verifier = isHostnameVerificationEnabled ? new DefaultHostnameVerifier() : NoopHostnameVerifier.INSTANCE.     SSLConnectionSocketFactory factory = new SSLConnectionSocketFactory(sslService.sslSocketFactory(sslConfiguration), verifier).     clientBuilder.setSSLSocketFactory(factory).     clientBuilder.evictExpiredConnections().     clientBuilder.setMaxConnPerRoute(MAX_CONNECTIONS).     clientBuilder.setMaxConnTotal(MAX_CONNECTIONS).     clientBuilder.setRedirectStrategy(new DefaultRedirectStrategy() {          @Override         public boolean isRedirected(org.apache.http.HttpRequest request, org.apache.http.HttpResponse response, HttpContext context) throws ProtocolException {             boolean isRedirected = super.isRedirected(request, response, context).             if (isRedirected) {                 String host = response.getHeaders("Location")[0].getValue().                 if (isWhitelisted(host) == false) {                     throw new ElasticsearchException("host [" + host + "] is not whitelisted in setting [" + HttpSettings.HOSTS_WHITELIST.getKey() + "], will not redirect").                 }             }             return isRedirected.         }     }).     clientBuilder.addInterceptorFirst((HttpRequestInterceptor) (request, context) -> {         if (request instanceof HttpRequestWrapper == false) {             throw new ElasticsearchException("unable to check request [{}/{}] for white listing", request, request.getClass().getName()).         }         HttpRequestWrapper wrapper = ((HttpRequestWrapper) request).         final String host.         if (wrapper.getTarget() != null) {             host = wrapper.getTarget().toURI().         } else {             host = wrapper.getOriginal().getRequestLine().getUri().         }         if (isWhitelisted(host) == false) {             throw new ElasticsearchException("host [" + host + "] is not whitelisted in setting [" + HttpSettings.HOSTS_WHITELIST.getKey() + "], will not connect").         }     }).     return clientBuilder.build(). }
false;private;1;3;;private void setWhitelistAutomaton(List<String> whiteListedHosts) {     whitelistAutomaton.set(createAutomaton(whiteListedHosts)). }
false;public;1;107;;public HttpResponse execute(HttpRequest request) throws IOException {     Tuple<HttpHost, URI> tuple = createURI(request).     final URI uri = tuple.v2().     final HttpHost httpHost = tuple.v1().     HttpRequestBase internalRequest.     if (request.method == HttpMethod.HEAD) {         internalRequest = new HttpHead(uri).     } else {         HttpMethodWithEntity methodWithEntity = new HttpMethodWithEntity(uri, request.method.name()).         if (request.hasBody()) {             ByteArrayEntity entity = new ByteArrayEntity(request.body.getBytes(StandardCharsets.UTF_8)).             String contentType = request.headers().get(HttpHeaders.CONTENT_TYPE).             if (Strings.hasLength(contentType)) {                 entity.setContentType(contentType).             } else {                 entity.setContentType(ContentType.TEXT_PLAIN.toString()).             }             methodWithEntity.setEntity(entity).         }         internalRequest = methodWithEntity.     }     internalRequest.setHeader(HttpHeaders.ACCEPT_CHARSET, StandardCharsets.UTF_8.name()).     // headers     if (request.headers().isEmpty() == false) {         for (Map.Entry<String, String> entry : request.headers.entrySet()) {             internalRequest.setHeader(entry.getKey(), entry.getValue()).         }     }     // BWC - hack for input requests made to elasticsearch that do not provide the right content-type header!     if (request.hasBody() && internalRequest.containsHeader("Content-Type") == false) {         XContentType xContentType = XContentFactory.xContentType(request.body()).         if (xContentType != null) {             internalRequest.setHeader("Content-Type", xContentType.mediaType()).         }     }     RequestConfig.Builder config = RequestConfig.custom().     setProxy(config, request, settingsProxy).     HttpClientContext localContext = HttpClientContext.create().     // auth     if (request.auth() != null) {         CredentialsProvider credentialsProvider = new BasicCredentialsProvider().         Credentials credentials = new UsernamePasswordCredentials(request.auth().username, new String(request.auth().password.text(cryptoService))).         credentialsProvider.setCredentials(new AuthScope(request.host, request.port), credentials).         localContext.setCredentialsProvider(credentialsProvider).         // preemptive auth, no need to wait for a 401 first         AuthCache authCache = new BasicAuthCache().         BasicScheme basicAuth = new BasicScheme().         authCache.put(httpHost, basicAuth).         localContext.setAuthCache(authCache).     }     // timeouts     if (request.connectionTimeout() != null) {         config.setConnectTimeout(Math.toIntExact(request.connectionTimeout.millis())).     } else {         config.setConnectTimeout(Math.toIntExact(defaultConnectionTimeout.millis())).     }     if (request.readTimeout() != null) {         config.setSocketTimeout(Math.toIntExact(request.readTimeout.millis())).         config.setConnectionRequestTimeout(Math.toIntExact(request.readTimeout.millis())).     } else {         config.setSocketTimeout(Math.toIntExact(defaultReadTimeout.millis())).         config.setConnectionRequestTimeout(Math.toIntExact(defaultReadTimeout.millis())).     }     internalRequest.setConfig(config.build()).     try (CloseableHttpResponse response = SocketAccess.doPrivileged(() -> client.execute(httpHost, internalRequest, localContext))) {         // headers         Header[] headers = response.getAllHeaders().         Map<String, String[]> responseHeaders = new HashMap<>(headers.length).         for (Header header : headers) {             if (responseHeaders.containsKey(header.getName())) {                 String[] old = responseHeaders.get(header.getName()).                 String[] values = new String[old.length + 1].                 System.arraycopy(old, 0, values, 0, old.length).                 values[values.length - 1] = header.getValue().                 responseHeaders.put(header.getName(), values).             } else {                 responseHeaders.put(header.getName(), new String[] { header.getValue() }).             }         }         final byte[] body.         // not every response has a content, i.e. 204         if (response.getEntity() == null) {             body = new byte[0].         } else {             try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {                 try (InputStream is = new SizeLimitInputStream(maxResponseSize, response.getEntity().getContent())) {                     Streams.copy(is, outputStream).                 }                 body = outputStream.toByteArray().             }         }         return new HttpResponse(response.getStatusLine().getStatusCode(), body, responseHeaders).     } }
true;static;3;12;/**  * Enriches the config object optionally with proxy information  *  * @param config    The request builder config object  * @param request   The request parsed into the HTTP client  */ ;/**  * Enriches the config object optionally with proxy information  *  * @param config    The request builder config object  * @param request   The request parsed into the HTTP client  */ static void setProxy(RequestConfig.Builder config, HttpRequest request, HttpProxy configuredProxy) {     if (request.proxy != null && request.proxy.equals(HttpProxy.NO_PROXY) == false) {         // if a proxy scheme is configured use this, but fall back to the same than the request in case there was no special         // configuration given         String scheme = request.proxy.getScheme() != null ? request.proxy.getScheme().scheme() : Scheme.HTTP.scheme().         HttpHost proxy = new HttpHost(request.proxy.getHost(), request.proxy.getPort(), scheme).         config.setProxy(proxy).     } else if (HttpProxy.NO_PROXY.equals(configuredProxy) == false) {         HttpHost proxy = new HttpHost(configuredProxy.getHost(), configuredProxy.getPort(), configuredProxy.getScheme().scheme()).         config.setProxy(proxy).     } }
true;private;1;18;/**  * Creates an HTTP proxy from the system wide settings  *  * @return An HTTP proxy instance, if no settings are configured this will be an HttpProxy.NO_PROXY instance  */ ;/**  * Creates an HTTP proxy from the system wide settings  *  * @return An HTTP proxy instance, if no settings are configured this will be an HttpProxy.NO_PROXY instance  */ private HttpProxy getProxyFromSettings(Settings settings) {     String proxyHost = HttpSettings.PROXY_HOST.get(settings).     Scheme proxyScheme = HttpSettings.PROXY_SCHEME.exists(settings) ? Scheme.parse(HttpSettings.PROXY_SCHEME.get(settings)) : Scheme.HTTP.     int proxyPort = HttpSettings.PROXY_PORT.get(settings).     if (proxyPort != 0 && Strings.hasText(proxyHost)) {         logger.info("Using default proxy for http input and slack/pagerduty/webhook actions [{}:{}]", proxyHost, proxyPort).     } else if (proxyPort != 0 ^ Strings.hasText(proxyHost)) {         throw new IllegalArgumentException("HTTP proxy requires both settings: [" + HttpSettings.PROXY_HOST.getKey() + "] and [" + HttpSettings.PROXY_PORT.getKey() + "]").     }     if (proxyPort > 0 && Strings.hasText(proxyHost)) {         return new HttpProxy(proxyHost, proxyPort, proxyScheme).     }     return HttpProxy.NO_PROXY. }
false;private;1;31;;private Tuple<HttpHost, URI> createURI(HttpRequest request) {     // url path escaping, and we have done this already, so this would result in double escaping     try {         List<NameValuePair> qparams = new ArrayList<>(request.params.size()).         request.params.forEach((k, v) -> qparams.add(new BasicNameValuePair(k, v))).         String format = URLEncodedUtils.format(qparams, "UTF-8").         URI uri = URIUtils.createURI(request.scheme.scheme(), request.host, request.port, request.path, Strings.isNullOrEmpty(format) ? null : format, null).         if (uri.isAbsolute() == false) {             throw new IllegalStateException("URI [" + uri.toASCIIString() + "] must be absolute").         }         final HttpHost httpHost = URIUtils.extractHost(uri).         // a proxy is not being used. To avoid this we can handle making it relative ourselves         if (request.path != null && request.path.contains("%2F")) {             final boolean isUsingProxy = (request.proxy != null && request.proxy.equals(HttpProxy.NO_PROXY) == false) || HttpProxy.NO_PROXY.equals(settingsProxy) == false.             if (isUsingProxy == false) {                 // we need a relative uri                 uri = URIUtils.createURI(null, null, -1, request.path, Strings.isNullOrEmpty(format) ? null : format, null).             }         }         return new Tuple<>(httpHost, uri).     } catch (URISyntaxException e) {         throw new IllegalArgumentException(e).     } }
false;public;0;4;;@Override public void close() throws IOException {     client.close(). }
false;public;0;4;;@Override public String getMethod() {     return methodName. }
false;private;1;3;;private boolean isWhitelisted(String host) {     return whitelistAutomaton.get().run(host). }
true;static;1;11;// visible for testing ;// visible for testing static CharacterRunAutomaton createAutomaton(List<String> whiteListedHosts) {     if (whiteListedHosts.isEmpty()) {         // we could emit depreciation warning here, if the whitelist is empty         return MATCH_ALL_AUTOMATON.     }     Automaton whiteListAutomaton = Regex.simpleMatchToAutomaton(whiteListedHosts.toArray(Strings.EMPTY_ARRAY)).     whiteListAutomaton = MinimizationOperations.minimize(whiteListAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES).     return new CharacterRunAutomaton(whiteListAutomaton). }
