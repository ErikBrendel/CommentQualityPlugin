commented;modifiers;parameterAmount;loc;comment;code
false;public;3;15;;public String renderTemplate(Script source, WatchExecutionContext ctx, Payload payload) throws IOException {     // Due the inconsistency with templates in ES 1.x, we maintain our own template format.     // This template format we use now, will become the template structure in ES 2.0     Map<String, Object> watcherContextParams = Variables.createCtxParamsMap(ctx, payload).     // convert to the template format used in ES core     if (source.getParams() != null) {         watcherContextParams.putAll(source.getParams()).     }     // Templates are always of lang mustache:     Script template = new Script(source.getType(), source.getType() == ScriptType.STORED ? null : "mustache", source.getIdOrCode(), source.getOptions(), watcherContextParams).     TemplateScript.Factory compiledTemplate = scriptService.compile(template, Watcher.SCRIPT_TEMPLATE_CONTEXT).     return compiledTemplate.newInstance(template.getParams()).execute(). }
false;public;1;19;;public SearchRequest toSearchRequest(WatcherSearchTemplateRequest request) throws IOException {     SearchRequest searchRequest = new SearchRequest(request.getIndices()).     if (request.getTypes() != null) {         searchRequest.types(request.getTypes()).     }     searchRequest.searchType(request.getSearchType()).     searchRequest.indicesOptions(request.getIndicesOptions()).     SearchSourceBuilder sourceBuilder = SearchSourceBuilder.searchSource().     BytesReference source = request.getSearchSource().     if (source != null && source.length() > 0) {         try (InputStream stream = source.streamInput().             XContentParser parser = XContentFactory.xContent(XContentHelper.xContentType(source)).createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, stream)) {             sourceBuilder.parseXContent(parser).             searchRequest.source(sourceBuilder).         }     }     return searchRequest. }
