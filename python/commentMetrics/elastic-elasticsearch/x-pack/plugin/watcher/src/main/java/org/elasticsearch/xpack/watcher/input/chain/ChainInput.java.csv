commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;2;14;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startArray(INPUTS.getPreferredName()).     for (Tuple<String, Input> tuple : inputs) {         builder.startObject().startObject(tuple.v1()).         builder.field(tuple.v2().type(), tuple.v2(), params).         builder.endObject().endObject().     }     builder.endArray().     builder.endObject().     return builder. }
false;public;0;3;;public List<Tuple<String, Input>> getInputs() {     return inputs. }
false;public,static;3;22;;public static ChainInput parse(String watchId, XContentParser parser, InputRegistry inputRegistry) throws IOException {     List<Tuple<String, Input>> inputs = new ArrayList<>().     String currentFieldName.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().             token = parser.nextToken().             if (token == XContentParser.Token.START_ARRAY && INPUTS.getPreferredName().equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token == XContentParser.Token.FIELD_NAME) {                         String inputName = parser.currentName().                         inputs.add(new Tuple<>(inputName, parseSingleInput(watchId, inputName, parser, inputRegistry))).                     }                 }             }         }     }     return new ChainInput(inputs). }
false;private,static;4;16;;private static Input parseSingleInput(String watchId, String name, XContentParser parser, InputRegistry inputRegistry) throws IOException {     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("Expected starting JSON object after [{}] in watch [{}]", name, watchId).     }     Input input = inputRegistry.parse(watchId, parser).input().     // expecting closing of two json object to start the next element in the array     if (parser.currentToken() != XContentParser.Token.END_OBJECT || parser.nextToken() != XContentParser.Token.END_OBJECT) {         throw new ElasticsearchParseException("Expected closing JSON object after parsing input [{}] named [{}] in watch [{}]", input.type(), name, watchId).     }     return input. }
false;public,static;0;3;;public static ChainInput.Builder builder() {     return new Builder(). }
false;public;2;4;;public Builder add(String name, Input.Builder input) {     inputs.add(new Tuple<>(name, input.build())).     return this. }
false;public;0;4;;@Override public ChainInput build() {     return new ChainInput(inputs). }
false;protected;2;10;;@Override protected XContentBuilder typeXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(type).     for (Tuple<String, Input.Result> tuple : results) {         builder.field(tuple.v1(), tuple.v2()).     }     builder.endObject().     return builder. }
