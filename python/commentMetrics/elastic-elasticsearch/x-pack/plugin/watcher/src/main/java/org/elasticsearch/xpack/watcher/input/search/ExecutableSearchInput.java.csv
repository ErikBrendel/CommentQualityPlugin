commented;modifiers;parameterAmount;loc;comment;code
false;public;2;13;;@Override public SearchInput.Result execute(WatchExecutionContext ctx, Payload payload) {     WatcherSearchTemplateRequest request = null.     try {         Script template = input.getRequest().getOrCreateTemplate().         String renderedTemplate = searchTemplateService.renderTemplate(template, ctx, payload).         request = new WatcherSearchTemplateRequest(input.getRequest(), new BytesArray(renderedTemplate)).         return doExecute(ctx, request).     } catch (Exception e) {         logger.error("failed to execute [{}] input for watch [{}], reason [{}]", TYPE, ctx.watch().id(), e.getMessage()).         return new SearchInput.Result(request, e).     } }
false;;2;37;;SearchInput.Result doExecute(WatchExecutionContext ctx, WatcherSearchTemplateRequest request) throws Exception {     if (logger.isTraceEnabled()) {         logger.trace("[{}] running query for [{}] [{}]", ctx.id(), ctx.watch().id(), request.getSearchSource().utf8ToString()).     }     SearchRequest searchRequest = searchTemplateService.toSearchRequest(request).     final SearchResponse response = ClientHelper.executeWithHeaders(ctx.watch().status().getHeaders(), ClientHelper.WATCHER_ORIGIN, client, () -> client.search(searchRequest).actionGet(timeout)).     if (logger.isDebugEnabled()) {         logger.debug("[{}] found [{}] hits", ctx.id(), response.getHits().getTotalHits().value).         for (SearchHit hit : response.getHits()) {             logger.debug("[{}] hit [{}]", ctx.id(), hit.getSourceAsMap()).         }     }     final Payload payload.     final Params params.     if (request.isRestTotalHitsAsint()) {         params = new MapParams(Collections.singletonMap("rest_total_hits_as_int", "true")).     } else {         params = EMPTY_PARAMS.     }     if (input.getExtractKeys() != null) {         BytesReference bytes = XContentHelper.toXContent(response, XContentType.JSON, params, false).         // EMPTY is safe here because we never use namedObject         try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, bytes, XContentType.JSON)) {             Map<String, Object> filteredKeys = XContentFilterKeysUtils.filterMapOrdered(input.getExtractKeys(), parser).             payload = new Payload.Simple(filteredKeys).         }     } else {         payload = new Payload.XContent(response, params).     }     return new SearchInput.Result(request, payload). }
