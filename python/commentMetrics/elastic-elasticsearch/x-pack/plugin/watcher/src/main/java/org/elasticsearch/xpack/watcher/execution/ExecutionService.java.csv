# id;timestamp;commentText;codeText;commentWords;codeWords
ExecutionService -> public int pause();1525334055;Pause the execution of the watcher executor_@return the number of tasks that have been removed;public int pause() {_        paused.set(true)__        int cancelledTaskCount = executor.queue().drainTo(new ArrayList<>())__        this.clearExecutions()__        return cancelledTaskCount__    };pause,the,execution,of,the,watcher,executor,return,the,number,of,tasks,that,have,been,removed;public,int,pause,paused,set,true,int,cancelled,task,count,executor,queue,drain,to,new,array,list,this,clear,executions,return,cancelled,task,count
ExecutionService -> public int pause();1525798021;Pause the execution of the watcher executor, and empty the state._Pausing means, that no new watch executions will be done unless this pausing is explicitely unset._This is important when watcher is stopped, so that scheduled watches do not accidentally get executed._This should not be used when we need to reload watcher based on some cluster state changes, then just calling_{@link #clearExecutionsAndQueue()} is the way to go__@return the number of tasks that have been removed;public int pause() {_        paused.set(true)__        return clearExecutionsAndQueue()__    };pause,the,execution,of,the,watcher,executor,and,empty,the,state,pausing,means,that,no,new,watch,executions,will,be,done,unless,this,pausing,is,explicitely,unset,this,is,important,when,watcher,is,stopped,so,that,scheduled,watches,do,not,accidentally,get,executed,this,should,not,be,used,when,we,need,to,reload,watcher,based,on,some,cluster,state,changes,then,just,calling,link,clear,executions,and,queue,is,the,way,to,go,return,the,number,of,tasks,that,have,been,removed;public,int,pause,paused,set,true,return,clear,executions,and,queue
ExecutionService -> public int pause();1537300661;Pause the execution of the watcher executor, and empty the state._Pausing means, that no new watch executions will be done unless this pausing is explicitely unset._This is important when watcher is stopped, so that scheduled watches do not accidentally get executed._This should not be used when we need to reload watcher based on some cluster state changes, then just calling_{@link #clearExecutionsAndQueue()} is the way to go__@return the number of tasks that have been removed;public int pause() {_        paused.set(true)__        return clearExecutionsAndQueue()__    };pause,the,execution,of,the,watcher,executor,and,empty,the,state,pausing,means,that,no,new,watch,executions,will,be,done,unless,this,pausing,is,explicitely,unset,this,is,important,when,watcher,is,stopped,so,that,scheduled,watches,do,not,accidentally,get,executed,this,should,not,be,used,when,we,need,to,reload,watcher,based,on,some,cluster,state,changes,then,just,calling,link,clear,executions,and,queue,is,the,way,to,go,return,the,number,of,tasks,that,have,been,removed;public,int,pause,paused,set,true,return,clear,executions,and,queue
ExecutionService -> public int pause();1539615817;Pause the execution of the watcher executor, and empty the state._Pausing means, that no new watch executions will be done unless this pausing is explicitly unset._This is important when watcher is stopped, so that scheduled watches do not accidentally get executed._This should not be used when we need to reload watcher based on some cluster state changes, then just calling_{@link #clearExecutionsAndQueue()} is the way to go__@return the number of tasks that have been removed;public int pause() {_        paused.set(true)__        return clearExecutionsAndQueue()__    };pause,the,execution,of,the,watcher,executor,and,empty,the,state,pausing,means,that,no,new,watch,executions,will,be,done,unless,this,pausing,is,explicitly,unset,this,is,important,when,watcher,is,stopped,so,that,scheduled,watches,do,not,accidentally,get,executed,this,should,not,be,used,when,we,need,to,reload,watcher,based,on,some,cluster,state,changes,then,just,calling,link,clear,executions,and,queue,is,the,way,to,go,return,the,number,of,tasks,that,have,been,removed;public,int,pause,paused,set,true,return,clear,executions,and,queue
ExecutionService -> public int pause();1541092382;Pause the execution of the watcher executor, and empty the state._Pausing means, that no new watch executions will be done unless this pausing is explicitly unset._This is important when watcher is stopped, so that scheduled watches do not accidentally get executed._This should not be used when we need to reload watcher based on some cluster state changes, then just calling_{@link #clearExecutionsAndQueue()} is the way to go__@return the number of tasks that have been removed;public int pause() {_        paused.set(true)__        return clearExecutionsAndQueue()__    };pause,the,execution,of,the,watcher,executor,and,empty,the,state,pausing,means,that,no,new,watch,executions,will,be,done,unless,this,pausing,is,explicitly,unset,this,is,important,when,watcher,is,stopped,so,that,scheduled,watches,do,not,accidentally,get,executed,this,should,not,be,used,when,we,need,to,reload,watcher,based,on,some,cluster,state,changes,then,just,calling,link,clear,executions,and,queue,is,the,way,to,go,return,the,number,of,tasks,that,have,been,removed;public,int,pause,paused,set,true,return,clear,executions,and,queue
ExecutionService -> public int pause();1543343306;Pause the execution of the watcher executor, and empty the state._Pausing means, that no new watch executions will be done unless this pausing is explicitly unset._This is important when watcher is stopped, so that scheduled watches do not accidentally get executed._This should not be used when we need to reload watcher based on some cluster state changes, then just calling_{@link #clearExecutionsAndQueue()} is the way to go__@return the number of tasks that have been removed;public int pause() {_        paused.set(true)__        return clearExecutionsAndQueue()__    };pause,the,execution,of,the,watcher,executor,and,empty,the,state,pausing,means,that,no,new,watch,executions,will,be,done,unless,this,pausing,is,explicitly,unset,this,is,important,when,watcher,is,stopped,so,that,scheduled,watches,do,not,accidentally,get,executed,this,should,not,be,used,when,we,need,to,reload,watcher,based,on,some,cluster,state,changes,then,just,calling,link,clear,executions,and,queue,is,the,way,to,go,return,the,number,of,tasks,that,have,been,removed;public,int,pause,paused,set,true,return,clear,executions,and,queue
ExecutionService -> public int pause();1548897299;Pause the execution of the watcher executor, and empty the state._Pausing means, that no new watch executions will be done unless this pausing is explicitly unset._This is important when watcher is stopped, so that scheduled watches do not accidentally get executed._This should not be used when we need to reload watcher based on some cluster state changes, then just calling_{@link #clearExecutionsAndQueue()} is the way to go__@return the number of tasks that have been removed;public int pause() {_        paused.set(true)__        return clearExecutionsAndQueue()__    };pause,the,execution,of,the,watcher,executor,and,empty,the,state,pausing,means,that,no,new,watch,executions,will,be,done,unless,this,pausing,is,explicitly,unset,this,is,important,when,watcher,is,stopped,so,that,scheduled,watches,do,not,accidentally,get,executed,this,should,not,be,used,when,we,need,to,reload,watcher,based,on,some,cluster,state,changes,then,just,calling,link,clear,executions,and,queue,is,the,way,to,go,return,the,number,of,tasks,that,have,been,removed;public,int,pause,paused,set,true,return,clear,executions,and,queue
ExecutionService -> public int pause();1549289311;Pause the execution of the watcher executor, and empty the state._Pausing means, that no new watch executions will be done unless this pausing is explicitly unset._This is important when watcher is stopped, so that scheduled watches do not accidentally get executed._This should not be used when we need to reload watcher based on some cluster state changes, then just calling_{@link #clearExecutionsAndQueue()} is the way to go__@return the number of tasks that have been removed;public int pause() {_        paused.set(true)__        return clearExecutionsAndQueue()__    };pause,the,execution,of,the,watcher,executor,and,empty,the,state,pausing,means,that,no,new,watch,executions,will,be,done,unless,this,pausing,is,explicitly,unset,this,is,important,when,watcher,is,stopped,so,that,scheduled,watches,do,not,accidentally,get,executed,this,should,not,be,used,when,we,need,to,reload,watcher,based,on,some,cluster,state,changes,then,just,calling,link,clear,executions,and,queue,is,the,way,to,go,return,the,number,of,tasks,that,have,been,removed;public,int,pause,paused,set,true,return,clear,executions,and,queue
ExecutionService -> private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events);1524684173;Create a tuple of triggered watches and their corresponding contexts, usable for sync and async processing__@param events The iterable list of trigger events to create the two lists from_@return       Two linked lists that contain the triggered watches and contexts;private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events) {_        final LinkedList<TriggeredWatch> triggeredWatches = new LinkedList<>()__        final LinkedList<TriggeredExecutionContext> contexts = new LinkedList<>()___        DateTime now = new DateTime(clock.millis(), UTC)__        for (TriggerEvent event : events) {_            GetResponse response = getWatch(event.jobName())__            if (response.isExists() == false) {_                logger.warn("unable to find watch [{}] in watch index, perhaps it has been deleted", event.jobName())__                continue__            }_            TriggeredExecutionContext ctx = new TriggeredExecutionContext(event.jobName(), now, event, defaultThrottlePeriod)__            contexts.add(ctx)__            triggeredWatches.add(new TriggeredWatch(ctx.id(), event))__        }__        return Tuple.tuple(triggeredWatches, contexts)__    };create,a,tuple,of,triggered,watches,and,their,corresponding,contexts,usable,for,sync,and,async,processing,param,events,the,iterable,list,of,trigger,events,to,create,the,two,lists,from,return,two,linked,lists,that,contain,the,triggered,watches,and,contexts;private,tuple,list,triggered,watch,list,triggered,execution,context,create,triggered,watches,and,context,iterable,trigger,event,events,final,linked,list,triggered,watch,triggered,watches,new,linked,list,final,linked,list,triggered,execution,context,contexts,new,linked,list,date,time,now,new,date,time,clock,millis,utc,for,trigger,event,event,events,get,response,response,get,watch,event,job,name,if,response,is,exists,false,logger,warn,unable,to,find,watch,in,watch,index,perhaps,it,has,been,deleted,event,job,name,continue,triggered,execution,context,ctx,new,triggered,execution,context,event,job,name,now,event,default,throttle,period,contexts,add,ctx,triggered,watches,add,new,triggered,watch,ctx,id,event,return,tuple,tuple,triggered,watches,contexts
ExecutionService -> private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events);1525334055;Create a tuple of triggered watches and their corresponding contexts, usable for sync and async processing__@param events The iterable list of trigger events to create the two lists from_@return       Two linked lists that contain the triggered watches and contexts;private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events) {_        final LinkedList<TriggeredWatch> triggeredWatches = new LinkedList<>()__        final LinkedList<TriggeredExecutionContext> contexts = new LinkedList<>()___        DateTime now = new DateTime(clock.millis(), UTC)__        for (TriggerEvent event : events) {_            GetResponse response = getWatch(event.jobName())__            if (response.isExists() == false) {_                logger.warn("unable to find watch [{}] in watch index, perhaps it has been deleted", event.jobName())__                continue__            }_            TriggeredExecutionContext ctx = new TriggeredExecutionContext(event.jobName(), now, event, defaultThrottlePeriod)__            contexts.add(ctx)__            triggeredWatches.add(new TriggeredWatch(ctx.id(), event))__        }__        return Tuple.tuple(triggeredWatches, contexts)__    };create,a,tuple,of,triggered,watches,and,their,corresponding,contexts,usable,for,sync,and,async,processing,param,events,the,iterable,list,of,trigger,events,to,create,the,two,lists,from,return,two,linked,lists,that,contain,the,triggered,watches,and,contexts;private,tuple,list,triggered,watch,list,triggered,execution,context,create,triggered,watches,and,context,iterable,trigger,event,events,final,linked,list,triggered,watch,triggered,watches,new,linked,list,final,linked,list,triggered,execution,context,contexts,new,linked,list,date,time,now,new,date,time,clock,millis,utc,for,trigger,event,event,events,get,response,response,get,watch,event,job,name,if,response,is,exists,false,logger,warn,unable,to,find,watch,in,watch,index,perhaps,it,has,been,deleted,event,job,name,continue,triggered,execution,context,ctx,new,triggered,execution,context,event,job,name,now,event,default,throttle,period,contexts,add,ctx,triggered,watches,add,new,triggered,watch,ctx,id,event,return,tuple,tuple,triggered,watches,contexts
ExecutionService -> private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events);1525798021;Create a tuple of triggered watches and their corresponding contexts, usable for sync and async processing__@param events The iterable list of trigger events to create the two lists from_@return       Two linked lists that contain the triggered watches and contexts;private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events) {_        final LinkedList<TriggeredWatch> triggeredWatches = new LinkedList<>()__        final LinkedList<TriggeredExecutionContext> contexts = new LinkedList<>()___        DateTime now = new DateTime(clock.millis(), UTC)__        for (TriggerEvent event : events) {_            GetResponse response = getWatch(event.jobName())__            if (response.isExists() == false) {_                logger.warn("unable to find watch [{}] in watch index, perhaps it has been deleted", event.jobName())__                continue__            }_            TriggeredExecutionContext ctx = new TriggeredExecutionContext(event.jobName(), now, event, defaultThrottlePeriod)__            contexts.add(ctx)__            triggeredWatches.add(new TriggeredWatch(ctx.id(), event))__        }__        return Tuple.tuple(triggeredWatches, contexts)__    };create,a,tuple,of,triggered,watches,and,their,corresponding,contexts,usable,for,sync,and,async,processing,param,events,the,iterable,list,of,trigger,events,to,create,the,two,lists,from,return,two,linked,lists,that,contain,the,triggered,watches,and,contexts;private,tuple,list,triggered,watch,list,triggered,execution,context,create,triggered,watches,and,context,iterable,trigger,event,events,final,linked,list,triggered,watch,triggered,watches,new,linked,list,final,linked,list,triggered,execution,context,contexts,new,linked,list,date,time,now,new,date,time,clock,millis,utc,for,trigger,event,event,events,get,response,response,get,watch,event,job,name,if,response,is,exists,false,logger,warn,unable,to,find,watch,in,watch,index,perhaps,it,has,been,deleted,event,job,name,continue,triggered,execution,context,ctx,new,triggered,execution,context,event,job,name,now,event,default,throttle,period,contexts,add,ctx,triggered,watches,add,new,triggered,watch,ctx,id,event,return,tuple,tuple,triggered,watches,contexts
ExecutionService -> private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events);1537300661;Create a tuple of triggered watches and their corresponding contexts, usable for sync and async processing__@param events The iterable list of trigger events to create the two lists from_@return       Two linked lists that contain the triggered watches and contexts;private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events) {_        final LinkedList<TriggeredWatch> triggeredWatches = new LinkedList<>()__        final LinkedList<TriggeredExecutionContext> contexts = new LinkedList<>()___        DateTime now = new DateTime(clock.millis(), UTC)__        for (TriggerEvent event : events) {_            GetResponse response = getWatch(event.jobName())__            if (response.isExists() == false) {_                logger.warn("unable to find watch [{}] in watch index, perhaps it has been deleted", event.jobName())__                continue__            }_            TriggeredExecutionContext ctx = new TriggeredExecutionContext(event.jobName(), now, event, defaultThrottlePeriod)__            contexts.add(ctx)__            triggeredWatches.add(new TriggeredWatch(ctx.id(), event))__        }__        return Tuple.tuple(triggeredWatches, contexts)__    };create,a,tuple,of,triggered,watches,and,their,corresponding,contexts,usable,for,sync,and,async,processing,param,events,the,iterable,list,of,trigger,events,to,create,the,two,lists,from,return,two,linked,lists,that,contain,the,triggered,watches,and,contexts;private,tuple,list,triggered,watch,list,triggered,execution,context,create,triggered,watches,and,context,iterable,trigger,event,events,final,linked,list,triggered,watch,triggered,watches,new,linked,list,final,linked,list,triggered,execution,context,contexts,new,linked,list,date,time,now,new,date,time,clock,millis,utc,for,trigger,event,event,events,get,response,response,get,watch,event,job,name,if,response,is,exists,false,logger,warn,unable,to,find,watch,in,watch,index,perhaps,it,has,been,deleted,event,job,name,continue,triggered,execution,context,ctx,new,triggered,execution,context,event,job,name,now,event,default,throttle,period,contexts,add,ctx,triggered,watches,add,new,triggered,watch,ctx,id,event,return,tuple,tuple,triggered,watches,contexts
ExecutionService -> private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events);1539615817;Create a tuple of triggered watches and their corresponding contexts, usable for sync and async processing__@param events The iterable list of trigger events to create the two lists from_@return       Two linked lists that contain the triggered watches and contexts;private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events) {_        final LinkedList<TriggeredWatch> triggeredWatches = new LinkedList<>()__        final LinkedList<TriggeredExecutionContext> contexts = new LinkedList<>()___        DateTime now = new DateTime(clock.millis(), UTC)__        for (TriggerEvent event : events) {_            GetResponse response = getWatch(event.jobName())__            if (response.isExists() == false) {_                logger.warn("unable to find watch [{}] in watch index, perhaps it has been deleted", event.jobName())__                continue__            }_            TriggeredExecutionContext ctx = new TriggeredExecutionContext(event.jobName(), now, event, defaultThrottlePeriod)__            contexts.add(ctx)__            triggeredWatches.add(new TriggeredWatch(ctx.id(), event))__        }__        return Tuple.tuple(triggeredWatches, contexts)__    };create,a,tuple,of,triggered,watches,and,their,corresponding,contexts,usable,for,sync,and,async,processing,param,events,the,iterable,list,of,trigger,events,to,create,the,two,lists,from,return,two,linked,lists,that,contain,the,triggered,watches,and,contexts;private,tuple,list,triggered,watch,list,triggered,execution,context,create,triggered,watches,and,context,iterable,trigger,event,events,final,linked,list,triggered,watch,triggered,watches,new,linked,list,final,linked,list,triggered,execution,context,contexts,new,linked,list,date,time,now,new,date,time,clock,millis,utc,for,trigger,event,event,events,get,response,response,get,watch,event,job,name,if,response,is,exists,false,logger,warn,unable,to,find,watch,in,watch,index,perhaps,it,has,been,deleted,event,job,name,continue,triggered,execution,context,ctx,new,triggered,execution,context,event,job,name,now,event,default,throttle,period,contexts,add,ctx,triggered,watches,add,new,triggered,watch,ctx,id,event,return,tuple,tuple,triggered,watches,contexts
ExecutionService -> private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events);1541092382;Create a tuple of triggered watches and their corresponding contexts, usable for sync and async processing__@param events The iterable list of trigger events to create the two lists from_@return       Two linked lists that contain the triggered watches and contexts;private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events) {_        final LinkedList<TriggeredWatch> triggeredWatches = new LinkedList<>()__        final LinkedList<TriggeredExecutionContext> contexts = new LinkedList<>()___        DateTime now = new DateTime(clock.millis(), UTC)__        for (TriggerEvent event : events) {_            GetResponse response = getWatch(event.jobName())__            if (response.isExists() == false) {_                logger.warn("unable to find watch [{}] in watch index, perhaps it has been deleted", event.jobName())__                continue__            }_            TriggeredExecutionContext ctx = new TriggeredExecutionContext(event.jobName(), now, event, defaultThrottlePeriod)__            contexts.add(ctx)__            triggeredWatches.add(new TriggeredWatch(ctx.id(), event))__        }__        return Tuple.tuple(triggeredWatches, contexts)__    };create,a,tuple,of,triggered,watches,and,their,corresponding,contexts,usable,for,sync,and,async,processing,param,events,the,iterable,list,of,trigger,events,to,create,the,two,lists,from,return,two,linked,lists,that,contain,the,triggered,watches,and,contexts;private,tuple,list,triggered,watch,list,triggered,execution,context,create,triggered,watches,and,context,iterable,trigger,event,events,final,linked,list,triggered,watch,triggered,watches,new,linked,list,final,linked,list,triggered,execution,context,contexts,new,linked,list,date,time,now,new,date,time,clock,millis,utc,for,trigger,event,event,events,get,response,response,get,watch,event,job,name,if,response,is,exists,false,logger,warn,unable,to,find,watch,in,watch,index,perhaps,it,has,been,deleted,event,job,name,continue,triggered,execution,context,ctx,new,triggered,execution,context,event,job,name,now,event,default,throttle,period,contexts,add,ctx,triggered,watches,add,new,triggered,watch,ctx,id,event,return,tuple,tuple,triggered,watches,contexts
ExecutionService -> private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events);1543343306;Create a tuple of triggered watches and their corresponding contexts, usable for sync and async processing__@param events The iterable list of trigger events to create the two lists from_@return       Two linked lists that contain the triggered watches and contexts;private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events) {_        final LinkedList<TriggeredWatch> triggeredWatches = new LinkedList<>()__        final LinkedList<TriggeredExecutionContext> contexts = new LinkedList<>()___        DateTime now = new DateTime(clock.millis(), UTC)__        for (TriggerEvent event : events) {_            GetResponse response = getWatch(event.jobName())__            if (response.isExists() == false) {_                logger.warn("unable to find watch [{}] in watch index, perhaps it has been deleted", event.jobName())__                continue__            }_            TriggeredExecutionContext ctx = new TriggeredExecutionContext(event.jobName(), now, event, defaultThrottlePeriod)__            contexts.add(ctx)__            triggeredWatches.add(new TriggeredWatch(ctx.id(), event))__        }__        return Tuple.tuple(triggeredWatches, contexts)__    };create,a,tuple,of,triggered,watches,and,their,corresponding,contexts,usable,for,sync,and,async,processing,param,events,the,iterable,list,of,trigger,events,to,create,the,two,lists,from,return,two,linked,lists,that,contain,the,triggered,watches,and,contexts;private,tuple,list,triggered,watch,list,triggered,execution,context,create,triggered,watches,and,context,iterable,trigger,event,events,final,linked,list,triggered,watch,triggered,watches,new,linked,list,final,linked,list,triggered,execution,context,contexts,new,linked,list,date,time,now,new,date,time,clock,millis,utc,for,trigger,event,event,events,get,response,response,get,watch,event,job,name,if,response,is,exists,false,logger,warn,unable,to,find,watch,in,watch,index,perhaps,it,has,been,deleted,event,job,name,continue,triggered,execution,context,ctx,new,triggered,execution,context,event,job,name,now,event,default,throttle,period,contexts,add,ctx,triggered,watches,add,new,triggered,watch,ctx,id,event,return,tuple,tuple,triggered,watches,contexts
ExecutionService -> private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events);1548897299;Create a tuple of triggered watches and their corresponding contexts, usable for sync and async processing__@param events The iterable list of trigger events to create the two lists from_@return       Two linked lists that contain the triggered watches and contexts;private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events) {_        final LinkedList<TriggeredWatch> triggeredWatches = new LinkedList<>()__        final LinkedList<TriggeredExecutionContext> contexts = new LinkedList<>()___        DateTime now = new DateTime(clock.millis(), UTC)__        for (TriggerEvent event : events) {_            GetResponse response = getWatch(event.jobName())__            if (response.isExists() == false) {_                logger.warn("unable to find watch [{}] in watch index, perhaps it has been deleted", event.jobName())__                continue__            }_            TriggeredExecutionContext ctx = new TriggeredExecutionContext(event.jobName(), now, event, defaultThrottlePeriod)__            contexts.add(ctx)__            triggeredWatches.add(new TriggeredWatch(ctx.id(), event))__        }__        return Tuple.tuple(triggeredWatches, contexts)__    };create,a,tuple,of,triggered,watches,and,their,corresponding,contexts,usable,for,sync,and,async,processing,param,events,the,iterable,list,of,trigger,events,to,create,the,two,lists,from,return,two,linked,lists,that,contain,the,triggered,watches,and,contexts;private,tuple,list,triggered,watch,list,triggered,execution,context,create,triggered,watches,and,context,iterable,trigger,event,events,final,linked,list,triggered,watch,triggered,watches,new,linked,list,final,linked,list,triggered,execution,context,contexts,new,linked,list,date,time,now,new,date,time,clock,millis,utc,for,trigger,event,event,events,get,response,response,get,watch,event,job,name,if,response,is,exists,false,logger,warn,unable,to,find,watch,in,watch,index,perhaps,it,has,been,deleted,event,job,name,continue,triggered,execution,context,ctx,new,triggered,execution,context,event,job,name,now,event,default,throttle,period,contexts,add,ctx,triggered,watches,add,new,triggered,watch,ctx,id,event,return,tuple,tuple,triggered,watches,contexts
ExecutionService -> private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events);1549289311;Create a tuple of triggered watches and their corresponding contexts, usable for sync and async processing__@param events The iterable list of trigger events to create the two lists from_@return       Two linked lists that contain the triggered watches and contexts;private Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> createTriggeredWatchesAndContext(Iterable<TriggerEvent> events) {_        final LinkedList<TriggeredWatch> triggeredWatches = new LinkedList<>()__        final LinkedList<TriggeredExecutionContext> contexts = new LinkedList<>()___        ZonedDateTime now = clock.instant().atZone(ZoneOffset.UTC)__        for (TriggerEvent event : events) {_            GetResponse response = getWatch(event.jobName())__            if (response.isExists() == false) {_                logger.warn("unable to find watch [{}] in watch index, perhaps it has been deleted", event.jobName())__                continue__            }_            TriggeredExecutionContext ctx = new TriggeredExecutionContext(event.jobName(), now, event, defaultThrottlePeriod)__            contexts.add(ctx)__            triggeredWatches.add(new TriggeredWatch(ctx.id(), event))__        }__        return Tuple.tuple(triggeredWatches, contexts)__    };create,a,tuple,of,triggered,watches,and,their,corresponding,contexts,usable,for,sync,and,async,processing,param,events,the,iterable,list,of,trigger,events,to,create,the,two,lists,from,return,two,linked,lists,that,contain,the,triggered,watches,and,contexts;private,tuple,list,triggered,watch,list,triggered,execution,context,create,triggered,watches,and,context,iterable,trigger,event,events,final,linked,list,triggered,watch,triggered,watches,new,linked,list,final,linked,list,triggered,execution,context,contexts,new,linked,list,zoned,date,time,now,clock,instant,at,zone,zone,offset,utc,for,trigger,event,event,events,get,response,response,get,watch,event,job,name,if,response,is,exists,false,logger,warn,unable,to,find,watch,in,watch,index,perhaps,it,has,been,deleted,event,job,name,continue,triggered,execution,context,ctx,new,triggered,execution,context,event,job,name,now,event,default,throttle,period,contexts,add,ctx,triggered,watches,add,new,triggered,watch,ctx,id,event,return,tuple,tuple,triggered,watches,contexts
ExecutionService -> private void clearExecutions();1525334055;This clears out the current executions and sets new empty current executions_This is needed, because when this method is called, watcher keeps running, so sealing executions would be a bad idea;private void clearExecutions() {_        final CurrentExecutions currentExecutionsBeforeSetting = currentExecutions.getAndSet(new CurrentExecutions())__        _        genericExecutor.execute(() -> currentExecutionsBeforeSetting.sealAndAwaitEmpty(maxStopTimeout))__    };this,clears,out,the,current,executions,and,sets,new,empty,current,executions,this,is,needed,because,when,this,method,is,called,watcher,keeps,running,so,sealing,executions,would,be,a,bad,idea;private,void,clear,executions,final,current,executions,current,executions,before,setting,current,executions,get,and,set,new,current,executions,generic,executor,execute,current,executions,before,setting,seal,and,await,empty,max,stop,timeout
ExecutionService -> private void clearExecutions();1525798021;This clears out the current executions and sets new empty current executions_This is needed, because when this method is called, watcher keeps running, so sealing executions would be a bad idea;private void clearExecutions() {_        final CurrentExecutions currentExecutionsBeforeSetting = currentExecutions.getAndSet(new CurrentExecutions())__        _        genericExecutor.execute(() -> currentExecutionsBeforeSetting.sealAndAwaitEmpty(maxStopTimeout))__    };this,clears,out,the,current,executions,and,sets,new,empty,current,executions,this,is,needed,because,when,this,method,is,called,watcher,keeps,running,so,sealing,executions,would,be,a,bad,idea;private,void,clear,executions,final,current,executions,current,executions,before,setting,current,executions,get,and,set,new,current,executions,generic,executor,execute,current,executions,before,setting,seal,and,await,empty,max,stop,timeout
ExecutionService -> private void clearExecutions();1537300661;This clears out the current executions and sets new empty current executions_This is needed, because when this method is called, watcher keeps running, so sealing executions would be a bad idea;private void clearExecutions() {_        final CurrentExecutions currentExecutionsBeforeSetting = currentExecutions.getAndSet(new CurrentExecutions())__        _        genericExecutor.execute(() -> currentExecutionsBeforeSetting.sealAndAwaitEmpty(maxStopTimeout))__    };this,clears,out,the,current,executions,and,sets,new,empty,current,executions,this,is,needed,because,when,this,method,is,called,watcher,keeps,running,so,sealing,executions,would,be,a,bad,idea;private,void,clear,executions,final,current,executions,current,executions,before,setting,current,executions,get,and,set,new,current,executions,generic,executor,execute,current,executions,before,setting,seal,and,await,empty,max,stop,timeout
ExecutionService -> private void clearExecutions();1539615817;This clears out the current executions and sets new empty current executions_This is needed, because when this method is called, watcher keeps running, so sealing executions would be a bad idea;private void clearExecutions() {_        final CurrentExecutions currentExecutionsBeforeSetting = currentExecutions.getAndSet(new CurrentExecutions())__        _        genericExecutor.execute(() -> currentExecutionsBeforeSetting.sealAndAwaitEmpty(maxStopTimeout))__    };this,clears,out,the,current,executions,and,sets,new,empty,current,executions,this,is,needed,because,when,this,method,is,called,watcher,keeps,running,so,sealing,executions,would,be,a,bad,idea;private,void,clear,executions,final,current,executions,current,executions,before,setting,current,executions,get,and,set,new,current,executions,generic,executor,execute,current,executions,before,setting,seal,and,await,empty,max,stop,timeout
ExecutionService -> private void clearExecutions();1541092382;This clears out the current executions and sets new empty current executions_This is needed, because when this method is called, watcher keeps running, so sealing executions would be a bad idea;private void clearExecutions() {_        final CurrentExecutions currentExecutionsBeforeSetting = currentExecutions.getAndSet(new CurrentExecutions())__        _        genericExecutor.execute(() -> currentExecutionsBeforeSetting.sealAndAwaitEmpty(maxStopTimeout))__    };this,clears,out,the,current,executions,and,sets,new,empty,current,executions,this,is,needed,because,when,this,method,is,called,watcher,keeps,running,so,sealing,executions,would,be,a,bad,idea;private,void,clear,executions,final,current,executions,current,executions,before,setting,current,executions,get,and,set,new,current,executions,generic,executor,execute,current,executions,before,setting,seal,and,await,empty,max,stop,timeout
ExecutionService -> private void clearExecutions();1543343306;This clears out the current executions and sets new empty current executions_This is needed, because when this method is called, watcher keeps running, so sealing executions would be a bad idea;private void clearExecutions() {_        final CurrentExecutions currentExecutionsBeforeSetting = currentExecutions.getAndSet(new CurrentExecutions())__        _        genericExecutor.execute(() -> currentExecutionsBeforeSetting.sealAndAwaitEmpty(maxStopTimeout))__    };this,clears,out,the,current,executions,and,sets,new,empty,current,executions,this,is,needed,because,when,this,method,is,called,watcher,keeps,running,so,sealing,executions,would,be,a,bad,idea;private,void,clear,executions,final,current,executions,current,executions,before,setting,current,executions,get,and,set,new,current,executions,generic,executor,execute,current,executions,before,setting,seal,and,await,empty,max,stop,timeout
ExecutionService -> private void clearExecutions();1548897299;This clears out the current executions and sets new empty current executions_This is needed, because when this method is called, watcher keeps running, so sealing executions would be a bad idea;private void clearExecutions() {_        final CurrentExecutions currentExecutionsBeforeSetting = currentExecutions.getAndSet(new CurrentExecutions())__        _        genericExecutor.execute(() -> currentExecutionsBeforeSetting.sealAndAwaitEmpty(maxStopTimeout))__    };this,clears,out,the,current,executions,and,sets,new,empty,current,executions,this,is,needed,because,when,this,method,is,called,watcher,keeps,running,so,sealing,executions,would,be,a,bad,idea;private,void,clear,executions,final,current,executions,current,executions,before,setting,current,executions,get,and,set,new,current,executions,generic,executor,execute,current,executions,before,setting,seal,and,await,empty,max,stop,timeout
ExecutionService -> private void clearExecutions();1549289311;This clears out the current executions and sets new empty current executions_This is needed, because when this method is called, watcher keeps running, so sealing executions would be a bad idea;private void clearExecutions() {_        final CurrentExecutions currentExecutionsBeforeSetting = currentExecutions.getAndSet(new CurrentExecutions())__        _        genericExecutor.execute(() -> currentExecutionsBeforeSetting.sealAndAwaitEmpty(maxStopTimeout))__    };this,clears,out,the,current,executions,and,sets,new,empty,current,executions,this,is,needed,because,when,this,method,is,called,watcher,keeps,running,so,sealing,executions,would,be,a,bad,idea;private,void,clear,executions,final,current,executions,current,executions,before,setting,current,executions,get,and,set,new,current,executions,generic,executor,execute,current,executions,before,setting,seal,and,await,empty,max,stop,timeout
ExecutionService -> private void executeTriggeredWatches(final BulkResponse response,                                          final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext);1524684173;Execute triggered watches, which have been successfully indexed into the triggered watches index__@param response            The bulk response containing the response of indexing triggered watches_@param watchesAndContext   The triggered watches and context objects needed for execution;private void executeTriggeredWatches(final BulkResponse response,_                                         final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext) {_        for (int i = 0_ i < response.getItems().length_ i++) {_            BulkItemResponse itemResponse = response.getItems()[i]__            if (itemResponse.isFailed()) {_                logger.error("could not store triggered watch with id [{}]: [{}]", itemResponse.getId(), itemResponse.getFailureMessage())__            } else {_                executeAsync(watchesAndContext.v2().get(i), watchesAndContext.v1().get(i))__            }_        }_    };execute,triggered,watches,which,have,been,successfully,indexed,into,the,triggered,watches,index,param,response,the,bulk,response,containing,the,response,of,indexing,triggered,watches,param,watches,and,context,the,triggered,watches,and,context,objects,needed,for,execution;private,void,execute,triggered,watches,final,bulk,response,response,final,tuple,list,triggered,watch,list,triggered,execution,context,watches,and,context,for,int,i,0,i,response,get,items,length,i,bulk,item,response,item,response,response,get,items,i,if,item,response,is,failed,logger,error,could,not,store,triggered,watch,with,id,item,response,get,id,item,response,get,failure,message,else,execute,async,watches,and,context,v2,get,i,watches,and,context,v1,get,i
ExecutionService -> private void executeTriggeredWatches(final BulkResponse response,                                          final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext);1525334055;Execute triggered watches, which have been successfully indexed into the triggered watches index__@param response            The bulk response containing the response of indexing triggered watches_@param watchesAndContext   The triggered watches and context objects needed for execution;private void executeTriggeredWatches(final BulkResponse response,_                                         final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext) {_        for (int i = 0_ i < response.getItems().length_ i++) {_            BulkItemResponse itemResponse = response.getItems()[i]__            if (itemResponse.isFailed()) {_                logger.error("could not store triggered watch with id [{}]: [{}]", itemResponse.getId(), itemResponse.getFailureMessage())__            } else {_                executeAsync(watchesAndContext.v2().get(i), watchesAndContext.v1().get(i))__            }_        }_    };execute,triggered,watches,which,have,been,successfully,indexed,into,the,triggered,watches,index,param,response,the,bulk,response,containing,the,response,of,indexing,triggered,watches,param,watches,and,context,the,triggered,watches,and,context,objects,needed,for,execution;private,void,execute,triggered,watches,final,bulk,response,response,final,tuple,list,triggered,watch,list,triggered,execution,context,watches,and,context,for,int,i,0,i,response,get,items,length,i,bulk,item,response,item,response,response,get,items,i,if,item,response,is,failed,logger,error,could,not,store,triggered,watch,with,id,item,response,get,id,item,response,get,failure,message,else,execute,async,watches,and,context,v2,get,i,watches,and,context,v1,get,i
ExecutionService -> private void executeTriggeredWatches(final BulkResponse response,                                          final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext);1525798021;Execute triggered watches, which have been successfully indexed into the triggered watches index__@param response            The bulk response containing the response of indexing triggered watches_@param watchesAndContext   The triggered watches and context objects needed for execution;private void executeTriggeredWatches(final BulkResponse response,_                                         final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext) {_        for (int i = 0_ i < response.getItems().length_ i++) {_            BulkItemResponse itemResponse = response.getItems()[i]__            if (itemResponse.isFailed()) {_                logger.error("could not store triggered watch with id [{}]: [{}]", itemResponse.getId(), itemResponse.getFailureMessage())__            } else {_                executeAsync(watchesAndContext.v2().get(i), watchesAndContext.v1().get(i))__            }_        }_    };execute,triggered,watches,which,have,been,successfully,indexed,into,the,triggered,watches,index,param,response,the,bulk,response,containing,the,response,of,indexing,triggered,watches,param,watches,and,context,the,triggered,watches,and,context,objects,needed,for,execution;private,void,execute,triggered,watches,final,bulk,response,response,final,tuple,list,triggered,watch,list,triggered,execution,context,watches,and,context,for,int,i,0,i,response,get,items,length,i,bulk,item,response,item,response,response,get,items,i,if,item,response,is,failed,logger,error,could,not,store,triggered,watch,with,id,item,response,get,id,item,response,get,failure,message,else,execute,async,watches,and,context,v2,get,i,watches,and,context,v1,get,i
ExecutionService -> private void executeTriggeredWatches(final BulkResponse response,                                          final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext);1537300661;Execute triggered watches, which have been successfully indexed into the triggered watches index__@param response            The bulk response containing the response of indexing triggered watches_@param watchesAndContext   The triggered watches and context objects needed for execution;private void executeTriggeredWatches(final BulkResponse response,_                                         final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext) {_        for (int i = 0_ i < response.getItems().length_ i++) {_            BulkItemResponse itemResponse = response.getItems()[i]__            if (itemResponse.isFailed()) {_                logger.error("could not store triggered watch with id [{}]: [{}]", itemResponse.getId(), itemResponse.getFailureMessage())__            } else {_                executeAsync(watchesAndContext.v2().get(i), watchesAndContext.v1().get(i))__            }_        }_    };execute,triggered,watches,which,have,been,successfully,indexed,into,the,triggered,watches,index,param,response,the,bulk,response,containing,the,response,of,indexing,triggered,watches,param,watches,and,context,the,triggered,watches,and,context,objects,needed,for,execution;private,void,execute,triggered,watches,final,bulk,response,response,final,tuple,list,triggered,watch,list,triggered,execution,context,watches,and,context,for,int,i,0,i,response,get,items,length,i,bulk,item,response,item,response,response,get,items,i,if,item,response,is,failed,logger,error,could,not,store,triggered,watch,with,id,item,response,get,id,item,response,get,failure,message,else,execute,async,watches,and,context,v2,get,i,watches,and,context,v1,get,i
ExecutionService -> private void executeTriggeredWatches(final BulkResponse response,                                          final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext);1539615817;Execute triggered watches, which have been successfully indexed into the triggered watches index__@param response            The bulk response containing the response of indexing triggered watches_@param watchesAndContext   The triggered watches and context objects needed for execution;private void executeTriggeredWatches(final BulkResponse response,_                                         final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext) {_        for (int i = 0_ i < response.getItems().length_ i++) {_            BulkItemResponse itemResponse = response.getItems()[i]__            if (itemResponse.isFailed()) {_                logger.error("could not store triggered watch with id [{}]: [{}]", itemResponse.getId(), itemResponse.getFailureMessage())__            } else {_                executeAsync(watchesAndContext.v2().get(i), watchesAndContext.v1().get(i))__            }_        }_    };execute,triggered,watches,which,have,been,successfully,indexed,into,the,triggered,watches,index,param,response,the,bulk,response,containing,the,response,of,indexing,triggered,watches,param,watches,and,context,the,triggered,watches,and,context,objects,needed,for,execution;private,void,execute,triggered,watches,final,bulk,response,response,final,tuple,list,triggered,watch,list,triggered,execution,context,watches,and,context,for,int,i,0,i,response,get,items,length,i,bulk,item,response,item,response,response,get,items,i,if,item,response,is,failed,logger,error,could,not,store,triggered,watch,with,id,item,response,get,id,item,response,get,failure,message,else,execute,async,watches,and,context,v2,get,i,watches,and,context,v1,get,i
ExecutionService -> private void executeTriggeredWatches(final BulkResponse response,                                          final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext);1541092382;Execute triggered watches, which have been successfully indexed into the triggered watches index__@param response            The bulk response containing the response of indexing triggered watches_@param watchesAndContext   The triggered watches and context objects needed for execution;private void executeTriggeredWatches(final BulkResponse response,_                                         final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext) {_        for (int i = 0_ i < response.getItems().length_ i++) {_            BulkItemResponse itemResponse = response.getItems()[i]__            if (itemResponse.isFailed()) {_                logger.error("could not store triggered watch with id [{}]: [{}]", itemResponse.getId(), itemResponse.getFailureMessage())__            } else {_                executeAsync(watchesAndContext.v2().get(i), watchesAndContext.v1().get(i))__            }_        }_    };execute,triggered,watches,which,have,been,successfully,indexed,into,the,triggered,watches,index,param,response,the,bulk,response,containing,the,response,of,indexing,triggered,watches,param,watches,and,context,the,triggered,watches,and,context,objects,needed,for,execution;private,void,execute,triggered,watches,final,bulk,response,response,final,tuple,list,triggered,watch,list,triggered,execution,context,watches,and,context,for,int,i,0,i,response,get,items,length,i,bulk,item,response,item,response,response,get,items,i,if,item,response,is,failed,logger,error,could,not,store,triggered,watch,with,id,item,response,get,id,item,response,get,failure,message,else,execute,async,watches,and,context,v2,get,i,watches,and,context,v1,get,i
ExecutionService -> private void executeTriggeredWatches(final BulkResponse response,                                          final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext);1543343306;Execute triggered watches, which have been successfully indexed into the triggered watches index__@param response            The bulk response containing the response of indexing triggered watches_@param watchesAndContext   The triggered watches and context objects needed for execution;private void executeTriggeredWatches(final BulkResponse response,_                                         final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext) {_        for (int i = 0_ i < response.getItems().length_ i++) {_            BulkItemResponse itemResponse = response.getItems()[i]__            if (itemResponse.isFailed()) {_                logger.error("could not store triggered watch with id [{}]: [{}]", itemResponse.getId(), itemResponse.getFailureMessage())__            } else {_                executeAsync(watchesAndContext.v2().get(i), watchesAndContext.v1().get(i))__            }_        }_    };execute,triggered,watches,which,have,been,successfully,indexed,into,the,triggered,watches,index,param,response,the,bulk,response,containing,the,response,of,indexing,triggered,watches,param,watches,and,context,the,triggered,watches,and,context,objects,needed,for,execution;private,void,execute,triggered,watches,final,bulk,response,response,final,tuple,list,triggered,watch,list,triggered,execution,context,watches,and,context,for,int,i,0,i,response,get,items,length,i,bulk,item,response,item,response,response,get,items,i,if,item,response,is,failed,logger,error,could,not,store,triggered,watch,with,id,item,response,get,id,item,response,get,failure,message,else,execute,async,watches,and,context,v2,get,i,watches,and,context,v1,get,i
ExecutionService -> private void executeTriggeredWatches(final BulkResponse response,                                          final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext);1548897299;Execute triggered watches, which have been successfully indexed into the triggered watches index__@param response            The bulk response containing the response of indexing triggered watches_@param watchesAndContext   The triggered watches and context objects needed for execution;private void executeTriggeredWatches(final BulkResponse response,_                                         final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext) {_        for (int i = 0_ i < response.getItems().length_ i++) {_            BulkItemResponse itemResponse = response.getItems()[i]__            if (itemResponse.isFailed()) {_                logger.error("could not store triggered watch with id [{}]: [{}]", itemResponse.getId(), itemResponse.getFailureMessage())__            } else {_                executeAsync(watchesAndContext.v2().get(i), watchesAndContext.v1().get(i))__            }_        }_    };execute,triggered,watches,which,have,been,successfully,indexed,into,the,triggered,watches,index,param,response,the,bulk,response,containing,the,response,of,indexing,triggered,watches,param,watches,and,context,the,triggered,watches,and,context,objects,needed,for,execution;private,void,execute,triggered,watches,final,bulk,response,response,final,tuple,list,triggered,watch,list,triggered,execution,context,watches,and,context,for,int,i,0,i,response,get,items,length,i,bulk,item,response,item,response,response,get,items,i,if,item,response,is,failed,logger,error,could,not,store,triggered,watch,with,id,item,response,get,id,item,response,get,failure,message,else,execute,async,watches,and,context,v2,get,i,watches,and,context,v1,get,i
ExecutionService -> private void executeTriggeredWatches(final BulkResponse response,                                          final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext);1549289311;Execute triggered watches, which have been successfully indexed into the triggered watches index__@param response            The bulk response containing the response of indexing triggered watches_@param watchesAndContext   The triggered watches and context objects needed for execution;private void executeTriggeredWatches(final BulkResponse response,_                                         final Tuple<List<TriggeredWatch>, List<TriggeredExecutionContext>> watchesAndContext) {_        for (int i = 0_ i < response.getItems().length_ i++) {_            BulkItemResponse itemResponse = response.getItems()[i]__            if (itemResponse.isFailed()) {_                logger.error("could not store triggered watch with id [{}]: [{}]", itemResponse.getId(), itemResponse.getFailureMessage())__            } else {_                executeAsync(watchesAndContext.v2().get(i), watchesAndContext.v1().get(i))__            }_        }_    };execute,triggered,watches,which,have,been,successfully,indexed,into,the,triggered,watches,index,param,response,the,bulk,response,containing,the,response,of,indexing,triggered,watches,param,watches,and,context,the,triggered,watches,and,context,objects,needed,for,execution;private,void,execute,triggered,watches,final,bulk,response,response,final,tuple,list,triggered,watch,list,triggered,execution,context,watches,and,context,for,int,i,0,i,response,get,items,length,i,bulk,item,response,item,response,response,get,items,i,if,item,response,is,failed,logger,error,could,not,store,triggered,watch,with,id,item,response,get,id,item,response,get,failure,message,else,execute,async,watches,and,context,v2,get,i,watches,and,context,v1,get,i
ExecutionService -> public void updateWatchStatus(Watch watch) throws IOException;1524684173;Updates and persists the status of the given watch__If the watch is missing (because it might have been deleted by the user during an execution), then this method_does nothing and just returns without throwing an exception;public void updateWatchStatus(Watch watch) throws IOException {_        _        _        _        Map<String, String> parameters = MapBuilder.<String, String>newMapBuilder()_                .put(Watch.INCLUDE_STATUS_KEY, "true")_                .put(WatchStatus.INCLUDE_STATE, "false")_                .immutableMap()__        ToXContent.MapParams params = new ToXContent.MapParams(parameters)__        XContentBuilder source = JsonXContent.contentBuilder()._                startObject()_                .field(WatchField.STATUS.getPreferredName(), watch.status(), params)_                .endObject()___        UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, watch.id())__        updateRequest.doc(source)__        updateRequest.version(watch.version())__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            client.update(updateRequest).actionGet(indexDefaultTimeout)__        } catch (DocumentMissingException e) {_            _            _            _        }_    };updates,and,persists,the,status,of,the,given,watch,if,the,watch,is,missing,because,it,might,have,been,deleted,by,the,user,during,an,execution,then,this,method,does,nothing,and,just,returns,without,throwing,an,exception;public,void,update,watch,status,watch,watch,throws,ioexception,map,string,string,parameters,map,builder,string,string,new,map,builder,put,watch,true,put,watch,status,false,immutable,map,to,xcontent,map,params,params,new,to,xcontent,map,params,parameters,xcontent,builder,source,json,xcontent,content,builder,start,object,field,watch,field,status,get,preferred,name,watch,status,params,end,object,update,request,update,request,new,update,request,watch,index,watch,watch,id,update,request,doc,source,update,request,version,watch,version,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,client,update,update,request,action,get,index,default,timeout,catch,document,missing,exception,e
ExecutionService -> public void updateWatchStatus(Watch watch) throws IOException;1525334055;Updates and persists the status of the given watch__If the watch is missing (because it might have been deleted by the user during an execution), then this method_does nothing and just returns without throwing an exception;public void updateWatchStatus(Watch watch) throws IOException {_        _        _        _        Map<String, String> parameters = MapBuilder.<String, String>newMapBuilder()_            .put(Watch.INCLUDE_STATUS_KEY, "true")_            .put(WatchStatus.INCLUDE_STATE, "false")_            .immutableMap()__        ToXContent.MapParams params = new ToXContent.MapParams(parameters)__        XContentBuilder source = JsonXContent.contentBuilder()._            startObject()_            .field(WatchField.STATUS.getPreferredName(), watch.status(), params)_            .endObject()___        UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, watch.id())__        updateRequest.doc(source)__        updateRequest.version(watch.version())__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            client.update(updateRequest).actionGet(indexDefaultTimeout)__        } catch (DocumentMissingException e) {_            _            _            _        }_    };updates,and,persists,the,status,of,the,given,watch,if,the,watch,is,missing,because,it,might,have,been,deleted,by,the,user,during,an,execution,then,this,method,does,nothing,and,just,returns,without,throwing,an,exception;public,void,update,watch,status,watch,watch,throws,ioexception,map,string,string,parameters,map,builder,string,string,new,map,builder,put,watch,true,put,watch,status,false,immutable,map,to,xcontent,map,params,params,new,to,xcontent,map,params,parameters,xcontent,builder,source,json,xcontent,content,builder,start,object,field,watch,field,status,get,preferred,name,watch,status,params,end,object,update,request,update,request,new,update,request,watch,index,watch,watch,id,update,request,doc,source,update,request,version,watch,version,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,client,update,update,request,action,get,index,default,timeout,catch,document,missing,exception,e
ExecutionService -> public void updateWatchStatus(Watch watch) throws IOException;1525798021;Updates and persists the status of the given watch__If the watch is missing (because it might have been deleted by the user during an execution), then this method_does nothing and just returns without throwing an exception;public void updateWatchStatus(Watch watch) throws IOException {_        _        _        _        Map<String, String> parameters = MapBuilder.<String, String>newMapBuilder()_            .put(Watch.INCLUDE_STATUS_KEY, "true")_            .put(WatchStatus.INCLUDE_STATE, "false")_            .immutableMap()__        ToXContent.MapParams params = new ToXContent.MapParams(parameters)__        XContentBuilder source = JsonXContent.contentBuilder()._            startObject()_            .field(WatchField.STATUS.getPreferredName(), watch.status(), params)_            .endObject()___        UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, watch.id())__        updateRequest.doc(source)__        updateRequest.version(watch.version())__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            client.update(updateRequest).actionGet(indexDefaultTimeout)__        } catch (DocumentMissingException e) {_            _            _            _        }_    };updates,and,persists,the,status,of,the,given,watch,if,the,watch,is,missing,because,it,might,have,been,deleted,by,the,user,during,an,execution,then,this,method,does,nothing,and,just,returns,without,throwing,an,exception;public,void,update,watch,status,watch,watch,throws,ioexception,map,string,string,parameters,map,builder,string,string,new,map,builder,put,watch,true,put,watch,status,false,immutable,map,to,xcontent,map,params,params,new,to,xcontent,map,params,parameters,xcontent,builder,source,json,xcontent,content,builder,start,object,field,watch,field,status,get,preferred,name,watch,status,params,end,object,update,request,update,request,new,update,request,watch,index,watch,watch,id,update,request,doc,source,update,request,version,watch,version,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,client,update,update,request,action,get,index,default,timeout,catch,document,missing,exception,e
ExecutionService -> public void updateWatchStatus(Watch watch) throws IOException;1537300661;Updates and persists the status of the given watch__If the watch is missing (because it might have been deleted by the user during an execution), then this method_does nothing and just returns without throwing an exception;public void updateWatchStatus(Watch watch) throws IOException {_        _        _        _        Map<String, String> parameters = MapBuilder.<String, String>newMapBuilder()_            .put(Watch.INCLUDE_STATUS_KEY, "true")_            .put(WatchStatus.INCLUDE_STATE, "false")_            .immutableMap()__        ToXContent.MapParams params = new ToXContent.MapParams(parameters)__        XContentBuilder source = JsonXContent.contentBuilder()._            startObject()_            .field(WatchField.STATUS.getPreferredName(), watch.status(), params)_            .endObject()___        UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, watch.id())__        updateRequest.doc(source)__        updateRequest.version(watch.version())__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            client.update(updateRequest).actionGet(indexDefaultTimeout)__        } catch (DocumentMissingException e) {_            _            _            _        }_    };updates,and,persists,the,status,of,the,given,watch,if,the,watch,is,missing,because,it,might,have,been,deleted,by,the,user,during,an,execution,then,this,method,does,nothing,and,just,returns,without,throwing,an,exception;public,void,update,watch,status,watch,watch,throws,ioexception,map,string,string,parameters,map,builder,string,string,new,map,builder,put,watch,true,put,watch,status,false,immutable,map,to,xcontent,map,params,params,new,to,xcontent,map,params,parameters,xcontent,builder,source,json,xcontent,content,builder,start,object,field,watch,field,status,get,preferred,name,watch,status,params,end,object,update,request,update,request,new,update,request,watch,index,watch,watch,id,update,request,doc,source,update,request,version,watch,version,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,client,update,update,request,action,get,index,default,timeout,catch,document,missing,exception,e
ExecutionService -> public void updateWatchStatus(Watch watch) throws IOException;1539615817;Updates and persists the status of the given watch__If the watch is missing (because it might have been deleted by the user during an execution), then this method_does nothing and just returns without throwing an exception;public void updateWatchStatus(Watch watch) throws IOException {_        _        _        _        Map<String, String> parameters = MapBuilder.<String, String>newMapBuilder()_            .put(Watch.INCLUDE_STATUS_KEY, "true")_            .put(WatchStatus.INCLUDE_STATE, "false")_            .immutableMap()__        ToXContent.MapParams params = new ToXContent.MapParams(parameters)__        XContentBuilder source = JsonXContent.contentBuilder()._            startObject()_            .field(WatchField.STATUS.getPreferredName(), watch.status(), params)_            .endObject()___        UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, watch.id())__        updateRequest.doc(source)__        updateRequest.version(watch.version())__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            client.update(updateRequest).actionGet(indexDefaultTimeout)__        } catch (DocumentMissingException e) {_            _            _            _        }_    };updates,and,persists,the,status,of,the,given,watch,if,the,watch,is,missing,because,it,might,have,been,deleted,by,the,user,during,an,execution,then,this,method,does,nothing,and,just,returns,without,throwing,an,exception;public,void,update,watch,status,watch,watch,throws,ioexception,map,string,string,parameters,map,builder,string,string,new,map,builder,put,watch,true,put,watch,status,false,immutable,map,to,xcontent,map,params,params,new,to,xcontent,map,params,parameters,xcontent,builder,source,json,xcontent,content,builder,start,object,field,watch,field,status,get,preferred,name,watch,status,params,end,object,update,request,update,request,new,update,request,watch,index,watch,watch,id,update,request,doc,source,update,request,version,watch,version,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,client,update,update,request,action,get,index,default,timeout,catch,document,missing,exception,e
ExecutionService -> public void updateWatchStatus(Watch watch) throws IOException;1541092382;Updates and persists the status of the given watch__If the watch is missing (because it might have been deleted by the user during an execution), then this method_does nothing and just returns without throwing an exception;public void updateWatchStatus(Watch watch) throws IOException {_        _        _        _        Map<String, String> parameters = MapBuilder.<String, String>newMapBuilder()_            .put(Watch.INCLUDE_STATUS_KEY, "true")_            .put(WatchStatus.INCLUDE_STATE, "false")_            .immutableMap()__        ToXContent.MapParams params = new ToXContent.MapParams(parameters)__        XContentBuilder source = JsonXContent.contentBuilder()._            startObject()_            .field(WatchField.STATUS.getPreferredName(), watch.status(), params)_            .endObject()___        UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, watch.id())__        updateRequest.doc(source)__        updateRequest.version(watch.version())__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            client.update(updateRequest).actionGet(indexDefaultTimeout)__        } catch (DocumentMissingException e) {_            _            _            _        }_    };updates,and,persists,the,status,of,the,given,watch,if,the,watch,is,missing,because,it,might,have,been,deleted,by,the,user,during,an,execution,then,this,method,does,nothing,and,just,returns,without,throwing,an,exception;public,void,update,watch,status,watch,watch,throws,ioexception,map,string,string,parameters,map,builder,string,string,new,map,builder,put,watch,true,put,watch,status,false,immutable,map,to,xcontent,map,params,params,new,to,xcontent,map,params,parameters,xcontent,builder,source,json,xcontent,content,builder,start,object,field,watch,field,status,get,preferred,name,watch,status,params,end,object,update,request,update,request,new,update,request,watch,index,watch,watch,id,update,request,doc,source,update,request,version,watch,version,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,client,update,update,request,action,get,index,default,timeout,catch,document,missing,exception,e
ExecutionService -> public void updateWatchStatus(Watch watch) throws IOException;1543343306;Updates and persists the status of the given watch__If the watch is missing (because it might have been deleted by the user during an execution), then this method_does nothing and just returns without throwing an exception;public void updateWatchStatus(Watch watch) throws IOException {_        _        _        _        Map<String, String> parameters = MapBuilder.<String, String>newMapBuilder()_            .put(Watch.INCLUDE_STATUS_KEY, "true")_            .put(WatchStatus.INCLUDE_STATE, "false")_            .immutableMap()__        ToXContent.MapParams params = new ToXContent.MapParams(parameters)__        XContentBuilder source = JsonXContent.contentBuilder()._            startObject()_            .field(WatchField.STATUS.getPreferredName(), watch.status(), params)_            .endObject()___        UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, watch.id())__        updateRequest.doc(source)__        updateRequest.version(watch.version())__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            client.update(updateRequest).actionGet(indexDefaultTimeout)__        } catch (DocumentMissingException e) {_            _            _            _        }_    };updates,and,persists,the,status,of,the,given,watch,if,the,watch,is,missing,because,it,might,have,been,deleted,by,the,user,during,an,execution,then,this,method,does,nothing,and,just,returns,without,throwing,an,exception;public,void,update,watch,status,watch,watch,throws,ioexception,map,string,string,parameters,map,builder,string,string,new,map,builder,put,watch,true,put,watch,status,false,immutable,map,to,xcontent,map,params,params,new,to,xcontent,map,params,parameters,xcontent,builder,source,json,xcontent,content,builder,start,object,field,watch,field,status,get,preferred,name,watch,status,params,end,object,update,request,update,request,new,update,request,watch,index,watch,watch,id,update,request,doc,source,update,request,version,watch,version,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,client,update,update,request,action,get,index,default,timeout,catch,document,missing,exception,e
ExecutionService -> public void updateWatchStatus(Watch watch) throws IOException;1548897299;Updates and persists the status of the given watch__If the watch is missing (because it might have been deleted by the user during an execution), then this method_does nothing and just returns without throwing an exception;public void updateWatchStatus(Watch watch) throws IOException {_        _        _        _        Map<String, String> parameters = MapBuilder.<String, String>newMapBuilder()_            .put(Watch.INCLUDE_STATUS_KEY, "true")_            .put(WatchStatus.INCLUDE_STATE, "false")_            .immutableMap()__        ToXContent.MapParams params = new ToXContent.MapParams(parameters)__        XContentBuilder source = JsonXContent.contentBuilder()._            startObject()_            .field(WatchField.STATUS.getPreferredName(), watch.status(), params)_            .endObject()___        UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, watch.id())__        updateRequest.doc(source)__        updateRequest.setIfSeqNo(watch.getSourceSeqNo())__        updateRequest.setIfPrimaryTerm(watch.getSourcePrimaryTerm())__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            client.update(updateRequest).actionGet(indexDefaultTimeout)__        } catch (DocumentMissingException e) {_            _            _            _        }_    };updates,and,persists,the,status,of,the,given,watch,if,the,watch,is,missing,because,it,might,have,been,deleted,by,the,user,during,an,execution,then,this,method,does,nothing,and,just,returns,without,throwing,an,exception;public,void,update,watch,status,watch,watch,throws,ioexception,map,string,string,parameters,map,builder,string,string,new,map,builder,put,watch,true,put,watch,status,false,immutable,map,to,xcontent,map,params,params,new,to,xcontent,map,params,parameters,xcontent,builder,source,json,xcontent,content,builder,start,object,field,watch,field,status,get,preferred,name,watch,status,params,end,object,update,request,update,request,new,update,request,watch,index,watch,watch,id,update,request,doc,source,update,request,set,if,seq,no,watch,get,source,seq,no,update,request,set,if,primary,term,watch,get,source,primary,term,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,client,update,update,request,action,get,index,default,timeout,catch,document,missing,exception,e
ExecutionService -> public void updateWatchStatus(Watch watch) throws IOException;1549289311;Updates and persists the status of the given watch__If the watch is missing (because it might have been deleted by the user during an execution), then this method_does nothing and just returns without throwing an exception;public void updateWatchStatus(Watch watch) throws IOException {_        _        _        _        Map<String, String> parameters = MapBuilder.<String, String>newMapBuilder()_            .put(Watch.INCLUDE_STATUS_KEY, "true")_            .put(WatchStatus.INCLUDE_STATE, "false")_            .immutableMap()__        ToXContent.MapParams params = new ToXContent.MapParams(parameters)__        XContentBuilder source = JsonXContent.contentBuilder()._            startObject()_            .field(WatchField.STATUS.getPreferredName(), watch.status(), params)_            .endObject()___        UpdateRequest updateRequest = new UpdateRequest(Watch.INDEX, Watch.DOC_TYPE, watch.id())__        updateRequest.doc(source)__        updateRequest.setIfSeqNo(watch.getSourceSeqNo())__        updateRequest.setIfPrimaryTerm(watch.getSourcePrimaryTerm())__        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            client.update(updateRequest).actionGet(indexDefaultTimeout)__        } catch (DocumentMissingException e) {_            _            _            _        }_    };updates,and,persists,the,status,of,the,given,watch,if,the,watch,is,missing,because,it,might,have,been,deleted,by,the,user,during,an,execution,then,this,method,does,nothing,and,just,returns,without,throwing,an,exception;public,void,update,watch,status,watch,watch,throws,ioexception,map,string,string,parameters,map,builder,string,string,new,map,builder,put,watch,true,put,watch,status,false,immutable,map,to,xcontent,map,params,params,new,to,xcontent,map,params,parameters,xcontent,builder,source,json,xcontent,content,builder,start,object,field,watch,field,status,get,preferred,name,watch,status,params,end,object,update,request,update,request,new,update,request,watch,index,watch,watch,id,update,request,doc,source,update,request,set,if,seq,no,watch,get,source,seq,no,update,request,set,if,primary,term,watch,get,source,primary,term,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,client,update,update,request,action,get,index,default,timeout,catch,document,missing,exception,e
ExecutionService -> public int clearExecutionsAndQueue();1525798021;Empty the currently queued tasks and wait for current executions to finish.__@return the number of tasks that have been removed;public int clearExecutionsAndQueue() {_        int cancelledTaskCount = executor.queue().drainTo(new ArrayList<>())__        this.clearExecutions()__        return cancelledTaskCount__    };empty,the,currently,queued,tasks,and,wait,for,current,executions,to,finish,return,the,number,of,tasks,that,have,been,removed;public,int,clear,executions,and,queue,int,cancelled,task,count,executor,queue,drain,to,new,array,list,this,clear,executions,return,cancelled,task,count
ExecutionService -> public int clearExecutionsAndQueue();1537300661;Empty the currently queued tasks and wait for current executions to finish.__@return the number of tasks that have been removed;public int clearExecutionsAndQueue() {_        int cancelledTaskCount = executor.queue().drainTo(new ArrayList<>())__        this.clearExecutions()__        return cancelledTaskCount__    };empty,the,currently,queued,tasks,and,wait,for,current,executions,to,finish,return,the,number,of,tasks,that,have,been,removed;public,int,clear,executions,and,queue,int,cancelled,task,count,executor,queue,drain,to,new,array,list,this,clear,executions,return,cancelled,task,count
ExecutionService -> public int clearExecutionsAndQueue();1539615817;Empty the currently queued tasks and wait for current executions to finish.__@return the number of tasks that have been removed;public int clearExecutionsAndQueue() {_        int cancelledTaskCount = executor.queue().drainTo(new ArrayList<>())__        this.clearExecutions()__        return cancelledTaskCount__    };empty,the,currently,queued,tasks,and,wait,for,current,executions,to,finish,return,the,number,of,tasks,that,have,been,removed;public,int,clear,executions,and,queue,int,cancelled,task,count,executor,queue,drain,to,new,array,list,this,clear,executions,return,cancelled,task,count
ExecutionService -> public int clearExecutionsAndQueue();1541092382;Empty the currently queued tasks and wait for current executions to finish.__@return the number of tasks that have been removed;public int clearExecutionsAndQueue() {_        int cancelledTaskCount = executor.queue().drainTo(new ArrayList<>())__        this.clearExecutions()__        return cancelledTaskCount__    };empty,the,currently,queued,tasks,and,wait,for,current,executions,to,finish,return,the,number,of,tasks,that,have,been,removed;public,int,clear,executions,and,queue,int,cancelled,task,count,executor,queue,drain,to,new,array,list,this,clear,executions,return,cancelled,task,count
ExecutionService -> public int clearExecutionsAndQueue();1543343306;Empty the currently queued tasks and wait for current executions to finish.__@return the number of tasks that have been removed;public int clearExecutionsAndQueue() {_        int cancelledTaskCount = executor.queue().drainTo(new ArrayList<>())__        this.clearExecutions()__        return cancelledTaskCount__    };empty,the,currently,queued,tasks,and,wait,for,current,executions,to,finish,return,the,number,of,tasks,that,have,been,removed;public,int,clear,executions,and,queue,int,cancelled,task,count,executor,queue,drain,to,new,array,list,this,clear,executions,return,cancelled,task,count
ExecutionService -> public int clearExecutionsAndQueue();1548897299;Empty the currently queued tasks and wait for current executions to finish.__@return the number of tasks that have been removed;public int clearExecutionsAndQueue() {_        int cancelledTaskCount = executor.queue().drainTo(new ArrayList<>())__        this.clearExecutions()__        return cancelledTaskCount__    };empty,the,currently,queued,tasks,and,wait,for,current,executions,to,finish,return,the,number,of,tasks,that,have,been,removed;public,int,clear,executions,and,queue,int,cancelled,task,count,executor,queue,drain,to,new,array,list,this,clear,executions,return,cancelled,task,count
ExecutionService -> public int clearExecutionsAndQueue();1549289311;Empty the currently queued tasks and wait for current executions to finish.__@return the number of tasks that have been removed;public int clearExecutionsAndQueue() {_        int cancelledTaskCount = executor.queue().drainTo(new ArrayList<>())__        this.clearExecutions()__        return cancelledTaskCount__    };empty,the,currently,queued,tasks,and,wait,for,current,executions,to,finish,return,the,number,of,tasks,that,have,been,removed;public,int,clear,executions,and,queue,int,cancelled,task,count,executor,queue,drain,to,new,array,list,this,clear,executions,return,cancelled,task,count
ExecutionService -> private GetResponse getWatch(String id);1524684173;Gets a watch but in a synchronous way, so that no async calls need to be built_@param id The id of watch_@return The GetResponse of calling the get API of this watch;private GetResponse getWatch(String id) {_        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, id).preference(Preference.LOCAL.type()).realtime(true)__            PlainActionFuture<GetResponse> future = PlainActionFuture.newFuture()__            client.get(getRequest, future)__            return future.actionGet()__        }_    };gets,a,watch,but,in,a,synchronous,way,so,that,no,async,calls,need,to,be,built,param,id,the,id,of,watch,return,the,get,response,of,calling,the,get,api,of,this,watch;private,get,response,get,watch,string,id,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,get,request,get,request,new,get,request,watch,index,watch,id,preference,preference,local,type,realtime,true,plain,action,future,get,response,future,plain,action,future,new,future,client,get,get,request,future,return,future,action,get
ExecutionService -> private GetResponse getWatch(String id);1525334055;Gets a watch but in a synchronous way, so that no async calls need to be built_@param id The id of watch_@return The GetResponse of calling the get API of this watch;private GetResponse getWatch(String id) {_        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, id).preference(Preference.LOCAL.type()).realtime(true)__            PlainActionFuture<GetResponse> future = PlainActionFuture.newFuture()__            client.get(getRequest, future)__            return future.actionGet()__        }_    };gets,a,watch,but,in,a,synchronous,way,so,that,no,async,calls,need,to,be,built,param,id,the,id,of,watch,return,the,get,response,of,calling,the,get,api,of,this,watch;private,get,response,get,watch,string,id,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,get,request,get,request,new,get,request,watch,index,watch,id,preference,preference,local,type,realtime,true,plain,action,future,get,response,future,plain,action,future,new,future,client,get,get,request,future,return,future,action,get
ExecutionService -> private GetResponse getWatch(String id);1525798021;Gets a watch but in a synchronous way, so that no async calls need to be built_@param id The id of watch_@return The GetResponse of calling the get API of this watch;private GetResponse getWatch(String id) {_        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, id).preference(Preference.LOCAL.type()).realtime(true)__            PlainActionFuture<GetResponse> future = PlainActionFuture.newFuture()__            client.get(getRequest, future)__            return future.actionGet()__        }_    };gets,a,watch,but,in,a,synchronous,way,so,that,no,async,calls,need,to,be,built,param,id,the,id,of,watch,return,the,get,response,of,calling,the,get,api,of,this,watch;private,get,response,get,watch,string,id,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,get,request,get,request,new,get,request,watch,index,watch,id,preference,preference,local,type,realtime,true,plain,action,future,get,response,future,plain,action,future,new,future,client,get,get,request,future,return,future,action,get
ExecutionService -> private GetResponse getWatch(String id);1537300661;Gets a watch but in a synchronous way, so that no async calls need to be built_@param id The id of watch_@return The GetResponse of calling the get API of this watch;private GetResponse getWatch(String id) {_        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, id).preference(Preference.LOCAL.type()).realtime(true)__            PlainActionFuture<GetResponse> future = PlainActionFuture.newFuture()__            client.get(getRequest, future)__            return future.actionGet()__        }_    };gets,a,watch,but,in,a,synchronous,way,so,that,no,async,calls,need,to,be,built,param,id,the,id,of,watch,return,the,get,response,of,calling,the,get,api,of,this,watch;private,get,response,get,watch,string,id,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,get,request,get,request,new,get,request,watch,index,watch,id,preference,preference,local,type,realtime,true,plain,action,future,get,response,future,plain,action,future,new,future,client,get,get,request,future,return,future,action,get
ExecutionService -> private GetResponse getWatch(String id);1539615817;Gets a watch but in a synchronous way, so that no async calls need to be built_@param id The id of watch_@return The GetResponse of calling the get API of this watch;private GetResponse getWatch(String id) {_        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, id).preference(Preference.LOCAL.type()).realtime(true)__            PlainActionFuture<GetResponse> future = PlainActionFuture.newFuture()__            client.get(getRequest, future)__            return future.actionGet()__        }_    };gets,a,watch,but,in,a,synchronous,way,so,that,no,async,calls,need,to,be,built,param,id,the,id,of,watch,return,the,get,response,of,calling,the,get,api,of,this,watch;private,get,response,get,watch,string,id,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,get,request,get,request,new,get,request,watch,index,watch,id,preference,preference,local,type,realtime,true,plain,action,future,get,response,future,plain,action,future,new,future,client,get,get,request,future,return,future,action,get
ExecutionService -> private GetResponse getWatch(String id);1541092382;Gets a watch but in a synchronous way, so that no async calls need to be built_@param id The id of watch_@return The GetResponse of calling the get API of this watch;private GetResponse getWatch(String id) {_        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, id).preference(Preference.LOCAL.type()).realtime(true)__            PlainActionFuture<GetResponse> future = PlainActionFuture.newFuture()__            client.get(getRequest, future)__            return future.actionGet()__        }_    };gets,a,watch,but,in,a,synchronous,way,so,that,no,async,calls,need,to,be,built,param,id,the,id,of,watch,return,the,get,response,of,calling,the,get,api,of,this,watch;private,get,response,get,watch,string,id,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,get,request,get,request,new,get,request,watch,index,watch,id,preference,preference,local,type,realtime,true,plain,action,future,get,response,future,plain,action,future,new,future,client,get,get,request,future,return,future,action,get
ExecutionService -> private GetResponse getWatch(String id);1543343306;Gets a watch but in a synchronous way, so that no async calls need to be built_@param id The id of watch_@return The GetResponse of calling the get API of this watch;private GetResponse getWatch(String id) {_        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, id).preference(Preference.LOCAL.type()).realtime(true)__            PlainActionFuture<GetResponse> future = PlainActionFuture.newFuture()__            client.get(getRequest, future)__            return future.actionGet()__        }_    };gets,a,watch,but,in,a,synchronous,way,so,that,no,async,calls,need,to,be,built,param,id,the,id,of,watch,return,the,get,response,of,calling,the,get,api,of,this,watch;private,get,response,get,watch,string,id,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,get,request,get,request,new,get,request,watch,index,watch,id,preference,preference,local,type,realtime,true,plain,action,future,get,response,future,plain,action,future,new,future,client,get,get,request,future,return,future,action,get
ExecutionService -> private GetResponse getWatch(String id);1548897299;Gets a watch but in a synchronous way, so that no async calls need to be built_@param id The id of watch_@return The GetResponse of calling the get API of this watch;private GetResponse getWatch(String id) {_        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, id).preference(Preference.LOCAL.type()).realtime(true)__            PlainActionFuture<GetResponse> future = PlainActionFuture.newFuture()__            client.get(getRequest, future)__            return future.actionGet()__        }_    };gets,a,watch,but,in,a,synchronous,way,so,that,no,async,calls,need,to,be,built,param,id,the,id,of,watch,return,the,get,response,of,calling,the,get,api,of,this,watch;private,get,response,get,watch,string,id,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,get,request,get,request,new,get,request,watch,index,watch,id,preference,preference,local,type,realtime,true,plain,action,future,get,response,future,plain,action,future,new,future,client,get,get,request,future,return,future,action,get
ExecutionService -> private GetResponse getWatch(String id);1549289311;Gets a watch but in a synchronous way, so that no async calls need to be built_@param id The id of watch_@return The GetResponse of calling the get API of this watch;private GetResponse getWatch(String id) {_        try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN)) {_            GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, id).preference(Preference.LOCAL.type()).realtime(true)__            PlainActionFuture<GetResponse> future = PlainActionFuture.newFuture()__            client.get(getRequest, future)__            return future.actionGet()__        }_    };gets,a,watch,but,in,a,synchronous,way,so,that,no,async,calls,need,to,be,built,param,id,the,id,of,watch,return,the,get,response,of,calling,the,get,api,of,this,watch;private,get,response,get,watch,string,id,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,get,request,get,request,new,get,request,watch,index,watch,id,preference,preference,local,type,realtime,true,plain,action,future,get,response,future,plain,action,future,new,future,client,get,get,request,future,return,future,action,get
