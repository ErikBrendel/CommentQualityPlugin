commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;0;3;;public MonthTimes[] times() {     return times. }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (params.paramAsBoolean("normalize", false) && times.length == 1) {         return times[0].toXContent(builder, params).     }     builder.startArray().     for (MonthTimes monthTimes : times) {         monthTimes.toXContent(builder, params).     }     return builder.endArray(). }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;static;1;8;;static String[] crons(MonthTimes[] times) {     assert times.length > 0 : "at least one time must be defined".     Set<String> crons = new HashSet<>(times.length).     for (MonthTimes time : times) {         crons.addAll(time.crons()).     }     return crons.toArray(new String[crons.size()]). }
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;1;24;;@Override public MonthlySchedule parse(XContentParser parser) throws IOException {     if (parser.currentToken() == XContentParser.Token.START_OBJECT) {         try {             return new MonthlySchedule(MonthTimes.parse(parser, parser.currentToken())).         } catch (ElasticsearchParseException pe) {             throw new ElasticsearchParseException("could not parse [{}] schedule. invalid month times", pe, TYPE).         }     }     if (parser.currentToken() == XContentParser.Token.START_ARRAY) {         List<MonthTimes> times = new ArrayList<>().         XContentParser.Token token.         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {             try {                 times.add(MonthTimes.parse(parser, token)).             } catch (ElasticsearchParseException pe) {                 throw new ElasticsearchParseException("could not parse [{}] schedule. invalid month times", pe, TYPE).             }         }         return times.isEmpty() ? new MonthlySchedule() : new MonthlySchedule(times.toArray(new MonthTimes[times.size()])).     }     throw new ElasticsearchParseException("could not parse [{}] schedule. expected either an object or an array " + "of objects representing month times, but found [{}] instead", TYPE, parser.currentToken()). }
false;public;1;4;;public Builder time(MonthTimes time) {     times.add(time).     return this. }
false;public;1;3;;public Builder time(MonthTimes.Builder builder) {     return time(builder.build()). }
false;public;0;3;;public MonthlySchedule build() {     return times.isEmpty() ? new MonthlySchedule() : new MonthlySchedule(times.toArray(new MonthTimes[times.size()])). }
