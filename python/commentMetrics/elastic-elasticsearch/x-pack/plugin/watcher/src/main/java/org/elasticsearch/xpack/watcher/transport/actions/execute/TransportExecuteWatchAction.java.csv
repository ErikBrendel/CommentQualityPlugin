commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;31;;@Override protected void doExecute(ExecuteWatchRequest request, ActionListener<ExecuteWatchResponse> listener) {     if (request.getId() != null) {         GetRequest getRequest = new GetRequest(Watch.INDEX, Watch.DOC_TYPE, request.getId()).preference(Preference.LOCAL.type()).realtime(true).         executeAsyncWithOrigin(client.threadPool().getThreadContext(), WATCHER_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {             if (response.isExists()) {                 Watch watch = watchParser.parse(request.getId(), true, response.getSourceAsBytesRef(), request.getXContentType(), response.getSeqNo(), response.getPrimaryTerm()).                 watch.status().version(response.getVersion()).                 executeWatch(request, listener, watch, true).             } else {                 listener.onFailure(new ResourceNotFoundException("Watch with id [{}] does not exist", request.getId())).             }         }, listener::onFailure), client::get).     } else if (request.getWatchSource() != null) {         try {             assert !request.isRecordExecution().             Watch watch = watchParser.parse(ExecuteWatchRequest.INLINE_WATCH_ID, true, request.getWatchSource(), request.getXContentType(), SequenceNumbers.UNASSIGNED_SEQ_NO, SequenceNumbers.UNASSIGNED_PRIMARY_TERM).             executeWatch(request, listener, watch, false).         } catch (IOException e) {             logger.error(new ParameterizedMessage("failed to parse [{}]", request.getId()), e).             listener.onFailure(e).         }     } else {         listener.onFailure(new IllegalArgumentException("no watch provided")).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;protected;0;33;;@Override protected void doRun() throws Exception {     // ensure that the headers from the incoming request are used instead those of the stored watch     // otherwise the watch would run as the user who stored the watch, but it needs to be run as the user who     // executes this request     Map<String, String> headers = new HashMap<>(threadPool.getThreadContext().getHeaders()).     watch.status().setHeaders(headers).     String triggerType = watch.trigger().type().     TriggerEvent triggerEvent = triggerService.simulateEvent(triggerType, watch.id(), request.getTriggerData()).     ManualExecutionContext.Builder ctxBuilder = ManualExecutionContext.builder(watch, knownWatch, new ManualTriggerEvent(triggerEvent.jobName(), triggerEvent), executionService.defaultThrottlePeriod()).     ZonedDateTime executionTime = clock.instant().atZone(ZoneOffset.UTC).     ctxBuilder.executionTime(executionTime).     for (Map.Entry<String, ActionExecutionMode> entry : request.getActionModes().entrySet()) {         ctxBuilder.actionMode(entry.getKey(), entry.getValue()).     }     if (request.getAlternativeInput() != null) {         ctxBuilder.withInput(new SimpleInput.Result(new Payload.Simple(request.getAlternativeInput()))).     }     if (request.isIgnoreCondition()) {         ctxBuilder.withCondition(InternalAlwaysCondition.RESULT_INSTANCE).     }     ctxBuilder.recordExecution(request.isRecordExecution()).     WatchRecord record = executionService.execute(ctxBuilder.build()).     XContentBuilder builder = XContentFactory.jsonBuilder().     record.toXContent(builder, WatcherParams.builder().hideSecrets(true).debug(request.isDebug()).build()).     listener.onResponse(new ExecuteWatchResponse(record.id().value(), BytesReference.bytes(builder), XContentType.JSON)). }
false;private;4;44;;private void executeWatch(ExecuteWatchRequest request, ActionListener<ExecuteWatchResponse> listener, Watch watch, boolean knownWatch) {     threadPool.executor(XPackField.WATCHER).submit(new AbstractRunnable() {          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }          @Override         protected void doRun() throws Exception {             // ensure that the headers from the incoming request are used instead those of the stored watch             // otherwise the watch would run as the user who stored the watch, but it needs to be run as the user who             // executes this request             Map<String, String> headers = new HashMap<>(threadPool.getThreadContext().getHeaders()).             watch.status().setHeaders(headers).             String triggerType = watch.trigger().type().             TriggerEvent triggerEvent = triggerService.simulateEvent(triggerType, watch.id(), request.getTriggerData()).             ManualExecutionContext.Builder ctxBuilder = ManualExecutionContext.builder(watch, knownWatch, new ManualTriggerEvent(triggerEvent.jobName(), triggerEvent), executionService.defaultThrottlePeriod()).             ZonedDateTime executionTime = clock.instant().atZone(ZoneOffset.UTC).             ctxBuilder.executionTime(executionTime).             for (Map.Entry<String, ActionExecutionMode> entry : request.getActionModes().entrySet()) {                 ctxBuilder.actionMode(entry.getKey(), entry.getValue()).             }             if (request.getAlternativeInput() != null) {                 ctxBuilder.withInput(new SimpleInput.Result(new Payload.Simple(request.getAlternativeInput()))).             }             if (request.isIgnoreCondition()) {                 ctxBuilder.withCondition(InternalAlwaysCondition.RESULT_INSTANCE).             }             ctxBuilder.recordExecution(request.isRecordExecution()).             WatchRecord record = executionService.execute(ctxBuilder.build()).             XContentBuilder builder = XContentFactory.jsonBuilder().             record.toXContent(builder, WatcherParams.builder().hideSecrets(true).debug(request.isDebug()).build()).             listener.onResponse(new ExecuteWatchResponse(record.id().value(), BytesReference.bytes(builder), XContentType.JSON)).         }     }). }
