commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;1;// overridable by tests ;// overridable by tests protected SSLService getSslService() {     return XPackPlugin.getSharedSslService(). }
false;protected;0;1;;protected XPackLicenseState getLicenseState() {     return XPackPlugin.getSharedLicenseState(). }
false;protected;0;1;;protected Clock getClock() {     return Clock.systemUTC(). }
false;public;2;3;;@Override public void beforeBulk(long executionId, BulkRequest request) { }
false;public;3;25;;@Override public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {     if (response.hasFailures()) {         Map<String, String> triggeredWatches = Arrays.stream(response.getItems()).filter(BulkItemResponse::isFailed).filter(r -> r.getIndex().startsWith(TriggeredWatchStoreField.INDEX_NAME)).collect(Collectors.toMap(BulkItemResponse::getId, BulkItemResponse::getFailureMessage)).         if (triggeredWatches.isEmpty() == false) {             String failure = triggeredWatches.values().stream().collect(Collectors.joining(", ")).             logger.error("triggered watches could not be deleted {}, failure [{}]", triggeredWatches.keySet(), Strings.substring(failure, 0, 2000)).         }         Map<String, String> overwrittenIds = Arrays.stream(response.getItems()).filter(BulkItemResponse::isFailed).filter(r -> r.getIndex().startsWith(HistoryStoreField.INDEX_PREFIX)).filter(r -> r.getVersion() > 1).collect(Collectors.toMap(BulkItemResponse::getId, BulkItemResponse::getFailureMessage)).         if (overwrittenIds.isEmpty() == false) {             String failure = overwrittenIds.values().stream().collect(Collectors.joining(", ")).             logger.info("overwrote watch history entries {}, possible second execution of a triggered watch, failure [{}]", overwrittenIds.keySet(), Strings.substring(failure, 0, 2000)).         }     } }
false;public;3;4;;@Override public void afterBulk(long executionId, BulkRequest request, Throwable failure) {     logger.error("error executing bulk", failure). }
false;public;9;169;;@Override public Collection<Object> createComponents(Client client, ClusterService clusterService, ThreadPool threadPool, ResourceWatcherService resourceWatcherService, ScriptService scriptService, NamedXContentRegistry xContentRegistry, Environment environment, NodeEnvironment nodeEnvironment, NamedWriteableRegistry namedWriteableRegistry) {     if (enabled == false) {         return Collections.emptyList().     }     // only initialize these classes if Watcher is enabled, and only after the plugin security policy for Watcher is in place     BodyPartSource.init().     Account.init().     final CryptoService cryptoService.     try {         cryptoService = ENCRYPT_SENSITIVE_DATA_SETTING.get(settings) ? new CryptoService(settings) : null.     } catch (IOException e) {         throw new UncheckedIOException(e).     }     new WatcherIndexTemplateRegistry(clusterService, threadPool, client, xContentRegistry).     // http client     httpClient = new HttpClient(settings, getSslService(), cryptoService, clusterService).     // notification     EmailService emailService = new EmailService(settings, cryptoService, clusterService.getClusterSettings()).     JiraService jiraService = new JiraService(settings, httpClient, clusterService.getClusterSettings()).     SlackService slackService = new SlackService(settings, httpClient, clusterService.getClusterSettings()).     PagerDutyService pagerDutyService = new PagerDutyService(settings, httpClient, clusterService.getClusterSettings()).     reloadableServices.add(emailService).     reloadableServices.add(jiraService).     reloadableServices.add(slackService).     reloadableServices.add(pagerDutyService).     TextTemplateEngine templateEngine = new TextTemplateEngine(scriptService).     Map<String, EmailAttachmentParser> emailAttachmentParsers = new HashMap<>().     emailAttachmentParsers.put(HttpEmailAttachementParser.TYPE, new HttpEmailAttachementParser(httpClient, templateEngine)).     emailAttachmentParsers.put(DataAttachmentParser.TYPE, new DataAttachmentParser()).     emailAttachmentParsers.put(ReportingAttachmentParser.TYPE, new ReportingAttachmentParser(settings, httpClient, templateEngine)).     EmailAttachmentsParser emailAttachmentsParser = new EmailAttachmentsParser(emailAttachmentParsers).     // conditions     final Map<String, ConditionFactory> parsers = new HashMap<>().     parsers.put(InternalAlwaysCondition.TYPE, (c, id, p) -> InternalAlwaysCondition.parse(id, p)).     parsers.put(NeverCondition.TYPE, (c, id, p) -> NeverCondition.parse(id, p)).     parsers.put(ArrayCompareCondition.TYPE, ArrayCompareCondition::parse).     parsers.put(CompareCondition.TYPE, CompareCondition::parse).     parsers.put(ScriptCondition.TYPE, (c, id, p) -> ScriptCondition.parse(scriptService, id, p)).     final ConditionRegistry conditionRegistry = new ConditionRegistry(Collections.unmodifiableMap(parsers), getClock()).     final Map<String, TransformFactory> transformFactories = new HashMap<>().     transformFactories.put(ScriptTransform.TYPE, new ScriptTransformFactory(scriptService)).     transformFactories.put(SearchTransform.TYPE, new SearchTransformFactory(settings, client, xContentRegistry, scriptService)).     final TransformRegistry transformRegistry = new TransformRegistry(Collections.unmodifiableMap(transformFactories)).     // actions     final Map<String, ActionFactory> actionFactoryMap = new HashMap<>().     actionFactoryMap.put(EmailAction.TYPE, new EmailActionFactory(settings, emailService, templateEngine, emailAttachmentsParser)).     actionFactoryMap.put(WebhookAction.TYPE, new WebhookActionFactory(httpClient, templateEngine)).     actionFactoryMap.put(IndexAction.TYPE, new IndexActionFactory(settings, client)).     actionFactoryMap.put(LoggingAction.TYPE, new LoggingActionFactory(templateEngine)).     actionFactoryMap.put(JiraAction.TYPE, new JiraActionFactory(templateEngine, jiraService)).     actionFactoryMap.put(SlackAction.TYPE, new SlackActionFactory(templateEngine, slackService)).     actionFactoryMap.put(PagerDutyAction.TYPE, new PagerDutyActionFactory(templateEngine, pagerDutyService)).     final ActionRegistry registry = new ActionRegistry(actionFactoryMap, conditionRegistry, transformRegistry, getClock(), getLicenseState()).     // inputs     final Map<String, InputFactory> inputFactories = new HashMap<>().     inputFactories.put(SearchInput.TYPE, new SearchInputFactory(settings, client, xContentRegistry, scriptService)).     inputFactories.put(SimpleInput.TYPE, new SimpleInputFactory()).     inputFactories.put(HttpInput.TYPE, new HttpInputFactory(settings, httpClient, templateEngine)).     inputFactories.put(NoneInput.TYPE, new NoneInputFactory()).     inputFactories.put(TransformInput.TYPE, new TransformInputFactory(transformRegistry)).     final InputRegistry inputRegistry = new InputRegistry(inputFactories).     inputFactories.put(ChainInput.TYPE, new ChainInputFactory(inputRegistry)).     bulkProcessor = BulkProcessor.builder(ClientHelper.clientWithOrigin(client, WATCHER_ORIGIN), new BulkProcessor.Listener() {          @Override         public void beforeBulk(long executionId, BulkRequest request) {         }          @Override         public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {             if (response.hasFailures()) {                 Map<String, String> triggeredWatches = Arrays.stream(response.getItems()).filter(BulkItemResponse::isFailed).filter(r -> r.getIndex().startsWith(TriggeredWatchStoreField.INDEX_NAME)).collect(Collectors.toMap(BulkItemResponse::getId, BulkItemResponse::getFailureMessage)).                 if (triggeredWatches.isEmpty() == false) {                     String failure = triggeredWatches.values().stream().collect(Collectors.joining(", ")).                     logger.error("triggered watches could not be deleted {}, failure [{}]", triggeredWatches.keySet(), Strings.substring(failure, 0, 2000)).                 }                 Map<String, String> overwrittenIds = Arrays.stream(response.getItems()).filter(BulkItemResponse::isFailed).filter(r -> r.getIndex().startsWith(HistoryStoreField.INDEX_PREFIX)).filter(r -> r.getVersion() > 1).collect(Collectors.toMap(BulkItemResponse::getId, BulkItemResponse::getFailureMessage)).                 if (overwrittenIds.isEmpty() == false) {                     String failure = overwrittenIds.values().stream().collect(Collectors.joining(", ")).                     logger.info("overwrote watch history entries {}, possible second execution of a triggered watch, failure [{}]", overwrittenIds.keySet(), Strings.substring(failure, 0, 2000)).                 }             }         }          @Override         public void afterBulk(long executionId, BulkRequest request, Throwable failure) {             logger.error("error executing bulk", failure).         }     }).setFlushInterval(SETTING_BULK_FLUSH_INTERVAL.get(settings)).setBulkActions(SETTING_BULK_ACTIONS.get(settings)).setBulkSize(SETTING_BULK_SIZE.get(settings)).setConcurrentRequests(SETTING_BULK_CONCURRENT_REQUESTS.get(settings)).build().     HistoryStore historyStore = new HistoryStore(bulkProcessor).     // schedulers     final Set<Schedule.Parser> scheduleParsers = new HashSet<>().     scheduleParsers.add(new CronSchedule.Parser()).     scheduleParsers.add(new DailySchedule.Parser()).     scheduleParsers.add(new HourlySchedule.Parser()).     scheduleParsers.add(new IntervalSchedule.Parser()).     scheduleParsers.add(new MonthlySchedule.Parser()).     scheduleParsers.add(new WeeklySchedule.Parser()).     scheduleParsers.add(new YearlySchedule.Parser()).     final ScheduleRegistry scheduleRegistry = new ScheduleRegistry(scheduleParsers).     TriggerEngine manualTriggerEngine = new ManualTriggerEngine().     final TriggerEngine configuredTriggerEngine = getTriggerEngine(getClock(), scheduleRegistry).     final Set<TriggerEngine> triggerEngines = new HashSet<>().     triggerEngines.add(manualTriggerEngine).     triggerEngines.add(configuredTriggerEngine).     final TriggerService triggerService = new TriggerService(triggerEngines).     final TriggeredWatch.Parser triggeredWatchParser = new TriggeredWatch.Parser(triggerService).     final TriggeredWatchStore triggeredWatchStore = new TriggeredWatchStore(settings, client, triggeredWatchParser, bulkProcessor).     final WatcherSearchTemplateService watcherSearchTemplateService = new WatcherSearchTemplateService(scriptService, xContentRegistry).     final WatchExecutor watchExecutor = getWatchExecutor(threadPool).     final WatchParser watchParser = new WatchParser(triggerService, registry, inputRegistry, cryptoService, getClock()).     final ExecutionService executionService = new ExecutionService(settings, historyStore, triggeredWatchStore, watchExecutor, getClock(), watchParser, clusterService, client, threadPool.generic()).     final Consumer<Iterable<TriggerEvent>> triggerEngineListener = getTriggerEngineListener(executionService).     triggerService.register(triggerEngineListener).     WatcherService watcherService = new WatcherService(settings, triggerService, triggeredWatchStore, executionService, watchParser, client).     final WatcherLifeCycleService watcherLifeCycleService = new WatcherLifeCycleService(clusterService, watcherService).     listener = new WatcherIndexingListener(watchParser, getClock(), triggerService).     clusterService.addListener(listener).     return Arrays.asList(registry, inputRegistry, historyStore, triggerService, triggeredWatchParser, watcherLifeCycleService, executionService, triggerEngineListener, watcherService, watchParser, configuredTriggerEngine, triggeredWatchStore, watcherSearchTemplateService, slackService, pagerDutyService). }
false;protected;2;3;;protected TriggerEngine getTriggerEngine(Clock clock, ScheduleRegistry scheduleRegistry) {     return new TickerScheduleTriggerEngine(settings, scheduleRegistry, clock). }
false;protected;1;3;;protected WatchExecutor getWatchExecutor(ThreadPool threadPool) {     return new InternalWatchExecutor(threadPool). }
false;protected;1;3;;protected Consumer<Iterable<TriggerEvent>> getTriggerEngineListener(ExecutionService executionService) {     return new AsyncTriggerEventConsumer(executionService). }
false;public;0;13;;@Override public Collection<Module> createGuiceModules() {     List<Module> modules = new ArrayList<>().     // currently assuming the only place clock is bound     modules.add(b -> b.bind(Clock.class).toInstance(getClock())).     modules.add(b -> {         XPackPlugin.bindFeatureSet(b, WatcherFeatureSet.class).         if (transportClient || enabled == false) {             b.bind(WatcherService.class).toProvider(Providers.of(null)).         }     }).     return modules. }
false;public;0;44;;@Override public List<Setting<?>> getSettings() {     List<Setting<?>> settings = new ArrayList<>().     settings.add(INDEX_WATCHER_TEMPLATE_VERSION_SETTING).     settings.add(MAX_STOP_TIMEOUT_SETTING).     settings.add(ExecutionService.DEFAULT_THROTTLE_PERIOD_SETTING).     settings.add(TickerScheduleTriggerEngine.TICKER_INTERVAL_SETTING).     settings.add(Setting.intSetting("xpack.watcher.execution.scroll.size", 0, Setting.Property.NodeScope)).     settings.add(Setting.intSetting("xpack.watcher.watch.scroll.size", 0, Setting.Property.NodeScope)).     settings.add(ENCRYPT_SENSITIVE_DATA_SETTING).     settings.add(WatcherField.ENCRYPTION_KEY_SETTING).     settings.add(Setting.simpleString("xpack.watcher.internal.ops.search.default_timeout", Setting.Property.NodeScope)).     settings.add(Setting.simpleString("xpack.watcher.internal.ops.bulk.default_timeout", Setting.Property.NodeScope)).     settings.add(Setting.simpleString("xpack.watcher.internal.ops.index.default_timeout", Setting.Property.NodeScope)).     settings.add(Setting.simpleString("xpack.watcher.actions.index.default_timeout", Setting.Property.NodeScope)).     settings.add(Setting.simpleString("xpack.watcher.actions.bulk.default_timeout", Setting.Property.NodeScope)).     settings.add(Setting.simpleString("xpack.watcher.index.rest.direct_access", Setting.Property.NodeScope)).     settings.add(Setting.simpleString("xpack.watcher.input.search.default_timeout", Setting.Property.NodeScope)).     settings.add(Setting.simpleString("xpack.watcher.transform.search.default_timeout", Setting.Property.NodeScope)).     settings.add(Setting.simpleString("xpack.watcher.execution.scroll.timeout", Setting.Property.NodeScope)).     // bulk processor configuration     settings.add(SETTING_BULK_ACTIONS).     settings.add(SETTING_BULK_CONCURRENT_REQUESTS).     settings.add(SETTING_BULK_FLUSH_INTERVAL).     settings.add(SETTING_BULK_SIZE).     // notification services     settings.addAll(SlackService.getSettings()).     settings.addAll(EmailService.getSettings()).     settings.addAll(HtmlSanitizer.getSettings()).     settings.addAll(JiraService.getSettings()).     settings.addAll(PagerDutyService.getSettings()).     settings.add(ReportingAttachmentParser.RETRIES_SETTING).     settings.add(ReportingAttachmentParser.INTERVAL_SETTING).     // http settings     settings.addAll(HttpSettings.getSettings()).     // encryption settings     CryptoService.addSettings(settings).     return settings. }
false;public;1;14;;@Override public List<ExecutorBuilder<?>> getExecutorBuilders(final Settings settings) {     if (enabled) {         final FixedExecutorBuilder builder = new FixedExecutorBuilder(settings, InternalWatchExecutor.THREAD_POOL_NAME, getWatcherThreadPoolSize(settings), 1000, "xpack.watcher.thread_pool").         return Collections.singletonList(builder).     }     return Collections.emptyList(). }
true;static;1;10;/**  * A method to indicate the size of the watcher thread pool  * As watches are primarily bound on I/O waiting and execute  * synchronously, it makes sense to have a certain minimum of a  * threadpool size. This means you should start with a fair number  * of threads which is more than the number of CPUs, but you also need  * to ensure that this number does not go crazy high if you have really  * beefy machines. This can still be configured manually.  *  * Calculation is as follows:  * Use five times the number of processors up until 50, then stick with the  * number of processors.  *  * If the node is not a data node, we will never need so much threads, so we  * just return 1 here, which still allows to execute a watch locally, but  * there is no need of managing any more threads here  *  * @param settings The current settings  * @return A number between 5 and the number of processors  */ ;/**  * A method to indicate the size of the watcher thread pool  * As watches are primarily bound on I/O waiting and execute  * synchronously, it makes sense to have a certain minimum of a  * threadpool size. This means you should start with a fair number  * of threads which is more than the number of CPUs, but you also need  * to ensure that this number does not go crazy high if you have really  * beefy machines. This can still be configured manually.  *  * Calculation is as follows:  * Use five times the number of processors up until 50, then stick with the  * number of processors.  *  * If the node is not a data node, we will never need so much threads, so we  * just return 1 here, which still allows to execute a watch locally, but  * there is no need of managing any more threads here  *  * @param settings The current settings  * @return A number between 5 and the number of processors  */ static int getWatcherThreadPoolSize(Settings settings) {     boolean isDataNode = Node.NODE_DATA_SETTING.get(settings).     if (isDataNode) {         int numberOfProcessors = EsExecutors.numberOfProcessors(settings).         long size = Math.max(Math.min(5 * numberOfProcessors, 50), numberOfProcessors).         return Math.toIntExact(size).     } else {         return 1.     } }
false;public;0;14;;@Override public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {     if (false == enabled) {         return emptyList().     }     return Arrays.asList(new ActionHandler<>(PutWatchAction.INSTANCE, TransportPutWatchAction.class), new ActionHandler<>(DeleteWatchAction.INSTANCE, TransportDeleteWatchAction.class), new ActionHandler<>(GetWatchAction.INSTANCE, TransportGetWatchAction.class), new ActionHandler<>(WatcherStatsAction.INSTANCE, TransportWatcherStatsAction.class), new ActionHandler<>(AckWatchAction.INSTANCE, TransportAckWatchAction.class), new ActionHandler<>(ActivateWatchAction.INSTANCE, TransportActivateWatchAction.class), new ActionHandler<>(WatcherServiceAction.INSTANCE, TransportWatcherServiceAction.class), new ActionHandler<>(ExecuteWatchAction.INSTANCE, TransportExecuteWatchAction.class)). }
false;public;7;17;;@Override public List<RestHandler> getRestHandlers(Settings settings, RestController restController, ClusterSettings clusterSettings, IndexScopedSettings indexScopedSettings, SettingsFilter settingsFilter, IndexNameExpressionResolver indexNameExpressionResolver, Supplier<DiscoveryNodes> nodesInCluster) {     if (false == enabled) {         return emptyList().     }     return Arrays.asList(new RestPutWatchAction(settings, restController), new RestDeleteWatchAction(settings, restController), new RestWatcherStatsAction(settings, restController), new RestGetWatchAction(settings, restController), new RestWatchServiceAction(settings, restController), new RestAckWatchAction(settings, restController), new RestActivateWatchAction(settings, restController), new RestExecuteWatchAction(settings, restController)). }
false;public;1;13;;@Override public void onIndexModule(IndexModule module) {     if (enabled == false || transportClient) {         return.     }     assert listener != null.     // this also means, that aliases pointing to this index have to follow this notation     if (module.getIndex().getName().startsWith(Watch.INDEX)) {         module.addIndexOperationListener(listener).     } }
false;static;2;59;;static void validAutoCreateIndex(Settings settings, Logger logger) {     String value = settings.get("action.auto_create_index").     if (value == null) {         return.     }     String errorMessage = LoggerMessageFormat.format("the [action.auto_create_index] setting value [{}] is too" + " restrictive. disable [action.auto_create_index] or set it to " + "[{},{},{}*]", (Object) value, Watch.INDEX, TriggeredWatchStoreField.INDEX_NAME, HistoryStoreField.INDEX_PREFIX).     if (Booleans.isFalse(value)) {         throw new IllegalArgumentException(errorMessage).     }     if (Booleans.isTrue(value)) {         return.     }     String[] matches = Strings.commaDelimitedListToStringArray(value).     List<String> indices = new ArrayList<>().     indices.add(".watches").     indices.add(".triggered_watches").     ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC).     indices.add(HistoryStoreField.getHistoryIndexNameForTime(now)).     indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusDays(1))).     indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(1))).     indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(2))).     indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(3))).     indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(4))).     indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(5))).     indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(6))).     for (String index : indices) {         boolean matched = false.         for (String match : matches) {             char c = match.charAt(0).             if (c == '-') {                 if (Regex.simpleMatch(match.substring(1), index)) {                     throw new IllegalArgumentException(errorMessage).                 }             } else if (c == '+') {                 if (Regex.simpleMatch(match.substring(1), index)) {                     matched = true.                     break.                 }             } else {                 if (Regex.simpleMatch(match, index)) {                     matched = true.                     break.                 }             }         }         if (!matched) {             throw new IllegalArgumentException(errorMessage).         }     }     logger.warn("the [action.auto_create_index] setting is configured to be restrictive [{}]. " + " for the next 6 months daily history indices are allowed to be created, but please make sure" + " that any future history indices after 6 months with the pattern " + "[.watcher-history-yyyy.MM.dd] are allowed to be created", value). }
true;public;0;7;// These are all old templates from pre 6.0 era, that need to be deleted ;// These are all old templates from pre 6.0 era, that need to be deleted @Override public UnaryOperator<Map<String, IndexTemplateMetaData>> getIndexTemplateMetaDataUpgrader() {     return map -> {         map.keySet().removeIf(name -> name.startsWith("watch_history_")).         return map.     }. }
false;public;0;4;;@Override public List<BootstrapCheck> getBootstrapChecks() {     return Collections.singletonList(new EncryptSensitiveDataBootstrapCheck()). }
false;public;0;4;;@Override public List<ScriptContext<?>> getContexts() {     return Arrays.asList(WatcherTransformScript.CONTEXT, WatcherConditionScript.CONTEXT, Watcher.SCRIPT_TEMPLATE_CONTEXT). }
false;public;0;14;;@Override public void close() throws IOException {     if (enabled) {         bulkProcessor.flush().     }     IOUtils.closeWhileHandlingException(httpClient).     try {         if (enabled && bulkProcessor.awaitClose(10, TimeUnit.SECONDS) == false) {             logger.warn("failed to properly close watcher bulk processor").         }     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } }
true;public;1;7;/**  * Reloads all the reloadable services in watcher.  */ ;/**  * Reloads all the reloadable services in watcher.  */ @Override public void reload(Settings settings) {     if (enabled == false || transportClient) {         return.     }     reloadableServices.forEach(s -> s.reload(settings)). }
