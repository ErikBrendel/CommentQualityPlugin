commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;0;3;;public int[] minutes() {     return minutes. }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (params.paramAsBoolean("normalize", false) && minutes.length == 1) {         builder.field(Parser.MINUTE_FIELD.getPreferredName(), minutes[0]).     } else {         builder.array(Parser.MINUTE_FIELD.getPreferredName(), minutes).     }     return builder.endObject(). }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;static;1;14;;static String cron(int[] minutes) {     assert minutes.length > 0 : "at least one minute must be defined".     StringBuilder sb = new StringBuilder("0 ").     for (int i = 0. i < minutes.length. i++) {         if (i != 0) {             sb.append(",").         }         if (!validMinute(minutes[i])) {             throw illegalArgument("invalid hourly minute [{}]. minute must be between 0 and 59 incl.", minutes[i]).         }         sb.append(minutes[i]).     }     return sb.append(" * * * ?").toString(). }
false;static;1;3;;static boolean validMinute(int minute) {     return minute >= 0 && minute < 60. }
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;1;40;;@Override public HourlySchedule parse(XContentParser parser) throws IOException {     List<Integer> minutes = new ArrayList<>().     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (currentFieldName == null) {             throw new ElasticsearchParseException("could not parse [{}] schedule. unexpected token [{}]", TYPE, token).         } else if (MINUTE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 try {                     minutes.add(DayTimes.parseMinuteValue(parser, token)).                 } catch (ElasticsearchParseException pe) {                     throw new ElasticsearchParseException("could not parse [{}] schedule. invalid value for [{}]", pe, TYPE, currentFieldName).                 }             } else if (token == XContentParser.Token.START_ARRAY) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     try {                         minutes.add(DayTimes.parseMinuteValue(parser, token)).                     } catch (ElasticsearchParseException pe) {                         throw new ElasticsearchParseException("could not parse [{}] schedule. invalid value for [{}]", pe, TYPE, currentFieldName).                     }                 }             } else {                 throw new ElasticsearchParseException("could not parse [{}] schedule. invalid value for [{}]. " + "expected either string/value or an array of string/number values, but found [{}]", TYPE, currentFieldName, token).             }         } else {             throw new ElasticsearchParseException("could not parse [{}] schedule. unexpected field [{}]", TYPE, currentFieldName).         }     }     return minutes.isEmpty() ? new HourlySchedule() : new HourlySchedule(CollectionUtils.toArray(minutes)). }
false;public;1;6;;public Builder minutes(int... minutes) {     for (int minute : minutes) {         this.minutes.add(minute).     }     return this. }
false;public;0;3;;public HourlySchedule build() {     return minutes.isEmpty() ? new HourlySchedule() : new HourlySchedule(CollectionUtils.toArray(minutes)). }
