commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public CollationFieldType clone() {     return new CollationFieldType(this). }
false;public;1;4;;@Override public boolean equals(Object o) {     return super.equals(o) && Objects.equals(collator, ((CollationFieldType) o).collator). }
false;public;2;8;;@Override public void checkCompatibility(MappedFieldType otherFT, List<String> conflicts) {     super.checkCompatibility(otherFT, conflicts).     CollationFieldType other = (CollationFieldType) otherFT.     if (!Objects.equals(collator, other.collator)) {         conflicts.add("mapper [" + name() + "] has different [collator]").     } }
false;public;0;4;;@Override public int hashCode() {     return 31 * super.hashCode() + Objects.hashCode(collator). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;0;3;;public Collator collator() {     return collator. }
false;public;1;4;;public void setCollator(Collator collator) {     checkIfFrozen().     this.collator = collator.isFrozen() ? collator : collator.freeze(). }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     if (hasDocValues()) {         return new DocValuesFieldExistsQuery(name()).     } else {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new DocValuesIndexFieldData.Builder(). }
false;protected;1;16;;@Override protected BytesRef indexedValueForSearch(Object value) {     if (value == null) {         return null.     }     if (value instanceof BytesRef) {         value = ((BytesRef) value).utf8ToString().     }     if (collator != null) {         RawCollationKey key = collator.getRawCollationKey(value.toString(), null).         return new BytesRef(key.bytes, 0, key.size).     } else {         throw new IllegalStateException("collator is null").     } }
false;public;5;5;;@Override public Query fuzzyQuery(Object value, Fuzziness fuzziness, int prefixLength, int maxExpansions, boolean transpositions) {     throw new UnsupportedOperationException("[fuzzy] queries are not supported on [" + CONTENT_TYPE + "] fields."). }
false;public;3;4;;@Override public Query prefixQuery(String value, MultiTermQuery.RewriteMethod method, QueryShardContext context) {     throw new UnsupportedOperationException("[prefix] queries are not supported on [" + CONTENT_TYPE + "] fields."). }
false;public;3;6;;@Override public Query wildcardQuery(String value, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {     throw new UnsupportedOperationException("[wildcard] queries are not supported on [" + CONTENT_TYPE + "] fields."). }
false;public;5;5;;@Override public Query regexpQuery(String value, int flags, int maxDeterminizedStates, MultiTermQuery.RewriteMethod method, QueryShardContext context) {     throw new UnsupportedOperationException("[regexp] queries are not supported on [" + CONTENT_TYPE + "] fields."). }
false;public;0;4;;@Override public String getWriteableName() {     return "collate". }
false;public;1;3;;@Override public void writeTo(StreamOutput out) { }
false;public;1;7;;@Override public String format(BytesRef value) {     int encodedLength = IndexableBinaryStringTools.getEncodedLength(value.bytes, value.offset, value.length).     char[] encoded = new char[encodedLength].     IndexableBinaryStringTools.encode(value.bytes, value.offset, value.length, encoded, 0, encodedLength).     return new String(encoded, 0, encodedLength). }
false;public;1;8;;@Override public BytesRef parseBytesRef(String value) {     char[] encoded = value.toCharArray().     int decodedLength = IndexableBinaryStringTools.getDecodedLength(encoded, 0, encoded.length).     byte[] decoded = new byte[decodedLength].     IndexableBinaryStringTools.decode(encoded, 0, encoded.length, decoded, 0, decodedLength).     return new BytesRef(decoded). }
false;public;2;4;;@Override public DocValueFormat docValueFormat(final String format, final ZoneId timeZone) {     return COLLATE_FORMAT. }
false;public;0;4;;@Override public CollationFieldType fieldType() {     return (CollationFieldType) super.fieldType(). }
false;public;1;9;;@Override public Builder indexOptions(IndexOptions indexOptions) {     if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) > 0) {         throw new IllegalArgumentException("The [" + CONTENT_TYPE + "] field does not support positions, got [index_options]=" + indexOptionToString(indexOptions)).     }     return super.indexOptions(indexOptions). }
false;public;0;3;;public String rules() {     return rules. }
false;public;1;4;;public Builder rules(final String rules) {     this.rules = rules.     return this. }
false;public;0;3;;public String language() {     return language. }
false;public;1;4;;public Builder language(final String language) {     this.language = language.     return this. }
false;public;0;3;;public String country() {     return country. }
false;public;1;4;;public Builder country(final String country) {     this.country = country.     return this. }
false;public;0;3;;public String variant() {     return variant. }
false;public;1;4;;public Builder variant(final String variant) {     this.variant = variant.     return this. }
false;public;0;3;;public String strength() {     return strength. }
false;public;1;4;;public Builder strength(final String strength) {     this.strength = strength.     return this. }
false;public;0;3;;public String decomposition() {     return decomposition. }
false;public;1;4;;public Builder decomposition(final String decomposition) {     this.decomposition = decomposition.     return this. }
false;public;0;3;;public String alternate() {     return alternate. }
false;public;1;4;;public Builder alternate(final String alternate) {     this.alternate = alternate.     return this. }
false;public;0;3;;public boolean caseLevel() {     return caseLevel. }
false;public;1;4;;public Builder caseLevel(final boolean caseLevel) {     this.caseLevel = caseLevel.     return this. }
false;public;0;3;;public String caseFirst() {     return caseFirst. }
false;public;1;4;;public Builder caseFirst(final String caseFirst) {     this.caseFirst = caseFirst.     return this. }
false;public;0;3;;public boolean numeric() {     return numeric. }
false;public;1;4;;public Builder numeric(final boolean numeric) {     this.numeric = numeric.     return this. }
false;public;0;3;;public String variableTop() {     return variableTop. }
false;public;1;4;;public Builder variableTop(final String variableTop) {     this.variableTop = variableTop.     return this. }
false;public;0;3;;public boolean hiraganaQuaternaryMode() {     return hiraganaQuaternaryMode. }
false;public;1;4;;public Builder hiraganaQuaternaryMode(final boolean hiraganaQuaternaryMode) {     this.hiraganaQuaternaryMode = hiraganaQuaternaryMode.     return this. }
false;public;0;95;;public Collator buildCollator() {     Collator collator.     if (rules != null) {         try {             collator = new RuleBasedCollator(rules).         } catch (Exception e) {             throw new IllegalArgumentException("Failed to parse collation rules", e).         }     } else {         if (language != null) {             ULocale locale.             if (country != null) {                 if (variant != null) {                     locale = new ULocale(language, country, variant).                 } else {                     locale = new ULocale(language, country).                 }             } else {                 locale = new ULocale(language).             }             collator = Collator.getInstance(locale).         } else {             collator = Collator.getInstance(ULocale.ROOT).         }     }     // set the strength flag, otherwise it will be the default.     if (strength != null) {         if (strength.equalsIgnoreCase("primary")) {             collator.setStrength(Collator.PRIMARY).         } else if (strength.equalsIgnoreCase("secondary")) {             collator.setStrength(Collator.SECONDARY).         } else if (strength.equalsIgnoreCase("tertiary")) {             collator.setStrength(Collator.TERTIARY).         } else if (strength.equalsIgnoreCase("quaternary")) {             collator.setStrength(Collator.QUATERNARY).         } else if (strength.equalsIgnoreCase("identical")) {             collator.setStrength(Collator.IDENTICAL).         } else {             throw new IllegalArgumentException("Invalid strength: " + strength).         }     }     // set the decomposition flag, otherwise it will be the default.     if (decomposition != null) {         if (decomposition.equalsIgnoreCase("no")) {             collator.setDecomposition(Collator.NO_DECOMPOSITION).         } else if (decomposition.equalsIgnoreCase("canonical")) {             collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION).         } else {             throw new IllegalArgumentException("Invalid decomposition: " + decomposition).         }     }     // expert options: concrete subclasses are always a RuleBasedCollator     RuleBasedCollator rbc = (RuleBasedCollator) collator.     if (alternate != null) {         if (alternate.equalsIgnoreCase("shifted")) {             rbc.setAlternateHandlingShifted(true).         } else if (alternate.equalsIgnoreCase("non-ignorable")) {             rbc.setAlternateHandlingShifted(false).         } else {             throw new IllegalArgumentException("Invalid alternate: " + alternate).         }     }     if (caseLevel) {         rbc.setCaseLevel(true).     }     if (caseFirst != null) {         if (caseFirst.equalsIgnoreCase("lower")) {             rbc.setLowerCaseFirst(true).         } else if (caseFirst.equalsIgnoreCase("upper")) {             rbc.setUpperCaseFirst(true).         } else {             throw new IllegalArgumentException("Invalid caseFirst: " + caseFirst).         }     }     if (numeric) {         rbc.setNumericCollation(true).     }     if (variableTop != null) {         rbc.setVariableTop(variableTop).     }     if (hiraganaQuaternaryMode) {         rbc.setHiraganaQuaternary(true).     }     // freeze so thread-safe     return collator.freeze(). }
false;public;1;9;;@Override public ICUCollationKeywordFieldMapper build(BuilderContext context) {     final Collator collator = buildCollator().     fieldType().setCollator(collator).     setupFieldType(context).     return new ICUCollationKeywordFieldMapper(name, fieldType, defaultFieldType, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo, rules, language, country, variant, strength, decomposition, alternate, caseLevel, caseFirst, numeric, variableTop, hiraganaQuaternaryMode, collator). }
false;public;3;76;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder(name).     TypeParsers.parseField(builder, name, node, parserContext).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String fieldName = entry.getKey().         Object fieldNode = entry.getValue().         switch(fieldName) {             case "null_value":                 if (fieldNode == null) {                     throw new MapperParsingException("Property [null_value] cannot be null.").                 }                 builder.nullValue(fieldNode.toString()).                 iterator.remove().                 break.             case "norms":                 builder.omitNorms(!XContentMapValues.nodeBooleanValue(fieldNode, "norms")).                 iterator.remove().                 break.             case "rules":                 builder.rules(XContentMapValues.nodeStringValue(fieldNode, null)).                 iterator.remove().                 break.             case "language":                 builder.language(XContentMapValues.nodeStringValue(fieldNode, null)).                 iterator.remove().                 break.             case "country":                 builder.country(XContentMapValues.nodeStringValue(fieldNode, null)).                 iterator.remove().                 break.             case "variant":                 builder.variant(XContentMapValues.nodeStringValue(fieldNode, null)).                 iterator.remove().                 break.             case "strength":                 builder.strength(XContentMapValues.nodeStringValue(fieldNode, null)).                 iterator.remove().                 break.             case "decomposition":                 builder.decomposition(XContentMapValues.nodeStringValue(fieldNode, null)).                 iterator.remove().                 break.             case "alternate":                 builder.alternate(XContentMapValues.nodeStringValue(fieldNode, null)).                 iterator.remove().                 break.             case "case_level":                 builder.caseLevel(XContentMapValues.nodeBooleanValue(fieldNode, false)).                 iterator.remove().                 break.             case "case_first":                 builder.caseFirst(XContentMapValues.nodeStringValue(fieldNode, null)).                 iterator.remove().                 break.             case "numeric":                 builder.numeric(XContentMapValues.nodeBooleanValue(fieldNode, false)).                 iterator.remove().                 break.             case "variable_top":                 builder.variableTop(XContentMapValues.nodeStringValue(fieldNode, null)).                 iterator.remove().                 break.             case "hiragana_quaternary_mode":                 builder.hiraganaQuaternaryMode(XContentMapValues.nodeBooleanValue(fieldNode, false)).                 iterator.remove().                 break.             default:                 break.         }     }     return builder. }
false;public;0;4;;@Override public CollationFieldType fieldType() {     return (CollationFieldType) super.fieldType(). }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;protected;1;59;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     List<String> conflicts = new ArrayList<>().     ICUCollationKeywordFieldMapper icuMergeWith = (ICUCollationKeywordFieldMapper) mergeWith.     if (!Objects.equals(rules, icuMergeWith.rules)) {         conflicts.add("Cannot update rules setting for [" + CONTENT_TYPE + "]").     }     if (!Objects.equals(language, icuMergeWith.language)) {         conflicts.add("Cannot update language setting for [" + CONTENT_TYPE + "]").     }     if (!Objects.equals(country, icuMergeWith.country)) {         conflicts.add("Cannot update country setting for [" + CONTENT_TYPE + "]").     }     if (!Objects.equals(variant, icuMergeWith.variant)) {         conflicts.add("Cannot update variant setting for [" + CONTENT_TYPE + "]").     }     if (!Objects.equals(strength, icuMergeWith.strength)) {         conflicts.add("Cannot update strength setting for [" + CONTENT_TYPE + "]").     }     if (!Objects.equals(decomposition, icuMergeWith.decomposition)) {         conflicts.add("Cannot update decomposition setting for [" + CONTENT_TYPE + "]").     }     if (!Objects.equals(alternate, icuMergeWith.alternate)) {         conflicts.add("Cannot update alternate setting for [" + CONTENT_TYPE + "]").     }     if (caseLevel != icuMergeWith.caseLevel) {         conflicts.add("Cannot update case_level setting for [" + CONTENT_TYPE + "]").     }     if (!Objects.equals(caseFirst, icuMergeWith.caseFirst)) {         conflicts.add("Cannot update case_first setting for [" + CONTENT_TYPE + "]").     }     if (numeric != icuMergeWith.numeric) {         conflicts.add("Cannot update numeric setting for [" + CONTENT_TYPE + "]").     }     if (!Objects.equals(variableTop, icuMergeWith.variableTop)) {         conflicts.add("Cannot update variable_top setting for [" + CONTENT_TYPE + "]").     }     if (hiraganaQuaternaryMode != icuMergeWith.hiraganaQuaternaryMode) {         conflicts.add("Cannot update hiragana_quaternary_mode setting for [" + CONTENT_TYPE + "]").     }     if (!conflicts.isEmpty()) {         throw new IllegalArgumentException("Can't merge because of conflicts: " + conflicts).     } }
false;protected;3;56;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     if (includeDefaults || fieldType().nullValue() != null) {         builder.field("null_value", fieldType().nullValue()).     }     if (includeDefaults || rules != null) {         builder.field("rules", rules).     }     if (includeDefaults || language != null) {         builder.field("language", language).     }     if (includeDefaults || country != null) {         builder.field("country", country).     }     if (includeDefaults || variant != null) {         builder.field("variant", variant).     }     if (includeDefaults || strength != null) {         builder.field("strength", strength).     }     if (includeDefaults || decomposition != null) {         builder.field("decomposition", decomposition).     }     if (includeDefaults || alternate != null) {         builder.field("alternate", alternate).     }     if (includeDefaults || caseLevel) {         builder.field("case_level", caseLevel).     }     if (includeDefaults || caseFirst != null) {         builder.field("case_first", caseFirst).     }     if (includeDefaults || numeric) {         builder.field("numeric", numeric).     }     if (includeDefaults || variableTop != null) {         builder.field("variable_top", variableTop).     }     if (includeDefaults || hiraganaQuaternaryMode) {         builder.field("hiragana_quaternary_mode", hiraganaQuaternaryMode).     } }
false;protected;2;32;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     final String value.     if (context.externalValueSet()) {         value = context.externalValue().toString().     } else {         XContentParser parser = context.parser().         if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {             value = fieldType().nullValueAsString().         } else {             value = parser.textOrNull().         }     }     if (value == null) {         return.     }     RawCollationKey key = collator.getRawCollationKey(value, null).     final BytesRef binaryValue = new BytesRef(key.bytes, 0, key.size).     if (fieldType().indexOptions() != IndexOptions.NONE || fieldType().stored()) {         Field field = new Field(fieldType().name(), binaryValue, fieldType()).         fields.add(field).     }     if (fieldType().hasDocValues()) {         fields.add(new SortedSetDocValuesField(fieldType().name(), binaryValue)).     } else if (fieldType().indexOptions() != IndexOptions.NONE || fieldType().stored()) {         createFieldNamesField(context, fields).     } }
