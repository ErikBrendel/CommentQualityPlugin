commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getType() {     return type. }
false;public,static;1;8;;public static HostType fromString(String type) {     for (HostType hostType : values()) {         if (hostType.type.equalsIgnoreCase(type)) {             return hostType.         }     }     throw new IllegalArgumentException("invalid value for host type [" + type + "]"). }
false;public,static;1;8;;public static Deployment fromString(String string) {     for (Deployment deployment : values()) {         if (deployment.deployment.equalsIgnoreCase(string)) {             return deployment.         }     }     throw new IllegalArgumentException("invalid value for deployment type [" + string + "]"). }
true;public;1;88;/**  * We build the list of Nodes from Azure Management API  * Information can be cached using `cloud.azure.refresh_interval` property if needed.  * Setting `cloud.azure.refresh_interval` to `-1` will cause infinite caching.  * Setting `cloud.azure.refresh_interval` to `0` will disable caching (default).  */ ;/**  * We build the list of Nodes from Azure Management API  * Information can be cached using `cloud.azure.refresh_interval` property if needed.  * Setting `cloud.azure.refresh_interval` to `-1` will cause infinite caching.  * Setting `cloud.azure.refresh_interval` to `0` will disable caching (default).  */ @Override public List<TransportAddress> getSeedAddresses(HostsResolver hostsResolver) {     if (refreshInterval.millis() != 0) {         if (dynamicHosts != null && (refreshInterval.millis() < 0 || (System.currentTimeMillis() - lastRefresh) < refreshInterval.millis())) {             logger.trace("using cache to retrieve node list").             return dynamicHosts.         }         lastRefresh = System.currentTimeMillis().     }     logger.debug("start building nodes list using Azure API").     dynamicHosts = new ArrayList<>().     HostedServiceGetDetailedResponse detailed.     try {         detailed = azureComputeService.getServiceDetails().     } catch (AzureServiceDisableException e) {         logger.debug("Azure discovery service has been disabled. Returning empty list of nodes.").         return dynamicHosts.     } catch (AzureServiceRemoteException e) {         // We got a remote exception         logger.warn("can not get list of azure nodes: [{}]. Returning empty list of nodes.", e.getMessage()).         logger.trace("AzureServiceRemoteException caught", e).         return dynamicHosts.     }     InetAddress ipAddress = null.     try {         ipAddress = networkService.resolvePublishHostAddresses(NetworkService.GLOBAL_NETWORK_PUBLISH_HOST_SETTING.get(settings).toArray(Strings.EMPTY_ARRAY)).         logger.trace("ip of current node: [{}]", ipAddress).     } catch (IOException e) {         // We can't find the publish host address... Hmmm. Too bad :-(         logger.trace("exception while finding ip", e).     }     for (HostedServiceGetDetailedResponse.Deployment deployment : detailed.getDeployments()) {         // We check the deployment slot         if (deployment.getDeploymentSlot() != deploymentSlot) {             logger.debug("current deployment slot [{}] for [{}] is different from [{}]. skipping...", deployment.getDeploymentSlot(), deployment.getName(), deploymentSlot).             continue.         }         // If provided, we check the deployment name         if (Strings.hasLength(deploymentName) && !deploymentName.equals(deployment.getName())) {             logger.debug("current deployment name [{}] different from [{}]. skipping...", deployment.getName(), deploymentName).             continue.         }         // We check current deployment status         if (deployment.getStatus() != DeploymentStatus.Starting && deployment.getStatus() != DeploymentStatus.Deploying && deployment.getStatus() != DeploymentStatus.Running) {             logger.debug("[{}] status is [{}]. skipping...", deployment.getName(), deployment.getStatus()).             continue.         }         for (RoleInstance instance : deployment.getRoleInstances()) {             final String networkAddress = resolveInstanceAddress(hostType, instance).             if (networkAddress == null) {                 // We have a bad parameter here or not enough information from azure                 logger.warn("no network address found. ignoring [{}]...", instance.getInstanceName()).                 continue.             }             try {                 // we only limit to 1 port per address, makes no sense to ping 100 ports                 TransportAddress[] addresses = transportService.addressesFromString(networkAddress, 1).                 for (TransportAddress address : addresses) {                     logger.trace("adding {}, transport_address {}", networkAddress, address).                     dynamicHosts.add(address).                 }             } catch (Exception e) {                 logger.warn("can not convert [{}] to transport address. skipping. [{}]", networkAddress, e.getMessage()).             }         }     }     logger.debug("{} addresses added", dynamicHosts.size()).     return dynamicHosts. }
false;protected;2;19;;protected String resolveInstanceAddress(final HostType hostType, final RoleInstance instance) {     if (hostType == HostType.PRIVATE_IP) {         final InetAddress privateIp = instance.getIPAddress().         if (privateIp != null) {             return InetAddresses.toUriString(privateIp).         } else {             logger.trace("no private ip provided. ignoring [{}]...", instance.getInstanceName()).         }     } else if (hostType == HostType.PUBLIC_IP) {         for (InstanceEndpoint endpoint : instance.getInstanceEndpoints()) {             if (publicEndpointName.equals(endpoint.getName())) {                 return NetworkAddress.format(new InetSocketAddress(endpoint.getVirtualIPAddress(), endpoint.getPort())).             } else {                 logger.trace("ignoring endpoint [{}] as different than [{}]", endpoint.getName(), publicEndpointName).             }         }     }     return null. }
