commented;modifiers;parameterAmount;loc;comment;code
false;private;0;3;;private Storage client() throws IOException {     return storageService.client(clientName). }
false;public;1;4;;@Override public BlobContainer blobContainer(BlobPath path) {     return new GoogleCloudStorageBlobContainer(path, this). }
false;public;1;4;;@Override public void delete(BlobPath path) throws IOException {     deleteBlobsByPrefix(path.buildAsString()). }
false;public;0;3;;@Override public void close() { }
true;;1;8;/**  * Return true iff the given bucket exists  *  * @param bucketName name of the bucket  * @return true iff the bucket exists  */ ;/**  * Return true iff the given bucket exists  *  * @param bucketName name of the bucket  * @return true iff the bucket exists  */ boolean doesBucketExist(String bucketName) {     try {         final Bucket bucket = SocketAccess.doPrivilegedIOException(() -> client().get(bucketName)).         return bucket != null.     } catch (final Exception e) {         throw new BlobStoreException("Unable to check if bucket [" + bucketName + "] exists", e).     } }
true;;1;3;/**  * List blobs in the specific bucket under the specified path. The path root is removed.  *  * @param path base path of the blobs to list  * @return a map of blob names and their metadata  */ ;/**  * List blobs in the specific bucket under the specified path. The path root is removed.  *  * @param path base path of the blobs to list  * @return a map of blob names and their metadata  */ Map<String, BlobMetaData> listBlobs(String path) throws IOException {     return listBlobsByPrefix(path, ""). }
true;;2;12;/**  * List all blobs in the specific bucket with names prefixed  *  * @param path  *            base path of the blobs to list. This path is removed from the  *            names of the blobs returned.  * @param prefix prefix of the blobs to list.  * @return a map of blob names and their metadata.  */ ;/**  * List all blobs in the specific bucket with names prefixed  *  * @param path  *            base path of the blobs to list. This path is removed from the  *            names of the blobs returned.  * @param prefix prefix of the blobs to list.  * @return a map of blob names and their metadata.  */ Map<String, BlobMetaData> listBlobsByPrefix(String path, String prefix) throws IOException {     final String pathPrefix = buildKey(path, prefix).     final MapBuilder<String, BlobMetaData> mapBuilder = MapBuilder.newMapBuilder().     SocketAccess.doPrivilegedVoidIOException(() -> {         client().get(bucketName).list(BlobListOption.prefix(pathPrefix)).iterateAll().forEach(blob -> {             assert blob.getName().startsWith(path).             final String suffixName = blob.getName().substring(path.length()).             mapBuilder.put(suffixName, new PlainBlobMetaData(suffixName, blob.getSize())).         }).     }).     return mapBuilder.immutableMap(). }
true;;1;5;/**  * Returns true if the blob exists in the specific bucket  *  * @param blobName name of the blob  * @return true iff the blob exists  */ ;/**  * Returns true if the blob exists in the specific bucket  *  * @param blobName name of the blob  * @return true iff the blob exists  */ boolean blobExists(String blobName) throws IOException {     final BlobId blobId = BlobId.of(bucketName, blobName).     final Blob blob = SocketAccess.doPrivilegedIOException(() -> client().get(blobId)).     return blob != null. }
false;public;1;12;;@SuppressForbidden(reason = "Channel is based of a socket not a file") @Override public int read(ByteBuffer dst) throws IOException {     try {         return SocketAccess.doPrivilegedIOException(() -> readChannel.read(dst)).     } catch (StorageException e) {         if (e.getCode() == HTTP_NOT_FOUND) {             throw new NoSuchFileException("Blob [" + blobName + "] does not exist").         }         throw e.     } }
false;public;0;4;;@Override public boolean isOpen() {     return readChannel.isOpen(). }
false;public;0;4;;@Override public void close() throws IOException {     SocketAccess.doPrivilegedVoidIOException(readChannel::close). }
true;;1;28;/**  * Returns an {@link java.io.InputStream} for the given blob name  *  * @param blobName name of the blob  * @return the InputStream used to read the blob's content  */ ;/**  * Returns an {@link java.io.InputStream} for the given blob name  *  * @param blobName name of the blob  * @return the InputStream used to read the blob's content  */ InputStream readBlob(String blobName) throws IOException {     final BlobId blobId = BlobId.of(bucketName, blobName).     final ReadChannel readChannel = SocketAccess.doPrivilegedIOException(() -> client().reader(blobId)).     return Channels.newInputStream(new ReadableByteChannel() {          @SuppressForbidden(reason = "Channel is based of a socket not a file")         @Override         public int read(ByteBuffer dst) throws IOException {             try {                 return SocketAccess.doPrivilegedIOException(() -> readChannel.read(dst)).             } catch (StorageException e) {                 if (e.getCode() == HTTP_NOT_FOUND) {                     throw new NoSuchFileException("Blob [" + blobName + "] does not exist").                 }                 throw e.             }         }          @Override         public boolean isOpen() {             return readChannel.isOpen().         }          @Override         public void close() throws IOException {             SocketAccess.doPrivilegedVoidIOException(readChannel::close).         }     }). }
true;;4;8;/**  * Writes a blob in the specific bucket  *  @param inputStream content of the blob to be written  * @param blobSize    expected size of the blob to be written  * @param failIfAlreadyExists whether to throw a FileAlreadyExistsException if the given blob already exists  */ ;/**  * Writes a blob in the specific bucket  *  @param inputStream content of the blob to be written  * @param blobSize    expected size of the blob to be written  * @param failIfAlreadyExists whether to throw a FileAlreadyExistsException if the given blob already exists  */ void writeBlob(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {     final BlobInfo blobInfo = BlobInfo.newBuilder(bucketName, blobName).build().     if (blobSize > LARGE_BLOB_THRESHOLD_BYTE_SIZE) {         writeBlobResumable(blobInfo, inputStream, failIfAlreadyExists).     } else {         writeBlobMultipart(blobInfo, inputStream, blobSize, failIfAlreadyExists).     } }
false;public;0;4;;@Override public boolean isOpen() {     return writeChannel.isOpen(). }
false;public;0;4;;@Override public void close() throws IOException {     SocketAccess.doPrivilegedVoidIOException(writeChannel::close). }
false;public;1;5;;@SuppressForbidden(reason = "Channel is based of a socket not a file") @Override public int write(ByteBuffer src) throws IOException {     return SocketAccess.doPrivilegedIOException(() -> writeChannel.write(src)). }
true;private;3;31;/**  * Uploads a blob using the "resumable upload" method (multiple requests, which  * can be independently retried in case of failure, see  * https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload  * @param blobInfo the info for the blob to be uploaded  * @param inputStream the stream containing the blob data  * @param failIfAlreadyExists whether to throw a FileAlreadyExistsException if the given blob already exists  */ ;/**  * Uploads a blob using the "resumable upload" method (multiple requests, which  * can be independently retried in case of failure, see  * https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload  * @param blobInfo the info for the blob to be uploaded  * @param inputStream the stream containing the blob data  * @param failIfAlreadyExists whether to throw a FileAlreadyExistsException if the given blob already exists  */ private void writeBlobResumable(BlobInfo blobInfo, InputStream inputStream, boolean failIfAlreadyExists) throws IOException {     try {         final Storage.BlobWriteOption[] writeOptions = failIfAlreadyExists ? new Storage.BlobWriteOption[] { Storage.BlobWriteOption.doesNotExist() } : new Storage.BlobWriteOption[0].         final WriteChannel writeChannel = SocketAccess.doPrivilegedIOException(() -> client().writer(blobInfo, writeOptions)).         Streams.copy(inputStream, Channels.newOutputStream(new WritableByteChannel() {              @Override             public boolean isOpen() {                 return writeChannel.isOpen().             }              @Override             public void close() throws IOException {                 SocketAccess.doPrivilegedVoidIOException(writeChannel::close).             }              @SuppressForbidden(reason = "Channel is based of a socket not a file")             @Override             public int write(ByteBuffer src) throws IOException {                 return SocketAccess.doPrivilegedIOException(() -> writeChannel.write(src)).             }         })).     } catch (final StorageException se) {         if (failIfAlreadyExists && se.getCode() == HTTP_PRECON_FAILED) {             throw new FileAlreadyExistsException(blobInfo.getBlobId().getName(), null, se.getMessage()).         }         throw se.     } }
true;private;4;18;/**  * Uploads a blob using the "multipart upload" method (a single  * 'multipart/related' request containing both data and metadata. The request is  * gziped), see:  * https://cloud.google.com/storage/docs/json_api/v1/how-tos/multipart-upload  *  @param blobInfo the info for the blob to be uploaded  * @param inputStream the stream containing the blob data  * @param blobSize the size  * @param failIfAlreadyExists whether to throw a FileAlreadyExistsException if the given blob already exists  */ ;/**  * Uploads a blob using the "multipart upload" method (a single  * 'multipart/related' request containing both data and metadata. The request is  * gziped), see:  * https://cloud.google.com/storage/docs/json_api/v1/how-tos/multipart-upload  *  @param blobInfo the info for the blob to be uploaded  * @param inputStream the stream containing the blob data  * @param blobSize the size  * @param failIfAlreadyExists whether to throw a FileAlreadyExistsException if the given blob already exists  */ private void writeBlobMultipart(BlobInfo blobInfo, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {     assert blobSize <= LARGE_BLOB_THRESHOLD_BYTE_SIZE : "large blob uploads should use the resumable upload method".     final ByteArrayOutputStream baos = new ByteArrayOutputStream(Math.toIntExact(blobSize)).     Streams.copy(inputStream, baos).     try {         final Storage.BlobTargetOption[] targetOptions = failIfAlreadyExists ? new Storage.BlobTargetOption[] { Storage.BlobTargetOption.doesNotExist() } : new Storage.BlobTargetOption[0].         SocketAccess.doPrivilegedVoidIOException(() -> client().create(blobInfo, baos.toByteArray(), targetOptions)).     } catch (final StorageException se) {         if (failIfAlreadyExists && se.getCode() == HTTP_PRECON_FAILED) {             throw new FileAlreadyExistsException(blobInfo.getBlobId().getName(), null, se.getMessage()).         }         throw se.     } }
true;;1;7;/**  * Deletes the blob from the specific bucket  *  * @param blobName name of the blob  */ ;/**  * Deletes the blob from the specific bucket  *  * @param blobName name of the blob  */ void deleteBlob(String blobName) throws IOException {     final BlobId blobId = BlobId.of(bucketName, blobName).     final boolean deleted = SocketAccess.doPrivilegedIOException(() -> client().delete(blobId)).     if (deleted == false) {         throw new NoSuchFileException("Blob [" + blobName + "] does not exist").     } }
true;;1;3;/**  * Deletes multiple blobs from the specific bucket all of which have prefixed names  *  * @param prefix prefix of the blobs to delete  */ ;/**  * Deletes multiple blobs from the specific bucket all of which have prefixed names  *  * @param prefix prefix of the blobs to delete  */ void deleteBlobsByPrefix(String prefix) throws IOException {     deleteBlobs(listBlobsByPrefix("", prefix).keySet()). }
true;;1;23;/**  * Deletes multiple blobs from the specific bucket using a batch request  *  * @param blobNames names of the blobs to delete  */ ;/**  * Deletes multiple blobs from the specific bucket using a batch request  *  * @param blobNames names of the blobs to delete  */ void deleteBlobs(Collection<String> blobNames) throws IOException {     if (blobNames.isEmpty()) {         return.     }     // for a single op submit a simple delete instead of a batch of size 1     if (blobNames.size() == 1) {         deleteBlob(blobNames.iterator().next()).         return.     }     final List<BlobId> blobIdsToDelete = blobNames.stream().map(blob -> BlobId.of(bucketName, blob)).collect(Collectors.toList()).     final List<Boolean> deletedStatuses = SocketAccess.doPrivilegedIOException(() -> client().delete(blobIdsToDelete)).     assert blobIdsToDelete.size() == deletedStatuses.size().     boolean failed = false.     for (int i = 0. i < blobIdsToDelete.size(). i++) {         if (deletedStatuses.get(i) == false) {             logger.error("Failed to delete blob [{}] in bucket [{}]", blobIdsToDelete.get(i).getName(), bucketName).             failed = true.         }     }     if (failed) {         throw new IOException("Failed to delete all [" + blobIdsToDelete.size() + "] blobs").     } }
false;private,static;2;4;;private static String buildKey(String keyPath, String s) {     assert s != null.     return keyPath + s. }
