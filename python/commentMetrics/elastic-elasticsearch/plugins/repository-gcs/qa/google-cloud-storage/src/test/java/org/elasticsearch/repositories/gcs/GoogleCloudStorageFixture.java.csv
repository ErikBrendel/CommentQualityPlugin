# id;timestamp;commentText;codeText;commentWords;codeWords
GoogleCloudStorageFixture -> private static Response newResponse(final RestStatus status, final Map<String, String> headers, final XContentBuilder xContentBuilder);1528980219;Builds a JSON response;private static Response newResponse(final RestStatus status, final Map<String, String> headers, final XContentBuilder xContentBuilder) {_        final Map<String, String> responseHeaders = new HashMap<>(JSON_CONTENT_TYPE)__        responseHeaders.putAll(headers)___        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_            BytesReference.bytes(xContentBuilder).writeTo(out)___            return new Response(status.getStatus(), responseHeaders, out.toByteArray())__        } catch (final IOException e) {_            return newError(RestStatus.INTERNAL_SERVER_ERROR, e.getMessage())__        }_    };builds,a,json,response;private,static,response,new,response,final,rest,status,status,final,map,string,string,headers,final,xcontent,builder,x,content,builder,final,map,string,string,response,headers,new,hash,map,response,headers,put,all,headers,try,byte,array,output,stream,out,new,byte,array,output,stream,bytes,reference,bytes,x,content,builder,write,to,out,return,new,response,status,get,status,response,headers,out,to,byte,array,catch,final,ioexception,e,return,new,error,rest,status,e,get,message
GoogleCloudStorageFixture -> private static Response newResponse(final RestStatus status, final Map<String, String> headers, final XContentBuilder xContentBuilder);1531179852;Builds a JSON response;private static Response newResponse(final RestStatus status, final Map<String, String> headers, final XContentBuilder xContentBuilder) {_        final Map<String, String> responseHeaders = new HashMap<>(JSON_CONTENT_TYPE)__        responseHeaders.putAll(headers)___        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_            BytesReference.bytes(xContentBuilder).writeTo(out)___            return new Response(status.getStatus(), responseHeaders, out.toByteArray())__        } catch (final IOException e) {_            return newError(RestStatus.INTERNAL_SERVER_ERROR, e.getMessage())__        }_    };builds,a,json,response;private,static,response,new,response,final,rest,status,status,final,map,string,string,headers,final,xcontent,builder,x,content,builder,final,map,string,string,response,headers,new,hash,map,response,headers,put,all,headers,try,byte,array,output,stream,out,new,byte,array,output,stream,bytes,reference,bytes,x,content,builder,write,to,out,return,new,response,status,get,status,response,headers,out,to,byte,array,catch,final,ioexception,e,return,new,error,rest,status,e,get,message
GoogleCloudStorageFixture -> private static XContentBuilder buildObjectResource(final XContentBuilder builder,                                                        final String bucket,                                                        final String name,                                                        final byte[] bytes) throws IOException;1528980219;Storage Object JSON representation as defined in_https://cloud.google.com/storage/docs/json_api/v1/objects#resource;private static XContentBuilder buildObjectResource(final XContentBuilder builder,_                                                       final String bucket,_                                                       final String name,_                                                       final byte[] bytes) throws IOException {_        return builder.startObject()_                            .field("kind", "storage#object")_                            .field("id", String.join("/", bucket, name))_                            .field("name", name)_                            .field("bucket", bucket)_                            .field("size", String.valueOf(bytes.length))_                        .endObject()__    };storage,object,json,representation,as,defined,in,https,cloud,google,com,storage,docs,v1,objects,resource;private,static,xcontent,builder,build,object,resource,final,xcontent,builder,builder,final,string,bucket,final,string,name,final,byte,bytes,throws,ioexception,return,builder,start,object,field,kind,storage,object,field,id,string,join,bucket,name,field,name,name,field,bucket,bucket,field,size,string,value,of,bytes,length,end,object
GoogleCloudStorageFixture -> private static XContentBuilder buildObjectResource(final XContentBuilder builder,                                                        final String bucket,                                                        final String name,                                                        final byte[] bytes) throws IOException;1531179852;Storage Object JSON representation as defined in_https://cloud.google.com/storage/docs/json_api/v1/objects#resource;private static XContentBuilder buildObjectResource(final XContentBuilder builder,_                                                       final String bucket,_                                                       final String name,_                                                       final byte[] bytes) throws IOException {_        return builder.startObject()_                            .field("kind", "storage#object")_                            .field("id", String.join("/", bucket, name))_                            .field("name", name)_                            .field("bucket", bucket)_                            .field("size", String.valueOf(bytes.length))_                        .endObject()__    };storage,object,json,representation,as,defined,in,https,cloud,google,com,storage,docs,v1,objects,resource;private,static,xcontent,builder,build,object,resource,final,xcontent,builder,builder,final,string,bucket,final,string,name,final,byte,bytes,throws,ioexception,return,builder,start,object,field,kind,storage,object,field,id,string,join,bucket,name,field,name,name,field,bucket,bucket,field,size,string,value,of,bytes,length,end,object
GoogleCloudStorageFixture -> private static PathTrie<RequestHandler> defaultHandlers(final Map<String, Bucket> buckets);1528980219;Builds the default request handlers *;private static PathTrie<RequestHandler> defaultHandlers(final Map<String, Bucket> buckets) {_        final PathTrie<RequestHandler> handlers = new PathTrie<>(RestUtils.REST_DECODER)___        _        _        _        handlers.insert("GET /storage/v1/b/{bucket}", (request) -> {_            final String name = request.getParam("bucket")__            if (Strings.hasText(name) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "bucket name is missing")__            }__            if (buckets.containsKey(name)) {_                return newResponse(RestStatus.OK, emptyMap(), buildBucketResource(name))__            } else {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }_        })___        _        _        _        handlers.insert("GET /storage/v1/b/{bucket}/o/{object}", (request) -> {_            final String objectName = request.getParam("object")__            if (Strings.hasText(objectName) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "object name is missing")__            }__            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            for (final Map.Entry<String, byte[]> object : bucket.objects.entrySet()) {_                if (object.getKey().equals(objectName)) {_                    return newResponse(RestStatus.OK, emptyMap(), buildObjectResource(bucket.name, objectName, object.getValue()))__                }_            }_            return newError(RestStatus.NOT_FOUND, "object not found")__        })___        _        _        _        handlers.insert("DELETE /storage/v1/b/{bucket}/o/{object}", (request) -> {_            final String objectName = request.getParam("object")__            if (Strings.hasText(objectName) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "object name is missing")__            }__            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            final byte[] bytes = bucket.objects.remove(objectName)__            if (bytes != null) {_                return new Response(RestStatus.NO_CONTENT.getStatus(), TEXT_PLAIN_CONTENT_TYPE, EMPTY_BYTE)__            }_            return newError(RestStatus.NOT_FOUND, "object not found")__        })___        _        _        _        handlers.insert("POST /upload/storage/v1/b/{bucket}/o", (request) -> {_            final String ifGenerationMatch = request.getParam("ifGenerationMatch")__            if ("0".equals(ifGenerationMatch) == false) {_                return newError(RestStatus.PRECONDITION_FAILED, "object already exist")__            }__            final String uploadType = request.getParam("uploadType")__            if ("resumable".equals(uploadType)) {_                final String objectName = request.getParam("name")__                if (Strings.hasText(objectName) == false) {_                    return newError(RestStatus.INTERNAL_SERVER_ERROR, "object name is missing")__                }_                final Bucket bucket = buckets.get(request.getParam("bucket"))__                if (bucket == null) {_                    return newError(RestStatus.NOT_FOUND, "bucket not found")__                }_                if (bucket.objects.putIfAbsent(objectName, EMPTY_BYTE) == null) {_                    final String location =  "/upload/storage/v1/b/" + bucket.name + "/o?uploadType=resumable&upload_id="_                            + objectName__                    return newResponse(RestStatus.CREATED, singletonMap("Location", location), jsonBuilder())__                } else {_                    return newError(RestStatus.CONFLICT, "object already exist")__                }_            } else if ("multipart".equals(uploadType)) {_                _                String boundary = "__END_OF_PART__"__                _                final String contentType = request.getContentType()__                if ((contentType != null) && contentType.contains("multipart/related_ boundary=")) {_                    boundary = contentType.replace("multipart/related_ boundary=", "")__                }__                InputStream inputStreamBody = new ByteArrayInputStream(request.getBody())__                final String contentEncoding = request.getHeader("Content-Encoding")__                if (contentEncoding != null) {_                    if ("gzip".equalsIgnoreCase(contentEncoding)) {_                        inputStreamBody = new GZIPInputStream(inputStreamBody)__                    }_                }_                _                _                try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStreamBody, StandardCharsets.ISO_8859_1))) {_                    String line__                    _                    line = reader.readLine()__                    if ((line == null) || (line.equals("--" + boundary) == false)) {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR,_                                "Error parsing multipart request. Does not start with the part delimiter.")__                    }_                    final Map<String, List<String>> firstPartHeaders = new HashMap<>()__                    _                    while ((line = reader.readLine()) != null) {_                        if (line.equals("\r\n") || (line.length() == 0)) {_                            _                            break__                        } else {_                            final String[] header = line.split(":", 2)__                            firstPartHeaders.put(header[0], singletonList(header[1]))__                        }_                    }_                    final List<String> firstPartContentTypes = firstPartHeaders.getOrDefault("Content-Type",_                            firstPartHeaders.get("Content-type"))__                    if ((firstPartContentTypes == null)_                            || (firstPartContentTypes.stream().noneMatch(x -> x.contains("application/json")))) {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR,_                                "Error parsing multipart request. Metadata part expected to have the \"application/json\" content type.")__                    }_                    _                    line = reader.readLine()__                    final byte[] metadata = line.getBytes(StandardCharsets.ISO_8859_1)__                    if ((firstPartContentTypes != null) && (firstPartContentTypes.stream().anyMatch((x -> x.contains("charset=utf-8"))))) {_                        _                        line = new String(metadata, StandardCharsets.UTF_8)__                    }_                    final Matcher objectNameMatcher = Pattern.compile("\"name\":\"([^\"]*)\"").matcher(line)__                    objectNameMatcher.find()__                    final String objectName = objectNameMatcher.group(1)__                    final Matcher bucketNameMatcher = Pattern.compile("\"bucket\":\"([^\"]*)\"").matcher(line)__                    bucketNameMatcher.find()__                    final String bucketName = bucketNameMatcher.group(1)__                    _                    line = reader.readLine()__                    if ((line == null) || (line.equals("--" + boundary) == false)) {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR,_                                "Error parsing multipart request. Second part does not start with delimiter. "_                                        + "Is the metadata multi-line?")__                    }_                    final Map<String, List<String>> secondPartHeaders = new HashMap<>()__                    _                    while ((line = reader.readLine()) != null) {_                        if (line.equals("\r\n") || (line.length() == 0)) {_                            _                            break__                        } else {_                            final String[] header = line.split(":", 2)__                            secondPartHeaders.put(header[0], singletonList(header[1]))__                        }_                    }_                    final List<String> secondPartTransferEncoding = secondPartHeaders.getOrDefault("Content-Transfer-Encoding",_                            secondPartHeaders.get("content-transfer-encoding"))__                    if ((secondPartTransferEncoding == null)_                            || (secondPartTransferEncoding.stream().noneMatch(x -> x.contains("binary")))) {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR,_                                "Error parsing multipart request. Data part expected to have the \"binary\" content transfer encoding.")__                    }_                    final ByteArrayOutputStream baos = new ByteArrayOutputStream()__                    int c__                    while ((c = reader.read()) != -1) {_                        _                        baos.write(c)__                    }_                    final byte[] temp = baos.toByteArray()__                    final byte[] trailingEnding = ("\r\n--" + boundary + "--\r\n").getBytes(StandardCharsets.ISO_8859_1)__                    _                    for (int i = trailingEnding.length - 1_ i >= 0_ i--) {_                        if (trailingEnding[i] != temp[(temp.length - trailingEnding.length) + i]) {_                            return newError(RestStatus.INTERNAL_SERVER_ERROR, "Error parsing multipart request.")__                        }_                    }_                    final Bucket bucket = buckets.get(bucketName)__                    if (bucket == null) {_                        return newError(RestStatus.NOT_FOUND, "bucket not found")__                    }_                    final byte[] objectData = Arrays.copyOf(temp, temp.length - trailingEnding.length)__                    if ((objectName != null) && (bucketName != null) && (objectData != null)) {_                        bucket.objects.put(objectName, objectData)__                        return new Response(RestStatus.OK.getStatus(), JSON_CONTENT_TYPE, metadata)__                    } else {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR, "error parsing multipart request")__                    }_                }_            } else {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "upload type must be resumable or multipart")__            }_        })___        _        _        _        handlers.insert("PUT /upload/storage/v1/b/{bucket}/o", (request) -> {_            final String objectId = request.getParam("upload_id")__            if (Strings.hasText(objectId) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "upload id is missing")__            }__            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            if (bucket.objects.containsKey(objectId) == false) {_                return newError(RestStatus.NOT_FOUND, "object name not found")__            }__            bucket.objects.put(objectId, request.getBody())__            return newResponse(RestStatus.OK, emptyMap(), buildObjectResource(bucket.name, objectId, request.getBody()))__        })___        _        _        _        handlers.insert("GET /storage/v1/b/{bucket}/o", (request) -> {_            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            final XContentBuilder builder = jsonBuilder()__            builder.startObject()__            builder.field("kind", "storage#objects")__            {_                builder.startArray("items")___                final String prefixParam = request.getParam("prefix")__                for (final Map.Entry<String, byte[]> object : bucket.objects.entrySet()) {_                    if ((prefixParam != null) && (object.getKey().startsWith(prefixParam) == false)) {_                        continue__                    }_                    buildObjectResource(builder, bucket.name, object.getKey(), object.getValue())__                }_                builder.endArray()__            }_            builder.endObject()__            return newResponse(RestStatus.OK, emptyMap(), builder)__        })___        _        _        _        handlers.insert("GET /download/storage/v1/b/{bucket}/o/{object}", (request) -> {_            final String object = request.getParam("object")__            if (Strings.hasText(object) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "object id is missing")__            }__            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            if (bucket.objects.containsKey(object) == false) {_                return newError(RestStatus.NOT_FOUND, "object name not found")__            }__            return new Response(RestStatus.OK.getStatus(), contentType("application/octet-stream"), bucket.objects.get(object))__        })___        _        _        _        handlers.insert("POST /batch/storage/v1", (request) -> {_            final List<Response> batchedResponses = new ArrayList<>()___            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            __            _            String boundary = "__END_OF_PART__"___            _            final String contentType = request.getContentType()__            if ((contentType != null) && contentType.contains("multipart/mixed_ boundary=")) {_                boundary = contentType.replace("multipart/mixed_ boundary=", "")__            }__            long batchedRequests = 0L___            _            try (BufferedReader reader = new BufferedReader(_                                              new InputStreamReader(_                                                  new ByteArrayInputStream(request.getBody()), StandardCharsets.UTF_8))) {_                String line__                while ((line = reader.readLine()) != null) {_                    _                    if (line.equals("--" + boundary)) {_                        final Map<String, String> batchedHeaders = new HashMap<>()___                        _                        while ((line = reader.readLine()) != null) {_                            if (line.equals("\r\n") || (line.length() == 0)) {_                                _                                break__                            } else {_                                final String[] header = line.split(":", 2)__                                batchedHeaders.put(header[0], header[1])__                            }_                        }__                        _                        line = reader.readLine()__                        final String batchedMethod = line.substring(0, line.indexOf(' '))__                        final URI batchedUri = URI.create(line.substring(batchedMethod.length() + 1, line.lastIndexOf(' ')))___                        _                        line = reader.readLine()__                        byte[] batchedBody = new byte[0]__                        if ((line != null) || (line.startsWith("--" + boundary) == false)) {_                            batchedBody = line.getBytes(StandardCharsets.UTF_8)__                        }__                        final Request batchedRequest = new Request(batchedRequests, batchedMethod, batchedUri, batchedHeaders, batchedBody)__                        batchedRequests = batchedRequests + 1___                        _                        final RequestHandler handler =_                            handlers.retrieve(batchedRequest.getMethod() + " " + batchedRequest.getPath(), batchedRequest.getParameters())__                        if (handler != null) {_                            try {_                                batchedResponses.add(handler.handle(batchedRequest))__                            } catch (final IOException e) {_                                batchedResponses.add(newError(RestStatus.INTERNAL_SERVER_ERROR, e.getMessage()))__                            }_                        }_                    }_                }_            }__            _            final String sep = "--"__            final String line = "\r\n"___            final StringBuilder builder = new StringBuilder()__            for (final Response response : batchedResponses) {_                builder.append(sep).append(boundary).append(line)__                builder.append("Content-Type: application/http").append(line)__                builder.append(line)__                builder.append("HTTP/1.1 ")_                    .append(response.getStatus())_                    .append(' ')_                    .append(RestStatus.fromCode(response.getStatus()).toString())_                    .append(line)__                builder.append("Content-Length: ").append(response.getBody().length).append(line)__                builder.append("Content-Type: ").append(response.getContentType()).append(line)__                response.getHeaders().forEach((k, v) -> builder.append(k).append(": ").append(v).append(line))__                builder.append(line)__                builder.append(new String(response.getBody(), StandardCharsets.UTF_8)).append(line)__                builder.append(line)__            }_            builder.append(line)__            builder.append(sep).append(boundary).append(sep)___            final byte[] content = builder.toString().getBytes(StandardCharsets.UTF_8)__            return new Response(RestStatus.OK.getStatus(), contentType("multipart/mixed_ boundary=" + boundary), content)__        })___        _        _        handlers.insert("POST /o/oauth2/token", (request) ->_            newResponse(RestStatus.OK, emptyMap(), jsonBuilder()_                .startObject()_                    .field("access_token", "unknown")_                    .field("token_type", "Bearer")_                    .field("expires_in", 3600)_                .endObject())_        )___        return handlers__    };builds,the,default,request,handlers;private,static,path,trie,request,handler,default,handlers,final,map,string,bucket,buckets,final,path,trie,request,handler,handlers,new,path,trie,rest,utils,handlers,insert,get,storage,v1,b,bucket,request,final,string,name,request,get,param,bucket,if,strings,has,text,name,false,return,new,error,rest,status,bucket,name,is,missing,if,buckets,contains,key,name,return,new,response,rest,status,ok,empty,map,build,bucket,resource,name,else,return,new,error,rest,status,bucket,not,found,handlers,insert,get,storage,v1,b,bucket,o,object,request,final,string,object,name,request,get,param,object,if,strings,has,text,object,name,false,return,new,error,rest,status,object,name,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,for,final,map,entry,string,byte,object,bucket,objects,entry,set,if,object,get,key,equals,object,name,return,new,response,rest,status,ok,empty,map,build,object,resource,bucket,name,object,name,object,get,value,return,new,error,rest,status,object,not,found,handlers,insert,delete,storage,v1,b,bucket,o,object,request,final,string,object,name,request,get,param,object,if,strings,has,text,object,name,false,return,new,error,rest,status,object,name,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,final,byte,bytes,bucket,objects,remove,object,name,if,bytes,null,return,new,response,rest,status,get,status,return,new,error,rest,status,object,not,found,handlers,insert,post,upload,storage,v1,b,bucket,o,request,final,string,if,generation,match,request,get,param,if,generation,match,if,0,equals,if,generation,match,false,return,new,error,rest,status,object,already,exist,final,string,upload,type,request,get,param,upload,type,if,resumable,equals,upload,type,final,string,object,name,request,get,param,name,if,strings,has,text,object,name,false,return,new,error,rest,status,object,name,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,if,bucket,objects,put,if,absent,object,name,null,final,string,location,upload,storage,v1,b,bucket,name,o,upload,type,resumable,object,name,return,new,response,rest,status,created,singleton,map,location,location,json,builder,else,return,new,error,rest,status,conflict,object,already,exist,else,if,multipart,equals,upload,type,string,boundary,final,string,content,type,request,get,content,type,if,content,type,null,content,type,contains,multipart,related,boundary,boundary,content,type,replace,multipart,related,boundary,input,stream,input,stream,body,new,byte,array,input,stream,request,get,body,final,string,content,encoding,request,get,header,content,encoding,if,content,encoding,null,if,gzip,equals,ignore,case,content,encoding,input,stream,body,new,gzipinput,stream,input,stream,body,try,buffered,reader,reader,new,buffered,reader,new,input,stream,reader,input,stream,body,standard,charsets,string,line,line,reader,read,line,if,line,null,line,equals,boundary,false,return,new,error,rest,status,error,parsing,multipart,request,does,not,start,with,the,part,delimiter,final,map,string,list,string,first,part,headers,new,hash,map,while,line,reader,read,line,null,if,line,equals,r,n,line,length,0,break,else,final,string,header,line,split,2,first,part,headers,put,header,0,singleton,list,header,1,final,list,string,first,part,content,types,first,part,headers,get,or,default,content,type,first,part,headers,get,content,type,if,first,part,content,types,null,first,part,content,types,stream,none,match,x,x,contains,application,json,return,new,error,rest,status,error,parsing,multipart,request,metadata,part,expected,to,have,the,application,json,content,type,line,reader,read,line,final,byte,metadata,line,get,bytes,standard,charsets,if,first,part,content,types,null,first,part,content,types,stream,any,match,x,x,contains,charset,utf,8,line,new,string,metadata,standard,charsets,final,matcher,object,name,matcher,pattern,compile,name,matcher,line,object,name,matcher,find,final,string,object,name,object,name,matcher,group,1,final,matcher,bucket,name,matcher,pattern,compile,bucket,matcher,line,bucket,name,matcher,find,final,string,bucket,name,bucket,name,matcher,group,1,line,reader,read,line,if,line,null,line,equals,boundary,false,return,new,error,rest,status,error,parsing,multipart,request,second,part,does,not,start,with,delimiter,is,the,metadata,multi,line,final,map,string,list,string,second,part,headers,new,hash,map,while,line,reader,read,line,null,if,line,equals,r,n,line,length,0,break,else,final,string,header,line,split,2,second,part,headers,put,header,0,singleton,list,header,1,final,list,string,second,part,transfer,encoding,second,part,headers,get,or,default,content,transfer,encoding,second,part,headers,get,content,transfer,encoding,if,second,part,transfer,encoding,null,second,part,transfer,encoding,stream,none,match,x,x,contains,binary,return,new,error,rest,status,error,parsing,multipart,request,data,part,expected,to,have,the,binary,content,transfer,encoding,final,byte,array,output,stream,baos,new,byte,array,output,stream,int,c,while,c,reader,read,1,baos,write,c,final,byte,temp,baos,to,byte,array,final,byte,trailing,ending,r,n,boundary,r,n,get,bytes,standard,charsets,for,int,i,trailing,ending,length,1,i,0,i,if,trailing,ending,i,temp,temp,length,trailing,ending,length,i,return,new,error,rest,status,error,parsing,multipart,request,final,bucket,bucket,buckets,get,bucket,name,if,bucket,null,return,new,error,rest,status,bucket,not,found,final,byte,object,data,arrays,copy,of,temp,temp,length,trailing,ending,length,if,object,name,null,bucket,name,null,object,data,null,bucket,objects,put,object,name,object,data,return,new,response,rest,status,ok,get,status,metadata,else,return,new,error,rest,status,error,parsing,multipart,request,else,return,new,error,rest,status,upload,type,must,be,resumable,or,multipart,handlers,insert,put,upload,storage,v1,b,bucket,o,request,final,string,object,id,request,get,param,if,strings,has,text,object,id,false,return,new,error,rest,status,upload,id,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,if,bucket,objects,contains,key,object,id,false,return,new,error,rest,status,object,name,not,found,bucket,objects,put,object,id,request,get,body,return,new,response,rest,status,ok,empty,map,build,object,resource,bucket,name,object,id,request,get,body,handlers,insert,get,storage,v1,b,bucket,o,request,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,final,xcontent,builder,builder,json,builder,builder,start,object,builder,field,kind,storage,objects,builder,start,array,items,final,string,prefix,param,request,get,param,prefix,for,final,map,entry,string,byte,object,bucket,objects,entry,set,if,prefix,param,null,object,get,key,starts,with,prefix,param,false,continue,build,object,resource,builder,bucket,name,object,get,key,object,get,value,builder,end,array,builder,end,object,return,new,response,rest,status,ok,empty,map,builder,handlers,insert,get,download,storage,v1,b,bucket,o,object,request,final,string,object,request,get,param,object,if,strings,has,text,object,false,return,new,error,rest,status,object,id,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,if,bucket,objects,contains,key,object,false,return,new,error,rest,status,object,name,not,found,return,new,response,rest,status,ok,get,status,content,type,application,octet,stream,bucket,objects,get,object,handlers,insert,post,batch,storage,v1,request,final,list,response,batched,responses,new,array,list,string,boundary,final,string,content,type,request,get,content,type,if,content,type,null,content,type,contains,multipart,mixed,boundary,boundary,content,type,replace,multipart,mixed,boundary,long,batched,requests,0l,try,buffered,reader,reader,new,buffered,reader,new,input,stream,reader,new,byte,array,input,stream,request,get,body,standard,charsets,string,line,while,line,reader,read,line,null,if,line,equals,boundary,final,map,string,string,batched,headers,new,hash,map,while,line,reader,read,line,null,if,line,equals,r,n,line,length,0,break,else,final,string,header,line,split,2,batched,headers,put,header,0,header,1,line,reader,read,line,final,string,batched,method,line,substring,0,line,index,of,final,uri,batched,uri,uri,create,line,substring,batched,method,length,1,line,last,index,of,line,reader,read,line,byte,batched,body,new,byte,0,if,line,null,line,starts,with,boundary,false,batched,body,line,get,bytes,standard,charsets,final,request,batched,request,new,request,batched,requests,batched,method,batched,uri,batched,headers,batched,body,batched,requests,batched,requests,1,final,request,handler,handler,handlers,retrieve,batched,request,get,method,batched,request,get,path,batched,request,get,parameters,if,handler,null,try,batched,responses,add,handler,handle,batched,request,catch,final,ioexception,e,batched,responses,add,new,error,rest,status,e,get,message,final,string,sep,final,string,line,r,n,final,string,builder,builder,new,string,builder,for,final,response,response,batched,responses,builder,append,sep,append,boundary,append,line,builder,append,content,type,application,http,append,line,builder,append,line,builder,append,http,1,1,append,response,get,status,append,append,rest,status,from,code,response,get,status,to,string,append,line,builder,append,content,length,append,response,get,body,length,append,line,builder,append,content,type,append,response,get,content,type,append,line,response,get,headers,for,each,k,v,builder,append,k,append,append,v,append,line,builder,append,line,builder,append,new,string,response,get,body,standard,charsets,append,line,builder,append,line,builder,append,line,builder,append,sep,append,boundary,append,sep,final,byte,content,builder,to,string,get,bytes,standard,charsets,return,new,response,rest,status,ok,get,status,content,type,multipart,mixed,boundary,boundary,content,handlers,insert,post,o,oauth2,token,request,new,response,rest,status,ok,empty,map,json,builder,start,object,field,unknown,field,bearer,field,3600,end,object,return,handlers
GoogleCloudStorageFixture -> private static PathTrie<RequestHandler> defaultHandlers(final Map<String, Bucket> buckets);1531179852;Builds the default request handlers *;private static PathTrie<RequestHandler> defaultHandlers(final Map<String, Bucket> buckets) {_        final PathTrie<RequestHandler> handlers = new PathTrie<>(RestUtils.REST_DECODER)___        _        _        _        handlers.insert("GET /storage/v1/b/{bucket}", (request) -> {_            final String name = request.getParam("bucket")__            if (Strings.hasText(name) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "bucket name is missing")__            }__            if (buckets.containsKey(name)) {_                return newResponse(RestStatus.OK, emptyMap(), buildBucketResource(name))__            } else {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }_        })___        _        _        _        handlers.insert("GET /storage/v1/b/{bucket}/o/{object}", (request) -> {_            final String objectName = request.getParam("object")__            if (Strings.hasText(objectName) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "object name is missing")__            }__            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            for (final Map.Entry<String, byte[]> object : bucket.objects.entrySet()) {_                if (object.getKey().equals(objectName)) {_                    return newResponse(RestStatus.OK, emptyMap(), buildObjectResource(bucket.name, objectName, object.getValue()))__                }_            }_            return newError(RestStatus.NOT_FOUND, "object not found")__        })___        _        _        _        handlers.insert("DELETE /storage/v1/b/{bucket}/o/{object}", (request) -> {_            final String objectName = request.getParam("object")__            if (Strings.hasText(objectName) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "object name is missing")__            }__            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            final byte[] bytes = bucket.objects.remove(objectName)__            if (bytes != null) {_                return new Response(RestStatus.NO_CONTENT.getStatus(), TEXT_PLAIN_CONTENT_TYPE, EMPTY_BYTE)__            }_            return newError(RestStatus.NOT_FOUND, "object not found")__        })___        _        _        _        handlers.insert("POST /upload/storage/v1/b/{bucket}/o", (request) -> {_            final String ifGenerationMatch = request.getParam("ifGenerationMatch")__            final String uploadType = request.getParam("uploadType")__            if ("resumable".equals(uploadType)) {_                final String objectName = request.getParam("name")__                if (Strings.hasText(objectName) == false) {_                    return newError(RestStatus.INTERNAL_SERVER_ERROR, "object name is missing")__                }_                final Bucket bucket = buckets.get(request.getParam("bucket"))__                if (bucket == null) {_                    return newError(RestStatus.NOT_FOUND, "bucket not found")__                }_                if ("0".equals(ifGenerationMatch)) {_                    if (bucket.objects.putIfAbsent(objectName, EMPTY_BYTE) == null) {_                        final String location =  "/upload/storage/v1/b/" + bucket.name + "/o?uploadType=resumable&upload_id="_                            + objectName__                        return newResponse(RestStatus.CREATED, singletonMap("Location", location), jsonBuilder())__                    } else {_                        return newError(RestStatus.PRECONDITION_FAILED, "object already exist")__                    }_                } else {_                    bucket.objects.put(objectName, EMPTY_BYTE)__                    final String location =  "/upload/storage/v1/b/" + bucket.name + "/o?uploadType=resumable&upload_id="_                        + objectName__                    return newResponse(RestStatus.CREATED, singletonMap("Location", location), jsonBuilder())__                }_            } else if ("multipart".equals(uploadType)) {_                _                String boundary = "__END_OF_PART__"__                _                final String contentType = request.getContentType()__                if ((contentType != null) && contentType.contains("multipart/related_ boundary=")) {_                    boundary = contentType.replace("multipart/related_ boundary=", "")__                }__                InputStream inputStreamBody = new ByteArrayInputStream(request.getBody())__                final String contentEncoding = request.getHeader("Content-Encoding")__                if (contentEncoding != null) {_                    if ("gzip".equalsIgnoreCase(contentEncoding)) {_                        inputStreamBody = new GZIPInputStream(inputStreamBody)__                    }_                }_                _                _                try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStreamBody, StandardCharsets.ISO_8859_1))) {_                    String line__                    _                    line = reader.readLine()__                    if ((line == null) || (line.equals("--" + boundary) == false)) {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR,_                                "Error parsing multipart request. Does not start with the part delimiter.")__                    }_                    final Map<String, List<String>> firstPartHeaders = new HashMap<>()__                    _                    while ((line = reader.readLine()) != null) {_                        if (line.equals("\r\n") || (line.length() == 0)) {_                            _                            break__                        } else {_                            final String[] header = line.split(":", 2)__                            firstPartHeaders.put(header[0], singletonList(header[1]))__                        }_                    }_                    final List<String> firstPartContentTypes = firstPartHeaders.getOrDefault("Content-Type",_                            firstPartHeaders.get("Content-type"))__                    if ((firstPartContentTypes == null)_                            || (firstPartContentTypes.stream().noneMatch(x -> x.contains("application/json")))) {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR,_                                "Error parsing multipart request. Metadata part expected to have the \"application/json\" content type.")__                    }_                    _                    line = reader.readLine()__                    final byte[] metadata = line.getBytes(StandardCharsets.ISO_8859_1)__                    if ((firstPartContentTypes != null) && (firstPartContentTypes.stream().anyMatch((x -> x.contains("charset=utf-8"))))) {_                        _                        line = new String(metadata, StandardCharsets.UTF_8)__                    }_                    final Matcher objectNameMatcher = Pattern.compile("\"name\":\"([^\"]*)\"").matcher(line)__                    objectNameMatcher.find()__                    final String objectName = objectNameMatcher.group(1)__                    final Matcher bucketNameMatcher = Pattern.compile("\"bucket\":\"([^\"]*)\"").matcher(line)__                    bucketNameMatcher.find()__                    final String bucketName = bucketNameMatcher.group(1)__                    _                    line = reader.readLine()__                    if ((line == null) || (line.equals("--" + boundary) == false)) {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR,_                                "Error parsing multipart request. Second part does not start with delimiter. "_                                        + "Is the metadata multi-line?")__                    }_                    final Map<String, List<String>> secondPartHeaders = new HashMap<>()__                    _                    while ((line = reader.readLine()) != null) {_                        if (line.equals("\r\n") || (line.length() == 0)) {_                            _                            break__                        } else {_                            final String[] header = line.split(":", 2)__                            secondPartHeaders.put(header[0], singletonList(header[1]))__                        }_                    }_                    final List<String> secondPartTransferEncoding = secondPartHeaders.getOrDefault("Content-Transfer-Encoding",_                            secondPartHeaders.get("content-transfer-encoding"))__                    if ((secondPartTransferEncoding == null)_                            || (secondPartTransferEncoding.stream().noneMatch(x -> x.contains("binary")))) {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR,_                                "Error parsing multipart request. Data part expected to have the \"binary\" content transfer encoding.")__                    }_                    final ByteArrayOutputStream baos = new ByteArrayOutputStream()__                    int c__                    while ((c = reader.read()) != -1) {_                        _                        baos.write(c)__                    }_                    final byte[] temp = baos.toByteArray()__                    final byte[] trailingEnding = ("\r\n--" + boundary + "--\r\n").getBytes(StandardCharsets.ISO_8859_1)__                    _                    for (int i = trailingEnding.length - 1_ i >= 0_ i--) {_                        if (trailingEnding[i] != temp[(temp.length - trailingEnding.length) + i]) {_                            return newError(RestStatus.INTERNAL_SERVER_ERROR, "Error parsing multipart request.")__                        }_                    }_                    final Bucket bucket = buckets.get(bucketName)__                    if (bucket == null) {_                        return newError(RestStatus.NOT_FOUND, "bucket not found")__                    }_                    final byte[] objectData = Arrays.copyOf(temp, temp.length - trailingEnding.length)__                    if ((objectName != null) && (bucketName != null) && (objectData != null)) {_                        bucket.objects.put(objectName, objectData)__                        return new Response(RestStatus.OK.getStatus(), JSON_CONTENT_TYPE, metadata)__                    } else {_                        return newError(RestStatus.INTERNAL_SERVER_ERROR, "error parsing multipart request")__                    }_                }_            } else {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "upload type must be resumable or multipart")__            }_        })___        _        _        _        handlers.insert("PUT /upload/storage/v1/b/{bucket}/o", (request) -> {_            final String objectId = request.getParam("upload_id")__            if (Strings.hasText(objectId) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "upload id is missing")__            }__            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            if (bucket.objects.containsKey(objectId) == false) {_                return newError(RestStatus.NOT_FOUND, "object name not found")__            }__            bucket.objects.put(objectId, request.getBody())__            return newResponse(RestStatus.OK, emptyMap(), buildObjectResource(bucket.name, objectId, request.getBody()))__        })___        _        _        _        handlers.insert("GET /storage/v1/b/{bucket}/o", (request) -> {_            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            final XContentBuilder builder = jsonBuilder()__            builder.startObject()__            builder.field("kind", "storage#objects")__            {_                builder.startArray("items")___                final String prefixParam = request.getParam("prefix")__                for (final Map.Entry<String, byte[]> object : bucket.objects.entrySet()) {_                    if ((prefixParam != null) && (object.getKey().startsWith(prefixParam) == false)) {_                        continue__                    }_                    buildObjectResource(builder, bucket.name, object.getKey(), object.getValue())__                }_                builder.endArray()__            }_            builder.endObject()__            return newResponse(RestStatus.OK, emptyMap(), builder)__        })___        _        _        _        handlers.insert("GET /download/storage/v1/b/{bucket}/o/{object}", (request) -> {_            final String object = request.getParam("object")__            if (Strings.hasText(object) == false) {_                return newError(RestStatus.INTERNAL_SERVER_ERROR, "object id is missing")__            }__            final Bucket bucket = buckets.get(request.getParam("bucket"))__            if (bucket == null) {_                return newError(RestStatus.NOT_FOUND, "bucket not found")__            }__            if (bucket.objects.containsKey(object) == false) {_                return newError(RestStatus.NOT_FOUND, "object name not found")__            }__            return new Response(RestStatus.OK.getStatus(), contentType("application/octet-stream"), bucket.objects.get(object))__        })___        _        _        _        handlers.insert("POST /batch/storage/v1", (request) -> {_            final List<Response> batchedResponses = new ArrayList<>()___            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            _            __            _            String boundary = "__END_OF_PART__"___            _            final String contentType = request.getContentType()__            if ((contentType != null) && contentType.contains("multipart/mixed_ boundary=")) {_                boundary = contentType.replace("multipart/mixed_ boundary=", "")__            }__            long batchedRequests = 0L___            _            try (BufferedReader reader = new BufferedReader(_                                              new InputStreamReader(_                                                  new ByteArrayInputStream(request.getBody()), StandardCharsets.UTF_8))) {_                String line__                while ((line = reader.readLine()) != null) {_                    _                    if (line.equals("--" + boundary)) {_                        final Map<String, String> batchedHeaders = new HashMap<>()___                        _                        while ((line = reader.readLine()) != null) {_                            if (line.equals("\r\n") || (line.length() == 0)) {_                                _                                break__                            } else {_                                final String[] header = line.split(":", 2)__                                batchedHeaders.put(header[0], header[1])__                            }_                        }__                        _                        line = reader.readLine()__                        final String batchedMethod = line.substring(0, line.indexOf(' '))__                        final URI batchedUri = URI.create(line.substring(batchedMethod.length() + 1, line.lastIndexOf(' ')))___                        _                        line = reader.readLine()__                        byte[] batchedBody = new byte[0]__                        if ((line != null) || (line.startsWith("--" + boundary) == false)) {_                            batchedBody = line.getBytes(StandardCharsets.UTF_8)__                        }__                        final Request batchedRequest = new Request(batchedRequests, batchedMethod, batchedUri, batchedHeaders, batchedBody)__                        batchedRequests = batchedRequests + 1___                        _                        final RequestHandler handler =_                            handlers.retrieve(batchedRequest.getMethod() + " " + batchedRequest.getPath(), batchedRequest.getParameters())__                        if (handler != null) {_                            try {_                                batchedResponses.add(handler.handle(batchedRequest))__                            } catch (final IOException e) {_                                batchedResponses.add(newError(RestStatus.INTERNAL_SERVER_ERROR, e.getMessage()))__                            }_                        }_                    }_                }_            }__            _            final String sep = "--"__            final String line = "\r\n"___            final StringBuilder builder = new StringBuilder()__            for (final Response response : batchedResponses) {_                builder.append(sep).append(boundary).append(line)__                builder.append("Content-Type: application/http").append(line)__                builder.append(line)__                builder.append("HTTP/1.1 ")_                    .append(response.getStatus())_                    .append(' ')_                    .append(RestStatus.fromCode(response.getStatus()).toString())_                    .append(line)__                builder.append("Content-Length: ").append(response.getBody().length).append(line)__                builder.append("Content-Type: ").append(response.getContentType()).append(line)__                response.getHeaders().forEach((k, v) -> builder.append(k).append(": ").append(v).append(line))__                builder.append(line)__                builder.append(new String(response.getBody(), StandardCharsets.UTF_8)).append(line)__                builder.append(line)__            }_            builder.append(line)__            builder.append(sep).append(boundary).append(sep)___            final byte[] content = builder.toString().getBytes(StandardCharsets.UTF_8)__            return new Response(RestStatus.OK.getStatus(), contentType("multipart/mixed_ boundary=" + boundary), content)__        })___        _        _        handlers.insert("POST /o/oauth2/token", (request) ->_            newResponse(RestStatus.OK, emptyMap(), jsonBuilder()_                .startObject()_                    .field("access_token", "unknown")_                    .field("token_type", "Bearer")_                    .field("expires_in", 3600)_                .endObject())_        )___        return handlers__    };builds,the,default,request,handlers;private,static,path,trie,request,handler,default,handlers,final,map,string,bucket,buckets,final,path,trie,request,handler,handlers,new,path,trie,rest,utils,handlers,insert,get,storage,v1,b,bucket,request,final,string,name,request,get,param,bucket,if,strings,has,text,name,false,return,new,error,rest,status,bucket,name,is,missing,if,buckets,contains,key,name,return,new,response,rest,status,ok,empty,map,build,bucket,resource,name,else,return,new,error,rest,status,bucket,not,found,handlers,insert,get,storage,v1,b,bucket,o,object,request,final,string,object,name,request,get,param,object,if,strings,has,text,object,name,false,return,new,error,rest,status,object,name,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,for,final,map,entry,string,byte,object,bucket,objects,entry,set,if,object,get,key,equals,object,name,return,new,response,rest,status,ok,empty,map,build,object,resource,bucket,name,object,name,object,get,value,return,new,error,rest,status,object,not,found,handlers,insert,delete,storage,v1,b,bucket,o,object,request,final,string,object,name,request,get,param,object,if,strings,has,text,object,name,false,return,new,error,rest,status,object,name,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,final,byte,bytes,bucket,objects,remove,object,name,if,bytes,null,return,new,response,rest,status,get,status,return,new,error,rest,status,object,not,found,handlers,insert,post,upload,storage,v1,b,bucket,o,request,final,string,if,generation,match,request,get,param,if,generation,match,final,string,upload,type,request,get,param,upload,type,if,resumable,equals,upload,type,final,string,object,name,request,get,param,name,if,strings,has,text,object,name,false,return,new,error,rest,status,object,name,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,if,0,equals,if,generation,match,if,bucket,objects,put,if,absent,object,name,null,final,string,location,upload,storage,v1,b,bucket,name,o,upload,type,resumable,object,name,return,new,response,rest,status,created,singleton,map,location,location,json,builder,else,return,new,error,rest,status,object,already,exist,else,bucket,objects,put,object,name,final,string,location,upload,storage,v1,b,bucket,name,o,upload,type,resumable,object,name,return,new,response,rest,status,created,singleton,map,location,location,json,builder,else,if,multipart,equals,upload,type,string,boundary,final,string,content,type,request,get,content,type,if,content,type,null,content,type,contains,multipart,related,boundary,boundary,content,type,replace,multipart,related,boundary,input,stream,input,stream,body,new,byte,array,input,stream,request,get,body,final,string,content,encoding,request,get,header,content,encoding,if,content,encoding,null,if,gzip,equals,ignore,case,content,encoding,input,stream,body,new,gzipinput,stream,input,stream,body,try,buffered,reader,reader,new,buffered,reader,new,input,stream,reader,input,stream,body,standard,charsets,string,line,line,reader,read,line,if,line,null,line,equals,boundary,false,return,new,error,rest,status,error,parsing,multipart,request,does,not,start,with,the,part,delimiter,final,map,string,list,string,first,part,headers,new,hash,map,while,line,reader,read,line,null,if,line,equals,r,n,line,length,0,break,else,final,string,header,line,split,2,first,part,headers,put,header,0,singleton,list,header,1,final,list,string,first,part,content,types,first,part,headers,get,or,default,content,type,first,part,headers,get,content,type,if,first,part,content,types,null,first,part,content,types,stream,none,match,x,x,contains,application,json,return,new,error,rest,status,error,parsing,multipart,request,metadata,part,expected,to,have,the,application,json,content,type,line,reader,read,line,final,byte,metadata,line,get,bytes,standard,charsets,if,first,part,content,types,null,first,part,content,types,stream,any,match,x,x,contains,charset,utf,8,line,new,string,metadata,standard,charsets,final,matcher,object,name,matcher,pattern,compile,name,matcher,line,object,name,matcher,find,final,string,object,name,object,name,matcher,group,1,final,matcher,bucket,name,matcher,pattern,compile,bucket,matcher,line,bucket,name,matcher,find,final,string,bucket,name,bucket,name,matcher,group,1,line,reader,read,line,if,line,null,line,equals,boundary,false,return,new,error,rest,status,error,parsing,multipart,request,second,part,does,not,start,with,delimiter,is,the,metadata,multi,line,final,map,string,list,string,second,part,headers,new,hash,map,while,line,reader,read,line,null,if,line,equals,r,n,line,length,0,break,else,final,string,header,line,split,2,second,part,headers,put,header,0,singleton,list,header,1,final,list,string,second,part,transfer,encoding,second,part,headers,get,or,default,content,transfer,encoding,second,part,headers,get,content,transfer,encoding,if,second,part,transfer,encoding,null,second,part,transfer,encoding,stream,none,match,x,x,contains,binary,return,new,error,rest,status,error,parsing,multipart,request,data,part,expected,to,have,the,binary,content,transfer,encoding,final,byte,array,output,stream,baos,new,byte,array,output,stream,int,c,while,c,reader,read,1,baos,write,c,final,byte,temp,baos,to,byte,array,final,byte,trailing,ending,r,n,boundary,r,n,get,bytes,standard,charsets,for,int,i,trailing,ending,length,1,i,0,i,if,trailing,ending,i,temp,temp,length,trailing,ending,length,i,return,new,error,rest,status,error,parsing,multipart,request,final,bucket,bucket,buckets,get,bucket,name,if,bucket,null,return,new,error,rest,status,bucket,not,found,final,byte,object,data,arrays,copy,of,temp,temp,length,trailing,ending,length,if,object,name,null,bucket,name,null,object,data,null,bucket,objects,put,object,name,object,data,return,new,response,rest,status,ok,get,status,metadata,else,return,new,error,rest,status,error,parsing,multipart,request,else,return,new,error,rest,status,upload,type,must,be,resumable,or,multipart,handlers,insert,put,upload,storage,v1,b,bucket,o,request,final,string,object,id,request,get,param,if,strings,has,text,object,id,false,return,new,error,rest,status,upload,id,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,if,bucket,objects,contains,key,object,id,false,return,new,error,rest,status,object,name,not,found,bucket,objects,put,object,id,request,get,body,return,new,response,rest,status,ok,empty,map,build,object,resource,bucket,name,object,id,request,get,body,handlers,insert,get,storage,v1,b,bucket,o,request,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,final,xcontent,builder,builder,json,builder,builder,start,object,builder,field,kind,storage,objects,builder,start,array,items,final,string,prefix,param,request,get,param,prefix,for,final,map,entry,string,byte,object,bucket,objects,entry,set,if,prefix,param,null,object,get,key,starts,with,prefix,param,false,continue,build,object,resource,builder,bucket,name,object,get,key,object,get,value,builder,end,array,builder,end,object,return,new,response,rest,status,ok,empty,map,builder,handlers,insert,get,download,storage,v1,b,bucket,o,object,request,final,string,object,request,get,param,object,if,strings,has,text,object,false,return,new,error,rest,status,object,id,is,missing,final,bucket,bucket,buckets,get,request,get,param,bucket,if,bucket,null,return,new,error,rest,status,bucket,not,found,if,bucket,objects,contains,key,object,false,return,new,error,rest,status,object,name,not,found,return,new,response,rest,status,ok,get,status,content,type,application,octet,stream,bucket,objects,get,object,handlers,insert,post,batch,storage,v1,request,final,list,response,batched,responses,new,array,list,string,boundary,final,string,content,type,request,get,content,type,if,content,type,null,content,type,contains,multipart,mixed,boundary,boundary,content,type,replace,multipart,mixed,boundary,long,batched,requests,0l,try,buffered,reader,reader,new,buffered,reader,new,input,stream,reader,new,byte,array,input,stream,request,get,body,standard,charsets,string,line,while,line,reader,read,line,null,if,line,equals,boundary,final,map,string,string,batched,headers,new,hash,map,while,line,reader,read,line,null,if,line,equals,r,n,line,length,0,break,else,final,string,header,line,split,2,batched,headers,put,header,0,header,1,line,reader,read,line,final,string,batched,method,line,substring,0,line,index,of,final,uri,batched,uri,uri,create,line,substring,batched,method,length,1,line,last,index,of,line,reader,read,line,byte,batched,body,new,byte,0,if,line,null,line,starts,with,boundary,false,batched,body,line,get,bytes,standard,charsets,final,request,batched,request,new,request,batched,requests,batched,method,batched,uri,batched,headers,batched,body,batched,requests,batched,requests,1,final,request,handler,handler,handlers,retrieve,batched,request,get,method,batched,request,get,path,batched,request,get,parameters,if,handler,null,try,batched,responses,add,handler,handle,batched,request,catch,final,ioexception,e,batched,responses,add,new,error,rest,status,e,get,message,final,string,sep,final,string,line,r,n,final,string,builder,builder,new,string,builder,for,final,response,response,batched,responses,builder,append,sep,append,boundary,append,line,builder,append,content,type,application,http,append,line,builder,append,line,builder,append,http,1,1,append,response,get,status,append,append,rest,status,from,code,response,get,status,to,string,append,line,builder,append,content,length,append,response,get,body,length,append,line,builder,append,content,type,append,response,get,content,type,append,line,response,get,headers,for,each,k,v,builder,append,k,append,append,v,append,line,builder,append,line,builder,append,new,string,response,get,body,standard,charsets,append,line,builder,append,line,builder,append,line,builder,append,sep,append,boundary,append,sep,final,byte,content,builder,to,string,get,bytes,standard,charsets,return,new,response,rest,status,ok,get,status,content,type,multipart,mixed,boundary,boundary,content,handlers,insert,post,o,oauth2,token,request,new,response,rest,status,ok,empty,map,json,builder,start,object,field,unknown,field,bearer,field,3600,end,object,return,handlers
GoogleCloudStorageFixture -> private GoogleCloudStorageFixture(final String workingDir, final String bucket);1528980219;Creates a {@link GoogleCloudStorageFixture};private GoogleCloudStorageFixture(final String workingDir, final String bucket) {_        super(workingDir)__        this.buckets.put(bucket, new Bucket(bucket))__        this.handlers = defaultHandlers(buckets)__    };creates,a,link,google,cloud,storage,fixture;private,google,cloud,storage,fixture,final,string,working,dir,final,string,bucket,super,working,dir,this,buckets,put,bucket,new,bucket,bucket,this,handlers,default,handlers,buckets
GoogleCloudStorageFixture -> private GoogleCloudStorageFixture(final String workingDir, final String bucket);1531179852;Creates a {@link GoogleCloudStorageFixture};private GoogleCloudStorageFixture(final String workingDir, final String bucket) {_        super(workingDir)__        this.buckets.put(bucket, new Bucket(bucket))__        this.handlers = defaultHandlers(buckets)__    };creates,a,link,google,cloud,storage,fixture;private,google,cloud,storage,fixture,final,string,working,dir,final,string,bucket,super,working,dir,this,buckets,put,bucket,new,bucket,bucket,this,handlers,default,handlers,buckets
GoogleCloudStorageFixture -> private static XContentBuilder buildObjectResource(final String bucket, final String name, final byte[] bytes) throws IOException;1528980219;Storage Object JSON representation as defined in_https://cloud.google.com/storage/docs/json_api/v1/objects#resource;private static XContentBuilder buildObjectResource(final String bucket, final String name, final byte[] bytes) throws IOException {_        return buildObjectResource(jsonBuilder(), bucket, name, bytes)__    };storage,object,json,representation,as,defined,in,https,cloud,google,com,storage,docs,v1,objects,resource;private,static,xcontent,builder,build,object,resource,final,string,bucket,final,string,name,final,byte,bytes,throws,ioexception,return,build,object,resource,json,builder,bucket,name,bytes
GoogleCloudStorageFixture -> private static XContentBuilder buildObjectResource(final String bucket, final String name, final byte[] bytes) throws IOException;1531179852;Storage Object JSON representation as defined in_https://cloud.google.com/storage/docs/json_api/v1/objects#resource;private static XContentBuilder buildObjectResource(final String bucket, final String name, final byte[] bytes) throws IOException {_        return buildObjectResource(jsonBuilder(), bucket, name, bytes)__    };storage,object,json,representation,as,defined,in,https,cloud,google,com,storage,docs,v1,objects,resource;private,static,xcontent,builder,build,object,resource,final,string,bucket,final,string,name,final,byte,bytes,throws,ioexception,return,build,object,resource,json,builder,bucket,name,bytes
GoogleCloudStorageFixture -> private static Response newError(final RestStatus status, final String message);1528980219;Storage Error JSON representation;private static Response newError(final RestStatus status, final String message) {_        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_            try (XContentBuilder builder = jsonBuilder()) {_                builder.startObject()_                            .startObject("error")_                                .field("code", status.getStatus())_                                .field("message", message)_                                .startArray("errors")_                                    .startObject()_                                        .field("domain", "global")_                                        .field("reason", status.toString())_                                        .field("message", message)_                                    .endObject()_                                .endArray()_                            .endObject()_                        .endObject()__                BytesReference.bytes(builder).writeTo(out)__            }_            return new Response(status.getStatus(), JSON_CONTENT_TYPE, out.toByteArray())__        } catch (final IOException e) {_            final byte[] bytes = (message != null ? message : "something went wrong").getBytes(StandardCharsets.UTF_8)__            return new Response(RestStatus.INTERNAL_SERVER_ERROR.getStatus(), TEXT_PLAIN_CONTENT_TYPE, bytes)__        }_    };storage,error,json,representation;private,static,response,new,error,final,rest,status,status,final,string,message,try,byte,array,output,stream,out,new,byte,array,output,stream,try,xcontent,builder,builder,json,builder,builder,start,object,start,object,error,field,code,status,get,status,field,message,message,start,array,errors,start,object,field,domain,global,field,reason,status,to,string,field,message,message,end,object,end,array,end,object,end,object,bytes,reference,bytes,builder,write,to,out,return,new,response,status,get,status,out,to,byte,array,catch,final,ioexception,e,final,byte,bytes,message,null,message,something,went,wrong,get,bytes,standard,charsets,return,new,response,rest,status,get,status,bytes
GoogleCloudStorageFixture -> private static Response newError(final RestStatus status, final String message);1531179852;Storage Error JSON representation;private static Response newError(final RestStatus status, final String message) {_        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_            try (XContentBuilder builder = jsonBuilder()) {_                builder.startObject()_                            .startObject("error")_                                .field("code", status.getStatus())_                                .field("message", message)_                                .startArray("errors")_                                    .startObject()_                                        .field("domain", "global")_                                        .field("reason", status.toString())_                                        .field("message", message)_                                    .endObject()_                                .endArray()_                            .endObject()_                        .endObject()__                BytesReference.bytes(builder).writeTo(out)__            }_            return new Response(status.getStatus(), JSON_CONTENT_TYPE, out.toByteArray())__        } catch (final IOException e) {_            final byte[] bytes = (message != null ? message : "something went wrong").getBytes(StandardCharsets.UTF_8)__            return new Response(RestStatus.INTERNAL_SERVER_ERROR.getStatus(), TEXT_PLAIN_CONTENT_TYPE, bytes)__        }_    };storage,error,json,representation;private,static,response,new,error,final,rest,status,status,final,string,message,try,byte,array,output,stream,out,new,byte,array,output,stream,try,xcontent,builder,builder,json,builder,builder,start,object,start,object,error,field,code,status,get,status,field,message,message,start,array,errors,start,object,field,domain,global,field,reason,status,to,string,field,message,message,end,object,end,array,end,object,end,object,bytes,reference,bytes,builder,write,to,out,return,new,response,status,get,status,out,to,byte,array,catch,final,ioexception,e,final,byte,bytes,message,null,message,something,went,wrong,get,bytes,standard,charsets,return,new,response,rest,status,get,status,bytes
GoogleCloudStorageFixture -> private static XContentBuilder buildBucketResource(final String name) throws IOException;1528980219;Storage Bucket JSON representation as defined in_https://cloud.google.com/storage/docs/json_api/v1/bucket#resource;private static XContentBuilder buildBucketResource(final String name) throws IOException {_        return jsonBuilder().startObject()_                                .field("kind", "storage#bucket")_                                .field("name", name)_                                .field("id", name)_                            .endObject()__    };storage,bucket,json,representation,as,defined,in,https,cloud,google,com,storage,docs,v1,bucket,resource;private,static,xcontent,builder,build,bucket,resource,final,string,name,throws,ioexception,return,json,builder,start,object,field,kind,storage,bucket,field,name,name,field,id,name,end,object
GoogleCloudStorageFixture -> private static XContentBuilder buildBucketResource(final String name) throws IOException;1531179852;Storage Bucket JSON representation as defined in_https://cloud.google.com/storage/docs/json_api/v1/bucket#resource;private static XContentBuilder buildBucketResource(final String name) throws IOException {_        return jsonBuilder().startObject()_                                .field("kind", "storage#bucket")_                                .field("name", name)_                                .field("id", name)_                            .endObject()__    };storage,bucket,json,representation,as,defined,in,https,cloud,google,com,storage,docs,v1,bucket,resource;private,static,xcontent,builder,build,bucket,resource,final,string,name,throws,ioexception,return,json,builder,start,object,field,kind,storage,bucket,field,name,name,field,id,name,end,object
