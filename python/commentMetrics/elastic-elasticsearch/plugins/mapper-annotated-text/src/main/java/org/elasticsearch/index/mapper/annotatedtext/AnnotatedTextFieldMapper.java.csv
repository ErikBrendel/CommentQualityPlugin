commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public AnnotatedTextFieldType fieldType() {     return (AnnotatedTextFieldType) super.fieldType(). }
false;public;1;7;;public Builder positionIncrementGap(int positionIncrementGap) {     if (positionIncrementGap < 0) {         throw new MapperParsingException("[positions_increment_gap] must be positive, got " + positionIncrementGap).     }     this.positionIncrementGap = positionIncrementGap.     return this. }
false;public;1;7;;@Override public Builder docValues(boolean docValues) {     if (docValues) {         throw new IllegalArgumentException("[" + CONTENT_TYPE + "] fields do not support doc values").     }     return super.docValues(docValues). }
false;public;1;28;;@Override public AnnotatedTextFieldMapper build(BuilderContext context) {     if (fieldType().indexOptions() == IndexOptions.NONE) {         throw new IllegalArgumentException("[" + CONTENT_TYPE + "] fields must be indexed").     }     if (positionIncrementGap != POSITION_INCREMENT_GAP_USE_ANALYZER) {         if (fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {             throw new IllegalArgumentException("Cannot set position_increment_gap on field [" + name + "] without positions enabled").         }         fieldType.setIndexAnalyzer(new NamedAnalyzer(fieldType.indexAnalyzer(), positionIncrementGap)).         fieldType.setSearchAnalyzer(new NamedAnalyzer(fieldType.searchAnalyzer(), positionIncrementGap)).         fieldType.setSearchQuoteAnalyzer(new NamedAnalyzer(fieldType.searchQuoteAnalyzer(), positionIncrementGap)).     } else {         // does to splice in new default of posIncGap=100 by wrapping the analyzer         if (fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0) {             int overrideInc = TextFieldMapper.Defaults.POSITION_INCREMENT_GAP.             fieldType.setIndexAnalyzer(new NamedAnalyzer(fieldType.indexAnalyzer(), overrideInc)).             fieldType.setSearchAnalyzer(new NamedAnalyzer(fieldType.searchAnalyzer(), overrideInc)).             fieldType.setSearchQuoteAnalyzer(new NamedAnalyzer(fieldType.searchQuoteAnalyzer(), overrideInc)).         }     }     setupFieldType(context).     return new AnnotatedTextFieldMapper(name, fieldType(), defaultFieldType, positionIncrementGap, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;21;;@Override public Mapper.Builder<AnnotatedTextFieldMapper.Builder, AnnotatedTextFieldMapper> parse(String fieldName, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     AnnotatedTextFieldMapper.Builder builder = new AnnotatedTextFieldMapper.Builder(fieldName).     builder.fieldType().setIndexAnalyzer(parserContext.getIndexAnalyzers().getDefaultIndexAnalyzer()).     builder.fieldType().setSearchAnalyzer(parserContext.getIndexAnalyzers().getDefaultSearchAnalyzer()).     builder.fieldType().setSearchQuoteAnalyzer(parserContext.getIndexAnalyzers().getDefaultSearchQuoteAnalyzer()).     parseTextField(builder, fieldName, node, parserContext).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String propName = entry.getKey().         Object propNode = entry.getValue().         if (propName.equals("position_increment_gap")) {             int newPositionIncrementGap = XContentMapValues.nodeIntegerValue(propNode, -1).             builder.positionIncrementGap(newPositionIncrementGap).             iterator.remove().         }     }     return builder. }
false;public,static;1;43;;public static AnnotatedText parse(String textPlusMarkup) {     List<AnnotationToken> annotations = new ArrayList<>().     Matcher m = markdownPattern.matcher(textPlusMarkup).     int lastPos = 0.     StringBuilder sb = new StringBuilder().     while (m.find()) {         if (m.start() > lastPos) {             sb.append(textPlusMarkup.substring(lastPos, m.start())).         }         int startOffset = sb.length().         int endOffset = sb.length() + m.group(1).length().         sb.append(m.group(1)).         lastPos = m.end().         String[] pairs = m.group(2).split("&").         String value = null.         for (String pair : pairs) {             String[] kv = pair.split("=").             try {                 if (kv.length == 2) {                     throw new ElasticsearchParseException("key=value pairs are not supported in annotations").                 }                 if (kv.length == 1) {                     // Check "=" sign wasn't in the pair string                     if (kv[0].length() == pair.length()) {                         // untyped value                         value = URLDecoder.decode(kv[0], "UTF-8").                     }                 }                 if (value != null && value.length() > 0) {                     annotations.add(new AnnotationToken(startOffset, endOffset, value)).                 }             } catch (UnsupportedEncodingException uee) {                 throw new ElasticsearchParseException("Unsupported encoding parsing annotated text", uee).             }         }     }     if (lastPos < textPlusMarkup.length()) {         sb.append(textPlusMarkup.substring(lastPos)).     }     return new AnnotatedText(sb.toString(), textPlusMarkup, annotations). }
false;public;0;4;;@Override public String toString() {     return value + " (" + offset + " - " + endOffset + ")". }
false;public;2;4;;public boolean intersects(int start, int end) {     return (start <= offset && end >= offset) || (start <= endOffset && end >= endOffset) || (start >= offset && end <= endOffset). }
false;public;0;9;;@Override public int hashCode() {     final int prime = 31.     int result = 1.     result = prime * result + endOffset.     result = prime * result + offset.     result = prime * result + Objects.hashCode(value).     return result. }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (this == obj)         return true.     if (obj == null)         return false.     if (getClass() != obj.getClass())         return false.     AnnotationToken other = (AnnotationToken) obj.     return Objects.equals(endOffset, other.endOffset) && Objects.equals(offset, other.offset) && Objects.equals(value, other.value). }
false;public;0;11;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     sb.append(textMinusMarkup).     sb.append("\n").     annotations.forEach(a -> {         sb.append(a).         sb.append("\n").     }).     return sb.toString(). }
false;public;0;3;;public int numAnnotations() {     return annotations.size(). }
false;public;1;3;;public AnnotationToken getAnnotation(int index) {     return annotations.get(index). }
false;public;1;6;;public void init(String[] markedUpFieldValues) {     this.annotations = new AnnotatedText[markedUpFieldValues.length].     for (int i = 0. i < markedUpFieldValues.length. i++) {         annotations[i] = AnnotatedText.parse(markedUpFieldValues[i]).     } }
false;public;0;7;;public String[] getPlainTextValuesForHighlighter() {     String[] result = new String[annotations.length].     for (int i = 0. i < annotations.length. i++) {         result[i] = annotations[i].textMinusMarkup.     }     return result. }
false;public;2;18;;public AnnotationToken[] getIntersectingAnnotations(int start, int end) {     List<AnnotationToken> intersectingAnnotations = new ArrayList<>().     int fieldValueOffset = 0.     for (AnnotatedText fieldValueAnnotations : this.annotations) {         // the previous values AND the MULTIVAL delimiter         for (AnnotationToken token : fieldValueAnnotations.annotations) {             if (token.intersects(start - fieldValueOffset, end - fieldValueOffset)) {                 intersectingAnnotations.add(new AnnotationToken(token.offset + fieldValueOffset, token.endOffset + fieldValueOffset, token.value)).             }         }         // add 1 for the fieldvalue separator character         fieldValueOffset += fieldValueAnnotations.textMinusMarkup.length() + 1.     }     return intersectingAnnotations.toArray(new AnnotationToken[intersectingAnnotations.size()]). }
false;public;1;4;;@Override public Analyzer getWrappedAnalyzer(String fieldName) {     return delegate. }
false;protected;2;12;;@Override protected TokenStreamComponents wrapComponents(String fieldName, TokenStreamComponents components) {     AnnotationsInjector injector = new AnnotationsInjector(components.getTokenStream()).     AtomicInteger readerNum = new AtomicInteger(0).     return new TokenStreamComponents(r -> {         String plainText = readToString(r).         AnnotatedText at = this.annotations[readerNum.getAndIncrement()].         assert at.textMinusMarkup.equals(plainText).         injector.setAnnotations(at).         components.getSource().accept(new StringReader(at.textMinusMarkup)).     }, injector). }
false;public;1;4;;@Override public Analyzer getWrappedAnalyzer(String fieldName) {     return delegate. }
false;protected;2;13;;@Override protected TokenStreamComponents wrapComponents(String fieldName, TokenStreamComponents components) {     if (components.getTokenStream() instanceof AnnotationsInjector) {         // already wrapped         return components.     }     AnnotationsInjector injector = new AnnotationsInjector(components.getTokenStream()).     return new TokenStreamComponents(r -> {         AnnotatedText annotations = AnnotatedText.parse(readToString(r)).         injector.setAnnotations(annotations).         components.getSource().accept(new StringReader(annotations.textMinusMarkup)).     }, injector). }
false;static;1;14;;static String readToString(Reader reader) {     char[] arr = new char[8 * 1024].     StringBuilder buffer = new StringBuilder().     int numCharsRead.     try {         while ((numCharsRead = reader.read(arr, 0, arr.length)) != -1) {             buffer.append(arr, 0, numCharsRead).         }         reader.close().         return buffer.toString().     } catch (IOException e) {         throw new UncheckedIOException("IO Error reading field content", e).     } }
false;public;1;9;;public void setAnnotations(AnnotatedText annotatedText) {     this.annotatedText = annotatedText.     currentAnnotationIndex = 0.     if (annotatedText != null && annotatedText.numAnnotations() > 0) {         nextAnnotationForInjection = annotatedText.getAnnotation(0).     } else {         nextAnnotationForInjection = null.     } }
false;public;0;7;;@Override public void reset() throws IOException {     pendingStates.clear().     pendingStatePos = 0.     inputExhausted = false.     super.reset(). }
true;private;0;15;// text tokens or directly from the wrapped TokenStream ;// Abstracts if we are pulling from some pre-cached buffer of // text tokens or directly from the wrapped TokenStream private boolean internalNextToken() throws IOException {     if (pendingStatePos < pendingStates.size()) {         restoreState(pendingStates.get(pendingStatePos)).         pendingStatePos++.         if (pendingStatePos >= pendingStates.size()) {             pendingStatePos = 0.             pendingStates.clear().         }         return true.     }     if (inputExhausted) {         return false.     }     return input.incrementToken(). }
false;public;0;38;;@Override public boolean incrementToken() throws IOException {     if (internalNextToken()) {         if (nextAnnotationForInjection != null) {             // If we are at the right point to inject an annotation....             if (textOffsetAtt.startOffset() >= nextAnnotationForInjection.offset) {                 int firstSpannedTextPosInc = posAtt.getPositionIncrement().                 int annotationPosLen = 1.                 // Capture the text token's state for later replay - but                 // with a zero pos increment so is same as annotation                 // that is injected before it                 posAtt.setPositionIncrement(0).                 pendingStates.add(captureState()).                 while (textOffsetAtt.endOffset() <= nextAnnotationForInjection.endOffset) {                     // Buffer up all the other tokens spanned by this annotation to determine length.                     if (input.incrementToken()) {                         if (textOffsetAtt.endOffset() <= nextAnnotationForInjection.endOffset && textOffsetAtt.startOffset() < nextAnnotationForInjection.endOffset) {                             annotationPosLen += posAtt.getPositionIncrement().                         }                         pendingStates.add(captureState()).                     } else {                         inputExhausted = true.                         break.                     }                 }                 emitAnnotation(firstSpannedTextPosInc, annotationPosLen).                 return true.             }         }         return true.     } else {         inputExhausted = true.         return false.     } }
false;private;1;4;;private void setType(AnnotationToken token) {     // Default annotation type - in future AnnotationTokens may contain custom type info     typeAtt.setType("annotation"). }
false;private;2;38;;private void emitAnnotation(int firstSpannedTextPosInc, int annotationPosLen) throws IOException {     // Set the annotation's attributes     posLenAtt.setPositionLength(annotationPosLen).     textOffsetAtt.setOffset(nextAnnotationForInjection.offset, nextAnnotationForInjection.endOffset).     setType(nextAnnotationForInjection).     // We may have multiple annotations at this location - stack them up     final int annotationOffset = nextAnnotationForInjection.offset.     final AnnotatedText.AnnotationToken firstAnnotationAtThisPos = nextAnnotationForInjection.     while (nextAnnotationForInjection != null && nextAnnotationForInjection.offset == annotationOffset) {         setType(nextAnnotationForInjection).         termAtt.resizeBuffer(nextAnnotationForInjection.value.length()).         termAtt.copyBuffer(nextAnnotationForInjection.value.toCharArray(), 0, nextAnnotationForInjection.value.length()).         if (nextAnnotationForInjection == firstAnnotationAtThisPos) {             posAtt.setPositionIncrement(firstSpannedTextPosInc).             // Put at the head of the queue of tokens to be emitted             pendingStates.add(0, captureState()).         } else {             posAtt.setPositionIncrement(0).             // Put after the head of the queue of tokens to be emitted             pendingStates.add(1, captureState()).         }         // Flag the inject annotation as null to prevent re-injection.         currentAnnotationIndex++.         if (currentAnnotationIndex < annotatedText.numAnnotations()) {             nextAnnotationForInjection = annotatedText.getAnnotation(currentAnnotationIndex).         } else {             nextAnnotationForInjection = null.         }     }     // Now pop the first of many potential buffered tokens:     internalNextToken(). }
false;public;1;11;;@Override public void setIndexAnalyzer(NamedAnalyzer delegate) {     if (delegate.analyzer() instanceof AnnotationAnalyzerWrapper) {         // Already wrapped the Analyzer with an AnnotationAnalyzer         super.setIndexAnalyzer(delegate).     } else {         // Wrap the analyzer with an AnnotationAnalyzer that will inject required annotations         super.setIndexAnalyzer(new NamedAnalyzer(delegate.name(), AnalyzerScope.INDEX, new AnnotationAnalyzerWrapper(delegate.analyzer()))).     } }
false;public;0;3;;public AnnotatedTextFieldType clone() {     return new AnnotatedTextFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     if (omitNorms()) {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } else {         return new NormsFieldExistsQuery(name()).     } }
false;public;3;7;;@Override public SpanQuery spanPrefixQuery(String value, SpanMultiTermQueryWrapper.SpanRewriteMethod method, QueryShardContext context) {     SpanMultiTermQueryWrapper<?> spanMulti = new SpanMultiTermQueryWrapper<>(new PrefixQuery(new Term(name(), indexedValueForSearch(value)))).     spanMulti.setRewriteMethod(method).     return spanMulti. }
false;public;3;4;;@Override public Query phraseQuery(TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {     return TextFieldMapper.createPhraseQuery(stream, name(), slop, enablePositionIncrements). }
false;public;3;4;;@Override public Query multiPhraseQuery(TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {     return TextFieldMapper.createPhraseQuery(stream, name(), slop, enablePositionIncrements). }
false;public;3;4;;@Override public Query phrasePrefixQuery(TokenStream stream, int slop, int maxExpansions) throws IOException {     return TextFieldMapper.createPhrasePrefixQuery(stream, name(), slop, maxExpansions). }
false;protected;0;4;;@Override protected AnnotatedTextFieldMapper clone() {     return (AnnotatedTextFieldMapper) super.clone(). }
false;public;0;3;;public int getPositionIncrementGap() {     return this.positionIncrementGap. }
false;protected;2;21;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     final String value.     if (context.externalValueSet()) {         value = context.externalValue().toString().     } else {         value = context.parser().textOrNull().     }     if (value == null) {         return.     }     if (fieldType().indexOptions() != IndexOptions.NONE || fieldType().stored()) {         Field field = new Field(fieldType().name(), value, fieldType()).         fields.add(field).         if (fieldType().omitNorms()) {             createFieldNamesField(context, fields).         }     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;0;4;;@Override public AnnotatedTextFieldType fieldType() {     return (AnnotatedTextFieldType) super.fieldType(). }
false;protected;3;9;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     doXContentAnalyzers(builder, includeDefaults).     if (includeDefaults || positionIncrementGap != POSITION_INCREMENT_GAP_USE_ANALYZER) {         builder.field("position_increment_gap", positionIncrementGap).     } }
