commented;modifiers;parameterAmount;loc;comment;code
true;static;1;11;/**  * Locates the keytab file in the environment and verifies that it exists.  * Expects keytab file to exist at {@code $CONFIG_DIR$/repository-hdfs/krb5.keytab}  */ ;/**  * Locates the keytab file in the environment and verifies that it exists.  * Expects keytab file to exist at {@code $CONFIG_DIR$/repository-hdfs/krb5.keytab}  */ static Path locateKeytabFile(Environment environment) {     Path keytabPath = environment.configFile().resolve("repository-hdfs").resolve("krb5.keytab").     try {         if (Files.exists(keytabPath) == false) {             throw new RuntimeException("Could not locate keytab at [" + keytabPath + "].").         }     } catch (SecurityException se) {         throw new RuntimeException("Could not locate keytab at [" + keytabPath + "]", se).     }     return keytabPath. }
false;private;1;19;;private Permission[] renderPermissions(UserGroupInformation ugi) {     Permission[] permissions.     if (ugi.isFromKeytab()) {         // KERBEROS         // Leave room to append one extra permission based on the logged in user's info.         int permlen = KERBEROS_AUTH_PERMISSIONS.length + 1.         permissions = new Permission[permlen].         System.arraycopy(KERBEROS_AUTH_PERMISSIONS, 0, permissions, 0, KERBEROS_AUTH_PERMISSIONS.length).         // Append a kerberos.ServicePermission to only allow initiating kerberos connections         // as the logged in user.         permissions[permissions.length - 1] = new ServicePermission(ugi.getUserName(), "initiate").     } else {         // SIMPLE         permissions = Arrays.copyOf(SIMPLE_AUTH_PERMISSIONS, SIMPLE_AUTH_PERMISSIONS.length).     }     return permissions. }
false;private;0;3;;private Permission[] getRestrictedExecutionPermissions() {     return restrictedExecutionPermissions. }
false;;1;12;;<T> T doPrivilegedOrThrow(PrivilegedExceptionAction<T> action) throws IOException {     SpecialPermission.check().     try {         if (restrictPermissions) {             return AccessController.doPrivileged(action, null, this.getRestrictedExecutionPermissions()).         } else {             return AccessController.doPrivileged(action).         }     } catch (PrivilegedActionException e) {         throw (IOException) e.getCause().     } }
false;;0;9;;void ensureLogin() {     if (ugi.isFromKeytab()) {         try {             ugi.checkTGTAndReloginFromKeytab().         } catch (IOException ioe) {             throw new UncheckedIOException("Could not re-authenticate", ioe).         }     } }
