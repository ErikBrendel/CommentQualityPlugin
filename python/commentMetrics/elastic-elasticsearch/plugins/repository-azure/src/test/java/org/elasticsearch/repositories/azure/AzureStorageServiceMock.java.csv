commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public boolean doesContainerExist(String account, String container) {     return true. }
false;public;3;7;;@Override public void deleteFiles(String account, String container, String path) throws URISyntaxException, StorageException {     final Map<String, BlobMetaData> blobs = listBlobsByPrefix(account, container, path, null).     for (String key : blobs.keySet()) {         deleteBlob(account, container, key).     } }
false;public;3;4;;@Override public boolean blobExists(String account, String container, String blob) {     return blobs.containsKey(blob). }
false;public;3;6;;@Override public void deleteBlob(String account, String container, String blob) throws URISyntaxException, StorageException {     if (blobs.remove(blob) == null) {         throw new StorageException("BlobNotFound", "[" + blob + "] does not exist.", 404, null, null).     } }
false;public;3;7;;@Override public InputStream getInputStream(String account, String container, String blob) throws IOException {     if (!blobExists(account, container, blob)) {         throw new NoSuchFileException("missing blob [" + blob + "]").     }     return AzureStorageService.giveSocketPermissionsToStream(new PermissionRequiringInputStream(blobs.get(blob).toByteArray())). }
false;public;4;17;;@Override public Map<String, BlobMetaData> listBlobsByPrefix(String account, String container, String keyPath, String prefix) {     MapBuilder<String, BlobMetaData> blobsBuilder = MapBuilder.newMapBuilder().     blobs.forEach((String blobName, ByteArrayOutputStream bos) -> {         final String checkBlob.         if (keyPath != null && !keyPath.isEmpty()) {             // strip off key path from the beginning of the blob name             checkBlob = blobName.replace(keyPath, "").         } else {             checkBlob = blobName.         }         if (prefix == null || startsWithIgnoreCase(checkBlob, prefix)) {             blobsBuilder.put(blobName, new PlainBlobMetaData(checkBlob, bos.size())).         }     }).     return blobsBuilder.immutableMap(). }
false;public;6;14;;@Override public void writeBlob(String account, String container, String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws URISyntaxException, StorageException, FileAlreadyExistsException {     if (failIfAlreadyExists && blobs.containsKey(blobName)) {         throw new FileAlreadyExistsException(blobName).     }     try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {         blobs.put(blobName, outputStream).         Streams.copy(inputStream, outputStream).     } catch (IOException e) {         throw new StorageException("MOCK", "Error while writing mock stream", e).     } }
true;private,static;2;14;/**  * Test if the given String starts with the specified prefix,  * ignoring upper/lower case.  *  * @param str    the String to check  * @param prefix the prefix to look for  * @see java.lang.String#startsWith  */ ;/**  * Test if the given String starts with the specified prefix,  * ignoring upper/lower case.  *  * @param str    the String to check  * @param prefix the prefix to look for  * @see java.lang.String#startsWith  */ private static boolean startsWithIgnoreCase(String str, String prefix) {     if (str == null || prefix == null) {         return false.     }     if (str.startsWith(prefix)) {         return true.     }     if (str.length() < prefix.length()) {         return false.     }     String lcStr = str.substring(0, prefix.length()).toLowerCase(Locale.ROOT).     String lcPrefix = prefix.toLowerCase(Locale.ROOT).     return lcStr.equals(lcPrefix). }
false;public,synchronized;0;5;;@Override public synchronized int read() {     AccessController.checkPermission(new SocketPermission("*", "connect")).     return super.read(). }
false;public;1;5;;@Override public int read(byte[] b) throws IOException {     AccessController.checkPermission(new SocketPermission("*", "connect")).     return super.read(b). }
false;public,synchronized;3;5;;@Override public synchronized int read(byte[] b, int off, int len) {     AccessController.checkPermission(new SocketPermission("*", "connect")).     return super.read(b, off, len). }
false;public;1;4;;@Override public Tuple<CloudBlobClient, Supplier<OperationContext>> client(String clientName) {     return null. }
false;public;1;4;;@Override public Map<String, AzureStorageSettings> refreshAndClearCache(Map<String, AzureStorageSettings> clientsSettings) {     return emptyMap(). }
