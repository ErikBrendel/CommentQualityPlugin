commented;modifiers;parameterAmount;loc;comment;code
true;private,static;1;3;/**  * Tests if the given character is a vowel.  *  * @param c the character to test  * @return {@code true} if the character is a vowel, {@code false} otherwise  */ ;/**  * Tests if the given character is a vowel.  *  * @param c the character to test  * @return {@code true} if the character is a vowel, {@code false} otherwise  */ private static boolean isVowel(final char c) {     return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'. }
true;private,static;4;51;/**  * Transcodes the remaining parts of the String. The method operates on a  * sliding window, looking at 4 characters at a time: [i-1, i, i+1, i+2].  *  * @param prev the previous character  * @param curr the current character  * @param next the next character  * @param aNext the after next character  * @return a transcoded array of characters, starting from the current  * position  */ ;/**  * Transcodes the remaining parts of the String. The method operates on a  * sliding window, looking at 4 characters at a time: [i-1, i, i+1, i+2].  *  * @param prev the previous character  * @param curr the current character  * @param next the next character  * @param aNext the after next character  * @return a transcoded array of characters, starting from the current  * position  */ private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {     // 1. EV -> AF     if (curr == 'E' && next == 'V') {         return CHARS_AF.     }     // A, E, I, O, U -> A     if (isVowel(curr)) {         return CHARS_A.     }     // 2. Q -> G, Z -> S, M -> N     if (curr == 'Q') {         return CHARS_G.     } else if (curr == 'Z') {         return CHARS_S.     } else if (curr == 'M') {         return CHARS_N.     }     // 3. KN -> NN else K -> C     if (curr == 'K') {         if (next == 'N') {             return CHARS_NN.         } else {             return CHARS_C.         }     }     // 4. SCH -> SSS     if (curr == 'S' && next == 'C' && aNext == 'H') {         return CHARS_SSS.     }     // PH -> FF     if (curr == 'P' && next == 'H') {         return CHARS_FF.     }     // 5. H -> If previous or next is a non vowel, previous.     if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) {         return new char[] { prev }.     }     // 6. W -> If previous is vowel, previous.     if (curr == 'W' && isVowel(prev)) {         return new char[] { prev }.     }     return new char[] { curr }. }
true;public;1;7;/**  * Encodes an Object using the NYSIIS algorithm. This method is provided in  * order to satisfy the requirements of the Encoder interface, and will  * throw an {@link EncoderException} if the supplied object is not of type  * {@link String}.  *  * @param obj Object to encode  * @return An object (or a {@link String}) containing the NYSIIS code which  * corresponds to the given String.  * @throws EncoderException if the parameter supplied is not of a {@link String}  * @throws IllegalArgumentException if a character is not mapped  */ ;/**  * Encodes an Object using the NYSIIS algorithm. This method is provided in  * order to satisfy the requirements of the Encoder interface, and will  * throw an {@link EncoderException} if the supplied object is not of type  * {@link String}.  *  * @param obj Object to encode  * @return An object (or a {@link String}) containing the NYSIIS code which  * corresponds to the given String.  * @throws EncoderException if the parameter supplied is not of a {@link String}  * @throws IllegalArgumentException if a character is not mapped  */ @Override public Object encode(Object obj) throws EncoderException {     if (!(obj instanceof String)) {         throw new EncoderException("Parameter supplied to Nysiis encode is not of type java.lang.String").     }     return this.nysiis((String) obj). }
true;public;1;4;/**  * Encodes a String using the NYSIIS algorithm.  *  * @param str A String object to encode  * @return A Nysiis code corresponding to the String supplied  * @throws IllegalArgumentException if a character is not mapped  */ ;/**  * Encodes a String using the NYSIIS algorithm.  *  * @param str A String object to encode  * @return A Nysiis code corresponding to the String supplied  * @throws IllegalArgumentException if a character is not mapped  */ @Override public String encode(String str) {     return this.nysiis(str). }
true;public;0;3;/**  * Indicates the strict mode for this {@link Nysiis} encoder.  *  * @return {@code true} if the encoder is configured for strict mode, {@code false}  * otherwise  */ ;/**  * Indicates the strict mode for this {@link Nysiis} encoder.  *  * @return {@code true} if the encoder is configured for strict mode, {@code false}  * otherwise  */ public boolean isStrict() {     return this.strict. }
true;public;1;71;/**  * Retrieves the NYSIIS code for a given String object.  *  * @param str String to encode using the NYSIIS algorithm  * @return A NYSIIS code for the String supplied  */ ;/**  * Retrieves the NYSIIS code for a given String object.  *  * @param str String to encode using the NYSIIS algorithm  * @return A NYSIIS code for the String supplied  */ public String nysiis(String str) {     if (str == null) {         return null.     }     // Use the same clean rules as Soundex     str = clean(str).     if (str.length() == 0) {         return str.     }     // Translate first characters of name:     // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS     str = PAT_MAC.matcher(str).replaceFirst("MCC").     str = PAT_KN.matcher(str).replaceFirst("NN").     str = PAT_K.matcher(str).replaceFirst("C").     str = PAT_PH_PF.matcher(str).replaceFirst("FF").     str = PAT_SCH.matcher(str).replaceFirst("SSS").     // Translate last characters of name:     // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D     str = PAT_EE_IE.matcher(str).replaceFirst("Y").     str = PAT_DT_ETC.matcher(str).replaceFirst("D").     // First character of key = first character of name.     StringBuilder key = new StringBuilder(str.length()).     key.append(str.charAt(0)).     // Transcode remaining characters, incrementing by one character each time     final char[] chars = str.toCharArray().     final int len = chars.length.     for (int i = 1. i < len. i++) {         final char next = i < len - 1 ? chars[i + 1] : SPACE.         final char aNext = i < len - 2 ? chars[i + 2] : SPACE.         final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext).         System.arraycopy(transcoded, 0, chars, i, transcoded.length).         // only append the current char to the key if it is different from the last one         if (chars[i] != chars[i - 1]) {             key.append(chars[i]).         }     }     if (key.length() > 1) {         char lastChar = key.charAt(key.length() - 1).         // If last character is S, remove it.         if (lastChar == 'S') {             key.deleteCharAt(key.length() - 1).             lastChar = key.charAt(key.length() - 1).         }         if (key.length() > 2) {             final char last2Char = key.charAt(key.length() - 2).             // If last characters are AY, replace with Y.             if (last2Char == 'A' && lastChar == 'Y') {                 key.deleteCharAt(key.length() - 2).             }         }         // If last character is A, remove it.         if (lastChar == 'A') {             key.deleteCharAt(key.length() - 1).         }     }     final String string = key.toString().     return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string. }
false;static;1;17;;static String clean(String str) {     if (str == null || str.length() == 0) {         return str.     }     int len = str.length().     char[] chars = new char[len].     int count = 0.     for (int i = 0. i < len. i++) {         if (Character.isLetter(str.charAt(i))) {             chars[count++] = str.charAt(i).         }     }     if (count == len) {         return str.toUpperCase(java.util.Locale.ENGLISH).     }     return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH). }
