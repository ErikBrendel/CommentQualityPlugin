commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public List<TransportAddress> getSeedAddresses(HostsResolver hostsResolver) {     return dynamicHosts.getOrRefresh(). }
false;protected;0;97;;protected List<TransportAddress> fetchDynamicNodes() {     final List<TransportAddress> dynamicHosts = new ArrayList<>().     final DescribeInstancesResult descInstances.     try (AmazonEc2Reference clientReference = awsEc2Service.client()) {         // Query EC2 API based on AZ, instance state, and tag.         // NOTE: we don't filter by security group during the describe instances request for two reasons:         // 1. differences in VPCs require different parameters during query (ID vs Name)         // 2. We want to use two different strategies: (all security groups vs. any security groups)         descInstances = SocketAccess.doPrivileged(() -> clientReference.client().describeInstances(buildDescribeInstancesRequest())).     } catch (final AmazonClientException e) {         logger.info("Exception while retrieving instance list from AWS API: {}", e.getMessage()).         logger.debug("Full exception:", e).         return dynamicHosts.     }     logger.trace("finding seed nodes...").     for (final Reservation reservation : descInstances.getReservations()) {         for (final Instance instance : reservation.getInstances()) {             // lets see if we can filter based on groups             if (!groups.isEmpty()) {                 final List<GroupIdentifier> instanceSecurityGroups = instance.getSecurityGroups().                 final List<String> securityGroupNames = new ArrayList<>(instanceSecurityGroups.size()).                 final List<String> securityGroupIds = new ArrayList<>(instanceSecurityGroups.size()).                 for (final GroupIdentifier sg : instanceSecurityGroups) {                     securityGroupNames.add(sg.getGroupName()).                     securityGroupIds.add(sg.getGroupId()).                 }                 if (bindAnyGroup) {                     // We check if we can find at least one group name or one group id in groups.                     if (disjoint(securityGroupNames, groups) && disjoint(securityGroupIds, groups)) {                         logger.trace("filtering out instance {} based on groups {}, not part of {}", instance.getInstanceId(), instanceSecurityGroups, groups).                         // continue to the next instance                         continue.                     }                 } else {                     // We need tp match all group names or group ids, otherwise we ignore this instance                     if (!(securityGroupNames.containsAll(groups) || securityGroupIds.containsAll(groups))) {                         logger.trace("filtering out instance {} based on groups {}, does not include all of {}", instance.getInstanceId(), instanceSecurityGroups, groups).                         // continue to the next instance                         continue.                     }                 }             }             String address = null.             if (hostType.equals(PRIVATE_DNS)) {                 address = instance.getPrivateDnsName().             } else if (hostType.equals(PRIVATE_IP)) {                 address = instance.getPrivateIpAddress().             } else if (hostType.equals(PUBLIC_DNS)) {                 address = instance.getPublicDnsName().             } else if (hostType.equals(PUBLIC_IP)) {                 address = instance.getPublicIpAddress().             } else if (hostType.startsWith(TAG_PREFIX)) {                 // Reading the node host from its metadata                 final String tagName = hostType.substring(TAG_PREFIX.length()).                 logger.debug("reading hostname from [{}] instance tag", tagName).                 final List<Tag> tags = instance.getTags().                 for (final Tag tag : tags) {                     if (tag.getKey().equals(tagName)) {                         address = tag.getValue().                         logger.debug("using [{}] as the instance address", address).                     }                 }             } else {                 throw new IllegalArgumentException(hostType + " is unknown for discovery.ec2.host_type").             }             if (address != null) {                 try {                     // we only limit to 1 port per address, makes no sense to ping 100 ports                     final TransportAddress[] addresses = transportService.addressesFromString(address, 1).                     for (int i = 0. i < addresses.length. i++) {                         logger.trace("adding {}, address {}, transport_address {}", instance.getInstanceId(), address, addresses[i]).                         dynamicHosts.add(addresses[i]).                     }                 } catch (final Exception e) {                     final String finalAddress = address.                     logger.warn((Supplier<?>) () -> new ParameterizedMessage("failed to add {}, address {}", instance.getInstanceId(), finalAddress), e).                 }             } else {                 logger.trace("not adding {}, address is null, host_type {}", instance.getInstanceId(), hostType).             }         }     }     logger.debug("using dynamic transport addresses {}", dynamicHosts).     return dynamicHosts. }
false;private;0;22;;private DescribeInstancesRequest buildDescribeInstancesRequest() {     final DescribeInstancesRequest describeInstancesRequest = new DescribeInstancesRequest().withFilters(new Filter("instance-state-name").withValues("running", "pending")).     for (final Map.Entry<String, List<String>> tagFilter : tags.entrySet()) {         // for a given tag key, OR relationship for multiple different values         describeInstancesRequest.withFilters(new Filter("tag:" + tagFilter.getKey()).withValues(tagFilter.getValue())).     }     if (!availabilityZones.isEmpty()) {         // OR relationship amongst multiple values of the availability-zone filter         describeInstancesRequest.withFilters(new Filter("availability-zone").withValues(availabilityZones)).     }     return describeInstancesRequest. }
false;protected;0;4;;@Override protected boolean needsRefresh() {     return (empty || super.needsRefresh()). }
false;protected;0;6;;@Override protected List<TransportAddress> refresh() {     final List<TransportAddress> nodes = fetchDynamicNodes().     empty = nodes.isEmpty().     return nodes. }
