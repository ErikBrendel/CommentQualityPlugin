commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;boolean isIgnoreMissing() {     return ignoreMissing. }
false;public;1;94;;@Override public IngestDocument execute(IngestDocument ingestDocument) {     Map<String, Object> additionalFields = new HashMap<>().     byte[] input = ingestDocument.getFieldValueAsBytes(field, ignoreMissing).     if (input == null && ignoreMissing) {         return ingestDocument.     } else if (input == null) {         throw new IllegalArgumentException("field [" + field + "] is null, cannot parse.").     }     Integer indexedChars = this.indexedChars.     if (indexedCharsField != null) {         // If the user provided the number of characters to be extracted as part of the document, we use it         indexedChars = ingestDocument.getFieldValue(indexedCharsField, Integer.class, true).         if (indexedChars == null) {             // If the field does not exist we fall back to the global limit             indexedChars = this.indexedChars.         }     }     Metadata metadata = new Metadata().     String parsedContent = "".     try {         parsedContent = TikaImpl.parse(input, metadata, indexedChars).     } catch (ZeroByteFileException e) {     // tika 1.17 throws an exception when the InputStream has 0 bytes.     // previously, it did not mind. This is here to preserve that behavior.     } catch (Exception e) {         throw new ElasticsearchParseException("Error parsing document in field [{}]", e, field).     }     if (properties.contains(Property.CONTENT) && Strings.hasLength(parsedContent)) {         // somehow tika seems to append a newline at the end automatically, lets remove that again         additionalFields.put(Property.CONTENT.toLowerCase(), parsedContent.trim()).     }     if (properties.contains(Property.LANGUAGE) && Strings.hasLength(parsedContent)) {         LanguageIdentifier identifier = new LanguageIdentifier(parsedContent).         String language = identifier.getLanguage().         additionalFields.put(Property.LANGUAGE.toLowerCase(), language).     }     if (properties.contains(Property.DATE)) {         String createdDate = metadata.get(TikaCoreProperties.CREATED).         if (createdDate != null) {             additionalFields.put(Property.DATE.toLowerCase(), createdDate).         }     }     if (properties.contains(Property.TITLE)) {         String title = metadata.get(TikaCoreProperties.TITLE).         if (Strings.hasLength(title)) {             additionalFields.put(Property.TITLE.toLowerCase(), title).         }     }     if (properties.contains(Property.AUTHOR)) {         String author = metadata.get("Author").         if (Strings.hasLength(author)) {             additionalFields.put(Property.AUTHOR.toLowerCase(), author).         }     }     if (properties.contains(Property.KEYWORDS)) {         String keywords = metadata.get("Keywords").         if (Strings.hasLength(keywords)) {             additionalFields.put(Property.KEYWORDS.toLowerCase(), keywords).         }     }     if (properties.contains(Property.CONTENT_TYPE)) {         String contentType = metadata.get(Metadata.CONTENT_TYPE).         if (Strings.hasLength(contentType)) {             additionalFields.put(Property.CONTENT_TYPE.toLowerCase(), contentType).         }     }     if (properties.contains(Property.CONTENT_LENGTH)) {         String contentLength = metadata.get(Metadata.CONTENT_LENGTH).         long length.         if (Strings.hasLength(contentLength)) {             length = Long.parseLong(contentLength).         } else {             length = parsedContent.length().         }         additionalFields.put(Property.CONTENT_LENGTH.toLowerCase(), length).     }     ingestDocument.setFieldValue(targetField, additionalFields).     return ingestDocument. }
false;public;0;4;;@Override public String getType() {     return TYPE. }
false;;0;3;;String getField() {     return field. }
false;;0;3;;String getTargetField() {     return targetField. }
false;;0;3;;Set<Property> getProperties() {     return properties. }
false;;0;3;;int getIndexedChars() {     return indexedChars. }
false;public;3;27;;@Override public AttachmentProcessor create(Map<String, Processor.Factory> registry, String processorTag, Map<String, Object> config) throws Exception {     String field = readStringProperty(TYPE, processorTag, config, "field").     String targetField = readStringProperty(TYPE, processorTag, config, "target_field", "attachment").     List<String> propertyNames = readOptionalList(TYPE, processorTag, config, "properties").     int indexedChars = readIntProperty(TYPE, processorTag, config, "indexed_chars", NUMBER_OF_CHARS_INDEXED).     boolean ignoreMissing = readBooleanProperty(TYPE, processorTag, config, "ignore_missing", false).     String indexedCharsField = readOptionalStringProperty(TYPE, processorTag, config, "indexed_chars_field").     final Set<Property> properties.     if (propertyNames != null) {         properties = EnumSet.noneOf(Property.class).         for (String fieldName : propertyNames) {             try {                 properties.add(Property.parse(fieldName)).             } catch (Exception e) {                 throw newConfigurationException(TYPE, processorTag, "properties", "illegal field option [" + fieldName + "]. valid values are " + Arrays.toString(Property.values())).             }         }     } else {         properties = DEFAULT_PROPERTIES.     }     return new AttachmentProcessor(processorTag, field, targetField, properties, indexedChars, ignoreMissing, indexedCharsField). }
false;public,static;1;3;;public static Property parse(String value) {     return valueOf(value.toUpperCase(Locale.ROOT)). }
false;public;0;3;;public String toLowerCase() {     return this.toString().toLowerCase(Locale.ROOT). }
