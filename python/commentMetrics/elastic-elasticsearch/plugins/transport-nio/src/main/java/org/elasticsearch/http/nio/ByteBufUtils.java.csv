commented;modifiers;parameterAmount;loc;comment;code
true;static;1;28;/**  * Turns the given BytesReference into a ByteBuf. Note: the returned ByteBuf will reference the internal  * pages of the BytesReference. Don't free the bytes of reference before the ByteBuf goes out of scope.  */ ;/**  * Turns the given BytesReference into a ByteBuf. Note: the returned ByteBuf will reference the internal  * pages of the BytesReference. Don't free the bytes of reference before the ByteBuf goes out of scope.  */ static ByteBuf toByteBuf(final BytesReference reference) {     if (reference.length() == 0) {         return Unpooled.EMPTY_BUFFER.     }     if (reference instanceof ByteBufBytesReference) {         return ((ByteBufBytesReference) reference).toByteBuf().     } else {         final BytesRefIterator iterator = reference.iterator().         // usually we have one, two, or three components from the header, the message, and a buffer         final List<ByteBuf> buffers = new ArrayList<>(3).         try {             BytesRef slice.             while ((slice = iterator.next()) != null) {                 buffers.add(Unpooled.wrappedBuffer(slice.bytes, slice.offset, slice.length)).             }             if (buffers.size() == 1) {                 return buffers.get(0).             } else {                 CompositeByteBuf composite = Unpooled.compositeBuffer(buffers.size()).                 composite.addComponents(true, buffers).                 return composite.             }         } catch (IOException ex) {             throw new AssertionError("no IO happens here", ex).         }     } }
false;static;1;3;;static BytesReference toBytesReference(final ByteBuf buffer) {     return new ByteBufBytesReference(buffer, buffer.readableBytes()). }
false;public;1;4;;@Override public byte get(int index) {     return buffer.getByte(offset + index). }
false;public;0;4;;@Override public int length() {     return length. }
false;public;2;4;;@Override public BytesReference slice(int from, int length) {     return new ByteBufBytesReference(buffer.slice(offset + from, length), length). }
false;public;0;4;;@Override public StreamInput streamInput() {     return new ByteBufStreamInput(buffer.duplicate(), length). }
false;public;1;4;;@Override public void writeTo(OutputStream os) throws IOException {     buffer.getBytes(offset, os, length). }
false;;0;3;;ByteBuf toByteBuf() {     return buffer.duplicate(). }
false;public;0;4;;@Override public String utf8ToString() {     return buffer.toString(offset, length, StandardCharsets.UTF_8). }
false;public;0;9;;@Override public BytesRef toBytesRef() {     if (buffer.hasArray()) {         return new BytesRef(buffer.array(), buffer.arrayOffset() + offset, length).     }     final byte[] copy = new byte[length].     buffer.getBytes(offset, copy).     return new BytesRef(copy). }
false;public;0;4;;@Override public long ramBytesUsed() {     return buffer.capacity(). }
false;public;1;8;;@Override public BytesReference readBytesReference(int length) throws IOException {     // memory leaks.     return super.readBytesReference(length). }
false;public;1;8;;@Override public BytesRef readBytesRef(int length) throws IOException {     // memory leaks.     return super.readBytesRef(length). }
false;public;0;4;;@Override public int available() throws IOException {     return endIndex - buffer.readerIndex(). }
false;protected;1;7;;@Override protected void ensureCanReadBytes(int length) throws EOFException {     int bytesAvailable = endIndex - buffer.readerIndex().     if (bytesAvailable < length) {         throw new EOFException("tried to read: " + length + " bytes but only " + bytesAvailable + " remaining").     } }
false;public;1;4;;@Override public void mark(int readlimit) {     buffer.markReaderIndex(). }
false;public;0;4;;@Override public boolean markSupported() {     return true. }
false;public;0;7;;@Override public int read() throws IOException {     if (available() == 0) {         return -1.     }     return buffer.readByte() & 0xff. }
false;public;3;14;;@Override public int read(byte[] b, int off, int len) throws IOException {     if (len == 0) {         return 0.     }     int available = available().     if (available == 0) {         return -1.     }     len = Math.min(available, len).     buffer.readBytes(b, off, len).     return len. }
false;public;0;4;;@Override public void reset() throws IOException {     buffer.resetReaderIndex(). }
false;public;1;8;;@Override public long skip(long n) throws IOException {     if (n > Integer.MAX_VALUE) {         return skipBytes(Integer.MAX_VALUE).     } else {         return skipBytes((int) n).     } }
false;public;1;5;;public int skipBytes(int n) throws IOException {     int nBytes = Math.min(available(), n).     buffer.skipBytes(nBytes).     return nBytes. }
false;public;0;10;;@Override public byte readByte() throws IOException {     try {         return buffer.readByte().     } catch (IndexOutOfBoundsException ex) {         EOFException eofException = new EOFException().         eofException.initCause(ex).         throw eofException.     } }
false;public;3;7;;@Override public void readBytes(byte[] b, int offset, int len) throws IOException {     int read = read(b, offset, len).     if (read < len) {         throw new IndexOutOfBoundsException().     } }
false;public;0;4;;@Override public void close() throws IOException { // nothing to do here }
