commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Settings getSettings() {     return settings. }
false;public,synchronized;0;3;;public synchronized NioGroup getTransportGroup() throws IOException {     return getGenericGroup(). }
false;public,synchronized;0;8;;public synchronized NioGroup getHttpGroup() throws IOException {     if (httpWorkerCount == 0) {         return getGenericGroup().     } else {         return new NioSelectorGroup(daemonThreadFactory(this.settings, HttpServerTransport.HTTP_SERVER_WORKER_THREAD_NAME_PREFIX), httpWorkerCount, (s) -> new EventHandler(this::onException, s)).     } }
false;private;0;12;;private NioGroup getGenericGroup() throws IOException {     if (refCountedGroup == null) {         ThreadFactory threadFactory = daemonThreadFactory(this.settings, TcpTransport.TRANSPORT_WORKER_THREAD_NAME_PREFIX).         NioSelectorGroup nioGroup = new NioSelectorGroup(threadFactory, NioTransportPlugin.NIO_WORKER_COUNT.get(settings), (s) -> new EventHandler(this::onException, s)).         this.refCountedGroup = new RefCountedNioGroup(nioGroup).         return new WrappedNioGroup(refCountedGroup).     } else {         refCountedGroup.incRef().         return new WrappedNioGroup(refCountedGroup).     } }
false;private;1;4;;private void onException(Exception exception) {     logger.warn(new ParameterizedMessage("exception caught on transport layer [thread={}]", Thread.currentThread().getName()), exception). }
false;protected;0;8;;@Override protected void closeInternal() {     try {         nioGroup.close().     } catch (IOException e) {         throw new UncheckedIOException(e).     } }
false;public;2;5;;@Override public <S extends NioServerSocketChannel> S bindServerChannel(InetSocketAddress address, ChannelFactory<S, ?> factory) throws IOException {     return nioGroup.bindServerChannel(address, factory). }
false;public;2;4;;@Override public <S extends NioSocketChannel> S openChannel(InetSocketAddress address, ChannelFactory<?, S> factory) throws IOException {     return nioGroup.openChannel(address, factory). }
false;public;0;4;;@Override public void close() throws IOException {     throw new UnsupportedOperationException("Should not close. Instead use decRef call."). }
false;public;2;5;;public <S extends NioServerSocketChannel> S bindServerChannel(InetSocketAddress address, ChannelFactory<S, ?> factory) throws IOException {     ensureOpen().     return refCountedNioGroup.bindServerChannel(address, factory). }
false;public;2;4;;public <S extends NioSocketChannel> S openChannel(InetSocketAddress address, ChannelFactory<?, S> factory) throws IOException {     ensureOpen().     return refCountedNioGroup.openChannel(address, factory). }
false;public;0;6;;@Override public void close() {     if (isOpen.compareAndSet(true, false)) {         refCountedNioGroup.decRef().     } }
false;private;0;5;;private void ensureOpen() {     if (isOpen.get() == false) {         throw new IllegalStateException("NioGroup is closed.").     } }
