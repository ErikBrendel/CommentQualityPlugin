commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;public void testBasicRead() {     TenIntsToStringsHandler handler = new TenIntsToStringsHandler().     NettyAdaptor nettyAdaptor = new NettyAdaptor(handler).     ByteBuffer message = ByteBuffer.allocate(40).     for (int i = 0. i < 10. ++i) {         message.putInt(i).     }     message.flip().     ByteBuffer[] buffers = { message }.     assertEquals(40, nettyAdaptor.read(buffers)).     assertEquals("0123456789", handler.result). }
false;public;0;12;;public void testBasicReadWithExcessData() {     TenIntsToStringsHandler handler = new TenIntsToStringsHandler().     NettyAdaptor nettyAdaptor = new NettyAdaptor(handler).     ByteBuffer message = ByteBuffer.allocate(52).     for (int i = 0. i < 13. ++i) {         message.putInt(i).     }     message.flip().     ByteBuffer[] buffers = { message }.     assertEquals(40, nettyAdaptor.read(buffers)).     assertEquals("0123456789", handler.result). }
false;public;0;10;;public void testUncaughtReadExceptionsBubbleUp() {     NettyAdaptor nettyAdaptor = new NettyAdaptor(new TenIntsToStringsHandler()).     ByteBuffer message = ByteBuffer.allocate(40).     for (int i = 0. i < 9. ++i) {         message.putInt(i).     }     message.flip().     ByteBuffer[] buffers = { message }.     expectThrows(IllegalStateException.class, () -> nettyAdaptor.read(buffers)). }
false;public;0;20;;public void testWriteInsidePipelineIsCaptured() {     TenIntsToStringsHandler tenIntsToStringsHandler = new TenIntsToStringsHandler().     PromiseCheckerHandler promiseCheckerHandler = new PromiseCheckerHandler().     NettyAdaptor nettyAdaptor = new NettyAdaptor(new CapitalizeWriteHandler(), promiseCheckerHandler, new WriteInMiddleHandler(), tenIntsToStringsHandler).     byte[] bytes = "SHOULD_WRITE".getBytes(StandardCharsets.UTF_8).     ByteBuffer message = ByteBuffer.wrap(bytes).     ByteBuffer[] buffers = { message }.     assertNull(nettyAdaptor.pollOutboundOperation()).     nettyAdaptor.read(buffers).     assertFalse(tenIntsToStringsHandler.wasCalled).     FlushOperation flushOperation = nettyAdaptor.pollOutboundOperation().     assertNotNull(flushOperation).     assertEquals("FAILED", Unpooled.wrappedBuffer(flushOperation.getBuffersToWrite()).toString(StandardCharsets.UTF_8)).     assertFalse(promiseCheckerHandler.isCalled.get()).     flushOperation.getListener().accept(null, null).     assertTrue(promiseCheckerHandler.isCalled.get()). }
false;public;0;12;;public void testCloseListener() {     AtomicBoolean listenerCalled = new AtomicBoolean(false).     CloseChannelHandler handler = new CloseChannelHandler().     NettyAdaptor nettyAdaptor = new NettyAdaptor(handler).     byte[] bytes = "SHOULD_CLOSE".getBytes(StandardCharsets.UTF_8).     ByteBuffer[] buffers = { ByteBuffer.wrap(bytes) }.     nettyAdaptor.addCloseListener((v, e) -> listenerCalled.set(true)).     assertFalse(listenerCalled.get()).     nettyAdaptor.read(buffers).     assertTrue(listenerCalled.get()). }
false;protected;2;12;;@Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {     wasCalled = true.     if (msg.readableBytes() < 10 * 4) {         throw new IllegalStateException("Must have ten ints").     }     StringBuilder builder = new StringBuilder().     for (int i = 0. i < 10. ++i) {         builder.append(msg.readInt()).     }     result = builder.toString(). }
false;public;2;10;;@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {     ByteBuf buffer = (ByteBuf) msg.     String bufferString = buffer.toString(StandardCharsets.UTF_8).     if (bufferString.equals("SHOULD_WRITE")) {         ctx.writeAndFlush("Failed").     } else {         throw new IllegalArgumentException("Only accept SHOULD_WRITE message").     } }
false;public;3;6;;@Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {     String string = (String) msg.     assert string.equals("Failed") : "Should be the same was what we wrote.".     super.write(ctx, Unpooled.wrappedBuffer(string.toUpperCase(Locale.ROOT).getBytes(StandardCharsets.UTF_8)), promise). }
false;public;3;5;;@Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {     promise.addListener((f) -> isCalled.set(true)).     super.write(ctx, msg, promise). }
false;public;2;10;;@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {     ByteBuf buffer = (ByteBuf) msg.     String bufferString = buffer.toString(StandardCharsets.UTF_8).     if (bufferString.equals("SHOULD_CLOSE")) {         ctx.close().     } else {         throw new IllegalArgumentException("Only accept SHOULD_CLOSE message").     } }
