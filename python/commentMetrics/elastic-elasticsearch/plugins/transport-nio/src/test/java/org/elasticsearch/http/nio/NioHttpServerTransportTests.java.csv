commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void setup() throws Exception {     networkService = new NetworkService(Collections.emptyList()).     threadPool = new TestThreadPool("test").     pageRecycler = new MockPageCacheRecycler(Settings.EMPTY).     bigArrays = new MockBigArrays(pageRecycler, new NoneCircuitBreakerService()). }
false;public;0;9;;@After public void shutdown() throws Exception {     if (threadPool != null) {         threadPool.shutdownNow().     }     threadPool = null.     networkService = null.     bigArrays = null. }
false;public;0;16;;public void testCorsConfig() {     final Set<String> methods = new HashSet<>(Arrays.asList("get", "options", "post")).     final Set<String> headers = new HashSet<>(Arrays.asList("Content-Type", "Content-Length")).     // sometimes have a leading whitespace between comma delimited elements     final String prefix = randomBoolean() ? " " : "".     final Settings settings = Settings.builder().put(SETTING_CORS_ENABLED.getKey(), true).put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "*").put(SETTING_CORS_ALLOW_METHODS.getKey(), Strings.collectionToDelimitedString(methods, ",", prefix, "")).put(SETTING_CORS_ALLOW_HEADERS.getKey(), Strings.collectionToDelimitedString(headers, ",", prefix, "")).put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true).build().     final NioCorsConfig corsConfig = NioHttpServerTransport.buildCorsConfig(settings).     assertTrue(corsConfig.isAnyOriginSupported()).     assertEquals(headers, corsConfig.allowedRequestHeaders()).     assertEquals(methods, corsConfig.allowedRequestMethods().stream().map(HttpMethod::name).collect(Collectors.toSet())). }
false;public;0;13;;public void testCorsConfigWithDefaults() {     final Set<String> methods = Strings.commaDelimitedListToSet(SETTING_CORS_ALLOW_METHODS.getDefault(Settings.EMPTY)).     final Set<String> headers = Strings.commaDelimitedListToSet(SETTING_CORS_ALLOW_HEADERS.getDefault(Settings.EMPTY)).     final long maxAge = SETTING_CORS_MAX_AGE.getDefault(Settings.EMPTY).     final Settings settings = Settings.builder().put(SETTING_CORS_ENABLED.getKey(), true).build().     final NioCorsConfig corsConfig = NioHttpServerTransport.buildCorsConfig(settings).     assertFalse(corsConfig.isAnyOriginSupported()).     assertEquals(Collections.emptySet(), corsConfig.origins().get()).     assertEquals(headers, corsConfig.allowedRequestHeaders()).     assertEquals(methods, corsConfig.allowedRequestMethods().stream().map(HttpMethod::name).collect(Collectors.toSet())).     assertEquals(maxAge, corsConfig.maxAge()).     assertFalse(corsConfig.isCredentialsAllowed()). }
false;public;0;10;;public void testCorsConfigWithBadRegex() {     final Settings settings = Settings.builder().put(SETTING_CORS_ENABLED.getKey(), true).put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "/[*/").put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true).build().     SettingsException e = expectThrows(SettingsException.class, () -> NioHttpServerTransport.buildCorsConfig(settings)).     assertThat(e.getMessage(), containsString("Bad regex in [http.cors.allow-origin]: [/[*/]")).     assertThat(e.getCause(), instanceOf(PatternSyntaxException.class)). }
true;public;0;5;/**  * Test that {@link NioHttpServerTransport} supports the "Expect: 100-continue" HTTP header  * @throws InterruptedException if the client communication with the server is interrupted  */ ;/**  * Test that {@link NioHttpServerTransport} supports the "Expect: 100-continue" HTTP header  * @throws InterruptedException if the client communication with the server is interrupted  */ public void testExpectContinueHeader() throws InterruptedException {     final Settings settings = Settings.EMPTY.     final int contentLength = randomIntBetween(1, HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH.get(settings).bytesAsInt()).     runExpectHeaderTest(settings, HttpHeaderValues.CONTINUE.toString(), contentLength, HttpResponseStatus.CONTINUE). }
true;public;0;8;/**  * Test that {@link NioHttpServerTransport} responds to a  * 100-continue expectation with too large a content-length  * with a 413 status.  * @throws InterruptedException if the client communication with the server is interrupted  */ ;/**  * Test that {@link NioHttpServerTransport} responds to a  * 100-continue expectation with too large a content-length  * with a 413 status.  * @throws InterruptedException if the client communication with the server is interrupted  */ public void testExpectContinueHeaderContentLengthTooLong() throws InterruptedException {     final String key = HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH.getKey().     final int maxContentLength = randomIntBetween(1, 104857600).     final Settings settings = Settings.builder().put(key, maxContentLength + "b").build().     final int contentLength = randomIntBetween(maxContentLength + 1, Integer.MAX_VALUE).     runExpectHeaderTest(settings, HttpHeaderValues.CONTINUE.toString(), contentLength, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE). }
true;public;0;3;/**  * Test that {@link NioHttpServerTransport} responds to an unsupported expectation with a 417 status.  * @throws InterruptedException if the client communication with the server is interrupted  */ ;/**  * Test that {@link NioHttpServerTransport} responds to an unsupported expectation with a 417 status.  * @throws InterruptedException if the client communication with the server is interrupted  */ public void testExpectUnsupportedExpectation() throws InterruptedException {     runExpectHeaderTest(Settings.EMPTY, "chocolate=yummy", 0, HttpResponseStatus.EXPECTATION_FAILED). }
false;public;3;4;;@Override public void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext) {     channel.sendResponse(new BytesRestResponse(OK, BytesRestResponse.TEXT_CONTENT_TYPE, new BytesArray("done"))). }
false;public;4;4;;@Override public void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadContext threadContext, Throwable cause) {     throw new AssertionError(). }
false;private;4;47;;private void runExpectHeaderTest(final Settings settings, final String expectation, final int contentLength, final HttpResponseStatus expectedStatus) throws InterruptedException {     final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() {          @Override         public void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext) {             channel.sendResponse(new BytesRestResponse(OK, BytesRestResponse.TEXT_CONTENT_TYPE, new BytesArray("done"))).         }          @Override         public void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadContext threadContext, Throwable cause) {             throw new AssertionError().         }     }.     try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) {         transport.start().         final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses()).         try (NioHttpClient client = new NioHttpClient()) {             final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/").             request.headers().set(HttpHeaderNames.EXPECT, expectation).             HttpUtil.setContentLength(request, contentLength).             final FullHttpResponse response = client.post(remoteAddress.address(), request).             try {                 assertThat(response.status(), equalTo(expectedStatus)).                 if (expectedStatus.equals(HttpResponseStatus.CONTINUE)) {                     final FullHttpRequest continuationRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/", Unpooled.EMPTY_BUFFER).                     final FullHttpResponse continuationResponse = client.post(remoteAddress.address(), continuationRequest).                     try {                         assertThat(continuationResponse.status(), is(HttpResponseStatus.OK)).                         assertThat(new String(ByteBufUtil.getBytes(continuationResponse.content()), StandardCharsets.UTF_8), is("done")).                     } finally {                         continuationResponse.release().                     }                 }             } finally {                 response.release().             }         }     } }
false;public;0;13;;public void testBindUnavailableAddress() {     try (NioHttpServerTransport transport = new NioHttpServerTransport(Settings.EMPTY, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), new NullDispatcher(), new NioGroupFactory(Settings.EMPTY, logger))) {         transport.start().         TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses()).         Settings settings = Settings.builder().put("http.port", remoteAddress.getPort()).build().         try (NioHttpServerTransport otherTransport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), new NullDispatcher(), new NioGroupFactory(Settings.EMPTY, logger))) {             BindHttpException bindHttpException = expectThrows(BindHttpException.class, () -> otherTransport.start()).             assertEquals("Failed to bind to [" + remoteAddress.getPort() + "]", bindHttpException.getMessage()).         }     } }
false;public;3;4;;@Override public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) {     throw new AssertionError(). }
false;public;4;13;;@Override public void dispatchBadRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext, final Throwable cause) {     causeReference.set(cause).     try {         final ElasticsearchException e = new ElasticsearchException("you sent a bad request and you should feel bad").         channel.sendResponse(new BytesRestResponse(channel, BAD_REQUEST, e)).     } catch (final IOException e) {         throw new AssertionError(e).     } }
false;public;0;60;;public void testBadRequest() throws InterruptedException {     final AtomicReference<Throwable> causeReference = new AtomicReference<>().     final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() {          @Override         public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) {             throw new AssertionError().         }          @Override         public void dispatchBadRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext, final Throwable cause) {             causeReference.set(cause).             try {                 final ElasticsearchException e = new ElasticsearchException("you sent a bad request and you should feel bad").                 channel.sendResponse(new BytesRestResponse(channel, BAD_REQUEST, e)).             } catch (final IOException e) {                 throw new AssertionError(e).             }         }     }.     final Settings settings.     final int maxInitialLineLength.     final Setting<ByteSizeValue> httpMaxInitialLineLengthSetting = HttpTransportSettings.SETTING_HTTP_MAX_INITIAL_LINE_LENGTH.     if (randomBoolean()) {         maxInitialLineLength = httpMaxInitialLineLengthSetting.getDefault(Settings.EMPTY).bytesAsInt().         settings = Settings.EMPTY.     } else {         maxInitialLineLength = randomIntBetween(1, 8192).         settings = Settings.builder().put(httpMaxInitialLineLengthSetting.getKey(), maxInitialLineLength + "b").build().     }     try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) {         transport.start().         final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses()).         try (NioHttpClient client = new NioHttpClient()) {             final String url = "/" + new String(new byte[maxInitialLineLength], Charset.forName("UTF-8")).             final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, url).             final FullHttpResponse response = client.post(remoteAddress.address(), request).             try {                 assertThat(response.status(), equalTo(HttpResponseStatus.BAD_REQUEST)).                 assertThat(new String(response.content().array(), Charset.forName("UTF-8")), containsString("you sent a bad request and you should feel bad")).             } finally {                 response.release().             }         }     }     assertNotNull(causeReference.get()).     assertThat(causeReference.get(), instanceOf(TooLongFrameException.class)). }
