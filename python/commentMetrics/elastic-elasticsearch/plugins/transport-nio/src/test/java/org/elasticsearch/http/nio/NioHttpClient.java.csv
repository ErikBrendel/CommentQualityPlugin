commented;modifiers;parameterAmount;loc;comment;code
false;static;1;7;;static Collection<String> returnOpaqueIds(Collection<FullHttpResponse> responses) {     List<String> list = new ArrayList<>(responses.size()).     for (HttpResponse response : responses) {         list.add(response.headers().get(Task.X_OPAQUE_ID)).     }     return list. }
false;public;2;10;;public Collection<FullHttpResponse> get(InetSocketAddress remoteAddress, String... uris) throws InterruptedException {     Collection<HttpRequest> requests = new ArrayList<>(uris.length).     for (int i = 0. i < uris.length. i++) {         final HttpRequest httpRequest = new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, uris[i]).         httpRequest.headers().add(HOST, "localhost").         httpRequest.headers().add(Task.X_OPAQUE_ID, String.valueOf(i)).         requests.add(httpRequest).     }     return sendRequests(remoteAddress, requests). }
false;public,final;2;5;;public final FullHttpResponse post(InetSocketAddress remoteAddress, FullHttpRequest httpRequest) throws InterruptedException {     Collection<FullHttpResponse> responses = sendRequests(remoteAddress, Collections.singleton(httpRequest)).     assert responses.size() == 1 : "expected 1 and only 1 http response".     return responses.iterator().next(). }
false;private;1;3;;private void onException(Exception e) {     logger.error("Exception from http client", e). }
false;private,synchronized;2;31;;private synchronized Collection<FullHttpResponse> sendRequests(InetSocketAddress remoteAddress, Collection<HttpRequest> requests) throws InterruptedException {     final CountDownLatch latch = new CountDownLatch(requests.size()).     final Collection<FullHttpResponse> content = Collections.synchronizedList(new ArrayList<>(requests.size())).     ChannelFactory<NioServerSocketChannel, NioSocketChannel> factory = new ClientChannelFactory(latch, content).     NioSocketChannel nioSocketChannel = null.     try {         nioSocketChannel = nioGroup.openChannel(remoteAddress, factory).         PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture().         nioSocketChannel.addConnectListener(ActionListener.toBiConsumer(connectFuture)).         connectFuture.actionGet().         for (HttpRequest request : requests) {             nioSocketChannel.getContext().sendMessage(request, (v, e) -> {             }).         }         if (latch.await(30L, TimeUnit.SECONDS) == false) {             fail("Failed to get all expected responses.").         }     } catch (IOException e) {         throw new UncheckedIOException(e).     } finally {         if (nioSocketChannel != null) {             nioSocketChannel.close().         }     }     return content. }
false;public;0;4;;@Override public void close() {     IOUtils.closeWhileHandlingException(nioGroup::close). }
false;public;2;14;;@Override public NioSocketChannel createChannel(NioSelector selector, java.nio.channels.SocketChannel channel) throws IOException {     NioSocketChannel nioSocketChannel = new NioSocketChannel(channel).     HttpClientHandler handler = new HttpClientHandler(nioSocketChannel, latch, content).     Consumer<Exception> exceptionHandler = (e) -> {         latch.countDown().         onException(e).         nioSocketChannel.close().     }.     SocketChannelContext context = new BytesChannelContext(nioSocketChannel, selector, exceptionHandler, handler, InboundChannelBuffer.allocatingInstance()).     nioSocketChannel.setContext(context).     return nioSocketChannel. }
false;public;2;4;;@Override public NioServerSocketChannel createServerChannel(NioSelector selector, ServerSocketChannel channel) {     throw new UnsupportedOperationException("Cannot create server channel"). }
false;public;0;4;;@Override public BiConsumer<Void, Exception> getListener() {     return listener. }
false;public;0;4;;@Override public SocketChannelContext getChannel() {     return context. }
false;public;0;4;;@Override public Object getObject() {     return message. }
false;public;3;20;;@Override public WriteOperation createWriteOperation(SocketChannelContext context, Object message, BiConsumer<Void, Exception> listener) {     assert message instanceof HttpRequest : "Expected type HttpRequest.class, found: " + message.getClass().     return new WriteOperation() {          @Override         public BiConsumer<Void, Exception> getListener() {             return listener.         }          @Override         public SocketChannelContext getChannel() {             return context.         }          @Override         public Object getObject() {             return message.         }     }. }
false;public;1;5;;@Override public List<FlushOperation> writeToBytes(WriteOperation writeOperation) {     adaptor.write(writeOperation).     return pollFlushOperations(). }
false;public;0;9;;@Override public List<FlushOperation> pollFlushOperations() {     ArrayList<FlushOperation> copiedOperations = new ArrayList<>(adaptor.getOutboundCount()).     FlushOperation flushOperation.     while ((flushOperation = adaptor.pollOutboundOperation()) != null) {         copiedOperations.add(flushOperation).     }     return copiedOperations. }
false;public;1;10;;@Override public int consumeReads(InboundChannelBuffer channelBuffer) throws IOException {     int bytesConsumed = adaptor.read(channelBuffer.sliceAndRetainPagesTo(channelBuffer.getIndex())).     Object message.     while ((message = adaptor.pollInboundMessage()) != null) {         handleRequest(message).     }     return bytesConsumed. }
false;public;0;8;;@Override public void close() throws IOException {     try {         adaptor.close().     } catch (Exception e) {         throw new IOException(e).     } }
false;private;1;11;;private void handleRequest(Object message) {     final FullHttpResponse response = (FullHttpResponse) message.     DefaultFullHttpResponse newResponse = new DefaultFullHttpResponse(response.protocolVersion(), response.status(), Unpooled.copiedBuffer(response.content()), response.headers().copy(), response.trailingHeaders().copy()).     response.release().     content.add(newResponse).     latch.countDown(). }
