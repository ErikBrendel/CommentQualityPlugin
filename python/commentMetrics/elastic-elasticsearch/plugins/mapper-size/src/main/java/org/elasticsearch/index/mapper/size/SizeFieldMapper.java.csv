commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;5;;private static MappedFieldType defaultFieldType(Version indexCreated) {     MappedFieldType defaultFieldType = Defaults.SIZE_FIELD_TYPE.clone().     defaultFieldType.setHasDocValues(true).     return defaultFieldType. }
false;public;1;4;;public Builder enabled(EnabledAttributeMapper enabled) {     this.enabledState = enabled.     return builder. }
false;public;1;5;;@Override public SizeFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new SizeFieldMapper(enabledState, fieldType, context.indexSettings()). }
false;public;3;17;;@Override public MetadataFieldMapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder(parserContext.mapperService().fullName(NAME), parserContext.indexVersionCreated()).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String fieldName = entry.getKey().         Object fieldNode = entry.getValue().         if (fieldName.equals("enabled")) {             boolean enabled = XContentMapValues.nodeBooleanValue(fieldNode, name + ".enabled").             builder.enabled(enabled ? EnabledAttributeMapper.ENABLED : EnabledAttributeMapper.DISABLED).             iterator.remove().         }     }     return builder. }
false;public;2;5;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final Settings indexSettings = context.mapperService().getIndexSettings().getSettings().     return new SizeFieldMapper(indexSettings, fieldType). }
false;protected;0;4;;@Override protected String contentType() {     return NAME. }
false;public;0;3;;public boolean enabled() {     return this.enabledState.enabled. }
false;public;1;3;;@Override public void preParse(ParseContext context) throws IOException { }
false;public;1;5;;@Override public void postParse(ParseContext context) throws IOException {     // we post parse it so we get the size stored, possibly compressed (source will be preParse)     super.parse(context). }
false;public;1;4;;@Override public void parse(ParseContext context) throws IOException { // nothing to do here, we call the parent in postParse }
false;protected;2;11;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     if (!enabledState.enabled) {         return.     }     final int value = context.sourceToParse().source().length().     boolean indexed = fieldType().indexOptions() != IndexOptions.NONE.     boolean docValued = fieldType().hasDocValues().     boolean stored = fieldType().stored().     fields.addAll(NumberFieldMapper.NumberType.INTEGER.createFields(name(), value, indexed, docValued, stored)). }
false;public;2;15;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     boolean includeDefaults = params.paramAsBoolean("include_defaults", false).     // all are defaults, no need to write it at all     if (!includeDefaults && enabledState == Defaults.ENABLED_STATE) {         return builder.     }     builder.startObject(contentType()).     if (includeDefaults || enabledState != Defaults.ENABLED_STATE) {         builder.field("enabled", enabledState.enabled).     }     builder.endObject().     return builder. }
false;protected;1;7;;@Override protected void doMerge(Mapper mergeWith) {     SizeFieldMapper sizeFieldMapperMergeWith = (SizeFieldMapper) mergeWith.     if (sizeFieldMapperMergeWith.enabledState != enabledState && !sizeFieldMapperMergeWith.enabledState.unset()) {         this.enabledState = sizeFieldMapperMergeWith.enabledState.     } }
