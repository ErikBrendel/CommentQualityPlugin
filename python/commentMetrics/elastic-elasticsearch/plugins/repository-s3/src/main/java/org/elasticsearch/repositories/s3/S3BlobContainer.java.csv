# id;timestamp;commentText;codeText;commentWords;codeWords
S3BlobContainer -> static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize);1524684173;Returns the number parts of size of {@code partSize} needed to reach {@code totalSize},_along with the size of the last (or unique) part.__@param totalSize the total size_@param partSize  the part size_@return a {@link Tuple} containing the number of parts to fill {@code totalSize} and_the size of the last part;static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize) {_        if (partSize <= 0) {_            throw new IllegalArgumentException("Part size must be greater than zero")__        }__        if (totalSize == 0L || totalSize <= partSize) {_            return Tuple.tuple(1L, totalSize)__        }__        final long parts = totalSize / partSize__        final long remaining = totalSize % partSize___        if (remaining == 0) {_            return Tuple.tuple(parts, partSize)__        } else {_            return Tuple.tuple(parts + 1, remaining)__        }_    };returns,the,number,parts,of,size,of,code,part,size,needed,to,reach,code,total,size,along,with,the,size,of,the,last,or,unique,part,param,total,size,the,total,size,param,part,size,the,part,size,return,a,link,tuple,containing,the,number,of,parts,to,fill,code,total,size,and,the,size,of,the,last,part;static,tuple,long,long,number,of,multiparts,final,long,total,size,final,long,part,size,if,part,size,0,throw,new,illegal,argument,exception,part,size,must,be,greater,than,zero,if,total,size,0l,total,size,part,size,return,tuple,tuple,1l,total,size,final,long,parts,total,size,part,size,final,long,remaining,total,size,part,size,if,remaining,0,return,tuple,tuple,parts,part,size,else,return,tuple,tuple,parts,1,remaining
S3BlobContainer -> static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize);1528304883;Returns the number parts of size of {@code partSize} needed to reach {@code totalSize},_along with the size of the last (or unique) part.__@param totalSize the total size_@param partSize  the part size_@return a {@link Tuple} containing the number of parts to fill {@code totalSize} and_the size of the last part;static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize) {_        if (partSize <= 0) {_            throw new IllegalArgumentException("Part size must be greater than zero")__        }__        if (totalSize == 0L || totalSize <= partSize) {_            return Tuple.tuple(1L, totalSize)__        }__        final long parts = totalSize / partSize__        final long remaining = totalSize % partSize___        if (remaining == 0) {_            return Tuple.tuple(parts, partSize)__        } else {_            return Tuple.tuple(parts + 1, remaining)__        }_    };returns,the,number,parts,of,size,of,code,part,size,needed,to,reach,code,total,size,along,with,the,size,of,the,last,or,unique,part,param,total,size,the,total,size,param,part,size,the,part,size,return,a,link,tuple,containing,the,number,of,parts,to,fill,code,total,size,and,the,size,of,the,last,part;static,tuple,long,long,number,of,multiparts,final,long,total,size,final,long,part,size,if,part,size,0,throw,new,illegal,argument,exception,part,size,must,be,greater,than,zero,if,total,size,0l,total,size,part,size,return,tuple,tuple,1l,total,size,final,long,parts,total,size,part,size,final,long,remaining,total,size,part,size,if,remaining,0,return,tuple,tuple,parts,part,size,else,return,tuple,tuple,parts,1,remaining
S3BlobContainer -> static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize);1528706846;Returns the number parts of size of {@code partSize} needed to reach {@code totalSize},_along with the size of the last (or unique) part.__@param totalSize the total size_@param partSize  the part size_@return a {@link Tuple} containing the number of parts to fill {@code totalSize} and_the size of the last part;static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize) {_        if (partSize <= 0) {_            throw new IllegalArgumentException("Part size must be greater than zero")__        }__        if (totalSize == 0L || totalSize <= partSize) {_            return Tuple.tuple(1L, totalSize)__        }__        final long parts = totalSize / partSize__        final long remaining = totalSize % partSize___        if (remaining == 0) {_            return Tuple.tuple(parts, partSize)__        } else {_            return Tuple.tuple(parts + 1, remaining)__        }_    };returns,the,number,parts,of,size,of,code,part,size,needed,to,reach,code,total,size,along,with,the,size,of,the,last,or,unique,part,param,total,size,the,total,size,param,part,size,the,part,size,return,a,link,tuple,containing,the,number,of,parts,to,fill,code,total,size,and,the,size,of,the,last,part;static,tuple,long,long,number,of,multiparts,final,long,total,size,final,long,part,size,if,part,size,0,throw,new,illegal,argument,exception,part,size,must,be,greater,than,zero,if,total,size,0l,total,size,part,size,return,tuple,tuple,1l,total,size,final,long,parts,total,size,part,size,final,long,remaining,total,size,part,size,if,remaining,0,return,tuple,tuple,parts,part,size,else,return,tuple,tuple,parts,1,remaining
S3BlobContainer -> static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize);1528762805;Returns the number parts of size of {@code partSize} needed to reach {@code totalSize},_along with the size of the last (or unique) part.__@param totalSize the total size_@param partSize  the part size_@return a {@link Tuple} containing the number of parts to fill {@code totalSize} and_the size of the last part;static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize) {_        if (partSize <= 0) {_            throw new IllegalArgumentException("Part size must be greater than zero")__        }__        if (totalSize == 0L || totalSize <= partSize) {_            return Tuple.tuple(1L, totalSize)__        }__        final long parts = totalSize / partSize__        final long remaining = totalSize % partSize___        if (remaining == 0) {_            return Tuple.tuple(parts, partSize)__        } else {_            return Tuple.tuple(parts + 1, remaining)__        }_    };returns,the,number,parts,of,size,of,code,part,size,needed,to,reach,code,total,size,along,with,the,size,of,the,last,or,unique,part,param,total,size,the,total,size,param,part,size,the,part,size,return,a,link,tuple,containing,the,number,of,parts,to,fill,code,total,size,and,the,size,of,the,last,part;static,tuple,long,long,number,of,multiparts,final,long,total,size,final,long,part,size,if,part,size,0,throw,new,illegal,argument,exception,part,size,must,be,greater,than,zero,if,total,size,0l,total,size,part,size,return,tuple,tuple,1l,total,size,final,long,parts,total,size,part,size,final,long,remaining,total,size,part,size,if,remaining,0,return,tuple,tuple,parts,part,size,else,return,tuple,tuple,parts,1,remaining
S3BlobContainer -> static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize);1529341607;Returns the number parts of size of {@code partSize} needed to reach {@code totalSize},_along with the size of the last (or unique) part.__@param totalSize the total size_@param partSize  the part size_@return a {@link Tuple} containing the number of parts to fill {@code totalSize} and_the size of the last part;static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize) {_        if (partSize <= 0) {_            throw new IllegalArgumentException("Part size must be greater than zero")__        }__        if ((totalSize == 0L) || (totalSize <= partSize)) {_            return Tuple.tuple(1L, totalSize)__        }__        final long parts = totalSize / partSize__        final long remaining = totalSize % partSize___        if (remaining == 0) {_            return Tuple.tuple(parts, partSize)__        } else {_            return Tuple.tuple(parts + 1, remaining)__        }_    };returns,the,number,parts,of,size,of,code,part,size,needed,to,reach,code,total,size,along,with,the,size,of,the,last,or,unique,part,param,total,size,the,total,size,param,part,size,the,part,size,return,a,link,tuple,containing,the,number,of,parts,to,fill,code,total,size,and,the,size,of,the,last,part;static,tuple,long,long,number,of,multiparts,final,long,total,size,final,long,part,size,if,part,size,0,throw,new,illegal,argument,exception,part,size,must,be,greater,than,zero,if,total,size,0l,total,size,part,size,return,tuple,tuple,1l,total,size,final,long,parts,total,size,part,size,final,long,remaining,total,size,part,size,if,remaining,0,return,tuple,tuple,parts,part,size,else,return,tuple,tuple,parts,1,remaining
S3BlobContainer -> static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize);1531179852;Returns the number parts of size of {@code partSize} needed to reach {@code totalSize},_along with the size of the last (or unique) part.__@param totalSize the total size_@param partSize  the part size_@return a {@link Tuple} containing the number of parts to fill {@code totalSize} and_the size of the last part;static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize) {_        if (partSize <= 0) {_            throw new IllegalArgumentException("Part size must be greater than zero")__        }__        if ((totalSize == 0L) || (totalSize <= partSize)) {_            return Tuple.tuple(1L, totalSize)__        }__        final long parts = totalSize / partSize__        final long remaining = totalSize % partSize___        if (remaining == 0) {_            return Tuple.tuple(parts, partSize)__        } else {_            return Tuple.tuple(parts + 1, remaining)__        }_    };returns,the,number,parts,of,size,of,code,part,size,needed,to,reach,code,total,size,along,with,the,size,of,the,last,or,unique,part,param,total,size,the,total,size,param,part,size,the,part,size,return,a,link,tuple,containing,the,number,of,parts,to,fill,code,total,size,and,the,size,of,the,last,part;static,tuple,long,long,number,of,multiparts,final,long,total,size,final,long,part,size,if,part,size,0,throw,new,illegal,argument,exception,part,size,must,be,greater,than,zero,if,total,size,0l,total,size,part,size,return,tuple,tuple,1l,total,size,final,long,parts,total,size,part,size,final,long,remaining,total,size,part,size,if,remaining,0,return,tuple,tuple,parts,part,size,else,return,tuple,tuple,parts,1,remaining
S3BlobContainer -> static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize);1546859479;Returns the number parts of size of {@code partSize} needed to reach {@code totalSize},_along with the size of the last (or unique) part.__@param totalSize the total size_@param partSize  the part size_@return a {@link Tuple} containing the number of parts to fill {@code totalSize} and_the size of the last part;static Tuple<Long, Long> numberOfMultiparts(final long totalSize, final long partSize) {_        if (partSize <= 0) {_            throw new IllegalArgumentException("Part size must be greater than zero")__        }__        if ((totalSize == 0L) || (totalSize <= partSize)) {_            return Tuple.tuple(1L, totalSize)__        }__        final long parts = totalSize / partSize__        final long remaining = totalSize % partSize___        if (remaining == 0) {_            return Tuple.tuple(parts, partSize)__        } else {_            return Tuple.tuple(parts + 1, remaining)__        }_    };returns,the,number,parts,of,size,of,code,part,size,needed,to,reach,code,total,size,along,with,the,size,of,the,last,or,unique,part,param,total,size,the,total,size,param,part,size,the,part,size,return,a,link,tuple,containing,the,number,of,parts,to,fill,code,total,size,and,the,size,of,the,last,part;static,tuple,long,long,number,of,multiparts,final,long,total,size,final,long,part,size,if,part,size,0,throw,new,illegal,argument,exception,part,size,must,be,greater,than,zero,if,total,size,0l,total,size,part,size,return,tuple,tuple,1l,total,size,final,long,parts,total,size,part,size,final,long,remaining,total,size,part,size,if,remaining,0,return,tuple,tuple,parts,part,size,else,return,tuple,tuple,parts,1,remaining
S3BlobContainer -> void executeMultipartUpload(final S3BlobStore blobStore,                                 final String blobName,                                 final InputStream input,                                 final long blobSize) throws IOException;1524684173;Uploads a blob using multipart upload requests.;void executeMultipartUpload(final S3BlobStore blobStore,_                                final String blobName,_                                final InputStream input,_                                final long blobSize) throws IOException {__        if (blobSize > MAX_FILE_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                                + "] can't be larger than " + MAX_FILE_SIZE_USING_MULTIPART)__        }_        if (blobSize < MIN_PART_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                               + "] can't be smaller than " + MIN_PART_SIZE_USING_MULTIPART)__        }__        final long partSize = blobStore.bufferSizeInBytes()__        final Tuple<Long, Long> multiparts = numberOfMultiparts(blobSize, partSize)___        if (multiparts.v1() > Integer.MAX_VALUE) {_            throw new IllegalArgumentException("Too many multipart upload requests, maybe try a larger buffer size?")__        }__        final int nbParts = multiparts.v1().intValue()__        final long lastPartSize = multiparts.v2()__        assert blobSize == (nbParts - 1) * partSize + lastPartSize : "blobSize does not match multipart sizes"___        final SetOnce<String> uploadId = new SetOnce<>()__        final String bucketName = blobStore.bucket()__        boolean success = false___        try {_            final InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest(bucketName, blobName)__            initRequest.setStorageClass(blobStore.getStorageClass())__            initRequest.setCannedACL(blobStore.getCannedACL())__            if (blobStore.serverSideEncryption()) {_                final ObjectMetadata md = new ObjectMetadata()__                md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__                initRequest.setObjectMetadata(md)__            }__            uploadId.set(blobStore.client().initiateMultipartUpload(initRequest).getUploadId())__            if (Strings.isEmpty(uploadId.get())) {_                throw new IOException("Failed to initialize multipart upload " + blobName)__            }__            final List<PartETag> parts = new ArrayList<>()___            long bytesCount = 0__            for (int i = 1_ i <= nbParts_ i++) {_                final UploadPartRequest uploadRequest = new UploadPartRequest()__                uploadRequest.setBucketName(bucketName)__                uploadRequest.setKey(blobName)__                uploadRequest.setUploadId(uploadId.get())__                uploadRequest.setPartNumber(i)__                uploadRequest.setInputStream(input)___                if (i < nbParts) {_                    uploadRequest.setPartSize(partSize)__                    uploadRequest.setLastPart(false)__                } else {_                    uploadRequest.setPartSize(lastPartSize)__                    uploadRequest.setLastPart(true)__                }_                bytesCount += uploadRequest.getPartSize()___                final UploadPartResult uploadResponse = blobStore.client().uploadPart(uploadRequest)__                parts.add(uploadResponse.getPartETag())__            }__            if (bytesCount != blobSize) {_                throw new IOException("Failed to execute multipart upload for [" + blobName + "], expected " + blobSize_                    + "bytes sent but got " + bytesCount)__            }__            CompleteMultipartUploadRequest complRequest = new CompleteMultipartUploadRequest(bucketName, blobName, uploadId.get(), parts)__            blobStore.client().completeMultipartUpload(complRequest)__            success = true___        } catch (AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using multipart upload", e)__        } finally {_            if (success == false && Strings.hasLength(uploadId.get())) {_                final AbortMultipartUploadRequest abortRequest = new AbortMultipartUploadRequest(bucketName, blobName, uploadId.get())__                blobStore.client().abortMultipartUpload(abortRequest)__            }_        }_    };uploads,a,blob,using,multipart,upload,requests;void,execute,multipart,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,smaller,than,final,long,part,size,blob,store,buffer,size,in,bytes,final,tuple,long,long,multiparts,number,of,multiparts,blob,size,part,size,if,multiparts,v1,integer,throw,new,illegal,argument,exception,too,many,multipart,upload,requests,maybe,try,a,larger,buffer,size,final,int,nb,parts,multiparts,v1,int,value,final,long,last,part,size,multiparts,v2,assert,blob,size,nb,parts,1,part,size,last,part,size,blob,size,does,not,match,multipart,sizes,final,set,once,string,upload,id,new,set,once,final,string,bucket,name,blob,store,bucket,boolean,success,false,try,final,initiate,multipart,upload,request,init,request,new,initiate,multipart,upload,request,bucket,name,blob,name,init,request,set,storage,class,blob,store,get,storage,class,init,request,set,canned,acl,blob,store,get,canned,acl,if,blob,store,server,side,encryption,final,object,metadata,md,new,object,metadata,md,set,ssealgorithm,object,metadata,init,request,set,object,metadata,md,upload,id,set,blob,store,client,initiate,multipart,upload,init,request,get,upload,id,if,strings,is,empty,upload,id,get,throw,new,ioexception,failed,to,initialize,multipart,upload,blob,name,final,list,part,etag,parts,new,array,list,long,bytes,count,0,for,int,i,1,i,nb,parts,i,final,upload,part,request,upload,request,new,upload,part,request,upload,request,set,bucket,name,bucket,name,upload,request,set,key,blob,name,upload,request,set,upload,id,upload,id,get,upload,request,set,part,number,i,upload,request,set,input,stream,input,if,i,nb,parts,upload,request,set,part,size,part,size,upload,request,set,last,part,false,else,upload,request,set,part,size,last,part,size,upload,request,set,last,part,true,bytes,count,upload,request,get,part,size,final,upload,part,result,upload,response,blob,store,client,upload,part,upload,request,parts,add,upload,response,get,part,etag,if,bytes,count,blob,size,throw,new,ioexception,failed,to,execute,multipart,upload,for,blob,name,expected,blob,size,bytes,sent,but,got,bytes,count,complete,multipart,upload,request,compl,request,new,complete,multipart,upload,request,bucket,name,blob,name,upload,id,get,parts,blob,store,client,complete,multipart,upload,compl,request,success,true,catch,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,multipart,upload,e,finally,if,success,false,strings,has,length,upload,id,get,final,abort,multipart,upload,request,abort,request,new,abort,multipart,upload,request,bucket,name,blob,name,upload,id,get,blob,store,client,abort,multipart,upload,abort,request
S3BlobContainer -> void executeMultipartUpload(final S3BlobStore blobStore,                                 final String blobName,                                 final InputStream input,                                 final long blobSize) throws IOException;1528304883;Uploads a blob using multipart upload requests.;void executeMultipartUpload(final S3BlobStore blobStore,_                                final String blobName,_                                final InputStream input,_                                final long blobSize) throws IOException {__        if (blobSize > MAX_FILE_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                                + "] can't be larger than " + MAX_FILE_SIZE_USING_MULTIPART)__        }_        if (blobSize < MIN_PART_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                               + "] can't be smaller than " + MIN_PART_SIZE_USING_MULTIPART)__        }__        final long partSize = blobStore.bufferSizeInBytes()__        final Tuple<Long, Long> multiparts = numberOfMultiparts(blobSize, partSize)___        if (multiparts.v1() > Integer.MAX_VALUE) {_            throw new IllegalArgumentException("Too many multipart upload requests, maybe try a larger buffer size?")__        }__        final int nbParts = multiparts.v1().intValue()__        final long lastPartSize = multiparts.v2()__        assert blobSize == (nbParts - 1) * partSize + lastPartSize : "blobSize does not match multipart sizes"___        final SetOnce<String> uploadId = new SetOnce<>()__        final String bucketName = blobStore.bucket()__        boolean success = false___        try {_            final InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest(bucketName, blobName)__            initRequest.setStorageClass(blobStore.getStorageClass())__            initRequest.setCannedACL(blobStore.getCannedACL())__            if (blobStore.serverSideEncryption()) {_                final ObjectMetadata md = new ObjectMetadata()__                md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__                initRequest.setObjectMetadata(md)__            }__            uploadId.set(blobStore.client().initiateMultipartUpload(initRequest).getUploadId())__            if (Strings.isEmpty(uploadId.get())) {_                throw new IOException("Failed to initialize multipart upload " + blobName)__            }__            final List<PartETag> parts = new ArrayList<>()___            long bytesCount = 0__            for (int i = 1_ i <= nbParts_ i++) {_                final UploadPartRequest uploadRequest = new UploadPartRequest()__                uploadRequest.setBucketName(bucketName)__                uploadRequest.setKey(blobName)__                uploadRequest.setUploadId(uploadId.get())__                uploadRequest.setPartNumber(i)__                uploadRequest.setInputStream(input)___                if (i < nbParts) {_                    uploadRequest.setPartSize(partSize)__                    uploadRequest.setLastPart(false)__                } else {_                    uploadRequest.setPartSize(lastPartSize)__                    uploadRequest.setLastPart(true)__                }_                bytesCount += uploadRequest.getPartSize()___                final UploadPartResult uploadResponse = blobStore.client().uploadPart(uploadRequest)__                parts.add(uploadResponse.getPartETag())__            }__            if (bytesCount != blobSize) {_                throw new IOException("Failed to execute multipart upload for [" + blobName + "], expected " + blobSize_                    + "bytes sent but got " + bytesCount)__            }__            CompleteMultipartUploadRequest complRequest = new CompleteMultipartUploadRequest(bucketName, blobName, uploadId.get(), parts)__            blobStore.client().completeMultipartUpload(complRequest)__            success = true___        } catch (AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using multipart upload", e)__        } finally {_            if (success == false && Strings.hasLength(uploadId.get())) {_                final AbortMultipartUploadRequest abortRequest = new AbortMultipartUploadRequest(bucketName, blobName, uploadId.get())__                blobStore.client().abortMultipartUpload(abortRequest)__            }_        }_    };uploads,a,blob,using,multipart,upload,requests;void,execute,multipart,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,smaller,than,final,long,part,size,blob,store,buffer,size,in,bytes,final,tuple,long,long,multiparts,number,of,multiparts,blob,size,part,size,if,multiparts,v1,integer,throw,new,illegal,argument,exception,too,many,multipart,upload,requests,maybe,try,a,larger,buffer,size,final,int,nb,parts,multiparts,v1,int,value,final,long,last,part,size,multiparts,v2,assert,blob,size,nb,parts,1,part,size,last,part,size,blob,size,does,not,match,multipart,sizes,final,set,once,string,upload,id,new,set,once,final,string,bucket,name,blob,store,bucket,boolean,success,false,try,final,initiate,multipart,upload,request,init,request,new,initiate,multipart,upload,request,bucket,name,blob,name,init,request,set,storage,class,blob,store,get,storage,class,init,request,set,canned,acl,blob,store,get,canned,acl,if,blob,store,server,side,encryption,final,object,metadata,md,new,object,metadata,md,set,ssealgorithm,object,metadata,init,request,set,object,metadata,md,upload,id,set,blob,store,client,initiate,multipart,upload,init,request,get,upload,id,if,strings,is,empty,upload,id,get,throw,new,ioexception,failed,to,initialize,multipart,upload,blob,name,final,list,part,etag,parts,new,array,list,long,bytes,count,0,for,int,i,1,i,nb,parts,i,final,upload,part,request,upload,request,new,upload,part,request,upload,request,set,bucket,name,bucket,name,upload,request,set,key,blob,name,upload,request,set,upload,id,upload,id,get,upload,request,set,part,number,i,upload,request,set,input,stream,input,if,i,nb,parts,upload,request,set,part,size,part,size,upload,request,set,last,part,false,else,upload,request,set,part,size,last,part,size,upload,request,set,last,part,true,bytes,count,upload,request,get,part,size,final,upload,part,result,upload,response,blob,store,client,upload,part,upload,request,parts,add,upload,response,get,part,etag,if,bytes,count,blob,size,throw,new,ioexception,failed,to,execute,multipart,upload,for,blob,name,expected,blob,size,bytes,sent,but,got,bytes,count,complete,multipart,upload,request,compl,request,new,complete,multipart,upload,request,bucket,name,blob,name,upload,id,get,parts,blob,store,client,complete,multipart,upload,compl,request,success,true,catch,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,multipart,upload,e,finally,if,success,false,strings,has,length,upload,id,get,final,abort,multipart,upload,request,abort,request,new,abort,multipart,upload,request,bucket,name,blob,name,upload,id,get,blob,store,client,abort,multipart,upload,abort,request
S3BlobContainer -> void executeMultipartUpload(final S3BlobStore blobStore,                                 final String blobName,                                 final InputStream input,                                 final long blobSize) throws IOException;1528706846;Uploads a blob using multipart upload requests.;void executeMultipartUpload(final S3BlobStore blobStore,_                                final String blobName,_                                final InputStream input,_                                final long blobSize) throws IOException {__        if (blobSize > MAX_FILE_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                                + "] can't be larger than " + MAX_FILE_SIZE_USING_MULTIPART)__        }_        if (blobSize < MIN_PART_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                               + "] can't be smaller than " + MIN_PART_SIZE_USING_MULTIPART)__        }__        final long partSize = blobStore.bufferSizeInBytes()__        final Tuple<Long, Long> multiparts = numberOfMultiparts(blobSize, partSize)___        if (multiparts.v1() > Integer.MAX_VALUE) {_            throw new IllegalArgumentException("Too many multipart upload requests, maybe try a larger buffer size?")__        }__        final int nbParts = multiparts.v1().intValue()__        final long lastPartSize = multiparts.v2()__        assert blobSize == (nbParts - 1) * partSize + lastPartSize : "blobSize does not match multipart sizes"___        final SetOnce<String> uploadId = new SetOnce<>()__        final String bucketName = blobStore.bucket()__        boolean success = false___        try {_            final InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest(bucketName, blobName)__            initRequest.setStorageClass(blobStore.getStorageClass())__            initRequest.setCannedACL(blobStore.getCannedACL())__            if (blobStore.serverSideEncryption()) {_                final ObjectMetadata md = new ObjectMetadata()__                md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__                initRequest.setObjectMetadata(md)__            }__            uploadId.set(blobStore.client().initiateMultipartUpload(initRequest).getUploadId())__            if (Strings.isEmpty(uploadId.get())) {_                throw new IOException("Failed to initialize multipart upload " + blobName)__            }__            final List<PartETag> parts = new ArrayList<>()___            long bytesCount = 0__            for (int i = 1_ i <= nbParts_ i++) {_                final UploadPartRequest uploadRequest = new UploadPartRequest()__                uploadRequest.setBucketName(bucketName)__                uploadRequest.setKey(blobName)__                uploadRequest.setUploadId(uploadId.get())__                uploadRequest.setPartNumber(i)__                uploadRequest.setInputStream(input)___                if (i < nbParts) {_                    uploadRequest.setPartSize(partSize)__                    uploadRequest.setLastPart(false)__                } else {_                    uploadRequest.setPartSize(lastPartSize)__                    uploadRequest.setLastPart(true)__                }_                bytesCount += uploadRequest.getPartSize()___                final UploadPartResult uploadResponse = blobStore.client().uploadPart(uploadRequest)__                parts.add(uploadResponse.getPartETag())__            }__            if (bytesCount != blobSize) {_                throw new IOException("Failed to execute multipart upload for [" + blobName + "], expected " + blobSize_                    + "bytes sent but got " + bytesCount)__            }__            CompleteMultipartUploadRequest complRequest = new CompleteMultipartUploadRequest(bucketName, blobName, uploadId.get(), parts)__            blobStore.client().completeMultipartUpload(complRequest)__            success = true___        } catch (AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using multipart upload", e)__        } finally {_            if (success == false && Strings.hasLength(uploadId.get())) {_                final AbortMultipartUploadRequest abortRequest = new AbortMultipartUploadRequest(bucketName, blobName, uploadId.get())__                blobStore.client().abortMultipartUpload(abortRequest)__            }_        }_    };uploads,a,blob,using,multipart,upload,requests;void,execute,multipart,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,smaller,than,final,long,part,size,blob,store,buffer,size,in,bytes,final,tuple,long,long,multiparts,number,of,multiparts,blob,size,part,size,if,multiparts,v1,integer,throw,new,illegal,argument,exception,too,many,multipart,upload,requests,maybe,try,a,larger,buffer,size,final,int,nb,parts,multiparts,v1,int,value,final,long,last,part,size,multiparts,v2,assert,blob,size,nb,parts,1,part,size,last,part,size,blob,size,does,not,match,multipart,sizes,final,set,once,string,upload,id,new,set,once,final,string,bucket,name,blob,store,bucket,boolean,success,false,try,final,initiate,multipart,upload,request,init,request,new,initiate,multipart,upload,request,bucket,name,blob,name,init,request,set,storage,class,blob,store,get,storage,class,init,request,set,canned,acl,blob,store,get,canned,acl,if,blob,store,server,side,encryption,final,object,metadata,md,new,object,metadata,md,set,ssealgorithm,object,metadata,init,request,set,object,metadata,md,upload,id,set,blob,store,client,initiate,multipart,upload,init,request,get,upload,id,if,strings,is,empty,upload,id,get,throw,new,ioexception,failed,to,initialize,multipart,upload,blob,name,final,list,part,etag,parts,new,array,list,long,bytes,count,0,for,int,i,1,i,nb,parts,i,final,upload,part,request,upload,request,new,upload,part,request,upload,request,set,bucket,name,bucket,name,upload,request,set,key,blob,name,upload,request,set,upload,id,upload,id,get,upload,request,set,part,number,i,upload,request,set,input,stream,input,if,i,nb,parts,upload,request,set,part,size,part,size,upload,request,set,last,part,false,else,upload,request,set,part,size,last,part,size,upload,request,set,last,part,true,bytes,count,upload,request,get,part,size,final,upload,part,result,upload,response,blob,store,client,upload,part,upload,request,parts,add,upload,response,get,part,etag,if,bytes,count,blob,size,throw,new,ioexception,failed,to,execute,multipart,upload,for,blob,name,expected,blob,size,bytes,sent,but,got,bytes,count,complete,multipart,upload,request,compl,request,new,complete,multipart,upload,request,bucket,name,blob,name,upload,id,get,parts,blob,store,client,complete,multipart,upload,compl,request,success,true,catch,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,multipart,upload,e,finally,if,success,false,strings,has,length,upload,id,get,final,abort,multipart,upload,request,abort,request,new,abort,multipart,upload,request,bucket,name,blob,name,upload,id,get,blob,store,client,abort,multipart,upload,abort,request
S3BlobContainer -> void executeMultipartUpload(final S3BlobStore blobStore,                                 final String blobName,                                 final InputStream input,                                 final long blobSize) throws IOException;1528762805;Uploads a blob using multipart upload requests.;void executeMultipartUpload(final S3BlobStore blobStore,_                                final String blobName,_                                final InputStream input,_                                final long blobSize) throws IOException {__        if (blobSize > MAX_FILE_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                                + "] can't be larger than " + MAX_FILE_SIZE_USING_MULTIPART)__        }_        if (blobSize < MIN_PART_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                               + "] can't be smaller than " + MIN_PART_SIZE_USING_MULTIPART)__        }__        final long partSize = blobStore.bufferSizeInBytes()__        final Tuple<Long, Long> multiparts = numberOfMultiparts(blobSize, partSize)___        if (multiparts.v1() > Integer.MAX_VALUE) {_            throw new IllegalArgumentException("Too many multipart upload requests, maybe try a larger buffer size?")__        }__        final int nbParts = multiparts.v1().intValue()__        final long lastPartSize = multiparts.v2()__        assert blobSize == (nbParts - 1) * partSize + lastPartSize : "blobSize does not match multipart sizes"___        final SetOnce<String> uploadId = new SetOnce<>()__        final String bucketName = blobStore.bucket()__        boolean success = false___        try {_            final InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest(bucketName, blobName)__            initRequest.setStorageClass(blobStore.getStorageClass())__            initRequest.setCannedACL(blobStore.getCannedACL())__            if (blobStore.serverSideEncryption()) {_                final ObjectMetadata md = new ObjectMetadata()__                md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__                initRequest.setObjectMetadata(md)__            }__            uploadId.set(blobStore.client().initiateMultipartUpload(initRequest).getUploadId())__            if (Strings.isEmpty(uploadId.get())) {_                throw new IOException("Failed to initialize multipart upload " + blobName)__            }__            final List<PartETag> parts = new ArrayList<>()___            long bytesCount = 0__            for (int i = 1_ i <= nbParts_ i++) {_                final UploadPartRequest uploadRequest = new UploadPartRequest()__                uploadRequest.setBucketName(bucketName)__                uploadRequest.setKey(blobName)__                uploadRequest.setUploadId(uploadId.get())__                uploadRequest.setPartNumber(i)__                uploadRequest.setInputStream(input)___                if (i < nbParts) {_                    uploadRequest.setPartSize(partSize)__                    uploadRequest.setLastPart(false)__                } else {_                    uploadRequest.setPartSize(lastPartSize)__                    uploadRequest.setLastPart(true)__                }_                bytesCount += uploadRequest.getPartSize()___                final UploadPartResult uploadResponse = blobStore.client().uploadPart(uploadRequest)__                parts.add(uploadResponse.getPartETag())__            }__            if (bytesCount != blobSize) {_                throw new IOException("Failed to execute multipart upload for [" + blobName + "], expected " + blobSize_                    + "bytes sent but got " + bytesCount)__            }__            CompleteMultipartUploadRequest complRequest = new CompleteMultipartUploadRequest(bucketName, blobName, uploadId.get(), parts)__            blobStore.client().completeMultipartUpload(complRequest)__            success = true___        } catch (AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using multipart upload", e)__        } finally {_            if (success == false && Strings.hasLength(uploadId.get())) {_                final AbortMultipartUploadRequest abortRequest = new AbortMultipartUploadRequest(bucketName, blobName, uploadId.get())__                blobStore.client().abortMultipartUpload(abortRequest)__            }_        }_    };uploads,a,blob,using,multipart,upload,requests;void,execute,multipart,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,smaller,than,final,long,part,size,blob,store,buffer,size,in,bytes,final,tuple,long,long,multiparts,number,of,multiparts,blob,size,part,size,if,multiparts,v1,integer,throw,new,illegal,argument,exception,too,many,multipart,upload,requests,maybe,try,a,larger,buffer,size,final,int,nb,parts,multiparts,v1,int,value,final,long,last,part,size,multiparts,v2,assert,blob,size,nb,parts,1,part,size,last,part,size,blob,size,does,not,match,multipart,sizes,final,set,once,string,upload,id,new,set,once,final,string,bucket,name,blob,store,bucket,boolean,success,false,try,final,initiate,multipart,upload,request,init,request,new,initiate,multipart,upload,request,bucket,name,blob,name,init,request,set,storage,class,blob,store,get,storage,class,init,request,set,canned,acl,blob,store,get,canned,acl,if,blob,store,server,side,encryption,final,object,metadata,md,new,object,metadata,md,set,ssealgorithm,object,metadata,init,request,set,object,metadata,md,upload,id,set,blob,store,client,initiate,multipart,upload,init,request,get,upload,id,if,strings,is,empty,upload,id,get,throw,new,ioexception,failed,to,initialize,multipart,upload,blob,name,final,list,part,etag,parts,new,array,list,long,bytes,count,0,for,int,i,1,i,nb,parts,i,final,upload,part,request,upload,request,new,upload,part,request,upload,request,set,bucket,name,bucket,name,upload,request,set,key,blob,name,upload,request,set,upload,id,upload,id,get,upload,request,set,part,number,i,upload,request,set,input,stream,input,if,i,nb,parts,upload,request,set,part,size,part,size,upload,request,set,last,part,false,else,upload,request,set,part,size,last,part,size,upload,request,set,last,part,true,bytes,count,upload,request,get,part,size,final,upload,part,result,upload,response,blob,store,client,upload,part,upload,request,parts,add,upload,response,get,part,etag,if,bytes,count,blob,size,throw,new,ioexception,failed,to,execute,multipart,upload,for,blob,name,expected,blob,size,bytes,sent,but,got,bytes,count,complete,multipart,upload,request,compl,request,new,complete,multipart,upload,request,bucket,name,blob,name,upload,id,get,parts,blob,store,client,complete,multipart,upload,compl,request,success,true,catch,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,multipart,upload,e,finally,if,success,false,strings,has,length,upload,id,get,final,abort,multipart,upload,request,abort,request,new,abort,multipart,upload,request,bucket,name,blob,name,upload,id,get,blob,store,client,abort,multipart,upload,abort,request
S3BlobContainer -> void executeMultipartUpload(final S3BlobStore blobStore,                                 final String blobName,                                 final InputStream input,                                 final long blobSize) throws IOException;1529341607;Uploads a blob using multipart upload requests.;void executeMultipartUpload(final S3BlobStore blobStore,_                                final String blobName,_                                final InputStream input,_                                final long blobSize) throws IOException {__        if (blobSize > MAX_FILE_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                                + "] can't be larger than " + MAX_FILE_SIZE_USING_MULTIPART)__        }_        if (blobSize < MIN_PART_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                               + "] can't be smaller than " + MIN_PART_SIZE_USING_MULTIPART)__        }__        final long partSize = blobStore.bufferSizeInBytes()__        final Tuple<Long, Long> multiparts = numberOfMultiparts(blobSize, partSize)___        if (multiparts.v1() > Integer.MAX_VALUE) {_            throw new IllegalArgumentException("Too many multipart upload requests, maybe try a larger buffer size?")__        }__        final int nbParts = multiparts.v1().intValue()__        final long lastPartSize = multiparts.v2()__        assert blobSize == (((nbParts - 1) * partSize) + lastPartSize) : "blobSize does not match multipart sizes"___        final SetOnce<String> uploadId = new SetOnce<>()__        final String bucketName = blobStore.bucket()__        boolean success = false___        final InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest(bucketName, blobName)__        initRequest.setStorageClass(blobStore.getStorageClass())__        initRequest.setCannedACL(blobStore.getCannedACL())__        if (blobStore.serverSideEncryption()) {_            final ObjectMetadata md = new ObjectMetadata()__            md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__            initRequest.setObjectMetadata(md)__        }_        try (AmazonS3Reference clientReference = blobStore.clientReference()) {__            uploadId.set(SocketAccess.doPrivileged(() -> clientReference.client().initiateMultipartUpload(initRequest).getUploadId()))__            if (Strings.isEmpty(uploadId.get())) {_                throw new IOException("Failed to initialize multipart upload " + blobName)__            }__            final List<PartETag> parts = new ArrayList<>()___            long bytesCount = 0__            for (int i = 1_ i <= nbParts_ i++) {_                final UploadPartRequest uploadRequest = new UploadPartRequest()__                uploadRequest.setBucketName(bucketName)__                uploadRequest.setKey(blobName)__                uploadRequest.setUploadId(uploadId.get())__                uploadRequest.setPartNumber(i)__                uploadRequest.setInputStream(input)___                if (i < nbParts) {_                    uploadRequest.setPartSize(partSize)__                    uploadRequest.setLastPart(false)__                } else {_                    uploadRequest.setPartSize(lastPartSize)__                    uploadRequest.setLastPart(true)__                }_                bytesCount += uploadRequest.getPartSize()___                final UploadPartResult uploadResponse = SocketAccess.doPrivileged(() -> clientReference.client().uploadPart(uploadRequest))__                parts.add(uploadResponse.getPartETag())__            }__            if (bytesCount != blobSize) {_                throw new IOException("Failed to execute multipart upload for [" + blobName + "], expected " + blobSize_                    + "bytes sent but got " + bytesCount)__            }__            final CompleteMultipartUploadRequest complRequest = new CompleteMultipartUploadRequest(bucketName, blobName, uploadId.get(),_                    parts)__            SocketAccess.doPrivilegedVoid(() -> clientReference.client().completeMultipartUpload(complRequest))__            success = true___        } catch (final AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using multipart upload", e)__        } finally {_            if ((success == false) && Strings.hasLength(uploadId.get())) {_                final AbortMultipartUploadRequest abortRequest = new AbortMultipartUploadRequest(bucketName, blobName, uploadId.get())__                try (AmazonS3Reference clientReference = blobStore.clientReference()) {_                    SocketAccess.doPrivilegedVoid(() -> clientReference.client().abortMultipartUpload(abortRequest))__                }_            }_        }_    };uploads,a,blob,using,multipart,upload,requests;void,execute,multipart,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,smaller,than,final,long,part,size,blob,store,buffer,size,in,bytes,final,tuple,long,long,multiparts,number,of,multiparts,blob,size,part,size,if,multiparts,v1,integer,throw,new,illegal,argument,exception,too,many,multipart,upload,requests,maybe,try,a,larger,buffer,size,final,int,nb,parts,multiparts,v1,int,value,final,long,last,part,size,multiparts,v2,assert,blob,size,nb,parts,1,part,size,last,part,size,blob,size,does,not,match,multipart,sizes,final,set,once,string,upload,id,new,set,once,final,string,bucket,name,blob,store,bucket,boolean,success,false,final,initiate,multipart,upload,request,init,request,new,initiate,multipart,upload,request,bucket,name,blob,name,init,request,set,storage,class,blob,store,get,storage,class,init,request,set,canned,acl,blob,store,get,canned,acl,if,blob,store,server,side,encryption,final,object,metadata,md,new,object,metadata,md,set,ssealgorithm,object,metadata,init,request,set,object,metadata,md,try,amazon,s3reference,client,reference,blob,store,client,reference,upload,id,set,socket,access,do,privileged,client,reference,client,initiate,multipart,upload,init,request,get,upload,id,if,strings,is,empty,upload,id,get,throw,new,ioexception,failed,to,initialize,multipart,upload,blob,name,final,list,part,etag,parts,new,array,list,long,bytes,count,0,for,int,i,1,i,nb,parts,i,final,upload,part,request,upload,request,new,upload,part,request,upload,request,set,bucket,name,bucket,name,upload,request,set,key,blob,name,upload,request,set,upload,id,upload,id,get,upload,request,set,part,number,i,upload,request,set,input,stream,input,if,i,nb,parts,upload,request,set,part,size,part,size,upload,request,set,last,part,false,else,upload,request,set,part,size,last,part,size,upload,request,set,last,part,true,bytes,count,upload,request,get,part,size,final,upload,part,result,upload,response,socket,access,do,privileged,client,reference,client,upload,part,upload,request,parts,add,upload,response,get,part,etag,if,bytes,count,blob,size,throw,new,ioexception,failed,to,execute,multipart,upload,for,blob,name,expected,blob,size,bytes,sent,but,got,bytes,count,final,complete,multipart,upload,request,compl,request,new,complete,multipart,upload,request,bucket,name,blob,name,upload,id,get,parts,socket,access,do,privileged,void,client,reference,client,complete,multipart,upload,compl,request,success,true,catch,final,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,multipart,upload,e,finally,if,success,false,strings,has,length,upload,id,get,final,abort,multipart,upload,request,abort,request,new,abort,multipart,upload,request,bucket,name,blob,name,upload,id,get,try,amazon,s3reference,client,reference,blob,store,client,reference,socket,access,do,privileged,void,client,reference,client,abort,multipart,upload,abort,request
S3BlobContainer -> void executeMultipartUpload(final S3BlobStore blobStore,                                 final String blobName,                                 final InputStream input,                                 final long blobSize) throws IOException;1531179852;Uploads a blob using multipart upload requests.;void executeMultipartUpload(final S3BlobStore blobStore,_                                final String blobName,_                                final InputStream input,_                                final long blobSize) throws IOException {__        if (blobSize > MAX_FILE_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                                + "] can't be larger than " + MAX_FILE_SIZE_USING_MULTIPART)__        }_        if (blobSize < MIN_PART_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                               + "] can't be smaller than " + MIN_PART_SIZE_USING_MULTIPART)__        }__        final long partSize = blobStore.bufferSizeInBytes()__        final Tuple<Long, Long> multiparts = numberOfMultiparts(blobSize, partSize)___        if (multiparts.v1() > Integer.MAX_VALUE) {_            throw new IllegalArgumentException("Too many multipart upload requests, maybe try a larger buffer size?")__        }__        final int nbParts = multiparts.v1().intValue()__        final long lastPartSize = multiparts.v2()__        assert blobSize == (((nbParts - 1) * partSize) + lastPartSize) : "blobSize does not match multipart sizes"___        final SetOnce<String> uploadId = new SetOnce<>()__        final String bucketName = blobStore.bucket()__        boolean success = false___        final InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest(bucketName, blobName)__        initRequest.setStorageClass(blobStore.getStorageClass())__        initRequest.setCannedACL(blobStore.getCannedACL())__        if (blobStore.serverSideEncryption()) {_            final ObjectMetadata md = new ObjectMetadata()__            md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__            initRequest.setObjectMetadata(md)__        }_        try (AmazonS3Reference clientReference = blobStore.clientReference()) {__            uploadId.set(SocketAccess.doPrivileged(() -> clientReference.client().initiateMultipartUpload(initRequest).getUploadId()))__            if (Strings.isEmpty(uploadId.get())) {_                throw new IOException("Failed to initialize multipart upload " + blobName)__            }__            final List<PartETag> parts = new ArrayList<>()___            long bytesCount = 0__            for (int i = 1_ i <= nbParts_ i++) {_                final UploadPartRequest uploadRequest = new UploadPartRequest()__                uploadRequest.setBucketName(bucketName)__                uploadRequest.setKey(blobName)__                uploadRequest.setUploadId(uploadId.get())__                uploadRequest.setPartNumber(i)__                uploadRequest.setInputStream(input)___                if (i < nbParts) {_                    uploadRequest.setPartSize(partSize)__                    uploadRequest.setLastPart(false)__                } else {_                    uploadRequest.setPartSize(lastPartSize)__                    uploadRequest.setLastPart(true)__                }_                bytesCount += uploadRequest.getPartSize()___                final UploadPartResult uploadResponse = SocketAccess.doPrivileged(() -> clientReference.client().uploadPart(uploadRequest))__                parts.add(uploadResponse.getPartETag())__            }__            if (bytesCount != blobSize) {_                throw new IOException("Failed to execute multipart upload for [" + blobName + "], expected " + blobSize_                    + "bytes sent but got " + bytesCount)__            }__            final CompleteMultipartUploadRequest complRequest = new CompleteMultipartUploadRequest(bucketName, blobName, uploadId.get(),_                    parts)__            SocketAccess.doPrivilegedVoid(() -> clientReference.client().completeMultipartUpload(complRequest))__            success = true___        } catch (final AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using multipart upload", e)__        } finally {_            if ((success == false) && Strings.hasLength(uploadId.get())) {_                final AbortMultipartUploadRequest abortRequest = new AbortMultipartUploadRequest(bucketName, blobName, uploadId.get())__                try (AmazonS3Reference clientReference = blobStore.clientReference()) {_                    SocketAccess.doPrivilegedVoid(() -> clientReference.client().abortMultipartUpload(abortRequest))__                }_            }_        }_    };uploads,a,blob,using,multipart,upload,requests;void,execute,multipart,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,smaller,than,final,long,part,size,blob,store,buffer,size,in,bytes,final,tuple,long,long,multiparts,number,of,multiparts,blob,size,part,size,if,multiparts,v1,integer,throw,new,illegal,argument,exception,too,many,multipart,upload,requests,maybe,try,a,larger,buffer,size,final,int,nb,parts,multiparts,v1,int,value,final,long,last,part,size,multiparts,v2,assert,blob,size,nb,parts,1,part,size,last,part,size,blob,size,does,not,match,multipart,sizes,final,set,once,string,upload,id,new,set,once,final,string,bucket,name,blob,store,bucket,boolean,success,false,final,initiate,multipart,upload,request,init,request,new,initiate,multipart,upload,request,bucket,name,blob,name,init,request,set,storage,class,blob,store,get,storage,class,init,request,set,canned,acl,blob,store,get,canned,acl,if,blob,store,server,side,encryption,final,object,metadata,md,new,object,metadata,md,set,ssealgorithm,object,metadata,init,request,set,object,metadata,md,try,amazon,s3reference,client,reference,blob,store,client,reference,upload,id,set,socket,access,do,privileged,client,reference,client,initiate,multipart,upload,init,request,get,upload,id,if,strings,is,empty,upload,id,get,throw,new,ioexception,failed,to,initialize,multipart,upload,blob,name,final,list,part,etag,parts,new,array,list,long,bytes,count,0,for,int,i,1,i,nb,parts,i,final,upload,part,request,upload,request,new,upload,part,request,upload,request,set,bucket,name,bucket,name,upload,request,set,key,blob,name,upload,request,set,upload,id,upload,id,get,upload,request,set,part,number,i,upload,request,set,input,stream,input,if,i,nb,parts,upload,request,set,part,size,part,size,upload,request,set,last,part,false,else,upload,request,set,part,size,last,part,size,upload,request,set,last,part,true,bytes,count,upload,request,get,part,size,final,upload,part,result,upload,response,socket,access,do,privileged,client,reference,client,upload,part,upload,request,parts,add,upload,response,get,part,etag,if,bytes,count,blob,size,throw,new,ioexception,failed,to,execute,multipart,upload,for,blob,name,expected,blob,size,bytes,sent,but,got,bytes,count,final,complete,multipart,upload,request,compl,request,new,complete,multipart,upload,request,bucket,name,blob,name,upload,id,get,parts,socket,access,do,privileged,void,client,reference,client,complete,multipart,upload,compl,request,success,true,catch,final,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,multipart,upload,e,finally,if,success,false,strings,has,length,upload,id,get,final,abort,multipart,upload,request,abort,request,new,abort,multipart,upload,request,bucket,name,blob,name,upload,id,get,try,amazon,s3reference,client,reference,blob,store,client,reference,socket,access,do,privileged,void,client,reference,client,abort,multipart,upload,abort,request
S3BlobContainer -> void executeMultipartUpload(final S3BlobStore blobStore,                                 final String blobName,                                 final InputStream input,                                 final long blobSize) throws IOException;1546859479;Uploads a blob using multipart upload requests.;void executeMultipartUpload(final S3BlobStore blobStore,_                                final String blobName,_                                final InputStream input,_                                final long blobSize) throws IOException {__        if (blobSize > MAX_FILE_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                                + "] can't be larger than " + MAX_FILE_SIZE_USING_MULTIPART)__        }_        if (blobSize < MIN_PART_SIZE_USING_MULTIPART.getBytes()) {_            throw new IllegalArgumentException("Multipart upload request size [" + blobSize_                                               + "] can't be smaller than " + MIN_PART_SIZE_USING_MULTIPART)__        }__        final long partSize = blobStore.bufferSizeInBytes()__        final Tuple<Long, Long> multiparts = numberOfMultiparts(blobSize, partSize)___        if (multiparts.v1() > Integer.MAX_VALUE) {_            throw new IllegalArgumentException("Too many multipart upload requests, maybe try a larger buffer size?")__        }__        final int nbParts = multiparts.v1().intValue()__        final long lastPartSize = multiparts.v2()__        assert blobSize == (((nbParts - 1) * partSize) + lastPartSize) : "blobSize does not match multipart sizes"___        final SetOnce<String> uploadId = new SetOnce<>()__        final String bucketName = blobStore.bucket()__        boolean success = false___        final InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest(bucketName, blobName)__        initRequest.setStorageClass(blobStore.getStorageClass())__        initRequest.setCannedACL(blobStore.getCannedACL())__        if (blobStore.serverSideEncryption()) {_            final ObjectMetadata md = new ObjectMetadata()__            md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__            initRequest.setObjectMetadata(md)__        }_        try (AmazonS3Reference clientReference = blobStore.clientReference()) {__            uploadId.set(SocketAccess.doPrivileged(() -> clientReference.client().initiateMultipartUpload(initRequest).getUploadId()))__            if (Strings.isEmpty(uploadId.get())) {_                throw new IOException("Failed to initialize multipart upload " + blobName)__            }__            final List<PartETag> parts = new ArrayList<>()___            long bytesCount = 0__            for (int i = 1_ i <= nbParts_ i++) {_                final UploadPartRequest uploadRequest = new UploadPartRequest()__                uploadRequest.setBucketName(bucketName)__                uploadRequest.setKey(blobName)__                uploadRequest.setUploadId(uploadId.get())__                uploadRequest.setPartNumber(i)__                uploadRequest.setInputStream(input)___                if (i < nbParts) {_                    uploadRequest.setPartSize(partSize)__                    uploadRequest.setLastPart(false)__                } else {_                    uploadRequest.setPartSize(lastPartSize)__                    uploadRequest.setLastPart(true)__                }_                bytesCount += uploadRequest.getPartSize()___                final UploadPartResult uploadResponse = SocketAccess.doPrivileged(() -> clientReference.client().uploadPart(uploadRequest))__                parts.add(uploadResponse.getPartETag())__            }__            if (bytesCount != blobSize) {_                throw new IOException("Failed to execute multipart upload for [" + blobName + "], expected " + blobSize_                    + "bytes sent but got " + bytesCount)__            }__            final CompleteMultipartUploadRequest complRequest = new CompleteMultipartUploadRequest(bucketName, blobName, uploadId.get(),_                    parts)__            SocketAccess.doPrivilegedVoid(() -> clientReference.client().completeMultipartUpload(complRequest))__            success = true___        } catch (final AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using multipart upload", e)__        } finally {_            if ((success == false) && Strings.hasLength(uploadId.get())) {_                final AbortMultipartUploadRequest abortRequest = new AbortMultipartUploadRequest(bucketName, blobName, uploadId.get())__                try (AmazonS3Reference clientReference = blobStore.clientReference()) {_                    SocketAccess.doPrivilegedVoid(() -> clientReference.client().abortMultipartUpload(abortRequest))__                }_            }_        }_    };uploads,a,blob,using,multipart,upload,requests;void,execute,multipart,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,get,bytes,throw,new,illegal,argument,exception,multipart,upload,request,size,blob,size,can,t,be,smaller,than,final,long,part,size,blob,store,buffer,size,in,bytes,final,tuple,long,long,multiparts,number,of,multiparts,blob,size,part,size,if,multiparts,v1,integer,throw,new,illegal,argument,exception,too,many,multipart,upload,requests,maybe,try,a,larger,buffer,size,final,int,nb,parts,multiparts,v1,int,value,final,long,last,part,size,multiparts,v2,assert,blob,size,nb,parts,1,part,size,last,part,size,blob,size,does,not,match,multipart,sizes,final,set,once,string,upload,id,new,set,once,final,string,bucket,name,blob,store,bucket,boolean,success,false,final,initiate,multipart,upload,request,init,request,new,initiate,multipart,upload,request,bucket,name,blob,name,init,request,set,storage,class,blob,store,get,storage,class,init,request,set,canned,acl,blob,store,get,canned,acl,if,blob,store,server,side,encryption,final,object,metadata,md,new,object,metadata,md,set,ssealgorithm,object,metadata,init,request,set,object,metadata,md,try,amazon,s3reference,client,reference,blob,store,client,reference,upload,id,set,socket,access,do,privileged,client,reference,client,initiate,multipart,upload,init,request,get,upload,id,if,strings,is,empty,upload,id,get,throw,new,ioexception,failed,to,initialize,multipart,upload,blob,name,final,list,part,etag,parts,new,array,list,long,bytes,count,0,for,int,i,1,i,nb,parts,i,final,upload,part,request,upload,request,new,upload,part,request,upload,request,set,bucket,name,bucket,name,upload,request,set,key,blob,name,upload,request,set,upload,id,upload,id,get,upload,request,set,part,number,i,upload,request,set,input,stream,input,if,i,nb,parts,upload,request,set,part,size,part,size,upload,request,set,last,part,false,else,upload,request,set,part,size,last,part,size,upload,request,set,last,part,true,bytes,count,upload,request,get,part,size,final,upload,part,result,upload,response,socket,access,do,privileged,client,reference,client,upload,part,upload,request,parts,add,upload,response,get,part,etag,if,bytes,count,blob,size,throw,new,ioexception,failed,to,execute,multipart,upload,for,blob,name,expected,blob,size,bytes,sent,but,got,bytes,count,final,complete,multipart,upload,request,compl,request,new,complete,multipart,upload,request,bucket,name,blob,name,upload,id,get,parts,socket,access,do,privileged,void,client,reference,client,complete,multipart,upload,compl,request,success,true,catch,final,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,multipart,upload,e,finally,if,success,false,strings,has,length,upload,id,get,final,abort,multipart,upload,request,abort,request,new,abort,multipart,upload,request,bucket,name,blob,name,upload,id,get,try,amazon,s3reference,client,reference,blob,store,client,reference,socket,access,do,privileged,void,client,reference,client,abort,multipart,upload,abort,request
S3BlobContainer -> @Override     public void writeBlob(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException;1531179852;This implementation ignores the failIfAlreadyExists flag as the S3 API has no way to enforce this due to its weak consistency model.;@Override_    public void writeBlob(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {_        SocketAccess.doPrivilegedIOException(() -> {_            if (blobSize <= blobStore.bufferSizeInBytes()) {_                executeSingleUpload(blobStore, buildKey(blobName), inputStream, blobSize)__            } else {_                executeMultipartUpload(blobStore, buildKey(blobName), inputStream, blobSize)__            }_            return null__        })__    };this,implementation,ignores,the,fail,if,already,exists,flag,as,the,s3,api,has,no,way,to,enforce,this,due,to,its,weak,consistency,model;override,public,void,write,blob,string,blob,name,input,stream,input,stream,long,blob,size,boolean,fail,if,already,exists,throws,ioexception,socket,access,do,privileged,ioexception,if,blob,size,blob,store,buffer,size,in,bytes,execute,single,upload,blob,store,build,key,blob,name,input,stream,blob,size,else,execute,multipart,upload,blob,store,build,key,blob,name,input,stream,blob,size,return,null
S3BlobContainer -> @Override     public void writeBlob(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException;1546859479;This implementation ignores the failIfAlreadyExists flag as the S3 API has no way to enforce this due to its weak consistency model.;@Override_    public void writeBlob(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {_        SocketAccess.doPrivilegedIOException(() -> {_            if (blobSize <= blobStore.bufferSizeInBytes()) {_                executeSingleUpload(blobStore, buildKey(blobName), inputStream, blobSize)__            } else {_                executeMultipartUpload(blobStore, buildKey(blobName), inputStream, blobSize)__            }_            return null__        })__    };this,implementation,ignores,the,fail,if,already,exists,flag,as,the,s3,api,has,no,way,to,enforce,this,due,to,its,weak,consistency,model;override,public,void,write,blob,string,blob,name,input,stream,input,stream,long,blob,size,boolean,fail,if,already,exists,throws,ioexception,socket,access,do,privileged,ioexception,if,blob,size,blob,store,buffer,size,in,bytes,execute,single,upload,blob,store,build,key,blob,name,input,stream,blob,size,else,execute,multipart,upload,blob,store,build,key,blob,name,input,stream,blob,size,return,null
S3BlobContainer -> void executeSingleUpload(final S3BlobStore blobStore,                              final String blobName,                              final InputStream input,                              final long blobSize) throws IOException;1524684173;Uploads a blob using a single upload request;void executeSingleUpload(final S3BlobStore blobStore,_                             final String blobName,_                             final InputStream input,_                             final long blobSize) throws IOException {__        _        if (blobSize > MAX_FILE_SIZE.getBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than " + MAX_FILE_SIZE)__        }_        if (blobSize > blobStore.bufferSizeInBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than buffer size")__        }__        try {_            final ObjectMetadata md = new ObjectMetadata()__            md.setContentLength(blobSize)__            if (blobStore.serverSideEncryption()) {_                md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__            }__            final PutObjectRequest putRequest = new PutObjectRequest(blobStore.bucket(), blobName, input, md)__            putRequest.setStorageClass(blobStore.getStorageClass())__            putRequest.setCannedAcl(blobStore.getCannedACL())___            blobStore.client().putObject(putRequest)__        } catch (AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using a single upload", e)__        }_    };uploads,a,blob,using,a,single,upload,request;void,execute,single,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,blob,store,buffer,size,in,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,buffer,size,try,final,object,metadata,md,new,object,metadata,md,set,content,length,blob,size,if,blob,store,server,side,encryption,md,set,ssealgorithm,object,metadata,final,put,object,request,put,request,new,put,object,request,blob,store,bucket,blob,name,input,md,put,request,set,storage,class,blob,store,get,storage,class,put,request,set,canned,acl,blob,store,get,canned,acl,blob,store,client,put,object,put,request,catch,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,a,single,upload,e
S3BlobContainer -> void executeSingleUpload(final S3BlobStore blobStore,                              final String blobName,                              final InputStream input,                              final long blobSize) throws IOException;1528304883;Uploads a blob using a single upload request;void executeSingleUpload(final S3BlobStore blobStore,_                             final String blobName,_                             final InputStream input,_                             final long blobSize) throws IOException {__        _        if (blobSize > MAX_FILE_SIZE.getBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than " + MAX_FILE_SIZE)__        }_        if (blobSize > blobStore.bufferSizeInBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than buffer size")__        }__        try {_            final ObjectMetadata md = new ObjectMetadata()__            md.setContentLength(blobSize)__            if (blobStore.serverSideEncryption()) {_                md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__            }__            final PutObjectRequest putRequest = new PutObjectRequest(blobStore.bucket(), blobName, input, md)__            putRequest.setStorageClass(blobStore.getStorageClass())__            putRequest.setCannedAcl(blobStore.getCannedACL())___            blobStore.client().putObject(putRequest)__        } catch (AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using a single upload", e)__        }_    };uploads,a,blob,using,a,single,upload,request;void,execute,single,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,blob,store,buffer,size,in,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,buffer,size,try,final,object,metadata,md,new,object,metadata,md,set,content,length,blob,size,if,blob,store,server,side,encryption,md,set,ssealgorithm,object,metadata,final,put,object,request,put,request,new,put,object,request,blob,store,bucket,blob,name,input,md,put,request,set,storage,class,blob,store,get,storage,class,put,request,set,canned,acl,blob,store,get,canned,acl,blob,store,client,put,object,put,request,catch,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,a,single,upload,e
S3BlobContainer -> void executeSingleUpload(final S3BlobStore blobStore,                              final String blobName,                              final InputStream input,                              final long blobSize) throws IOException;1528706846;Uploads a blob using a single upload request;void executeSingleUpload(final S3BlobStore blobStore,_                             final String blobName,_                             final InputStream input,_                             final long blobSize) throws IOException {__        _        if (blobSize > MAX_FILE_SIZE.getBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than " + MAX_FILE_SIZE)__        }_        if (blobSize > blobStore.bufferSizeInBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than buffer size")__        }__        try {_            final ObjectMetadata md = new ObjectMetadata()__            md.setContentLength(blobSize)__            if (blobStore.serverSideEncryption()) {_                md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__            }__            final PutObjectRequest putRequest = new PutObjectRequest(blobStore.bucket(), blobName, input, md)__            putRequest.setStorageClass(blobStore.getStorageClass())__            putRequest.setCannedAcl(blobStore.getCannedACL())___            blobStore.client().putObject(putRequest)__        } catch (AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using a single upload", e)__        }_    };uploads,a,blob,using,a,single,upload,request;void,execute,single,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,blob,store,buffer,size,in,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,buffer,size,try,final,object,metadata,md,new,object,metadata,md,set,content,length,blob,size,if,blob,store,server,side,encryption,md,set,ssealgorithm,object,metadata,final,put,object,request,put,request,new,put,object,request,blob,store,bucket,blob,name,input,md,put,request,set,storage,class,blob,store,get,storage,class,put,request,set,canned,acl,blob,store,get,canned,acl,blob,store,client,put,object,put,request,catch,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,a,single,upload,e
S3BlobContainer -> void executeSingleUpload(final S3BlobStore blobStore,                              final String blobName,                              final InputStream input,                              final long blobSize) throws IOException;1528762805;Uploads a blob using a single upload request;void executeSingleUpload(final S3BlobStore blobStore,_                             final String blobName,_                             final InputStream input,_                             final long blobSize) throws IOException {__        _        if (blobSize > MAX_FILE_SIZE.getBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than " + MAX_FILE_SIZE)__        }_        if (blobSize > blobStore.bufferSizeInBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than buffer size")__        }__        try {_            final ObjectMetadata md = new ObjectMetadata()__            md.setContentLength(blobSize)__            if (blobStore.serverSideEncryption()) {_                md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__            }__            final PutObjectRequest putRequest = new PutObjectRequest(blobStore.bucket(), blobName, input, md)__            putRequest.setStorageClass(blobStore.getStorageClass())__            putRequest.setCannedAcl(blobStore.getCannedACL())___            blobStore.client().putObject(putRequest)__        } catch (AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using a single upload", e)__        }_    };uploads,a,blob,using,a,single,upload,request;void,execute,single,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,blob,store,buffer,size,in,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,buffer,size,try,final,object,metadata,md,new,object,metadata,md,set,content,length,blob,size,if,blob,store,server,side,encryption,md,set,ssealgorithm,object,metadata,final,put,object,request,put,request,new,put,object,request,blob,store,bucket,blob,name,input,md,put,request,set,storage,class,blob,store,get,storage,class,put,request,set,canned,acl,blob,store,get,canned,acl,blob,store,client,put,object,put,request,catch,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,a,single,upload,e
S3BlobContainer -> void executeSingleUpload(final S3BlobStore blobStore,                              final String blobName,                              final InputStream input,                              final long blobSize) throws IOException;1529341607;Uploads a blob using a single upload request;void executeSingleUpload(final S3BlobStore blobStore,_                             final String blobName,_                             final InputStream input,_                             final long blobSize) throws IOException {__        _        if (blobSize > MAX_FILE_SIZE.getBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than " + MAX_FILE_SIZE)__        }_        if (blobSize > blobStore.bufferSizeInBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than buffer size")__        }__        final ObjectMetadata md = new ObjectMetadata()__        md.setContentLength(blobSize)__        if (blobStore.serverSideEncryption()) {_            md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__        }_        final PutObjectRequest putRequest = new PutObjectRequest(blobStore.bucket(), blobName, input, md)__        putRequest.setStorageClass(blobStore.getStorageClass())__        putRequest.setCannedAcl(blobStore.getCannedACL())___        try (AmazonS3Reference clientReference = blobStore.clientReference()) {_            SocketAccess.doPrivilegedVoid(() -> {_                clientReference.client().putObject(putRequest)__            })__        } catch (final AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using a single upload", e)__        }_    };uploads,a,blob,using,a,single,upload,request;void,execute,single,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,blob,store,buffer,size,in,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,buffer,size,final,object,metadata,md,new,object,metadata,md,set,content,length,blob,size,if,blob,store,server,side,encryption,md,set,ssealgorithm,object,metadata,final,put,object,request,put,request,new,put,object,request,blob,store,bucket,blob,name,input,md,put,request,set,storage,class,blob,store,get,storage,class,put,request,set,canned,acl,blob,store,get,canned,acl,try,amazon,s3reference,client,reference,blob,store,client,reference,socket,access,do,privileged,void,client,reference,client,put,object,put,request,catch,final,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,a,single,upload,e
S3BlobContainer -> void executeSingleUpload(final S3BlobStore blobStore,                              final String blobName,                              final InputStream input,                              final long blobSize) throws IOException;1531179852;Uploads a blob using a single upload request;void executeSingleUpload(final S3BlobStore blobStore,_                             final String blobName,_                             final InputStream input,_                             final long blobSize) throws IOException {__        _        if (blobSize > MAX_FILE_SIZE.getBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than " + MAX_FILE_SIZE)__        }_        if (blobSize > blobStore.bufferSizeInBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than buffer size")__        }__        final ObjectMetadata md = new ObjectMetadata()__        md.setContentLength(blobSize)__        if (blobStore.serverSideEncryption()) {_            md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__        }_        final PutObjectRequest putRequest = new PutObjectRequest(blobStore.bucket(), blobName, input, md)__        putRequest.setStorageClass(blobStore.getStorageClass())__        putRequest.setCannedAcl(blobStore.getCannedACL())___        try (AmazonS3Reference clientReference = blobStore.clientReference()) {_            SocketAccess.doPrivilegedVoid(() -> {_                clientReference.client().putObject(putRequest)__            })__        } catch (final AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using a single upload", e)__        }_    };uploads,a,blob,using,a,single,upload,request;void,execute,single,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,blob,store,buffer,size,in,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,buffer,size,final,object,metadata,md,new,object,metadata,md,set,content,length,blob,size,if,blob,store,server,side,encryption,md,set,ssealgorithm,object,metadata,final,put,object,request,put,request,new,put,object,request,blob,store,bucket,blob,name,input,md,put,request,set,storage,class,blob,store,get,storage,class,put,request,set,canned,acl,blob,store,get,canned,acl,try,amazon,s3reference,client,reference,blob,store,client,reference,socket,access,do,privileged,void,client,reference,client,put,object,put,request,catch,final,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,a,single,upload,e
S3BlobContainer -> void executeSingleUpload(final S3BlobStore blobStore,                              final String blobName,                              final InputStream input,                              final long blobSize) throws IOException;1546859479;Uploads a blob using a single upload request;void executeSingleUpload(final S3BlobStore blobStore,_                             final String blobName,_                             final InputStream input,_                             final long blobSize) throws IOException {__        _        if (blobSize > MAX_FILE_SIZE.getBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than " + MAX_FILE_SIZE)__        }_        if (blobSize > blobStore.bufferSizeInBytes()) {_            throw new IllegalArgumentException("Upload request size [" + blobSize + "] can't be larger than buffer size")__        }__        final ObjectMetadata md = new ObjectMetadata()__        md.setContentLength(blobSize)__        if (blobStore.serverSideEncryption()) {_            md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION)__        }_        final PutObjectRequest putRequest = new PutObjectRequest(blobStore.bucket(), blobName, input, md)__        putRequest.setStorageClass(blobStore.getStorageClass())__        putRequest.setCannedAcl(blobStore.getCannedACL())___        try (AmazonS3Reference clientReference = blobStore.clientReference()) {_            SocketAccess.doPrivilegedVoid(() -> {_                clientReference.client().putObject(putRequest)__            })__        } catch (final AmazonClientException e) {_            throw new IOException("Unable to upload object [" + blobName + "] using a single upload", e)__        }_    };uploads,a,blob,using,a,single,upload,request;void,execute,single,upload,final,s3blob,store,blob,store,final,string,blob,name,final,input,stream,input,final,long,blob,size,throws,ioexception,if,blob,size,get,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,if,blob,size,blob,store,buffer,size,in,bytes,throw,new,illegal,argument,exception,upload,request,size,blob,size,can,t,be,larger,than,buffer,size,final,object,metadata,md,new,object,metadata,md,set,content,length,blob,size,if,blob,store,server,side,encryption,md,set,ssealgorithm,object,metadata,final,put,object,request,put,request,new,put,object,request,blob,store,bucket,blob,name,input,md,put,request,set,storage,class,blob,store,get,storage,class,put,request,set,canned,acl,blob,store,get,canned,acl,try,amazon,s3reference,client,reference,blob,store,client,reference,socket,access,do,privileged,void,client,reference,client,put,object,put,request,catch,final,amazon,client,exception,e,throw,new,ioexception,unable,to,upload,object,blob,name,using,a,single,upload,e
