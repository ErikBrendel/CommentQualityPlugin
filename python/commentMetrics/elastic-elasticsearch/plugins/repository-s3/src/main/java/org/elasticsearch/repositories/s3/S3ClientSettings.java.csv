commented;modifiers;parameterAmount;loc;comment;code
true;;1;38;/**  * Overrides the settings in this instance with settings found in repository metadata.  *  * @param metadata RepositoryMetaData  * @return S3ClientSettings  */ ;/**  * Overrides the settings in this instance with settings found in repository metadata.  *  * @param metadata RepositoryMetaData  * @return S3ClientSettings  */ S3ClientSettings refine(RepositoryMetaData metadata) {     final Settings repoSettings = metadata.settings().     // Normalize settings to placeholder client settings prefix so that we can use the affix settings directly     final Settings normalizedSettings = Settings.builder().put(repoSettings).normalizePrefix(PREFIX + PLACEHOLDER_CLIENT + '.').build().     final String newEndpoint = getRepoSettingOrDefault(ENDPOINT_SETTING, normalizedSettings, endpoint).     final Protocol newProtocol = getRepoSettingOrDefault(PROTOCOL_SETTING, normalizedSettings, protocol).     final String newProxyHost = getRepoSettingOrDefault(PROXY_HOST_SETTING, normalizedSettings, proxyHost).     final int newProxyPort = getRepoSettingOrDefault(PROXY_PORT_SETTING, normalizedSettings, proxyPort).     final int newReadTimeoutMillis = Math.toIntExact(getRepoSettingOrDefault(READ_TIMEOUT_SETTING, normalizedSettings, TimeValue.timeValueMillis(readTimeoutMillis)).millis()).     final int newMaxRetries = getRepoSettingOrDefault(MAX_RETRIES_SETTING, normalizedSettings, maxRetries).     final boolean newThrottleRetries = getRepoSettingOrDefault(USE_THROTTLE_RETRIES_SETTING, normalizedSettings, throttleRetries).     final S3BasicCredentials newCredentials.     if (checkDeprecatedCredentials(repoSettings)) {         newCredentials = loadDeprecatedCredentials(repoSettings).     } else {         newCredentials = credentials.     }     if (Objects.equals(endpoint, newEndpoint) && protocol == newProtocol && Objects.equals(proxyHost, newProxyHost) && proxyPort == newProxyPort && newReadTimeoutMillis == readTimeoutMillis && maxRetries == newMaxRetries && newThrottleRetries == throttleRetries && Objects.equals(credentials, newCredentials)) {         return this.     }     return new S3ClientSettings(newCredentials, newEndpoint, newProtocol, newProxyHost, newProxyPort, proxyUsername, proxyPassword, newReadTimeoutMillis, newMaxRetries, newThrottleRetries). }
true;static;1;13;/**  * Load all client settings from the given settings.  *  * Note this will always at least return a client named "default".  */ ;/**  * Load all client settings from the given settings.  *  * Note this will always at least return a client named "default".  */ static Map<String, S3ClientSettings> load(Settings settings) {     final Set<String> clientNames = settings.getGroups(PREFIX).keySet().     final Map<String, S3ClientSettings> clients = new HashMap<>().     for (final String clientName : clientNames) {         clients.put(clientName, getClientSettings(settings, clientName)).     }     if (clients.containsKey("default") == false) {         // this won't find any settings under the default client,         // but it will pull all the fallback static settings         clients.put("default", getClientSettings(settings, "default")).     }     return Collections.unmodifiableMap(clients). }
false;static;1;13;;static boolean checkDeprecatedCredentials(Settings repositorySettings) {     if (S3Repository.ACCESS_KEY_SETTING.exists(repositorySettings)) {         if (S3Repository.SECRET_KEY_SETTING.exists(repositorySettings) == false) {             throw new IllegalArgumentException("Repository setting [" + S3Repository.ACCESS_KEY_SETTING.getKey() + " must be accompanied by setting [" + S3Repository.SECRET_KEY_SETTING.getKey() + "]").         }         return true.     } else if (S3Repository.SECRET_KEY_SETTING.exists(repositorySettings)) {         throw new IllegalArgumentException("Repository setting [" + S3Repository.SECRET_KEY_SETTING.getKey() + " must be accompanied by setting [" + S3Repository.ACCESS_KEY_SETTING.getKey() + "]").     }     return false. }
true;private,static;1;7;// backcompat for reading keys out of repository settings (clusterState) ;// backcompat for reading keys out of repository settings (clusterState) private static S3BasicCredentials loadDeprecatedCredentials(Settings repositorySettings) {     assert checkDeprecatedCredentials(repositorySettings).     try (SecureString key = S3Repository.ACCESS_KEY_SETTING.get(repositorySettings).         SecureString secret = S3Repository.SECRET_KEY_SETTING.get(repositorySettings)) {         return new S3BasicCredentials(key.toString(), secret.toString()).     } }
false;private,static;2;25;;private static S3BasicCredentials loadCredentials(Settings settings, String clientName) {     try (SecureString accessKey = getConfigValue(settings, clientName, ACCESS_KEY_SETTING).         SecureString secretKey = getConfigValue(settings, clientName, SECRET_KEY_SETTING).         SecureString sessionToken = getConfigValue(settings, clientName, SESSION_TOKEN_SETTING)) {         if (accessKey.length() != 0) {             if (secretKey.length() != 0) {                 if (sessionToken.length() != 0) {                     return new S3BasicSessionCredentials(accessKey.toString(), secretKey.toString(), sessionToken.toString()).                 } else {                     return new S3BasicCredentials(accessKey.toString(), secretKey.toString()).                 }             } else {                 throw new IllegalArgumentException("Missing secret key for s3 client [" + clientName + "]").             }         } else {             if (secretKey.length() != 0) {                 throw new IllegalArgumentException("Missing access key for s3 client [" + clientName + "]").             }             if (sessionToken.length() != 0) {                 throw new IllegalArgumentException("Missing access key and secret key for s3 client [" + clientName + "]").             }             return null.         }     } }
true;static;2;17;/**  * Parse settings for a single client.  */ ;// pkg private for tests /**  * Parse settings for a single client.  */ static S3ClientSettings getClientSettings(final Settings settings, final String clientName) {     try (SecureString proxyUsername = getConfigValue(settings, clientName, PROXY_USERNAME_SETTING).         SecureString proxyPassword = getConfigValue(settings, clientName, PROXY_PASSWORD_SETTING)) {         return new S3ClientSettings(S3ClientSettings.loadCredentials(settings, clientName), getConfigValue(settings, clientName, ENDPOINT_SETTING), getConfigValue(settings, clientName, PROTOCOL_SETTING), getConfigValue(settings, clientName, PROXY_HOST_SETTING), getConfigValue(settings, clientName, PROXY_PORT_SETTING), proxyUsername.toString(), proxyPassword.toString(), Math.toIntExact(getConfigValue(settings, clientName, READ_TIMEOUT_SETTING).millis()), getConfigValue(settings, clientName, MAX_RETRIES_SETTING), getConfigValue(settings, clientName, USE_THROTTLE_RETRIES_SETTING)).     } }
false;public;1;20;;@Override public boolean equals(final Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     final S3ClientSettings that = (S3ClientSettings) o.     return proxyPort == that.proxyPort && readTimeoutMillis == that.readTimeoutMillis && maxRetries == that.maxRetries && throttleRetries == that.throttleRetries && Objects.equals(credentials, that.credentials) && Objects.equals(endpoint, that.endpoint) && protocol == that.protocol && Objects.equals(proxyHost, that.proxyHost) && Objects.equals(proxyUsername, that.proxyUsername) && Objects.equals(proxyPassword, that.proxyPassword). }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(credentials, endpoint, protocol, proxyHost, proxyPort, proxyUsername, proxyPassword, readTimeoutMillis, maxRetries, throttleRetries). }
false;private,static;3;5;;private static <T> T getConfigValue(Settings settings, String clientName, Setting.AffixSetting<T> clientSetting) {     final Setting<T> concreteSetting = clientSetting.getConcreteSettingForNamespace(clientName).     return concreteSetting.get(settings). }
false;private,static;3;6;;private static <T> T getRepoSettingOrDefault(Setting.AffixSetting<T> setting, Settings normalizedSettings, T defaultValue) {     if (setting.getConcreteSettingForNamespace(PLACEHOLDER_CLIENT).exists(normalizedSettings)) {         return getConfigValue(normalizedSettings, PLACEHOLDER_CLIENT, setting).     }     return defaultValue. }
