commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return bucket. }
false;public;0;3;;public AmazonS3Reference clientReference() {     return service.client(repositoryMetaData). }
false;public;0;3;;public String bucket() {     return bucket. }
false;public;0;3;;public boolean serverSideEncryption() {     return serverSideEncryption. }
false;public;0;3;;public long bufferSizeInBytes() {     return bufferSize.getBytes(). }
false;public;1;4;;@Override public BlobContainer blobContainer(BlobPath path) {     return new S3BlobContainer(path, this). }
false;public;1;43;;@Override public void delete(BlobPath path) {     try (AmazonS3Reference clientReference = clientReference()) {         ObjectListing prevListing = null.         // From         // http://docs.amazonwebservices.com/AmazonS3/latest/dev/DeletingMultipleObjectsUsingJava.html         // we can do at most 1K objects per delete         // We don't know the bucket name until first object listing         DeleteObjectsRequest multiObjectDeleteRequest = null.         final ArrayList<KeyVersion> keys = new ArrayList<>().         while (true) {             ObjectListing list.             if (prevListing != null) {                 final ObjectListing finalPrevListing = prevListing.                 list = SocketAccess.doPrivileged(() -> clientReference.client().listNextBatchOfObjects(finalPrevListing)).             } else {                 list = SocketAccess.doPrivileged(() -> clientReference.client().listObjects(bucket, path.buildAsString())).                 multiObjectDeleteRequest = new DeleteObjectsRequest(list.getBucketName()).             }             for (final S3ObjectSummary summary : list.getObjectSummaries()) {                 keys.add(new KeyVersion(summary.getKey())).                 // Every 500 objects batch the delete request                 if (keys.size() > 500) {                     multiObjectDeleteRequest.setKeys(keys).                     final DeleteObjectsRequest finalMultiObjectDeleteRequest = multiObjectDeleteRequest.                     SocketAccess.doPrivilegedVoid(() -> clientReference.client().deleteObjects(finalMultiObjectDeleteRequest)).                     multiObjectDeleteRequest = new DeleteObjectsRequest(list.getBucketName()).                     keys.clear().                 }             }             if (list.isTruncated()) {                 prevListing = list.             } else {                 break.             }         }         if (!keys.isEmpty()) {             multiObjectDeleteRequest.setKeys(keys).             final DeleteObjectsRequest finalMultiObjectDeleteRequest = multiObjectDeleteRequest.             SocketAccess.doPrivilegedVoid(() -> clientReference.client().deleteObjects(finalMultiObjectDeleteRequest)).         }     } }
false;public;0;4;;@Override public void close() throws IOException {     this.service.close(). }
false;public;0;3;;public CannedAccessControlList getCannedACL() {     return cannedACL. }
false;public;0;3;;public StorageClass getStorageClass() {     return storageClass. }
false;public,static;1;16;;public static StorageClass initStorageClass(String storageClass) {     if ((storageClass == null) || storageClass.equals("")) {         return StorageClass.Standard.     }     try {         final StorageClass _storageClass = StorageClass.fromValue(storageClass.toUpperCase(Locale.ENGLISH)).         if (_storageClass.equals(StorageClass.Glacier)) {             throw new BlobStoreException("Glacier storage class is not supported").         }         return _storageClass.     } catch (final IllegalArgumentException illegalArgumentException) {         throw new BlobStoreException("`" + storageClass + "` is not a valid S3 Storage Class.").     } }
true;public,static;1;13;/**  * Constructs canned acl from string  */ ;/**  * Constructs canned acl from string  */ public static CannedAccessControlList initCannedACL(String cannedACL) {     if ((cannedACL == null) || cannedACL.equals("")) {         return CannedAccessControlList.Private.     }     for (final CannedAccessControlList cur : CannedAccessControlList.values()) {         if (cur.toString().equalsIgnoreCase(cannedACL)) {             return cur.         }     }     throw new BlobStoreException("cannedACL is not valid: [" + cannedACL + "]"). }
