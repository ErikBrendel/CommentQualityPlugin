commented;modifiers;parameterAmount;loc;comment;code
true;public,synchronized;1;9;/**  * Refreshes the settings for the AmazonS3 clients and clears the cache of  * existing clients. New clients will be build using these new settings. Old  * clients are usable until released. On release they will be destroyed instead  * of being returned to the cache.  */ ;/**  * Refreshes the settings for the AmazonS3 clients and clears the cache of  * existing clients. New clients will be build using these new settings. Old  * clients are usable until released. On release they will be destroyed instead  * of being returned to the cache.  */ public synchronized void refreshAndClearCache(Map<String, S3ClientSettings> clientsSettings) {     // shutdown all unused clients     // others will shutdown on their respective release     releaseCachedClients().     this.staticClientSettings = MapBuilder.newMapBuilder(clientsSettings).immutableMap().     derivedClientSettings = emptyMap().     assert this.staticClientSettings.containsKey("default") : "always at least have 'default'". // clients are built lazily by {@link client} }
true;public;1;19;/**  * Attempts to retrieve a client by its repository metadata and settings from the cache.  * If the client does not exist it will be created.  */ ;/**  * Attempts to retrieve a client by its repository metadata and settings from the cache.  * If the client does not exist it will be created.  */ public AmazonS3Reference client(RepositoryMetaData repositoryMetaData) {     final S3ClientSettings clientSettings = settings(repositoryMetaData).     {         final AmazonS3Reference clientReference = clientsCache.get(clientSettings).         if (clientReference != null && clientReference.tryIncRef()) {             return clientReference.         }     }     synchronized (this) {         final AmazonS3Reference existing = clientsCache.get(clientSettings).         if (existing != null && existing.tryIncRef()) {             return existing.         }         final AmazonS3Reference clientReference = new AmazonS3Reference(buildClient(clientSettings)).         clientReference.incRef().         clientsCache = MapBuilder.newMapBuilder(clientsCache).put(clientSettings, clientReference).immutableMap().         return clientReference.     } }
true;private;1;27;/**  * Either fetches {@link S3ClientSettings} for a given {@link RepositoryMetaData} from cached settings or creates them  * by overriding static client settings from {@link #staticClientSettings} with settings found in the repository metadata.  * @param repositoryMetaData Repository Metadata  * @return S3ClientSettings  */ ;/**  * Either fetches {@link S3ClientSettings} for a given {@link RepositoryMetaData} from cached settings or creates them  * by overriding static client settings from {@link #staticClientSettings} with settings found in the repository metadata.  * @param repositoryMetaData Repository Metadata  * @return S3ClientSettings  */ private S3ClientSettings settings(RepositoryMetaData repositoryMetaData) {     final String clientName = S3Repository.CLIENT_NAME.get(repositoryMetaData.settings()).     final S3ClientSettings staticSettings = staticClientSettings.get(clientName).     if (staticSettings != null) {         {             final S3ClientSettings existing = derivedClientSettings.getOrDefault(staticSettings, emptyMap()).get(repositoryMetaData).             if (existing != null) {                 return existing.             }         }         synchronized (this) {             final Map<RepositoryMetaData, S3ClientSettings> derivedSettings = derivedClientSettings.getOrDefault(staticSettings, emptyMap()).             final S3ClientSettings existing = derivedSettings.get(repositoryMetaData).             if (existing != null) {                 return existing.             }             final S3ClientSettings newSettings = staticSettings.refine(repositoryMetaData).             derivedClientSettings = MapBuilder.newMapBuilder(derivedClientSettings).put(staticSettings, MapBuilder.newMapBuilder(derivedSettings).put(repositoryMetaData, newSettings).immutableMap()).immutableMap().             return newSettings.         }     }     throw new IllegalArgumentException("Unknown s3 client name [" + clientName + "]. Existing client configs: " + Strings.collectionToDelimitedString(staticClientSettings.keySet(), ",")). }
true;;1;21;// proxy for testing ;// proxy for testing AmazonS3 buildClient(final S3ClientSettings clientSettings) {     final AmazonS3ClientBuilder builder = AmazonS3ClientBuilder.standard().     builder.withCredentials(buildCredentials(logger, clientSettings)).     builder.withClientConfiguration(buildConfiguration(clientSettings)).     final String endpoint = Strings.hasLength(clientSettings.endpoint) ? clientSettings.endpoint : Constants.S3_HOSTNAME.     logger.debug("using endpoint [{}]", endpoint).     // If the endpoint configuration isn't set on the builder then the default behaviour is to try     // and work out what region we are in and use an appropriate endpoint - see AwsClientBuilder#setRegion.     // In contrast, directly-constructed clients use s3.amazonaws.com unless otherwise instructed. We currently     // use a directly-constructed client, and need to keep the existing behaviour to avoid a breaking change,     // so to move to using the builder we must set it explicitly to keep the existing behaviour.     //      // We do this because directly constructing the client is deprecated (was already deprecated in 1.1.223 too)     // so this change removes that usage of a deprecated API.     builder.withEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration(endpoint, null)).enablePathStyleAccess().     return builder.build(). }
true;static;1;21;// pkg private for tests ;// pkg private for tests static ClientConfiguration buildConfiguration(S3ClientSettings clientSettings) {     final ClientConfiguration clientConfiguration = new ClientConfiguration().     // the response metadata cache is only there for diagnostics purposes,     // but can force objects from every response to the old generation.     clientConfiguration.setResponseMetadataCacheSize(0).     clientConfiguration.setProtocol(clientSettings.protocol).     if (Strings.hasText(clientSettings.proxyHost)) {         // TODO: remove this leniency, these settings should exist together and be validated         clientConfiguration.setProxyHost(clientSettings.proxyHost).         clientConfiguration.setProxyPort(clientSettings.proxyPort).         clientConfiguration.setProxyUsername(clientSettings.proxyUsername).         clientConfiguration.setProxyPassword(clientSettings.proxyPassword).     }     clientConfiguration.setMaxErrorRetry(clientSettings.maxRetries).     clientConfiguration.setUseThrottleRetries(clientSettings.throttleRetries).     clientConfiguration.setSocketTimeout(clientSettings.readTimeoutMillis).     return clientConfiguration. }
true;static;2;10;// pkg private for tests ;// pkg private for tests static AWSCredentialsProvider buildCredentials(Logger logger, S3ClientSettings clientSettings) {     final S3BasicCredentials credentials = clientSettings.credentials.     if (credentials == null) {         logger.debug("Using instance profile credentials").         return new PrivilegedInstanceProfileCredentialsProvider().     } else {         logger.debug("Using basic key/secret credentials").         return new AWSStaticCredentialsProvider(credentials).     } }
false;private,synchronized;0;11;;private synchronized void releaseCachedClients() {     // the clients will shutdown when they will not be used anymore     for (final AmazonS3Reference clientReference : clientsCache.values()) {         clientReference.decRef().     }     // clear previously cached clients, they will be build lazily     clientsCache = emptyMap().     // shutdown IdleConnectionReaper background thread     // it will be restarted on new client usage     IdleConnectionReaper.shutdown(). }
false;public;0;4;;@Override public AWSCredentials getCredentials() {     return SocketAccess.doPrivileged(credentials::getCredentials). }
false;public;0;4;;@Override public void refresh() {     SocketAccess.doPrivilegedVoid(credentials::refresh). }
false;public;0;4;;@Override public void close() throws IOException {     releaseCachedClients(). }
