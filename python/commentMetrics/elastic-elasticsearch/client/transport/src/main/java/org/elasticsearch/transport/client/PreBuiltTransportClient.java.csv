commented;modifiers;parameterAmount;loc;comment;code
true;private,static;0;14;/**  * Netty wants to do some unwelcome things like use unsafe and replace a private field, or use a poorly considered buffer recycler. This  * method disables these things by default, but can be overridden by setting the corresponding system properties.  */ ;/**  * Netty wants to do some unwelcome things like use unsafe and replace a private field, or use a poorly considered buffer recycler. This  * method disables these things by default, but can be overridden by setting the corresponding system properties.  */ private static void initializeNetty() {     /*          * We disable three pieces of Netty functionality here:          *  - we disable Netty from being unsafe          *  - we disable Netty from replacing the selector key set          *  - we disable Netty from using the recycler          *          * While permissions are needed to read and set these, the permissions needed here are innocuous and thus should simply be granted          * rather than us handling a security exception here.          */     setSystemPropertyIfUnset("io.netty.noUnsafe", Boolean.toString(true)).     setSystemPropertyIfUnset("io.netty.noKeySetOptimization", Boolean.toString(true)).     setSystemPropertyIfUnset("io.netty.recycler.maxCapacityPerThread", Integer.toString(0)). }
false;private,static;2;7;;@SuppressForbidden(reason = "set system properties to configure Netty") private static void setSystemPropertyIfUnset(final String key, final String value) {     final String currentValue = System.getProperty(key).     if (currentValue == null) {         System.setProperty(key, value).     } }
false;public;0;17;;@Override public void close() {     super.close().     if (NetworkModule.TRANSPORT_TYPE_SETTING.exists(settings) == false || NetworkModule.TRANSPORT_TYPE_SETTING.get(settings).equals(Netty4Plugin.NETTY_TRANSPORT_NAME)) {         try {             GlobalEventExecutor.INSTANCE.awaitInactivity(5, TimeUnit.SECONDS).         } catch (InterruptedException e) {             Thread.currentThread().interrupt().         }         try {             ThreadDeathWatcher.awaitInactivity(5, TimeUnit.SECONDS).         } catch (InterruptedException e) {             Thread.currentThread().interrupt().         }     } }
