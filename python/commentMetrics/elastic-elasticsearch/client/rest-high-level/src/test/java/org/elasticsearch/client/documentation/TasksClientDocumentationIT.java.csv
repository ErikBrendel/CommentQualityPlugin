commented;modifiers;parameterAmount;loc;comment;code
false;public;0;51;;@SuppressWarnings("unused") public void testListTasks() throws IOException {     RestHighLevelClient client = highLevelClient().     {         // tag::list-tasks-request         ListTasksRequest request = new ListTasksRequest().         // end::list-tasks-request         // tag::list-tasks-request-filter         // <1>         request.setActions("cluster:*").         // <2>         request.setNodes("nodeId1", "nodeId2").         // <3>         request.setParentTaskId(new TaskId("parentTaskId", 42)).         // end::list-tasks-request-filter         // tag::list-tasks-request-detailed         // <1>         request.setDetailed(true).         // end::list-tasks-request-detailed         // tag::list-tasks-request-wait-completion         // <1>         request.setWaitForCompletion(true).         // <2>         request.setTimeout(TimeValue.timeValueSeconds(50)).         // <3>         request.setTimeout("50s").     // end::list-tasks-request-wait-completion     }     ListTasksRequest request = new ListTasksRequest().     // tag::list-tasks-execute     ListTasksResponse response = client.tasks().list(request, RequestOptions.DEFAULT).     // end::list-tasks-execute     assertThat(response, notNullValue()).     // tag::list-tasks-response-tasks     // <1>     List<TaskInfo> tasks = response.getTasks().     // end::list-tasks-response-tasks     // tag::list-tasks-response-calc     // <1>     Map<String, List<TaskInfo>> perNodeTasks = response.getPerNodeTasks().     // <2>     List<TaskGroup> groups = response.getTaskGroups().     // end::list-tasks-response-calc     // tag::list-tasks-response-failures     // <1>     List<ElasticsearchException> nodeFailures = response.getNodeFailures().     // <2>     List<TaskOperationFailure> taskFailures = response.getTaskFailures().     // end::list-tasks-response-failures     assertThat(response.getNodeFailures(), equalTo(emptyList())).     assertThat(response.getTaskFailures(), equalTo(emptyList())).     assertThat(response.getTasks().size(), greaterThanOrEqualTo(2)). }
false;public;1;4;;@Override public void onResponse(ListTasksResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;31;;public void testListTasksAsync() throws Exception {     RestHighLevelClient client = highLevelClient().     {         ListTasksRequest request = new ListTasksRequest().         // tag::list-tasks-execute-listener         ActionListener<ListTasksResponse> listener = new ActionListener<ListTasksResponse>() {              @Override             public void onResponse(ListTasksResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::list-tasks-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::list-tasks-execute-async         // <1>         client.tasks().listAsync(request, RequestOptions.DEFAULT, listener).         // end::list-tasks-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;0;43;;@SuppressWarnings("unused") public void testCancelTasks() throws IOException {     RestHighLevelClient client = highLevelClient().     {         // tag::cancel-tasks-request         CancelTasksRequest request = new CancelTasksRequest().         // end::cancel-tasks-request         // tag::cancel-tasks-request-filter         // <1>         request.setTaskId(new TaskId("nodeId1", 42)).         // <2>         request.setActions("cluster:*").         // <3>         request.setNodes("nodeId1", "nodeId2").     // end::cancel-tasks-request-filter     }     CancelTasksRequest request = new CancelTasksRequest().     request.setTaskId(TaskId.EMPTY_TASK_ID).     // tag::cancel-tasks-execute     CancelTasksResponse response = client.tasks().cancel(request, RequestOptions.DEFAULT).     // end::cancel-tasks-execute     assertThat(response, notNullValue()).     // tag::cancel-tasks-response-tasks     // <1>     List<TaskInfo> tasks = response.getTasks().     // end::cancel-tasks-response-tasks     // tag::cancel-tasks-response-calc     // <1>     Map<String, List<TaskInfo>> perNodeTasks = response.getPerNodeTasks().     // <2>     List<TaskGroup> groups = response.getTaskGroups().     // end::cancel-tasks-response-calc     // tag::cancel-tasks-response-failures     // <1>     List<ElasticsearchException> nodeFailures = response.getNodeFailures().     // <2>     List<TaskOperationFailure> taskFailures = response.getTaskFailures().     // end::cancel-tasks-response-failures     assertThat(response.getNodeFailures(), equalTo(emptyList())).     assertThat(response.getTaskFailures(), equalTo(emptyList())). }
false;public;1;4;;@Override public void onResponse(CancelTasksResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;31;;public void testAsyncCancelTasks() throws InterruptedException {     RestHighLevelClient client = highLevelClient().     {         CancelTasksRequest request = new CancelTasksRequest().         // tag::cancel-tasks-execute-listener         ActionListener<CancelTasksResponse> listener = new ActionListener<CancelTasksResponse>() {              @Override             public void onResponse(CancelTasksResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::cancel-tasks-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::cancel-tasks-execute-async         // <1>         client.tasks().cancelAsync(request, RequestOptions.DEFAULT, listener).         // end::cancel-tasks-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
