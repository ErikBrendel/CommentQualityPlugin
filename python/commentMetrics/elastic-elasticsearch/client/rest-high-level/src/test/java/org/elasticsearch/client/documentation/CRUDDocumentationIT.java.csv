commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onResponse(IndexResponse indexResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;168;;@SuppressWarnings("unused") public void testIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         // tag::index-request-map         Map<String, Object> jsonMap = new HashMap<>().         jsonMap.put("user", "kimchy").         jsonMap.put("postDate", new Date()).         jsonMap.put("message", "trying out Elasticsearch").         IndexRequest indexRequest = new IndexRequest("posts").id("1").source(// <1>         jsonMap).         // end::index-request-map         IndexResponse indexResponse = client.index(indexRequest, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()).     }     {         // tag::index-request-xcontent         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.startObject().         {             builder.field("user", "kimchy").             builder.timeField("postDate", new Date()).             builder.field("message", "trying out Elasticsearch").         }         builder.endObject().         IndexRequest indexRequest = new IndexRequest("posts").id("1").source(// <1>         builder).         // end::index-request-xcontent         IndexResponse indexResponse = client.index(indexRequest, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, indexResponse.getResult()).     }     {         // tag::index-request-shortcut         IndexRequest indexRequest = new IndexRequest("posts").id("1").source("user", "kimchy", "postDate", new Date(), "message", // <1>         "trying out Elasticsearch").         // end::index-request-shortcut         IndexResponse indexResponse = client.index(indexRequest, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, indexResponse.getResult()).     }     {         // tag::index-request-string         // <1>         IndexRequest request = new IndexRequest("posts").         // <2>         request.id("1").         String jsonString = "{" + "\"user\":\"kimchy\"," + "\"postDate\":\"2013-01-30\"," + "\"message\":\"trying out Elasticsearch\"" + "}".         // <3>         request.source(jsonString, XContentType.JSON).         // end::index-request-string         // tag::index-execute         IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT).         // end::index-execute         assertEquals(DocWriteResponse.Result.UPDATED, indexResponse.getResult()).         // tag::index-response         String index = indexResponse.getIndex().         String id = indexResponse.getId().         if (indexResponse.getResult() == DocWriteResponse.Result.CREATED) {         // <1>         } else if (indexResponse.getResult() == DocWriteResponse.Result.UPDATED) {         // <2>         }         ReplicationResponse.ShardInfo shardInfo = indexResponse.getShardInfo().         if (shardInfo.getTotal() != shardInfo.getSuccessful()) {         // <3>         }         if (shardInfo.getFailed() > 0) {             for (ReplicationResponse.ShardInfo.Failure failure : shardInfo.getFailures()) {                 // <4>                 String reason = failure.reason().             }         }     // end::index-response     }     {         IndexRequest request = new IndexRequest("posts").id("1").         // tag::index-request-routing         // <1>         request.routing("routing").         // end::index-request-routing         // tag::index-request-timeout         // <1>         request.timeout(TimeValue.timeValueSeconds(1)).         // <2>         request.timeout("1s").         // end::index-request-timeout         // tag::index-request-refresh         // <1>         request.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL).         // <2>         request.setRefreshPolicy("wait_for").         // end::index-request-refresh         // tag::index-request-version         // <1>         request.version(2).         // end::index-request-version         // tag::index-request-version-type         // <1>         request.versionType(VersionType.EXTERNAL).         // end::index-request-version-type         // tag::index-request-op-type         // <1>         request.opType(DocWriteRequest.OpType.CREATE).         // <2>         request.opType("create").         // end::index-request-op-type         // tag::index-request-pipeline         // <1>         request.setPipeline("pipeline").     // end::index-request-pipeline     }     {         // tag::index-conflict         IndexRequest request = new IndexRequest("posts").id("1").source("field", "value").setIfSeqNo(10L).setIfPrimaryTerm(20).         try {             IndexResponse response = client.index(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException e) {             if (e.status() == RestStatus.CONFLICT) {             // <1>             }         }     // end::index-conflict     }     {         // tag::index-optype         IndexRequest request = new IndexRequest("posts").id("1").source("field", "value").opType(DocWriteRequest.OpType.CREATE).         try {             IndexResponse response = client.index(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException e) {             if (e.status() == RestStatus.CONFLICT) {             // <1>             }         }     // end::index-optype     }     {         IndexRequest request = new IndexRequest("posts").id("async").source("field", "value").         ActionListener<IndexResponse> listener.         // tag::index-execute-listener         listener = new ActionListener<IndexResponse>() {              @Override             public void onResponse(IndexResponse indexResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::index-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::index-execute-async         // <1>         client.indexAsync(request, RequestOptions.DEFAULT, listener).         // end::index-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(UpdateResponse updateResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;275;;@SuppressWarnings("unused") public void testUpdate() throws Exception {     RestHighLevelClient client = highLevelClient().     {         IndexRequest indexRequest = new IndexRequest("posts").id("1").source("field", 0).         IndexResponse indexResponse = client.index(indexRequest, RequestOptions.DEFAULT).         assertSame(RestStatus.CREATED, indexResponse.status()).         Request request = new Request("POST", "/_scripts/increment-field").         request.setJsonEntity(Strings.toString(JsonXContent.contentBuilder().startObject().startObject("script").field("lang", "painless").field("source", "ctx._source.field += params.count").endObject().endObject())).         Response response = client().performRequest(request).         assertEquals(RestStatus.OK.getStatus(), response.getStatusLine().getStatusCode()).     }     {         // tag::update-request         UpdateRequest request = new UpdateRequest(// <1>         "posts", // <2>         "1").         // end::update-request         request.fetchSource(true).         // tag::update-request-with-inline-script         // <1>         Map<String, Object> parameters = singletonMap("count", 4).         Script inline = new Script(ScriptType.INLINE, "painless", "ctx._source.field += params.count", // <2>         parameters).         // <3>         request.script(inline).         // end::update-request-with-inline-script         UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, updateResponse.getResult()).         assertEquals(4, updateResponse.getGetResult().getSource().get("field")).         request = new UpdateRequest("posts", "1").fetchSource(true).         // tag::update-request-with-stored-script         Script stored = new Script(ScriptType.STORED, null, "increment-field", // <1>         parameters).         // <2>         request.script(stored).         // end::update-request-with-stored-script         updateResponse = client.update(request, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, updateResponse.getResult()).         assertEquals(8, updateResponse.getGetResult().getSource().get("field")).     }     {         // tag::update-request-with-doc-as-map         Map<String, Object> jsonMap = new HashMap<>().         jsonMap.put("updated", new Date()).         jsonMap.put("reason", "daily update").         UpdateRequest request = new UpdateRequest("posts", "1").doc(// <1>         jsonMap).         // end::update-request-with-doc-as-map         UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, updateResponse.getResult()).     }     {         // tag::update-request-with-doc-as-xcontent         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.startObject().         {             builder.timeField("updated", new Date()).             builder.field("reason", "daily update").         }         builder.endObject().         UpdateRequest request = new UpdateRequest("posts", "1").doc(// <1>         builder).         // end::update-request-with-doc-as-xcontent         UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, updateResponse.getResult()).     }     {         // tag::update-request-shortcut         UpdateRequest request = new UpdateRequest("posts", "1").doc("updated", new Date(), "reason", // <1>         "daily update").         // end::update-request-shortcut         UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, updateResponse.getResult()).     }     {         // tag::update-request-with-doc-as-string         UpdateRequest request = new UpdateRequest("posts", "1").         String jsonString = "{" + "\"updated\":\"2017-01-01\"," + "\"reason\":\"daily update\"" + "}".         // <1>         request.doc(jsonString, XContentType.JSON).         // end::update-request-with-doc-as-string         request.fetchSource(true).         // tag::update-execute         UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         // end::update-execute         assertEquals(DocWriteResponse.Result.UPDATED, updateResponse.getResult()).         // tag::update-response         String index = updateResponse.getIndex().         String id = updateResponse.getId().         long version = updateResponse.getVersion().         if (updateResponse.getResult() == DocWriteResponse.Result.CREATED) {         // <1>         } else if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {         // <2>         } else if (updateResponse.getResult() == DocWriteResponse.Result.DELETED) {         // <3>         } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {         // <4>         }         // end::update-response         // tag::update-getresult         // <1>         GetResult result = updateResponse.getGetResult().         if (result.isExists()) {             // <2>             String sourceAsString = result.sourceAsString().             // <3>             Map<String, Object> sourceAsMap = result.sourceAsMap().             // <4>             byte[] sourceAsBytes = result.source().         } else {         // <5>         }         // end::update-getresult         assertNotNull(result).         assertEquals(3, result.sourceAsMap().size()).         // tag::update-failure         ReplicationResponse.ShardInfo shardInfo = updateResponse.getShardInfo().         if (shardInfo.getTotal() != shardInfo.getSuccessful()) {         // <1>         }         if (shardInfo.getFailed() > 0) {             for (ReplicationResponse.ShardInfo.Failure failure : shardInfo.getFailures()) {                 // <2>                 String reason = failure.reason().             }         }     // end::update-failure     }     {         // tag::update-docnotfound         UpdateRequest request = new UpdateRequest("posts", "does_not_exist").doc("field", "value").         try {             UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException e) {             if (e.status() == RestStatus.NOT_FOUND) {             // <1>             }         }     // end::update-docnotfound     }     {         // tag::update-conflict         UpdateRequest request = new UpdateRequest("posts", "1").doc("field", "value").setIfSeqNo(101L).setIfPrimaryTerm(200L).         try {             UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException e) {             if (e.status() == RestStatus.CONFLICT) {             // <1>             }         }     // end::update-conflict     }     {         UpdateRequest request = new UpdateRequest("posts", "1").doc("reason", "no source").         // tag::update-request-no-source         // <1>         request.fetchSource(true).         // end::update-request-no-source         UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, updateResponse.getResult()).         assertNotNull(updateResponse.getGetResult()).         assertEquals(3, updateResponse.getGetResult().sourceAsMap().size()).     }     {         UpdateRequest request = new UpdateRequest("posts", "1").doc("reason", "source includes").         // tag::update-request-source-include         String[] includes = new String[] { "updated", "r*" }.         String[] excludes = Strings.EMPTY_ARRAY.         request.fetchSource(// <1>         new FetchSourceContext(true, includes, excludes)).         // end::update-request-source-include         UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, updateResponse.getResult()).         Map<String, Object> sourceAsMap = updateResponse.getGetResult().sourceAsMap().         assertEquals(2, sourceAsMap.size()).         assertEquals("source includes", sourceAsMap.get("reason")).         assertTrue(sourceAsMap.containsKey("updated")).     }     {         UpdateRequest request = new UpdateRequest("posts", "1").doc("reason", "source excludes").         // tag::update-request-source-exclude         String[] includes = Strings.EMPTY_ARRAY.         String[] excludes = new String[] { "updated" }.         request.fetchSource(// <1>         new FetchSourceContext(true, includes, excludes)).         // end::update-request-source-exclude         UpdateResponse updateResponse = client.update(request, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.UPDATED, updateResponse.getResult()).         Map<String, Object> sourceAsMap = updateResponse.getGetResult().sourceAsMap().         assertEquals(2, sourceAsMap.size()).         assertEquals("source excludes", sourceAsMap.get("reason")).         assertTrue(sourceAsMap.containsKey("field")).     }     {         UpdateRequest request = new UpdateRequest("posts", "id").         // tag::update-request-routing         // <1>         request.routing("routing").         // end::update-request-routing         // tag::update-request-timeout         // <1>         request.timeout(TimeValue.timeValueSeconds(1)).         // <2>         request.timeout("1s").         // end::update-request-timeout         // tag::update-request-retry         // <1>         request.retryOnConflict(3).         // end::update-request-retry         // tag::update-request-refresh         // <1>         request.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL).         // <2>         request.setRefreshPolicy("wait_for").         // end::update-request-refresh         // tag::update-request-cas         // <1>         request.setIfSeqNo(2L).         // <2>         request.setIfPrimaryTerm(1L).         // end::update-request-cas         // tag::update-request-detect-noop         // <1>         request.detectNoop(false).         // end::update-request-detect-noop         // tag::update-request-upsert         String jsonString = "{\"created\":\"2017-01-01\"}".         // <1>         request.upsert(jsonString, XContentType.JSON).         // end::update-request-upsert         // tag::update-request-scripted-upsert         // <1>         request.scriptedUpsert(true).         // end::update-request-scripted-upsert         // tag::update-request-doc-upsert         // <1>         request.docAsUpsert(true).         // end::update-request-doc-upsert         // tag::update-request-active-shards         // <1>         request.waitForActiveShards(2).         // <2>         request.waitForActiveShards(ActiveShardCount.ALL).     // end::update-request-active-shards     }     {         UpdateRequest request = new UpdateRequest("posts", "async").doc("reason", "async update").docAsUpsert(true).         ActionListener<UpdateResponse> listener.         // tag::update-execute-listener         listener = new ActionListener<UpdateResponse>() {              @Override             public void onResponse(UpdateResponse updateResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::update-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::update-execute-async         // <1>         client.updateAsync(request, RequestOptions.DEFAULT, listener).         // end::update-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(DeleteResponse deleteResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;122;;@SuppressWarnings("unused") public void testDelete() throws Exception {     RestHighLevelClient client = highLevelClient().     {         IndexRequest indexRequest = new IndexRequest("posts").id("1").source("field", "value").         IndexResponse indexResponse = client.index(indexRequest, RequestOptions.DEFAULT).         assertSame(RestStatus.CREATED, indexResponse.status()).     }     {         // tag::delete-request         DeleteRequest request = new DeleteRequest(// <1>         "posts", // <2>         "1").         // end::delete-request         // tag::delete-execute         DeleteResponse deleteResponse = client.delete(request, RequestOptions.DEFAULT).         // end::delete-execute         assertSame(DocWriteResponse.Result.DELETED, deleteResponse.getResult()).         // tag::delete-response         String index = deleteResponse.getIndex().         String id = deleteResponse.getId().         long version = deleteResponse.getVersion().         ReplicationResponse.ShardInfo shardInfo = deleteResponse.getShardInfo().         if (shardInfo.getTotal() != shardInfo.getSuccessful()) {         // <1>         }         if (shardInfo.getFailed() > 0) {             for (ReplicationResponse.ShardInfo.Failure failure : shardInfo.getFailures()) {                 // <2>                 String reason = failure.reason().             }         }     // end::delete-response     }     {         DeleteRequest request = new DeleteRequest("posts", "1").         // tag::delete-request-routing         // <1>         request.routing("routing").         // end::delete-request-routing         // tag::delete-request-timeout         // <1>         request.timeout(TimeValue.timeValueMinutes(2)).         // <2>         request.timeout("2m").         // end::delete-request-timeout         // tag::delete-request-refresh         // <1>         request.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL).         // <2>         request.setRefreshPolicy("wait_for").         // end::delete-request-refresh         // tag::delete-request-version         // <1>         request.version(2).         // end::delete-request-version         // tag::delete-request-version-type         // <1>         request.versionType(VersionType.EXTERNAL).     // end::delete-request-version-type     }     {         // tag::delete-notfound         DeleteRequest request = new DeleteRequest("posts", "does_not_exist").         DeleteResponse deleteResponse = client.delete(request, RequestOptions.DEFAULT).         if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {         // <1>         }     // end::delete-notfound     }     {         IndexResponse indexResponse = client.index(new IndexRequest("posts").id("1").source("field", "value"), RequestOptions.DEFAULT).         assertSame(RestStatus.CREATED, indexResponse.status()).         // tag::delete-conflict         try {             DeleteResponse deleteResponse = client.delete(new DeleteRequest("posts", "1").setIfSeqNo(100).setIfPrimaryTerm(2), RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.CONFLICT) {             // <1>             }         }     // end::delete-conflict     }     {         IndexResponse indexResponse = client.index(new IndexRequest("posts").id("async").source("field", "value"), RequestOptions.DEFAULT).         assertSame(RestStatus.CREATED, indexResponse.status()).         DeleteRequest request = new DeleteRequest("posts", "async").         ActionListener<DeleteResponse> listener.         // tag::delete-execute-listener         listener = new ActionListener<DeleteResponse>() {              @Override             public void onResponse(DeleteResponse deleteResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::delete-execute-async         // <1>         client.deleteAsync(request, RequestOptions.DEFAULT, listener).         // end::delete-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(BulkResponse bulkResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;113;;@SuppressWarnings("unused") public void testBulk() throws Exception {     RestHighLevelClient client = highLevelClient().     {         // tag::bulk-request         // <1>         BulkRequest request = new BulkRequest().         request.add(// <2>         new IndexRequest("posts").id("1").source(XContentType.JSON, "field", "foo")).         request.add(// <3>         new IndexRequest("posts").id("2").source(XContentType.JSON, "field", "bar")).         request.add(// <4>         new IndexRequest("posts").id("3").source(XContentType.JSON, "field", "baz")).         // end::bulk-request         // tag::bulk-execute         BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT).         // end::bulk-execute         assertSame(RestStatus.OK, bulkResponse.status()).         assertFalse(bulkResponse.hasFailures()).     }     {         // tag::bulk-request-with-mixed-operations         BulkRequest request = new BulkRequest().         // <1>         request.add(new DeleteRequest("posts", "3")).         request.add(// <2>         new UpdateRequest("posts", "2").doc(XContentType.JSON, "other", "test")).         request.add(// <3>         new IndexRequest("posts").id("4").source(XContentType.JSON, "field", "baz")).         // end::bulk-request-with-mixed-operations         BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT).         assertSame(RestStatus.OK, bulkResponse.status()).         assertFalse(bulkResponse.hasFailures()).         // tag::bulk-response         for (BulkItemResponse bulkItemResponse : bulkResponse) {             // <1>             // <2>             DocWriteResponse itemResponse = bulkItemResponse.getResponse().             switch(bulkItemResponse.getOpType()) {                 // <3>                 case INDEX:                 case CREATE:                     IndexResponse indexResponse = (IndexResponse) itemResponse.                     break.                 case // <4>                 UPDATE:                     UpdateResponse updateResponse = (UpdateResponse) itemResponse.                     break.                 case // <5>                 DELETE:                     DeleteResponse deleteResponse = (DeleteResponse) itemResponse.             }         }         // tag::bulk-has-failures         if (bulkResponse.hasFailures()) {         // <1>         }         // tag::bulk-errors         for (BulkItemResponse bulkItemResponse : bulkResponse) {             if (bulkItemResponse.isFailed()) {                 // <1>                 BulkItemResponse.Failure failure = // <2>                 bulkItemResponse.getFailure().             }         }     // end::bulk-errors     }     {         BulkRequest request = new BulkRequest().         // tag::bulk-request-timeout         // <1>         request.timeout(TimeValue.timeValueMinutes(2)).         // <2>         request.timeout("2m").         // end::bulk-request-timeout         // tag::bulk-request-refresh         // <1>         request.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL).         // <2>         request.setRefreshPolicy("wait_for").         // end::bulk-request-refresh         // tag::bulk-request-active-shards         // <1>         request.waitForActiveShards(2).         // <2>         request.waitForActiveShards(ActiveShardCount.ALL).         // end::bulk-request-active-shards         // tag::bulk-request-pipeline         // <1>         request.pipeline("pipelineId").         // end::bulk-request-pipeline         // tag::bulk-request-routing         // <1>         request.routing("routingId").         // end::bulk-request-routing         // tag::bulk-request-index-type         // <1>         BulkRequest defaulted = new BulkRequest("posts").         // end::bulk-request-index-type         // tag::bulk-execute-listener         ActionListener<BulkResponse> listener = new ActionListener<BulkResponse>() {              @Override             public void onResponse(BulkResponse bulkResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::bulk-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::bulk-execute-async         // <1>         client.bulkAsync(request, RequestOptions.DEFAULT, listener).         // end::bulk-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(BulkByScrollResponse bulkResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;149;;@SuppressWarnings("unused") public void testReindex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         String mapping = "  \"properties\": {\n" + "    \"user\": {\n" + "      \"type\": \"text\"\n" + "    },\n" + "    \"field1\": {\n" + "      \"type\": \"integer\"\n" + "    },\n" + "    \"field2\": {\n" + "      \"type\": \"integer\"\n" + "    }\n" + "  }".         createIndex("source1", Settings.EMPTY, mapping).         createIndex("source2", Settings.EMPTY, mapping).         createPipeline("my_pipeline").     }     {         // tag::reindex-request         // <1>         ReindexRequest request = new ReindexRequest().         // <2>         request.setSourceIndices("source1", "source2").         // <3>         request.setDestIndex("dest").         // end::reindex-request         // tag::reindex-request-versionType         // <1>         request.setDestVersionType(VersionType.EXTERNAL).         // end::reindex-request-versionType         // tag::reindex-request-opType         // <1>         request.setDestOpType("create").         // end::reindex-request-opType         // tag::reindex-request-conflicts         // <1>         request.setConflicts("proceed").         // end::reindex-request-conflicts         // tag::reindex-request-size         // <1>         request.setSize(10).         // end::reindex-request-size         // tag::reindex-request-sourceSize         // <1>         request.setSourceBatchSize(100).         // end::reindex-request-sourceSize         // tag::reindex-request-pipeline         // <1>         request.setDestPipeline("my_pipeline").         // end::reindex-request-pipeline         // tag::reindex-request-sort         // <1>         request.addSortField("field1", SortOrder.DESC).         // <2>         request.addSortField("field2", SortOrder.ASC).         // end::reindex-request-sort         // tag::reindex-request-script         request.setScript(new Script(ScriptType.INLINE, "painless", "if (ctx._source.user == 'kimchy') {ctx._source.likes++.}", // <1>         Collections.emptyMap())).         // end::reindex-request-script         HttpHost host = getClusterHosts().get(0).         Integer remotePort = host.getPort().         String remoteHost = host.getHostName().         String user = "test_user".         String password = "test-password".         // tag::reindex-request-remote         request.setRemoteInfo(new RemoteInfo("http", remoteHost, remotePort, null, new BytesArray(new MatchAllQueryBuilder().toString()), user, password, Collections.emptyMap(), new TimeValue(100, TimeUnit.MILLISECONDS), new TimeValue(100, TimeUnit.SECONDS))).         // <1>         // end::reindex-request-remote         // tag::reindex-request-timeout         // <1>         request.setTimeout(TimeValue.timeValueMinutes(2)).         // end::reindex-request-timeout         // tag::reindex-request-refresh         // <1>         request.setRefresh(true).         // end::reindex-request-refresh         // tag::reindex-request-scroll         // <1>         request.setScroll(TimeValue.timeValueMinutes(10)).         // end::reindex-request-scroll         // tag::reindex-execute         BulkByScrollResponse bulkResponse = client.reindex(request, RequestOptions.DEFAULT).         // end::reindex-execute         assertSame(0, bulkResponse.getSearchFailures().size()).         assertSame(0, bulkResponse.getBulkFailures().size()).         // tag::reindex-response         // <1>         TimeValue timeTaken = bulkResponse.getTook().         // <2>         boolean timedOut = bulkResponse.isTimedOut().         // <3>         long totalDocs = bulkResponse.getTotal().         // <4>         long updatedDocs = bulkResponse.getUpdated().         // <5>         long createdDocs = bulkResponse.getCreated().         // <6>         long deletedDocs = bulkResponse.getDeleted().         // <7>         long batches = bulkResponse.getBatches().         // <8>         long noops = bulkResponse.getNoops().         // <9>         long versionConflicts = bulkResponse.getVersionConflicts().         // <10>         long bulkRetries = bulkResponse.getBulkRetries().         // <11>         long searchRetries = bulkResponse.getSearchRetries().         // <12>         TimeValue throttledMillis = bulkResponse.getStatus().getThrottled().         TimeValue throttledUntilMillis = // <13>         bulkResponse.getStatus().getThrottledUntil().         List<ScrollableHitSource.SearchFailure> searchFailures = // <14>         bulkResponse.getSearchFailures().         List<BulkItemResponse.Failure> bulkFailures = // <15>         bulkResponse.getBulkFailures().     // end::reindex-response     }     {         ReindexRequest request = new ReindexRequest().         request.setSourceIndices("source1").         request.setDestIndex("dest").         // These cannot be set with a remote set, so its set here instead for the docs         // tag::reindex-request-query         // <1>         request.setSourceQuery(new TermQueryBuilder("user", "kimchy")).         // end::reindex-request-query         // tag::reindex-request-slices         // <1>         request.setSlices(2).         // end::reindex-request-slices         ActionListener<BulkByScrollResponse> listener.         // tag::reindex-execute-listener         listener = new ActionListener<BulkByScrollResponse>() {              @Override             public void onResponse(BulkByScrollResponse bulkResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::reindex-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::reindex-execute-async         // <1>         client.reindexAsync(request, RequestOptions.DEFAULT, listener).         // end::reindex-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(ListTasksResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;55;;@SuppressWarnings("unused") public void testReindexRethrottle() throws Exception {     RestHighLevelClient client = highLevelClient().     TaskId taskId = new TaskId("oTUltX4IQMOUUVeiohTt8A:124").     {         // tag::rethrottle-disable-request         // <1>         RethrottleRequest request = new RethrottleRequest(taskId).     // end::rethrottle-disable-request     }     {         // tag::rethrottle-request         // <1>         RethrottleRequest request = new RethrottleRequest(taskId, 100.0f).     // end::rethrottle-request     }     {         RethrottleRequest request = new RethrottleRequest(taskId).         // tag::rethrottle-request-execution         // <1>         client.reindexRethrottle(request, RequestOptions.DEFAULT).         // <2>         client.updateByQueryRethrottle(request, RequestOptions.DEFAULT).         // <3>         client.deleteByQueryRethrottle(request, RequestOptions.DEFAULT).     // end::rethrottle-request-execution     }     ActionListener<ListTasksResponse> listener.     // tag::rethrottle-request-async-listener     listener = new ActionListener<ListTasksResponse>() {          @Override         public void onResponse(ListTasksResponse response) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::rethrottle-request-async-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(3).     listener = new LatchedActionListener<>(listener, latch).     RethrottleRequest request = new RethrottleRequest(taskId).     // tag::rethrottle-execute-async     client.reindexRethrottleAsync(request, RequestOptions.DEFAULT, // <1>     listener).     client.updateByQueryRethrottleAsync(request, RequestOptions.DEFAULT, // <2>     listener).     client.deleteByQueryRethrottleAsync(request, RequestOptions.DEFAULT, // <3>     listener).     // end::rethrottle-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(BulkByScrollResponse bulkResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;122;;@SuppressWarnings("unused") public void testUpdateByQuery() throws Exception {     RestHighLevelClient client = highLevelClient().     {         String mapping = "  \"properties\": {\n" + "    \"user\": {\n" + "      \"type\": \"text\"\n" + "    },\n" + "    \"field1\": {\n" + "      \"type\": \"integer\"\n" + "    },\n" + "    \"field2\": {\n" + "      \"type\": \"integer\"\n" + "    }\n" + "  }".         createIndex("source1", Settings.EMPTY, mapping).         createIndex("source2", Settings.EMPTY, mapping).         createPipeline("my_pipeline").     }     {         // tag::update-by-query-request         UpdateByQueryRequest request = // <1>         new UpdateByQueryRequest("source1", "source2").         // end::update-by-query-request         // tag::update-by-query-request-conflicts         // <1>         request.setConflicts("proceed").         // end::update-by-query-request-conflicts         // tag::update-by-query-request-query         // <1>         request.setQuery(new TermQueryBuilder("user", "kimchy")).         // end::update-by-query-request-query         // tag::update-by-query-request-size         // <1>         request.setSize(10).         // end::update-by-query-request-size         // tag::update-by-query-request-scrollSize         // <1>         request.setBatchSize(100).         // end::update-by-query-request-scrollSize         // tag::update-by-query-request-pipeline         // <1>         request.setPipeline("my_pipeline").         // end::update-by-query-request-pipeline         // tag::update-by-query-request-script         request.setScript(new Script(ScriptType.INLINE, "painless", "if (ctx._source.user == 'kimchy') {ctx._source.likes++.}", // <1>         Collections.emptyMap())).         // end::update-by-query-request-script         // tag::update-by-query-request-timeout         // <1>         request.setTimeout(TimeValue.timeValueMinutes(2)).         // end::update-by-query-request-timeout         // tag::update-by-query-request-refresh         // <1>         request.setRefresh(true).         // end::update-by-query-request-refresh         // tag::update-by-query-request-slices         // <1>         request.setSlices(2).         // end::update-by-query-request-slices         // tag::update-by-query-request-scroll         // <1>         request.setScroll(TimeValue.timeValueMinutes(10)).         // end::update-by-query-request-scroll         // tag::update-by-query-request-routing         // <1>         request.setRouting("=cat").         // end::update-by-query-request-routing         // tag::update-by-query-request-indicesOptions         // <1>         request.setIndicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN).         // end::update-by-query-request-indicesOptions         // tag::update-by-query-execute         BulkByScrollResponse bulkResponse = client.updateByQuery(request, RequestOptions.DEFAULT).         // end::update-by-query-execute         assertSame(0, bulkResponse.getSearchFailures().size()).         assertSame(0, bulkResponse.getBulkFailures().size()).         // tag::update-by-query-response         // <1>         TimeValue timeTaken = bulkResponse.getTook().         // <2>         boolean timedOut = bulkResponse.isTimedOut().         // <3>         long totalDocs = bulkResponse.getTotal().         // <4>         long updatedDocs = bulkResponse.getUpdated().         // <5>         long deletedDocs = bulkResponse.getDeleted().         // <6>         long batches = bulkResponse.getBatches().         // <7>         long noops = bulkResponse.getNoops().         // <8>         long versionConflicts = bulkResponse.getVersionConflicts().         // <9>         long bulkRetries = bulkResponse.getBulkRetries().         // <10>         long searchRetries = bulkResponse.getSearchRetries().         // <11>         TimeValue throttledMillis = bulkResponse.getStatus().getThrottled().         TimeValue throttledUntilMillis = // <12>         bulkResponse.getStatus().getThrottledUntil().         List<ScrollableHitSource.SearchFailure> searchFailures = // <13>         bulkResponse.getSearchFailures().         List<BulkItemResponse.Failure> bulkFailures = // <14>         bulkResponse.getBulkFailures().     // end::update-by-query-response     }     {         UpdateByQueryRequest request = new UpdateByQueryRequest().         request.indices("source1").         ActionListener<BulkByScrollResponse> listener.         // tag::update-by-query-execute-listener         listener = new ActionListener<BulkByScrollResponse>() {              @Override             public void onResponse(BulkByScrollResponse bulkResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::update-by-query-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::update-by-query-execute-async         // <1>         client.updateByQueryAsync(request, RequestOptions.DEFAULT, listener).         // end::update-by-query-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(BulkByScrollResponse bulkResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;110;;@SuppressWarnings("unused") public void testDeleteByQuery() throws Exception {     RestHighLevelClient client = highLevelClient().     {         String mapping = "  \"properties\": {\n" + "    \"user\": {\n" + "      \"type\": \"text\"\n" + "    },\n" + "    \"field1\": {\n" + "      \"type\": \"integer\"\n" + "    },\n" + "    \"field2\": {\n" + "      \"type\": \"integer\"\n" + "    }\n" + "  }".         createIndex("source1", Settings.EMPTY, mapping).         createIndex("source2", Settings.EMPTY, mapping).     }     {         // tag::delete-by-query-request         DeleteByQueryRequest request = // <1>         new DeleteByQueryRequest("source1", "source2").         // end::delete-by-query-request         // tag::delete-by-query-request-conflicts         // <1>         request.setConflicts("proceed").         // end::delete-by-query-request-conflicts         // tag::delete-by-query-request-query         // <1>         request.setQuery(new TermQueryBuilder("user", "kimchy")).         // end::delete-by-query-request-query         // tag::delete-by-query-request-size         // <1>         request.setSize(10).         // end::delete-by-query-request-size         // tag::delete-by-query-request-scrollSize         // <1>         request.setBatchSize(100).         // end::delete-by-query-request-scrollSize         // tag::delete-by-query-request-timeout         // <1>         request.setTimeout(TimeValue.timeValueMinutes(2)).         // end::delete-by-query-request-timeout         // tag::delete-by-query-request-refresh         // <1>         request.setRefresh(true).         // end::delete-by-query-request-refresh         // tag::delete-by-query-request-slices         // <1>         request.setSlices(2).         // end::delete-by-query-request-slices         // tag::delete-by-query-request-scroll         // <1>         request.setScroll(TimeValue.timeValueMinutes(10)).         // end::delete-by-query-request-scroll         // tag::delete-by-query-request-routing         // <1>         request.setRouting("=cat").         // end::delete-by-query-request-routing         // tag::delete-by-query-request-indicesOptions         // <1>         request.setIndicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN).         // end::delete-by-query-request-indicesOptions         // tag::delete-by-query-execute         BulkByScrollResponse bulkResponse = client.deleteByQuery(request, RequestOptions.DEFAULT).         // end::delete-by-query-execute         assertSame(0, bulkResponse.getSearchFailures().size()).         assertSame(0, bulkResponse.getBulkFailures().size()).         // tag::delete-by-query-response         // <1>         TimeValue timeTaken = bulkResponse.getTook().         // <2>         boolean timedOut = bulkResponse.isTimedOut().         // <3>         long totalDocs = bulkResponse.getTotal().         // <4>         long deletedDocs = bulkResponse.getDeleted().         // <5>         long batches = bulkResponse.getBatches().         // <6>         long noops = bulkResponse.getNoops().         // <7>         long versionConflicts = bulkResponse.getVersionConflicts().         // <8>         long bulkRetries = bulkResponse.getBulkRetries().         // <9>         long searchRetries = bulkResponse.getSearchRetries().         // <10>         TimeValue throttledMillis = bulkResponse.getStatus().getThrottled().         TimeValue throttledUntilMillis = // <11>         bulkResponse.getStatus().getThrottledUntil().         List<ScrollableHitSource.SearchFailure> searchFailures = // <12>         bulkResponse.getSearchFailures().         List<BulkItemResponse.Failure> bulkFailures = // <13>         bulkResponse.getBulkFailures().     // end::delete-by-query-response     }     {         DeleteByQueryRequest request = new DeleteByQueryRequest().         request.indices("source1").         ActionListener<BulkByScrollResponse> listener.         // tag::delete-by-query-execute-listener         listener = new ActionListener<BulkByScrollResponse>() {              @Override             public void onResponse(BulkByScrollResponse bulkResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-by-query-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::delete-by-query-execute-async         // <1>         client.deleteByQueryAsync(request, RequestOptions.DEFAULT, listener).         // end::delete-by-query-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetResponse getResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;173;;@SuppressWarnings("unused") public void testGet() throws Exception {     RestHighLevelClient client = highLevelClient().     {         Request createIndex = new Request("PUT", "/posts").         createIndex.setJsonEntity("{\n" + "    \"mappings\" : {\n" + "        \"properties\" : {\n" + "            \"message\" : {\n" + "                \"type\": \"text\",\n" + "                \"store\": true\n" + "            }\n" + "        }\n" + "    }\n" + "}").         Response response = client().performRequest(createIndex).         assertEquals(200, response.getStatusLine().getStatusCode()).         IndexRequest indexRequest = new IndexRequest("posts").id("1").source("user", "kimchy", "postDate", new Date(), "message", "trying out Elasticsearch").         IndexResponse indexResponse = client.index(indexRequest, RequestOptions.DEFAULT).         assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()).     }     {         // tag::get-request         GetRequest getRequest = new GetRequest(// <1>         "posts", // <2>         "1").         // end::get-request         // tag::get-execute         GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT).         // end::get-execute         assertTrue(getResponse.isExists()).         assertEquals(3, getResponse.getSourceAsMap().size()).         // tag::get-response         String index = getResponse.getIndex().         String id = getResponse.getId().         if (getResponse.isExists()) {             long version = getResponse.getVersion().             // <1>             String sourceAsString = getResponse.getSourceAsString().             // <2>             Map<String, Object> sourceAsMap = getResponse.getSourceAsMap().             // <3>             byte[] sourceAsBytes = getResponse.getSourceAsBytes().         } else {         // <4>         }     // end::get-response     }     {         GetRequest request = new GetRequest("posts", "1").         // tag::get-request-no-source         // <1>         request.fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE).         // end::get-request-no-source         GetResponse getResponse = client.get(request, RequestOptions.DEFAULT).         assertNull(getResponse.getSourceInternal()).     }     {         GetRequest request = new GetRequest("posts", "1").         // tag::get-request-source-include         String[] includes = new String[] { "message", "*Date" }.         String[] excludes = Strings.EMPTY_ARRAY.         FetchSourceContext fetchSourceContext = new FetchSourceContext(true, includes, excludes).         // <1>         request.fetchSourceContext(fetchSourceContext).         // end::get-request-source-include         GetResponse getResponse = client.get(request, RequestOptions.DEFAULT).         Map<String, Object> sourceAsMap = getResponse.getSourceAsMap().         assertEquals(2, sourceAsMap.size()).         assertEquals("trying out Elasticsearch", sourceAsMap.get("message")).         assertTrue(sourceAsMap.containsKey("postDate")).     }     {         GetRequest request = new GetRequest("posts", "1").         // tag::get-request-source-exclude         String[] includes = Strings.EMPTY_ARRAY.         String[] excludes = new String[] { "message" }.         FetchSourceContext fetchSourceContext = new FetchSourceContext(true, includes, excludes).         // <1>         request.fetchSourceContext(fetchSourceContext).         // end::get-request-source-exclude         GetResponse getResponse = client.get(request, RequestOptions.DEFAULT).         Map<String, Object> sourceAsMap = getResponse.getSourceAsMap().         assertEquals(2, sourceAsMap.size()).         assertEquals("kimchy", sourceAsMap.get("user")).         assertTrue(sourceAsMap.containsKey("postDate")).     }     {         GetRequest request = new GetRequest("posts", "1").         // tag::get-request-stored         // <1>         request.storedFields("message").         GetResponse getResponse = client.get(request, RequestOptions.DEFAULT).         // <2>         String message = getResponse.getField("message").getValue().         // end::get-request-stored         assertEquals("trying out Elasticsearch", message).         assertEquals(1, getResponse.getFields().size()).         assertNull(getResponse.getSourceInternal()).     }     {         GetRequest request = new GetRequest("posts", "1").         // tag::get-request-routing         // <1>         request.routing("routing").         // end::get-request-routing         // tag::get-request-preference         // <1>         request.preference("preference").         // end::get-request-preference         // tag::get-request-realtime         // <1>         request.realtime(false).         // end::get-request-realtime         // tag::get-request-refresh         // <1>         request.refresh(true).         // end::get-request-refresh         // tag::get-request-version         // <1>         request.version(2).         // end::get-request-version         // tag::get-request-version-type         // <1>         request.versionType(VersionType.EXTERNAL).     // end::get-request-version-type     }     {         GetRequest request = new GetRequest("posts", "1").         // tag::get-execute-listener         ActionListener<GetResponse> listener = new ActionListener<GetResponse>() {              @Override             public void onResponse(GetResponse getResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-execute-async         // <1>         client.getAsync(request, RequestOptions.DEFAULT, listener).         // end::get-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::get-indexnotfound         GetRequest request = new GetRequest("does_not_exist", "1").         try {             GetResponse getResponse = client.get(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException e) {             if (e.status() == RestStatus.NOT_FOUND) {             // <1>             }         }     // end::get-indexnotfound     }     {         // tag::get-conflict         try {             GetRequest request = new GetRequest("posts", "1").version(2).             GetResponse getResponse = client.get(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.CONFLICT) {             // <1>             }         }     // end::get-conflict     } }
false;public;1;4;;@Override public void onResponse(Boolean exists) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;41;;public void testExists() throws Exception {     RestHighLevelClient client = highLevelClient().     // tag::exists-request     GetRequest getRequest = new GetRequest(// <1>     "posts", // <2>     "1").     // <3>     getRequest.fetchSourceContext(new FetchSourceContext(false)).     // <4>     getRequest.storedFields("_none_").     // end::exists-request     {         // tag::exists-execute         boolean exists = client.exists(getRequest, RequestOptions.DEFAULT).         // end::exists-execute         assertFalse(exists).     }     {         // tag::exists-execute-listener         ActionListener<Boolean> listener = new ActionListener<Boolean>() {              @Override             public void onResponse(Boolean exists) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::exists-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::exists-execute-async         // <1>         client.existsAsync(getRequest, RequestOptions.DEFAULT, listener).         // end::exists-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;2;4;;@Override public void beforeBulk(long executionId, BulkRequest request) { // <2> }
false;public;3;5;;@Override public void afterBulk(long executionId, BulkRequest request, BulkResponse response) { // <3> }
false;public;3;5;;@Override public void afterBulk(long executionId, BulkRequest request, Throwable failure) { // <4> }
false;public;2;6;;@Override public void beforeBulk(long executionId, BulkRequest request) {     // <1>     int numberOfActions = request.numberOfActions().     logger.debug("Executing bulk [{}] with {} requests", executionId, numberOfActions). }
false;public;3;10;;@Override public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {     if (response.hasFailures()) {         // <2>         logger.warn("Bulk [{}] executed with failures", executionId).     } else {         logger.debug("Bulk [{}] completed in {} milliseconds", executionId, response.getTook().getMillis()).     } }
false;public;3;5;;@Override public void afterBulk(long executionId, BulkRequest request, Throwable failure) {     // <3>     logger.error("Failed to execute bulk", failure). }
false;public;0;98;;public void testBulkProcessor() throws InterruptedException {     RestHighLevelClient client = highLevelClient().     {         // tag::bulk-processor-init         BulkProcessor.Listener listener = new // <1>         BulkProcessor.Listener() {              @Override             public void beforeBulk(long executionId, BulkRequest request) {             // <2>             }              @Override             public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {             // <3>             }              @Override             public void afterBulk(long executionId, BulkRequest request, Throwable failure) {             // <4>             }         }.         BulkProcessor bulkProcessor = BulkProcessor.builder((request, bulkListener) -> client.bulkAsync(request, RequestOptions.DEFAULT, bulkListener), listener).build().         // end::bulk-processor-init         assertNotNull(bulkProcessor).         // tag::bulk-processor-add         IndexRequest one = new IndexRequest("posts").id("1").source(XContentType.JSON, "title", "In which order are my Elasticsearch queries executed?").         IndexRequest two = new IndexRequest("posts").id("2").source(XContentType.JSON, "title", "Current status and upcoming changes in Elasticsearch").         IndexRequest three = new IndexRequest("posts").id("3").source(XContentType.JSON, "title", "The Future of Federated Search in Elasticsearch").         bulkProcessor.add(one).         bulkProcessor.add(two).         bulkProcessor.add(three).         // end::bulk-processor-add         // tag::bulk-processor-await         // <1>         boolean terminated = bulkProcessor.awaitClose(30L, TimeUnit.SECONDS).         // end::bulk-processor-await         assertTrue(terminated).         // tag::bulk-processor-close         bulkProcessor.close().     // end::bulk-processor-close     }     {         // tag::bulk-processor-listener         BulkProcessor.Listener listener = new BulkProcessor.Listener() {              @Override             public void beforeBulk(long executionId, BulkRequest request) {                 // <1>                 int numberOfActions = request.numberOfActions().                 logger.debug("Executing bulk [{}] with {} requests", executionId, numberOfActions).             }              @Override             public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {                 if (response.hasFailures()) {                     // <2>                     logger.warn("Bulk [{}] executed with failures", executionId).                 } else {                     logger.debug("Bulk [{}] completed in {} milliseconds", executionId, response.getTook().getMillis()).                 }             }              @Override             public void afterBulk(long executionId, BulkRequest request, Throwable failure) {                 // <3>                 logger.error("Failed to execute bulk", failure).             }         }.         // end::bulk-processor-listener         // tag::bulk-processor-options         BulkProcessor.Builder builder = BulkProcessor.builder((request, bulkListener) -> client.bulkAsync(request, RequestOptions.DEFAULT, bulkListener), listener).         // <1>         builder.setBulkActions(500).         // <2>         builder.setBulkSize(new ByteSizeValue(1L, ByteSizeUnit.MB)).         // <3>         builder.setConcurrentRequests(0).         // <4>         builder.setFlushInterval(TimeValue.timeValueSeconds(10L)).         builder.setBackoffPolicy(BackoffPolicy.constantBackoff(TimeValue.timeValueSeconds(1L), // <5>         3)).     // end::bulk-processor-options     } }
false;public;1;4;;@Override public void onResponse(TermVectorsResponse termVectorsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
true;public;0;128;// Not entirely sure if _termvectors belongs to CRUD, and in the absence of a better place, will have it here ;// Not entirely sure if _termvectors belongs to CRUD, and in the absence of a better place, will have it here public void testTermVectors() throws Exception {     RestHighLevelClient client = highLevelClient().     CreateIndexRequest authorsRequest = new CreateIndexRequest("authors").mapping(XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("user").field("type", "keyword").endObject().endObject().endObject()).     CreateIndexResponse authorsResponse = client.indices().create(authorsRequest, RequestOptions.DEFAULT).     assertTrue(authorsResponse.isAcknowledged()).     client.index(new IndexRequest("index").id("1").source("user", "kimchy"), RequestOptions.DEFAULT).     Response refreshResponse = client().performRequest(new Request("POST", "/authors/_refresh")).     assertEquals(200, refreshResponse.getStatusLine().getStatusCode()).     {         // tag::term-vectors-request         TermVectorsRequest request = new TermVectorsRequest("authors", "1").         request.setFields("user").     // end::term-vectors-request     }     {         // tag::term-vectors-request-artificial         XContentBuilder docBuilder = XContentFactory.jsonBuilder().         docBuilder.startObject().field("user", "guest-user").endObject().         TermVectorsRequest request = new TermVectorsRequest("authors", // <1>         docBuilder).         // end::term-vectors-request-artificial         // tag::term-vectors-request-optional-arguments         // <1>         request.setFieldStatistics(false).         // <2>         request.setTermStatistics(true).         // <3>         request.setPositions(false).         // <4>         request.setOffsets(false).         // <5>         request.setPayloads(false).         Map<String, Integer> filterSettings = new HashMap<>().         filterSettings.put("max_num_terms", 3).         filterSettings.put("min_term_freq", 1).         filterSettings.put("max_term_freq", 10).         filterSettings.put("min_doc_freq", 1).         filterSettings.put("max_doc_freq", 100).         filterSettings.put("min_word_length", 1).         filterSettings.put("max_word_length", 10).         // <6>         request.setFilterSettings(filterSettings).         Map<String, String> perFieldAnalyzer = new HashMap<>().         perFieldAnalyzer.put("user", "keyword").         // <7>         request.setPerFieldAnalyzer(perFieldAnalyzer).         // <8>         request.setRealtime(false).         // <9>         request.setRouting("routing").     // end::term-vectors-request-optional-arguments     }     TermVectorsRequest request = new TermVectorsRequest("authors", "1").     request.setFields("user").     // tag::term-vectors-execute     TermVectorsResponse response = client.termvectors(request, RequestOptions.DEFAULT).     // end::term-vectors-execute     // tag::term-vectors-response     // <1>     String index = response.getIndex().     // <2>     String type = response.getType().     // <3>     String id = response.getId().     // <4>     boolean found = response.getFound().     if (response.getTermVectorsList() != null) {         // tag::term-vectors-term-vectors         for (TermVectorsResponse.TermVector tv : response.getTermVectorsList()) {             // <1>             String fieldname = tv.getFieldName().             // <2>             int docCount = tv.getFieldStatistics().getDocCount().             long sumTotalTermFreq = // <3>             tv.getFieldStatistics().getSumTotalTermFreq().             // <4>             long sumDocFreq = tv.getFieldStatistics().getSumDocFreq().             if (tv.getTerms() != null) {                 List<TermVectorsResponse.TermVector.Term> terms = // <5>                 tv.getTerms().                 for (TermVectorsResponse.TermVector.Term term : terms) {                     // <6>                     String termStr = term.getTerm().                     // <7>                     int termFreq = term.getTermFreq().                     // <8>                     int docFreq = term.getDocFreq().                     // <9>                     long totalTermFreq = term.getTotalTermFreq().                     // <10>                     float score = term.getScore().                     if (term.getTokens() != null) {                         List<TermVectorsResponse.TermVector.Token> tokens = // <11>                         term.getTokens().                         for (TermVectorsResponse.TermVector.Token token : tokens) {                             // <12>                             int position = token.getPosition().                             // <13>                             int startOffset = token.getStartOffset().                             // <14>                             int endOffset = token.getEndOffset().                             // <15>                             String payload = token.getPayload().                         }                     }                 }             }         }     // end::term-vectors-term-vectors     }     ActionListener<TermVectorsResponse> listener.     // tag::term-vectors-execute-listener     listener = new ActionListener<TermVectorsResponse>() {          @Override         public void onResponse(TermVectorsResponse termVectorsResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::term-vectors-execute-listener     CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::term-vectors-execute-async     // <1>     client.termvectorsAsync(request, RequestOptions.DEFAULT, listener).     // end::term-vectors-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(MultiTermVectorsResponse mtvResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
true;public;0;78;// Not entirely sure if _mtermvectors belongs to CRUD, and in the absence of a better place, will have it here ;// Not entirely sure if _mtermvectors belongs to CRUD, and in the absence of a better place, will have it here public void testMultiTermVectors() throws Exception {     RestHighLevelClient client = highLevelClient().     CreateIndexRequest authorsRequest = new CreateIndexRequest("authors").mapping(XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("user").field("type", "keyword").endObject().endObject().endObject()).     CreateIndexResponse authorsResponse = client.indices().create(authorsRequest, RequestOptions.DEFAULT).     assertTrue(authorsResponse.isAcknowledged()).     client.index(new IndexRequest("index").id("1").source("user", "kimchy"), RequestOptions.DEFAULT).     client.index(new IndexRequest("index").id("2").source("user", "s1monw"), RequestOptions.DEFAULT).     Response refreshResponse = client().performRequest(new Request("POST", "/authors/_refresh")).     assertEquals(200, refreshResponse.getStatusLine().getStatusCode()).     {         // tag::multi-term-vectors-request         // <1>         MultiTermVectorsRequest request = new MultiTermVectorsRequest().         TermVectorsRequest tvrequest1 = new TermVectorsRequest("authors", "1").         tvrequest1.setFields("user").         // <2>         request.add(tvrequest1).         XContentBuilder docBuilder = XContentFactory.jsonBuilder().         docBuilder.startObject().field("user", "guest-user").endObject().         TermVectorsRequest tvrequest2 = new TermVectorsRequest("authors", docBuilder).         // <3>         request.add(tvrequest2).     // end::multi-term-vectors-request     }     // tag::multi-term-vectors-request-template     TermVectorsRequest tvrequestTemplate = // <1>     new TermVectorsRequest("authors", "fake_id").     tvrequestTemplate.setFields("user").     String[] ids = { "1", "2" }.     MultiTermVectorsRequest request = // <2>     new MultiTermVectorsRequest(ids, tvrequestTemplate).     // end::multi-term-vectors-request-template     // tag::multi-term-vectors-execute     MultiTermVectorsResponse response = client.mtermvectors(request, RequestOptions.DEFAULT).     // end::multi-term-vectors-execute     // tag::multi-term-vectors-response     List<TermVectorsResponse> tvresponseList = // <1>     response.getTermVectorsResponses().     if (tvresponseList != null) {         for (TermVectorsResponse tvresponse : tvresponseList) {         }     }     // end::multi-term-vectors-response     ActionListener<MultiTermVectorsResponse> listener.     // tag::multi-term-vectors-execute-listener     listener = new ActionListener<MultiTermVectorsResponse>() {          @Override         public void onResponse(MultiTermVectorsResponse mtvResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::multi-term-vectors-execute-listener     CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::multi-term-vectors-execute-async     client.mtermvectorsAsync(request, RequestOptions.DEFAULT, // <1>     listener).     // end::multi-term-vectors-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(MultiGetResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;184;;@SuppressWarnings("unused") public void testMultiGet() throws Exception {     RestHighLevelClient client = highLevelClient().     {         Request createIndex = new Request("PUT", "/index").         createIndex.setJsonEntity("{\n" + "    \"mappings\" : {\n" + "        \"properties\" : {\n" + "            \"foo\" : {\n" + "                \"type\": \"text\",\n" + "                \"store\": true\n" + "            }\n" + "        }\n" + "    }\n" + "}").         Response response = client().performRequest(createIndex).         assertEquals(200, response.getStatusLine().getStatusCode()).     }     Map<String, Object> source = new HashMap<>().     source.put("foo", "val1").     source.put("bar", "val2").     source.put("baz", "val3").     client.index(new IndexRequest("index").id("example_id").source(source).setRefreshPolicy(RefreshPolicy.IMMEDIATE), RequestOptions.DEFAULT).     {         // tag::multi-get-request         MultiGetRequest request = new MultiGetRequest().         request.add(new MultiGetRequest.Item(// <1>         "index", // <2>         "example_id")).         // <3>         request.add(new MultiGetRequest.Item("index", "another_id")).         // end::multi-get-request         // Add a missing index so we can test it.         request.add(new MultiGetRequest.Item("missing_index", "id")).         // tag::multi-get-request-item-extras         request.add(new MultiGetRequest.Item("index", "with_routing").routing(// <1>         "some_routing")).         request.add(new MultiGetRequest.Item("index", "with_version").versionType(// <2>         VersionType.EXTERNAL).version(// <3>         10123L)).         // end::multi-get-request-item-extras         // tag::multi-get-request-top-level-extras         // <1>         request.preference("some_preference").         // <2>         request.realtime(false).         // <3>         request.refresh(true).         // end::multi-get-request-top-level-extras         // tag::multi-get-execute         MultiGetResponse response = client.mget(request, RequestOptions.DEFAULT).         // end::multi-get-execute         // tag::multi-get-response         MultiGetItemResponse firstItem = response.getResponses()[0].         // <1>         assertNull(firstItem.getFailure()).         // <2>         GetResponse firstGet = firstItem.getResponse().         String index = firstItem.getIndex().         String id = firstItem.getId().         if (firstGet.isExists()) {             long version = firstGet.getVersion().             // <3>             String sourceAsString = firstGet.getSourceAsString().             // <4>             Map<String, Object> sourceAsMap = firstGet.getSourceAsMap().             // <5>             byte[] sourceAsBytes = firstGet.getSourceAsBytes().         } else {         // <6>         }         // end::multi-get-response         assertTrue(firstGet.isExists()).         assertEquals(source, firstGet.getSource()).         MultiGetItemResponse missingIndexItem = response.getResponses()[2].         // tag::multi-get-indexnotfound         // <1>         assertNull(missingIndexItem.getResponse()).         // <2>         Exception e = missingIndexItem.getFailure().getFailure().         // <3>         ElasticsearchException ee = (ElasticsearchException) e.         // TODO status is broken! fix in a followup         // assertEquals(RestStatus.NOT_FOUND, ee.status()).        // <4>         assertThat(e.getMessage(), // <5>         containsString("reason=no such index [missing_index]")).         // end::multi-get-indexnotfound         ActionListener<MultiGetResponse> listener.         // tag::multi-get-execute-listener         listener = new ActionListener<MultiGetResponse>() {              @Override             public void onResponse(MultiGetResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::multi-get-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::multi-get-execute-async         // <1>         client.mgetAsync(request, RequestOptions.DEFAULT, listener).         // end::multi-get-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         MultiGetRequest request = new MultiGetRequest().         // tag::multi-get-request-no-source         request.add(new MultiGetRequest.Item("index", "example_id").fetchSourceContext(// <1>         FetchSourceContext.DO_NOT_FETCH_SOURCE)).         // end::multi-get-request-no-source         MultiGetItemResponse item = unwrapAndAssertExample(client.mget(request, RequestOptions.DEFAULT)).         assertNull(item.getResponse().getSource()).     }     {         MultiGetRequest request = new MultiGetRequest().         // tag::multi-get-request-source-include         String[] includes = new String[] { "foo", "*r" }.         String[] excludes = Strings.EMPTY_ARRAY.         FetchSourceContext fetchSourceContext = new FetchSourceContext(true, includes, excludes).         request.add(new MultiGetRequest.Item("index", "example_id").fetchSourceContext(// <1>         fetchSourceContext)).         // end::multi-get-request-source-include         MultiGetItemResponse item = unwrapAndAssertExample(client.mget(request, RequestOptions.DEFAULT)).         assertThat(item.getResponse().getSource(), hasEntry("foo", "val1")).         assertThat(item.getResponse().getSource(), hasEntry("bar", "val2")).         assertThat(item.getResponse().getSource(), not(hasKey("baz"))).     }     {         MultiGetRequest request = new MultiGetRequest().         // tag::multi-get-request-source-exclude         String[] includes = Strings.EMPTY_ARRAY.         String[] excludes = new String[] { "foo", "*r" }.         FetchSourceContext fetchSourceContext = new FetchSourceContext(true, includes, excludes).         request.add(new MultiGetRequest.Item("index", "example_id").fetchSourceContext(// <1>         fetchSourceContext)).         // end::multi-get-request-source-exclude         MultiGetItemResponse item = unwrapAndAssertExample(client.mget(request, RequestOptions.DEFAULT)).         assertThat(item.getResponse().getSource(), not(hasKey("foo"))).         assertThat(item.getResponse().getSource(), not(hasKey("bar"))).         assertThat(item.getResponse().getSource(), hasEntry("baz", "val3")).     }     {         MultiGetRequest request = new MultiGetRequest().         // tag::multi-get-request-stored         request.add(new MultiGetRequest.Item("index", "example_id").storedFields(// <1>         "foo")).         MultiGetResponse response = client.mget(request, RequestOptions.DEFAULT).         MultiGetItemResponse item = response.getResponses()[0].         // <2>         String value = item.getResponse().getField("foo").getValue().         // end::multi-get-request-stored         assertNull(item.getResponse().getSource()).         assertEquals("val1", value).     }     {         // tag::multi-get-conflict         MultiGetRequest request = new MultiGetRequest().         request.add(new MultiGetRequest.Item("index", "example_id").version(1000L)).         MultiGetResponse response = client.mget(request, RequestOptions.DEFAULT).         MultiGetItemResponse item = response.getResponses()[0].         // <1>         assertNull(item.getResponse()).         // <2>         Exception e = item.getFailure().getFailure().         // <3>         ElasticsearchException ee = (ElasticsearchException) e.         // TODO status is broken! fix in a followup         // assertEquals(RestStatus.CONFLICT, ee.status()).          // <4>         assertThat(e.getMessage(), containsString("version conflict, current version [1] is " + // <5>         "different than the one provided [1000]")).     // end::multi-get-conflict     } }
false;private;1;8;;private MultiGetItemResponse unwrapAndAssertExample(MultiGetResponse response) {     assertThat(response.getResponses(), arrayWithSize(1)).     MultiGetItemResponse item = response.getResponses()[0].     assertEquals("index", item.getIndex()).     assertEquals("_doc", item.getType()).     assertEquals("example_id", item.getId()).     return item. }
