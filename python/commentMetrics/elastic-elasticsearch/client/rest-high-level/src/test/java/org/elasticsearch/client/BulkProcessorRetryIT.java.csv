commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;4;;private static BulkProcessor.Builder initBulkProcessorBuilder(BulkProcessor.Listener listener) {     return BulkProcessor.builder((request, bulkListener) -> highLevelClient().bulkAsync(request, RequestOptions.DEFAULT, bulkListener), listener). }
false;public;0;4;;public void testBulkRejectionLoadWithoutBackoff() throws Exception {     boolean rejectedExecutionExpected = true.     executeBulkRejectionLoad(BackoffPolicy.noBackoff(), rejectedExecutionExpected). }
false;public;0;4;;public void testBulkRejectionLoadWithBackoff() throws Throwable {     boolean rejectedExecutionExpected = false.     executeBulkRejectionLoad(BackoffPolicy.exponentialBackoff(), rejectedExecutionExpected). }
false;public;2;3;;@Override public void beforeBulk(long executionId, BulkRequest request) { }
false;public;3;6;;@Override public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {     internalPolicy.logResponse(response).     responses.add(response).     latch.countDown(). }
false;public;3;5;;@Override public void afterBulk(long executionId, BulkRequest request, Throwable failure) {     responses.add(failure).     latch.countDown(). }
false;private;2;78;;private void executeBulkRejectionLoad(BackoffPolicy backoffPolicy, boolean rejectedExecutionExpected) throws Exception {     final CorrelatingBackoffPolicy internalPolicy = new CorrelatingBackoffPolicy(backoffPolicy).     final int numberOfAsyncOps = randomIntBetween(600, 700).     final CountDownLatch latch = new CountDownLatch(numberOfAsyncOps).     final Set<Object> responses = Collections.newSetFromMap(new ConcurrentHashMap<>()).     BulkProcessor bulkProcessor = initBulkProcessorBuilder(new BulkProcessor.Listener() {          @Override         public void beforeBulk(long executionId, BulkRequest request) {         }          @Override         public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {             internalPolicy.logResponse(response).             responses.add(response).             latch.countDown().         }          @Override         public void afterBulk(long executionId, BulkRequest request, Throwable failure) {             responses.add(failure).             latch.countDown().         }     }).setBulkActions(1).setConcurrentRequests(randomIntBetween(0, 100)).setBackoffPolicy(internalPolicy).build().     MultiGetRequest multiGetRequest = indexDocs(bulkProcessor, numberOfAsyncOps).     latch.await(10, TimeUnit.SECONDS).     bulkProcessor.close().     assertEquals(responses.size(), numberOfAsyncOps).     boolean rejectedAfterAllRetries = false.     for (Object response : responses) {         if (response instanceof BulkResponse) {             BulkResponse bulkResponse = (BulkResponse) response.             for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {                 if (bulkItemResponse.isFailed()) {                     BulkItemResponse.Failure failure = bulkItemResponse.getFailure().                     if (failure.getStatus() == RestStatus.TOO_MANY_REQUESTS) {                         if (rejectedExecutionExpected == false) {                             Iterator<TimeValue> backoffState = internalPolicy.backoffStateFor(bulkResponse).                             assertNotNull("backoffState is null (indicates a bulk request got rejected without retry)", backoffState).                             if (backoffState.hasNext()) {                                 // we're not expecting that we overwhelmed it even once when we maxed out the number of retries                                 throw new AssertionError("Got rejected although backoff policy would allow more retries", failure.getCause()).                             } else {                                 rejectedAfterAllRetries = true.                                 logger.debug("We maxed out the number of bulk retries and got rejected (this is ok).").                             }                         }                     } else {                         throw new AssertionError("Unexpected failure with status: " + failure.getStatus()).                     }                 }             }         } else {             Throwable t = (Throwable) response.             // we're not expecting any other errors             throw new AssertionError("Unexpected failure", t).         }     }     highLevelClient().indices().refresh(new RefreshRequest(), RequestOptions.DEFAULT).     int multiGetResponsesCount = highLevelClient().mget(multiGetRequest, RequestOptions.DEFAULT).getResponses().length.     if (rejectedExecutionExpected) {         assertThat(multiGetResponsesCount, lessThanOrEqualTo(numberOfAsyncOps)).     } else if (rejectedAfterAllRetries) {         assertThat(multiGetResponsesCount, lessThan(numberOfAsyncOps)).     } else {         assertThat(multiGetResponsesCount, equalTo(numberOfAsyncOps)).     } }
false;private,static;2;9;;private static MultiGetRequest indexDocs(BulkProcessor processor, int numDocs) {     MultiGetRequest multiGetRequest = new MultiGetRequest().     for (int i = 1. i <= numDocs. i++) {         processor.add(new IndexRequest(INDEX_NAME).id(Integer.toString(i)).source(XContentType.JSON, "field", randomRealisticUnicodeOfCodepointLengthBetween(1, 30))).         multiGetRequest.add(INDEX_NAME, Integer.toString(i)).     }     return multiGetRequest. }
false;public;1;3;;public Iterator<TimeValue> backoffStateFor(BulkResponse response) {     return correlations.get(response). }
true;public;1;9;// see also Retry.AbstractRetryHandler#onResponse(). ;// Assumption: This method is called from the same thread as the last call to the internal iterator's #hasNext() / #next() // see also Retry.AbstractRetryHandler#onResponse(). public void logResponse(BulkResponse response) {     Iterator<TimeValue> iterator = iterators.get().     // did we ever retry?     if (iterator != null) {         // we should correlate any iterator only once         iterators.remove().         correlations.put(response, iterator).     } }
false;public;0;4;;@Override public Iterator<TimeValue> iterator() {     return new CorrelatingIterator(iterators, delegate.iterator()). }
false;public;0;8;;@Override public boolean hasNext() {     // update on every invocation as we might get rescheduled on a different thread. Unfortunately, there is a chance that     // we pollute the thread local map with stale values. Due to the implementation of Retry and the life cycle of the     // enclosing class CorrelatingBackoffPolicy this should not pose a major problem though.     iterators.set(this).     return delegate.hasNext(). }
false;public;0;6;;@Override public TimeValue next() {     // update on every invocation     iterators.set(this).     return delegate.next(). }
