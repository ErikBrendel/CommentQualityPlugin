commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;0;1;;protected abstract T createTestInstance().
false;protected,abstract;2;1;;protected abstract void toXContent(T response, XContentBuilder builder) throws IOException.
false;protected,abstract;1;1;;protected abstract T fromXContent(XContentParser parser) throws IOException.
false;protected;0;3;;protected Predicate<String> randomFieldsExcludeFilter() {     return field -> false. }
false;protected;0;3;;protected String[] shuffleFieldsExceptions() {     return Strings.EMPTY_ARRAY. }
false;public;0;11;;public void testFromXContent() throws IOException {     xContentTester(this::createParser, this::createTestInstance, this::toXContent, this::fromXContent).supportsUnknownFields(true).randomFieldsExcludeFilter(randomFieldsExcludeFilter()).shuffleFieldsExceptions(shuffleFieldsExceptions()).test(). }
false;private;0;17;;@Before private void setupIndices() throws IOException {     int numIndices = randomIntBetween(1, 5).     indices = new HashMap<>(numIndices).     for (int i = 0. i < numIndices. i++) {         String indexName = "index_" + randomAlphaOfLength(10).         int numJobs = randomIntBetween(1, 5).         List<RollupJobCaps> jobs = new ArrayList<>(numJobs).         for (int j = 0. j < numJobs. j++) {             RollupJobConfig config = RollupJobConfigTests.randomRollupJobConfig(randomAlphaOfLength(10)).             jobs.add(new RollupJobCaps(config.getId(), config.getIndexPattern(), config.getRollupIndex(), createRollupFieldCaps(config))).         }         RollableIndexCaps cap = new RollableIndexCaps(indexName, jobs).         indices.put(indexName, cap).     } }
true;private,static;1;65;/**  * Lifted from core's RollupJobCaps, so that we can test without having to include this actual logic in the request  */ ;/**  * Lifted from core's RollupJobCaps, so that we can test without having to include this actual logic in the request  */ private static Map<String, RollupJobCaps.RollupFieldCaps> createRollupFieldCaps(final RollupJobConfig rollupJobConfig) {     final Map<String, List<Map<String, Object>>> tempFieldCaps = new HashMap<>().     final GroupConfig groupConfig = rollupJobConfig.getGroupConfig().     if (groupConfig != null) {         // Create RollupFieldCaps for the date histogram         final DateHistogramGroupConfig dateHistogram = groupConfig.getDateHistogram().         final Map<String, Object> dateHistogramAggCap = new HashMap<>().         dateHistogramAggCap.put("agg", DateHistogramAggregationBuilder.NAME).         dateHistogramAggCap.put("interval", dateHistogram.getInterval().toString()).         if (dateHistogram.getDelay() != null) {             dateHistogramAggCap.put("delay", dateHistogram.getDelay().toString()).         }         dateHistogramAggCap.put("time_zone", dateHistogram.getTimeZone()).         List<Map<String, Object>> dateAggCaps = tempFieldCaps.getOrDefault(dateHistogram.getField(), new ArrayList<>()).         dateAggCaps.add(dateHistogramAggCap).         tempFieldCaps.put(dateHistogram.getField(), dateAggCaps).         // Create RollupFieldCaps for the histogram         final HistogramGroupConfig histogram = groupConfig.getHistogram().         if (histogram != null) {             final Map<String, Object> histogramAggCap = new HashMap<>().             histogramAggCap.put("agg", HistogramAggregationBuilder.NAME).             histogramAggCap.put("interval", histogram.getInterval()).             Arrays.stream(rollupJobConfig.getGroupConfig().getHistogram().getFields()).forEach(field -> {                 List<Map<String, Object>> caps = tempFieldCaps.getOrDefault(field, new ArrayList<>()).                 caps.add(histogramAggCap).                 tempFieldCaps.put(field, caps).             }).         }         // Create RollupFieldCaps for the term         final TermsGroupConfig terms = groupConfig.getTerms().         if (terms != null) {             final Map<String, Object> termsAggCap = singletonMap("agg", TermsAggregationBuilder.NAME).             Arrays.stream(rollupJobConfig.getGroupConfig().getTerms().getFields()).forEach(field -> {                 List<Map<String, Object>> caps = tempFieldCaps.getOrDefault(field, new ArrayList<>()).                 caps.add(termsAggCap).                 tempFieldCaps.put(field, caps).             }).         }     }     // Create RollupFieldCaps for the metrics     final List<MetricConfig> metricsConfig = rollupJobConfig.getMetricsConfig().     if (metricsConfig.size() > 0) {         rollupJobConfig.getMetricsConfig().forEach(metricConfig -> {             final List<Map<String, Object>> metrics = metricConfig.getMetrics().stream().map(metric -> singletonMap("agg", (Object) metric)).collect(Collectors.toList()).             metrics.forEach(m -> {                 List<Map<String, Object>> caps = tempFieldCaps.getOrDefault(metricConfig.getField(), new ArrayList<>()).                 caps.add(m).                 tempFieldCaps.put(metricConfig.getField(), caps).             }).         }).     }     return Collections.unmodifiableMap(tempFieldCaps.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> new RollupJobCaps.RollupFieldCaps(e.getValue())))). }
