commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@After public void cleanUp() throws IOException {     new MlTestStateCleaner(logger, highLevelClient().machineLearning()).clearMlMetadata(). }
false;public;1;4;;@Override public void onResponse(PutJobResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;77;;public void testCreateJob() throws Exception {     RestHighLevelClient client = highLevelClient().     // tag::put-job-detector     Detector.Builder detectorBuilder = new Detector.Builder().setFunction(// <1>     "sum").setFieldName(// <2>     "total").setDetectorDescription(// <3>     "Sum of total").     // end::put-job-detector     // tag::put-job-analysis-config     // <1>     List<Detector> detectors = Collections.singletonList(detectorBuilder.build()).     AnalysisConfig.Builder analysisConfigBuilder = // <2>     new AnalysisConfig.Builder(detectors).setBucketSpan(// <3>     TimeValue.timeValueMinutes(10)).     // end::put-job-analysis-config     // tag::put-job-data-description     DataDescription.Builder dataDescriptionBuilder = new DataDescription.Builder().setTimeField(// <1>     "timestamp").     // end::put-job-data-description     {         String id = "job_1".         // tag::put-job-config         Job.Builder jobBuilder = // <1>         new Job.Builder(id).setAnalysisConfig(// <2>         analysisConfigBuilder).setDataDescription(// <3>         dataDescriptionBuilder).setDescription(// <4>         "Total sum of requests").         // end::put-job-config         // tag::put-job-request         // <1>         PutJobRequest request = new PutJobRequest(jobBuilder.build()).         // end::put-job-request         // tag::put-job-execute         PutJobResponse response = client.machineLearning().putJob(request, RequestOptions.DEFAULT).         // end::put-job-execute         // tag::put-job-response         // <1>         Date createTime = response.getResponse().getCreateTime().         // end::put-job-response         assertThat(createTime.getTime(), greaterThan(0L)).     }     {         String id = "job_2".         Job.Builder jobBuilder = new Job.Builder(id).setAnalysisConfig(analysisConfigBuilder).setDataDescription(dataDescriptionBuilder).setDescription("Total sum of requests").         PutJobRequest request = new PutJobRequest(jobBuilder.build()).         // tag::put-job-execute-listener         ActionListener<PutJobResponse> listener = new ActionListener<PutJobResponse>() {              @Override             public void onResponse(PutJobResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::put-job-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::put-job-execute-async         // <1>         client.machineLearning().putJobAsync(request, RequestOptions.DEFAULT, listener).         // end::put-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetJobResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;56;;public void testGetJob() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("get-machine-learning-job1").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     Job secondJob = MachineLearningIT.buildJob("get-machine-learning-job2").     client.machineLearning().putJob(new PutJobRequest(secondJob), RequestOptions.DEFAULT).     {         // tag::get-job-request         // <1>         GetJobRequest request = new GetJobRequest("get-machine-learning-job1", "get-machine-learning-job*").         // <2>         request.setAllowNoJobs(true).         // end::get-job-request         // tag::get-job-execute         GetJobResponse response = client.machineLearning().getJob(request, RequestOptions.DEFAULT).         // end::get-job-execute         // tag::get-job-response         // <1>         long numberOfJobs = response.count().         // <2>         List<Job> jobs = response.jobs().         // end::get-job-response         assertEquals(2, response.count()).         assertThat(response.jobs(), hasSize(2)).         assertThat(response.jobs().stream().map(Job::getId).collect(Collectors.toList()), containsInAnyOrder(job.getId(), secondJob.getId())).     }     {         GetJobRequest request = new GetJobRequest("get-machine-learning-job1", "get-machine-learning-job*").         // tag::get-job-execute-listener         ActionListener<GetJobResponse> listener = new ActionListener<GetJobResponse>() {              @Override             public void onResponse(GetJobResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-job-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-job-execute-async         // <1>         client.machineLearning().getJobAsync(request, RequestOptions.DEFAULT, listener).         // end::get-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(DeleteJobResponse deleteJobResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;63;;public void testDeleteJob() throws Exception {     RestHighLevelClient client = highLevelClient().     String jobId = "my-first-machine-learning-job".     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     Job secondJob = MachineLearningIT.buildJob("my-second-machine-learning-job").     client.machineLearning().putJob(new PutJobRequest(secondJob), RequestOptions.DEFAULT).     {         // tag::delete-job-request         // <1>         DeleteJobRequest deleteJobRequest = new DeleteJobRequest("my-first-machine-learning-job").         // end::delete-job-request         // tag::delete-job-request-force         // <1>         deleteJobRequest.setForce(false).         // end::delete-job-request-force         // tag::delete-job-request-wait-for-completion         // <1>         deleteJobRequest.setWaitForCompletion(true).         // end::delete-job-request-wait-for-completion         // tag::delete-job-execute         DeleteJobResponse deleteJobResponse = client.machineLearning().deleteJob(deleteJobRequest, RequestOptions.DEFAULT).         // end::delete-job-execute         // tag::delete-job-response         // <1>         Boolean isAcknowledged = deleteJobResponse.getAcknowledged().         // <2>         TaskId task = deleteJobResponse.getTask().         // end::delete-job-response         assertTrue(isAcknowledged).         assertNull(task).     }     {         // tag::delete-job-execute-listener         ActionListener<DeleteJobResponse> listener = new ActionListener<DeleteJobResponse>() {              @Override             public void onResponse(DeleteJobResponse deleteJobResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-job-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         DeleteJobRequest deleteJobRequest = new DeleteJobRequest("my-second-machine-learning-job").         // tag::delete-job-execute-async         // <1>         client.machineLearning().deleteJobAsync(deleteJobRequest, RequestOptions.DEFAULT, listener).         // end::delete-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(OpenJobResponse openJobResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;49;;public void testOpenJob() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("opening-my-first-machine-learning-job").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     Job secondJob = MachineLearningIT.buildJob("opening-my-second-machine-learning-job").     client.machineLearning().putJob(new PutJobRequest(secondJob), RequestOptions.DEFAULT).     {         // tag::open-job-request         // <1>         OpenJobRequest openJobRequest = new OpenJobRequest("opening-my-first-machine-learning-job").         // <2>         openJobRequest.setTimeout(TimeValue.timeValueMinutes(10)).         // end::open-job-request         // tag::open-job-execute         OpenJobResponse openJobResponse = client.machineLearning().openJob(openJobRequest, RequestOptions.DEFAULT).         // end::open-job-execute         // tag::open-job-response         // <1>         boolean isOpened = openJobResponse.isOpened().     // end::open-job-response     }     {         // tag::open-job-execute-listener         ActionListener<OpenJobResponse> listener = new ActionListener<OpenJobResponse>() {              @Override             public void onResponse(OpenJobResponse openJobResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::open-job-execute-listener         OpenJobRequest openJobRequest = new OpenJobRequest("opening-my-second-machine-learning-job").         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::open-job-execute-async         // <1>         client.machineLearning().openJobAsync(openJobRequest, RequestOptions.DEFAULT, listener).         // end::open-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(CloseJobResponse closeJobResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;55;;public void testCloseJob() throws Exception {     RestHighLevelClient client = highLevelClient().     {         Job job = MachineLearningIT.buildJob("closing-my-first-machine-learning-job").         client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).         client.machineLearning().openJob(new OpenJobRequest(job.getId()), RequestOptions.DEFAULT).         // tag::close-job-request         // <1>         CloseJobRequest closeJobRequest = new CloseJobRequest("closing-my-first-machine-learning-job", "otherjobs*").         // <2>         closeJobRequest.setForce(false).         // <3>         closeJobRequest.setAllowNoJobs(true).         // <4>         closeJobRequest.setTimeout(TimeValue.timeValueMinutes(10)).         // end::close-job-request         // tag::close-job-execute         CloseJobResponse closeJobResponse = client.machineLearning().closeJob(closeJobRequest, RequestOptions.DEFAULT).         // end::close-job-execute         // tag::close-job-response         // <1>         boolean isClosed = closeJobResponse.isClosed().     // end::close-job-response     }     {         Job job = MachineLearningIT.buildJob("closing-my-second-machine-learning-job").         client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).         client.machineLearning().openJob(new OpenJobRequest(job.getId()), RequestOptions.DEFAULT).         // tag::close-job-execute-listener         ActionListener<CloseJobResponse> listener = new ActionListener<CloseJobResponse>() {              @Override             public void onResponse(CloseJobResponse closeJobResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::close-job-execute-listener         CloseJobRequest closeJobRequest = new CloseJobRequest("closing-my-second-machine-learning-job").         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::close-job-execute-async         // <1>         client.machineLearning().closeJobAsync(closeJobRequest, RequestOptions.DEFAULT, listener).         // end::close-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PutJobResponse updateJobResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;87;;public void testUpdateJob() throws Exception {     RestHighLevelClient client = highLevelClient().     String jobId = "test-update-job".     Job tempJob = MachineLearningIT.buildJob(jobId).     Job job = new Job.Builder(tempJob).setAnalysisConfig(new AnalysisConfig.Builder(tempJob.getAnalysisConfig()).setCategorizationFieldName("categorization-field").setDetector(0, new Detector.Builder().setFieldName("total").setFunction("sum").setPartitionFieldName("mlcategory").setDetectorDescription(randomAlphaOfLength(10)).build())).build().     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     {         List<DetectionRule> detectionRules = Arrays.asList(new DetectionRule.Builder(Arrays.asList(RuleCondition.createTime(Operator.GT, 100L))).build()).         Map<String, Object> customSettings = new HashMap<>().         customSettings.put("custom-setting-1", "custom-value").         // tag::update-job-detector-options         JobUpdate.DetectorUpdate detectorUpdate = new // <1>         JobUpdate.DetectorUpdate(// <1>         0, // <2>         "detector description", // <3>         detectionRules).         // end::update-job-detector-options         // tag::update-job-options         JobUpdate update = // <1>         new JobUpdate.Builder(jobId).setDescription(// <2>         "My description").setAnalysisLimits(// <3>         new AnalysisLimits(1000L, null)).setBackgroundPersistInterval(// <4>         TimeValue.timeValueHours(3)).setCategorizationFilters(// <5>         Arrays.asList("categorization-filter")).setDetectorUpdates(// <6>         Arrays.asList(detectorUpdate)).setGroups(// <7>         Arrays.asList("job-group-1")).setResultsRetentionDays(// <8>         10L).setModelPlotConfig(// <9>         new ModelPlotConfig(true, null)).setModelSnapshotRetentionDays(// <10>         7L).setCustomSettings(// <11>         customSettings).setRenormalizationWindowDays(// <12>         3L).build().         // end::update-job-options         // tag::update-job-request         // <1>         UpdateJobRequest updateJobRequest = new UpdateJobRequest(update).         // end::update-job-request         // tag::update-job-execute         PutJobResponse updateJobResponse = client.machineLearning().updateJob(updateJobRequest, RequestOptions.DEFAULT).         // end::update-job-execute         // tag::update-job-response         // <1>         Job updatedJob = updateJobResponse.getResponse().         // end::update-job-response         assertEquals(update.getDescription(), updatedJob.getDescription()).     }     {         // tag::update-job-execute-listener         ActionListener<PutJobResponse> listener = new ActionListener<PutJobResponse>() {              @Override             public void onResponse(PutJobResponse updateJobResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::update-job-execute-listener         UpdateJobRequest updateJobRequest = new UpdateJobRequest(new JobUpdate.Builder(jobId).build()).         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::update-job-execute-async         // <1>         client.machineLearning().updateJobAsync(updateJobRequest, RequestOptions.DEFAULT, listener).         // end::update-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PutDatafeedResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;107;;public void testPutDatafeed() throws Exception {     RestHighLevelClient client = highLevelClient().     {         // We need to create a job for the datafeed request to be valid         String jobId = "put-datafeed-job-1".         Job job = MachineLearningIT.buildJob(jobId).         client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).         String id = "datafeed-1".         // tag::put-datafeed-config         DatafeedConfig.Builder datafeedBuilder = // <1>         new DatafeedConfig.Builder(id, jobId).setIndices("index_1", // <2>         "index_2").         // end::put-datafeed-config         AggregatorFactories.Builder aggs = AggregatorFactories.builder().         // tag::put-datafeed-config-set-aggregations         // <1>         datafeedBuilder.setAggregations(aggs).         // end::put-datafeed-config-set-aggregations         // Clearing aggregation to avoid complex validation rules         datafeedBuilder.setAggregations((String) null).         // tag::put-datafeed-config-set-chunking-config         // <1>         datafeedBuilder.setChunkingConfig(ChunkingConfig.newAuto()).         // end::put-datafeed-config-set-chunking-config         // tag::put-datafeed-config-set-frequency         // <1>         datafeedBuilder.setFrequency(TimeValue.timeValueSeconds(30)).         // end::put-datafeed-config-set-frequency         // tag::put-datafeed-config-set-query         // <1>         datafeedBuilder.setQuery(QueryBuilders.matchAllQuery()).         // end::put-datafeed-config-set-query         // tag::put-datafeed-config-set-query-delay         // <1>         datafeedBuilder.setQueryDelay(TimeValue.timeValueMinutes(1)).         // end::put-datafeed-config-set-query-delay         // tag::put-datafeed-config-set-delayed-data-check-config         datafeedBuilder.setDelayedDataCheckConfig(DelayedDataCheckConfig.enabledDelayedDataCheckConfig(// <1>         TimeValue.timeValueHours(1))).         // end::put-datafeed-config-set-delayed-data-check-config         // no need to accidentally trip internal validations due to job bucket size         datafeedBuilder.setDelayedDataCheckConfig(null).         List<SearchSourceBuilder.ScriptField> scriptFields = Collections.emptyList().         // tag::put-datafeed-config-set-script-fields         // <1>         datafeedBuilder.setScriptFields(scriptFields).         // end::put-datafeed-config-set-script-fields         // tag::put-datafeed-config-set-scroll-size         // <1>         datafeedBuilder.setScrollSize(1000).         // end::put-datafeed-config-set-scroll-size         // tag::put-datafeed-request         // <1>         PutDatafeedRequest request = new PutDatafeedRequest(datafeedBuilder.build()).         // end::put-datafeed-request         // tag::put-datafeed-execute         PutDatafeedResponse response = client.machineLearning().putDatafeed(request, RequestOptions.DEFAULT).         // end::put-datafeed-execute         // tag::put-datafeed-response         // <1>         DatafeedConfig datafeed = response.getResponse().         // end::put-datafeed-response         assertThat(datafeed.getId(), equalTo("datafeed-1")).     }     {         // We need to create a job for the datafeed request to be valid         String jobId = "put-datafeed-job-2".         Job job = MachineLearningIT.buildJob(jobId).         client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).         String id = "datafeed-2".         DatafeedConfig datafeed = new DatafeedConfig.Builder(id, jobId).setIndices("index_1", "index_2").build().         PutDatafeedRequest request = new PutDatafeedRequest(datafeed).         // tag::put-datafeed-execute-listener         ActionListener<PutDatafeedResponse> listener = new ActionListener<PutDatafeedResponse>() {              @Override             public void onResponse(PutDatafeedResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::put-datafeed-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::put-datafeed-execute-async         // <1>         client.machineLearning().putDatafeedAsync(request, RequestOptions.DEFAULT, listener).         // end::put-datafeed-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PutDatafeedResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;70;;public void testUpdateDatafeed() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("update-datafeed-job").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     String datafeedId = job.getId() + "-feed".     DatafeedConfig datafeed = DatafeedConfig.builder(datafeedId, job.getId()).setIndices("foo").build().     client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed), RequestOptions.DEFAULT).     {         AggregatorFactories.Builder aggs = AggregatorFactories.builder().         List<SearchSourceBuilder.ScriptField> scriptFields = Collections.emptyList().         // tag::update-datafeed-config         DatafeedUpdate.Builder datafeedUpdateBuilder = // <1>         new DatafeedUpdate.Builder(datafeedId).setAggregations(// <2>         aggs).setIndices("index_1", // <3>         "index_2").setChunkingConfig(// <4>         ChunkingConfig.newAuto()).setFrequency(// <5>         TimeValue.timeValueSeconds(30)).setQuery(// <6>         QueryBuilders.matchAllQuery()).setQueryDelay(// <7>         TimeValue.timeValueMinutes(1)).setScriptFields(// <8>         scriptFields).setScrollSize(// <9>         1000).setJobId(// <10>         "update-datafeed-job").         // end::update-datafeed-config         // Clearing aggregation to avoid complex validation rules         datafeedUpdateBuilder.setAggregations((String) null).         // tag::update-datafeed-request         // <1>         UpdateDatafeedRequest request = new UpdateDatafeedRequest(datafeedUpdateBuilder.build()).         // end::update-datafeed-request         // tag::update-datafeed-execute         PutDatafeedResponse response = client.machineLearning().updateDatafeed(request, RequestOptions.DEFAULT).         // end::update-datafeed-execute         // tag::update-datafeed-response         // <1>         DatafeedConfig updatedDatafeed = response.getResponse().         // end::update-datafeed-response         assertThat(updatedDatafeed.getId(), equalTo(datafeedId)).     }     {         DatafeedUpdate datafeedUpdate = new DatafeedUpdate.Builder(datafeedId).setIndices("index_1", "index_2").build().         UpdateDatafeedRequest request = new UpdateDatafeedRequest(datafeedUpdate).         // tag::update-datafeed-execute-listener         ActionListener<PutDatafeedResponse> listener = new ActionListener<PutDatafeedResponse>() {              @Override             public void onResponse(PutDatafeedResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::update-datafeed-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::update-datafeed-execute-async         // <1>         client.machineLearning().updateDatafeedAsync(request, RequestOptions.DEFAULT, listener).         // end::update-datafeed-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetDatafeedResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;55;;public void testGetDatafeed() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("get-datafeed-job").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     String datafeedId = job.getId() + "-feed".     DatafeedConfig datafeed = DatafeedConfig.builder(datafeedId, job.getId()).setIndices("foo").build().     client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed), RequestOptions.DEFAULT).     {         // tag::get-datafeed-request         // <1>         GetDatafeedRequest request = new GetDatafeedRequest(datafeedId).         // <2>         request.setAllowNoDatafeeds(true).         // end::get-datafeed-request         // tag::get-datafeed-execute         GetDatafeedResponse response = client.machineLearning().getDatafeed(request, RequestOptions.DEFAULT).         // end::get-datafeed-execute         // tag::get-datafeed-response         // <1>         long numberOfDatafeeds = response.count().         // <2>         List<DatafeedConfig> datafeeds = response.datafeeds().         // end::get-datafeed-response         assertEquals(1, numberOfDatafeeds).         assertEquals(1, datafeeds.size()).     }     {         GetDatafeedRequest request = new GetDatafeedRequest(datafeedId).         // tag::get-datafeed-execute-listener         ActionListener<GetDatafeedResponse> listener = new ActionListener<GetDatafeedResponse>() {              @Override             public void onResponse(GetDatafeedResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-datafeed-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-datafeed-execute-async         // <1>         client.machineLearning().getDatafeedAsync(request, RequestOptions.DEFAULT, listener).         // end::get-datafeed-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse acknowledgedResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;58;;public void testDeleteDatafeed() throws Exception {     RestHighLevelClient client = highLevelClient().     String jobId = "test-delete-datafeed-job".     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     String datafeedId = "test-delete-datafeed".     DatafeedConfig datafeed = DatafeedConfig.builder(datafeedId, jobId).setIndices("foo").build().     client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed), RequestOptions.DEFAULT).     {         // tag::delete-datafeed-request         DeleteDatafeedRequest deleteDatafeedRequest = new DeleteDatafeedRequest(datafeedId).         // <1>         deleteDatafeedRequest.setForce(false).         // end::delete-datafeed-request         // tag::delete-datafeed-execute         AcknowledgedResponse deleteDatafeedResponse = client.machineLearning().deleteDatafeed(deleteDatafeedRequest, RequestOptions.DEFAULT).         // end::delete-datafeed-execute         // tag::delete-datafeed-response         // <1>         boolean isAcknowledged = deleteDatafeedResponse.isAcknowledged().     // end::delete-datafeed-response     }     // Recreate datafeed to allow second deletion     client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed), RequestOptions.DEFAULT).     {         // tag::delete-datafeed-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse acknowledgedResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-datafeed-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         DeleteDatafeedRequest deleteDatafeedRequest = new DeleteDatafeedRequest(datafeedId).         // tag::delete-datafeed-execute-async         // <1>         client.machineLearning().deleteDatafeedAsync(deleteDatafeedRequest, RequestOptions.DEFAULT, listener).         // end::delete-datafeed-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PreviewDatafeedResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;67;;public void testPreviewDatafeed() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("preview-datafeed-job").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     String datafeedId = job.getId() + "-feed".     String indexName = "preview_data_2".     CreateIndexRequest createIndexRequest = new CreateIndexRequest(indexName).     createIndexRequest.mapping(XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("timestamp").field("type", "date").endObject().startObject("total").field("type", "long").endObject().endObject().endObject()).     highLevelClient().indices().create(createIndexRequest, RequestOptions.DEFAULT).     DatafeedConfig datafeed = DatafeedConfig.builder(datafeedId, job.getId()).setIndices(indexName).build().     client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed), RequestOptions.DEFAULT).     {         // tag::preview-datafeed-request         // <1>         PreviewDatafeedRequest request = new PreviewDatafeedRequest(datafeedId).         // end::preview-datafeed-request         // tag::preview-datafeed-execute         PreviewDatafeedResponse response = client.machineLearning().previewDatafeed(request, RequestOptions.DEFAULT).         // end::preview-datafeed-execute         // tag::preview-datafeed-response         // <1>         BytesReference rawPreview = response.getPreview().         // <2>         List<Map<String, Object>> semiParsedPreview = response.getDataList().         // end::preview-datafeed-response         assertTrue(semiParsedPreview.isEmpty()).     }     {         PreviewDatafeedRequest request = new PreviewDatafeedRequest(datafeedId).         // tag::preview-datafeed-execute-listener         ActionListener<PreviewDatafeedResponse> listener = new ActionListener<PreviewDatafeedResponse>() {              @Override             public void onResponse(PreviewDatafeedResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::preview-datafeed-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::preview-datafeed-execute-async         // <1>         client.machineLearning().previewDatafeedAsync(request, RequestOptions.DEFAULT, listener).         // end::preview-datafeed-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(StartDatafeedResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;72;;public void testStartDatafeed() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("start-datafeed-job").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     String datafeedId = job.getId() + "-feed".     String indexName = "start_data_2".     CreateIndexRequest createIndexRequest = new CreateIndexRequest(indexName).     createIndexRequest.mapping(XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("timestamp").field("type", "date").endObject().startObject("total").field("type", "long").endObject().endObject().endObject()).     highLevelClient().indices().create(createIndexRequest, RequestOptions.DEFAULT).     DatafeedConfig datafeed = DatafeedConfig.builder(datafeedId, job.getId()).setIndices(indexName).build().     client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed), RequestOptions.DEFAULT).     client.machineLearning().openJob(new OpenJobRequest(job.getId()), RequestOptions.DEFAULT).     {         // tag::start-datafeed-request         // <1>         StartDatafeedRequest request = new StartDatafeedRequest(datafeedId).         // end::start-datafeed-request         // tag::start-datafeed-request-options         // <1>         request.setEnd("2018-08-21T00:00:00Z").         // <2>         request.setStart("2018-08-20T00:00:00Z").         // <3>         request.setTimeout(TimeValue.timeValueMinutes(10)).         // end::start-datafeed-request-options         // tag::start-datafeed-execute         StartDatafeedResponse response = client.machineLearning().startDatafeed(request, RequestOptions.DEFAULT).         // end::start-datafeed-execute         // tag::start-datafeed-response         // <1>         boolean started = response.isStarted().         // end::start-datafeed-response         assertTrue(started).     }     {         StartDatafeedRequest request = new StartDatafeedRequest(datafeedId).         // tag::start-datafeed-execute-listener         ActionListener<StartDatafeedResponse> listener = new ActionListener<StartDatafeedResponse>() {              @Override             public void onResponse(StartDatafeedResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::start-datafeed-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::start-datafeed-execute-async         // <1>         client.machineLearning().startDatafeedAsync(request, RequestOptions.DEFAULT, listener).         // end::start-datafeed-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(StopDatafeedResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;52;;public void testStopDatafeed() throws Exception {     RestHighLevelClient client = highLevelClient().     {         // tag::stop-datafeed-request         // <1>         StopDatafeedRequest request = new StopDatafeedRequest("datafeed_id1", "datafeed_id*").         // end::stop-datafeed-request         request = StopDatafeedRequest.stopAllDatafeedsRequest().         // tag::stop-datafeed-request-options         // <1>         request.setAllowNoDatafeeds(true).         // <2>         request.setForce(true).         // <3>         request.setTimeout(TimeValue.timeValueMinutes(10)).         // end::stop-datafeed-request-options         // tag::stop-datafeed-execute         StopDatafeedResponse response = client.machineLearning().stopDatafeed(request, RequestOptions.DEFAULT).         // end::stop-datafeed-execute         // tag::stop-datafeed-response         // <1>         boolean stopped = response.isStopped().         // end::stop-datafeed-response         assertTrue(stopped).     }     {         StopDatafeedRequest request = StopDatafeedRequest.stopAllDatafeedsRequest().         // tag::stop-datafeed-execute-listener         ActionListener<StopDatafeedResponse> listener = new ActionListener<StopDatafeedResponse>() {              @Override             public void onResponse(StopDatafeedResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::stop-datafeed-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::stop-datafeed-execute-async         // <1>         client.machineLearning().stopDatafeedAsync(request, RequestOptions.DEFAULT, listener).         // end::stop-datafeed-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetDatafeedStatsResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;82;;public void testGetDatafeedStats() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("get-machine-learning-datafeed-stats1").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     Job secondJob = MachineLearningIT.buildJob("get-machine-learning-datafeed-stats2").     client.machineLearning().putJob(new PutJobRequest(secondJob), RequestOptions.DEFAULT).     String datafeedId1 = job.getId() + "-feed".     String indexName = "datafeed_stats_data_2".     CreateIndexRequest createIndexRequest = new CreateIndexRequest(indexName).     createIndexRequest.mapping(XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("timestamp").field("type", "date").endObject().startObject("total").field("type", "long").endObject().endObject().endObject()).     highLevelClient().indices().create(createIndexRequest, RequestOptions.DEFAULT).     DatafeedConfig datafeed = DatafeedConfig.builder(datafeedId1, job.getId()).setIndices(indexName).build().     client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed), RequestOptions.DEFAULT).     String datafeedId2 = secondJob.getId() + "-feed".     DatafeedConfig secondDatafeed = DatafeedConfig.builder(datafeedId2, secondJob.getId()).setIndices(indexName).build().     client.machineLearning().putDatafeed(new PutDatafeedRequest(secondDatafeed), RequestOptions.DEFAULT).     {         // tag::get-datafeed-stats-request         GetDatafeedStatsRequest request = // <1>         new GetDatafeedStatsRequest("get-machine-learning-datafeed-stats1-feed", "get-machine-learning-datafeed*").         // <2>         request.setAllowNoDatafeeds(true).         // end::get-datafeed-stats-request         // tag::get-datafeed-stats-execute         GetDatafeedStatsResponse response = client.machineLearning().getDatafeedStats(request, RequestOptions.DEFAULT).         // end::get-datafeed-stats-execute         // tag::get-datafeed-stats-response         // <1>         long numberOfDatafeedStats = response.count().         // <2>         List<DatafeedStats> datafeedStats = response.datafeedStats().         // end::get-datafeed-stats-response         assertEquals(2, response.count()).         assertThat(response.datafeedStats(), hasSize(2)).         assertThat(response.datafeedStats().stream().map(DatafeedStats::getDatafeedId).collect(Collectors.toList()), containsInAnyOrder(datafeed.getId(), secondDatafeed.getId())).     }     {         GetDatafeedStatsRequest request = new GetDatafeedStatsRequest("*").         // tag::get-datafeed-stats-execute-listener         ActionListener<GetDatafeedStatsResponse> listener = new ActionListener<GetDatafeedStatsResponse>() {              @Override             public void onResponse(GetDatafeedStatsResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-datafeed-stats-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-datafeed-stats-execute-async         // <1>         client.machineLearning().getDatafeedStatsAsync(request, RequestOptions.DEFAULT, listener).         // end::get-datafeed-stats-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetBucketsResponse getBucketsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;100;;public void testGetBuckets() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId = "test-get-buckets".     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     // Let us index a bucket     IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared", "_doc").     indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     indexRequest.source("{\"job_id\":\"test-get-buckets\", \"result_type\":\"bucket\", \"timestamp\": 1533081600000," + "\"bucket_span\": 600,\"is_interim\": false, \"anomaly_score\": 80.0}", XContentType.JSON).     client.index(indexRequest, RequestOptions.DEFAULT).     {         // tag::get-buckets-request         // <1>         GetBucketsRequest request = new GetBucketsRequest(jobId).         // end::get-buckets-request         // tag::get-buckets-timestamp         // <1>         request.setTimestamp("2018-08-17T00:00:00Z").         // end::get-buckets-timestamp         // Set timestamp to null as it is incompatible with other args         request.setTimestamp(null).         // tag::get-buckets-anomaly-score         // <1>         request.setAnomalyScore(75.0).         // end::get-buckets-anomaly-score         // tag::get-buckets-desc         // <1>         request.setDescending(true).         // end::get-buckets-desc         // tag::get-buckets-end         // <1>         request.setEnd("2018-08-21T00:00:00Z").         // end::get-buckets-end         // tag::get-buckets-exclude-interim         // <1>         request.setExcludeInterim(true).         // end::get-buckets-exclude-interim         // tag::get-buckets-expand         // <1>         request.setExpand(true).         // end::get-buckets-expand         // tag::get-buckets-page         // <1>         request.setPageParams(new PageParams(100, 200)).         // end::get-buckets-page         // Set page params back to null so the response contains the bucket we indexed         request.setPageParams(null).         // tag::get-buckets-sort         // <1>         request.setSort("anomaly_score").         // end::get-buckets-sort         // tag::get-buckets-start         // <1>         request.setStart("2018-08-01T00:00:00Z").         // end::get-buckets-start         // tag::get-buckets-execute         GetBucketsResponse response = client.machineLearning().getBuckets(request, RequestOptions.DEFAULT).         // end::get-buckets-execute         // tag::get-buckets-response         // <1>         long count = response.count().         // <2>         List<Bucket> buckets = response.buckets().         // end::get-buckets-response         assertEquals(1, buckets.size()).     }     {         GetBucketsRequest request = new GetBucketsRequest(jobId).         // tag::get-buckets-execute-listener         ActionListener<GetBucketsResponse> listener = new ActionListener<GetBucketsResponse>() {              @Override             public void onResponse(GetBucketsResponse getBucketsResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-buckets-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-buckets-execute-async         // <1>         client.machineLearning().getBucketsAsync(request, RequestOptions.DEFAULT, listener).         // end::get-buckets-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(FlushJobResponse FlushJobResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;61;;public void testFlushJob() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("flushing-my-first-machine-learning-job").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     client.machineLearning().openJob(new OpenJobRequest(job.getId()), RequestOptions.DEFAULT).     Job secondJob = MachineLearningIT.buildJob("flushing-my-second-machine-learning-job").     client.machineLearning().putJob(new PutJobRequest(secondJob), RequestOptions.DEFAULT).     client.machineLearning().openJob(new OpenJobRequest(secondJob.getId()), RequestOptions.DEFAULT).     {         // tag::flush-job-request         // <1>         FlushJobRequest flushJobRequest = new FlushJobRequest("flushing-my-first-machine-learning-job").         // end::flush-job-request         // tag::flush-job-request-options         // <1>         flushJobRequest.setCalcInterim(true).         // <2>         flushJobRequest.setAdvanceTime("2018-08-31T16:35:07+00:00").         // <3>         flushJobRequest.setStart("2018-08-31T16:35:17+00:00").         // <4>         flushJobRequest.setEnd("2018-08-31T16:35:27+00:00").         // <5>         flushJobRequest.setSkipTime("2018-08-31T16:35:00+00:00").         // end::flush-job-request-options         // tag::flush-job-execute         FlushJobResponse flushJobResponse = client.machineLearning().flushJob(flushJobRequest, RequestOptions.DEFAULT).         // end::flush-job-execute         // tag::flush-job-response         // <1>         boolean isFlushed = flushJobResponse.isFlushed().         // <2>         Date lastFinalizedBucketEnd = flushJobResponse.getLastFinalizedBucketEnd().     // end::flush-job-response     }     {         // tag::flush-job-execute-listener         ActionListener<FlushJobResponse> listener = new ActionListener<FlushJobResponse>() {              @Override             public void onResponse(FlushJobResponse FlushJobResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::flush-job-execute-listener         FlushJobRequest flushJobRequest = new FlushJobRequest("flushing-my-second-machine-learning-job").         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::flush-job-execute-async         // <1>         client.machineLearning().flushJobAsync(flushJobRequest, RequestOptions.DEFAULT, listener).         // end::flush-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse DeleteForecastResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;78;;public void testDeleteForecast() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("deleting-forecast-for-job").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     client.machineLearning().openJob(new OpenJobRequest(job.getId()), RequestOptions.DEFAULT).     PostDataRequest.JsonBuilder builder = new PostDataRequest.JsonBuilder().     for (int i = 0. i < 30. i++) {         Map<String, Object> hashMap = new HashMap<>().         hashMap.put("total", randomInt(1000)).         hashMap.put("timestamp", (i + 1) * 1000).         builder.addDoc(hashMap).     }     PostDataRequest postDataRequest = new PostDataRequest(job.getId(), builder).     client.machineLearning().postData(postDataRequest, RequestOptions.DEFAULT).     client.machineLearning().flushJob(new FlushJobRequest(job.getId()), RequestOptions.DEFAULT).     ForecastJobResponse forecastJobResponse = client.machineLearning().forecastJob(new ForecastJobRequest(job.getId()), RequestOptions.DEFAULT).     String forecastId = forecastJobResponse.getForecastId().     GetRequest request = new GetRequest(".ml-anomalies-" + job.getId()).     request.id(job.getId() + "_model_forecast_request_stats_" + forecastId).     assertBusy(() -> {         GetResponse getResponse = highLevelClient().get(request, RequestOptions.DEFAULT).         assertTrue(getResponse.isExists()).         assertTrue(getResponse.getSourceAsString().contains("finished")).     }, 30, TimeUnit.SECONDS).     {         // tag::delete-forecast-request         // <1>         DeleteForecastRequest deleteForecastRequest = new DeleteForecastRequest("deleting-forecast-for-job").         // end::delete-forecast-request         // tag::delete-forecast-request-options         // <1>         deleteForecastRequest.setForecastIds(forecastId).         // <2>         deleteForecastRequest.timeout("30s").         // <3>         deleteForecastRequest.setAllowNoForecasts(true).         // end::delete-forecast-request-options         // tag::delete-forecast-execute         AcknowledgedResponse deleteForecastResponse = client.machineLearning().deleteForecast(deleteForecastRequest, RequestOptions.DEFAULT).         // end::delete-forecast-execute         // tag::delete-forecast-response         // <1>         boolean isAcknowledged = deleteForecastResponse.isAcknowledged().     // end::delete-forecast-response     }     {         // tag::delete-forecast-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse DeleteForecastResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-forecast-execute-listener         DeleteForecastRequest deleteForecastRequest = DeleteForecastRequest.deleteAllForecasts(job.getId()).         deleteForecastRequest.setAllowNoForecasts(true).         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::delete-forecast-execute-async         // <1>         client.machineLearning().deleteForecastAsync(deleteForecastRequest, RequestOptions.DEFAULT, listener).         // end::delete-forecast-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetJobStatsResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;57;;public void testGetJobStats() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("get-machine-learning-job-stats1").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     Job secondJob = MachineLearningIT.buildJob("get-machine-learning-job-stats2").     client.machineLearning().putJob(new PutJobRequest(secondJob), RequestOptions.DEFAULT).     {         // tag::get-job-stats-request         // <1>         GetJobStatsRequest request = new GetJobStatsRequest("get-machine-learning-job-stats1", "get-machine-learning-job-*").         // <2>         request.setAllowNoJobs(true).         // end::get-job-stats-request         // tag::get-job-stats-execute         GetJobStatsResponse response = client.machineLearning().getJobStats(request, RequestOptions.DEFAULT).         // end::get-job-stats-execute         // tag::get-job-stats-response         // <1>         long numberOfJobStats = response.count().         // <2>         List<JobStats> jobStats = response.jobStats().         // end::get-job-stats-response         assertEquals(2, response.count()).         assertThat(response.jobStats(), hasSize(2)).         assertThat(response.jobStats().stream().map(JobStats::getJobId).collect(Collectors.toList()), containsInAnyOrder(job.getId(), secondJob.getId())).     }     {         GetJobStatsRequest request = new GetJobStatsRequest("get-machine-learning-job-stats1", "get-machine-learning-job-*").         // tag::get-job-stats-execute-listener         ActionListener<GetJobStatsResponse> listener = new ActionListener<GetJobStatsResponse>() {              @Override             public void onResponse(GetJobStatsResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-job-stats-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-job-stats-execute-async         // <1>         client.machineLearning().getJobStatsAsync(request, RequestOptions.DEFAULT, listener).         // end::get-job-stats-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(ForecastJobResponse forecastJobResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;66;;public void testForecastJob() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("forecasting-my-first-machine-learning-job").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     client.machineLearning().openJob(new OpenJobRequest(job.getId()), RequestOptions.DEFAULT).     PostDataRequest.JsonBuilder builder = new PostDataRequest.JsonBuilder().     for (int i = 0. i < 30. i++) {         Map<String, Object> hashMap = new HashMap<>().         hashMap.put("total", randomInt(1000)).         hashMap.put("timestamp", (i + 1) * 1000).         builder.addDoc(hashMap).     }     PostDataRequest postDataRequest = new PostDataRequest(job.getId(), builder).     client.machineLearning().postData(postDataRequest, RequestOptions.DEFAULT).     client.machineLearning().flushJob(new FlushJobRequest(job.getId()), RequestOptions.DEFAULT).     {         // tag::forecast-job-request         // <1>         ForecastJobRequest forecastJobRequest = new ForecastJobRequest("forecasting-my-first-machine-learning-job").         // end::forecast-job-request         // tag::forecast-job-request-options         // <1>         forecastJobRequest.setExpiresIn(TimeValue.timeValueHours(48)).         // <2>         forecastJobRequest.setDuration(TimeValue.timeValueHours(24)).         // end::forecast-job-request-options         // tag::forecast-job-execute         ForecastJobResponse forecastJobResponse = client.machineLearning().forecastJob(forecastJobRequest, RequestOptions.DEFAULT).         // end::forecast-job-execute         // tag::forecast-job-response         // <1>         boolean isAcknowledged = forecastJobResponse.isAcknowledged().         // <2>         String forecastId = forecastJobResponse.getForecastId().         // end::forecast-job-response         assertTrue(isAcknowledged).         assertNotNull(forecastId).     }     {         // tag::forecast-job-execute-listener         ActionListener<ForecastJobResponse> listener = new ActionListener<ForecastJobResponse>() {              @Override             public void onResponse(ForecastJobResponse forecastJobResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::forecast-job-execute-listener         ForecastJobRequest forecastJobRequest = new ForecastJobRequest("forecasting-my-first-machine-learning-job").         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::forecast-job-execute-async         // <1>         client.machineLearning().forecastJobAsync(forecastJobRequest, RequestOptions.DEFAULT, listener).         // end::forecast-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetOverallBucketsResponse getOverallBucketsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;100;;public void testGetOverallBuckets() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId1 = "test-get-overall-buckets-1".     String jobId2 = "test-get-overall-buckets-2".     Job job1 = MachineLearningGetResultsIT.buildJob(jobId1).     Job job2 = MachineLearningGetResultsIT.buildJob(jobId2).     client.machineLearning().putJob(new PutJobRequest(job1), RequestOptions.DEFAULT).     client.machineLearning().putJob(new PutJobRequest(job2), RequestOptions.DEFAULT).     // Let us index some buckets     BulkRequest bulkRequest = new BulkRequest().     bulkRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     {         IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared").         indexRequest.source("{\"job_id\":\"test-get-overall-buckets-1\", \"result_type\":\"bucket\", \"timestamp\": 1533081600000," + "\"bucket_span\": 600,\"is_interim\": false, \"anomaly_score\": 60.0}", XContentType.JSON).         bulkRequest.add(indexRequest).     }     {         IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared").         indexRequest.source("{\"job_id\":\"test-get-overall-buckets-2\", \"result_type\":\"bucket\", \"timestamp\": 1533081600000," + "\"bucket_span\": 3600,\"is_interim\": false, \"anomaly_score\": 100.0}", XContentType.JSON).         bulkRequest.add(indexRequest).     }     client.bulk(bulkRequest, RequestOptions.DEFAULT).     {         // tag::get-overall-buckets-request         // <1>         GetOverallBucketsRequest request = new GetOverallBucketsRequest(jobId1, jobId2).         // end::get-overall-buckets-request         // tag::get-overall-buckets-bucket-span         // <1>         request.setBucketSpan(TimeValue.timeValueHours(24)).         // end::get-overall-buckets-bucket-span         // tag::get-overall-buckets-end         // <1>         request.setEnd("2018-08-21T00:00:00Z").         // end::get-overall-buckets-end         // tag::get-overall-buckets-exclude-interim         // <1>         request.setExcludeInterim(true).         // end::get-overall-buckets-exclude-interim         // tag::get-overall-buckets-overall-score         // <1>         request.setOverallScore(75.0).         // end::get-overall-buckets-overall-score         // tag::get-overall-buckets-start         // <1>         request.setStart("2018-08-01T00:00:00Z").         // end::get-overall-buckets-start         // tag::get-overall-buckets-top-n         // <1>         request.setTopN(2).         // end::get-overall-buckets-top-n         // tag::get-overall-buckets-execute         GetOverallBucketsResponse response = client.machineLearning().getOverallBuckets(request, RequestOptions.DEFAULT).         // end::get-overall-buckets-execute         // tag::get-overall-buckets-response         // <1>         long count = response.count().         // <2>         List<OverallBucket> overallBuckets = response.overallBuckets().         // end::get-overall-buckets-response         assertEquals(1, overallBuckets.size()).         assertThat(overallBuckets.get(0).getOverallScore(), is(closeTo(80.0, 0.001))).     }     {         GetOverallBucketsRequest request = new GetOverallBucketsRequest(jobId1, jobId2).         // tag::get-overall-buckets-execute-listener         ActionListener<GetOverallBucketsResponse> listener = new ActionListener<GetOverallBucketsResponse>() {              @Override             public void onResponse(GetOverallBucketsResponse getOverallBucketsResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-overall-buckets-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-overall-buckets-execute-async         // <1>         client.machineLearning().getOverallBucketsAsync(request, RequestOptions.DEFAULT, listener).         // end::get-overall-buckets-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetRecordsResponse getRecordsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;89;;public void testGetRecords() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId = "test-get-records".     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     // Let us index a record     IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared", "_doc").     indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     indexRequest.source("{\"job_id\":\"test-get-records\", \"result_type\":\"record\", \"timestamp\": 1533081600000," + "\"bucket_span\": 600,\"is_interim\": false, \"record_score\": 80.0}", XContentType.JSON).     client.index(indexRequest, RequestOptions.DEFAULT).     {         // tag::get-records-request         // <1>         GetRecordsRequest request = new GetRecordsRequest(jobId).         // end::get-records-request         // tag::get-records-desc         // <1>         request.setDescending(true).         // end::get-records-desc         // tag::get-records-end         // <1>         request.setEnd("2018-08-21T00:00:00Z").         // end::get-records-end         // tag::get-records-exclude-interim         // <1>         request.setExcludeInterim(true).         // end::get-records-exclude-interim         // tag::get-records-page         // <1>         request.setPageParams(new PageParams(100, 200)).         // end::get-records-page         // Set page params back to null so the response contains the record we indexed         request.setPageParams(null).         // tag::get-records-record-score         // <1>         request.setRecordScore(75.0).         // end::get-records-record-score         // tag::get-records-sort         // <1>         request.setSort("probability").         // end::get-records-sort         // tag::get-records-start         // <1>         request.setStart("2018-08-01T00:00:00Z").         // end::get-records-start         // tag::get-records-execute         GetRecordsResponse response = client.machineLearning().getRecords(request, RequestOptions.DEFAULT).         // end::get-records-execute         // tag::get-records-response         // <1>         long count = response.count().         // <2>         List<AnomalyRecord> records = response.records().         // end::get-records-response         assertEquals(1, records.size()).     }     {         GetRecordsRequest request = new GetRecordsRequest(jobId).         // tag::get-records-execute-listener         ActionListener<GetRecordsResponse> listener = new ActionListener<GetRecordsResponse>() {              @Override             public void onResponse(GetRecordsResponse getRecordsResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-records-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-records-execute-async         // <1>         client.machineLearning().getRecordsAsync(request, RequestOptions.DEFAULT, listener).         // end::get-records-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PostDataResponse postDataResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;66;;public void testPostData() throws Exception {     RestHighLevelClient client = highLevelClient().     Job job = MachineLearningIT.buildJob("test-post-data").     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     client.machineLearning().openJob(new OpenJobRequest(job.getId()), RequestOptions.DEFAULT).     {         // tag::post-data-request         // <1>         PostDataRequest.JsonBuilder jsonBuilder = new PostDataRequest.JsonBuilder().         Map<String, Object> mapData = new HashMap<>().         mapData.put("total", 109).         // <2>         jsonBuilder.addDoc(mapData).         // <3>         jsonBuilder.addDoc("{\"total\":1000}").         // <4>         PostDataRequest postDataRequest = new PostDataRequest("test-post-data", jsonBuilder).         // end::post-data-request         // tag::post-data-request-options         // <1>         postDataRequest.setResetStart("2018-08-31T16:35:07+00:00").         // <2>         postDataRequest.setResetEnd("2018-08-31T16:35:17+00:00").         // end::post-data-request-options         postDataRequest.setResetEnd(null).         postDataRequest.setResetStart(null).         // tag::post-data-execute         PostDataResponse postDataResponse = client.machineLearning().postData(postDataRequest, RequestOptions.DEFAULT).         // end::post-data-execute         // tag::post-data-response         // <1>         DataCounts dataCounts = postDataResponse.getDataCounts().         // end::post-data-response         assertEquals(2, dataCounts.getInputRecordCount()).     }     {         // tag::post-data-execute-listener         ActionListener<PostDataResponse> listener = new ActionListener<PostDataResponse>() {              @Override             public void onResponse(PostDataResponse postDataResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::post-data-execute-listener         PostDataRequest.JsonBuilder jsonBuilder = new PostDataRequest.JsonBuilder().         Map<String, Object> mapData = new HashMap<>().         mapData.put("total", 109).         jsonBuilder.addDoc(mapData).         // <1>         PostDataRequest postDataRequest = new PostDataRequest("test-post-data", jsonBuilder).         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::post-data-execute-async         // <1>         client.machineLearning().postDataAsync(postDataRequest, RequestOptions.DEFAULT, listener).         // end::post-data-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(FindFileStructureResponse findFileStructureResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;61;;public void testFindFileStructure() throws Exception {     RestHighLevelClient client = highLevelClient().     Path anInterestingFile = createTempFile().     String contents = "{\"logger\":\"controller\",\"timestamp\":1478261151445,\"level\":\"INFO\"," + "\"pid\":42,\"thread\":\"0x7fff7d2a8000\",\"message\":\"message 1\",\"class\":\"ml\"," + "\"method\":\"core::SomeNoiseMaker\",\"file\":\"Noisemaker.cc\",\"line\":333}\n" + "{\"logger\":\"controller\",\"timestamp\":1478261151445," + "\"level\":\"INFO\",\"pid\":42,\"thread\":\"0x7fff7d2a8000\",\"message\":\"message 2\",\"class\":\"ml\"," + "\"method\":\"core::SomeNoiseMaker\",\"file\":\"Noisemaker.cc\",\"line\":333}\n".     Files.write(anInterestingFile, Collections.singleton(contents), StandardCharsets.UTF_8).     {         // tag::find-file-structure-request         // <1>         FindFileStructureRequest findFileStructureRequest = new FindFileStructureRequest().         // <2>         findFileStructureRequest.setSample(Files.readAllBytes(anInterestingFile)).         // end::find-file-structure-request         // tag::find-file-structure-request-options         // <1>         findFileStructureRequest.setLinesToSample(500).         // <2>         findFileStructureRequest.setExplain(true).         // end::find-file-structure-request-options         // tag::find-file-structure-execute         FindFileStructureResponse findFileStructureResponse = client.machineLearning().findFileStructure(findFileStructureRequest, RequestOptions.DEFAULT).         // end::find-file-structure-execute         // tag::find-file-structure-response         // <1>         FileStructure structure = findFileStructureResponse.getFileStructure().         // end::find-file-structure-response         assertEquals(2, structure.getNumLinesAnalyzed()).     }     {         // tag::find-file-structure-execute-listener         ActionListener<FindFileStructureResponse> listener = new ActionListener<FindFileStructureResponse>() {              @Override             public void onResponse(FindFileStructureResponse findFileStructureResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::find-file-structure-execute-listener         FindFileStructureRequest findFileStructureRequest = new FindFileStructureRequest().         findFileStructureRequest.setSample(Files.readAllBytes(anInterestingFile)).         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::find-file-structure-execute-async         // <1>         client.machineLearning().findFileStructureAsync(findFileStructureRequest, RequestOptions.DEFAULT, listener).         // end::find-file-structure-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetInfluencersResponse getInfluencersResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;90;;public void testGetInfluencers() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId = "test-get-influencers".     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     // Let us index a record     IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared", "_doc").     indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     indexRequest.source("{\"job_id\":\"test-get-influencers\", \"result_type\":\"influencer\", \"timestamp\": 1533081600000," + "\"bucket_span\": 600,\"is_interim\": false, \"influencer_score\": 80.0, \"influencer_field_name\": \"my_influencer\"," + "\"influencer_field_value\":\"foo\"}", XContentType.JSON).     client.index(indexRequest, RequestOptions.DEFAULT).     {         // tag::get-influencers-request         // <1>         GetInfluencersRequest request = new GetInfluencersRequest(jobId).         // end::get-influencers-request         // tag::get-influencers-desc         // <1>         request.setDescending(true).         // end::get-influencers-desc         // tag::get-influencers-end         // <1>         request.setEnd("2018-08-21T00:00:00Z").         // end::get-influencers-end         // tag::get-influencers-exclude-interim         // <1>         request.setExcludeInterim(true).         // end::get-influencers-exclude-interim         // tag::get-influencers-influencer-score         // <1>         request.setInfluencerScore(75.0).         // end::get-influencers-influencer-score         // tag::get-influencers-page         // <1>         request.setPageParams(new PageParams(100, 200)).         // end::get-influencers-page         // Set page params back to null so the response contains the influencer we indexed         request.setPageParams(null).         // tag::get-influencers-sort         // <1>         request.setSort("probability").         // end::get-influencers-sort         // tag::get-influencers-start         // <1>         request.setStart("2018-08-01T00:00:00Z").         // end::get-influencers-start         // tag::get-influencers-execute         GetInfluencersResponse response = client.machineLearning().getInfluencers(request, RequestOptions.DEFAULT).         // end::get-influencers-execute         // tag::get-influencers-response         // <1>         long count = response.count().         // <2>         List<Influencer> influencers = response.influencers().         // end::get-influencers-response         assertEquals(1, influencers.size()).     }     {         GetInfluencersRequest request = new GetInfluencersRequest(jobId).         // tag::get-influencers-execute-listener         ActionListener<GetInfluencersResponse> listener = new ActionListener<GetInfluencersResponse>() {              @Override             public void onResponse(GetInfluencersResponse getInfluencersResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-influencers-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-influencers-execute-async         // <1>         client.machineLearning().getInfluencersAsync(request, RequestOptions.DEFAULT, listener).         // end::get-influencers-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetCategoriesResponse getcategoriesResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;69;;public void testGetCategories() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId = "test-get-categories".     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     // Let us index a category     IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared", "_doc").     indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     indexRequest.source("{\"job_id\": \"test-get-categories\", \"category_id\": 1, \"terms\": \"AAL\"," + " \"regex\": \".*?AAL.*\", \"max_matching_length\": 3, \"examples\": [\"AAL\"]}", XContentType.JSON).     client.index(indexRequest, RequestOptions.DEFAULT).     {         // tag::get-categories-request         // <1>         GetCategoriesRequest request = new GetCategoriesRequest(jobId).         // end::get-categories-request         // tag::get-categories-category-id         // <1>         request.setCategoryId(1L).         // end::get-categories-category-id         // tag::get-categories-page         // <1>         request.setPageParams(new PageParams(100, 200)).         // end::get-categories-page         // Set page params back to null so the response contains the category we indexed         request.setPageParams(null).         // tag::get-categories-execute         GetCategoriesResponse response = client.machineLearning().getCategories(request, RequestOptions.DEFAULT).         // end::get-categories-execute         // tag::get-categories-response         // <1>         long count = response.count().         // <2>         List<CategoryDefinition> categories = response.categories().         // end::get-categories-response         assertEquals(1, categories.size()).     }     {         GetCategoriesRequest request = new GetCategoriesRequest(jobId).         // tag::get-categories-execute-listener         ActionListener<GetCategoriesResponse> listener = new ActionListener<GetCategoriesResponse>() {              @Override             public void onResponse(GetCategoriesResponse getcategoriesResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-categories-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-categories-execute-async         // <1>         client.machineLearning().getCategoriesAsync(request, RequestOptions.DEFAULT, listener).         // end::get-categories-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(DeleteExpiredDataResponse deleteExpiredDataResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;48;;public void testDeleteExpiredData() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId = "test-delete-expired-data".     MachineLearningIT.buildJob(jobId).     {         // tag::delete-expired-data-request         // <1>         DeleteExpiredDataRequest request = new DeleteExpiredDataRequest().         // end::delete-expired-data-request         // tag::delete-expired-data-execute         DeleteExpiredDataResponse response = client.machineLearning().deleteExpiredData(request, RequestOptions.DEFAULT).         // end::delete-expired-data-execute         // tag::delete-expired-data-response         // <1>         boolean deleted = response.getDeleted().         // end::delete-expired-data-response         assertTrue(deleted).     }     {         // tag::delete-expired-data-execute-listener         ActionListener<DeleteExpiredDataResponse> listener = new ActionListener<DeleteExpiredDataResponse>() {              @Override             public void onResponse(DeleteExpiredDataResponse deleteExpiredDataResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-expired-data-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         DeleteExpiredDataRequest deleteExpiredDataRequest = new DeleteExpiredDataRequest().         // tag::delete-expired-data-execute-async         // <1>         client.machineLearning().deleteExpiredDataAsync(deleteExpiredDataRequest, RequestOptions.DEFAULT, listener).         // end::delete-expired-data-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse acknowledgedResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;66;;public void testDeleteModelSnapshot() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId = "test-delete-model-snapshot".     String snapshotId = "1541587919".     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     // Let us index a snapshot     IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared", "_doc").     indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     indexRequest.source("{\"job_id\":\"" + jobId + "\", \"timestamp\":1541587919000, " + "\"description\":\"State persisted due to job close at 2018-11-07T10:51:59+0000\", " + "\"snapshot_id\":\"" + snapshotId + "\", \"snapshot_doc_count\":1, \"model_size_stats\":{" + "\"job_id\":\"" + jobId + "\", \"result_type\":\"model_size_stats\",\"model_bytes\":51722, " + "\"total_by_field_count\":3, \"total_over_field_count\":0, \"total_partition_field_count\":2," + "\"bucket_allocation_failures_count\":0, \"memory_status\":\"ok\", \"log_time\":1541587919000, " + "\"timestamp\":1519930800000}, \"latest_record_time_stamp\":1519931700000," + "\"latest_result_time_stamp\":1519930800000, \"retain\":false}", XContentType.JSON).     {         client.index(indexRequest, RequestOptions.DEFAULT).         // tag::delete-model-snapshot-request         // <1>         DeleteModelSnapshotRequest request = new DeleteModelSnapshotRequest(jobId, snapshotId).         // end::delete-model-snapshot-request         // tag::delete-model-snapshot-execute         AcknowledgedResponse response = client.machineLearning().deleteModelSnapshot(request, RequestOptions.DEFAULT).         // end::delete-model-snapshot-execute         // tag::delete-model-snapshot-response         // <1>         boolean isAcknowledged = response.isAcknowledged().         // end::delete-model-snapshot-response         assertTrue(isAcknowledged).     }     {         client.index(indexRequest, RequestOptions.DEFAULT).         // tag::delete-model-snapshot-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse acknowledgedResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-model-snapshot-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         DeleteModelSnapshotRequest deleteModelSnapshotRequest = new DeleteModelSnapshotRequest(jobId, "1541587919").         // tag::delete-model-snapshot-execute-async         // <1>         client.machineLearning().deleteModelSnapshotAsync(deleteModelSnapshotRequest, RequestOptions.DEFAULT, listener).         // end::delete-model-snapshot-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetModelSnapshotsResponse getModelSnapshotsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;95;;public void testGetModelSnapshots() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId = "test-get-model-snapshots".     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     // Let us index a snapshot     IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared", "_doc").     indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     indexRequest.source("{\"job_id\":\"test-get-model-snapshots\", \"timestamp\":1541587919000, " + "\"description\":\"State persisted due to job close at 2018-11-07T10:51:59+0000\", " + "\"snapshot_id\":\"1541587919\", \"snapshot_doc_count\":1, \"model_size_stats\":{" + "\"job_id\":\"test-get-model-snapshots\", \"result_type\":\"model_size_stats\",\"model_bytes\":51722, " + "\"total_by_field_count\":3, \"total_over_field_count\":0, \"total_partition_field_count\":2," + "\"bucket_allocation_failures_count\":0, \"memory_status\":\"ok\", \"log_time\":1541587919000, " + "\"timestamp\":1519930800000}, \"latest_record_time_stamp\":1519931700000," + "\"latest_result_time_stamp\":1519930800000, \"retain\":false}", XContentType.JSON).     client.index(indexRequest, RequestOptions.DEFAULT).     {         // tag::get-model-snapshots-request         // <1>         GetModelSnapshotsRequest request = new GetModelSnapshotsRequest(jobId).         // end::get-model-snapshots-request         // tag::get-model-snapshots-snapshot-id         // <1>         request.setSnapshotId("1541587919").         // end::get-model-snapshots-snapshot-id         // Set snapshot id to null as it is incompatible with other args         request.setSnapshotId(null).         // tag::get-model-snapshots-desc         // <1>         request.setDesc(true).         // end::get-model-snapshots-desc         // tag::get-model-snapshots-end         // <1>         request.setEnd("2018-11-07T21:00:00Z").         // end::get-model-snapshots-end         // tag::get-model-snapshots-page         // <1>         request.setPageParams(new PageParams(100, 200)).         // end::get-model-snapshots-page         // Set page params back to null so the response contains the snapshot we indexed         request.setPageParams(null).         // tag::get-model-snapshots-sort         // <1>         request.setSort("latest_result_time_stamp").         // end::get-model-snapshots-sort         // tag::get-model-snapshots-start         // <1>         request.setStart("2018-11-07T00:00:00Z").         // end::get-model-snapshots-start         // tag::get-model-snapshots-execute         GetModelSnapshotsResponse response = client.machineLearning().getModelSnapshots(request, RequestOptions.DEFAULT).         // end::get-model-snapshots-execute         // tag::get-model-snapshots-response         // <1>         long count = response.count().         // <2>         List<ModelSnapshot> modelSnapshots = response.snapshots().         // end::get-model-snapshots-response         assertEquals(1, modelSnapshots.size()).     }     {         GetModelSnapshotsRequest request = new GetModelSnapshotsRequest(jobId).         // tag::get-model-snapshots-execute-listener         ActionListener<GetModelSnapshotsResponse> listener = new ActionListener<GetModelSnapshotsResponse>() {              @Override             public void onResponse(GetModelSnapshotsResponse getModelSnapshotsResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-model-snapshots-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-model-snapshots-execute-async         // <1>         client.machineLearning().getModelSnapshotsAsync(request, RequestOptions.DEFAULT, listener).         // end::get-model-snapshots-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(RevertModelSnapshotResponse revertModelSnapshotResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;74;;public void testRevertModelSnapshot() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId = "test-revert-model-snapshot".     String snapshotId = "1541587919".     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     // Let us index a snapshot     String documentId = jobId + "_model_snapshot_" + snapshotId.     IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared", "_doc", documentId).     indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     indexRequest.source("{\"job_id\":\"test-revert-model-snapshot\", \"timestamp\":1541587919000, " + "\"description\":\"State persisted due to job close at 2018-11-07T10:51:59+0000\", " + "\"snapshot_id\":\"1541587919\", \"snapshot_doc_count\":1, \"model_size_stats\":{" + "\"job_id\":\"test-revert-model-snapshot\", \"result_type\":\"model_size_stats\",\"model_bytes\":51722, " + "\"total_by_field_count\":3, \"total_over_field_count\":0, \"total_partition_field_count\":2," + "\"bucket_allocation_failures_count\":0, \"memory_status\":\"ok\", \"log_time\":1541587919000, " + "\"timestamp\":1519930800000}, \"latest_record_time_stamp\":1519931700000," + "\"latest_result_time_stamp\":1519930800000, \"retain\":false, " + "\"quantiles\":{\"job_id\":\"test-revert-model-snapshot\", \"timestamp\":1541587919000, " + "\"quantile_state\":\"state\"}}", XContentType.JSON).     client.index(indexRequest, RequestOptions.DEFAULT).     {         // tag::revert-model-snapshot-request         // <1>         RevertModelSnapshotRequest request = new RevertModelSnapshotRequest(jobId, snapshotId).         // end::revert-model-snapshot-request         // tag::revert-model-snapshot-delete-intervening-results         // <1>         request.setDeleteInterveningResults(true).         // end::revert-model-snapshot-delete-intervening-results         // tag::revert-model-snapshot-execute         RevertModelSnapshotResponse response = client.machineLearning().revertModelSnapshot(request, RequestOptions.DEFAULT).         // end::revert-model-snapshot-execute         // tag::revert-model-snapshot-response         // <1>         ModelSnapshot modelSnapshot = response.getModel().         // end::revert-model-snapshot-response         assertEquals(snapshotId, modelSnapshot.getSnapshotId()).         assertEquals("State persisted due to job close at 2018-11-07T10:51:59+0000", modelSnapshot.getDescription()).         assertEquals(51722, modelSnapshot.getModelSizeStats().getModelBytes()).     }     {         RevertModelSnapshotRequest request = new RevertModelSnapshotRequest(jobId, snapshotId).         // tag::revert-model-snapshot-execute-listener         ActionListener<RevertModelSnapshotResponse> listener = new ActionListener<RevertModelSnapshotResponse>() {              @Override             public void onResponse(RevertModelSnapshotResponse revertModelSnapshotResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::revert-model-snapshot-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::revert-model-snapshot-execute-async         // <1>         client.machineLearning().revertModelSnapshotAsync(request, RequestOptions.DEFAULT, listener).         // end::revert-model-snapshot-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(UpdateModelSnapshotResponse updateModelSnapshotResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;75;;public void testUpdateModelSnapshot() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String jobId = "test-update-model-snapshot".     String snapshotId = "1541587919".     String documentId = jobId + "_model_snapshot_" + snapshotId.     Job job = MachineLearningIT.buildJob(jobId).     client.machineLearning().putJob(new PutJobRequest(job), RequestOptions.DEFAULT).     // Let us index a snapshot     IndexRequest indexRequest = new IndexRequest(".ml-anomalies-shared", "_doc", documentId).     indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     indexRequest.source("{\"job_id\":\"test-update-model-snapshot\", \"timestamp\":1541587919000, " + "\"description\":\"State persisted due to job close at 2018-11-07T10:51:59+0000\", " + "\"snapshot_id\":\"1541587919\", \"snapshot_doc_count\":1, \"model_size_stats\":{" + "\"job_id\":\"test-update-model-snapshot\", \"result_type\":\"model_size_stats\",\"model_bytes\":51722, " + "\"total_by_field_count\":3, \"total_over_field_count\":0, \"total_partition_field_count\":2," + "\"bucket_allocation_failures_count\":0, \"memory_status\":\"ok\", \"log_time\":1541587919000, " + "\"timestamp\":1519930800000}, \"latest_record_time_stamp\":1519931700000," + "\"latest_result_time_stamp\":1519930800000, \"retain\":false}", XContentType.JSON).     client.index(indexRequest, RequestOptions.DEFAULT).     {         // tag::update-model-snapshot-request         // <1>         UpdateModelSnapshotRequest request = new UpdateModelSnapshotRequest(jobId, snapshotId).         // end::update-model-snapshot-request         // tag::update-model-snapshot-description         // <1>         request.setDescription("My Snapshot").         // end::update-model-snapshot-description         // tag::update-model-snapshot-retain         // <1>         request.setRetain(true).         // end::update-model-snapshot-retain         // tag::update-model-snapshot-execute         UpdateModelSnapshotResponse response = client.machineLearning().updateModelSnapshot(request, RequestOptions.DEFAULT).         // end::update-model-snapshot-execute         // tag::update-model-snapshot-response         // <1>         boolean acknowledged = response.getAcknowledged().         // <2>         ModelSnapshot modelSnapshot = response.getModel().         // end::update-model-snapshot-response         assertTrue(acknowledged).         assertEquals("My Snapshot", modelSnapshot.getDescription()).     }     {         UpdateModelSnapshotRequest request = new UpdateModelSnapshotRequest(jobId, snapshotId).         // tag::update-model-snapshot-execute-listener         ActionListener<UpdateModelSnapshotResponse> listener = new ActionListener<UpdateModelSnapshotResponse>() {              @Override             public void onResponse(UpdateModelSnapshotResponse updateModelSnapshotResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::update-model-snapshot-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::update-model-snapshot-execute-async         // <1>         client.machineLearning().updateModelSnapshotAsync(request, RequestOptions.DEFAULT, listener).         // end::update-model-snapshot-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PutCalendarResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;41;;public void testPutCalendar() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     // tag::put-calendar-request     Calendar calendar = new Calendar("public_holidays", Collections.singletonList("job_1"), "A calendar for public holidays").     // <1>     PutCalendarRequest request = new PutCalendarRequest(calendar).     // end::put-calendar-request     // tag::put-calendar-execute     PutCalendarResponse response = client.machineLearning().putCalendar(request, RequestOptions.DEFAULT).     // end::put-calendar-execute     // tag::put-calendar-response     // <1>     Calendar newCalendar = response.getCalendar().     // end::put-calendar-response     assertThat(newCalendar.getId(), equalTo("public_holidays")).     // tag::put-calendar-execute-listener     ActionListener<PutCalendarResponse> listener = new ActionListener<PutCalendarResponse>() {          @Override         public void onResponse(PutCalendarResponse response) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::put-calendar-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::put-calendar-execute-async     // <1>     client.machineLearning().putCalendarAsync(request, RequestOptions.DEFAULT, listener).     // end::put-calendar-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(PutCalendarResponse putCalendarsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;51;;public void testPutCalendarJob() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     Calendar calendar = new Calendar("holidays", Collections.singletonList("job_1"), "A calendar for public holidays").     PutCalendarRequest putRequest = new PutCalendarRequest(calendar).     client.machineLearning().putCalendar(putRequest, RequestOptions.DEFAULT).     {         // tag::put-calendar-job-request         PutCalendarJobRequest request = new // <1>         PutCalendarJobRequest(// <1>         "holidays", "job_2", // <2>         "job_group_1").         // end::put-calendar-job-request         // tag::put-calendar-job-execute         PutCalendarResponse response = client.machineLearning().putCalendarJob(request, RequestOptions.DEFAULT).         // end::put-calendar-job-execute         // tag::put-calendar-job-response         // <1>         Calendar updatedCalendar = response.getCalendar().         // end::put-calendar-job-response         assertThat(updatedCalendar.getJobIds(), containsInAnyOrder("job_1", "job_2", "job_group_1")).     }     {         PutCalendarJobRequest request = new PutCalendarJobRequest("holidays", "job_4").         // tag::put-calendar-job-execute-listener         ActionListener<PutCalendarResponse> listener = new ActionListener<PutCalendarResponse>() {              @Override             public void onResponse(PutCalendarResponse putCalendarsResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::put-calendar-job-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::put-calendar-job-execute-async         // <1>         client.machineLearning().putCalendarJobAsync(request, RequestOptions.DEFAULT, listener).         // end::put-calendar-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PutCalendarResponse deleteCalendarsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;53;;public void testDeleteCalendarJob() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     Calendar calendar = new Calendar("holidays", Arrays.asList("job_1", "job_group_1", "job_2"), "A calendar for public holidays").     PutCalendarRequest putRequest = new PutCalendarRequest(calendar).     client.machineLearning().putCalendar(putRequest, RequestOptions.DEFAULT).     {         // tag::delete-calendar-job-request         DeleteCalendarJobRequest request = new // <1>         DeleteCalendarJobRequest(// <1>         "holidays", "job_1", // <2>         "job_group_1").         // end::delete-calendar-job-request         // tag::delete-calendar-job-execute         PutCalendarResponse response = client.machineLearning().deleteCalendarJob(request, RequestOptions.DEFAULT).         // end::delete-calendar-job-execute         // tag::delete-calendar-job-response         // <1>         Calendar updatedCalendar = response.getCalendar().         // end::delete-calendar-job-response         assertThat(updatedCalendar.getJobIds(), containsInAnyOrder("job_2")).     }     {         DeleteCalendarJobRequest request = new DeleteCalendarJobRequest("holidays", "job_2").         // tag::delete-calendar-job-execute-listener         ActionListener<PutCalendarResponse> listener = new ActionListener<PutCalendarResponse>() {              @Override             public void onResponse(PutCalendarResponse deleteCalendarsResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-calendar-job-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::delete-calendar-job-execute-async         // <1>         client.machineLearning().deleteCalendarJobAsync(request, RequestOptions.DEFAULT, listener).         // end::delete-calendar-job-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetCalendarsResponse getCalendarsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;61;;public void testGetCalendar() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     Calendar calendar = new Calendar("holidays", Collections.singletonList("job_1"), "A calendar for public holidays").     PutCalendarRequest putRequest = new PutCalendarRequest(calendar).     client.machineLearning().putCalendar(putRequest, RequestOptions.DEFAULT).     {         // tag::get-calendars-request         // <1>         GetCalendarsRequest request = new GetCalendarsRequest().         // end::get-calendars-request         // tag::get-calendars-id         // <1>         request.setCalendarId("holidays").         // end::get-calendars-id         // tag::get-calendars-page         // <1>         request.setPageParams(new PageParams(10, 20)).         // end::get-calendars-page         // reset page params         request.setPageParams(null).         // tag::get-calendars-execute         GetCalendarsResponse response = client.machineLearning().getCalendars(request, RequestOptions.DEFAULT).         // end::get-calendars-execute         // tag::get-calendars-response         // <1>         long count = response.count().         // <2>         List<Calendar> calendars = response.calendars().         // end::get-calendars-response         assertEquals(1, calendars.size()).     }     {         GetCalendarsRequest request = new GetCalendarsRequest("holidays").         // tag::get-calendars-execute-listener         ActionListener<GetCalendarsResponse> listener = new ActionListener<GetCalendarsResponse>() {              @Override             public void onResponse(GetCalendarsResponse getCalendarsResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-calendars-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-calendars-execute-async         // <1>         client.machineLearning().getCalendarsAsync(request, RequestOptions.DEFAULT, listener).         // end::get-calendars-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;45;;public void testDeleteCalendar() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     Calendar calendar = new Calendar("holidays", Collections.singletonList("job_1"), "A calendar for public holidays").     PutCalendarRequest putCalendarRequest = new PutCalendarRequest(calendar).     client.machineLearning().putCalendar(putCalendarRequest, RequestOptions.DEFAULT).     // tag::delete-calendar-request     // <1>     DeleteCalendarRequest request = new DeleteCalendarRequest("holidays").     // end::delete-calendar-request     // tag::delete-calendar-execute     AcknowledgedResponse response = client.machineLearning().deleteCalendar(request, RequestOptions.DEFAULT).     // end::delete-calendar-execute     // tag::delete-calendar-response     // <1>     boolean isAcknowledged = response.isAcknowledged().     // end::delete-calendar-response     assertTrue(isAcknowledged).     // tag::delete-calendar-execute-listener     ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {          @Override         public void onResponse(AcknowledgedResponse response) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::delete-calendar-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::delete-calendar-execute-async     // <1>     client.machineLearning().deleteCalendarAsync(request, RequestOptions.DEFAULT, listener).     // end::delete-calendar-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(GetCalendarEventsResponse getCalendarsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;74;;public void testGetCalendarEvent() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     Calendar calendar = new Calendar("holidays", Collections.singletonList("job_1"), "A calendar for public holidays").     PutCalendarRequest putRequest = new PutCalendarRequest(calendar).     client.machineLearning().putCalendar(putRequest, RequestOptions.DEFAULT).     List<ScheduledEvent> events = Collections.singletonList(ScheduledEventTests.testInstance(calendar.getId(), null)).     client.machineLearning().postCalendarEvent(new PostCalendarEventRequest("holidays", events), RequestOptions.DEFAULT).     {         // tag::get-calendar-events-request         // <1>         GetCalendarEventsRequest request = new GetCalendarEventsRequest("holidays").         // end::get-calendar-events-request         // tag::get-calendar-events-page         // <1>         request.setPageParams(new PageParams(10, 20)).         // end::get-calendar-events-page         // tag::get-calendar-events-start         // <1>         request.setStart("2018-08-01T00:00:00Z").         // end::get-calendar-events-start         // tag::get-calendar-events-end         // <1>         request.setEnd("2018-08-02T00:00:00Z").         // end::get-calendar-events-end         // tag::get-calendar-events-jobid         // <1>         request.setJobId("job_1").         // end::get-calendar-events-jobid         // reset params         request.setPageParams(null).         request.setJobId(null).         request.setStart(null).         request.setEnd(null).         // tag::get-calendar-events-execute         GetCalendarEventsResponse response = client.machineLearning().getCalendarEvents(request, RequestOptions.DEFAULT).         // end::get-calendar-events-execute         // tag::get-calendar-events-response         // <1>         long count = response.count().         // <2>         List<ScheduledEvent> scheduledEvents = response.events().         // end::get-calendar-events-response         assertEquals(1, scheduledEvents.size()).     }     {         GetCalendarEventsRequest request = new GetCalendarEventsRequest("holidays").         // tag::get-calendar-events-execute-listener         ActionListener<GetCalendarEventsResponse> listener = new ActionListener<GetCalendarEventsResponse>() {              @Override             public void onResponse(GetCalendarEventsResponse getCalendarsResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-calendar-events-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-calendar-events-execute-async         // <1>         client.machineLearning().getCalendarEventsAsync(request, RequestOptions.DEFAULT, listener).         // end::get-calendar-events-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PostCalendarEventResponse postCalendarsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;54;;public void testPostCalendarEvent() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     Calendar calendar = new Calendar("holidays", Collections.singletonList("job_1"), "A calendar for public holidays").     PutCalendarRequest putRequest = new PutCalendarRequest(calendar).     client.machineLearning().putCalendar(putRequest, RequestOptions.DEFAULT).     {         List<ScheduledEvent> events = Collections.singletonList(ScheduledEventTests.testInstance(calendar.getId(), null)).         // tag::post-calendar-event-request         PostCalendarEventRequest request = new // <1>         PostCalendarEventRequest(// <1>         "holidays", // <2>         events).         // end::post-calendar-event-request         // tag::post-calendar-event-execute         PostCalendarEventResponse response = client.machineLearning().postCalendarEvent(request, RequestOptions.DEFAULT).         // end::post-calendar-event-execute         // tag::post-calendar-event-response         // <1>         List<ScheduledEvent> scheduledEvents = response.getScheduledEvents().         // end::post-calendar-event-response         assertEquals(1, scheduledEvents.size()).     }     {         List<ScheduledEvent> events = Collections.singletonList(ScheduledEventTests.testInstance()).         // <1>         PostCalendarEventRequest request = new PostCalendarEventRequest("holidays", events).         // tag::post-calendar-event-execute-listener         ActionListener<PostCalendarEventResponse> listener = new ActionListener<PostCalendarEventResponse>() {              @Override             public void onResponse(PostCalendarEventResponse postCalendarsResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::post-calendar-event-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::post-calendar-event-execute-async         // <1>         client.machineLearning().postCalendarEventAsync(request, RequestOptions.DEFAULT, listener).         // end::post-calendar-event-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse deleteCalendarEventResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;62;;public void testDeleteCalendarEvent() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     Calendar calendar = new Calendar("holidays", Arrays.asList("job_1", "job_group_1", "job_2"), "A calendar for public holidays").     PutCalendarRequest putRequest = new PutCalendarRequest(calendar).     client.machineLearning().putCalendar(putRequest, RequestOptions.DEFAULT).     List<ScheduledEvent> events = Arrays.asList(ScheduledEventTests.testInstance(calendar.getId(), null), ScheduledEventTests.testInstance(calendar.getId(), null)).     client.machineLearning().postCalendarEvent(new PostCalendarEventRequest("holidays", events), RequestOptions.DEFAULT).     GetCalendarEventsResponse getCalendarEventsResponse = client.machineLearning().getCalendarEvents(new GetCalendarEventsRequest("holidays"), RequestOptions.DEFAULT).     {         // tag::delete-calendar-event-request         DeleteCalendarEventRequest request = new // <1>         DeleteCalendarEventRequest(// <1>         "holidays", // <2>         "EventId").         // end::delete-calendar-event-request         request = new DeleteCalendarEventRequest("holidays", getCalendarEventsResponse.events().get(0).getEventId()).         // tag::delete-calendar-event-execute         AcknowledgedResponse response = client.machineLearning().deleteCalendarEvent(request, RequestOptions.DEFAULT).         // end::delete-calendar-event-execute         // tag::delete-calendar-event-response         // <1>         boolean acknowledged = response.isAcknowledged().         // end::delete-calendar-event-response         assertThat(acknowledged, is(true)).     }     {         DeleteCalendarEventRequest request = new DeleteCalendarEventRequest("holidays", getCalendarEventsResponse.events().get(1).getEventId()).         // tag::delete-calendar-event-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse deleteCalendarEventResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-calendar-event-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::delete-calendar-event-execute-async         // <1>         client.machineLearning().deleteCalendarEventAsync(request, RequestOptions.DEFAULT, listener).         // end::delete-calendar-event-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PutFilterResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;53;;public void testCreateFilter() throws Exception {     RestHighLevelClient client = highLevelClient().     {         // tag::put-filter-config         MlFilter.Builder filterBuilder = // <1>         MlFilter.builder("my_safe_domains").setDescription(// <2>         "A list of safe domains").setItems("*.google.com", // <3>         "wikipedia.org").         // end::put-filter-config         // tag::put-filter-request         // <1>         PutFilterRequest request = new PutFilterRequest(filterBuilder.build()).         // end::put-filter-request         // tag::put-filter-execute         PutFilterResponse response = client.machineLearning().putFilter(request, RequestOptions.DEFAULT).         // end::put-filter-execute         // tag::put-filter-response         // <1>         MlFilter createdFilter = response.getResponse().         // end::put-filter-response         assertThat(createdFilter.getId(), equalTo("my_safe_domains")).     }     {         MlFilter.Builder filterBuilder = MlFilter.builder("safe_domains_async").setDescription("A list of safe domains").setItems("*.google.com", "wikipedia.org").         PutFilterRequest request = new PutFilterRequest(filterBuilder.build()).         // tag::put-filter-execute-listener         ActionListener<PutFilterResponse> listener = new ActionListener<PutFilterResponse>() {              @Override             public void onResponse(PutFilterResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::put-filter-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::put-filter-execute-async         // <1>         client.machineLearning().putFilterAsync(request, RequestOptions.DEFAULT, listener).         // end::put-filter-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetFiltersResponse getfiltersResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;63;;public void testGetFilters() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String filterId = "get-filter-doc-test".     MlFilter.Builder filterBuilder = MlFilter.builder(filterId).setDescription("test").setItems("*.google.com", "wikipedia.org").     client.machineLearning().putFilter(new PutFilterRequest(filterBuilder.build()), RequestOptions.DEFAULT).     {         // tag::get-filters-request         // <1>         GetFiltersRequest request = new GetFiltersRequest().         // end::get-filters-request         // tag::get-filters-filter-id         // <1>         request.setFilterId("get-filter-doc-test").         // end::get-filters-filter-id         // tag::get-filters-page-params         // <1>         request.setFrom(100).         // <2>         request.setSize(200).         // end::get-filters-page-params         request.setFrom(null).         request.setSize(null).         // tag::get-filters-execute         GetFiltersResponse response = client.machineLearning().getFilter(request, RequestOptions.DEFAULT).         // end::get-filters-execute         // tag::get-filters-response         // <1>         long count = response.count().         // <2>         List<MlFilter> filters = response.filters().         // end::get-filters-response         assertEquals(1, filters.size()).     }     {         GetFiltersRequest request = new GetFiltersRequest().         request.setFilterId(filterId).         // tag::get-filters-execute-listener         ActionListener<GetFiltersResponse> listener = new ActionListener<GetFiltersResponse>() {              @Override             public void onResponse(GetFiltersResponse getfiltersResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-filters-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-filters-execute-async         // <1>         client.machineLearning().getFilterAsync(request, RequestOptions.DEFAULT, listener).         // end::get-filters-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(PutFilterResponse putFilterResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;61;;public void testUpdateFilter() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String filterId = "update-filter-doc-test".     MlFilter.Builder filterBuilder = MlFilter.builder(filterId).setDescription("test").setItems("*.google.com", "wikipedia.org").     client.machineLearning().putFilter(new PutFilterRequest(filterBuilder.build()), RequestOptions.DEFAULT).     {         // tag::update-filter-request         // <1>         UpdateFilterRequest request = new UpdateFilterRequest(filterId).         // end::update-filter-request         // tag::update-filter-description         // <1>         request.setDescription("my new description").         // end::update-filter-description         // tag::update-filter-add-items         // <1>         request.setAddItems(Arrays.asList("*.bing.com", "*.elastic.co")).         // end::update-filter-add-items         // tag::update-filter-remove-items         // <1>         request.setRemoveItems(Arrays.asList("*.google.com")).         // end::update-filter-remove-items         // tag::update-filter-execute         PutFilterResponse response = client.machineLearning().updateFilter(request, RequestOptions.DEFAULT).         // end::update-filter-execute         // tag::update-filter-response         // <1>         MlFilter updatedFilter = response.getResponse().         // end::update-filter-response         assertEquals(request.getDescription(), updatedFilter.getDescription()).     }     {         UpdateFilterRequest request = new UpdateFilterRequest(filterId).         // tag::update-filter-execute-listener         ActionListener<PutFilterResponse> listener = new ActionListener<PutFilterResponse>() {              @Override             public void onResponse(PutFilterResponse putFilterResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::update-filter-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::update-filter-execute-async         // <1>         client.machineLearning().updateFilterAsync(request, RequestOptions.DEFAULT, listener).         // end::update-filter-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;46;;public void testDeleteFilter() throws Exception {     RestHighLevelClient client = highLevelClient().     String filterId = createFilter(client).     {         // tag::delete-filter-request         // <1>         DeleteFilterRequest request = new DeleteFilterRequest(filterId).         // end::delete-filter-request         // tag::delete-filter-execute         AcknowledgedResponse response = client.machineLearning().deleteFilter(request, RequestOptions.DEFAULT).         // end::delete-filter-execute         // tag::delete-filter-response         // <1>         boolean isAcknowledged = response.isAcknowledged().         // end::delete-filter-response         assertTrue(isAcknowledged).     }     filterId = createFilter(client).     {         DeleteFilterRequest request = new DeleteFilterRequest(filterId).         // tag::delete-filter-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-filter-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::delete-filter-execute-async         // <1>         client.machineLearning().deleteFilterAsync(request, RequestOptions.DEFAULT, listener).         // end::delete-filter-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(MlInfoResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;48;;public void testGetMlInfo() throws Exception {     RestHighLevelClient client = highLevelClient().     {         // tag::get-ml-info-request         // <1>         MlInfoRequest request = new MlInfoRequest().         // end::get-ml-info-request         // tag::get-ml-info-execute         MlInfoResponse response = client.machineLearning().getMlInfo(request, RequestOptions.DEFAULT).         // end::get-ml-info-execute         // tag::get-ml-info-response         // <1>         final Map<String, Object> info = response.getInfo().         // end::get-ml-info-response         assertTrue(info.containsKey("defaults")).         assertTrue(info.containsKey("limits")).     }     {         MlInfoRequest request = new MlInfoRequest().         // tag::get-ml-info-execute-listener         ActionListener<MlInfoResponse> listener = new ActionListener<MlInfoResponse>() {              @Override             public void onResponse(MlInfoResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-ml-info-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-ml-info-execute-async         client.machineLearning().getMlInfoAsync(request, RequestOptions.DEFAULT, // <1>         listener).         // end::get-ml-info-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse acknowledgedResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;50;;public void testSetUpgradeMode() throws Exception {     RestHighLevelClient client = highLevelClient().     {         // tag::set-upgrade-mode-request         // <1>         SetUpgradeModeRequest request = new SetUpgradeModeRequest(true).         // <2>         request.setTimeout(TimeValue.timeValueMinutes(10)).         // end::set-upgrade-mode-request         // Set to false so that the cluster setting does not have to be unset at the end of the test.         request.setEnabled(false).         // tag::set-upgrade-mode-execute         AcknowledgedResponse acknowledgedResponse = client.machineLearning().setUpgradeMode(request, RequestOptions.DEFAULT).         // end::set-upgrade-mode-execute         // tag::set-upgrade-mode-response         // <1>         boolean acknowledged = acknowledgedResponse.isAcknowledged().         // end::set-upgrade-mode-response         assertThat(acknowledged, is(true)).     }     {         SetUpgradeModeRequest request = new SetUpgradeModeRequest(false).         // tag::set-upgrade-mode-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse acknowledgedResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::set-upgrade-mode-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::set-upgrade-mode-execute-async         client.machineLearning().setUpgradeModeAsync(request, RequestOptions.DEFAULT, // <1>         listener).         // end::set-upgrade-mode-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;private;1;10;;private String createFilter(RestHighLevelClient client) throws IOException {     MlFilter.Builder filterBuilder = MlFilter.builder("my_safe_domains").setDescription("A list of safe domains").setItems("*.google.com", "wikipedia.org").     PutFilterRequest putFilterRequest = new PutFilterRequest(filterBuilder.build()).     PutFilterResponse putFilterResponse = client.machineLearning().putFilter(putFilterRequest, RequestOptions.DEFAULT).     MlFilter createdFilter = putFilterResponse.getResponse().     assertThat(createdFilter.getId(), equalTo("my_safe_domains")).     return createdFilter.getId(). }
