commented;modifiers;parameterAmount;loc;comment;code
true;public;0;11;// parsing it back as a client object. We check equality between the original client object, and the parsed one. ;// Because the client-side class does not have a toXContent method, we test xContent serialization by creating // a random client object, converting it to a server object then serializing it to xContent, and finally // parsing it back as a client object. We check equality between the original client object, and the parsed one. public void testFromXContent() throws IOException {     xContentTester(this::createParser, GetMappingsResponseTests::createTestInstance, GetMappingsResponseTests::toXContent, GetMappingsResponse::fromXContent).supportsUnknownFields(true).assertEqualsConsumer(GetMappingsResponseTests::assertEqualInstances).randomFieldsExcludeFilter(randomFieldsExcludeFilter()).test(). }
false;private,static;0;5;;private static GetMappingsResponse createTestInstance() {     Map<String, MappingMetaData> mappings = Collections.singletonMap("index-" + randomAlphaOfLength(5), randomMappingMetaData()).     return new GetMappingsResponse(mappings). }
false;private,static;2;3;;private static void assertEqualInstances(GetMappingsResponse expected, GetMappingsResponse actual) {     assertEquals(expected.mappings(), actual.mappings()). }
false;private;0;3;;private Predicate<String> randomFieldsExcludeFilter() {     return field -> !field.equals(MAPPINGS.getPreferredName()). }
false;public,static;0;16;;public static MappingMetaData randomMappingMetaData() {     Map<String, Object> mappings = new HashMap<>().     if (frequently()) {         // rarely have no fields         mappings.put("field1", randomFieldMapping()).         if (randomBoolean()) {             mappings.put("field2", randomFieldMapping()).         }     }     try {         return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mappings).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;private,static;0;12;;private static Map<String, Object> randomFieldMapping() {     Map<String, Object> mappings = new HashMap<>().     if (randomBoolean()) {         mappings.put("type", randomFrom("text", "keyword")).         mappings.put("index", "analyzed").         mappings.put("analyzer", "english").     } else {         mappings.put("type", randomFrom("integer", "float", "long", "double")).         mappings.put("index", Objects.toString(randomBoolean())).     }     return mappings. }
false;private,static;2;18;;private static void toXContent(GetMappingsResponse response, XContentBuilder builder) throws IOException {     Params params = new ToXContent.MapParams(Collections.singletonMap(BaseRestHandler.INCLUDE_TYPE_NAME_PARAMETER, "false")).     ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> allMappings = ImmutableOpenMap.builder().     for (Map.Entry<String, MappingMetaData> indexEntry : response.mappings().entrySet()) {         ImmutableOpenMap.Builder<String, MappingMetaData> mappings = ImmutableOpenMap.builder().         mappings.put(MapperService.SINGLE_MAPPING_NAME, indexEntry.getValue()).         allMappings.put(indexEntry.getKey(), mappings.build()).     }     org.elasticsearch.action.admin.indices.mapping.get.GetMappingsResponse serverResponse = new org.elasticsearch.action.admin.indices.mapping.get.GetMappingsResponse(allMappings.build()).     builder.startObject().     serverResponse.toXContent(builder, params).     builder.endObject(). }
