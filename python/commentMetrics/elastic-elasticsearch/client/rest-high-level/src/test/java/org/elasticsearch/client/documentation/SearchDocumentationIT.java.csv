commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onResponse(SearchResponse searchResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;142;;@SuppressWarnings({ "unused", "unchecked" }) public void testSearch() throws Exception {     indexSearchTestData().     RestHighLevelClient client = highLevelClient().     {         // tag::search-request-basic         // <1>         SearchRequest searchRequest = new SearchRequest().         // <2>         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         // <3>         searchSourceBuilder.query(QueryBuilders.matchAllQuery()).         // <4>         searchRequest.source(searchSourceBuilder).     // end::search-request-basic     }     {         // tag::search-request-indices         // <1>         SearchRequest searchRequest = new SearchRequest("posts").         // end::search-request-indices         // tag::search-request-routing         // <1>         searchRequest.routing("routing").         // end::search-request-routing         // tag::search-request-indicesOptions         // <1>         searchRequest.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::search-request-indicesOptions         // tag::search-request-preference         // <1>         searchRequest.preference("_local").         // end::search-request-preference         assertNotNull(client.search(searchRequest, RequestOptions.DEFAULT)).     }     {         // tag::search-source-basics         // <1>         SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().         // <2>         sourceBuilder.query(QueryBuilders.termQuery("user", "kimchy")).         // <3>         sourceBuilder.from(0).         // <4>         sourceBuilder.size(5).         // <5>         sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)).         // end::search-source-basics         // tag::search-source-sorting         // <1>         sourceBuilder.sort(new ScoreSortBuilder().order(SortOrder.DESC)).         // <2>         sourceBuilder.sort(new FieldSortBuilder("_id").order(SortOrder.ASC)).         // end::search-source-sorting         // tag::search-source-filtering-off         sourceBuilder.fetchSource(false).         // end::search-source-filtering-off         // tag::search-source-filtering-includes         String[] includeFields = new String[] { "title", "innerObject.*" }.         String[] excludeFields = new String[] { "user" }.         sourceBuilder.fetchSource(includeFields, excludeFields).         // end::search-source-filtering-includes         sourceBuilder.fetchSource(true).         // tag::search-source-setter         SearchRequest searchRequest = new SearchRequest().         searchRequest.indices("posts").         searchRequest.source(sourceBuilder).         // end::search-source-setter         // tag::search-execute         SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT).         // end::search-execute         // tag::search-execute-listener         ActionListener<SearchResponse> listener = new ActionListener<SearchResponse>() {              @Override             public void onResponse(SearchResponse searchResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::search-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::search-execute-async         // <1>         client.searchAsync(searchRequest, RequestOptions.DEFAULT, listener).         // end::search-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).         // tag::search-response-1         RestStatus status = searchResponse.status().         TimeValue took = searchResponse.getTook().         Boolean terminatedEarly = searchResponse.isTerminatedEarly().         boolean timedOut = searchResponse.isTimedOut().         // end::search-response-1         // tag::search-response-2         int totalShards = searchResponse.getTotalShards().         int successfulShards = searchResponse.getSuccessfulShards().         int failedShards = searchResponse.getFailedShards().         for (ShardSearchFailure failure : searchResponse.getShardFailures()) {         // failures should be handled here         }         // end::search-response-2         assertNotNull(searchResponse).         // tag::search-hits-get         SearchHits hits = searchResponse.getHits().         // end::search-hits-get         // tag::search-hits-info         TotalHits totalHits = hits.getTotalHits().         // the total number of hits, must be interpreted in the context of totalHits.relation         long numHits = totalHits.value.         // whether the number of hits is accurate (EQUAL_TO) or a lower bound of the total (GREATER_THAN_OR_EQUAL_TO)         TotalHits.Relation relation = totalHits.relation.         float maxScore = hits.getMaxScore().         // end::search-hits-info         // tag::search-hits-singleHit         SearchHit[] searchHits = hits.getHits().         for (SearchHit hit : searchHits) {         // do something with the SearchHit         }         // end::search-hits-singleHit         for (SearchHit hit : searchHits) {             // tag::search-hits-singleHit-properties             String index = hit.getIndex().             String id = hit.getId().             float score = hit.getScore().             // end::search-hits-singleHit-properties             // tag::search-hits-singleHit-source             String sourceAsString = hit.getSourceAsString().             Map<String, Object> sourceAsMap = hit.getSourceAsMap().             String documentTitle = (String) sourceAsMap.get("title").             List<Object> users = (List<Object>) sourceAsMap.get("user").             Map<String, Object> innerObject = (Map<String, Object>) sourceAsMap.get("innerObject").         // end::search-hits-singleHit-source         }         assertEquals(3, numHits).         assertEquals(TotalHits.Relation.EQUAL_TO, relation).         assertNotNull(hits.getHits()[0].getSourceAsString()).         assertNotNull(hits.getHits()[0].getSourceAsMap().get("title")).         assertNotNull(hits.getHits()[0].getSourceAsMap().get("innerObject")).         assertNull(hits.getHits()[0].getSourceAsMap().get("user")).     } }
false;public;0;26;;@SuppressWarnings("unused") public void testBuildingSearchQueries() {     RestHighLevelClient client = highLevelClient().     {         // tag::search-query-builder-ctor         // <1>         MatchQueryBuilder matchQueryBuilder = new MatchQueryBuilder("user", "kimchy").         // end::search-query-builder-ctor         // tag::search-query-builder-options         // <1>         matchQueryBuilder.fuzziness(Fuzziness.AUTO).         // <2>         matchQueryBuilder.prefixLength(3).         // <3>         matchQueryBuilder.maxExpansions(10).     // end::search-query-builder-options     }     {         // tag::search-query-builders         QueryBuilder matchQueryBuilder = QueryBuilders.matchQuery("user", "kimchy").fuzziness(Fuzziness.AUTO).prefixLength(3).maxExpansions(10).         // end::search-query-builders         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         // tag::search-query-setter         searchSourceBuilder.query(matchQueryBuilder).     // end::search-query-setter     } }
false;public;0;75;;@SuppressWarnings({ "unused" }) public void testSearchRequestAggregations() throws IOException {     RestHighLevelClient client = highLevelClient().     {         BulkRequest request = new BulkRequest().         request.add(new IndexRequest("posts").id("1").source(XContentType.JSON, "company", "Elastic", "age", 20)).         request.add(new IndexRequest("posts").id("2").source(XContentType.JSON, "company", "Elastic", "age", 30)).         request.add(new IndexRequest("posts").id("3").source(XContentType.JSON, "company", "Elastic", "age", 40)).         request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).         BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT).         assertSame(RestStatus.OK, bulkResponse.status()).         assertFalse(bulkResponse.hasFailures()).     }     {         SearchRequest searchRequest = new SearchRequest().         // tag::search-request-aggregations         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         TermsAggregationBuilder aggregation = AggregationBuilders.terms("by_company").field("company.keyword").         aggregation.subAggregation(AggregationBuilders.avg("average_age").field("age")).         searchSourceBuilder.aggregation(aggregation).         // end::search-request-aggregations         searchSourceBuilder.query(QueryBuilders.matchAllQuery()).         searchRequest.source(searchSourceBuilder).         SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT).         {             // tag::search-request-aggregations-get             Aggregations aggregations = searchResponse.getAggregations().             // <1>             Terms byCompanyAggregation = aggregations.get("by_company").             // <2>             Bucket elasticBucket = byCompanyAggregation.getBucketByKey("Elastic").             // <3>             Avg averageAge = elasticBucket.getAggregations().get("average_age").             double avg = averageAge.getValue().             try {                 // tag::search-request-aggregations-get-wrongCast                 // <1>                 Range range = aggregations.get("by_company").             // end::search-request-aggregations-get-wrongCast             } catch (ClassCastException ex) {                 String message = ex.getMessage().                 assertThat(message, containsString("org.elasticsearch.search.aggregations.bucket.terms.ParsedStringTerms")).                 assertThat(message, containsString("org.elasticsearch.search.aggregations.bucket.range.Range")).             }             assertEquals(3, elasticBucket.getDocCount()).             assertEquals(30, avg, 0.0).         }         Aggregations aggregations = searchResponse.getAggregations().         {             // tag::search-request-aggregations-asMap             Map<String, Aggregation> aggregationMap = aggregations.getAsMap().             Terms companyAggregation = (Terms) aggregationMap.get("by_company").         // end::search-request-aggregations-asMap         }         {             // tag::search-request-aggregations-asList             List<Aggregation> aggregationList = aggregations.asList().         // end::search-request-aggregations-asList         }         {             // tag::search-request-aggregations-iterator             for (Aggregation agg : aggregations) {                 String type = agg.getType().                 if (type.equals(TermsAggregationBuilder.NAME)) {                     Bucket elasticBucket = ((Terms) agg).getBucketByKey("Elastic").                     long numberOfDocs = elasticBucket.getDocCount().                 }             }         // end::search-request-aggregations-iterator         }     } }
false;public;0;42;;@SuppressWarnings({ "unused", "rawtypes" }) public void testSearchRequestSuggestions() throws IOException {     RestHighLevelClient client = highLevelClient().     {         BulkRequest request = new BulkRequest().         request.add(new IndexRequest("posts").id("1").source(XContentType.JSON, "user", "kimchy")).         request.add(new IndexRequest("posts").id("2").source(XContentType.JSON, "user", "javanna")).         request.add(new IndexRequest("posts").id("3").source(XContentType.JSON, "user", "tlrx")).         request.add(new IndexRequest("posts").id("4").source(XContentType.JSON, "user", "cbuescher")).         request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).         BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT).         assertSame(RestStatus.OK, bulkResponse.status()).         assertFalse(bulkResponse.hasFailures()).     }     {         SearchRequest searchRequest = new SearchRequest().         // tag::search-request-suggestion         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         SuggestionBuilder termSuggestionBuilder = // <1>         SuggestBuilders.termSuggestion("user").text("kmichy").         SuggestBuilder suggestBuilder = new SuggestBuilder().         // <2>         suggestBuilder.addSuggestion("suggest_user", termSuggestionBuilder).         searchSourceBuilder.suggest(suggestBuilder).         // end::search-request-suggestion         searchRequest.source(searchSourceBuilder).         SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT).         {             // tag::search-request-suggestion-get             // <1>             Suggest suggest = searchResponse.getSuggest().             // <2>             TermSuggestion termSuggestion = suggest.getSuggestion("suggest_user").             for (TermSuggestion.Entry entry : termSuggestion.getEntries()) {                 // <3>                 for (TermSuggestion.Entry.Option option : entry) {                     // <4>                     String suggestText = option.getText().string().                 }             }             // end::search-request-suggestion-get             assertEquals(1, termSuggestion.getEntries().size()).             assertEquals(1, termSuggestion.getEntries().get(0).getOptions().size()).             assertEquals("kimchy", termSuggestion.getEntries().get(0).getOptions().get(0).getText().string()).         }     } }
false;public;0;63;;@SuppressWarnings("unused") public void testSearchRequestHighlighting() throws IOException {     RestHighLevelClient client = highLevelClient().     {         BulkRequest request = new BulkRequest().         request.add(new IndexRequest("posts").id("1").source(XContentType.JSON, "title", "In which order are my Elasticsearch queries executed?", "user", Arrays.asList("kimchy", "luca"), "innerObject", Collections.singletonMap("key", "value"))).         request.add(new IndexRequest("posts").id("2").source(XContentType.JSON, "title", "Current status and upcoming changes in Elasticsearch", "user", Arrays.asList("kimchy", "christoph"), "innerObject", Collections.singletonMap("key", "value"))).         request.add(new IndexRequest("posts").id("3").source(XContentType.JSON, "title", "The Future of Federated Search in Elasticsearch", "user", Arrays.asList("kimchy", "tanguy"), "innerObject", Collections.singletonMap("key", "value"))).         request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).         BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT).         assertSame(RestStatus.OK, bulkResponse.status()).         assertFalse(bulkResponse.hasFailures()).     }     {         SearchRequest searchRequest = new SearchRequest().         // tag::search-request-highlighting         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         // <1>         HighlightBuilder highlightBuilder = new HighlightBuilder().         HighlightBuilder.Field highlightTitle = // <2>         new HighlightBuilder.Field("title").         // <3>         highlightTitle.highlighterType("unified").         // <4>         highlightBuilder.field(highlightTitle).         HighlightBuilder.Field highlightUser = new HighlightBuilder.Field("user").         highlightBuilder.field(highlightUser).         searchSourceBuilder.highlighter(highlightBuilder).         // end::search-request-highlighting         searchSourceBuilder.query(QueryBuilders.boolQuery().should(matchQuery("title", "Elasticsearch")).should(matchQuery("user", "kimchy"))).         searchRequest.source(searchSourceBuilder).         SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT).         {             // tag::search-request-highlighting-get             SearchHits hits = searchResponse.getHits().             for (SearchHit hit : hits.getHits()) {                 Map<String, HighlightField> highlightFields = hit.getHighlightFields().                 // <1>                 HighlightField highlight = highlightFields.get("title").                 // <2>                 Text[] fragments = highlight.fragments().                 String fragmentString = fragments[0].string().             }             // end::search-request-highlighting-get             hits = searchResponse.getHits().             for (SearchHit hit : hits.getHits()) {                 Map<String, HighlightField> highlightFields = hit.getHighlightFields().                 HighlightField highlight = highlightFields.get("title").                 Text[] fragments = highlight.fragments().                 assertEquals(1, fragments.length).                 assertThat(fragments[0].string(), containsString("<em>Elasticsearch</em>")).                 highlight = highlightFields.get("user").                 fragments = highlight.fragments().                 assertEquals(1, fragments.length).                 assertThat(fragments[0].string(), containsString("<em>kimchy</em>")).             }         }     } }
false;public;0;71;;@SuppressWarnings("unused") public void testSearchRequestProfiling() throws IOException {     RestHighLevelClient client = highLevelClient().     {         IndexRequest request = new IndexRequest("posts").id("1").source(XContentType.JSON, "tags", "elasticsearch", "comments", 123).         request.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL).         IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT).         assertSame(RestStatus.CREATED, indexResponse.status()).     }     {         SearchRequest searchRequest = new SearchRequest().         // tag::search-request-profiling         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         searchSourceBuilder.profile(true).         // end::search-request-profiling         searchSourceBuilder.query(QueryBuilders.termQuery("tags", "elasticsearch")).         searchSourceBuilder.aggregation(AggregationBuilders.histogram("by_comments").field("comments").interval(100)).         searchRequest.source(searchSourceBuilder).         SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT).         // tag::search-request-profiling-get         Map<String, ProfileShardResult> profilingResults = // <1>         searchResponse.getProfileResults().         for (Map.Entry<String, ProfileShardResult> profilingResult : profilingResults.entrySet()) {             // <2>             // <3>             String key = profilingResult.getKey().             // <4>             ProfileShardResult profileShardResult = profilingResult.getValue().         }         // end::search-request-profiling-get         ProfileShardResult profileShardResult = profilingResults.values().iterator().next().         assertNotNull(profileShardResult).         // tag::search-request-profiling-queries         List<QueryProfileShardResult> queryProfileShardResults = // <1>         profileShardResult.getQueryProfileResults().         for (QueryProfileShardResult queryProfileResult : queryProfileShardResults) {         // <2>         }         // end::search-request-profiling-queries         assertThat(queryProfileShardResults.size(), equalTo(1)).         for (QueryProfileShardResult queryProfileResult : queryProfileShardResults) {             // tag::search-request-profiling-queries-results             for (ProfileResult profileResult : queryProfileResult.getQueryResults()) {                 // <1>                 // <2>                 String queryName = profileResult.getQueryName().                 // <3>                 long queryTimeInMillis = profileResult.getTime().                 // <4>                 List<ProfileResult> profiledChildren = profileResult.getProfiledChildren().             }             // end::search-request-profiling-queries-results             // tag::search-request-profiling-queries-collectors             // <1>             CollectorResult collectorResult = queryProfileResult.getCollectorResult().             // <2>             String collectorName = collectorResult.getName().             // <3>             Long collectorTimeInMillis = collectorResult.getTime().             // <4>             List<CollectorResult> profiledChildren = collectorResult.getProfiledChildren().         // end::search-request-profiling-queries-collectors         }         // tag::search-request-profiling-aggs         AggregationProfileShardResult aggsProfileResults = // <1>         profileShardResult.getAggregationProfileResults().         for (ProfileResult profileResult : aggsProfileResults.getProfileResults()) {             // <2>             // <3>             String aggName = profileResult.getQueryName().             // <4>             long aggTimeInMillis = profileResult.getTime().             // <5>             List<ProfileResult> profiledChildren = profileResult.getProfiledChildren().         }         // end::search-request-profiling-aggs         assertThat(aggsProfileResults.getProfileResults().size(), equalTo(1)).     } }
false;public;1;4;;@Override public void onResponse(SearchResponse searchResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;1;4;;@Override public void onResponse(ClearScrollResponse clearScrollResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;176;;public void testScroll() throws Exception {     RestHighLevelClient client = highLevelClient().     {         BulkRequest request = new BulkRequest().         request.add(new IndexRequest("posts").id("1").source(XContentType.JSON, "title", "In which order are my Elasticsearch queries executed?")).         request.add(new IndexRequest("posts").id("2").source(XContentType.JSON, "title", "Current status and upcoming changes in Elasticsearch")).         request.add(new IndexRequest("posts").id("3").source(XContentType.JSON, "title", "The Future of Federated Search in Elasticsearch")).         request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).         BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT).         assertSame(RestStatus.OK, bulkResponse.status()).         assertFalse(bulkResponse.hasFailures()).     }     {         int size = 1.         // tag::search-scroll-init         SearchRequest searchRequest = new SearchRequest("posts").         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         searchSourceBuilder.query(matchQuery("title", "Elasticsearch")).         // <1>         searchSourceBuilder.size(size).         searchRequest.source(searchSourceBuilder).         // <2>         searchRequest.scroll(TimeValue.timeValueMinutes(1L)).         SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT).         // <3>         String scrollId = searchResponse.getScrollId().         // <4>         SearchHits hits = searchResponse.getHits().         // end::search-scroll-init         assertEquals(3, hits.getTotalHits().value).         assertEquals(1, hits.getHits().length).         assertNotNull(scrollId).         // tag::search-scroll2         // <1>         SearchScrollRequest scrollRequest = new SearchScrollRequest(scrollId).         scrollRequest.scroll(TimeValue.timeValueSeconds(30)).         SearchResponse searchScrollResponse = client.scroll(scrollRequest, RequestOptions.DEFAULT).         // <2>         scrollId = searchScrollResponse.getScrollId().         // <3>         hits = searchScrollResponse.getHits().         assertEquals(3, hits.getTotalHits().value).         assertEquals(1, hits.getHits().length).         assertNotNull(scrollId).         // end::search-scroll2         ClearScrollRequest clearScrollRequest = new ClearScrollRequest().         clearScrollRequest.addScrollId(scrollId).         ClearScrollResponse clearScrollResponse = client.clearScroll(clearScrollRequest, RequestOptions.DEFAULT).         assertTrue(clearScrollResponse.isSucceeded()).     }     {         SearchRequest searchRequest = new SearchRequest().         searchRequest.scroll("60s").         SearchResponse initialSearchResponse = client.search(searchRequest, RequestOptions.DEFAULT).         String scrollId = initialSearchResponse.getScrollId().         SearchScrollRequest scrollRequest = new SearchScrollRequest().         scrollRequest.scrollId(scrollId).         // tag::scroll-request-arguments         // <1>         scrollRequest.scroll(TimeValue.timeValueSeconds(60L)).         // <2>         scrollRequest.scroll("60s").         // end::scroll-request-arguments         // tag::search-scroll-execute-sync         SearchResponse searchResponse = client.scroll(scrollRequest, RequestOptions.DEFAULT).         // end::search-scroll-execute-sync         assertEquals(0, searchResponse.getFailedShards()).         assertEquals(3L, searchResponse.getHits().getTotalHits().value).         // tag::search-scroll-execute-listener         ActionListener<SearchResponse> scrollListener = new ActionListener<SearchResponse>() {              @Override             public void onResponse(SearchResponse searchResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::search-scroll-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         scrollListener = new LatchedActionListener<>(scrollListener, latch).         // tag::search-scroll-execute-async         // <1>         client.scrollAsync(scrollRequest, RequestOptions.DEFAULT, scrollListener).         // end::search-scroll-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).         // tag::clear-scroll-request         // <1>         ClearScrollRequest request = new ClearScrollRequest().         // <2>         request.addScrollId(scrollId).         // end::clear-scroll-request         // tag::clear-scroll-add-scroll-id         request.addScrollId(scrollId).         // end::clear-scroll-add-scroll-id         List<String> scrollIds = Collections.singletonList(scrollId).         // tag::clear-scroll-add-scroll-ids         request.setScrollIds(scrollIds).         // end::clear-scroll-add-scroll-ids         // tag::clear-scroll-execute         ClearScrollResponse response = client.clearScroll(request, RequestOptions.DEFAULT).         // end::clear-scroll-execute         // tag::clear-scroll-response         // <1>         boolean success = response.isSucceeded().         // <2>         int released = response.getNumFreed().         // end::clear-scroll-response         assertTrue(success).         assertThat(released, greaterThan(0)).         // tag::clear-scroll-execute-listener         ActionListener<ClearScrollResponse> listener = new ActionListener<ClearScrollResponse>() {              @Override             public void onResponse(ClearScrollResponse clearScrollResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::clear-scroll-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch clearScrollLatch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, clearScrollLatch).         // tag::clear-scroll-execute-async         // <1>         client.clearScrollAsync(request, RequestOptions.DEFAULT, listener).         // end::clear-scroll-execute-async         assertTrue(clearScrollLatch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::search-scroll-example         final Scroll scroll = new Scroll(TimeValue.timeValueMinutes(1L)).         SearchRequest searchRequest = new SearchRequest("posts").         searchRequest.scroll(scroll).         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         searchSourceBuilder.query(matchQuery("title", "Elasticsearch")).         searchRequest.source(searchSourceBuilder).         // <1>         SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT).         String scrollId = searchResponse.getScrollId().         SearchHit[] searchHits = searchResponse.getHits().getHits().         while (searchHits != null && searchHits.length > 0) {             // <2>             // <3>             // <4>             SearchScrollRequest scrollRequest = new SearchScrollRequest(scrollId).             scrollRequest.scroll(scroll).             searchResponse = client.scroll(scrollRequest, RequestOptions.DEFAULT).             scrollId = searchResponse.getScrollId().             searchHits = searchResponse.getHits().getHits().         }         // <5>         ClearScrollRequest clearScrollRequest = new ClearScrollRequest().         clearScrollRequest.addScrollId(scrollId).         ClearScrollResponse clearScrollResponse = client.clearScroll(clearScrollRequest, RequestOptions.DEFAULT).         boolean succeeded = clearScrollResponse.isSucceeded().         // end::search-scroll-example         assertTrue(succeeded).     } }
false;public;0;46;;public void testSearchTemplateWithInlineScript() throws Exception {     indexSearchTestData().     RestHighLevelClient client = highLevelClient().     // tag::search-template-request-inline     SearchTemplateRequest request = new SearchTemplateRequest().     // <1>     request.setRequest(new SearchRequest("posts")).     request.setScriptType(ScriptType.INLINE).     // <2>     request.setScript("{" + "  \"query\": { \"match\" : { \"{{field}}\" : \"{{value}}\" } }," + "  \"size\" : \"{{size}}\"" + "}").     Map<String, Object> scriptParams = new HashMap<>().     scriptParams.put("field", "title").     scriptParams.put("value", "elasticsearch").     scriptParams.put("size", 5).     // <3>     request.setScriptParams(scriptParams).     // end::search-template-request-inline     // tag::search-template-response     SearchTemplateResponse response = client.searchTemplate(request, RequestOptions.DEFAULT).     SearchResponse searchResponse = response.getResponse().     // end::search-template-response     assertNotNull(searchResponse).     assertTrue(searchResponse.getHits().getTotalHits().value > 0).     // tag::render-search-template-request     // <1>     request.setSimulate(true).     // end::render-search-template-request     // tag::render-search-template-response     SearchTemplateResponse renderResponse = client.searchTemplate(request, RequestOptions.DEFAULT).     // <1>     BytesReference source = renderResponse.getSource().     // end::render-search-template-response     assertNotNull(source).     assertEquals(("{" + "  \"size\" : \"5\"," + "  \"query\": { \"match\" : { \"title\" : \"elasticsearch\" } }" + "}").replaceAll("\\s+", ""), source.utf8ToString()). }
false;public;1;4;;@Override public void onResponse(SearchTemplateResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;58;;public void testSearchTemplateWithStoredScript() throws Exception {     indexSearchTestData().     RestHighLevelClient client = highLevelClient().     RestClient restClient = client().     registerQueryScript(restClient).     // tag::search-template-request-stored     SearchTemplateRequest request = new SearchTemplateRequest().     request.setRequest(new SearchRequest("posts")).     request.setScriptType(ScriptType.STORED).     request.setScript("title_search").     Map<String, Object> params = new HashMap<>().     params.put("field", "title").     params.put("value", "elasticsearch").     params.put("size", 5).     request.setScriptParams(params).     // end::search-template-request-stored     // tag::search-template-request-options     request.setExplain(true).     request.setProfile(true).     // end::search-template-request-options     // tag::search-template-execute     SearchTemplateResponse response = client.searchTemplate(request, RequestOptions.DEFAULT).     // end::search-template-execute     SearchResponse searchResponse = response.getResponse().     assertNotNull(searchResponse).     assertTrue(searchResponse.getHits().getTotalHits().value > 0).     // tag::search-template-execute-listener     ActionListener<SearchTemplateResponse> listener = new ActionListener<SearchTemplateResponse>() {          @Override         public void onResponse(SearchTemplateResponse response) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::search-template-execute-listener     // Replace the empty listener by a blocking listener for tests.     CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::search-template-execute-async     // <1>     client.searchTemplateAsync(request, RequestOptions.DEFAULT, listener).     // end::search-template-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;0;53;;@SuppressWarnings("unused") public void testMultiSearchTemplateWithInlineScript() throws Exception {     indexSearchTestData().     RestHighLevelClient client = highLevelClient().     // tag::multi-search-template-request-inline     String[] searchTerms = { "elasticsearch", "logstash", "kibana" }.     // <1>     MultiSearchTemplateRequest multiRequest = new MultiSearchTemplateRequest().     for (String searchTerm : searchTerms) {         // <2>         SearchTemplateRequest request = new SearchTemplateRequest().         request.setRequest(new SearchRequest("posts")).         request.setScriptType(ScriptType.INLINE).         request.setScript("{" + "  \"query\": { \"match\" : { \"{{field}}\" : \"{{value}}\" } }," + "  \"size\" : \"{{size}}\"" + "}").         Map<String, Object> scriptParams = new HashMap<>().         scriptParams.put("field", "title").         scriptParams.put("value", searchTerm).         scriptParams.put("size", 5).         request.setScriptParams(scriptParams).         // <3>         multiRequest.add(request).     }     // end::multi-search-template-request-inline     // tag::multi-search-template-request-sync     MultiSearchTemplateResponse multiResponse = client.msearchTemplate(multiRequest, RequestOptions.DEFAULT).     // tag::multi-search-template-response     for (Item item : multiResponse.getResponses()) {         // <1>         if (item.isFailure()) {             // <2>             String error = item.getFailureMessage().         } else {             // <3>             SearchTemplateResponse searchTemplateResponse = item.getResponse().             SearchResponse searchResponse = searchTemplateResponse.getResponse().             searchResponse.getHits().         }     }     // end::multi-search-template-response     assertNotNull(multiResponse).     assertEquals(searchTerms.length, multiResponse.getResponses().length).     assertNotNull(multiResponse.getResponses()[0]).     SearchResponse searchResponse = multiResponse.getResponses()[0].getResponse().getResponse().     assertTrue(searchResponse.getHits().getTotalHits().value > 0). }
false;public;1;4;;@Override public void onResponse(MultiSearchTemplateResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;65;;public void testMultiSearchTemplateWithStoredScript() throws Exception {     indexSearchTestData().     RestHighLevelClient client = highLevelClient().     RestClient restClient = client().     registerQueryScript(restClient).     // tag::multi-search-template-request-stored     MultiSearchTemplateRequest multiRequest = new MultiSearchTemplateRequest().     String[] searchTerms = { "elasticsearch", "logstash", "kibana" }.     for (String searchTerm : searchTerms) {         SearchTemplateRequest request = new SearchTemplateRequest().         request.setRequest(new SearchRequest("posts")).         request.setScriptType(ScriptType.STORED).         request.setScript("title_search").         Map<String, Object> params = new HashMap<>().         params.put("field", "title").         params.put("value", searchTerm).         params.put("size", 5).         request.setScriptParams(params).         multiRequest.add(request).     }     // end::multi-search-template-request-stored     // tag::multi-search-template-execute     MultiSearchTemplateResponse multiResponse = client.msearchTemplate(multiRequest, RequestOptions.DEFAULT).     // end::multi-search-template-execute     assertNotNull(multiResponse).     assertEquals(searchTerms.length, multiResponse.getResponses().length).     assertNotNull(multiResponse.getResponses()[0]).     SearchResponse searchResponse = multiResponse.getResponses()[0].getResponse().getResponse().     assertTrue(searchResponse.getHits().getTotalHits().value > 0).     // tag::multi-search-template-execute-listener     ActionListener<MultiSearchTemplateResponse> listener = new ActionListener<MultiSearchTemplateResponse>() {          @Override         public void onResponse(MultiSearchTemplateResponse response) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::multi-search-template-execute-listener     // Replace the empty listener by a blocking listener for tests.     CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::multi-search-template-execute-async     client.msearchTemplateAsync(multiRequest, RequestOptions.DEFAULT, listener).     // end::multi-search-template-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;protected;1;17;;protected void registerQueryScript(RestClient restClient) throws IOException {     // tag::register-script     Request scriptRequest = new Request("POST", "_scripts/title_search").     scriptRequest.setJsonEntity("{" + "  \"script\": {" + "    \"lang\": \"mustache\"," + "    \"source\": {" + "      \"query\": { \"match\" : { \"{{field}}\" : \"{{value}}\" } }," + "      \"size\" : \"{{size}}\"" + "    }" + "  }" + "}").     Response scriptResponse = restClient.performRequest(scriptRequest).     // end::register-script     assertEquals(RestStatus.OK.getStatus(), scriptResponse.getStatusLine().getStatusCode()). }
false;public;1;4;;@Override public void onResponse(ExplainResponse explainResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;76;;public void testExplain() throws Exception {     indexSearchTestData().     RestHighLevelClient client = highLevelClient().     // tag::explain-request     ExplainRequest request = new ExplainRequest("contributors", "1").     request.query(QueryBuilders.termQuery("user", "tanguy")).     // end::explain-request     // tag::explain-request-routing     // <1>     request.routing("routing").     // end::explain-request-routing     // tag::explain-request-preference     // <1>     request.preference("_local").     // end::explain-request-preference     // tag::explain-request-source     // <1>     request.fetchSourceContext(new FetchSourceContext(true, new String[] { "user" }, null)).     // end::explain-request-source     // tag::explain-request-stored-field     // <1>     request.storedFields(new String[] { "user" }).     // end::explain-request-stored-field     // tag::explain-execute     ExplainResponse response = client.explain(request, RequestOptions.DEFAULT).     // end::explain-execute     // tag::explain-response     // <1>     String index = response.getIndex().     // <2>     String id = response.getId().     // <3>     boolean exists = response.isExists().     // <4>     boolean match = response.isMatch().     // <5>     boolean hasExplanation = response.hasExplanation().     // <6>     Explanation explanation = response.getExplanation().     // <7>     GetResult getResult = response.getGetResult().     // end::explain-response     assertThat(index, equalTo("contributors")).     assertThat(id, equalTo("1")).     assertTrue(exists).     assertTrue(match).     assertTrue(hasExplanation).     assertNotNull(explanation).     assertNotNull(getResult).     // tag::get-result     // <1>     Map<String, Object> source = getResult.getSource().     // <2>     Map<String, DocumentField> fields = getResult.getFields().     // end::get-result     assertThat(source, equalTo(Collections.singletonMap("user", "tanguy"))).     assertThat(fields.get("user").getValue(), equalTo("tanguy")).     // tag::explain-execute-listener     ActionListener<ExplainResponse> listener = new ActionListener<ExplainResponse>() {          @Override         public void onResponse(ExplainResponse explainResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::explain-execute-listener     CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::explain-execute-async     // <1>     client.explainAsync(request, RequestOptions.DEFAULT, listener).     // end::explain-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(FieldCapabilitiesResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;63;;public void testFieldCaps() throws Exception {     indexSearchTestData().     RestHighLevelClient client = highLevelClient().     // tag::field-caps-request     FieldCapabilitiesRequest request = new FieldCapabilitiesRequest().fields("user").indices("posts", "authors", "contributors").     // end::field-caps-request     // tag::field-caps-request-indicesOptions     // <1>     request.indicesOptions(IndicesOptions.lenientExpandOpen()).     // end::field-caps-request-indicesOptions     // tag::field-caps-execute     FieldCapabilitiesResponse response = client.fieldCaps(request, RequestOptions.DEFAULT).     // end::field-caps-execute     // tag::field-caps-response     // <1>     Map<String, FieldCapabilities> userResponse = response.getField("user").     FieldCapabilities textCapabilities = userResponse.get("keyword").     boolean isSearchable = textCapabilities.isSearchable().     boolean isAggregatable = textCapabilities.isAggregatable().     // <2>     String[] indices = textCapabilities.indices().     // <3>     String[] nonSearchableIndices = textCapabilities.nonSearchableIndices().     // <4>     String[] nonAggregatableIndices = textCapabilities.nonAggregatableIndices().     // end::field-caps-response     assertThat(userResponse.keySet(), containsInAnyOrder("keyword", "text")).     assertTrue(isSearchable).     assertFalse(isAggregatable).     assertArrayEquals(indices, new String[] { "authors", "contributors" }).     assertNull(nonSearchableIndices).     assertArrayEquals(nonAggregatableIndices, new String[] { "authors" }).     // tag::field-caps-execute-listener     ActionListener<FieldCapabilitiesResponse> listener = new ActionListener<FieldCapabilitiesResponse>() {          @Override         public void onResponse(FieldCapabilitiesResponse response) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::field-caps-execute-listener     // Replace the empty listener by a blocking listener for tests.     CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::field-caps-execute-async     // <1>     client.fieldCapsAsync(request, RequestOptions.DEFAULT, listener).     // end::field-caps-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(RankEvalResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;70;;public void testRankEval() throws Exception {     indexSearchTestData().     RestHighLevelClient client = highLevelClient().     {         // tag::rank-eval-request-basic         // <1>         EvaluationMetric metric = new PrecisionAtK().         List<RatedDocument> ratedDocs = new ArrayList<>().         // <2>         ratedDocs.add(new RatedDocument("posts", "1", 1)).         SearchSourceBuilder searchQuery = new SearchSourceBuilder().         // <3>         searchQuery.query(QueryBuilders.matchQuery("user", "kimchy")).         // <4>         RatedRequest ratedRequest = new RatedRequest("kimchy_query", ratedDocs, searchQuery).         List<RatedRequest> ratedRequests = Arrays.asList(ratedRequest).         RankEvalSpec specification = // <5>         new RankEvalSpec(ratedRequests, metric).         // <6>         RankEvalRequest request = new RankEvalRequest(specification, new String[] { "posts" }).         // end::rank-eval-request-basic         // tag::rank-eval-execute         RankEvalResponse response = client.rankEval(request, RequestOptions.DEFAULT).         // end::rank-eval-execute         // tag::rank-eval-response         // <1>         double evaluationResult = response.getMetricScore().         assertEquals(1.0 / 3.0, evaluationResult, 0.0).         Map<String, EvalQueryQuality> partialResults = response.getPartialResults().         EvalQueryQuality evalQuality = // <2>         partialResults.get("kimchy_query").         assertEquals("kimchy_query", evalQuality.getId()).         // <3>         double qualityLevel = evalQuality.metricScore().         assertEquals(1.0 / 3.0, qualityLevel, 0.0).         List<RatedSearchHit> hitsAndRatings = evalQuality.getHitsAndRatings().         RatedSearchHit ratedSearchHit = hitsAndRatings.get(2).         // <4>         assertEquals("3", ratedSearchHit.getSearchHit().getId()).         // <5>         assertFalse(ratedSearchHit.getRating().isPresent()).         MetricDetail metricDetails = evalQuality.getMetricDetails().         String metricName = metricDetails.getMetricName().         // <6>         assertEquals(PrecisionAtK.NAME, metricName).         PrecisionAtK.Detail detail = (PrecisionAtK.Detail) metricDetails.         // <7>         assertEquals(1, detail.getRelevantRetrieved()).         assertEquals(3, detail.getRetrieved()).         // end::rank-eval-response         // tag::rank-eval-execute-listener         ActionListener<RankEvalResponse> listener = new ActionListener<RankEvalResponse>() {              @Override             public void onResponse(RankEvalResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::rank-eval-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::rank-eval-execute-async         // <1>         client.rankEvalAsync(request, RequestOptions.DEFAULT, listener).         // end::rank-eval-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(MultiSearchResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;56;;public void testMultiSearch() throws Exception {     indexSearchTestData().     RestHighLevelClient client = highLevelClient().     {         // tag::multi-search-request-basic         // <1>         MultiSearchRequest request = new MultiSearchRequest().         // <2>         SearchRequest firstSearchRequest = new SearchRequest().         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         searchSourceBuilder.query(QueryBuilders.matchQuery("user", "kimchy")).         firstSearchRequest.source(searchSourceBuilder).         // <3>         request.add(firstSearchRequest).         // <4>         SearchRequest secondSearchRequest = new SearchRequest().         searchSourceBuilder = new SearchSourceBuilder().         searchSourceBuilder.query(QueryBuilders.matchQuery("user", "luca")).         secondSearchRequest.source(searchSourceBuilder).         request.add(secondSearchRequest).         // end::multi-search-request-basic         // tag::multi-search-execute         MultiSearchResponse response = client.msearch(request, RequestOptions.DEFAULT).         // end::multi-search-execute         // tag::multi-search-response         // <1>         MultiSearchResponse.Item firstResponse = response.getResponses()[0].         // <2>         assertNull(firstResponse.getFailure()).         // <3>         SearchResponse searchResponse = firstResponse.getResponse().         assertEquals(4, searchResponse.getHits().getTotalHits().value).         // <4>         MultiSearchResponse.Item secondResponse = response.getResponses()[1].         assertNull(secondResponse.getFailure()).         searchResponse = secondResponse.getResponse().         assertEquals(1, searchResponse.getHits().getTotalHits().value).         // end::multi-search-response         // tag::multi-search-execute-listener         ActionListener<MultiSearchResponse> listener = new ActionListener<MultiSearchResponse>() {              @Override             public void onResponse(MultiSearchResponse response) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::multi-search-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::multi-search-execute-async         // <1>         client.msearchAsync(request, RequestOptions.DEFAULT, listener).         // end::multi-search-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;private;0;47;;private void indexSearchTestData() throws IOException {     CreateIndexRequest authorsRequest = new CreateIndexRequest("authors").mapping(XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("user").field("type", "keyword").field("doc_values", "false").endObject().endObject().endObject()).     CreateIndexResponse authorsResponse = highLevelClient().indices().create(authorsRequest, RequestOptions.DEFAULT).     assertTrue(authorsResponse.isAcknowledged()).     CreateIndexRequest reviewersRequest = new CreateIndexRequest("contributors").mapping(XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("user").field("type", "keyword").field("store", "true").endObject().endObject().endObject()).     CreateIndexResponse reviewersResponse = highLevelClient().indices().create(reviewersRequest, RequestOptions.DEFAULT).     assertTrue(reviewersResponse.isAcknowledged()).     BulkRequest bulkRequest = new BulkRequest().     bulkRequest.add(new IndexRequest("posts").id("1").source(XContentType.JSON, "title", "In which order are my Elasticsearch queries executed?", "user", Arrays.asList("kimchy", "luca"), "innerObject", Collections.singletonMap("key", "value"))).     bulkRequest.add(new IndexRequest("posts").id("2").source(XContentType.JSON, "title", "Current status and upcoming changes in Elasticsearch", "user", Arrays.asList("kimchy", "christoph"), "innerObject", Collections.singletonMap("key", "value"))).     bulkRequest.add(new IndexRequest("posts").id("3").source(XContentType.JSON, "title", "The Future of Federated Search in Elasticsearch", "user", Arrays.asList("kimchy", "tanguy"), "innerObject", Collections.singletonMap("key", "value"))).     bulkRequest.add(new IndexRequest("authors").id("1").source(XContentType.JSON, "user", "kimchy")).     bulkRequest.add(new IndexRequest("contributors").id("1").source(XContentType.JSON, "user", "tanguy")).     bulkRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     BulkResponse bulkResponse = highLevelClient().bulk(bulkRequest, RequestOptions.DEFAULT).     assertSame(RestStatus.OK, bulkResponse.status()).     assertFalse(bulkResponse.hasFailures()). }
false;public;1;4;;@Override public void onResponse(CountResponse countResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;83;;@SuppressWarnings({ "unused", "unchecked" }) public void testCount() throws Exception {     indexCountTestData().     RestHighLevelClient client = highLevelClient().     {         // tag::count-request-basic         // <1>         CountRequest countRequest = new CountRequest().         // <2>         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().         // <3>         searchSourceBuilder.query(QueryBuilders.matchAllQuery()).         // <4>         countRequest.source(searchSourceBuilder).     // end::count-request-basic     }     {         // tag::count-request-args         CountRequest countRequest = // <1>         new CountRequest("blog").routing(// <2>         "routing").indicesOptions(// <3>         IndicesOptions.lenientExpandOpen()).preference(// <4>         "_local").         // end::count-request-args         assertNotNull(client.count(countRequest, RequestOptions.DEFAULT)).     }     {         // tag::count-source-basics         // <1>         SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().         // <2>         sourceBuilder.query(QueryBuilders.termQuery("user", "kimchy")).         // end::count-source-basics         // tag::count-source-setter         CountRequest countRequest = new CountRequest().         countRequest.indices("blog", "author").         countRequest.source(sourceBuilder).         // end::count-source-setter         // tag::count-execute         CountResponse countResponse = client.count(countRequest, RequestOptions.DEFAULT).         // end::count-execute         // tag::count-execute-listener         ActionListener<CountResponse> listener = new ActionListener<CountResponse>() {              @Override             public void onResponse(CountResponse countResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::count-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::count-execute-async         // <1>         client.countAsync(countRequest, RequestOptions.DEFAULT, listener).         // end::count-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).         // tag::count-response-1         long count = countResponse.getCount().         RestStatus status = countResponse.status().         Boolean terminatedEarly = countResponse.isTerminatedEarly().         // end::count-response-1         // tag::count-response-2         int totalShards = countResponse.getTotalShards().         int skippedShards = countResponse.getSkippedShards().         int successfulShards = countResponse.getSuccessfulShards().         int failedShards = countResponse.getFailedShards().         for (ShardSearchFailure failure : countResponse.getShardFailures()) {         // failures should be handled here         }         // end::count-response-2         assertNotNull(countResponse).         assertEquals(4, countResponse.getCount()).     } }
false;private,static;0;33;;private static void indexCountTestData() throws IOException {     CreateIndexRequest authorsRequest = new CreateIndexRequest("author").mapping(XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("user").field("type", "keyword").field("doc_values", "false").endObject().endObject().endObject()).     CreateIndexResponse authorsResponse = highLevelClient().indices().create(authorsRequest, RequestOptions.DEFAULT).     assertTrue(authorsResponse.isAcknowledged()).     BulkRequest bulkRequest = new BulkRequest().     bulkRequest.add(new IndexRequest("blog").id("1").source(XContentType.JSON, "title", "Doubling Down on Open?", "user", Collections.singletonList("kimchy"), "innerObject", Collections.singletonMap("key", "value"))).     bulkRequest.add(new IndexRequest("blog").id("2").source(XContentType.JSON, "title", "Swiftype Joins Forces with Elastic", "user", Arrays.asList("kimchy", "matt"), "innerObject", Collections.singletonMap("key", "value"))).     bulkRequest.add(new IndexRequest("blog").id("3").source(XContentType.JSON, "title", "On Net Neutrality", "user", Arrays.asList("tyler", "kimchy"), "innerObject", Collections.singletonMap("key", "value"))).     bulkRequest.add(new IndexRequest("author").id("1").source(XContentType.JSON, "user", "kimchy")).     bulkRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).     BulkResponse bulkResponse = highLevelClient().bulk(bulkRequest, RequestOptions.DEFAULT).     assertSame(RestStatus.OK, bulkResponse.status()).     assertFalse(bulkResponse.hasFailures()). }
