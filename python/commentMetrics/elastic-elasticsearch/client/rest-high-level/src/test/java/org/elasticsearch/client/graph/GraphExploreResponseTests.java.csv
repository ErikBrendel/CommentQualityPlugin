commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected GraphExploreResponse createTestInstance() {     return createInstance(0). }
false;private,static;1;32;;private static GraphExploreResponse createInstance(int numFailures) {     int numItems = randomIntBetween(4, 128).     boolean timedOut = randomBoolean().     boolean showDetails = randomBoolean().     long overallTookInMillis = randomNonNegativeLong().     Map<Vertex.VertexId, Vertex> vertices = new HashMap<>().     Map<Connection.ConnectionId, Connection> connections = new HashMap<>().     ShardOperationFailedException[] failures = new ShardOperationFailedException[numFailures].     for (int i = 0. i < failures.length. i++) {         failures[i] = new ShardSearchFailure(new ElasticsearchException("an error")).     }     // Create random set of vertices     for (int i = 0. i < numItems. i++) {         Vertex v = new Vertex("field1", randomAlphaOfLength(5), randomDouble(), 0, showDetails ? randomIntBetween(100, 200) : 0, showDetails ? randomIntBetween(1, 100) : 0).         vertices.put(v.getId(), v).     }     // Wire up half the vertices randomly     Vertex[] vs = vertices.values().toArray(new Vertex[vertices.size()]).     for (int i = 0. i < numItems / 2. i++) {         Vertex v1 = vs[randomIntBetween(0, vs.length - 1)].         Vertex v2 = vs[randomIntBetween(0, vs.length - 1)].         if (v1 != v2) {             Connection conn = new Connection(v1, v2, randomDouble(), randomLongBetween(1, 10)).             connections.put(conn.getId(), conn).         }     }     return new GraphExploreResponse(overallTookInMillis, timedOut, failures, vertices, connections, showDetails). }
false;private,static;0;3;;private static GraphExploreResponse createTestInstanceWithFailures() {     return createInstance(randomIntBetween(1, 128)). }
false;protected;1;4;;@Override protected GraphExploreResponse doParseInstance(XContentParser parser) throws IOException {     return GraphExploreResponse.fromXContent(parser). }
false;protected;0;4;;@Override protected boolean supportsUnknownFields() {     return true. }
false;protected;0;4;;@Override protected boolean assertToXContentEquivalence() {     return false. }
false;protected;0;4;;@Override protected String[] getShuffleFieldsExceptions() {     return new String[] { "vertices", "connections" }. }
false;protected;0;3;;protected Predicate<String> getRandomFieldsExcludeFilterWhenResultHasErrors() {     return field -> field.startsWith("responses"). }
false;public;2;4;;@Override public int compare(Connection o1, Connection o2) {     return o1.getId().toString().compareTo(o2.getId().toString()). }
false;public;2;4;;@Override public int compare(Vertex o1, Vertex o2) {     return o1.getId().toString().compareTo(o2.getId().toString()). }
false;protected;2;35;;@Override protected void assertEqualInstances(GraphExploreResponse expectedInstance, GraphExploreResponse newInstance) {     assertThat(newInstance.getTook(), equalTo(expectedInstance.getTook())).     assertThat(newInstance.isTimedOut(), equalTo(expectedInstance.isTimedOut())).     Comparator<Connection> connComparator = new Comparator<Connection>() {          @Override         public int compare(Connection o1, Connection o2) {             return o1.getId().toString().compareTo(o2.getId().toString()).         }     }.     Connection[] newConns = newInstance.getConnections().toArray(new Connection[0]).     Connection[] expectedConns = expectedInstance.getConnections().toArray(new Connection[0]).     Arrays.sort(newConns, connComparator).     Arrays.sort(expectedConns, connComparator).     assertArrayEquals(expectedConns, newConns).     // Sort the vertices lists before equality test (map insertion sequences can cause order differences)     Comparator<Vertex> comparator = new Comparator<Vertex>() {          @Override         public int compare(Vertex o1, Vertex o2) {             return o1.getId().toString().compareTo(o2.getId().toString()).         }     }.     Vertex[] newVertices = newInstance.getVertices().toArray(new Vertex[0]).     Vertex[] expectedVertices = expectedInstance.getVertices().toArray(new Vertex[0]).     Arrays.sort(newVertices, comparator).     Arrays.sort(expectedVertices, comparator).     assertArrayEquals(expectedVertices, newVertices).     ShardOperationFailedException[] newFailures = newInstance.getShardFailures().     ShardOperationFailedException[] expectedFailures = expectedInstance.getShardFailures().     assertEquals(expectedFailures.length, newFailures.length). }
true;public;0;12;/**  * Test parsing {@link  GraphExploreResponse} with inner failures as they don't support asserting on xcontent equivalence, given  * exceptions are not parsed back as the same original class. We run the usual {@link AbstractXContentTestCase#testFromXContent()}  * without failures, and this other test with failures where we disable asserting on xcontent equivalence at the end.  */ ;/**  * Test parsing {@link  GraphExploreResponse} with inner failures as they don't support asserting on xcontent equivalence, given  * exceptions are not parsed back as the same original class. We run the usual {@link AbstractXContentTestCase#testFromXContent()}  * without failures, and this other test with failures where we disable asserting on xcontent equivalence at the end.  */ public void testFromXContentWithFailures() throws IOException {     Supplier<GraphExploreResponse> instanceSupplier = GraphExploreResponseTests::createTestInstanceWithFailures.     // with random fields insertion in the inner exceptions, some random stuff may be parsed back as metadata,     // but that does not bother our assertions, as we only want to test that we don't break.     boolean supportsUnknownFields = true.     // exceptions are not of the same type whenever parsed back     boolean assertToXContentEquivalence = false.     AbstractXContentTestCase.testFromXContent(NUMBER_OF_TEST_RUNS, instanceSupplier, supportsUnknownFields, getShuffleFieldsExceptions(), getRandomFieldsExcludeFilterWhenResultHasErrors(), this::createParser, this::doParseInstance, this::assertEqualInstances, assertToXContentEquivalence, ToXContent.EMPTY_PARAMS). }
