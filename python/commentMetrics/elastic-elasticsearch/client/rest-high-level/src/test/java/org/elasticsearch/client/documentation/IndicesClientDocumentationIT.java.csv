commented;modifiers;parameterAmount;loc;comment;code
false;public;0;28;;public void testIndicesExist() throws IOException {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("twitter"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::indices-exists-request         // <1>         GetIndexRequest request = new GetIndexRequest("twitter").         // end::indices-exists-request         IndicesOptions indicesOptions = IndicesOptions.strictExpand().         // tag::indices-exists-request-optionals         // <1>         request.local(false).         // <2>         request.humanReadable(true).         // <3>         request.includeDefaults(false).         // <4>         request.indicesOptions(indicesOptions).         // end::indices-exists-request-optionals         // tag::indices-exists-execute         boolean exists = client.indices().exists(request, RequestOptions.DEFAULT).         // end::indices-exists-execute         assertTrue(exists).     } }
false;public;1;4;;@Override public void onResponse(Boolean exists) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;36;;public void testIndicesExistAsync() throws Exception {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("twitter"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         GetIndexRequest request = new GetIndexRequest("twitter").         // tag::indices-exists-execute-listener         ActionListener<Boolean> listener = new ActionListener<Boolean>() {              @Override             public void onResponse(Boolean exists) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::indices-exists-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::indices-exists-execute-async         // <1>         client.indices().existsAsync(request, RequestOptions.DEFAULT, listener).         // end::indices-exists-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;0;48;;public void testDeleteIndex() throws IOException {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("posts"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::delete-index-request         // <1>         DeleteIndexRequest request = new DeleteIndexRequest("posts").         // end::delete-index-request         // tag::delete-index-request-timeout         // <1>         request.timeout(TimeValue.timeValueMinutes(2)).         // <2>         request.timeout("2m").         // end::delete-index-request-timeout         // tag::delete-index-request-masterTimeout         // <1>         request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).         // <2>         request.masterNodeTimeout("1m").         // end::delete-index-request-masterTimeout         // tag::delete-index-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::delete-index-request-indicesOptions         // tag::delete-index-execute         AcknowledgedResponse deleteIndexResponse = client.indices().delete(request, RequestOptions.DEFAULT).         // end::delete-index-execute         // tag::delete-index-response         // <1>         boolean acknowledged = deleteIndexResponse.isAcknowledged().         // end::delete-index-response         assertTrue(acknowledged).     }     {         // tag::delete-index-notfound         try {             DeleteIndexRequest request = new DeleteIndexRequest("does_not_exist").             client.indices().delete(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.NOT_FOUND) {             // <1>             }         }     // end::delete-index-notfound     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse deleteIndexResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;37;;public void testDeleteIndexAsync() throws Exception {     final RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("posts"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         DeleteIndexRequest request = new DeleteIndexRequest("posts").         // tag::delete-index-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse deleteIndexResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::delete-index-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::delete-index-execute-async         // <1>         client.indices().deleteAsync(request, RequestOptions.DEFAULT, listener).         // end::delete-index-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;0;118;;public void testCreateIndex() throws IOException {     RestHighLevelClient client = highLevelClient().     {         // tag::create-index-request         // <1>         CreateIndexRequest request = new CreateIndexRequest("twitter").         // end::create-index-request         // tag::create-index-request-settings         request.settings(// <1>         Settings.builder().put("index.number_of_shards", 3).put("index.number_of_replicas", 2)).         // end::create-index-request-settings         {             // tag::create-index-request-mappings             // <1>             request.mapping("{\n" + "  \"properties\": {\n" + "    \"message\": {\n" + "      \"type\": \"text\"\n" + "    }\n" + "  }\n" + // <2>             "}", XContentType.JSON).             // end::create-index-request-mappings             CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT).             assertTrue(createIndexResponse.isAcknowledged()).         }         {             request = new CreateIndexRequest("twitter2").             // tag::create-index-mappings-map             Map<String, Object> message = new HashMap<>().             message.put("type", "text").             Map<String, Object> properties = new HashMap<>().             properties.put("message", message).             Map<String, Object> mapping = new HashMap<>().             mapping.put("properties", properties).             // <1>             request.mapping(mapping).             // end::create-index-mappings-map             CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT).             assertTrue(createIndexResponse.isAcknowledged()).         }         {             request = new CreateIndexRequest("twitter3").             // tag::create-index-mappings-xcontent             XContentBuilder builder = XContentFactory.jsonBuilder().             builder.startObject().             {                 builder.startObject("properties").                 {                     builder.startObject("message").                     {                         builder.field("type", "text").                     }                     builder.endObject().                 }                 builder.endObject().             }             builder.endObject().             // <1>             request.mapping(builder).             // end::create-index-mappings-xcontent             CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT).             assertTrue(createIndexResponse.isAcknowledged()).         }         request = new CreateIndexRequest("twitter5").         // tag::create-index-request-aliases         // <1>         request.alias(new Alias("twitter_alias").filter(QueryBuilders.termQuery("user", "kimchy"))).         // end::create-index-request-aliases         // tag::create-index-request-timeout         // <1>         request.setTimeout(TimeValue.timeValueMinutes(2)).         // end::create-index-request-timeout         // tag::create-index-request-masterTimeout         // <1>         request.setMasterTimeout(TimeValue.timeValueMinutes(1)).         // end::create-index-request-masterTimeout         // tag::create-index-request-waitForActiveShards         // <1>         request.waitForActiveShards(ActiveShardCount.from(2)).         // <2>         request.waitForActiveShards(ActiveShardCount.DEFAULT).         // end::create-index-request-waitForActiveShards         {             CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT).             assertTrue(createIndexResponse.isAcknowledged()).         }         request = new CreateIndexRequest("twitter6").         // tag::create-index-whole-source         request.source("{\n" + "    \"settings\" : {\n" + "        \"number_of_shards\" : 1,\n" + "        \"number_of_replicas\" : 0\n" + "    },\n" + "    \"mappings\" : {\n" + "        \"properties\" : {\n" + "            \"message\" : { \"type\" : \"text\" }\n" + "        }\n" + "    },\n" + "    \"aliases\" : {\n" + "        \"twitter_alias\" : {}\n" + "    }\n" + "}", // <1>         XContentType.JSON).         // end::create-index-whole-source         // tag::create-index-execute         CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT).         // end::create-index-execute         // tag::create-index-response         // <1>         boolean acknowledged = createIndexResponse.isAcknowledged().         // <2>         boolean shardsAcknowledged = createIndexResponse.isShardsAcknowledged().         // end::create-index-response         assertTrue(acknowledged).         assertTrue(shardsAcknowledged).     } }
false;public;1;4;;@Override public void onResponse(CreateIndexResponse createIndexResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;33;;public void testCreateIndexAsync() throws Exception {     final RestHighLevelClient client = highLevelClient().     {         CreateIndexRequest request = new CreateIndexRequest("twitter").         // tag::create-index-execute-listener         ActionListener<CreateIndexResponse> listener = new ActionListener<CreateIndexResponse>() {              @Override             public void onResponse(CreateIndexResponse createIndexResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::create-index-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::create-index-execute-async         // <1>         client.indices().createAsync(request, RequestOptions.DEFAULT, listener).         // end::create-index-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;0;82;;public void testPutMapping() throws IOException {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("twitter"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::put-mapping-request         // <1>         PutMappingRequest request = new PutMappingRequest("twitter").         // end::put-mapping-request         {             // tag::put-mapping-request-source             request.source("{\n" + "  \"properties\": {\n" + "    \"message\": {\n" + "      \"type\": \"text\"\n" + "    }\n" + "  }\n" + // <1>             "}", XContentType.JSON).             // end::put-mapping-request-source             AcknowledgedResponse putMappingResponse = client.indices().putMapping(request, RequestOptions.DEFAULT).             assertTrue(putMappingResponse.isAcknowledged()).         }         {             // tag::put-mapping-map             Map<String, Object> jsonMap = new HashMap<>().             Map<String, Object> message = new HashMap<>().             message.put("type", "text").             Map<String, Object> properties = new HashMap<>().             properties.put("message", message).             jsonMap.put("properties", properties).             // <1>             request.source(jsonMap).             // end::put-mapping-map             AcknowledgedResponse putMappingResponse = client.indices().putMapping(request, RequestOptions.DEFAULT).             assertTrue(putMappingResponse.isAcknowledged()).         }         {             // tag::put-mapping-xcontent             XContentBuilder builder = XContentFactory.jsonBuilder().             builder.startObject().             {                 builder.startObject("properties").                 {                     builder.startObject("message").                     {                         builder.field("type", "text").                     }                     builder.endObject().                 }                 builder.endObject().             }             builder.endObject().             // <1>             request.source(builder).             // end::put-mapping-xcontent             AcknowledgedResponse putMappingResponse = client.indices().putMapping(request, RequestOptions.DEFAULT).             assertTrue(putMappingResponse.isAcknowledged()).         }         // tag::put-mapping-request-timeout         // <1>         request.setTimeout(TimeValue.timeValueMinutes(2)).         // end::put-mapping-request-timeout         // tag::put-mapping-request-masterTimeout         // <1>         request.setMasterTimeout(TimeValue.timeValueMinutes(1)).         // end::put-mapping-request-masterTimeout         // tag::put-mapping-execute         AcknowledgedResponse putMappingResponse = client.indices().putMapping(request, RequestOptions.DEFAULT).         // end::put-mapping-execute         // tag::put-mapping-response         // <1>         boolean acknowledged = putMappingResponse.isAcknowledged().         // end::put-mapping-response         assertTrue(acknowledged).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse putMappingResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;37;;public void testPutMappingAsync() throws Exception {     final RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("twitter"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         PutMappingRequest request = new PutMappingRequest("twitter").         // tag::put-mapping-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse putMappingResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::put-mapping-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::put-mapping-execute-async         // <1>         client.indices().putMappingAsync(request, RequestOptions.DEFAULT, listener).         // end::put-mapping-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;0;53;;public void testGetMapping() throws IOException {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("twitter"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).         PutMappingRequest request = new PutMappingRequest("twitter").         request.source("{\n" + "  \"properties\": {\n" + "    \"message\": {\n" + "      \"type\": \"text\"\n" + "    }\n" + "  }\n" + // <1>         "}", XContentType.JSON).         AcknowledgedResponse putMappingResponse = client.indices().putMapping(request, RequestOptions.DEFAULT).         assertTrue(putMappingResponse.isAcknowledged()).     }     {         // tag::get-mappings-request         // <1>         GetMappingsRequest request = new GetMappingsRequest().         // <2>         request.indices("twitter").         // end::get-mappings-request         // tag::get-mappings-request-masterTimeout         // <1>         request.setMasterTimeout(TimeValue.timeValueMinutes(1)).         // end::get-mappings-request-masterTimeout         // tag::get-mappings-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::get-mappings-request-indicesOptions         // tag::get-mappings-execute         GetMappingsResponse getMappingResponse = client.indices().getMapping(request, RequestOptions.DEFAULT).         // end::get-mappings-execute         // tag::get-mappings-response         // <1>         Map<String, MappingMetaData> allMappings = getMappingResponse.mappings().         // <2>         MappingMetaData indexMapping = allMappings.get("twitter").         // <3>         Map<String, Object> mapping = indexMapping.sourceAsMap().         // end::get-mappings-response         Map<String, String> type = new HashMap<>().         type.put("type", "text").         Map<String, Object> field = new HashMap<>().         field.put("message", type).         Map<String, Object> expected = new HashMap<>().         expected.put("properties", field).         assertThat(mapping, equalTo(expected)).     } }
false;public;1;4;;@Override public void onResponse(GetMappingsResponse putMappingResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;67;;public void testGetMappingAsync() throws Exception {     final RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("twitter"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).         PutMappingRequest request = new PutMappingRequest("twitter").         request.source("{\n" + "  \"properties\": {\n" + "    \"message\": {\n" + "      \"type\": \"text\"\n" + "    }\n" + "  }\n" + // <1>         "}", XContentType.JSON).         AcknowledgedResponse putMappingResponse = client.indices().putMapping(request, RequestOptions.DEFAULT).         assertTrue(putMappingResponse.isAcknowledged()).     }     {         GetMappingsRequest request = new GetMappingsRequest().         request.indices("twitter").         // tag::get-mappings-execute-listener         ActionListener<GetMappingsResponse> listener = new ActionListener<GetMappingsResponse>() {              @Override             public void onResponse(GetMappingsResponse putMappingResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-mappings-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         final ActionListener<GetMappingsResponse> latchListener = new LatchedActionListener<>(listener, latch).         listener = ActionListener.wrap(r -> {             Map<String, MappingMetaData> allMappings = r.mappings().             MappingMetaData indexMapping = allMappings.get("twitter").             Map<String, Object> mapping = indexMapping.sourceAsMap().             Map<String, String> type = new HashMap<>().             type.put("type", "text").             Map<String, Object> field = new HashMap<>().             field.put("message", type).             Map<String, Object> expected = new HashMap<>().             expected.put("properties", field).             assertThat(mapping, equalTo(expected)).             latchListener.onResponse(r).         }, e -> {             latchListener.onFailure(e).             fail("should not fail").         }).         // tag::get-mappings-execute-async         // <1>         client.indices().getMappingAsync(request, RequestOptions.DEFAULT, listener).         // end::get-mappings-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(GetFieldMappingsResponse putMappingResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;101;;@SuppressWarnings("unused") public void testGetFieldMapping() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("twitter"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).         PutMappingRequest request = new PutMappingRequest("twitter").         request.source("{\n" + "  \"properties\": {\n" + "    \"message\": {\n" + "      \"type\": \"text\"\n" + "    },\n" + "    \"timestamp\": {\n" + "      \"type\": \"date\"\n" + "    }\n" + "  }\n" + // <1>         "}", XContentType.JSON).         AcknowledgedResponse putMappingResponse = client.indices().putMapping(request, RequestOptions.DEFAULT).         assertTrue(putMappingResponse.isAcknowledged()).     }     // tag::get-field-mappings-request     // <1>     GetFieldMappingsRequest request = new GetFieldMappingsRequest().     // <2>     request.indices("twitter").     // <3>     request.fields("message", "timestamp").     // end::get-field-mappings-request     // tag::get-field-mappings-request-indicesOptions     // <1>     request.indicesOptions(IndicesOptions.lenientExpandOpen()).     // end::get-field-mappings-request-indicesOptions     // tag::get-field-mappings-request-local     // <1>     request.local(true).     // end::get-field-mappings-request-local     {         // tag::get-field-mappings-execute         GetFieldMappingsResponse response = client.indices().getFieldMapping(request, RequestOptions.DEFAULT).         // end::get-field-mappings-execute         // tag::get-field-mappings-response         final Map<String, Map<String, GetFieldMappingsResponse.FieldMappingMetaData>> mappings = // <1>         response.mappings().         final Map<String, GetFieldMappingsResponse.FieldMappingMetaData> fieldMappings = // <2>         mappings.get("twitter").         final GetFieldMappingsResponse.FieldMappingMetaData metaData = // <3>         fieldMappings.get("message").         // <4>         final String fullName = metaData.fullName().         // <5>         final Map<String, Object> source = metaData.sourceAsMap().     // end::get-field-mappings-response     }     {         // tag::get-field-mappings-execute-listener         ActionListener<GetFieldMappingsResponse> listener = new ActionListener<GetFieldMappingsResponse>() {              @Override             public void onResponse(GetFieldMappingsResponse putMappingResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-field-mappings-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         final ActionListener<GetFieldMappingsResponse> latchListener = new LatchedActionListener<>(listener, latch).         listener = ActionListener.wrap(r -> {             final Map<String, Map<String, GetFieldMappingsResponse.FieldMappingMetaData>> mappings = r.mappings().             final Map<String, GetFieldMappingsResponse.FieldMappingMetaData> fieldMappings = mappings.get("twitter").             final GetFieldMappingsResponse.FieldMappingMetaData metaData1 = fieldMappings.get("message").             final String fullName = metaData1.fullName().             final Map<String, Object> source = metaData1.sourceAsMap().             latchListener.onResponse(r).         }, e -> {             latchListener.onFailure(e).             fail("should not fail").         }).         // tag::get-field-mappings-execute-async         // <1>         client.indices().getFieldMappingAsync(request, RequestOptions.DEFAULT, listener).         // end::get-field-mappings-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(OpenIndexResponse openIndexResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;80;;public void testOpenIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::open-index-request         // <1>         OpenIndexRequest request = new OpenIndexRequest("index").         // end::open-index-request         // tag::open-index-request-timeout         // <1>         request.timeout(TimeValue.timeValueMinutes(2)).         // <2>         request.timeout("2m").         // end::open-index-request-timeout         // tag::open-index-request-masterTimeout         // <1>         request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).         // <2>         request.masterNodeTimeout("1m").         // end::open-index-request-masterTimeout         // tag::open-index-request-waitForActiveShards         // <1>         request.waitForActiveShards(2).         // <2>         request.waitForActiveShards(ActiveShardCount.DEFAULT).         // end::open-index-request-waitForActiveShards         // tag::open-index-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.strictExpandOpen()).         // end::open-index-request-indicesOptions         // tag::open-index-execute         OpenIndexResponse openIndexResponse = client.indices().open(request, RequestOptions.DEFAULT).         // end::open-index-execute         // tag::open-index-response         // <1>         boolean acknowledged = openIndexResponse.isAcknowledged().         // <2>         boolean shardsAcked = openIndexResponse.isShardsAcknowledged().         // end::open-index-response         assertTrue(acknowledged).         assertTrue(shardsAcked).         // tag::open-index-execute-listener         ActionListener<OpenIndexResponse> listener = new ActionListener<OpenIndexResponse>() {              @Override             public void onResponse(OpenIndexResponse openIndexResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::open-index-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::open-index-execute-async         // <1>         client.indices().openAsync(request, RequestOptions.DEFAULT, listener).         // end::open-index-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::open-index-notfound         try {             OpenIndexRequest request = new OpenIndexRequest("does_not_exist").             client.indices().open(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.BAD_REQUEST) {             // <1>             }         }     // end::open-index-notfound     } }
false;public;1;4;;@Override public void onResponse(RefreshResponse refreshResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;68;;@SuppressWarnings("unused") public void testRefreshIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         createIndex("index1", Settings.EMPTY).     }     {         // tag::refresh-request         // <1>         RefreshRequest request = new RefreshRequest("index1").         // <2>         RefreshRequest requestMultiple = new RefreshRequest("index1", "index2").         // <3>         RefreshRequest requestAll = new RefreshRequest().         // end::refresh-request         // tag::refresh-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::refresh-request-indicesOptions         // tag::refresh-execute         RefreshResponse refreshResponse = client.indices().refresh(request, RequestOptions.DEFAULT).         // end::refresh-execute         // tag::refresh-response         // <1>         int totalShards = refreshResponse.getTotalShards().         // <2>         int successfulShards = refreshResponse.getSuccessfulShards().         // <3>         int failedShards = refreshResponse.getFailedShards().         // <4>         DefaultShardOperationFailedException[] failures = refreshResponse.getShardFailures().         // end::refresh-response         // tag::refresh-execute-listener         ActionListener<RefreshResponse> listener = new ActionListener<RefreshResponse>() {              @Override             public void onResponse(RefreshResponse refreshResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::refresh-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::refresh-execute-async         // <1>         client.indices().refreshAsync(request, RequestOptions.DEFAULT, listener).         // end::refresh-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::refresh-notfound         try {             RefreshRequest request = new RefreshRequest("does_not_exist").             client.indices().refresh(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.NOT_FOUND) {             // <1>             }         }     // end::refresh-notfound     } }
false;public;1;4;;@Override public void onResponse(FlushResponse flushResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;76;;@SuppressWarnings("unused") public void testFlushIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         createIndex("index1", Settings.EMPTY).     }     {         // tag::flush-request         // <1>         FlushRequest request = new FlushRequest("index1").         // <2>         FlushRequest requestMultiple = new FlushRequest("index1", "index2").         // <3>         FlushRequest requestAll = new FlushRequest().         // end::flush-request         // tag::flush-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::flush-request-indicesOptions         // tag::flush-request-wait         // <1>         request.waitIfOngoing(true).         // end::flush-request-wait         // tag::flush-request-force         // <1>         request.force(true).         // end::flush-request-force         // tag::flush-execute         FlushResponse flushResponse = client.indices().flush(request, RequestOptions.DEFAULT).         // end::flush-execute         // tag::flush-response         // <1>         int totalShards = flushResponse.getTotalShards().         // <2>         int successfulShards = flushResponse.getSuccessfulShards().         // <3>         int failedShards = flushResponse.getFailedShards().         // <4>         DefaultShardOperationFailedException[] failures = flushResponse.getShardFailures().         // end::flush-response         // tag::flush-execute-listener         ActionListener<FlushResponse> listener = new ActionListener<FlushResponse>() {              @Override             public void onResponse(FlushResponse flushResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::flush-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::flush-execute-async         // <1>         client.indices().flushAsync(request, RequestOptions.DEFAULT, listener).         // end::flush-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::flush-notfound         try {             FlushRequest request = new FlushRequest("does_not_exist").             client.indices().flush(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.NOT_FOUND) {             // <1>             }         }     // end::flush-notfound     } }
false;public;1;4;;@Override public void onResponse(SyncedFlushResponse refreshResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;83;;@SuppressWarnings("unused") public void testSyncedFlushIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         createIndex("index1", Settings.EMPTY).     }     {         // tag::flush-synced-request         // <1>         SyncedFlushRequest request = new SyncedFlushRequest("index1").         // <2>         SyncedFlushRequest requestMultiple = new SyncedFlushRequest("index1", "index2").         // <3>         SyncedFlushRequest requestAll = new SyncedFlushRequest().         // end::flush-synced-request         // tag::flush-synced-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::flush-synced-request-indicesOptions         // tag::flush-synced-execute         SyncedFlushResponse flushSyncedResponse = client.indices().flushSynced(request, RequestOptions.DEFAULT).         // end::flush-synced-execute         // tag::flush-synced-response         // <1>         int totalShards = flushSyncedResponse.totalShards().         // <2>         int successfulShards = flushSyncedResponse.successfulShards().         // <3>         int failedShards = flushSyncedResponse.failedShards().         for (Map.Entry<String, SyncedFlushResponse.IndexResult> responsePerIndexEntry : flushSyncedResponse.getIndexResults().entrySet()) {             // <4>             String indexName = responsePerIndexEntry.getKey().             SyncedFlushResponse.IndexResult indexResult = responsePerIndexEntry.getValue().             // <5>             int totalShardsForIndex = indexResult.totalShards().             // <6>             int successfulShardsForIndex = indexResult.successfulShards().             // <7>             int failedShardsForIndex = indexResult.failedShards().             if (failedShardsForIndex > 0) {                 for (SyncedFlushResponse.ShardFailure failureEntry : indexResult.failures()) {                     // <8>                     int shardId = failureEntry.getShardId().                     // <9>                     String failureReason = failureEntry.getFailureReason().                     // <10>                     Map<String, Object> routing = failureEntry.getRouting().                 }             }         }         // end::flush-synced-response         // tag::flush-synced-execute-listener         ActionListener<SyncedFlushResponse> listener = new ActionListener<SyncedFlushResponse>() {              @Override             public void onResponse(SyncedFlushResponse refreshResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::flush-synced-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::flush-synced-execute-async         // <1>         client.indices().flushSyncedAsync(request, RequestOptions.DEFAULT, listener).         // end::flush-synced-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::flush-synced-notfound         try {             SyncedFlushRequest request = new SyncedFlushRequest("does_not_exist").             client.indices().flushSynced(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.NOT_FOUND) {             // <1>             }         }     // end::flush-synced-notfound     } }
false;public;1;4;;@Override public void onResponse(GetSettingsResponse GetSettingsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;63;;public void testGetSettings() throws Exception {     RestHighLevelClient client = highLevelClient().     {         Settings settings = Settings.builder().put("number_of_shards", 3).build().         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index").settings(settings), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     // tag::get-settings-request     // <1>     GetSettingsRequest request = new GetSettingsRequest().indices("index").     // end::get-settings-request     // tag::get-settings-request-names     // <1>     request.names("index.number_of_shards").     // end::get-settings-request-names     // tag::get-settings-request-indicesOptions     // <1>     request.indicesOptions(IndicesOptions.lenientExpandOpen()).     // end::get-settings-request-indicesOptions     // tag::get-settings-execute     GetSettingsResponse getSettingsResponse = client.indices().getSettings(request, RequestOptions.DEFAULT).     // end::get-settings-execute     // tag::get-settings-response     // <1>     String numberOfShardsString = getSettingsResponse.getSetting("index", "index.number_of_shards").     // <2>     Settings indexSettings = getSettingsResponse.getIndexToSettings().get("index").     // <3>     Integer numberOfShards = indexSettings.getAsInt("index.number_of_shards", null).     // end::get-settings-response     assertEquals("3", numberOfShardsString).     assertEquals(Integer.valueOf(3), numberOfShards).     assertNull("refresh_interval returned but was never set!", getSettingsResponse.getSetting("index", "index.refresh_interval")).     // tag::get-settings-execute-listener     ActionListener<GetSettingsResponse> listener = new ActionListener<GetSettingsResponse>() {          @Override         public void onResponse(GetSettingsResponse GetSettingsResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::get-settings-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::get-settings-execute-async     // <1>     client.indices().getSettingsAsync(request, RequestOptions.DEFAULT, listener).     // end::get-settings-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;3;;@Override public void onResponse(GetSettingsResponse GetSettingsResponse) { }
false;public;1;3;;@Override public void onFailure(Exception e) { }
false;public;0;50;;public void testGetSettingsWithDefaults() throws Exception {     RestHighLevelClient client = highLevelClient().     {         Settings settings = Settings.builder().put("number_of_shards", 3).build().         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index").settings(settings), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     GetSettingsRequest request = new GetSettingsRequest().indices("index").     request.indicesOptions(IndicesOptions.lenientExpandOpen()).     // tag::get-settings-request-include-defaults     // <1>     request.includeDefaults(true).     // end::get-settings-request-include-defaults     GetSettingsResponse getSettingsResponse = client.indices().getSettings(request, RequestOptions.DEFAULT).     String numberOfShardsString = getSettingsResponse.getSetting("index", "index.number_of_shards").     Settings indexSettings = getSettingsResponse.getIndexToSettings().get("index").     Integer numberOfShards = indexSettings.getAsInt("index.number_of_shards", null).     // tag::get-settings-defaults-response     // <1>     String refreshInterval = getSettingsResponse.getSetting("index", "index.refresh_interval").     // <2>     Settings indexDefaultSettings = getSettingsResponse.getIndexToDefaultSettings().get("index").     // end::get-settings-defaults-response     assertEquals("3", numberOfShardsString).     assertEquals(Integer.valueOf(3), numberOfShards).     assertNotNull("with defaults enabled we should get a value for refresh_interval!", refreshInterval).     assertEquals(refreshInterval, indexDefaultSettings.get("index.refresh_interval")).     ActionListener<GetSettingsResponse> listener = new ActionListener<GetSettingsResponse>() {          @Override         public void onResponse(GetSettingsResponse GetSettingsResponse) {         }          @Override         public void onFailure(Exception e) {         }     }.     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     client.indices().getSettingsAsync(request, RequestOptions.DEFAULT, listener).     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(GetIndexResponse getIndexResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;76;;public void testGetIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         Settings settings = Settings.builder().put("number_of_shards", 3).build().         String mappings = "{\"properties\":{\"field-1\":{\"type\":\"integer\"}}}".         CreateIndexRequest createIndexRequest = new CreateIndexRequest("index").settings(settings).mapping(mappings, XContentType.JSON).         CreateIndexResponse createIndexResponse = client.indices().create(createIndexRequest, RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     // tag::get-index-request     // <1>     GetIndexRequest request = new GetIndexRequest("index").     // end::get-index-request     // tag::get-index-request-indicesOptions     // <1>     request.indicesOptions(IndicesOptions.lenientExpandOpen()).     // end::get-index-request-indicesOptions     // tag::get-index-request-includeDefaults     // <1>     request.includeDefaults(true).     // end::get-index-request-includeDefaults     // tag::get-index-execute     GetIndexResponse getIndexResponse = client.indices().get(request, RequestOptions.DEFAULT).     // end::get-index-execute     // tag::get-index-response     // <1>     MappingMetaData indexMappings = getIndexResponse.getMappings().get("index").     // <2>     Map<String, Object> indexTypeMappings = indexMappings.getSourceAsMap().     // <3>     List<AliasMetaData> indexAliases = getIndexResponse.getAliases().get("index").     // <4>     String numberOfShardsString = getIndexResponse.getSetting("index", "index.number_of_shards").     // <5>     Settings indexSettings = getIndexResponse.getSettings().get("index").     // <6>     Integer numberOfShards = indexSettings.getAsInt("index.number_of_shards", null).     TimeValue time = getIndexResponse.getDefaultSettings().get("index").getAsTime("index.refresh_interval", // <7>     null).     // end::get-index-response     assertEquals(Collections.singletonMap("properties", Collections.singletonMap("field-1", Collections.singletonMap("type", "integer"))), indexTypeMappings).     assertTrue(indexAliases.isEmpty()).     assertEquals(IndexSettings.DEFAULT_REFRESH_INTERVAL, time).     assertEquals("3", numberOfShardsString).     assertEquals(Integer.valueOf(3), numberOfShards).     // tag::get-index-execute-listener     ActionListener<GetIndexResponse> listener = new ActionListener<GetIndexResponse>() {          @Override         public void onResponse(GetIndexResponse getIndexResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::get-index-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::get-index-execute-async     // <1>     client.indices().getAsync(request, RequestOptions.DEFAULT, listener).     // end::get-index-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(ForceMergeResponse forceMergeResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;73;;@SuppressWarnings("unused") public void testForceMergeIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         createIndex("index", Settings.EMPTY).     }     {         // tag::force-merge-request         // <1>         ForceMergeRequest request = new ForceMergeRequest("index1").         // <2>         ForceMergeRequest requestMultiple = new ForceMergeRequest("index1", "index2").         // <3>         ForceMergeRequest requestAll = new ForceMergeRequest().         // end::force-merge-request         // tag::force-merge-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::force-merge-request-indicesOptions         // tag::force-merge-request-segments-num         // <1>         request.maxNumSegments(1).         // end::force-merge-request-segments-num         // tag::force-merge-request-only-expunge-deletes         // <1>         request.onlyExpungeDeletes(true).         // end::force-merge-request-only-expunge-deletes         // tag::force-merge-request-flush         // <1>         request.flush(true).         // end::force-merge-request-flush         // tag::force-merge-execute         ForceMergeResponse forceMergeResponse = client.indices().forcemerge(request, RequestOptions.DEFAULT).         // end::force-merge-execute         // tag::force-merge-response         // <1>         int totalShards = forceMergeResponse.getTotalShards().         // <2>         int successfulShards = forceMergeResponse.getSuccessfulShards().         // <3>         int failedShards = forceMergeResponse.getFailedShards().         // <4>         DefaultShardOperationFailedException[] failures = forceMergeResponse.getShardFailures().         // end::force-merge-response         // tag::force-merge-execute-listener         ActionListener<ForceMergeResponse> listener = new ActionListener<ForceMergeResponse>() {              @Override             public void onResponse(ForceMergeResponse forceMergeResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::force-merge-execute-listener         // tag::force-merge-execute-async         // <1>         client.indices().forcemergeAsync(request, RequestOptions.DEFAULT, listener).     // end::force-merge-execute-async     }     {         // tag::force-merge-notfound         try {             ForceMergeRequest request = new ForceMergeRequest("does_not_exist").             client.indices().forcemerge(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.NOT_FOUND) {             // <1>             }         }     // end::force-merge-notfound     } }
false;public;1;4;;@Override public void onResponse(ClearIndicesCacheResponse clearCacheResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;84;;@SuppressWarnings("unused") public void testClearCache() throws Exception {     RestHighLevelClient client = highLevelClient().     {         createIndex("index1", Settings.EMPTY).     }     {         // tag::clear-cache-request         // <1>         ClearIndicesCacheRequest request = new ClearIndicesCacheRequest("index1").         // <2>         ClearIndicesCacheRequest requestMultiple = new ClearIndicesCacheRequest("index1", "index2").         // <3>         ClearIndicesCacheRequest requestAll = new ClearIndicesCacheRequest().         // end::clear-cache-request         // tag::clear-cache-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::clear-cache-request-indicesOptions         // tag::clear-cache-request-query         // <1>         request.queryCache(true).         // end::clear-cache-request-query         // tag::clear-cache-request-request         // <1>         request.requestCache(true).         // end::clear-cache-request-request         // tag::clear-cache-request-fielddata         // <1>         request.fieldDataCache(true).         // end::clear-cache-request-fielddata         // tag::clear-cache-request-fields         // <1>         request.fields("field1", "field2", "field3").         // end::clear-cache-request-fields         // tag::clear-cache-execute         ClearIndicesCacheResponse clearCacheResponse = client.indices().clearCache(request, RequestOptions.DEFAULT).         // end::clear-cache-execute         // tag::clear-cache-response         // <1>         int totalShards = clearCacheResponse.getTotalShards().         // <2>         int successfulShards = clearCacheResponse.getSuccessfulShards().         // <3>         int failedShards = clearCacheResponse.getFailedShards().         // <4>         DefaultShardOperationFailedException[] failures = clearCacheResponse.getShardFailures().         // end::clear-cache-response         // tag::clear-cache-execute-listener         ActionListener<ClearIndicesCacheResponse> listener = new ActionListener<ClearIndicesCacheResponse>() {              @Override             public void onResponse(ClearIndicesCacheResponse clearCacheResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::clear-cache-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::clear-cache-execute-async         // <1>         client.indices().clearCacheAsync(request, RequestOptions.DEFAULT, listener).         // end::clear-cache-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::clear-cache-notfound         try {             ClearIndicesCacheRequest request = new ClearIndicesCacheRequest("does_not_exist").             client.indices().clearCache(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.NOT_FOUND) {             // <1>             }         }     // end::clear-cache-notfound     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse closeIndexResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;61;;public void testCloseIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::close-index-request         // <1>         CloseIndexRequest request = new CloseIndexRequest("index").         // end::close-index-request         // tag::close-index-request-timeout         // <1>         request.timeout(TimeValue.timeValueMinutes(2)).         // <2>         request.timeout("2m").         // end::close-index-request-timeout         // tag::close-index-request-masterTimeout         // <1>         request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).         // <2>         request.masterNodeTimeout("1m").         // end::close-index-request-masterTimeout         // tag::close-index-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::close-index-request-indicesOptions         // tag::close-index-execute         AcknowledgedResponse closeIndexResponse = client.indices().close(request, RequestOptions.DEFAULT).         // end::close-index-execute         // tag::close-index-response         // <1>         boolean acknowledged = closeIndexResponse.isAcknowledged().         // end::close-index-response         assertTrue(acknowledged).         // tag::close-index-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse closeIndexResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::close-index-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::close-index-execute-async         // <1>         client.indices().closeAsync(request, RequestOptions.DEFAULT, listener).         // end::close-index-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(Boolean exists) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;63;;@SuppressWarnings("unused") public void testExistsAlias() throws Exception {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index").alias(new Alias("alias")), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::exists-alias-request         GetAliasesRequest request = new GetAliasesRequest().         GetAliasesRequest requestWithAlias = new GetAliasesRequest("alias1").         GetAliasesRequest requestWithAliases = new GetAliasesRequest(new String[] { "alias1", "alias2" }).         // end::exists-alias-request         // tag::exists-alias-request-alias         // <1>         request.aliases("alias").         // end::exists-alias-request-alias         // tag::exists-alias-request-indices         // <1>         request.indices("index").         // end::exists-alias-request-indices         // tag::exists-alias-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::exists-alias-request-indicesOptions         // tag::exists-alias-request-local         // <1>         request.local(true).         // end::exists-alias-request-local         // tag::exists-alias-execute         boolean exists = client.indices().existsAlias(request, RequestOptions.DEFAULT).         // end::exists-alias-execute         assertTrue(exists).         // tag::exists-alias-execute-listener         ActionListener<Boolean> listener = new ActionListener<Boolean>() {              @Override             public void onResponse(Boolean exists) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::exists-alias-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::exists-alias-execute-async         // <1>         client.indices().existsAliasAsync(request, RequestOptions.DEFAULT, listener).         // end::exists-alias-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse indicesAliasesResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;96;;@SuppressWarnings("unused") public void testUpdateAliases() throws Exception {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index1"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).         createIndexResponse = client.indices().create(new CreateIndexRequest("index2"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).         createIndexResponse = client.indices().create(new CreateIndexRequest("index3"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).         createIndexResponse = client.indices().create(new CreateIndexRequest("index4"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::update-aliases-request         // <1>         IndicesAliasesRequest request = new IndicesAliasesRequest().         AliasActions aliasAction = new AliasActions(AliasActions.Type.ADD).index("index1").alias(// <2>         "alias1").         // <3>         request.addAliasAction(aliasAction).         // end::update-aliases-request         // tag::update-aliases-request2         AliasActions addIndexAction = new AliasActions(AliasActions.Type.ADD).index("index1").alias("alias1").filter(// <1>         "{\"term\":{\"year\":2016}}").         AliasActions addIndicesAction = new AliasActions(AliasActions.Type.ADD).indices("index1", "index2").alias("alias2").routing(// <2>         "1").         AliasActions removeAction = new AliasActions(AliasActions.Type.REMOVE).index("index3").alias(// <3>         "alias3").         AliasActions removeIndexAction = new AliasActions(AliasActions.Type.REMOVE_INDEX).index(// <4>         "index4").         // end::update-aliases-request2         // tag::update-aliases-request-timeout         // <1>         request.timeout(TimeValue.timeValueMinutes(2)).         // <2>         request.timeout("2m").         // end::update-aliases-request-timeout         // tag::update-aliases-request-masterTimeout         // <1>         request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).         // <2>         request.masterNodeTimeout("1m").         // end::update-aliases-request-masterTimeout         // tag::update-aliases-execute         AcknowledgedResponse indicesAliasesResponse = client.indices().updateAliases(request, RequestOptions.DEFAULT).         // end::update-aliases-execute         // tag::update-aliases-response         // <1>         boolean acknowledged = indicesAliasesResponse.isAcknowledged().         // end::update-aliases-response         assertTrue(acknowledged).     }     {         IndicesAliasesRequest request = new IndicesAliasesRequest().         AliasActions aliasAction = new AliasActions(AliasActions.Type.ADD).index("index1").alias("async").         request.addAliasAction(aliasAction).         // tag::update-aliases-execute-listener         ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse indicesAliasesResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::update-aliases-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::update-aliases-execute-async         // <1>         client.indices().updateAliasesAsync(request, RequestOptions.DEFAULT, listener).         // end::update-aliases-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(ResizeResponse resizeResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;72;;public void testShrinkIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         Map<String, Object> nodes = getAsMap("_nodes").         @SuppressWarnings("unchecked")         String firstNode = ((Map<String, Object>) nodes.get("nodes")).keySet().iterator().next().         createIndex("source_index", Settings.builder().put("index.number_of_shards", 4).put("index.number_of_replicas", 0).build()).         updateIndexSettings("source_index", Settings.builder().put("index.routing.allocation.require._name", firstNode).put("index.blocks.write", true)).     }     // tag::shrink-index-request     // <1>     ResizeRequest request = new ResizeRequest("target_index", "source_index").     // end::shrink-index-request     // tag::shrink-index-request-timeout     // <1>     request.timeout(TimeValue.timeValueMinutes(2)).     // <2>     request.timeout("2m").     // end::shrink-index-request-timeout     // tag::shrink-index-request-masterTimeout     // <1>     request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).     // <2>     request.masterNodeTimeout("1m").     // end::shrink-index-request-masterTimeout     // tag::shrink-index-request-waitForActiveShards     // <1>     request.setWaitForActiveShards(2).     // <2>     request.setWaitForActiveShards(ActiveShardCount.DEFAULT).     // end::shrink-index-request-waitForActiveShards     // tag::shrink-index-request-settings     request.getTargetIndexRequest().settings(Settings.builder().put("index.number_of_shards", // <1>     2).putNull(// <2>     "index.routing.allocation.require._name")).     // end::shrink-index-request-settings     // tag::shrink-index-request-aliases     // <1>     request.getTargetIndexRequest().alias(new Alias("target_alias")).     // end::shrink-index-request-aliases     // tag::shrink-index-execute     ResizeResponse resizeResponse = client.indices().shrink(request, RequestOptions.DEFAULT).     // end::shrink-index-execute     // tag::shrink-index-response     // <1>     boolean acknowledged = resizeResponse.isAcknowledged().     // <2>     boolean shardsAcked = resizeResponse.isShardsAcknowledged().     // end::shrink-index-response     assertTrue(acknowledged).     assertTrue(shardsAcked).     // tag::shrink-index-execute-listener     ActionListener<ResizeResponse> listener = new ActionListener<ResizeResponse>() {          @Override         public void onResponse(ResizeResponse resizeResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::shrink-index-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::shrink-index-execute-async     // <1>     client.indices().shrinkAsync(request, RequestOptions.DEFAULT, listener).     // end::shrink-index-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(ResizeResponse resizeResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;69;;public void testSplitIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         createIndex("source_index", Settings.builder().put("index.number_of_shards", 2).put("index.number_of_replicas", 0).put("index.number_of_routing_shards", 4).build()).         updateIndexSettings("source_index", Settings.builder().put("index.blocks.write", true)).     }     // tag::split-index-request     // <1>     ResizeRequest request = new ResizeRequest("target_index", "source_index").     // <2>     request.setResizeType(ResizeType.SPLIT).     // end::split-index-request     // tag::split-index-request-timeout     // <1>     request.timeout(TimeValue.timeValueMinutes(2)).     // <2>     request.timeout("2m").     // end::split-index-request-timeout     // tag::split-index-request-masterTimeout     // <1>     request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).     // <2>     request.masterNodeTimeout("1m").     // end::split-index-request-masterTimeout     // tag::split-index-request-waitForActiveShards     // <1>     request.setWaitForActiveShards(2).     // <2>     request.setWaitForActiveShards(ActiveShardCount.DEFAULT).     // end::split-index-request-waitForActiveShards     // tag::split-index-request-settings     request.getTargetIndexRequest().settings(Settings.builder().put("index.number_of_shards", // <1>     4)).     // end::split-index-request-settings     // tag::split-index-request-aliases     // <1>     request.getTargetIndexRequest().alias(new Alias("target_alias")).     // end::split-index-request-aliases     // tag::split-index-execute     ResizeResponse resizeResponse = client.indices().split(request, RequestOptions.DEFAULT).     // end::split-index-execute     // tag::split-index-response     // <1>     boolean acknowledged = resizeResponse.isAcknowledged().     // <2>     boolean shardsAcked = resizeResponse.isShardsAcknowledged().     // end::split-index-response     assertTrue(acknowledged).     assertTrue(shardsAcked).     // tag::split-index-execute-listener     ActionListener<ResizeResponse> listener = new ActionListener<ResizeResponse>() {          @Override         public void onResponse(ResizeResponse resizeResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::split-index-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::split-index-execute-async     // <1>     client.indices().splitAsync(request, RequestOptions.DEFAULT, listener).     // end::split-index-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(RolloverResponse rolloverResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;84;;public void testRolloverIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         client.indices().create(new CreateIndexRequest("index-1").alias(new Alias("alias")), RequestOptions.DEFAULT).     }     // tag::rollover-index-request     // <1>     RolloverRequest request = new RolloverRequest("alias", "index-2").     // <2>     request.addMaxIndexAgeCondition(new TimeValue(7, TimeUnit.DAYS)).     // <3>     request.addMaxIndexDocsCondition(1000).     // <4>     request.addMaxIndexSizeCondition(new ByteSizeValue(5, ByteSizeUnit.GB)).     // end::rollover-index-request     // tag::rollover-index-request-timeout     // <1>     request.setTimeout(TimeValue.timeValueMinutes(2)).     // end::rollover-index-request-timeout     // tag::rollover-index-request-masterTimeout     // <1>     request.setMasterTimeout(TimeValue.timeValueMinutes(1)).     // end::rollover-index-request-masterTimeout     // tag::rollover-index-request-dryRun     // <1>     request.dryRun(true).     // end::rollover-index-request-dryRun     // tag::rollover-index-request-waitForActiveShards     // <1>     request.getCreateIndexRequest().waitForActiveShards(ActiveShardCount.from(2)).     // <2>     request.getCreateIndexRequest().waitForActiveShards(ActiveShardCount.DEFAULT).     // end::rollover-index-request-waitForActiveShards     // tag::rollover-index-request-settings     request.getCreateIndexRequest().settings(Settings.builder().put("index.number_of_shards", // <1>     4)).     // end::rollover-index-request-settings     // tag::rollover-index-request-mapping     String mappings = "{\"properties\":{\"field-1\":{\"type\":\"keyword\"}}}".     // <1>     request.getCreateIndexRequest().mapping(mappings, XContentType.JSON).     // end::rollover-index-request-mapping     // tag::rollover-index-request-alias     // <1>     request.getCreateIndexRequest().alias(new Alias("another_alias")).     // end::rollover-index-request-alias     // tag::rollover-index-execute     RolloverResponse rolloverResponse = client.indices().rollover(request, RequestOptions.DEFAULT).     // end::rollover-index-execute     // tag::rollover-index-response     // <1>     boolean acknowledged = rolloverResponse.isAcknowledged().     // <2>     boolean shardsAcked = rolloverResponse.isShardsAcknowledged().     // <3>     String oldIndex = rolloverResponse.getOldIndex().     // <4>     String newIndex = rolloverResponse.getNewIndex().     // <5>     boolean isRolledOver = rolloverResponse.isRolledOver().     // <6>     boolean isDryRun = rolloverResponse.isDryRun().     // <7>     Map<String, Boolean> conditionStatus = rolloverResponse.getConditionStatus().     // end::rollover-index-response     assertFalse(acknowledged).     assertFalse(shardsAcked).     assertEquals("index-1", oldIndex).     assertEquals("index-2", newIndex).     assertFalse(isRolledOver).     assertTrue(isDryRun).     assertEquals(3, conditionStatus.size()).     // tag::rollover-index-execute-listener     ActionListener<RolloverResponse> listener = new ActionListener<RolloverResponse>() {          @Override         public void onResponse(RolloverResponse rolloverResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::rollover-index-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::rollover-index-execute-async     // <1>     client.indices().rolloverAsync(request, RequestOptions.DEFAULT, listener).     // end::rollover-index-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(GetAliasesResponse getAliasesResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;70;;@SuppressWarnings("unused") public void testGetAlias() throws Exception {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index").alias(new Alias("alias")), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::get-alias-request         GetAliasesRequest request = new GetAliasesRequest().         GetAliasesRequest requestWithAlias = new GetAliasesRequest("alias1").         GetAliasesRequest requestWithAliases = new GetAliasesRequest(new String[] { "alias1", "alias2" }).         // end::get-alias-request         // tag::get-alias-request-alias         // <1>         request.aliases("alias").         // end::get-alias-request-alias         // tag::get-alias-request-indices         // <1>         request.indices("index").         // end::get-alias-request-indices         // tag::get-alias-request-indicesOptions         // <1>         request.indicesOptions(IndicesOptions.lenientExpandOpen()).         // end::get-alias-request-indicesOptions         // tag::get-alias-request-local         // <1>         request.local(true).         // end::get-alias-request-local         // tag::get-alias-execute         GetAliasesResponse response = client.indices().getAlias(request, RequestOptions.DEFAULT).         // end::get-alias-execute         // tag::get-alias-response         // <1>         Map<String, Set<AliasMetaData>> aliases = response.getAliases().         // end::get-alias-response         assertThat(response.getAliases().get("index").size(), equalTo(1)).         assertThat(response.getAliases().get("index").iterator().next().alias(), equalTo("alias")).         // tag::get-alias-execute-listener         ActionListener<GetAliasesResponse> listener = new ActionListener<GetAliasesResponse>() {              @Override             public void onResponse(GetAliasesResponse getAliasesResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::get-alias-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::get-alias-execute-async         // <1>         client.indices().getAliasAsync(request, RequestOptions.DEFAULT, listener).         // end::get-alias-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse updateSettingsResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;102;;@SuppressWarnings("unused") public void testIndexPutSettings() throws Exception {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     // tag::indices-put-settings-request     // <1>     UpdateSettingsRequest request = new UpdateSettingsRequest("index1").     UpdateSettingsRequest requestMultiple = // <2>     new UpdateSettingsRequest("index1", "index2").     // <3>     UpdateSettingsRequest requestAll = new UpdateSettingsRequest().     // end::indices-put-settings-request     // tag::indices-put-settings-create-settings     String settingKey = "index.number_of_replicas".     int settingValue = 0.     Settings settings = Settings.builder().put(settingKey, settingValue).build().     // end::indices-put-settings-create-settings     // tag::indices-put-settings-request-index-settings     request.settings(settings).     // end::indices-put-settings-request-index-settings     {         // tag::indices-put-settings-settings-builder         Settings.Builder settingsBuilder = Settings.builder().put(settingKey, settingValue).         // <1>         request.settings(settingsBuilder).     // end::indices-put-settings-settings-builder     }     {         // tag::indices-put-settings-settings-map         Map<String, Object> map = new HashMap<>().         map.put(settingKey, settingValue).         // <1>         request.settings(map).     // end::indices-put-settings-settings-map     }     {         // tag::indices-put-settings-settings-source         request.settings("{\"index.number_of_replicas\": \"2\"}", // <1>         XContentType.JSON).     // end::indices-put-settings-settings-source     }     // tag::indices-put-settings-request-preserveExisting     // <1>     request.setPreserveExisting(false).     // end::indices-put-settings-request-preserveExisting     // tag::indices-put-settings-request-timeout     // <1>     request.timeout(TimeValue.timeValueMinutes(2)).     // <2>     request.timeout("2m").     // end::indices-put-settings-request-timeout     // tag::indices-put-settings-request-masterTimeout     // <1>     request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).     // <2>     request.masterNodeTimeout("1m").     // end::indices-put-settings-request-masterTimeout     // tag::indices-put-settings-request-indicesOptions     // <1>     request.indicesOptions(IndicesOptions.lenientExpandOpen()).     // end::indices-put-settings-request-indicesOptions     // tag::indices-put-settings-execute     AcknowledgedResponse updateSettingsResponse = client.indices().putSettings(request, RequestOptions.DEFAULT).     // end::indices-put-settings-execute     // tag::indices-put-settings-response     // <1>     boolean acknowledged = updateSettingsResponse.isAcknowledged().     // end::indices-put-settings-response     assertTrue(acknowledged).     // tag::indices-put-settings-execute-listener     ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {          @Override         public void onResponse(AcknowledgedResponse updateSettingsResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::indices-put-settings-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::indices-put-settings-execute-async     // <1>     client.indices().putSettingsAsync(request, RequestOptions.DEFAULT, listener).     // end::indices-put-settings-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse putTemplateResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;148;;public void testPutTemplate() throws Exception {     RestHighLevelClient client = highLevelClient().     // tag::put-template-request     // <1>     PutIndexTemplateRequest request = new PutIndexTemplateRequest("my-template").     // <2>     request.patterns(Arrays.asList("pattern-1", "log-*")).     // end::put-template-request     // tag::put-template-request-settings     request.settings(// <1>     Settings.builder().put("index.number_of_shards", 3).put("index.number_of_replicas", 1)).     // end::put-template-request-settings     {         // tag::put-template-request-mappings-json         // <1>         request.mapping("{\n" + "  \"properties\": {\n" + "    \"message\": {\n" + "      \"type\": \"text\"\n" + "    }\n" + "  }\n" + "}", XContentType.JSON).         // end::put-template-request-mappings-json         assertTrue(client.indices().putTemplate(request, RequestOptions.DEFAULT).isAcknowledged()).     }     {         // tag::put-template-request-mappings-map         Map<String, Object> jsonMap = new HashMap<>().         {             Map<String, Object> properties = new HashMap<>().             {                 Map<String, Object> message = new HashMap<>().                 message.put("type", "text").                 properties.put("message", message).             }             jsonMap.put("properties", properties).         }         // <1>         request.mapping(jsonMap).         // end::put-template-request-mappings-map         assertTrue(client.indices().putTemplate(request, RequestOptions.DEFAULT).isAcknowledged()).     }     {         // tag::put-template-request-mappings-xcontent         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.startObject().         {             builder.startObject("properties").             {                 builder.startObject("message").                 {                     builder.field("type", "text").                 }                 builder.endObject().             }             builder.endObject().         }         builder.endObject().         // <1>         request.mapping(builder).         // end::put-template-request-mappings-xcontent         assertTrue(client.indices().putTemplate(request, RequestOptions.DEFAULT).isAcknowledged()).     }     // tag::put-template-request-aliases     // <1>     request.alias(new Alias("twitter_alias").filter(QueryBuilders.termQuery("user", "kimchy"))).     // <2>     request.alias(new Alias("{index}_alias").searchRouting("xyz")).     // end::put-template-request-aliases     // tag::put-template-request-order     // <1>     request.order(20).     // end::put-template-request-order     // tag::put-template-request-version     // <1>     request.version(4).     // end::put-template-request-version     // tag::put-template-whole-source     request.source("{\n" + "  \"index_patterns\": [\n" + "    \"log-*\",\n" + "    \"pattern-1\"\n" + "  ],\n" + "  \"order\": 1,\n" + "  \"settings\": {\n" + "    \"number_of_shards\": 1\n" + "  },\n" + "  \"mappings\": {\n" + "    \"properties\": {\n" + "      \"message\": {\n" + "        \"type\": \"text\"\n" + "      }\n" + "    }\n" + "  },\n" + "  \"aliases\": {\n" + "    \"alias-1\": {},\n" + "    \"{index}-alias\": {}\n" + "  }\n" + "}", // <1>     XContentType.JSON).     // end::put-template-whole-source     // tag::put-template-request-create     // <1>     request.create(true).     // end::put-template-request-create     // tag::put-template-request-masterTimeout     // <1>     request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).     // <2>     request.masterNodeTimeout("1m").     // end::put-template-request-masterTimeout     // make test happy     request.create(false).     // tag::put-template-execute     AcknowledgedResponse putTemplateResponse = client.indices().putTemplate(request, RequestOptions.DEFAULT).     // end::put-template-execute     // tag::put-template-response     // <1>     boolean acknowledged = putTemplateResponse.isAcknowledged().     // end::put-template-response     assertTrue(acknowledged).     // tag::put-template-execute-listener     ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {          @Override         public void onResponse(AcknowledgedResponse putTemplateResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::put-template-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::put-template-execute-async     // <1>     client.indices().putTemplateAsync(request, RequestOptions.DEFAULT, listener).     // end::put-template-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(GetIndexTemplatesResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;64;;public void testGetTemplates() throws Exception {     RestHighLevelClient client = highLevelClient().     {         PutIndexTemplateRequest putRequest = new PutIndexTemplateRequest("my-template").         putRequest.patterns(Arrays.asList("pattern-1", "log-*")).         putRequest.settings(Settings.builder().put("index.number_of_shards", 3).put("index.number_of_replicas", 1)).         putRequest.mapping("{\n" + "  \"properties\": {\n" + "    \"message\": {\n" + "      \"type\": \"text\"\n" + "    }\n" + "  }\n" + "}", XContentType.JSON).         assertTrue(client.indices().putTemplate(putRequest, RequestOptions.DEFAULT).isAcknowledged()).     }     // tag::get-templates-request     // <1>     GetIndexTemplatesRequest request = new GetIndexTemplatesRequest("my-template").     // <2>     request = new GetIndexTemplatesRequest("template-1", "template-2").     // <3>     request = new GetIndexTemplatesRequest("my-*").     // end::get-templates-request     // tag::get-templates-request-masterTimeout     // <1>     request.setMasterNodeTimeout(TimeValue.timeValueMinutes(1)).     // <2>     request.setMasterNodeTimeout("1m").     // end::get-templates-request-masterTimeout     // tag::get-templates-execute     GetIndexTemplatesResponse getTemplatesResponse = client.indices().getIndexTemplate(request, RequestOptions.DEFAULT).     // end::get-templates-execute     // tag::get-templates-response     // <1>     List<IndexTemplateMetaData> templates = getTemplatesResponse.getIndexTemplates().     // end::get-templates-response     assertThat(templates, hasSize(1)).     assertThat(templates.get(0).name(), equalTo("my-template")).     // tag::get-templates-execute-listener     ActionListener<GetIndexTemplatesResponse> listener = new ActionListener<GetIndexTemplatesResponse>() {          @Override         public void onResponse(GetIndexTemplatesResponse response) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::get-templates-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::get-templates-execute-async     // <1>     client.indices().getIndexTemplateAsync(request, RequestOptions.DEFAULT, listener).     // end::get-templates-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(Boolean aBoolean) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;52;;public void testTemplatesExist() throws Exception {     final RestHighLevelClient client = highLevelClient().     {         final PutIndexTemplateRequest putRequest = new PutIndexTemplateRequest("my-template").         putRequest.patterns(Collections.singletonList("foo")).         assertTrue(client.indices().putTemplate(putRequest, RequestOptions.DEFAULT).isAcknowledged()).     }     {         // tag::templates-exist-request         IndexTemplatesExistRequest request.         // <1>         request = new IndexTemplatesExistRequest("my-template").         // <2>         request = new IndexTemplatesExistRequest("template-1", "template-2").         // <3>         request = new IndexTemplatesExistRequest("my-*").         // end::templates-exist-request         // tag::templates-exist-request-optionals         // <1>         request.setLocal(true).         // <2>         request.setMasterNodeTimeout(TimeValue.timeValueMinutes(1)).         // <3>         request.setMasterNodeTimeout("1m").         // end::templates-exist-request-optionals         // tag::templates-exist-execute         boolean exists = client.indices().existsTemplate(request, RequestOptions.DEFAULT).         // end::templates-exist-execute         assertTrue(exists).         // tag::templates-exist-execute-listener         ActionListener<Boolean> listener = new ActionListener<Boolean>() {              @Override             public void onResponse(Boolean aBoolean) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::templates-exist-execute-listener         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::templates-exist-execute-async         // <1>         client.indices().existsTemplateAsync(request, RequestOptions.DEFAULT, listener).         // end::templates-exist-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     } }
false;public;1;4;;@Override public void onResponse(ValidateQueryResponse validateQueryResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;79;;@SuppressWarnings("unused") public void testValidateQuery() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     String index = "some_index".     createIndex(index, Settings.EMPTY).     // tag::indices-validate-query-request     // <1>     ValidateQueryRequest request = new ValidateQueryRequest(index).     // end::indices-validate-query-request     // tag::indices-validate-query-request-query     QueryBuilder builder = QueryBuilders.boolQuery().must(QueryBuilders.queryStringQuery("*:*")).filter(QueryBuilders.termQuery("user", "kimchy")).     // <2>     request.query(builder).     // end::indices-validate-query-request-query     // tag::indices-validate-query-request-explain     // <1>     request.explain(true).     // end::indices-validate-query-request-explain     // tag::indices-validate-query-request-allShards     // <1>     request.allShards(true).     // end::indices-validate-query-request-allShards     // tag::indices-validate-query-request-rewrite     // <1>     request.rewrite(true).     // end::indices-validate-query-request-rewrite     // tag::indices-validate-query-execute     // <1>     ValidateQueryResponse response = client.indices().validateQuery(request, RequestOptions.DEFAULT).     // end::indices-validate-query-execute     // tag::indices-validate-query-response     // <1>     boolean isValid = response.isValid().     // <2>     int totalShards = response.getTotalShards().     // <3>     int successfulShards = response.getSuccessfulShards().     // <4>     int failedShards = response.getFailedShards().     if (failedShards > 0) {         for (DefaultShardOperationFailedException failure : response.getShardFailures()) {             // <5>             // <6>             String failedIndex = failure.index().             // <7>             int shardId = failure.shardId().             // <8>             String reason = failure.reason().         }     }     for (QueryExplanation explanation : response.getQueryExplanation()) {         // <9>         // <10>         String explanationIndex = explanation.getIndex().         // <11>         int shardId = explanation.getShard().         // <12>         String explanationString = explanation.getExplanation().     }     // end::indices-validate-query-response     // tag::indices-validate-query-execute-listener     ActionListener<ValidateQueryResponse> listener = new ActionListener<ValidateQueryResponse>() {          @Override         public void onResponse(ValidateQueryResponse validateQueryResponse) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::indices-validate-query-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::indices-validate-query-execute-async     // <1>     client.indices().validateQueryAsync(request, RequestOptions.DEFAULT, listener).     // end::indices-validate-query-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
false;public;1;4;;@Override public void onResponse(AnalyzeResponse analyzeTokens) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;127;;public void testAnalyze() throws IOException, InterruptedException {     RestHighLevelClient client = highLevelClient().     {         // tag::analyze-builtin-request         AnalyzeRequest request = new AnalyzeRequest().         // <1>         request.text("Some text to analyze", "Some more text to analyze").         // <2>         request.analyzer("english").     // end::analyze-builtin-request     }     {         // tag::analyze-custom-request         AnalyzeRequest request = new AnalyzeRequest().         request.text("<b>Some text to analyze</b>").         // <1>         request.addCharFilter("html_strip").         // <2>         request.tokenizer("standard").         // <3>         request.addTokenFilter("lowercase").         Map<String, Object> stopFilter = new HashMap<>().         stopFilter.put("type", "stop").         // <4>         stopFilter.put("stopwords", new String[] { "to" }).         // <5>         request.addTokenFilter(stopFilter).     // end::analyze-custom-request     }     {         // tag::analyze-custom-normalizer-request         AnalyzeRequest request = new AnalyzeRequest().         request.text("<b>BaR</b>").         request.addTokenFilter("lowercase").         // end::analyze-custom-normalizer-request         // tag::analyze-request-explain         // <1>         request.explain(true).         // <2>         request.attributes("keyword", "type").         // end::analyze-request-explain         // tag::analyze-execute         AnalyzeResponse response = client.indices().analyze(request, RequestOptions.DEFAULT).         // end::analyze-execute         // tag::analyze-response-tokens         // <1>         List<AnalyzeResponse.AnalyzeToken> tokens = response.getTokens().         // end::analyze-response-tokens         // tag::analyze-response-detail         // <1>         DetailAnalyzeResponse detail = response.detail().         // end::analyze-response-detail         assertNull(tokens).         assertNotNull(detail.tokenizer()).     }     CreateIndexRequest req = new CreateIndexRequest("my_index").     CreateIndexResponse resp = client.indices().create(req, RequestOptions.DEFAULT).     assertTrue(resp.isAcknowledged()).     PutMappingRequest pmReq = new PutMappingRequest("my_index").source(XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("my_field").field("type", "text").field("analyzer", "english").endObject().endObject().endObject()).     AcknowledgedResponse pmResp = client.indices().putMapping(pmReq, RequestOptions.DEFAULT).     assertTrue(pmResp.isAcknowledged()).     {         // tag::analyze-index-request         AnalyzeRequest request = new AnalyzeRequest().         // <1>         request.index("my_index").         // <2>         request.analyzer("my_analyzer").         request.text("some text to analyze").         // end::analyze-index-request         // tag::analyze-execute-listener         ActionListener<AnalyzeResponse> listener = new ActionListener<AnalyzeResponse>() {              @Override             public void onResponse(AnalyzeResponse analyzeTokens) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::analyze-execute-listener         // use a built-in analyzer in the test         request = new AnalyzeRequest().         request.index("my_index").         request.field("my_field").         request.text("some text to analyze").         // Use a blocking listener in the test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::analyze-execute-async         // <1>         client.indices().analyzeAsync(request, RequestOptions.DEFAULT, listener).         // end::analyze-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::analyze-index-normalizer-request         AnalyzeRequest request = new AnalyzeRequest().         // <1>         request.index("my_index").         // <2>         request.normalizer("my_normalizer").         request.text("some text to analyze").     // end::analyze-index-normalizer-request     }     {         // tag::analyze-field-request         AnalyzeRequest request = new AnalyzeRequest().         request.index("my_index").         request.field("my_field").         request.text("some text to analyze").     // end::analyze-field-request     } }
false;public;1;4;;@Override public void onResponse(ShardsAcknowledgedResponse freezeIndexResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;77;;public void testFreezeIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::freeze-index-request         // <1>         FreezeIndexRequest request = new FreezeIndexRequest("index").         // end::freeze-index-request         // tag::freeze-index-request-timeout         // <1>         request.setTimeout(TimeValue.timeValueMinutes(2)).         // end::freeze-index-request-timeout         // tag::freeze-index-request-masterTimeout         // <1>         request.setMasterTimeout(TimeValue.timeValueMinutes(1)).         // end::freeze-index-request-masterTimeout         // tag::freeze-index-request-waitForActiveShards         // <1>         request.setWaitForActiveShards(ActiveShardCount.DEFAULT).         // end::freeze-index-request-waitForActiveShards         // tag::freeze-index-request-indicesOptions         // <1>         request.setIndicesOptions(IndicesOptions.strictExpandOpen()).         // end::freeze-index-request-indicesOptions         // tag::freeze-index-execute         ShardsAcknowledgedResponse openIndexResponse = client.indices().freeze(request, RequestOptions.DEFAULT).         // end::freeze-index-execute         // tag::freeze-index-response         // <1>         boolean acknowledged = openIndexResponse.isAcknowledged().         // <2>         boolean shardsAcked = openIndexResponse.isShardsAcknowledged().         // end::freeze-index-response         assertTrue(acknowledged).         assertTrue(shardsAcked).         // tag::freeze-index-execute-listener         ActionListener<ShardsAcknowledgedResponse> listener = new ActionListener<ShardsAcknowledgedResponse>() {              @Override             public void onResponse(ShardsAcknowledgedResponse freezeIndexResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::freeze-index-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::freeze-index-execute-async         // <1>         client.indices().freezeAsync(request, RequestOptions.DEFAULT, listener).         // end::freeze-index-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::freeze-index-notfound         try {             FreezeIndexRequest request = new FreezeIndexRequest("does_not_exist").             client.indices().freeze(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.BAD_REQUEST) {             // <1>             }         }     // end::freeze-index-notfound     } }
false;public;1;4;;@Override public void onResponse(ShardsAcknowledgedResponse freezeIndexResponse) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;77;;public void testUnfreezeIndex() throws Exception {     RestHighLevelClient client = highLevelClient().     {         CreateIndexResponse createIndexResponse = client.indices().create(new CreateIndexRequest("index"), RequestOptions.DEFAULT).         assertTrue(createIndexResponse.isAcknowledged()).     }     {         // tag::unfreeze-index-request         // <1>         UnfreezeIndexRequest request = new UnfreezeIndexRequest("index").         // end::unfreeze-index-request         // tag::unfreeze-index-request-timeout         // <1>         request.setTimeout(TimeValue.timeValueMinutes(2)).         // end::unfreeze-index-request-timeout         // tag::unfreeze-index-request-masterTimeout         // <1>         request.setMasterTimeout(TimeValue.timeValueMinutes(1)).         // end::unfreeze-index-request-masterTimeout         // tag::unfreeze-index-request-waitForActiveShards         // <1>         request.setWaitForActiveShards(ActiveShardCount.DEFAULT).         // end::unfreeze-index-request-waitForActiveShards         // tag::unfreeze-index-request-indicesOptions         // <1>         request.setIndicesOptions(IndicesOptions.strictExpandOpen()).         // end::unfreeze-index-request-indicesOptions         // tag::unfreeze-index-execute         ShardsAcknowledgedResponse openIndexResponse = client.indices().unfreeze(request, RequestOptions.DEFAULT).         // end::unfreeze-index-execute         // tag::unfreeze-index-response         // <1>         boolean acknowledged = openIndexResponse.isAcknowledged().         // <2>         boolean shardsAcked = openIndexResponse.isShardsAcknowledged().         // end::unfreeze-index-response         assertTrue(acknowledged).         assertTrue(shardsAcked).         // tag::unfreeze-index-execute-listener         ActionListener<ShardsAcknowledgedResponse> listener = new ActionListener<ShardsAcknowledgedResponse>() {              @Override             public void onResponse(ShardsAcknowledgedResponse freezeIndexResponse) {             // <1>             }              @Override             public void onFailure(Exception e) {             // <2>             }         }.         // end::unfreeze-index-execute-listener         // Replace the empty listener by a blocking listener in test         final CountDownLatch latch = new CountDownLatch(1).         listener = new LatchedActionListener<>(listener, latch).         // tag::unfreeze-index-execute-async         // <1>         client.indices().unfreezeAsync(request, RequestOptions.DEFAULT, listener).         // end::unfreeze-index-execute-async         assertTrue(latch.await(30L, TimeUnit.SECONDS)).     }     {         // tag::unfreeze-index-notfound         try {             UnfreezeIndexRequest request = new UnfreezeIndexRequest("does_not_exist").             client.indices().unfreeze(request, RequestOptions.DEFAULT).         } catch (ElasticsearchException exception) {             if (exception.status() == RestStatus.BAD_REQUEST) {             // <1>             }         }     // end::unfreeze-index-notfound     } }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse response) { // <1> }
false;public;1;4;;@Override public void onFailure(Exception e) { // <2> }
false;public;0;59;;public void testDeleteTemplate() throws Exception {     RestHighLevelClient client = highLevelClient().     {         PutIndexTemplateRequest putRequest = new PutIndexTemplateRequest("my-template").         putRequest.patterns(Arrays.asList("pattern-1", "log-*")).         putRequest.settings(Settings.builder().put("index.number_of_shards", 3)).         assertTrue(client.indices().putTemplate(putRequest, RequestOptions.DEFAULT).isAcknowledged()).     }     // tag::delete-template-request     DeleteIndexTemplateRequest request = new DeleteIndexTemplateRequest().     // <1>     request.name("my-template").     // end::delete-template-request     // tag::delete-template-request-masterTimeout     // <1>     request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).     // <2>     request.masterNodeTimeout("1m").     // end::delete-template-request-masterTimeout     // tag::delete-template-execute     AcknowledgedResponse deleteTemplateAcknowledge = client.indices().deleteTemplate(request, RequestOptions.DEFAULT).     // end::delete-template-execute     // tag::delete-template-response     // <1>     boolean acknowledged = deleteTemplateAcknowledge.isAcknowledged().     // end::delete-template-response     assertThat(acknowledged, equalTo(true)).     {         PutIndexTemplateRequest putRequest = new PutIndexTemplateRequest("my-template").         putRequest.patterns(Arrays.asList("pattern-1", "log-*")).         putRequest.settings(Settings.builder().put("index.number_of_shards", 3)).         assertTrue(client.indices().putTemplate(putRequest, RequestOptions.DEFAULT).isAcknowledged()).     }     // tag::delete-template-execute-listener     ActionListener<AcknowledgedResponse> listener = new ActionListener<AcknowledgedResponse>() {          @Override         public void onResponse(AcknowledgedResponse response) {         // <1>         }          @Override         public void onFailure(Exception e) {         // <2>         }     }.     // end::delete-template-execute-listener     // Replace the empty listener by a blocking listener in test     final CountDownLatch latch = new CountDownLatch(1).     listener = new LatchedActionListener<>(listener, latch).     // tag::delete-template-execute-async     // <1>     client.indices().deleteTemplateAsync(request, RequestOptions.DEFAULT, listener).     // end::delete-template-execute-async     assertTrue(latch.await(30L, TimeUnit.SECONDS)). }
