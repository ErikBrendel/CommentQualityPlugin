commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;@Before public void initClients() throws IOException {     if (restHighLevelClient == null) {         final RestClient restClient = mock(RestClient.class).         restHighLevelClient = new CustomRestClient(restClient).         doAnswer(inv -> mockPerformRequest((Request) inv.getArguments()[0])).when(restClient).performRequest(any(Request.class)).         doAnswer(inv -> mockPerformRequestAsync(((Request) inv.getArguments()[0]), (ResponseListener) inv.getArguments()[1])).when(restClient).performRequestAsync(any(Request.class), any(ResponseListener.class)).     } }
false;public;0;10;;public void testCustomEndpoint() throws IOException {     final MainRequest request = new MainRequest().     String nodeName = randomAlphaOfLengthBetween(1, 10).     MainResponse response = restHighLevelClient.custom(request, optionsForNodeName(nodeName)).     assertEquals(nodeName, response.getNodeName()).     response = restHighLevelClient.customAndParse(request, optionsForNodeName(nodeName)).     assertEquals(nodeName, response.getNodeName()). }
false;public;0;12;;public void testCustomEndpointAsync() throws Exception {     final MainRequest request = new MainRequest().     String nodeName = randomAlphaOfLengthBetween(1, 10).     PlainActionFuture<MainResponse> future = PlainActionFuture.newFuture().     restHighLevelClient.customAsync(request, optionsForNodeName(nodeName), future).     assertEquals(nodeName, future.get().getNodeName()).     future = PlainActionFuture.newFuture().     restHighLevelClient.customAndParseAsync(request, optionsForNodeName(nodeName), future).     assertEquals(nodeName, future.get().getNodeName()). }
false;private,static;1;5;;private static RequestOptions optionsForNodeName(String nodeName) {     RequestOptions.Builder options = RequestOptions.DEFAULT.toBuilder().     options.addHeader("node_name", nodeName).     return options.build(). }
true;public;0;20;/**  * The {@link RestHighLevelClient} must declare the following execution methods using the <code>protected</code> modifier  * so that they can be used by subclasses to implement custom logic.  */ ;/**  * The {@link RestHighLevelClient} must declare the following execution methods using the <code>protected</code> modifier  * so that they can be used by subclasses to implement custom logic.  */ @SuppressForbidden(reason = "We're forced to uses Class#getDeclaredMethods() here because this test checks protected methods") public void testMethodsVisibility() {     final String[] methodNames = new String[] { "convertExistsResponse", "parseEntity", "parseResponseException", "performRequest", "performRequestAndParseEntity", "performRequestAndParseOptionalEntity", "performRequestAsync", "performRequestAsyncAndParseEntity", "performRequestAsyncAndParseOptionalEntity" }.     final Set<String> protectedMethods = Arrays.stream(RestHighLevelClient.class.getDeclaredMethods()).filter(method -> Modifier.isProtected(method.getModifiers())).map(Method::getName).collect(Collectors.toCollection(TreeSet::new)).     assertThat(protectedMethods, contains(methodNames)). }
true;private;2;8;/**  * Mocks the asynchronous request execution by calling the {@link #mockPerformRequest(Request)} method.  */ ;/**  * Mocks the asynchronous request execution by calling the {@link #mockPerformRequest(Request)} method.  */ private Void mockPerformRequestAsync(Request request, ResponseListener responseListener) {     try {         responseListener.onSuccess(mockPerformRequest(request)).     } catch (IOException e) {         responseListener.onFailure(e).     }     return null. }
true;private;1;18;/**  * Mocks the synchronous request execution like if it was executed by Elasticsearch.  */ ;/**  * Mocks the synchronous request execution like if it was executed by Elasticsearch.  */ private Response mockPerformRequest(Request request) throws IOException {     assertThat(request.getOptions().getHeaders(), hasSize(1)).     Header httpHeader = request.getOptions().getHeaders().get(0).     final Response mockResponse = mock(Response.class).     when(mockResponse.getHost()).thenReturn(new HttpHost("localhost", 9200)).     ProtocolVersion protocol = new ProtocolVersion("HTTP", 1, 1).     when(mockResponse.getStatusLine()).thenReturn(new BasicStatusLine(protocol, 200, "OK")).     MainResponse response = new MainResponse(httpHeader.getValue(), Version.CURRENT, ClusterName.DEFAULT, "_na", Build.CURRENT).     BytesRef bytesRef = XContentHelper.toXContent(response, XContentType.JSON, false).toBytesRef().     when(mockResponse.getEntity()).thenReturn(new NByteArrayEntity(bytesRef.bytes, ContentType.APPLICATION_JSON)).     RequestLine requestLine = new BasicRequestLine(HttpGet.METHOD_NAME, ENDPOINT, protocol).     when(mockResponse.getRequestLine()).thenReturn(requestLine).     return mockResponse. }
false;;2;3;;MainResponse custom(MainRequest mainRequest, RequestOptions options) throws IOException {     return performRequest(mainRequest, this::toRequest, options, this::toResponse, emptySet()). }
false;;2;3;;MainResponse customAndParse(MainRequest mainRequest, RequestOptions options) throws IOException {     return performRequestAndParseEntity(mainRequest, this::toRequest, options, MainResponse::fromXContent, emptySet()). }
false;;3;3;;void customAsync(MainRequest mainRequest, RequestOptions options, ActionListener<MainResponse> listener) {     performRequestAsync(mainRequest, this::toRequest, options, this::toResponse, listener, emptySet()). }
false;;3;3;;void customAndParseAsync(MainRequest mainRequest, RequestOptions options, ActionListener<MainResponse> listener) {     performRequestAsyncAndParseEntity(mainRequest, this::toRequest, options, MainResponse::fromXContent, listener, emptySet()). }
false;;1;3;;Request toRequest(MainRequest mainRequest) throws IOException {     return new Request(HttpGet.METHOD_NAME, ENDPOINT). }
false;;1;3;;MainResponse toResponse(Response response) throws IOException {     return parseEntity(response.getEntity(), MainResponse::fromXContent). }
