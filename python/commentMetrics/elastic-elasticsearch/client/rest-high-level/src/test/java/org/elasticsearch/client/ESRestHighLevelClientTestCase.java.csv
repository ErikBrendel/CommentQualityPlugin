commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void initHighLevelClient() throws IOException {     super.initClient().     if (restHighLevelClient == null) {         restHighLevelClient = new HighLevelClient(client()).     } }
false;public,static;0;5;;@AfterClass public static void cleanupClient() throws IOException {     IOUtils.close(restHighLevelClient).     restHighLevelClient = null. }
false;protected,static;0;3;;protected static RestHighLevelClient highLevelClient() {     return restHighLevelClient. }
true;protected,static;3;4;/**  * Executes the provided request using either the sync method or its async variant, both provided as functions  */ ;/**  * Executes the provided request using either the sync method or its async variant, both provided as functions  */ protected static <Req, Resp> Resp execute(Req request, SyncMethod<Req, Resp> syncMethod, AsyncMethod<Req, Resp> asyncMethod) throws IOException {     return execute(request, syncMethod, asyncMethod, RequestOptions.DEFAULT). }
true;protected,static;4;10;/**  * Executes the provided request using either the sync method or its async variant, both provided as functions  */ ;/**  * Executes the provided request using either the sync method or its async variant, both provided as functions  */ protected static <Req, Resp> Resp execute(Req request, SyncMethod<Req, Resp> syncMethod, AsyncMethod<Req, Resp> asyncMethod, RequestOptions options) throws IOException {     if (randomBoolean()) {         return syncMethod.execute(request, options).     } else {         PlainActionFuture<Resp> future = PlainActionFuture.newFuture().         asyncMethod.execute(request, options, future).         return future.actionGet().     } }
true;protected,static;3;10;/**  * Executes the provided request using either the sync method or its async  * variant, both provided as functions. This variant is used when the call does  * not have a request object (only headers and the request path).  */ ;/**  * Executes the provided request using either the sync method or its async  * variant, both provided as functions. This variant is used when the call does  * not have a request object (only headers and the request path).  */ protected static <Resp> Resp execute(SyncMethodNoRequest<Resp> syncMethodNoRequest, AsyncMethodNoRequest<Resp> asyncMethodNoRequest, RequestOptions requestOptions) throws IOException {     if (randomBoolean()) {         return syncMethodNoRequest.execute(requestOptions).     } else {         PlainActionFuture<Resp> future = PlainActionFuture.newFuture().         asyncMethodNoRequest.execute(requestOptions, future).         return future.actionGet().     } }
false;;2;1;;Response execute(Request request, RequestOptions options) throws IOException.
false;;1;1;;Response execute(RequestOptions options) throws IOException.
false;;3;1;;void execute(Request request, RequestOptions options, ActionListener<Response> listener).
false;;2;1;;void execute(RequestOptions options, ActionListener<Response> listener).
false;protected,static;1;26;;protected static XContentBuilder buildRandomXContentPipeline(XContentBuilder pipelineBuilder) throws IOException {     pipelineBuilder.startObject().     {         pipelineBuilder.field(Pipeline.DESCRIPTION_KEY, "some random set of processors").         pipelineBuilder.startArray(Pipeline.PROCESSORS_KEY).         {             pipelineBuilder.startObject().startObject("set").             {                 pipelineBuilder.field("field", "foo").field("value", "bar").             }             pipelineBuilder.endObject().endObject().             pipelineBuilder.startObject().startObject("convert").             {                 pipelineBuilder.field("field", "rank").field("type", "integer").             }             pipelineBuilder.endObject().endObject().         }         pipelineBuilder.endArray().     }     pipelineBuilder.endObject().     return pipelineBuilder. }
false;protected,static;0;5;;protected static XContentBuilder buildRandomXContentPipeline() throws IOException {     XContentType xContentType = randomFrom(XContentType.values()).     XContentBuilder pipelineBuilder = XContentBuilder.builder(xContentType.xContent()).     return buildRandomXContentPipeline(pipelineBuilder). }
false;protected,static;3;15;;protected static void createFieldAddingPipleine(String id, String fieldName, String value) throws IOException {     XContentBuilder pipeline = jsonBuilder().startObject().startArray("processors").startObject().startObject("set").field("field", fieldName).field("value", value).endObject().endObject().endArray().endObject().     createPipeline(new PutPipelineRequest(id, BytesReference.bytes(pipeline), XContentType.JSON)). }
false;protected,static;1;4;;protected static void createPipeline(String pipelineId) throws IOException {     XContentBuilder builder = buildRandomXContentPipeline().     createPipeline(new PutPipelineRequest(pipelineId, BytesReference.bytes(builder), builder.contentType())). }
false;protected,static;1;4;;protected static void createPipeline(PutPipelineRequest putPipelineRequest) throws IOException {     assertTrue(execute(putPipelineRequest, highLevelClient().ingest()::putPipeline, highLevelClient().ingest()::putPipelineAsync).isAcknowledged()). }
false;protected,static;2;8;;protected static void clusterUpdateSettings(Settings persistentSettings, Settings transientSettings) throws IOException {     ClusterUpdateSettingsRequest request = new ClusterUpdateSettingsRequest().     request.persistentSettings(persistentSettings).     request.transientSettings(transientSettings).     assertTrue(execute(request, highLevelClient().cluster()::putSettings, highLevelClient().cluster()::putSettingsAsync).isAcknowledged()). }
false;protected;0;10;;@Override protected Settings restClientSettings() {     final String user = Objects.requireNonNull(System.getProperty("tests.rest.cluster.username")).     final String pass = Objects.requireNonNull(System.getProperty("tests.rest.cluster.password")).     final String token = "Basic " + Base64.getEncoder().encodeToString((user + ":" + pass).getBytes(StandardCharsets.UTF_8)).     return Settings.builder().put(super.restClientSettings()).put(ThreadContext.PREFIX + ".Authorization", token).build(). }
false;protected;1;4;;protected Iterable<SearchHit> searchAll(String... indices) throws IOException {     SearchRequest searchRequest = new SearchRequest(indices).     return searchAll(searchRequest). }
false;protected;1;5;;protected Iterable<SearchHit> searchAll(SearchRequest searchRequest) throws IOException {     refreshIndexes(searchRequest.indices()).     SearchResponse search = highLevelClient().search(searchRequest, RequestOptions.DEFAULT).     return search.getHits(). }
false;protected;1;6;;protected void refreshIndexes(String... indices) throws IOException {     String joinedIndices = Arrays.stream(indices).collect(Collectors.joining(",")).     Response refreshResponse = client().performRequest(new Request("POST", "/" + joinedIndices + "/_refresh")).     assertEquals(200, refreshResponse.getStatusLine().getStatusCode()). }
false;protected;1;9;;protected void createIndexWithMultipleShards(String index) throws IOException {     CreateIndexRequest indexRequest = new CreateIndexRequest(index).     int shards = randomIntBetween(8, 10).     indexRequest.settings(Settings.builder().put("index.number_of_shards", shards).put("index.number_of_replicas", 0)).     highLevelClient().indices().create(indexRequest, RequestOptions.DEFAULT). }
