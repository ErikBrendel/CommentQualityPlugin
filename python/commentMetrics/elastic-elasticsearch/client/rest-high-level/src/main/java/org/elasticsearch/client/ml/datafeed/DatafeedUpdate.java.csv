# id;timestamp;commentText;codeText;commentWords;codeWords
DatafeedUpdate -> @Override     public int hashCode();1536828374;Note this could be a heavy operation when a query or aggregations_are set as we need to convert the bytes references into maps to_compute a stable hash code.;@Override_    public int hashCode() {_        return Objects.hash(id, jobId, frequency, queryDelay, indices, types, asMap(query), scrollSize, asMap(aggregations), scriptFields,_            chunkingConfig)__    };note,this,could,be,a,heavy,operation,when,a,query,or,aggregations,are,set,as,we,need,to,convert,the,bytes,references,into,maps,to,compute,a,stable,hash,code;override,public,int,hash,code,return,objects,hash,id,job,id,frequency,query,delay,indices,types,as,map,query,scroll,size,as,map,aggregations,script,fields,chunking,config
DatafeedUpdate -> @Override     public int hashCode();1540847035;Note this could be a heavy operation when a query or aggregations_are set as we need to convert the bytes references into maps to_compute a stable hash code.;@Override_    public int hashCode() {_        return Objects.hash(id, jobId, frequency, queryDelay, indices, types, asMap(query), scrollSize, asMap(aggregations), scriptFields,_            chunkingConfig)__    };note,this,could,be,a,heavy,operation,when,a,query,or,aggregations,are,set,as,we,need,to,convert,the,bytes,references,into,maps,to,compute,a,stable,hash,code;override,public,int,hash,code,return,objects,hash,id,job,id,frequency,query,delay,indices,types,as,map,query,scroll,size,as,map,aggregations,script,fields,chunking,config
DatafeedUpdate -> @Override     public int hashCode();1542310365;Note this could be a heavy operation when a query or aggregations_are set as we need to convert the bytes references into maps to_compute a stable hash code.;@Override_    public int hashCode() {_        return Objects.hash(id, jobId, frequency, queryDelay, indices, types, asMap(query), scrollSize, asMap(aggregations), scriptFields,_            chunkingConfig, delayedDataCheckConfig)__    };note,this,could,be,a,heavy,operation,when,a,query,or,aggregations,are,set,as,we,need,to,convert,the,bytes,references,into,maps,to,compute,a,stable,hash,code;override,public,int,hash,code,return,objects,hash,id,job,id,frequency,query,delay,indices,types,as,map,query,scroll,size,as,map,aggregations,script,fields,chunking,config,delayed,data,check,config
DatafeedUpdate -> @Override     public int hashCode();1546587824;Note this could be a heavy operation when a query or aggregations_are set as we need to convert the bytes references into maps to_compute a stable hash code.;@Override_    public int hashCode() {_        return Objects.hash(id, jobId, frequency, queryDelay, indices, asMap(query), scrollSize, asMap(aggregations), scriptFields,_            chunkingConfig, delayedDataCheckConfig)__    };note,this,could,be,a,heavy,operation,when,a,query,or,aggregations,are,set,as,we,need,to,convert,the,bytes,references,into,maps,to,compute,a,stable,hash,code;override,public,int,hash,code,return,objects,hash,id,job,id,frequency,query,delay,indices,as,map,query,scroll,size,as,map,aggregations,script,fields,chunking,config,delayed,data,check,config
DatafeedUpdate -> @Override     public boolean equals(Object other);1535552903;The lists of indices and types are compared for equality but they are not_sorted first so this test could fail simply because the indices and types_lists are in different orders.;@Override_    public boolean equals(Object other) {_        if (this == other) {_            return true__        }__        if (other == null || getClass() != other.getClass()) {_            return false__        }__        DatafeedUpdate that = (DatafeedUpdate) other___        return Objects.equals(this.id, that.id)_            && Objects.equals(this.jobId, that.jobId)_            && Objects.equals(this.frequency, that.frequency)_            && Objects.equals(this.queryDelay, that.queryDelay)_            && Objects.equals(this.indices, that.indices)_            && Objects.equals(this.types, that.types)_            && Objects.equals(this.query, that.query)_            && Objects.equals(this.scrollSize, that.scrollSize)_            && Objects.equals(this.aggregations, that.aggregations)_            && Objects.equals(this.scriptFields, that.scriptFields)_            && Objects.equals(this.chunkingConfig, that.chunkingConfig)__    };the,lists,of,indices,and,types,are,compared,for,equality,but,they,are,not,sorted,first,so,this,test,could,fail,simply,because,the,indices,and,types,lists,are,in,different,orders;override,public,boolean,equals,object,other,if,this,other,return,true,if,other,null,get,class,other,get,class,return,false,datafeed,update,that,datafeed,update,other,return,objects,equals,this,id,that,id,objects,equals,this,job,id,that,job,id,objects,equals,this,frequency,that,frequency,objects,equals,this,query,delay,that,query,delay,objects,equals,this,indices,that,indices,objects,equals,this,types,that,types,objects,equals,this,query,that,query,objects,equals,this,scroll,size,that,scroll,size,objects,equals,this,aggregations,that,aggregations,objects,equals,this,script,fields,that,script,fields,objects,equals,this,chunking,config,that,chunking,config
DatafeedUpdate -> @Override     public boolean equals(Object other);1536828374;The lists of indices and types are compared for equality but they are not_sorted first so this test could fail simply because the indices and types_lists are in different orders.__Also note this could be a heavy operation when a query or aggregations_are set as we need to convert the bytes references into maps to correctly_compare them.;@Override_    public boolean equals(Object other) {_        if (this == other) {_            return true__        }__        if (other == null || getClass() != other.getClass()) {_            return false__        }__        DatafeedUpdate that = (DatafeedUpdate) other___        return Objects.equals(this.id, that.id)_            && Objects.equals(this.jobId, that.jobId)_            && Objects.equals(this.frequency, that.frequency)_            && Objects.equals(this.queryDelay, that.queryDelay)_            && Objects.equals(this.indices, that.indices)_            && Objects.equals(this.types, that.types)_            && Objects.equals(asMap(this.query), asMap(that.query))_            && Objects.equals(this.scrollSize, that.scrollSize)_            && Objects.equals(asMap(this.aggregations), asMap(that.aggregations))_            && Objects.equals(this.scriptFields, that.scriptFields)_            && Objects.equals(this.chunkingConfig, that.chunkingConfig)__    };the,lists,of,indices,and,types,are,compared,for,equality,but,they,are,not,sorted,first,so,this,test,could,fail,simply,because,the,indices,and,types,lists,are,in,different,orders,also,note,this,could,be,a,heavy,operation,when,a,query,or,aggregations,are,set,as,we,need,to,convert,the,bytes,references,into,maps,to,correctly,compare,them;override,public,boolean,equals,object,other,if,this,other,return,true,if,other,null,get,class,other,get,class,return,false,datafeed,update,that,datafeed,update,other,return,objects,equals,this,id,that,id,objects,equals,this,job,id,that,job,id,objects,equals,this,frequency,that,frequency,objects,equals,this,query,delay,that,query,delay,objects,equals,this,indices,that,indices,objects,equals,this,types,that,types,objects,equals,as,map,this,query,as,map,that,query,objects,equals,this,scroll,size,that,scroll,size,objects,equals,as,map,this,aggregations,as,map,that,aggregations,objects,equals,this,script,fields,that,script,fields,objects,equals,this,chunking,config,that,chunking,config
DatafeedUpdate -> @Override     public boolean equals(Object other);1540847035;The lists of indices and types are compared for equality but they are not_sorted first so this test could fail simply because the indices and types_lists are in different orders.__Also note this could be a heavy operation when a query or aggregations_are set as we need to convert the bytes references into maps to correctly_compare them.;@Override_    public boolean equals(Object other) {_        if (this == other) {_            return true__        }__        if (other == null || getClass() != other.getClass()) {_            return false__        }__        DatafeedUpdate that = (DatafeedUpdate) other___        return Objects.equals(this.id, that.id)_            && Objects.equals(this.jobId, that.jobId)_            && Objects.equals(this.frequency, that.frequency)_            && Objects.equals(this.queryDelay, that.queryDelay)_            && Objects.equals(this.indices, that.indices)_            && Objects.equals(this.types, that.types)_            && Objects.equals(asMap(this.query), asMap(that.query))_            && Objects.equals(this.scrollSize, that.scrollSize)_            && Objects.equals(asMap(this.aggregations), asMap(that.aggregations))_            && Objects.equals(this.scriptFields, that.scriptFields)_            && Objects.equals(this.chunkingConfig, that.chunkingConfig)__    };the,lists,of,indices,and,types,are,compared,for,equality,but,they,are,not,sorted,first,so,this,test,could,fail,simply,because,the,indices,and,types,lists,are,in,different,orders,also,note,this,could,be,a,heavy,operation,when,a,query,or,aggregations,are,set,as,we,need,to,convert,the,bytes,references,into,maps,to,correctly,compare,them;override,public,boolean,equals,object,other,if,this,other,return,true,if,other,null,get,class,other,get,class,return,false,datafeed,update,that,datafeed,update,other,return,objects,equals,this,id,that,id,objects,equals,this,job,id,that,job,id,objects,equals,this,frequency,that,frequency,objects,equals,this,query,delay,that,query,delay,objects,equals,this,indices,that,indices,objects,equals,this,types,that,types,objects,equals,as,map,this,query,as,map,that,query,objects,equals,this,scroll,size,that,scroll,size,objects,equals,as,map,this,aggregations,as,map,that,aggregations,objects,equals,this,script,fields,that,script,fields,objects,equals,this,chunking,config,that,chunking,config
DatafeedUpdate -> @Override     public boolean equals(Object other);1542310365;The lists of indices and types are compared for equality but they are not_sorted first so this test could fail simply because the indices and types_lists are in different orders.__Also note this could be a heavy operation when a query or aggregations_are set as we need to convert the bytes references into maps to correctly_compare them.;@Override_    public boolean equals(Object other) {_        if (this == other) {_            return true__        }__        if (other == null || getClass() != other.getClass()) {_            return false__        }__        DatafeedUpdate that = (DatafeedUpdate) other___        return Objects.equals(this.id, that.id)_            && Objects.equals(this.jobId, that.jobId)_            && Objects.equals(this.frequency, that.frequency)_            && Objects.equals(this.queryDelay, that.queryDelay)_            && Objects.equals(this.indices, that.indices)_            && Objects.equals(this.types, that.types)_            && Objects.equals(asMap(this.query), asMap(that.query))_            && Objects.equals(this.scrollSize, that.scrollSize)_            && Objects.equals(asMap(this.aggregations), asMap(that.aggregations))_            && Objects.equals(this.delayedDataCheckConfig, that.delayedDataCheckConfig)_            && Objects.equals(this.scriptFields, that.scriptFields)_            && Objects.equals(this.chunkingConfig, that.chunkingConfig)__    };the,lists,of,indices,and,types,are,compared,for,equality,but,they,are,not,sorted,first,so,this,test,could,fail,simply,because,the,indices,and,types,lists,are,in,different,orders,also,note,this,could,be,a,heavy,operation,when,a,query,or,aggregations,are,set,as,we,need,to,convert,the,bytes,references,into,maps,to,correctly,compare,them;override,public,boolean,equals,object,other,if,this,other,return,true,if,other,null,get,class,other,get,class,return,false,datafeed,update,that,datafeed,update,other,return,objects,equals,this,id,that,id,objects,equals,this,job,id,that,job,id,objects,equals,this,frequency,that,frequency,objects,equals,this,query,delay,that,query,delay,objects,equals,this,indices,that,indices,objects,equals,this,types,that,types,objects,equals,as,map,this,query,as,map,that,query,objects,equals,this,scroll,size,that,scroll,size,objects,equals,as,map,this,aggregations,as,map,that,aggregations,objects,equals,this,delayed,data,check,config,that,delayed,data,check,config,objects,equals,this,script,fields,that,script,fields,objects,equals,this,chunking,config,that,chunking,config
DatafeedUpdate -> @Override     public boolean equals(Object other);1546587824;The lists of indices and types are compared for equality but they are not_sorted first so this test could fail simply because the indices and types_lists are in different orders.__Also note this could be a heavy operation when a query or aggregations_are set as we need to convert the bytes references into maps to correctly_compare them.;@Override_    public boolean equals(Object other) {_        if (this == other) {_            return true__        }__        if (other == null || getClass() != other.getClass()) {_            return false__        }__        DatafeedUpdate that = (DatafeedUpdate) other___        return Objects.equals(this.id, that.id)_            && Objects.equals(this.jobId, that.jobId)_            && Objects.equals(this.frequency, that.frequency)_            && Objects.equals(this.queryDelay, that.queryDelay)_            && Objects.equals(this.indices, that.indices)_            && Objects.equals(asMap(this.query), asMap(that.query))_            && Objects.equals(this.scrollSize, that.scrollSize)_            && Objects.equals(asMap(this.aggregations), asMap(that.aggregations))_            && Objects.equals(this.delayedDataCheckConfig, that.delayedDataCheckConfig)_            && Objects.equals(this.scriptFields, that.scriptFields)_            && Objects.equals(this.chunkingConfig, that.chunkingConfig)__    };the,lists,of,indices,and,types,are,compared,for,equality,but,they,are,not,sorted,first,so,this,test,could,fail,simply,because,the,indices,and,types,lists,are,in,different,orders,also,note,this,could,be,a,heavy,operation,when,a,query,or,aggregations,are,set,as,we,need,to,convert,the,bytes,references,into,maps,to,correctly,compare,them;override,public,boolean,equals,object,other,if,this,other,return,true,if,other,null,get,class,other,get,class,return,false,datafeed,update,that,datafeed,update,other,return,objects,equals,this,id,that,id,objects,equals,this,job,id,that,job,id,objects,equals,this,frequency,that,frequency,objects,equals,this,query,delay,that,query,delay,objects,equals,this,indices,that,indices,objects,equals,as,map,this,query,as,map,that,query,objects,equals,this,scroll,size,that,scroll,size,objects,equals,as,map,this,aggregations,as,map,that,aggregations,objects,equals,this,delayed,data,check,config,that,delayed,data,check,config,objects,equals,this,script,fields,that,script,fields,objects,equals,this,chunking,config,that,chunking,config
DatafeedUpdate -> public String getId();1535552903;Get the id of the datafeed to update;public String getId() {_        return id__    };get,the,id,of,the,datafeed,to,update;public,string,get,id,return,id
DatafeedUpdate -> public String getId();1536828374;Get the id of the datafeed to update;public String getId() {_        return id__    };get,the,id,of,the,datafeed,to,update;public,string,get,id,return,id
DatafeedUpdate -> public String getId();1540847035;Get the id of the datafeed to update;public String getId() {_        return id__    };get,the,id,of,the,datafeed,to,update;public,string,get,id,return,id
DatafeedUpdate -> public String getId();1542310365;Get the id of the datafeed to update;public String getId() {_        return id__    };get,the,id,of,the,datafeed,to,update;public,string,get,id,return,id
DatafeedUpdate -> public String getId();1546587824;Get the id of the datafeed to update;public String getId() {_        return id__    };get,the,id,of,the,datafeed,to,update;public,string,get,id,return,id
