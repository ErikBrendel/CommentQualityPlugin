commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The indices names covered by the privileges.  */ ;/**  * The indices names covered by the privileges.  */ public Set<String> getIndices() {     return this.indices. }
true;public;0;3;/**  * The privileges acting over indices. There is a canonical predefined set of  * such privileges, but the {@code String} datatype allows for flexibility in defining  * finer grained privileges.  */ ;/**  * The privileges acting over indices. There is a canonical predefined set of  * such privileges, but the {@code String} datatype allows for flexibility in defining  * finer grained privileges.  */ public Set<String> getPrivileges() {     return this.privileges. }
true;public;0;3;/**  * True if the privileges cover restricted internal indices too. Certain indices are reserved for internal services and should be  * transparent to ordinary users. For that matter, when granting privileges, you also have to toggle this flag to confirm that all  * indices, including restricted ones, are in the scope of this permission. By default this is false.  */ ;/**  * True if the privileges cover restricted internal indices too. Certain indices are reserved for internal services and should be  * transparent to ordinary users. For that matter, when granting privileges, you also have to toggle this flag to confirm that all  * indices, including restricted ones, are in the scope of this permission. By default this is false.  */ public boolean allowRestrictedIndices() {     return this.allowRestrictedIndices. }
true;public,abstract;0;1;/**  * If {@code true} some documents might not be visible. Only the documents  * matching {@code query} will be readable.  */ ;/**  * If {@code true} some documents might not be visible. Only the documents  * matching {@code query} will be readable.  */ public abstract boolean isUsingDocumentLevelSecurity().
true;public,abstract;0;1;/**  * If {@code true} some document fields might not be visible.  */ ;/**  * If {@code true} some document fields might not be visible.  */ public abstract boolean isUsingFieldLevelSecurity().
false;private,static;1;7;;@SuppressWarnings("unchecked") private static FieldSecurity buildObjectFromParserArgs(Object[] args) {     return new FieldSecurity((Collection<String>) args[0], (Collection<String>) args[1]). }
false;static;2;3;;static FieldSecurity parse(XContentParser parser, Void context) throws IOException {     return PARSER.parse(parser, context). }
true;public;0;3;/**  * The document fields that can be read or queried. Can be null, in this case  * all the document's fields are granted access to. Can also be empty, in which  * case no fields are granted access to.  */ ;/**  * The document fields that can be read or queried. Can be null, in this case  * all the document's fields are granted access to. Can also be empty, in which  * case no fields are granted access to.  */ public Set<String> getGrantedFields() {     return grantedFields. }
true;public;0;3;/**  * The document fields that cannot be accessed or queried. Can be null or empty,  * in which case no fields are denied.  */ ;/**  * The document fields that cannot be accessed or queried. Can be null or empty,  * in which case no fields are denied.  */ public Set<String> getDeniedFields() {     return deniedFields. }
false;public;0;3;;public boolean isUsingFieldLevelSecurity() {     return limitsGrantedFields() || hasDeniedFields(). }
false;private;0;3;;private boolean hasDeniedFields() {     return deniedFields != null && false == deniedFields.isEmpty(). }
false;private;0;7;;private boolean limitsGrantedFields() {     // we treat just '*' as no FLS since that's what the UI defaults to     if (grantedFields == null || (grantedFields.size() == 1 && grantedFields.iterator().next().equals("*"))) {         return false.     }     return true. }
false;public;2;14;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (grantedFields == null) {         // The role parser will reject a field_security object that doesn't have a "granted" field         builder.field(GRANT_FIELDS.getPreferredName(), Collections.singletonList("*")).     } else {         builder.field(GRANT_FIELDS.getPreferredName(), grantedFields).     }     if (deniedFields != null) {         builder.field(EXCEPT_FIELDS.getPreferredName(), deniedFields).     }     return builder.endObject(). }
false;public;0;8;;@Override public String toString() {     try {         return XContentHelper.toXContent(this, XContentType.JSON, true).utf8ToString().     } catch (IOException e) {         throw new UncheckedIOException("Unexpected", e).     } }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     final FieldSecurity that = (FieldSecurity) o.     return Objects.equals(this.grantedFields, that.grantedFields) && Objects.equals(this.deniedFields, that.deniedFields). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(grantedFields, deniedFields). }
