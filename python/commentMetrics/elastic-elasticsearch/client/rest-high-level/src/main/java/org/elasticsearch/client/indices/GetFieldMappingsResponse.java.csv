commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the fields mapping. The return map keys are indexes and fields (as specified in the request).  */ ;/**  * Returns the fields mapping. The return map keys are indexes and fields (as specified in the request).  */ public Map<String, Map<String, FieldMappingMetaData>> mappings() {     return mappings. }
true;public;2;7;/**  * Returns the mappings of a specific index and field.  *  * @param field field name as specified in the {@link GetFieldMappingsRequest}  * @return FieldMappingMetaData for the requested field or null if not found.  */ ;/**  * Returns the mappings of a specific index and field.  *  * @param field field name as specified in the {@link GetFieldMappingsRequest}  * @return FieldMappingMetaData for the requested field or null if not found.  */ public FieldMappingMetaData fieldMappings(String index, String field) {     Map<String, FieldMappingMetaData> indexMapping = mappings.get(index).     if (indexMapping == null) {         return null.     }     return indexMapping.get(field). }
false;public,static;1;13;;public static GetFieldMappingsResponse fromXContent(XContentParser parser) throws IOException {     ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation).     final Map<String, Map<String, FieldMappingMetaData>> mappings = new HashMap<>().     if (parser.nextToken() == XContentParser.Token.FIELD_NAME) {         while (parser.currentToken() == XContentParser.Token.FIELD_NAME) {             final String index = parser.currentName().             final Map<String, FieldMappingMetaData> fieldMappings = PARSER.parse(parser, index).             mappings.put(index, fieldMappings).             parser.nextToken().         }     }     return new GetFieldMappingsResponse(mappings). }
false;public;0;3;;public String fullName() {     return fullName. }
true;public;0;3;/**  * Returns the mappings as a map. Note that the returned map has a single key which is always the field's {@link Mapper#name}.  */ ;/**  * Returns the mappings as a map. Note that the returned map has a single key which is always the field's {@link Mapper#name}.  */ public Map<String, Object> sourceAsMap() {     return XContentHelper.convertToMap(source, true, XContentType.JSON).v2(). }
true;;0;3;// pkg-private for testing ;// pkg-private for testing BytesReference getSource() {     return source. }
false;public,static;1;3;;public static FieldMappingMetaData fromXContent(XContentParser parser) throws IOException {     return PARSER.parse(parser, null). }
false;public;0;4;;@Override public String toString() {     return "FieldMappingMetaData{fullName='" + fullName + '\'' + ", source=" + source + '}'. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (!(o instanceof FieldMappingMetaData))         return false.     FieldMappingMetaData that = (FieldMappingMetaData) o.     return Objects.equals(fullName, that.fullName) && Objects.equals(source, that.source). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(fullName, source). }
false;public;0;4;;@Override public String toString() {     return "GetFieldMappingsResponse{" + "mappings=" + mappings + '}'. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (!(o instanceof GetFieldMappingsResponse))         return false.     GetFieldMappingsResponse that = (GetFieldMappingsResponse) o.     return Objects.equals(mappings, that.mappings). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(mappings). }
