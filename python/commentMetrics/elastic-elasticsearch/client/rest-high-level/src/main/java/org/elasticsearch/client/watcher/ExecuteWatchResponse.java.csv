commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * @return The id of the watch record holding the watch execution result.  */ ;/**  * @return The id of the watch record holding the watch execution result.  */ public String getRecordId() {     return recordId. }
true;public;0;3;/**  * @return The watch record source  */ ;/**  * @return The watch record source  */ public BytesReference getRecord() {     return contentSource. }
true;public;0;13;/**  * Returns the watch record as a map  *  * Use {@link org.elasticsearch.common.xcontent.ObjectPath} to navigate through the data  */ ;/**  * Returns the watch record as a map  *  * Use {@link org.elasticsearch.common.xcontent.ObjectPath} to navigate through the data  */ @SuppressWarnings("unchecked") public Map<String, Object> getRecordAsMap() {     if (data == null) {         // EMPTY is safe here because we never use namedObject         try (InputStream stream = contentSource.streamInput().             XContentParser parser = XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY, null, stream)) {             data = (Map<String, Object>) XContentUtils.readValue(parser, parser.nextToken()).         } catch (IOException ex) {             throw new ElasticsearchException("failed to read value", ex).         }     }     return data. }
false;public,static;1;3;;public static ExecuteWatchResponse fromXContent(XContentParser parser) throws IOException {     return PARSER.parse(parser, null). }
false;private,static;1;6;;private static BytesReference readBytesReference(XContentParser parser) throws IOException {     try (XContentBuilder builder = XContentFactory.jsonBuilder()) {         builder.copyCurrentStructure(parser).         return BytesReference.bytes(builder).     } }
