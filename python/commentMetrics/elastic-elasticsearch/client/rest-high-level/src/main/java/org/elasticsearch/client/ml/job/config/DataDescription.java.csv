commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Case-insensitive from string method.  * Works with either XCONTENT, XContent, etc.  *  * @param value String representation  * @return The data format  */ ;/**  * Case-insensitive from string method.  * Works with either XCONTENT, XContent, etc.  *  * @param value String representation  * @return The data format  */ public static DataFormat forString(String value) {     return DataFormat.valueOf(value.toUpperCase(Locale.ROOT)). }
false;public;0;4;;@Override public String toString() {     return name().toLowerCase(Locale.ROOT). }
false;public;2;17;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (dataFormat != DataFormat.XCONTENT) {         builder.field(FORMAT_FIELD.getPreferredName(), dataFormat).     }     builder.field(TIME_FIELD_NAME_FIELD.getPreferredName(), timeFieldName).     builder.field(TIME_FORMAT_FIELD.getPreferredName(), timeFormat).     if (fieldDelimiter != null) {         builder.field(FIELD_DELIMITER_FIELD.getPreferredName(), String.valueOf(fieldDelimiter)).     }     if (quoteCharacter != null) {         builder.field(QUOTE_CHARACTER_FIELD.getPreferredName(), String.valueOf(quoteCharacter)).     }     builder.endObject().     return builder. }
true;public;0;3;/**  * The format of the data to be processed.  * Defaults to {@link DataDescription.DataFormat#XCONTENT}  *  * @return The data format  */ ;/**  * The format of the data to be processed.  * Defaults to {@link DataDescription.DataFormat#XCONTENT}  *  * @return The data format  */ public DataFormat getFormat() {     return dataFormat. }
true;public;0;3;/**  * The name of the field containing the timestamp  *  * @return A String if set or <code>null</code>  */ ;/**  * The name of the field containing the timestamp  *  * @return A String if set or <code>null</code>  */ public String getTimeField() {     return timeFieldName. }
true;public;0;3;/**  * Either {@value #EPOCH}, {@value #EPOCH_MS} or a SimpleDateTime format string.  * If not set (is <code>null</code> or an empty string) or set to  * {@value #EPOCH_MS} (the default) then the date is assumed to be in  * milliseconds from the epoch.  *  * @return A String if set or <code>null</code>  */ ;/**  * Either {@value #EPOCH}, {@value #EPOCH_MS} or a SimpleDateTime format string.  * If not set (is <code>null</code> or an empty string) or set to  * {@value #EPOCH_MS} (the default) then the date is assumed to be in  * milliseconds from the epoch.  *  * @return A String if set or <code>null</code>  */ public String getTimeFormat() {     return timeFormat. }
true;public;0;3;/**  * If the data is in a delimited format with a header e.g. csv or tsv  * this is the delimiter character used. This is only applicable if  * {@linkplain #getFormat()} is {@link DataDescription.DataFormat#DELIMITED}.  * The default value for delimited format is {@value #DEFAULT_DELIMITER}.  *  * @return A char  */ ;/**  * If the data is in a delimited format with a header e.g. csv or tsv  * this is the delimiter character used. This is only applicable if  * {@linkplain #getFormat()} is {@link DataDescription.DataFormat#DELIMITED}.  * The default value for delimited format is {@value #DEFAULT_DELIMITER}.  *  * @return A char  */ public Character getFieldDelimiter() {     return fieldDelimiter. }
true;public;0;3;/**  * The quote character used in delimited formats.  * The default value for delimited format is {@value #DEFAULT_QUOTE_CHAR}.  *  * @return The delimited format quote character  */ ;/**  * The quote character used in delimited formats.  * The default value for delimited format is {@value #DEFAULT_QUOTE_CHAR}.  *  * @return The delimited format quote character  */ public Character getQuoteCharacter() {     return quoteCharacter. }
false;private,static;1;10;;private static Character extractChar(XContentParser parser) throws IOException {     if (parser.currentToken() == XContentParser.Token.VALUE_STRING) {         String charStr = parser.text().         if (charStr.length() != 1) {             throw new IllegalArgumentException("String must be a single character, found [" + charStr + "]").         }         return charStr.charAt(0).     }     throw new IllegalArgumentException("Unsupported token [" + parser.currentToken() + "]"). }
true;public;1;18;/**  * Overridden equality test  */ ;/**  * Overridden equality test  */ @Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other instanceof DataDescription == false) {         return false.     }     DataDescription that = (DataDescription) other.     return this.dataFormat == that.dataFormat && Objects.equals(this.quoteCharacter, that.quoteCharacter) && Objects.equals(this.timeFieldName, that.timeFieldName) && Objects.equals(this.timeFormat, that.timeFormat) && Objects.equals(this.fieldDelimiter, that.fieldDelimiter). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(dataFormat, quoteCharacter, timeFieldName, timeFormat, fieldDelimiter). }
false;public;1;4;;public Builder setFormat(DataFormat format) {     dataFormat = Objects.requireNonNull(format).     return this. }
false;private;1;4;;private Builder setFormat(String format) {     setFormat(DataFormat.forString(format)).     return this. }
false;public;1;4;;public Builder setTimeField(String fieldName) {     timeFieldName = Objects.requireNonNull(fieldName).     return this. }
false;public;1;4;;public Builder setTimeFormat(String format) {     timeFormat = Objects.requireNonNull(format).     return this. }
false;public;1;4;;public Builder setFieldDelimiter(Character delimiter) {     fieldDelimiter = delimiter.     return this. }
false;public;1;4;;public Builder setQuoteCharacter(Character value) {     quoteCharacter = value.     return this. }
false;public;0;11;;public DataDescription build() {     if (dataFormat == DataFormat.DELIMITED) {         if (fieldDelimiter == null) {             fieldDelimiter = DEFAULT_DELIMITER.         }         if (quoteCharacter == null) {             quoteCharacter = DEFAULT_QUOTE_CHAR.         }     }     return new DataDescription(dataFormat, timeFieldName, timeFormat, fieldDelimiter, quoteCharacter). }
