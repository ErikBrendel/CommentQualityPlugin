commented;modifiers;parameterAmount;loc;comment;code
false;static;1;15;;static Request delete(DeleteRequest deleteRequest) {     String endpoint = endpoint(deleteRequest.index(), deleteRequest.type(), deleteRequest.id()).     Request request = new Request(HttpDelete.METHOD_NAME, endpoint).     Params parameters = new Params(request).     parameters.withRouting(deleteRequest.routing()).     parameters.withTimeout(deleteRequest.timeout()).     parameters.withVersion(deleteRequest.version()).     parameters.withVersionType(deleteRequest.versionType()).     parameters.withIfSeqNo(deleteRequest.ifSeqNo()).     parameters.withIfPrimaryTerm(deleteRequest.ifPrimaryTerm()).     parameters.withRefreshPolicy(deleteRequest.getRefreshPolicy()).     parameters.withWaitForActiveShards(deleteRequest.waitForActiveShards()).     return request. }
false;static;0;3;;static Request info() {     return new Request(HttpGet.METHOD_NAME, "/"). }
false;static;1;133;;static Request bulk(BulkRequest bulkRequest) throws IOException {     Request request = new Request(HttpPost.METHOD_NAME, "/_bulk").     Params parameters = new Params(request).     parameters.withTimeout(bulkRequest.timeout()).     parameters.withRefreshPolicy(bulkRequest.getRefreshPolicy()).     parameters.withPipeline(bulkRequest.pipeline()).     parameters.withRouting(bulkRequest.routing()).     // Bulk API only supports newline delimited JSON or Smile. Before executing     // the bulk, we need to check that all requests have the same content-type     // and this content-type is supported by the Bulk API.     XContentType bulkContentType = null.     for (int i = 0. i < bulkRequest.numberOfActions(). i++) {         DocWriteRequest<?> action = bulkRequest.requests().get(i).         DocWriteRequest.OpType opType = action.opType().         if (opType == DocWriteRequest.OpType.INDEX || opType == DocWriteRequest.OpType.CREATE) {             bulkContentType = enforceSameContentType((IndexRequest) action, bulkContentType).         } else if (opType == DocWriteRequest.OpType.UPDATE) {             UpdateRequest updateRequest = (UpdateRequest) action.             if (updateRequest.doc() != null) {                 bulkContentType = enforceSameContentType(updateRequest.doc(), bulkContentType).             }             if (updateRequest.upsertRequest() != null) {                 bulkContentType = enforceSameContentType(updateRequest.upsertRequest(), bulkContentType).             }         }     }     if (bulkContentType == null) {         bulkContentType = XContentType.JSON.     }     final byte separator = bulkContentType.xContent().streamSeparator().     final ContentType requestContentType = createContentType(bulkContentType).     ByteArrayOutputStream content = new ByteArrayOutputStream().     for (DocWriteRequest<?> action : bulkRequest.requests()) {         DocWriteRequest.OpType opType = action.opType().         try (XContentBuilder metadata = XContentBuilder.builder(bulkContentType.xContent())) {             metadata.startObject().             {                 metadata.startObject(opType.getLowercase()).                 if (Strings.hasLength(action.index())) {                     metadata.field("_index", action.index()).                 }                 if (Strings.hasLength(action.type())) {                     if (MapperService.SINGLE_MAPPING_NAME.equals(action.type()) == false) {                         metadata.field("_type", action.type()).                     }                 }                 if (Strings.hasLength(action.id())) {                     metadata.field("_id", action.id()).                 }                 if (Strings.hasLength(action.routing())) {                     metadata.field("routing", action.routing()).                 }                 if (action.version() != Versions.MATCH_ANY) {                     metadata.field("version", action.version()).                 }                 VersionType versionType = action.versionType().                 if (versionType != VersionType.INTERNAL) {                     if (versionType == VersionType.EXTERNAL) {                         metadata.field("version_type", "external").                     } else if (versionType == VersionType.EXTERNAL_GTE) {                         metadata.field("version_type", "external_gte").                     } else if (versionType == VersionType.FORCE) {                         metadata.field("version_type", "force").                     }                 }                 if (action.ifSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO) {                     metadata.field("if_seq_no", action.ifSeqNo()).                     metadata.field("if_primary_term", action.ifPrimaryTerm()).                 }                 if (opType == DocWriteRequest.OpType.INDEX || opType == DocWriteRequest.OpType.CREATE) {                     IndexRequest indexRequest = (IndexRequest) action.                     if (Strings.hasLength(indexRequest.getPipeline())) {                         metadata.field("pipeline", indexRequest.getPipeline()).                     }                 } else if (opType == DocWriteRequest.OpType.UPDATE) {                     UpdateRequest updateRequest = (UpdateRequest) action.                     if (updateRequest.retryOnConflict() > 0) {                         metadata.field("retry_on_conflict", updateRequest.retryOnConflict()).                     }                     if (updateRequest.fetchSource() != null) {                         metadata.field("_source", updateRequest.fetchSource()).                     }                 }                 metadata.endObject().             }             metadata.endObject().             BytesRef metadataSource = BytesReference.bytes(metadata).toBytesRef().             content.write(metadataSource.bytes, metadataSource.offset, metadataSource.length).             content.write(separator).         }         BytesRef source = null.         if (opType == DocWriteRequest.OpType.INDEX || opType == DocWriteRequest.OpType.CREATE) {             IndexRequest indexRequest = (IndexRequest) action.             BytesReference indexSource = indexRequest.source().             XContentType indexXContentType = indexRequest.getContentType().             try (XContentParser parser = XContentHelper.createParser(/*                          * EMPTY and THROW are fine here because we just call                          * copyCurrentStructure which doesn't touch the                          * registry or deprecation.                          */             NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, indexSource, indexXContentType)) {                 try (XContentBuilder builder = XContentBuilder.builder(bulkContentType.xContent())) {                     builder.copyCurrentStructure(parser).                     source = BytesReference.bytes(builder).toBytesRef().                 }             }         } else if (opType == DocWriteRequest.OpType.UPDATE) {             source = XContentHelper.toXContent((UpdateRequest) action, bulkContentType, false).toBytesRef().         }         if (source != null) {             content.write(source.bytes, source.offset, source.length).             content.write(separator).         }     }     request.setEntity(new NByteArrayEntity(content.toByteArray(), 0, content.size(), requestContentType)).     return request. }
false;static;1;3;;static Request exists(GetRequest getRequest) {     return getStyleRequest(HttpHead.METHOD_NAME, getRequest). }
false;static;1;3;;static Request get(GetRequest getRequest) {     return getStyleRequest(HttpGet.METHOD_NAME, getRequest). }
false;private,static;2;15;;private static Request getStyleRequest(String method, GetRequest getRequest) {     Request request = new Request(method, endpoint(getRequest.index(), getRequest.type(), getRequest.id())).     Params parameters = new Params(request).     parameters.withPreference(getRequest.preference()).     parameters.withRouting(getRequest.routing()).     parameters.withRefresh(getRequest.refresh()).     parameters.withRealtime(getRequest.realtime()).     parameters.withStoredFields(getRequest.storedFields()).     parameters.withVersion(getRequest.version()).     parameters.withVersionType(getRequest.versionType()).     parameters.withFetchSourceContext(getRequest.fetchSourceContext()).     return request. }
false;static;1;17;;static Request sourceExists(GetRequest getRequest) {     String optionalType = getRequest.type().     String endpoint.     if (optionalType.equals(MapperService.SINGLE_MAPPING_NAME)) {         endpoint = endpoint(getRequest.index(), "_source", getRequest.id()).     } else {         endpoint = endpoint(getRequest.index(), optionalType, getRequest.id(), "_source").     }     Request request = new Request(HttpHead.METHOD_NAME, endpoint).     Params parameters = new Params(request).     parameters.withPreference(getRequest.preference()).     parameters.withRouting(getRequest.routing()).     parameters.withRefresh(getRequest.refresh()).     parameters.withRealtime(getRequest.realtime()).     // Version params are not currently supported by the source exists API so are not passed     return request. }
false;static;1;11;;static Request multiGet(MultiGetRequest multiGetRequest) throws IOException {     Request request = new Request(HttpPost.METHOD_NAME, "/_mget").     Params parameters = new Params(request).     parameters.withPreference(multiGetRequest.preference()).     parameters.withRealtime(multiGetRequest.realtime()).     parameters.withRefresh(multiGetRequest.refresh()).     request.setEntity(createEntity(multiGetRequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;30;;static Request index(IndexRequest indexRequest) {     String method = Strings.hasLength(indexRequest.id()) ? HttpPut.METHOD_NAME : HttpPost.METHOD_NAME.     String endpoint.     if (indexRequest.opType() == DocWriteRequest.OpType.CREATE) {         endpoint = indexRequest.type().equals(MapperService.SINGLE_MAPPING_NAME) ? endpoint(indexRequest.index(), "_create", indexRequest.id()) : endpoint(indexRequest.index(), indexRequest.type(), indexRequest.id(), "_create").     } else {         endpoint = endpoint(indexRequest.index(), indexRequest.type(), indexRequest.id()).     }     Request request = new Request(method, endpoint).     Params parameters = new Params(request).     parameters.withRouting(indexRequest.routing()).     parameters.withTimeout(indexRequest.timeout()).     parameters.withVersion(indexRequest.version()).     parameters.withVersionType(indexRequest.versionType()).     parameters.withIfSeqNo(indexRequest.ifSeqNo()).     parameters.withIfPrimaryTerm(indexRequest.ifPrimaryTerm()).     parameters.withPipeline(indexRequest.getPipeline()).     parameters.withRefreshPolicy(indexRequest.getRefreshPolicy()).     parameters.withWaitForActiveShards(indexRequest.waitForActiveShards()).     BytesRef source = indexRequest.source().toBytesRef().     ContentType contentType = createContentType(indexRequest.getContentType()).     request.setEntity(new NByteArrayEntity(source.bytes, source.offset, source.length, contentType)).     return request. }
false;static;0;3;;static Request ping() {     return new Request(HttpHead.METHOD_NAME, "/"). }
false;static;1;40;;static Request update(UpdateRequest updateRequest) throws IOException {     String endpoint = updateRequest.type().equals(MapperService.SINGLE_MAPPING_NAME) ? endpoint(updateRequest.index(), "_update", updateRequest.id()) : endpoint(updateRequest.index(), updateRequest.type(), updateRequest.id(), "_update").     Request request = new Request(HttpPost.METHOD_NAME, endpoint).     Params parameters = new Params(request).     parameters.withRouting(updateRequest.routing()).     parameters.withTimeout(updateRequest.timeout()).     parameters.withRefreshPolicy(updateRequest.getRefreshPolicy()).     parameters.withWaitForActiveShards(updateRequest.waitForActiveShards()).     parameters.withDocAsUpsert(updateRequest.docAsUpsert()).     parameters.withFetchSourceContext(updateRequest.fetchSource()).     parameters.withRetryOnConflict(updateRequest.retryOnConflict()).     parameters.withVersion(updateRequest.version()).     parameters.withVersionType(updateRequest.versionType()).     // The Java API allows update requests with different content types     // set for the partial document and the upsert document. This client     // only accepts update requests that have the same content types set     // for both doc and upsert.     XContentType xContentType = null.     if (updateRequest.doc() != null) {         xContentType = updateRequest.doc().getContentType().     }     if (updateRequest.upsertRequest() != null) {         XContentType upsertContentType = updateRequest.upsertRequest().getContentType().         if ((xContentType != null) && (xContentType != upsertContentType)) {             throw new IllegalStateException("Update request cannot have different content types for doc [" + xContentType + "]" + " and upsert [" + upsertContentType + "] documents").         } else {             xContentType = upsertContentType.         }     }     if (xContentType == null) {         xContentType = Requests.INDEX_CONTENT_TYPE.     }     request.setEntity(createEntity(updateRequest, xContentType)).     return request. }
true;static;2;11;/**  * Convert a {@linkplain SearchRequest} into a {@linkplain Request}.  * @param searchRequest the request to convert  * @param searchEndpoint the name of the search endpoint. {@literal _search}  *    for standard searches and {@literal _rollup_search} for rollup  *    searches.  */ ;/**  * Convert a {@linkplain SearchRequest} into a {@linkplain Request}.  * @param searchRequest the request to convert  * @param searchEndpoint the name of the search endpoint. {@literal _search}  *    for standard searches and {@literal _rollup_search} for rollup  *    searches.  */ static Request search(SearchRequest searchRequest, String searchEndpoint) throws IOException {     Request request = new Request(HttpPost.METHOD_NAME, endpoint(searchRequest.indices(), searchRequest.types(), searchEndpoint)).     Params params = new Params(request).     addSearchRequestParams(params, searchRequest).     if (searchRequest.source() != null) {         request.setEntity(createEntity(searchRequest.source(), REQUEST_BODY_CONTENT_TYPE)).     }     return request. }
false;private,static;2;18;;private static void addSearchRequestParams(Params params, SearchRequest searchRequest) {     params.putParam(RestSearchAction.TYPED_KEYS_PARAM, "true").     params.withRouting(searchRequest.routing()).     params.withPreference(searchRequest.preference()).     params.withIndicesOptions(searchRequest.indicesOptions()).     params.putParam("search_type", searchRequest.searchType().name().toLowerCase(Locale.ROOT)).     params.putParam("ccs_minimize_roundtrips", Boolean.toString(searchRequest.isCcsMinimizeRoundtrips())).     if (searchRequest.requestCache() != null) {         params.putParam("request_cache", Boolean.toString(searchRequest.requestCache())).     }     if (searchRequest.allowPartialSearchResults() != null) {         params.putParam("allow_partial_search_results", Boolean.toString(searchRequest.allowPartialSearchResults())).     }     params.putParam("batched_reduce_size", Integer.toString(searchRequest.getBatchedReduceSize())).     if (searchRequest.scroll() != null) {         params.putParam("scroll", searchRequest.scroll().keepAlive()).     } }
false;static;1;5;;static Request searchScroll(SearchScrollRequest searchScrollRequest) throws IOException {     Request request = new Request(HttpPost.METHOD_NAME, "/_search/scroll").     request.setEntity(createEntity(searchScrollRequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;5;;static Request clearScroll(ClearScrollRequest clearScrollRequest) throws IOException {     Request request = new Request(HttpDelete.METHOD_NAME, "/_search/scroll").     request.setEntity(createEntity(clearScrollRequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;14;;static Request multiSearch(MultiSearchRequest multiSearchRequest) throws IOException {     Request request = new Request(HttpPost.METHOD_NAME, "/_msearch").     Params params = new Params(request).     params.putParam(RestSearchAction.TYPED_KEYS_PARAM, "true").     if (multiSearchRequest.maxConcurrentSearchRequests() != MultiSearchRequest.MAX_CONCURRENT_SEARCH_REQUESTS_DEFAULT) {         params.putParam("max_concurrent_searches", Integer.toString(multiSearchRequest.maxConcurrentSearchRequests())).     }     XContent xContent = REQUEST_BODY_CONTENT_TYPE.xContent().     byte[] source = MultiSearchRequest.writeMultiLineFormat(multiSearchRequest, xContent).     request.setEntity(new NByteArrayEntity(source, createContentType(xContent.type()))).     return request. }
false;static;1;17;;static Request searchTemplate(SearchTemplateRequest searchTemplateRequest) throws IOException {     Request request.     if (searchTemplateRequest.isSimulate()) {         request = new Request(HttpGet.METHOD_NAME, "_render/template").     } else {         SearchRequest searchRequest = searchTemplateRequest.getRequest().         String endpoint = endpoint(searchRequest.indices(), searchRequest.types(), "_search/template").         request = new Request(HttpGet.METHOD_NAME, endpoint).         Params params = new Params(request).         addSearchRequestParams(params, searchRequest).     }     request.setEntity(createEntity(searchTemplateRequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;14;;static Request multiSearchTemplate(MultiSearchTemplateRequest multiSearchTemplateRequest) throws IOException {     Request request = new Request(HttpPost.METHOD_NAME, "/_msearch/template").     Params params = new Params(request).     params.putParam(RestSearchAction.TYPED_KEYS_PARAM, "true").     if (multiSearchTemplateRequest.maxConcurrentSearchRequests() != MultiSearchRequest.MAX_CONCURRENT_SEARCH_REQUESTS_DEFAULT) {         params.putParam("max_concurrent_searches", Integer.toString(multiSearchTemplateRequest.maxConcurrentSearchRequests())).     }     XContent xContent = REQUEST_BODY_CONTENT_TYPE.xContent().     byte[] source = MultiSearchTemplateRequest.writeMultiLineFormat(multiSearchTemplateRequest, xContent).     request.setEntity(new NByteArrayEntity(source, createContentType(xContent.type()))).     return request. }
false;static;1;9;;static Request count(CountRequest countRequest) throws IOException {     Request request = new Request(HttpPost.METHOD_NAME, endpoint(countRequest.indices(), countRequest.types(), "_count")).     Params params = new Params(request).     params.withRouting(countRequest.routing()).     params.withPreference(countRequest.preference()).     params.withIndicesOptions(countRequest.indicesOptions()).     request.setEntity(createEntity(countRequest.source(), REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;14;;static Request explain(ExplainRequest explainRequest) throws IOException {     String endpoint = explainRequest.type().equals(MapperService.SINGLE_MAPPING_NAME) ? endpoint(explainRequest.index(), "_explain", explainRequest.id()) : endpoint(explainRequest.index(), explainRequest.type(), explainRequest.id(), "_explain").     Request request = new Request(HttpGet.METHOD_NAME, endpoint).     Params params = new Params(request).     params.withStoredFields(explainRequest.storedFields()).     params.withFetchSourceContext(explainRequest.fetchSourceContext()).     params.withRouting(explainRequest.routing()).     params.withPreference(explainRequest.preference()).     request.setEntity(createEntity(explainRequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;8;;static Request fieldCaps(FieldCapabilitiesRequest fieldCapabilitiesRequest) {     Request request = new Request(HttpGet.METHOD_NAME, endpoint(fieldCapabilitiesRequest.indices(), "_field_caps")).     Params params = new Params(request).     params.withFields(fieldCapabilitiesRequest.fields()).     params.withIndicesOptions(fieldCapabilitiesRequest.indicesOptions()).     return request. }
false;static;1;9;;static Request rankEval(RankEvalRequest rankEvalRequest) throws IOException {     Request request = new Request(HttpGet.METHOD_NAME, endpoint(rankEvalRequest.indices(), Strings.EMPTY_ARRAY, "_rank_eval")).     Params params = new Params(request).     params.withIndicesOptions(rankEvalRequest.indicesOptions()).     request.setEntity(createEntity(rankEvalRequest.getRankEvalSpec(), REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;3;;static Request reindex(ReindexRequest reindexRequest) throws IOException {     return prepareReindexRequest(reindexRequest, true). }
false;static;1;3;;static Request submitReindex(ReindexRequest reindexRequest) throws IOException {     return prepareReindexRequest(reindexRequest, false). }
false;private,static;2;16;;private static Request prepareReindexRequest(ReindexRequest reindexRequest, boolean waitForCompletion) throws IOException {     String endpoint = new EndpointBuilder().addPathPart("_reindex").build().     Request request = new Request(HttpPost.METHOD_NAME, endpoint).     Params params = new Params(request).withWaitForCompletion(waitForCompletion).withRefresh(reindexRequest.isRefresh()).withTimeout(reindexRequest.getTimeout()).withWaitForActiveShards(reindexRequest.getWaitForActiveShards()).withRequestsPerSecond(reindexRequest.getRequestsPerSecond()).     if (reindexRequest.getScrollTime() != null) {         params.putParam("scroll", reindexRequest.getScrollTime()).     }     request.setEntity(createEntity(reindexRequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;27;;static Request updateByQuery(UpdateByQueryRequest updateByQueryRequest) throws IOException {     String endpoint = endpoint(updateByQueryRequest.indices(), updateByQueryRequest.getDocTypes(), "_update_by_query").     Request request = new Request(HttpPost.METHOD_NAME, endpoint).     Params params = new Params(request).withRouting(updateByQueryRequest.getRouting()).withPipeline(updateByQueryRequest.getPipeline()).withRefresh(updateByQueryRequest.isRefresh()).withTimeout(updateByQueryRequest.getTimeout()).withWaitForActiveShards(updateByQueryRequest.getWaitForActiveShards()).withRequestsPerSecond(updateByQueryRequest.getRequestsPerSecond()).withIndicesOptions(updateByQueryRequest.indicesOptions()).     if (updateByQueryRequest.isAbortOnVersionConflict() == false) {         params.putParam("conflicts", "proceed").     }     if (updateByQueryRequest.getBatchSize() != AbstractBulkByScrollRequest.DEFAULT_SCROLL_SIZE) {         params.putParam("scroll_size", Integer.toString(updateByQueryRequest.getBatchSize())).     }     if (updateByQueryRequest.getScrollTime() != AbstractBulkByScrollRequest.DEFAULT_SCROLL_TIMEOUT) {         params.putParam("scroll", updateByQueryRequest.getScrollTime()).     }     if (updateByQueryRequest.getSize() > 0) {         params.putParam("size", Integer.toString(updateByQueryRequest.getSize())).     }     request.setEntity(createEntity(updateByQueryRequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;26;;static Request deleteByQuery(DeleteByQueryRequest deleteByQueryRequest) throws IOException {     String endpoint = endpoint(deleteByQueryRequest.indices(), deleteByQueryRequest.getDocTypes(), "_delete_by_query").     Request request = new Request(HttpPost.METHOD_NAME, endpoint).     Params params = new Params(request).withRouting(deleteByQueryRequest.getRouting()).withRefresh(deleteByQueryRequest.isRefresh()).withTimeout(deleteByQueryRequest.getTimeout()).withWaitForActiveShards(deleteByQueryRequest.getWaitForActiveShards()).withRequestsPerSecond(deleteByQueryRequest.getRequestsPerSecond()).withIndicesOptions(deleteByQueryRequest.indicesOptions()).     if (deleteByQueryRequest.isAbortOnVersionConflict() == false) {         params.putParam("conflicts", "proceed").     }     if (deleteByQueryRequest.getBatchSize() != AbstractBulkByScrollRequest.DEFAULT_SCROLL_SIZE) {         params.putParam("scroll_size", Integer.toString(deleteByQueryRequest.getBatchSize())).     }     if (deleteByQueryRequest.getScrollTime() != AbstractBulkByScrollRequest.DEFAULT_SCROLL_TIMEOUT) {         params.putParam("scroll", deleteByQueryRequest.getScrollTime()).     }     if (deleteByQueryRequest.getSize() > 0) {         params.putParam("size", Integer.toString(deleteByQueryRequest.getSize())).     }     request.setEntity(createEntity(deleteByQueryRequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;3;;static Request rethrottleReindex(RethrottleRequest rethrottleRequest) {     return rethrottle(rethrottleRequest, "_reindex"). }
false;static;1;3;;static Request rethrottleUpdateByQuery(RethrottleRequest rethrottleRequest) {     return rethrottle(rethrottleRequest, "_update_by_query"). }
false;static;1;3;;static Request rethrottleDeleteByQuery(RethrottleRequest rethrottleRequest) {     return rethrottle(rethrottleRequest, "_delete_by_query"). }
false;private,static;2;10;;private static Request rethrottle(RethrottleRequest rethrottleRequest, String firstPathPart) {     String endpoint = new EndpointBuilder().addPathPart(firstPathPart).addPathPart(rethrottleRequest.getTaskId().toString()).addPathPart("_rethrottle").build().     Request request = new Request(HttpPost.METHOD_NAME, endpoint).     Params params = new Params(request).withRequestsPerSecond(rethrottleRequest.getRequestsPerSecond()).     // we set "group_by" to "none" because this is the response format we can parse back     params.putParam("group_by", "none").     return request. }
false;static;1;12;;static Request putScript(PutStoredScriptRequest putStoredScriptRequest) throws IOException {     String endpoint = new EndpointBuilder().addPathPartAsIs("_scripts").addPathPart(putStoredScriptRequest.id()).build().     Request request = new Request(HttpPost.METHOD_NAME, endpoint).     Params params = new Params(request).     params.withTimeout(putStoredScriptRequest.timeout()).     params.withMasterTimeout(putStoredScriptRequest.masterNodeTimeout()).     if (Strings.hasText(putStoredScriptRequest.context())) {         params.putParam("context", putStoredScriptRequest.context()).     }     request.setEntity(createEntity(putStoredScriptRequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;11;;static Request analyze(AnalyzeRequest request) throws IOException {     EndpointBuilder builder = new EndpointBuilder().     String index = request.index().     if (index != null) {         builder.addPathPart(index).     }     builder.addPathPartAsIs("_analyze").     Request req = new Request(HttpGet.METHOD_NAME, builder.build()).     req.setEntity(createEntity(request, REQUEST_BODY_CONTENT_TYPE)).     return req. }
false;static;1;22;;static Request termVectors(TermVectorsRequest tvrequest) throws IOException {     String endpoint.     if (tvrequest.getType() != null) {         endpoint = new EndpointBuilder().addPathPart(tvrequest.getIndex(), tvrequest.getType(), tvrequest.getId()).addPathPartAsIs("_termvectors").build().     } else {         endpoint = new EndpointBuilder().addPathPart(tvrequest.getIndex()).addPathPartAsIs("_termvectors").addPathPart(tvrequest.getId()).build().     }     Request request = new Request(HttpGet.METHOD_NAME, endpoint).     Params params = new Params(request).     params.withRouting(tvrequest.getRouting()).     params.withPreference(tvrequest.getPreference()).     params.withFields(tvrequest.getFields()).     params.withRealtime(tvrequest.getRealtime()).     request.setEntity(createEntity(tvrequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;6;;static Request mtermVectors(MultiTermVectorsRequest mtvrequest) throws IOException {     String endpoint = "_mtermvectors".     Request request = new Request(HttpGet.METHOD_NAME, endpoint).     request.setEntity(createEntity(mtvrequest, REQUEST_BODY_CONTENT_TYPE)).     return request. }
false;static;1;7;;static Request getScript(GetStoredScriptRequest getStoredScriptRequest) {     String endpoint = new EndpointBuilder().addPathPartAsIs("_scripts").addPathPart(getStoredScriptRequest.id()).build().     Request request = new Request(HttpGet.METHOD_NAME, endpoint).     Params params = new Params(request).     params.withMasterTimeout(getStoredScriptRequest.masterNodeTimeout()).     return request. }
false;static;1;8;;static Request deleteScript(DeleteStoredScriptRequest deleteStoredScriptRequest) {     String endpoint = new EndpointBuilder().addPathPartAsIs("_scripts").addPathPart(deleteStoredScriptRequest.id()).build().     Request request = new Request(HttpDelete.METHOD_NAME, endpoint).     Params params = new Params(request).     params.withTimeout(deleteStoredScriptRequest.timeout()).     params.withMasterTimeout(deleteStoredScriptRequest.masterNodeTimeout()).     return request. }
false;static;2;3;;static HttpEntity createEntity(ToXContent toXContent, XContentType xContentType) throws IOException {     return createEntity(toXContent, xContentType, ToXContent.EMPTY_PARAMS). }
false;static;3;5;;static HttpEntity createEntity(ToXContent toXContent, XContentType xContentType, ToXContent.Params toXContentParams) throws IOException {     BytesRef source = XContentHelper.toXContent(toXContent, xContentType, toXContentParams, false).toBytesRef().     return new NByteArrayEntity(source.bytes, source.offset, source.length, createContentType(xContentType)). }
false;static;3;3;;static String endpoint(String index, String type, String id) {     return new EndpointBuilder().addPathPart(index, type, id).build(). }
false;static;4;3;;static String endpoint(String index, String type, String id, String endpoint) {     return new EndpointBuilder().addPathPart(index, type, id).addPathPartAsIs(endpoint).build(). }
false;static;1;3;;static String endpoint(String[] indices) {     return new EndpointBuilder().addCommaSeparatedPathParts(indices).build(). }
false;static;2;3;;static String endpoint(String[] indices, String endpoint) {     return new EndpointBuilder().addCommaSeparatedPathParts(indices).addPathPartAsIs(endpoint).build(). }
false;static;3;4;;static String endpoint(String[] indices, String[] types, String endpoint) {     return new EndpointBuilder().addCommaSeparatedPathParts(indices).addCommaSeparatedPathParts(types).addPathPartAsIs(endpoint).build(). }
false;static;3;4;;static String endpoint(String[] indices, String endpoint, String[] suffixes) {     return new EndpointBuilder().addCommaSeparatedPathParts(indices).addPathPartAsIs(endpoint).addCommaSeparatedPathParts(suffixes).build(). }
false;static;3;3;;static String endpoint(String[] indices, String endpoint, String type) {     return new EndpointBuilder().addCommaSeparatedPathParts(indices).addPathPartAsIs(endpoint).addPathPart(type).build(). }
true;public,static;1;4;/**  * Returns a {@link ContentType} from a given {@link XContentType}.  *  * @param xContentType the {@link XContentType}  * @return the {@link ContentType}  */ ;/**  * Returns a {@link ContentType} from a given {@link XContentType}.  *  * @param xContentType the {@link XContentType}  * @return the {@link ContentType}  */ @SuppressForbidden(reason = "Only allowed place to convert a XContentType to a ContentType") public static ContentType createContentType(final XContentType xContentType) {     return ContentType.create(xContentType.mediaTypeWithoutParameters(), (Charset) null). }
false;;2;6;;Params putParam(String name, String value) {     if (Strings.hasLength(value)) {         request.addParameter(name, value).     }     return this. }
false;;2;6;;Params putParam(String key, TimeValue value) {     if (value != null) {         return putParam(key, value.getStringRep()).     }     return this. }
false;;1;6;;Params withDocAsUpsert(boolean docAsUpsert) {     if (docAsUpsert) {         return putParam("doc_as_upsert", Boolean.TRUE.toString()).     }     return this. }
false;;1;14;;Params withFetchSourceContext(FetchSourceContext fetchSourceContext) {     if (fetchSourceContext != null) {         if (fetchSourceContext.fetchSource() == false) {             putParam("_source", Boolean.FALSE.toString()).         }         if (fetchSourceContext.includes() != null && fetchSourceContext.includes().length > 0) {             putParam("_source_includes", String.join(",", fetchSourceContext.includes())).         }         if (fetchSourceContext.excludes() != null && fetchSourceContext.excludes().length > 0) {             putParam("_source_excludes", String.join(",", fetchSourceContext.excludes())).         }     }     return this. }
false;;1;6;;Params withFields(String[] fields) {     if (fields != null && fields.length > 0) {         return putParam("fields", String.join(",", fields)).     }     return this. }
false;;1;3;;Params withMasterTimeout(TimeValue masterTimeout) {     return putParam("master_timeout", masterTimeout). }
false;;1;3;;Params withPipeline(String pipeline) {     return putParam("pipeline", pipeline). }
false;;1;3;;Params withPreference(String preference) {     return putParam("preference", preference). }
false;;1;6;;Params withRealtime(boolean realtime) {     if (realtime == false) {         return putParam("realtime", Boolean.FALSE.toString()).     }     return this. }
false;;1;6;;Params withRefresh(boolean refresh) {     if (refresh) {         return withRefreshPolicy(RefreshPolicy.IMMEDIATE).     }     return this. }
true;;1;7;/**  *  @deprecated If creating a new HLRC ReST API call, use {@link RefreshPolicy}  *  instead of {@link WriteRequest.RefreshPolicy} from the server project  */ ;/**  *  @deprecated If creating a new HLRC ReST API call, use {@link RefreshPolicy}  *  instead of {@link WriteRequest.RefreshPolicy} from the server project  */ @Deprecated Params withRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy) {     if (refreshPolicy != WriteRequest.RefreshPolicy.NONE) {         return putParam("refresh", refreshPolicy.getValue()).     }     return this. }
false;;1;6;;Params withRefreshPolicy(RefreshPolicy refreshPolicy) {     if (refreshPolicy != RefreshPolicy.NONE) {         return putParam("refresh", refreshPolicy.getValue()).     }     return this. }
false;;1;9;;Params withRequestsPerSecond(float requestsPerSecond) {     // but we don't want to add that to the URL parameters, instead we use -1     if (Float.isFinite(requestsPerSecond)) {         return putParam(RethrottleRequest.REQUEST_PER_SECOND_PARAMETER, Float.toString(requestsPerSecond)).     } else {         return putParam(RethrottleRequest.REQUEST_PER_SECOND_PARAMETER, "-1").     } }
false;;1;6;;Params withRetryOnConflict(int retryOnConflict) {     if (retryOnConflict > 0) {         return putParam("retry_on_conflict", String.valueOf(retryOnConflict)).     }     return this. }
false;;1;3;;Params withRouting(String routing) {     return putParam("routing", routing). }
false;;1;6;;Params withStoredFields(String[] storedFields) {     if (storedFields != null && storedFields.length > 0) {         return putParam("stored_fields", String.join(",", storedFields)).     }     return this. }
false;;1;3;;Params withTimeout(TimeValue timeout) {     return putParam("timeout", timeout). }
false;;1;6;;Params withVersion(long version) {     if (version != Versions.MATCH_ANY) {         return putParam("version", Long.toString(version)).     }     return this. }
false;;1;6;;Params withVersionType(VersionType versionType) {     if (versionType != VersionType.INTERNAL) {         return putParam("version_type", versionType.name().toLowerCase(Locale.ROOT)).     }     return this. }
false;;1;6;;Params withIfSeqNo(long ifSeqNo) {     if (ifSeqNo != SequenceNumbers.UNASSIGNED_SEQ_NO) {         return putParam("if_seq_no", Long.toString(ifSeqNo)).     }     return this. }
false;;1;6;;Params withIfPrimaryTerm(long ifPrimaryTerm) {     if (ifPrimaryTerm != SequenceNumbers.UNASSIGNED_PRIMARY_TERM) {         return putParam("if_primary_term", Long.toString(ifPrimaryTerm)).     }     return this. }
false;;1;3;;Params withWaitForActiveShards(ActiveShardCount activeShardCount) {     return withWaitForActiveShards(activeShardCount, ActiveShardCount.DEFAULT). }
false;;2;6;;Params withWaitForActiveShards(ActiveShardCount activeShardCount, ActiveShardCount defaultActiveShardCount) {     if (activeShardCount != null && activeShardCount != defaultActiveShardCount) {         return putParam("wait_for_active_shards", activeShardCount.toString().toLowerCase(Locale.ROOT)).     }     return this. }
false;;1;21;;Params withIndicesOptions(IndicesOptions indicesOptions) {     if (indicesOptions != null) {         withIgnoreUnavailable(indicesOptions.ignoreUnavailable()).         putParam("allow_no_indices", Boolean.toString(indicesOptions.allowNoIndices())).         String expandWildcards.         if (indicesOptions.expandWildcardsOpen() == false && indicesOptions.expandWildcardsClosed() == false) {             expandWildcards = "none".         } else {             StringJoiner joiner = new StringJoiner(",").             if (indicesOptions.expandWildcardsOpen()) {                 joiner.add("open").             }             if (indicesOptions.expandWildcardsClosed()) {                 joiner.add("closed").             }             expandWildcards = joiner.toString().         }         putParam("expand_wildcards", expandWildcards).     }     return this. }
false;;1;5;;Params withIgnoreUnavailable(boolean ignoreUnavailable) {     // Always explicitly place the ignore_unavailable value.     putParam("ignore_unavailable", Boolean.toString(ignoreUnavailable)).     return this. }
false;;1;6;;Params withHuman(boolean human) {     if (human) {         putParam("human", Boolean.toString(human)).     }     return this. }
false;;1;6;;Params withLocal(boolean local) {     if (local) {         putParam("local", Boolean.toString(local)).     }     return this. }
false;;1;6;;Params withIncludeDefaults(boolean includeDefaults) {     if (includeDefaults) {         return putParam("include_defaults", Boolean.TRUE.toString()).     }     return this. }
false;;1;6;;Params withPreserveExisting(boolean preserveExisting) {     if (preserveExisting) {         return putParam("preserve_existing", Boolean.TRUE.toString()).     }     return this. }
false;;1;6;;Params withDetailed(boolean detailed) {     if (detailed) {         return putParam("detailed", Boolean.TRUE.toString()).     }     return this. }
false;;1;3;;Params withWaitForCompletion(Boolean waitForCompletion) {     return putParam("wait_for_completion", waitForCompletion.toString()). }
false;;1;6;;Params withNodes(String[] nodes) {     if (nodes != null && nodes.length > 0) {         return putParam("nodes", String.join(",", nodes)).     }     return this. }
false;;1;6;;Params withActions(String[] actions) {     if (actions != null && actions.length > 0) {         return putParam("actions", String.join(",", actions)).     }     return this. }
false;;1;6;;Params withTaskId(TaskId taskId) {     if (taskId != null && taskId.isSet()) {         return putParam("task_id", taskId.toString()).     }     return this. }
false;;1;6;;Params withParentTaskId(TaskId parentTaskId) {     if (parentTaskId != null && parentTaskId.isSet()) {         return putParam("parent_task_id", parentTaskId.toString()).     }     return this. }
false;;1;6;;Params withVerify(boolean verify) {     if (verify) {         return putParam("verify", Boolean.TRUE.toString()).     }     return this. }
false;;1;6;;Params withWaitForStatus(ClusterHealthStatus status) {     if (status != null) {         return putParam("wait_for_status", status.name().toLowerCase(Locale.ROOT)).     }     return this. }
false;;1;6;;Params withWaitForNoRelocatingShards(boolean waitNoRelocatingShards) {     if (waitNoRelocatingShards) {         return putParam("wait_for_no_relocating_shards", Boolean.TRUE.toString()).     }     return this. }
false;;1;6;;Params withWaitForNoInitializingShards(boolean waitNoInitShards) {     if (waitNoInitShards) {         return putParam("wait_for_no_initializing_shards", Boolean.TRUE.toString()).     }     return this. }
false;;1;3;;Params withWaitForNodes(String waitForNodes) {     return putParam("wait_for_nodes", waitForNodes). }
false;;1;3;;Params withLevel(ClusterHealthRequest.Level level) {     return putParam("level", level.name().toLowerCase(Locale.ROOT)). }
false;;1;6;;Params withWaitForEvents(Priority waitForEvents) {     if (waitForEvents != null) {         return putParam("wait_for_events", waitForEvents.name().toLowerCase(Locale.ROOT)).     }     return this. }
true;static;2;15;/**  * Ensure that the {@link IndexRequest}'s content type is supported by the Bulk API and that it conforms  * to the current {@link BulkRequest}'s content type (if it's known at the time of this method get called).  *  * @return the {@link IndexRequest}'s content type  */ ;/**  * Ensure that the {@link IndexRequest}'s content type is supported by the Bulk API and that it conforms  * to the current {@link BulkRequest}'s content type (if it's known at the time of this method get called).  *  * @return the {@link IndexRequest}'s content type  */ static XContentType enforceSameContentType(IndexRequest indexRequest, @Nullable XContentType xContentType) {     XContentType requestContentType = indexRequest.getContentType().     if (requestContentType != XContentType.JSON && requestContentType != XContentType.SMILE) {         throw new IllegalArgumentException("Unsupported content-type found for request with content-type [" + requestContentType + "], only JSON and SMILE are supported").     }     if (xContentType == null) {         return requestContentType.     }     if (requestContentType != xContentType) {         throw new IllegalArgumentException("Mismatching content-type found for request with content-type [" + requestContentType + "], previous requests have content-type [" + xContentType + "]").     }     return xContentType. }
false;;1;8;;EndpointBuilder addPathPart(String... parts) {     for (String part : parts) {         if (Strings.hasLength(part)) {             joiner.add(encodePart(part)).         }     }     return this. }
false;;1;4;;EndpointBuilder addCommaSeparatedPathParts(String[] parts) {     addPathPart(String.join(",", parts)).     return this. }
false;;1;4;;EndpointBuilder addCommaSeparatedPathParts(List<String> parts) {     addPathPart(String.join(",", parts)).     return this. }
false;;1;8;;EndpointBuilder addPathPartAsIs(String... parts) {     for (String part : parts) {         if (Strings.hasLength(part)) {             joiner.add(part).         }     }     return this. }
false;;0;3;;String build() {     return joiner.toString(). }
false;private,static;1;12;;private static String encodePart(String pathPart) {     try {         // encode each part (e.g. index, type and id) separately before merging them into the path         // we prepend "/" to the path part to make this path absolute, otherwise there can be issues with         // paths that start with `-` or contain `:`         URI uri = new URI(null, null, null, -1, "/" + pathPart, null, null).         // manually encode any slash that each part may contain         return uri.getRawPath().substring(1).replaceAll("/", "%2F").     } catch (URISyntaxException e) {         throw new IllegalArgumentException("Path part [" + pathPart + "] couldn't be encoded", e).     } }
