commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (indexPatterns == null || indexPatterns.size() == 0) {         validationException = addValidationError("index patterns are missing", validationException).     }     return validationException. }
true;public;1;7;/**  * Sets the name of the index template.  */ ;/**  * Sets the name of the index template.  */ public PutIndexTemplateRequest name(String name) {     if (name == null) {         throw new IllegalArgumentException("Name cannot be null").     }     this.name = name.     return this. }
true;public;0;3;/**  * The name of the index template.  */ ;/**  * The name of the index template.  */ public String name() {     return this.name. }
false;public;1;4;;public PutIndexTemplateRequest patterns(List<String> indexPatterns) {     this.indexPatterns = indexPatterns.     return this. }
false;public;0;3;;public List<String> patterns() {     return this.indexPatterns. }
false;public;1;4;;public PutIndexTemplateRequest order(int order) {     this.order = order.     return this. }
false;public;0;3;;public int order() {     return this.order. }
false;public;1;4;;public PutIndexTemplateRequest version(Integer version) {     this.version = version.     return this. }
false;public;0;3;;public Integer version() {     return this.version. }
true;public;1;4;/**  * Set to {@code true} to force only creation, not an update of an index template. If it already  * exists, it will fail with an {@link IllegalArgumentException}.  */ ;/**  * Set to {@code true} to force only creation, not an update of an index template. If it already  * exists, it will fail with an {@link IllegalArgumentException}.  */ public PutIndexTemplateRequest create(boolean create) {     this.create = create.     return this. }
false;public;0;3;;public boolean create() {     return create. }
true;public;1;4;/**  * The settings to create the index template with.  */ ;/**  * The settings to create the index template with.  */ public PutIndexTemplateRequest settings(Settings settings) {     this.settings = settings.     return this. }
true;public;1;4;/**  * The settings to create the index template with.  */ ;/**  * The settings to create the index template with.  */ public PutIndexTemplateRequest settings(Settings.Builder settings) {     this.settings = settings.build().     return this. }
true;public;2;4;/**  * The settings to create the index template with (either json/yaml format).  */ ;/**  * The settings to create the index template with (either json/yaml format).  */ public PutIndexTemplateRequest settings(String source, XContentType xContentType) {     this.settings = Settings.builder().loadFromSource(source, xContentType).build().     return this. }
true;public;1;10;/**  * The settings to create the index template with (either json or yaml format).  */ ;/**  * The settings to create the index template with (either json or yaml format).  */ public PutIndexTemplateRequest settings(Map<String, Object> source) {     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(source).         settings(Strings.toString(builder), XContentType.JSON).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     }     return this. }
false;public;0;3;;public Settings settings() {     return this.settings. }
true;public;2;4;/**  * Adds mapping that will be added when the index gets created.  *  * @param source The mapping source  * @param xContentType The type of content contained within the source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param source The mapping source  * @param xContentType The type of content contained within the source  */ public PutIndexTemplateRequest mapping(String source, XContentType xContentType) {     internalMapping(XContentHelper.convertToMap(new BytesArray(source), true, xContentType).v2()).     return this. }
true;public;1;4;/**  * The cause for this index template creation.  */ ;/**  * The cause for this index template creation.  */ public PutIndexTemplateRequest cause(String cause) {     this.cause = cause.     return this. }
false;public;0;3;;public String cause() {     return this.cause. }
true;public;1;5;/**  * Adds mapping that will be added when the index gets created.  *  * @param source The mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param source The mapping source  */ public PutIndexTemplateRequest mapping(XContentBuilder source) {     internalMapping(XContentHelper.convertToMap(BytesReference.bytes(source), true, source.contentType()).v2()).     return this. }
true;public;2;4;/**  * Adds mapping that will be added when the index gets created.  *  * @param source The mapping source  * @param xContentType the source content type  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param source The mapping source  * @param xContentType the source content type  */ public PutIndexTemplateRequest mapping(BytesReference source, XContentType xContentType) {     internalMapping(XContentHelper.convertToMap(source, true, xContentType).v2()).     return this. }
true;public;1;3;/**  * Adds mapping that will be added when the index gets created.  *  * @param source The mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param source The mapping source  */ public PutIndexTemplateRequest mapping(Map<String, Object> source) {     return internalMapping(source). }
false;private;1;16;;private PutIndexTemplateRequest internalMapping(Map<String, Object> source) {     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(source).         Objects.requireNonNull(builder.contentType()).         try {             mappings = new BytesArray(XContentHelper.convertToJson(BytesReference.bytes(builder), false, false, builder.contentType())).             return this.         } catch (IOException e) {             throw new UncheckedIOException("failed to convert source to json", e).         }     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     } }
false;public;0;3;;public BytesReference mappings() {     return this.mappings. }
true;public;1;7;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(XContentBuilder templateBuilder) {     try {         return source(BytesReference.bytes(templateBuilder), templateBuilder.contentType()).     } catch (Exception e) {         throw new IllegalArgumentException("Failed to build json for template request", e).     } }
true;public;1;41;/**  * The template source definition.  */ ;/**  * The template source definition.  */ @SuppressWarnings("unchecked") public PutIndexTemplateRequest source(Map<String, Object> templateSource) {     Map<String, Object> source = templateSource.     for (Map.Entry<String, Object> entry : source.entrySet()) {         String name = entry.getKey().         if (name.equals("template")) {             if (entry.getValue() instanceof String) {                 patterns(Collections.singletonList((String) entry.getValue())).             }         } else if (name.equals("index_patterns")) {             if (entry.getValue() instanceof String) {                 patterns(Collections.singletonList((String) entry.getValue())).             } else if (entry.getValue() instanceof List) {                 List<String> elements = ((List<?>) entry.getValue()).stream().map(Object::toString).collect(Collectors.toList()).                 patterns(elements).             } else {                 throw new IllegalArgumentException("Malformed [template] value, should be a string or a list of strings").             }         } else if (name.equals("order")) {             order(XContentMapValues.nodeIntegerValue(entry.getValue(), order())).         } else if ("version".equals(name)) {             if ((entry.getValue() instanceof Integer) == false) {                 throw new IllegalArgumentException("Malformed [version] value, should be an integer").             }             version((Integer) entry.getValue()).         } else if (name.equals("settings")) {             if ((entry.getValue() instanceof Map) == false) {                 throw new IllegalArgumentException("Malformed [settings] section, should include an inner object").             }             settings((Map<String, Object>) entry.getValue()).         } else if (name.equals("mappings")) {             Map<String, Object> mappings = (Map<String, Object>) entry.getValue().             mapping(mappings).         } else if (name.equals("aliases")) {             aliases((Map<String, Object>) entry.getValue()).         } else {             throw new ElasticsearchParseException("unknown key [{}] in the template ", name).         }     }     return this. }
true;public;2;3;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(String templateSource, XContentType xContentType) {     return source(XContentHelper.convertToMap(xContentType.xContent(), templateSource, true)). }
true;public;2;3;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(byte[] source, XContentType xContentType) {     return source(source, 0, source.length, xContentType). }
true;public;4;3;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(byte[] source, int offset, int length, XContentType xContentType) {     return source(new BytesArray(source, offset, length), xContentType). }
true;public;2;3;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(BytesReference source, XContentType xContentType) {     return source(XContentHelper.convertToMap(source, true, xContentType).v2()). }
false;public;0;3;;public Set<Alias> aliases() {     return this.aliases. }
true;public;1;9;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public PutIndexTemplateRequest aliases(Map<String, ?> source) {     try {         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.map(source).         return aliases(BytesReference.bytes(builder)).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     } }
true;public;1;3;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public PutIndexTemplateRequest aliases(XContentBuilder source) {     return aliases(BytesReference.bytes(source)). }
true;public;1;3;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public PutIndexTemplateRequest aliases(String source) {     return aliases(new BytesArray(source)). }
true;public;1;14;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public PutIndexTemplateRequest aliases(BytesReference source) {     // EMPTY is safe here because we never call namedObject     try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, source)) {         // move to the first alias         parser.nextToken().         while ((parser.nextToken()) != XContentParser.Token.END_OBJECT) {             alias(Alias.fromXContent(parser)).         }         return this.     } catch (IOException e) {         throw new ElasticsearchParseException("Failed to parse aliases", e).     } }
true;public;1;4;/**  * Adds an alias that will be added when the index gets created.  *  * @param alias   The metadata for the new alias  * @return  the index template creation request  */ ;/**  * Adds an alias that will be added when the index gets created.  *  * @param alias   The metadata for the new alias  * @return  the index template creation request  */ public PutIndexTemplateRequest alias(Alias alias) {     aliases.add(alias).     return this. }
false;public;0;4;;@Override public String[] indices() {     return indexPatterns.toArray(new String[indexPatterns.size()]). }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return IndicesOptions.strictExpand(). }
false;public;2;28;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("index_patterns", indexPatterns).     builder.field("order", order).     if (version != null) {         builder.field("version", version).     }     builder.startObject("settings").     settings.toXContent(builder, params).     builder.endObject().     if (mappings != null) {         builder.field("mappings").         try (XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, mappings.utf8ToString())) {             builder.copyCurrentStructure(parser).         }     }     builder.startObject("aliases").     for (Alias alias : aliases) {         alias.toXContent(builder, params).     }     builder.endObject().     return builder. }
