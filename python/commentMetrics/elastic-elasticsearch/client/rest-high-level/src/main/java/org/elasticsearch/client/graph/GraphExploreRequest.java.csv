commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Override public Optional<ValidationException> validate() {     ValidationException validationException = new ValidationException().     if (hops.size() == 0) {         validationException.addValidationError(NO_HOPS_ERROR_MESSAGE).     }     for (Hop hop : hops) {         hop.validate(validationException).     }     return validationException.validationErrors().isEmpty() ? Optional.empty() : Optional.of(validationException). }
false;public;0;4;;@Override public String[] indices() {     return this.indices. }
false;public;1;5;;@Override public GraphExploreRequest indices(String... indices) {     this.indices = indices.     return this. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return indicesOptions. }
false;public;1;7;;public GraphExploreRequest indicesOptions(IndicesOptions indicesOptions) {     if (indicesOptions == null) {         throw new IllegalArgumentException("IndicesOptions must not be null").     }     this.indicesOptions = indicesOptions.     return this. }
false;public;0;3;;public String[] types() {     return this.types. }
false;public;1;4;;public GraphExploreRequest types(String... types) {     this.types = types.     return this. }
false;public;0;3;;public String routing() {     return this.routing. }
false;public;1;4;;public GraphExploreRequest routing(String routing) {     this.routing = routing.     return this. }
false;public;1;4;;public GraphExploreRequest routing(String... routings) {     this.routing = Strings.arrayToCommaDelimitedString(routings).     return this. }
false;public;0;3;;public TimeValue timeout() {     return timeout. }
true;public;1;7;/**  * Graph exploration can be set to timeout after the given period. Search  * operations involved in each hop are limited to the remaining time  * available but can still overrun due to the nature of their "best efforts"  * timeout support. When a timeout occurs partial results are returned.  *  * @param timeout  *            a {@link TimeValue} object which determines the maximum length  *            of time to spend exploring  */ ;/**  * Graph exploration can be set to timeout after the given period. Search  * operations involved in each hop are limited to the remaining time  * available but can still overrun due to the nature of their "best efforts"  * timeout support. When a timeout occurs partial results are returned.  *  * @param timeout  *            a {@link TimeValue} object which determines the maximum length  *            of time to spend exploring  */ public GraphExploreRequest timeout(TimeValue timeout) {     if (timeout == null) {         throw new IllegalArgumentException("timeout must not be null").     }     this.timeout = timeout.     return this. }
false;public;1;4;;public GraphExploreRequest timeout(String timeout) {     timeout(TimeValue.parseTimeValue(timeout, null, getClass().getSimpleName() + ".timeout")).     return this. }
false;public;0;4;;@Override public String toString() {     return "graph explore [" + Arrays.toString(indices) + "][" + Arrays.toString(types) + "]". }
true;public;1;3;/**  * The number of top-matching documents that are considered during each hop  * (default is {@link SamplerAggregationBuilder#DEFAULT_SHARD_SAMPLE_SIZE}  * Very small values (less than 50) may not provide sufficient  * weight-of-evidence to identify significant connections between terms.  * <p>  * Very large values (many thousands) are not recommended with loosely  * defined queries (fuzzy queries or those with many OR clauses). This is  * because any useful signals in the best documents are diluted with  * irrelevant noise from low-quality matches. Performance is also typically  * better with smaller samples as there are less look-ups required for  * background frequencies of terms found in the documents  * </p>  *  * @param maxNumberOfDocsPerHop  *            shard-level sample size in documents  */ ;/**  * The number of top-matching documents that are considered during each hop  * (default is {@link SamplerAggregationBuilder#DEFAULT_SHARD_SAMPLE_SIZE}  * Very small values (less than 50) may not provide sufficient  * weight-of-evidence to identify significant connections between terms.  * <p>  * Very large values (many thousands) are not recommended with loosely  * defined queries (fuzzy queries or those with many OR clauses). This is  * because any useful signals in the best documents are diluted with  * irrelevant noise from low-quality matches. Performance is also typically  * better with smaller samples as there are less look-ups required for  * background frequencies of terms found in the documents  * </p>  *  * @param maxNumberOfDocsPerHop  *            shard-level sample size in documents  */ public void sampleSize(int maxNumberOfDocsPerHop) {     sampleSize = maxNumberOfDocsPerHop. }
false;public;0;3;;public int sampleSize() {     return sampleSize. }
true;public;1;3;/**  * Optional choice of single-value field on which to diversify sampled  * search results  */ ;/**  * Optional choice of single-value field on which to diversify sampled  * search results  */ public void sampleDiversityField(String name) {     sampleDiversityField = name. }
false;public;0;3;;public String sampleDiversityField() {     return sampleDiversityField. }
true;public;1;3;/**  * Optional number of permitted docs with same value in sampled search  * results. Must also declare which field using sampleDiversityField  */ ;/**  * Optional number of permitted docs with same value in sampled search  * results. Must also declare which field using sampleDiversityField  */ public void maxDocsPerDiversityValue(int maxDocs) {     this.maxDocsPerDiversityValue = maxDocs. }
false;public;0;3;;public int maxDocsPerDiversityValue() {     return maxDocsPerDiversityValue. }
true;public;1;3;/**  * Controls the choice of algorithm used to select interesting terms. The  * default value is true which means terms are selected based on  * significance (see the {@link SignificantTerms} aggregation) rather than  * popularity (using the {@link TermsAggregator}).  *  * @param value  *            true if the significant_terms algorithm should be used.  */ ;/**  * Controls the choice of algorithm used to select interesting terms. The  * default value is true which means terms are selected based on  * significance (see the {@link SignificantTerms} aggregation) rather than  * popularity (using the {@link TermsAggregator}).  *  * @param value  *            true if the significant_terms algorithm should be used.  */ public void useSignificance(boolean value) {     this.useSignificance = value. }
false;public;0;3;;public boolean useSignificance() {     return useSignificance. }
true;public;1;3;/**  * Return detailed information about vertex frequencies as part of JSON  * results - defaults to false  *  * @param value  *            true if detailed information is required in JSON responses  */ ;/**  * Return detailed information about vertex frequencies as part of JSON  * results - defaults to false  *  * @param value  *            true if detailed information is required in JSON responses  */ public void returnDetailedInfo(boolean value) {     this.returnDetailedInfo = value. }
false;public;0;3;;public boolean returnDetailedInfo() {     return returnDetailedInfo. }
true;public;1;10;/**  * Add a stage in the graph exploration. Each hop represents a stage of  * querying elasticsearch to identify terms which can then be connnected to  * other terms in a subsequent hop.  *  * @param guidingQuery  *            optional choice of query which influences which documents are  *            considered in this stage  * @return a {@link Hop} object that holds settings for a stage in the graph  *         exploration  */ ;/**  * Add a stage in the graph exploration. Each hop represents a stage of  * querying elasticsearch to identify terms which can then be connnected to  * other terms in a subsequent hop.  *  * @param guidingQuery  *            optional choice of query which influences which documents are  *            considered in this stage  * @return a {@link Hop} object that holds settings for a stage in the graph  *         exploration  */ public Hop createNextHop(QueryBuilder guidingQuery) {     Hop parent = null.     if (hops.size() > 0) {         parent = hops.get(hops.size() - 1).     }     Hop newHop = new Hop(parent).     newHop.guidingQuery = guidingQuery.     hops.add(newHop).     return newHop. }
false;public;0;3;;public int getHopNumbers() {     return hops.size(). }
false;public;1;3;;public Hop getHop(int hopNumber) {     return hops.get(hopNumber). }
false;public;0;3;;public String getTerm() {     return term. }
false;public;0;3;;public float getBoost() {     return boost. }
false;;1;4;;void readFrom(StreamInput in) throws IOException {     this.term = in.readString().     this.boost = in.readFloat(). }
false;;1;4;;void writeTo(StreamOutput out) throws IOException {     out.writeString(term).     out.writeFloat(boost). }
false;public;2;37;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startObject("controls").     {         if (sampleSize != SamplerAggregationBuilder.DEFAULT_SHARD_SAMPLE_SIZE) {             builder.field("sample_size", sampleSize).         }         if (sampleDiversityField != null) {             builder.startObject("sample_diversity").             builder.field("field", sampleDiversityField).             builder.field("max_docs_per_value", maxDocsPerDiversityValue).             builder.endObject().         }         builder.field("use_significance", useSignificance).         if (returnDetailedInfo) {             builder.field("return_detailed_stats", returnDetailedInfo).         }     }     builder.endObject().     for (Hop hop : hops) {         if (hop.parentHop != null) {             builder.startObject("connections").         }         hop.toXContent(builder, params).     }     for (Hop hop : hops) {         if (hop.parentHop != null) {             builder.endObject().         }     }     builder.endObject().     return builder. }
