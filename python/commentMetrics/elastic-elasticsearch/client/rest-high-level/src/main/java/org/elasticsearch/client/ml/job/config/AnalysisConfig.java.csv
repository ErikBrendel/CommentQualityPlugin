commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The analysis bucket span  *  * @return The bucketspan or <code>null</code> if not set  */ ;/**  * The analysis bucket span  *  * @return The bucketspan or <code>null</code> if not set  */ public TimeValue getBucketSpan() {     return bucketSpan. }
false;public;0;3;;public String getCategorizationFieldName() {     return categorizationFieldName. }
false;public;0;3;;public List<String> getCategorizationFilters() {     return categorizationFilters. }
false;public;0;3;;public CategorizationAnalyzerConfig getCategorizationAnalyzerConfig() {     return categorizationAnalyzerConfig. }
true;public;0;3;/**  * The latency interval during which out-of-order records should be handled.  *  * @return The latency interval or <code>null</code> if not set  */ ;/**  * The latency interval during which out-of-order records should be handled.  *  * @return The latency interval or <code>null</code> if not set  */ public TimeValue getLatency() {     return latency. }
true;public;0;3;/**  * The name of the field that contains counts for pre-summarised input  *  * @return The field name or <code>null</code> if not set  */ ;/**  * The name of the field that contains counts for pre-summarised input  *  * @return The field name or <code>null</code> if not set  */ public String getSummaryCountFieldName() {     return summaryCountFieldName. }
true;public;0;3;/**  * The list of analysis detectors. In a valid configuration the list should  * contain at least 1 {@link Detector}  *  * @return The Detectors used in this job  */ ;/**  * The list of analysis detectors. In a valid configuration the list should  * contain at least 1 {@link Detector}  *  * @return The Detectors used in this job  */ public List<Detector> getDetectors() {     return detectors. }
true;public;0;3;/**  * The list of influence field names  */ ;/**  * The list of influence field names  */ public List<String> getInfluencers() {     return influencers. }
false;public;0;3;;public Boolean getMultivariateByFields() {     return multivariateByFields. }
false;private,static;2;5;;private static void addIfNotNull(Set<String> fields, String field) {     if (field != null) {         fields.add(field).     } }
false;public;0;3;;public List<String> fields() {     return collectNonNullAndNonEmptyDetectorFields(Detector::getFieldName). }
false;private;1;13;;private List<String> collectNonNullAndNonEmptyDetectorFields(Function<Detector, String> fieldGetter) {     Set<String> fields = new HashSet<>().     for (Detector d : getDetectors()) {         addIfNotNull(fields, fieldGetter.apply(d)).     }     // remove empty strings     fields.remove("").     return new ArrayList<>(fields). }
false;public;0;3;;public List<String> byFields() {     return collectNonNullAndNonEmptyDetectorFields(Detector::getByFieldName). }
false;public;0;3;;public List<String> overFields() {     return collectNonNullAndNonEmptyDetectorFields(Detector::getOverFieldName). }
false;public;0;3;;public List<String> partitionFields() {     return collectNonNullAndNonEmptyDetectorFields(Detector::getPartitionFieldName). }
false;public;2;36;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (bucketSpan != null) {         builder.field(BUCKET_SPAN.getPreferredName(), bucketSpan.getStringRep()).     }     if (categorizationFieldName != null) {         builder.field(CATEGORIZATION_FIELD_NAME.getPreferredName(), categorizationFieldName).     }     if (categorizationFilters != null) {         builder.field(CATEGORIZATION_FILTERS.getPreferredName(), categorizationFilters).     }     if (categorizationAnalyzerConfig != null) {         // This cannot be builder.field(CATEGORIZATION_ANALYZER.getPreferredName(), categorizationAnalyzerConfig, params).         // because that always writes categorizationAnalyzerConfig as an object, and in the case of a global analyzer it         // gets written as a single string.         categorizationAnalyzerConfig.toXContent(builder, params).     }     if (latency != null) {         builder.field(LATENCY.getPreferredName(), latency.getStringRep()).     }     if (summaryCountFieldName != null) {         builder.field(SUMMARY_COUNT_FIELD_NAME.getPreferredName(), summaryCountFieldName).     }     builder.startArray(DETECTORS.getPreferredName()).     for (Detector detector : detectors) {         detector.toXContent(builder, params).     }     builder.endArray().     builder.field(INFLUENCERS.getPreferredName(), influencers).     if (multivariateByFields != null) {         builder.field(MULTIVARIATE_BY_FIELDS.getPreferredName(), multivariateByFields).     }     builder.endObject().     return builder. }
false;public;1;21;;@Override public boolean equals(Object object) {     if (this == object) {         return true.     }     if (object == null || getClass() != object.getClass()) {         return false.     }     AnalysisConfig that = (AnalysisConfig) object.     return Objects.equals(latency, that.latency) && Objects.equals(bucketSpan, that.bucketSpan) && Objects.equals(categorizationFieldName, that.categorizationFieldName) && Objects.equals(categorizationFilters, that.categorizationFilters) && Objects.equals(categorizationAnalyzerConfig, that.categorizationAnalyzerConfig) && Objects.equals(summaryCountFieldName, that.summaryCountFieldName) && Objects.equals(detectors, that.detectors) && Objects.equals(influencers, that.influencers) && Objects.equals(multivariateByFields, that.multivariateByFields). }
false;public;0;6;;@Override public int hashCode() {     return Objects.hash(bucketSpan, categorizationFieldName, categorizationFilters, categorizationAnalyzerConfig, latency, summaryCountFieldName, detectors, influencers, multivariateByFields). }
false;public,static;1;3;;public static Builder builder(List<Detector> detectors) {     return new Builder(detectors). }
false;public;1;13;;public Builder setDetectors(List<Detector> detectors) {     Objects.requireNonNull(detectors, "[" + DETECTORS.getPreferredName() + "] must not be null").     // We always assign sequential IDs to the detectors that are correct for this analysis config     int detectorIndex = 0.     List<Detector> sequentialIndexDetectors = new ArrayList<>(detectors.size()).     for (Detector origDetector : detectors) {         Detector.Builder builder = new Detector.Builder(origDetector).         builder.setDetectorIndex(detectorIndex++).         sequentialIndexDetectors.add(builder.build()).     }     this.detectors = sequentialIndexDetectors.     return this. }
false;public;2;4;;public Builder setDetector(int detectorIndex, Detector detector) {     detectors.set(detectorIndex, detector).     return this. }
false;public;1;4;;public Builder setBucketSpan(TimeValue bucketSpan) {     this.bucketSpan = bucketSpan.     return this. }
false;public;1;4;;public Builder setLatency(TimeValue latency) {     this.latency = latency.     return this. }
false;public;1;4;;public Builder setCategorizationFieldName(String categorizationFieldName) {     this.categorizationFieldName = categorizationFieldName.     return this. }
false;public;1;4;;public Builder setCategorizationFilters(List<String> categorizationFilters) {     this.categorizationFilters = categorizationFilters.     return this. }
false;public;1;4;;public Builder setCategorizationAnalyzerConfig(CategorizationAnalyzerConfig categorizationAnalyzerConfig) {     this.categorizationAnalyzerConfig = categorizationAnalyzerConfig.     return this. }
false;public;1;4;;public Builder setSummaryCountFieldName(String summaryCountFieldName) {     this.summaryCountFieldName = summaryCountFieldName.     return this. }
false;public;1;4;;public Builder setInfluencers(List<String> influencers) {     this.influencers = Objects.requireNonNull(influencers, INFLUENCERS.getPreferredName()).     return this. }
false;public;1;4;;public Builder setMultivariateByFields(Boolean multivariateByFields) {     this.multivariateByFields = multivariateByFields.     return this. }
false;public;0;5;;public AnalysisConfig build() {     return new AnalysisConfig(bucketSpan, categorizationFieldName, categorizationFilters, categorizationAnalyzerConfig, latency, summaryCountFieldName, detectors, influencers, multivariateByFields). }
