commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String[] getIndices() {     return indices. }
false;public;0;3;;public Map<String, MappingMetaData> getMappings() {     return mappings. }
false;public;0;3;;public Map<String, List<AliasMetaData>> getAliases() {     return aliases. }
true;public;0;3;/**  * If the originating {@link GetIndexRequest} object was configured to include  * defaults, this will contain a mapping of index name to {@link Settings} objects.  * The returned {@link Settings} objects will contain only those settings taking  * effect as defaults.  Any settings explicitly set on the index will be available  * via {@link #getSettings()}.  * See also {@link GetIndexRequest#includeDefaults(boolean)}  */ ;/**  * If the originating {@link GetIndexRequest} object was configured to include  * defaults, this will contain a mapping of index name to {@link Settings} objects.  * The returned {@link Settings} objects will contain only those settings taking  * effect as defaults.  Any settings explicitly set on the index will be available  * via {@link #getSettings()}.  * See also {@link GetIndexRequest#includeDefaults(boolean)}  */ public Map<String, Settings> getDefaultSettings() {     return defaultSettings. }
false;public;0;3;;public Map<String, Settings> getSettings() {     return settings. }
true;public;2;17;/**  * Returns the string value for the specified index and setting. If the includeDefaults flag was not set or set to  * false on the {@link GetIndexRequest}, this method will only return a value where the setting was explicitly set  * on the index.  If the includeDefaults flag was set to true on the {@link GetIndexRequest}, this method will fall  * back to return the default value if the setting was not explicitly set.  */ ;/**  * Returns the string value for the specified index and setting. If the includeDefaults flag was not set or set to  * false on the {@link GetIndexRequest}, this method will only return a value where the setting was explicitly set  * on the index.  If the includeDefaults flag was set to true on the {@link GetIndexRequest}, this method will fall  * back to return the default value if the setting was not explicitly set.  */ public String getSetting(String index, String setting) {     Settings indexSettings = settings.get(index).     if (setting != null) {         if (indexSettings != null && indexSettings.hasValue(setting)) {             return indexSettings.get(setting).         } else {             Settings defaultIndexSettings = defaultSettings.get(index).             if (defaultIndexSettings != null) {                 return defaultIndexSettings.get(setting).             } else {                 return null.             }         }     } else {         return null.     } }
false;private,static;1;9;;private static List<AliasMetaData> parseAliases(XContentParser parser) throws IOException {     List<AliasMetaData> indexAliases = new ArrayList<>().     // We start at START_OBJECT since parseIndexEntry ensures that     while (parser.nextToken() != Token.END_OBJECT) {         ensureExpectedToken(Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation).         indexAliases.add(AliasMetaData.Builder.fromXContent(parser)).     }     return indexAliases. }
false;private,static;1;3;;private static MappingMetaData parseMappings(XContentParser parser) throws IOException {     return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, parser.map()). }
false;private,static;1;32;;private static IndexEntry parseIndexEntry(XContentParser parser) throws IOException {     List<AliasMetaData> indexAliases = null.     MappingMetaData indexMappings = null.     Settings indexSettings = null.     Settings indexDefaultSettings = null.     // We start at START_OBJECT since fromXContent ensures that     while (parser.nextToken() != Token.END_OBJECT) {         ensureExpectedToken(Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation).         parser.nextToken().         if (parser.currentToken() == Token.START_OBJECT) {             switch(parser.currentName()) {                 case "aliases":                     indexAliases = parseAliases(parser).                     break.                 case "mappings":                     indexMappings = parseMappings(parser).                     break.                 case "settings":                     indexSettings = Settings.fromXContent(parser).                     break.                 case "defaults":                     indexDefaultSettings = Settings.fromXContent(parser).                     break.                 default:                     parser.skipChildren().             }         } else if (parser.currentToken() == Token.START_ARRAY) {             parser.skipChildren().         }     }     return new IndexEntry(indexAliases, indexMappings, indexSettings, indexDefaultSettings). }
false;public,static;1;35;;public static GetIndexResponse fromXContent(XContentParser parser) throws IOException {     Map<String, List<AliasMetaData>> aliases = new HashMap<>().     Map<String, MappingMetaData> mappings = new HashMap<>().     Map<String, Settings> settings = new HashMap<>().     Map<String, Settings> defaultSettings = new HashMap<>().     List<String> indices = new ArrayList<>().     if (parser.currentToken() == null) {         parser.nextToken().     }     ensureExpectedToken(Token.START_OBJECT, parser.currentToken(), parser::getTokenLocation).     parser.nextToken().     while (!parser.isClosed()) {         if (parser.currentToken() == Token.START_OBJECT) {             // we assume this is an index entry             String indexName = parser.currentName().             indices.add(indexName).             IndexEntry indexEntry = parseIndexEntry(parser).             // make the order deterministic             CollectionUtil.timSort(indexEntry.indexAliases, Comparator.comparing(AliasMetaData::alias)).             aliases.put(indexName, Collections.unmodifiableList(indexEntry.indexAliases)).             mappings.put(indexName, indexEntry.indexMappings).             settings.put(indexName, indexEntry.indexSettings).             if (indexEntry.indexDefaultSettings.isEmpty() == false) {                 defaultSettings.put(indexName, indexEntry.indexDefaultSettings).             }         } else if (parser.currentToken() == Token.START_ARRAY) {             parser.skipChildren().         } else {             parser.nextToken().         }     }     return new GetIndexResponse(indices.toArray(new String[0]), mappings, aliases, settings, defaultSettings). }
