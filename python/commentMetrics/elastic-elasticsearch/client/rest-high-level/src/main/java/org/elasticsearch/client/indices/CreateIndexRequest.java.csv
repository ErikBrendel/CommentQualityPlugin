commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The name of the index to create.  */ ;/**  * The name of the index to create.  */ public String index() {     return index. }
true;public;0;3;/**  * The settings to create the index with.  */ ;/**  * The settings to create the index with.  */ public Settings settings() {     return settings. }
true;public;1;4;/**  * The settings to create the index with.  */ ;/**  * The settings to create the index with.  */ public CreateIndexRequest settings(Settings.Builder settings) {     this.settings = settings.build().     return this. }
true;public;1;4;/**  * The settings to create the index with.  */ ;/**  * The settings to create the index with.  */ public CreateIndexRequest settings(Settings settings) {     this.settings = settings.     return this. }
true;public;2;4;/**  * The settings to create the index with (either json or yaml format)  */ ;/**  * The settings to create the index with (either json or yaml format)  */ public CreateIndexRequest settings(String source, XContentType xContentType) {     this.settings = Settings.builder().loadFromSource(source, xContentType).build().     return this. }
true;public;1;4;/**  * Allows to set the settings using a json builder.  */ ;/**  * Allows to set the settings using a json builder.  */ public CreateIndexRequest settings(XContentBuilder builder) {     settings(Strings.toString(builder), builder.contentType()).     return this. }
true;public;1;10;/**  * The settings to create the index with (either json/yaml/properties format)  */ ;/**  * The settings to create the index with (either json/yaml/properties format)  */ public CreateIndexRequest settings(Map<String, ?> source) {     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(source).         settings(Strings.toString(builder), XContentType.JSON).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     }     return this. }
false;public;0;3;;public BytesReference mappings() {     return mappings. }
false;public;0;3;;public XContentType mappingsXContentType() {     return mappingsXContentType. }
true;public;2;3;/**  * Adds mapping that will be added when the index gets created.  *  * Note that the definition should *not* be nested under a type name.  *  * @param source The mapping source  * @param xContentType The content type of the source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * Note that the definition should *not* be nested under a type name.  *  * @param source The mapping source  * @param xContentType The content type of the source  */ public CreateIndexRequest mapping(String source, XContentType xContentType) {     return mapping(new BytesArray(source), xContentType). }
true;public;1;3;/**  * Adds mapping that will be added when the index gets created.  *  * Note that the definition should *not* be nested under a type name.  *  * @param source The mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * Note that the definition should *not* be nested under a type name.  *  * @param source The mapping source  */ public CreateIndexRequest mapping(XContentBuilder source) {     return mapping(BytesReference.bytes(source), source.contentType()). }
true;public;1;9;/**  * Adds mapping that will be added when the index gets created.  *  * Note that the definition should *not* be nested under a type name.  *  * @param source The mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * Note that the definition should *not* be nested under a type name.  *  * @param source The mapping source  */ public CreateIndexRequest mapping(Map<String, ?> source) {     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(source).         return mapping(BytesReference.bytes(builder), builder.contentType()).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     } }
true;public;2;6;/**  * Adds mapping that will be added when the index gets created.  *  * Note that the definition should *not* be nested under a type name.  *  * @param source The mapping source  * @param xContentType the content type of the mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * Note that the definition should *not* be nested under a type name.  *  * @param source The mapping source  * @param xContentType the content type of the mapping source  */ public CreateIndexRequest mapping(BytesReference source, XContentType xContentType) {     Objects.requireNonNull(xContentType).     mappings = source.     mappingsXContentType = xContentType.     return this. }
false;public;0;3;;public Set<Alias> aliases() {     return this.aliases. }
true;public;1;9;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public CreateIndexRequest aliases(Map<String, ?> source) {     try {         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.map(source).         return aliases(BytesReference.bytes(builder), builder.contentType()).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     } }
true;public;1;3;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public CreateIndexRequest aliases(XContentBuilder source) {     return aliases(BytesReference.bytes(source), source.contentType()). }
true;public;2;3;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public CreateIndexRequest aliases(String source, XContentType contentType) {     return aliases(new BytesArray(source), contentType). }
true;public;2;14;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public CreateIndexRequest aliases(BytesReference source, XContentType contentType) {     // EMPTY is safe here because we never call namedObject     try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, source, contentType)) {         // move to the first alias         parser.nextToken().         while ((parser.nextToken()) != XContentParser.Token.END_OBJECT) {             alias(Alias.fromXContent(parser)).         }         return this.     } catch (IOException e) {         throw new ElasticsearchParseException("Failed to parse aliases", e).     } }
true;public;1;4;/**  * Adds an alias that will be associated with the index when it gets created  */ ;/**  * Adds an alias that will be associated with the index when it gets created  */ public CreateIndexRequest alias(Alias alias) {     this.aliases.add(alias).     return this. }
true;public;1;4;/**  * Adds aliases that will be associated with the index when it gets created  */ ;/**  * Adds aliases that will be associated with the index when it gets created  */ public CreateIndexRequest aliases(Collection<Alias> aliases) {     this.aliases.addAll(aliases).     return this. }
true;public;2;3;/**  * Sets the settings and mappings as a single source.  *  * Note that the mapping definition should *not* be nested under a type name.  */ ;/**  * Sets the settings and mappings as a single source.  *  * Note that the mapping definition should *not* be nested under a type name.  */ public CreateIndexRequest source(String source, XContentType xContentType) {     return source(new BytesArray(source), xContentType). }
true;public;1;3;/**  * Sets the settings and mappings as a single source.  *  * Note that the mapping definition should *not* be nested under a type name.  */ ;/**  * Sets the settings and mappings as a single source.  *  * Note that the mapping definition should *not* be nested under a type name.  */ public CreateIndexRequest source(XContentBuilder source) {     return source(BytesReference.bytes(source), source.contentType()). }
true;public;2;5;/**  * Sets the settings and mappings as a single source.  *  * Note that the mapping definition should *not* be nested under a type name.  */ ;/**  * Sets the settings and mappings as a single source.  *  * Note that the mapping definition should *not* be nested under a type name.  */ public CreateIndexRequest source(BytesReference source, XContentType xContentType) {     Objects.requireNonNull(xContentType).     source(XContentHelper.convertToMap(source, false, xContentType).v2()).     return this. }
true;public;1;15;/**  * Sets the settings and mappings as a single source.  *  * Note that the mapping definition should *not* be nested under a type name.  */ ;/**  * Sets the settings and mappings as a single source.  *  * Note that the mapping definition should *not* be nested under a type name.  */ @SuppressWarnings("unchecked") public CreateIndexRequest source(Map<String, ?> source) {     DeprecationHandler deprecationHandler = DeprecationHandler.THROW_UNSUPPORTED_OPERATION.     for (Map.Entry<String, ?> entry : source.entrySet()) {         String name = entry.getKey().         if (SETTINGS.match(name, deprecationHandler)) {             settings((Map<String, Object>) entry.getValue()).         } else if (MAPPINGS.match(name, deprecationHandler)) {             mapping((Map<String, Object>) entry.getValue()).         } else if (ALIASES.match(name, deprecationHandler)) {             aliases((Map<String, Object>) entry.getValue()).         }     }     return this. }
false;public;0;3;;public ActiveShardCount waitForActiveShards() {     return waitForActiveShards. }
true;public;1;4;/**  * Sets the number of shard copies that should be active for index creation to return.  * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy  * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to  * wait for all shards (primary and all replicas) to be active before returning.  * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Index creation will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link CreateIndexResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ ;/**  * Sets the number of shard copies that should be active for index creation to return.  * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy  * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to  * wait for all shards (primary and all replicas) to be active before returning.  * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Index creation will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link CreateIndexResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ public CreateIndexRequest waitForActiveShards(ActiveShardCount waitForActiveShards) {     this.waitForActiveShards = waitForActiveShards.     return this. }
false;public;2;6;;public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     innerToXContent(builder, params).     builder.endObject().     return builder. }
false;public;2;18;;public XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(SETTINGS.getPreferredName()).     settings.toXContent(builder, params).     builder.endObject().     if (mappings != null) {         try (InputStream stream = mappings.streamInput()) {             builder.rawField(MAPPINGS.getPreferredName(), stream, mappingsXContentType).         }     }     builder.startObject(ALIASES.getPreferredName()).     for (Alias alias : aliases) {         alias.toXContent(builder, params).     }     builder.endObject().     return builder. }
