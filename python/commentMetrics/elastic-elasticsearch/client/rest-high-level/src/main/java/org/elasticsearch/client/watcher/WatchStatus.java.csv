commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public State state() {     return state. }
false;public;0;3;;public boolean checked() {     return lastChecked != null. }
false;public;0;3;;public ZonedDateTime lastChecked() {     return lastChecked. }
false;public;0;3;;public ZonedDateTime lastMetCondition() {     return lastMetCondition. }
false;public;1;3;;public ActionStatus actionStatus(String actionId) {     return actions.get(actionId). }
false;public;0;3;;public Map<String, ActionStatus> getActions() {     return actions. }
false;public;0;3;;public long version() {     return version. }
false;public;0;3;;public ExecutionState getExecutionState() {     return executionState. }
false;public;0;3;;public Map<String, String> getHeaders() {     return headers. }
false;public;1;14;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     WatchStatus that = (WatchStatus) o.     return Objects.equals(lastChecked, that.lastChecked) && Objects.equals(lastMetCondition, that.lastMetCondition) && Objects.equals(version, that.version) && Objects.equals(executionState, that.executionState) && Objects.equals(actions, that.actions) && Objects.equals(headers, that.headers). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(lastChecked, lastMetCondition, actions, version, executionState). }
false;public,static;1;79;;public static WatchStatus parse(XContentParser parser) throws IOException {     State state = null.     ExecutionState executionState = null.     ZonedDateTime lastChecked = null.     ZonedDateTime lastMetCondition = null.     Map<String, ActionStatus> actions = null.     Map<String, String> headers = Collections.emptyMap().     long version = -1.     ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.currentToken(), parser::getTokenLocation).     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.STATE.match(currentFieldName, parser.getDeprecationHandler())) {             try {                 state = State.parse(parser).             } catch (ElasticsearchParseException e) {                 throw new ElasticsearchParseException("could not parse watch status. failed to parse field [{}]", e, currentFieldName).             }         } else if (Field.VERSION.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 version = parser.longValue().             } else {                 throw new ElasticsearchParseException("could not parse watch status. expecting field [{}] to hold a long " + "value, found [{}] instead", currentFieldName, token).             }         } else if (Field.LAST_CHECKED.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 lastChecked = parseDate(currentFieldName, parser).             } else {                 throw new ElasticsearchParseException("could not parse watch status. expecting field [{}] to hold a date " + "value, found [{}] instead", currentFieldName, token).             }         } else if (Field.LAST_MET_CONDITION.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 lastMetCondition = parseDate(currentFieldName, parser).             } else {                 throw new ElasticsearchParseException("could not parse watch status. expecting field [{}] to hold a date " + "value, found [{}] instead", currentFieldName, token).             }         } else if (Field.EXECUTION_STATE.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 executionState = ExecutionState.resolve(parser.text()).             } else {                 throw new ElasticsearchParseException("could not parse watch status. expecting field [{}] to hold a string " + "value, found [{}] instead", currentFieldName, token).             }         } else if (Field.ACTIONS.match(currentFieldName, parser.getDeprecationHandler())) {             actions = new HashMap<>().             if (token == XContentParser.Token.START_OBJECT) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         currentFieldName = parser.currentName().                     } else {                         ActionStatus actionStatus = ActionStatus.parse(currentFieldName, parser).                         actions.put(currentFieldName, actionStatus).                     }                 }             } else {                 throw new ElasticsearchParseException("could not parse watch status. expecting field [{}] to be an object, " + "found [{}] instead", currentFieldName, token).             }         } else if (Field.HEADERS.match(currentFieldName, parser.getDeprecationHandler())) {             if (token == XContentParser.Token.START_OBJECT) {                 headers = parser.mapStrings().             }         } else {             parser.skipChildren().         }     }     actions = actions == null ? emptyMap() : unmodifiableMap(actions).     return new WatchStatus(version, state, executionState, lastChecked, lastMetCondition, actions, headers). }
false;public;0;3;;public boolean isActive() {     return active. }
false;public;0;3;;public ZonedDateTime getTimestamp() {     return timestamp. }
false;public,static;1;21;;public static State parse(XContentParser parser) throws IOException {     if (parser.currentToken() != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("expected an object but found [{}] instead", parser.currentToken()).     }     boolean active = true.     ZonedDateTime timestamp = ZonedDateTime.now(ZoneOffset.UTC).     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.ACTIVE.match(currentFieldName, parser.getDeprecationHandler())) {             active = parser.booleanValue().         } else if (Field.TIMESTAMP.match(currentFieldName, parser.getDeprecationHandler())) {             timestamp = parseDate(currentFieldName, parser).         } else {             parser.skipChildren().         }     }     return new State(active, timestamp). }
