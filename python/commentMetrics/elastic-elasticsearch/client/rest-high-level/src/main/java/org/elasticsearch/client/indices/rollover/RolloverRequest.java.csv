commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the alias of the rollover operation  */ ;/**  * Returns the alias of the rollover operation  */ public String getAlias() {     return alias. }
true;public;0;3;/**  * Returns the new index name for the rollover  */ ;/**  * Returns the new index name for the rollover  */ public String getNewIndexName() {     return newIndexName. }
true;public;1;4;/**  * Sets if the rollover should not be executed when conditions are met  */ ;/**  * Sets if the rollover should not be executed when conditions are met  */ public RolloverRequest dryRun(boolean dryRun) {     this.dryRun = dryRun.     return this. }
true;public;0;3;/**  * Returns if the rollover should not be executed when conditions are met  */ ;/**  * Returns if the rollover should not be executed when conditions are met  */ public boolean isDryRun() {     return dryRun. }
true;public;1;8;/**  * Adds condition to check if the index is at least <code>age</code> old  */ ;/**  * Adds condition to check if the index is at least <code>age</code> old  */ public RolloverRequest addMaxIndexAgeCondition(TimeValue age) {     MaxAgeCondition maxAgeCondition = new MaxAgeCondition(age).     if (this.conditions.containsKey(maxAgeCondition.name())) {         throw new IllegalArgumentException(maxAgeCondition.name() + " condition is already set").     }     this.conditions.put(maxAgeCondition.name(), maxAgeCondition).     return this. }
true;public;1;8;/**  * Adds condition to check if the index has at least <code>numDocs</code>  */ ;/**  * Adds condition to check if the index has at least <code>numDocs</code>  */ public RolloverRequest addMaxIndexDocsCondition(long numDocs) {     MaxDocsCondition maxDocsCondition = new MaxDocsCondition(numDocs).     if (this.conditions.containsKey(maxDocsCondition.name())) {         throw new IllegalArgumentException(maxDocsCondition.name() + " condition is already set").     }     this.conditions.put(maxDocsCondition.name(), maxDocsCondition).     return this. }
true;public;1;8;/**  * Adds a size-based condition to check if the index size is at least <code>size</code>.  */ ;/**  * Adds a size-based condition to check if the index size is at least <code>size</code>.  */ public RolloverRequest addMaxIndexSizeCondition(ByteSizeValue size) {     MaxSizeCondition maxSizeCondition = new MaxSizeCondition(size).     if (this.conditions.containsKey(maxSizeCondition.name())) {         throw new IllegalArgumentException(maxSizeCondition + " condition is already set").     }     this.conditions.put(maxSizeCondition.name(), maxSizeCondition).     return this. }
true;public;0;3;/**  * Returns all set conditions  */ ;/**  * Returns all set conditions  */ public Map<String, Condition<?>> getConditions() {     return conditions. }
true;public;0;3;/**  * Returns the inner {@link CreateIndexRequest}. Allows to configure mappings, settings and aliases for the new index.  */ ;/**  * Returns the inner {@link CreateIndexRequest}. Allows to configure mappings, settings and aliases for the new index.  */ public CreateIndexRequest getCreateIndexRequest() {     return createIndexRequest. }
false;public;2;14;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     createIndexRequest.innerToXContent(builder, params).     builder.startObject("conditions").     for (Condition<?> condition : conditions.values()) {         condition.toXContent(builder, params).     }     builder.endObject().     builder.endObject().     return builder. }
