commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ActionRequestValidationException validate() {     return null. }
true;public;1;8;/**  * Sets the indices the count will be executed on.  */ ;/**  * Sets the indices the count will be executed on.  */ public CountRequest indices(String... indices) {     Objects.requireNonNull(indices, "indices must not be null").     for (String index : indices) {         Objects.requireNonNull(index, "index must not be null").     }     this.indices = indices.     return this. }
true;public;1;4;/**  * The source of the count request.  */ ;/**  * The source of the count request.  */ public CountRequest source(SearchSourceBuilder searchSourceBuilder) {     this.searchSourceBuilder = Objects.requireNonNull(searchSourceBuilder, "source must not be null").     return this. }
true;public;1;9;/**  * The document types to execute the count against. Defaults to be executed against all types.  *  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ ;/**  * The document types to execute the count against. Defaults to be executed against all types.  *  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ @Deprecated public CountRequest types(String... types) {     Objects.requireNonNull(types, "types must not be null").     for (String type : types) {         Objects.requireNonNull(type, "type must not be null").     }     this.types = types.     return this. }
true;public;1;4;/**  * The routing values to control the shards that the search will be executed on.  */ ;/**  * The routing values to control the shards that the search will be executed on.  */ public CountRequest routing(String routing) {     this.routing = routing.     return this. }
true;public;1;4;/**  * A comma separated list of routing values to control the shards the count will be executed on.  */ ;/**  * A comma separated list of routing values to control the shards the count will be executed on.  */ public CountRequest routing(String... routings) {     this.routing = Strings.arrayToCommaDelimitedString(routings).     return this. }
true;public;1;4;/**  * Returns the indices options used to resolve indices. They tell for instance whether a single index is accepted, whether an empty  * array will be converted to _all, and how wildcards will be expanded if needed.  *  * @see org.elasticsearch.action.support.IndicesOptions  */ ;/**  * Returns the indices options used to resolve indices. They tell for instance whether a single index is accepted, whether an empty  * array will be converted to _all, and how wildcards will be expanded if needed.  *  * @see org.elasticsearch.action.support.IndicesOptions  */ public CountRequest indicesOptions(IndicesOptions indicesOptions) {     this.indicesOptions = Objects.requireNonNull(indicesOptions, "indicesOptions must not be null").     return this. }
true;public;1;4;/**  * Sets the preference to execute the count. Defaults to randomize across shards. Can be set to {@code _local} to prefer local shards  * or a custom value, which guarantees that the same order will be used across different requests.  */ ;/**  * Sets the preference to execute the count. Defaults to randomize across shards. Can be set to {@code _local} to prefer local shards  * or a custom value, which guarantees that the same order will be used across different requests.  */ public CountRequest preference(String preference) {     this.preference = preference.     return this. }
false;public;0;3;;public IndicesOptions indicesOptions() {     return this.indicesOptions. }
false;public;0;3;;public String routing() {     return this.routing. }
false;public;0;3;;public String preference() {     return this.preference. }
false;public;0;3;;public String[] indices() {     return Arrays.copyOf(this.indices, this.indices.length). }
false;public;0;3;;public Float minScore() {     return this.searchSourceBuilder.minScore(). }
false;public;1;4;;public CountRequest minScore(Float minScore) {     this.searchSourceBuilder.minScore(minScore).     return this. }
false;public;0;3;;public int terminateAfter() {     return this.searchSourceBuilder.terminateAfter(). }
false;public;1;4;;public CountRequest terminateAfter(int terminateAfter) {     this.searchSourceBuilder.terminateAfter(terminateAfter).     return this. }
true;public;0;4;/**  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ ;/**  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ @Deprecated public String[] types() {     return Arrays.copyOf(this.types, this.types.length). }
false;public;0;3;;public SearchSourceBuilder source() {     return this.searchSourceBuilder. }
false;public;1;15;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     CountRequest that = (CountRequest) o.     return Objects.equals(indicesOptions, that.indicesOptions) && Arrays.equals(indices, that.indices) && Arrays.equals(types, that.types) && Objects.equals(routing, that.routing) && Objects.equals(preference, that.preference). }
false;public;0;7;;@Override public int hashCode() {     int result = Objects.hash(indicesOptions, routing, preference).     result = 31 * result + Arrays.hashCode(indices).     result = 31 * result + Arrays.hashCode(types).     return result. }
