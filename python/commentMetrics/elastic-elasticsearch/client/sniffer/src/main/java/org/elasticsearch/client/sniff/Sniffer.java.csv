commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public void run() {     super.run().     initialized.compareAndSet(false, true). }
true;public;0;18;/**  * Schedule sniffing to run as soon as possible if it isn't already running. Once such sniffing round runs  * it will also schedule a new round after sniffAfterFailureDelay ms.  */ ;/**  * Schedule sniffing to run as soon as possible if it isn't already running. Once such sniffing round runs  * it will also schedule a new round after sniffAfterFailureDelay ms.  */ public void sniffOnFailure() {     // sniffOnFailure does nothing until the initial sniffing round has been completed     if (initialized.get()) {         /*              * If sniffing is already running, there is no point in scheduling another round right after the current one.              * Concurrent calls may be checking the same task state, but only the first skip call on the same task returns true.              * The task may also get replaced while we check its state, in which case calling skip on it returns false.              */         if (this.nextScheduledTask.skip()) {             /*                  * We do not keep track of this future as the task will immediately run and we don't intend to cancel it                  * due to concurrent sniffOnFailure runs. Effectively the previous (now cancelled or skipped) task will stay                  * assigned to nextTask till this onFailure round gets run and schedules its corresponding afterFailure round.                  */             scheduler.schedule(new Task(sniffAfterFailureDelayMillis), 0L).         }     } }
false;public;0;25;;@Override public void run() {     /*              * Skipped or already started tasks do nothing. In most cases tasks will be cancelled and not run, but we want to protect for              * cases where future#cancel returns true yet the task runs. We want to make sure that such tasks do nothing otherwise they will              * schedule another round at the end and so on, leaving us with multiple parallel sniffing "tracks" whish is undesirable.              */     if (taskState.compareAndSet(TaskState.WAITING, TaskState.STARTED) == false) {         return.     }     try {         sniff().     } catch (Exception e) {         logger.error("error while sniffing nodes", e).     } finally {         Task task = new Task(sniffIntervalMillis).         Future<?> future = scheduler.schedule(task, nextTaskDelay).         // tasks are run by a single threaded executor, so swapping is safe with a simple volatile variable         ScheduledTask previousTask = nextScheduledTask.         nextScheduledTask = new ScheduledTask(task, future).         assert initialized.get() == false || previousTask.task.isSkipped() || previousTask.task.hasStarted() : "task that we are replacing is neither " + "cancelled nor has it ever started".     } }
true;;0;3;/**  * Returns true if the task has started, false in case it didn't start (yet?) or it was skipped  */ ;/**  * Returns true if the task has started, false in case it didn't start (yet?) or it was skipped  */ boolean hasStarted() {     return taskState.get() == TaskState.STARTED. }
true;;0;9;/**  * Sets this task to be skipped. Returns true if the task will be skipped, false if the task has already started.  */ ;/**  * Sets this task to be skipped. Returns true if the task will be skipped, false if the task has already started.  */ boolean skip() {     /*              * Threads may still get run although future#cancel returns true. We make sure that a task is either cancelled (or skipped),              * or entirely run. In the odd case that future#cancel returns true and the thread still runs, the task won't do anything.              * In case future#cancel returns true but the task has already started, this state change will not succeed hence this method              * returns false and the task will normally run.              */     return taskState.compareAndSet(TaskState.WAITING, TaskState.SKIPPED). }
true;;0;3;/**  * Returns true if the task was set to be skipped before it was started  */ ;/**  * Returns true if the task was set to be skipped before it was started  */ boolean isSkipped() {     return taskState.get() == TaskState.SKIPPED. }
true;;0;10;/**  * Cancels this task. Returns true if the task has been successfully cancelled, meaning it won't be executed  * or if it is its execution won't have any effect. Returns false if the task cannot be cancelled (possibly it was  * already cancelled or already completed).  */ ;/**  * Cancels this task. Returns true if the task has been successfully cancelled, meaning it won't be executed  * or if it is its execution won't have any effect. Returns false if the task cannot be cancelled (possibly it was  * already cancelled or already completed).  */ boolean skip() {     /*              * Future#cancel should return false whenever a task cannot be cancelled, most likely as it has already started. We don't              * trust it much though so we try to cancel hoping that it will work.  At the same time we always call skip too, which means              * that if the task has already started the state change will fail. We could potentially not call skip when cancel returns              * false but we prefer to stay on the safe side.              */     future.cancel(false).     return task.skip(). }
false;final;0;11;;final void sniff() throws IOException {     List<Node> sniffedNodes = nodesSniffer.sniff().     if (logger.isDebugEnabled()) {         logger.debug("sniffed nodes: " + sniffedNodes).     }     if (sniffedNodes.isEmpty()) {         logger.warn("no nodes to set, nodes will be updated at the next sniffing round").     } else {         restClient.setNodes(sniffedNodes).     } }
false;public;0;7;;@Override public void close() {     if (initialized.get()) {         nextScheduledTask.skip().     }     this.scheduler.shutdown(). }
true;public,static;1;3;/**  * Returns a new {@link SnifferBuilder} to help with {@link Sniffer} creation.  *  * @param restClient the client that gets its hosts set (via  *      {@link RestClient#setNodes(Collection)}) once they are fetched  * @return a new instance of {@link SnifferBuilder}  */ ;/**  * Returns a new {@link SnifferBuilder} to help with {@link Sniffer} creation.  *  * @param restClient the client that gets its hosts set (via  *      {@link RestClient#setNodes(Collection)}) once they are fetched  * @return a new instance of {@link SnifferBuilder}  */ public static SnifferBuilder builder(RestClient restClient) {     return new SnifferBuilder(restClient). }
true;;2;1;/**  * Schedules the provided {@link Runnable} to be executed in <code>delayMillis</code> milliseconds  */ ;/**  * Schedules the provided {@link Runnable} to be executed in <code>delayMillis</code> milliseconds  */ Future<?> schedule(Task task, long delayMillis).
true;;0;1;/**  * Shuts this scheduler down  */ ;/**  * Shuts this scheduler down  */ void shutdown().
false;private,static;0;5;;private static ScheduledExecutorService initScheduledExecutorService() {     ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1, new SnifferThreadFactory(SNIFFER_THREAD_NAME)).     executor.setRemoveOnCancelPolicy(true).     return executor. }
false;public;2;4;;@Override public Future<?> schedule(Task task, long delayMillis) {     return executor.schedule(task, delayMillis, TimeUnit.MILLISECONDS). }
false;public;0;12;;@Override public void shutdown() {     executor.shutdown().     try {         if (executor.awaitTermination(1000, TimeUnit.MILLISECONDS)) {             return.         }         executor.shutdownNow().     } catch (InterruptedException ignore) {         Thread.currentThread().interrupt().     } }
false;public;0;4;;@Override public ThreadFactory run() {     return Executors.defaultThreadFactory(). }
false;public;0;7;;@Override public Thread run() {     Thread t = originalThreadFactory.newThread(r).     t.setName(namePrefix + "[T#" + threadNumber.getAndIncrement() + "]").     t.setDaemon(true).     return t. }
false;public;1;12;;@Override public Thread newThread(final Runnable r) {     return AccessController.doPrivileged(new PrivilegedAction<Thread>() {          @Override         public Thread run() {             Thread t = originalThreadFactory.newThread(r).             t.setName(namePrefix + "[T#" + threadNumber.getAndIncrement() + "]").             t.setDaemon(true).             return t.         }     }). }
