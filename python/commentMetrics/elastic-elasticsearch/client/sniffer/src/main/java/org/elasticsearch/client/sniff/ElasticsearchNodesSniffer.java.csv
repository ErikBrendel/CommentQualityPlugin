commented;modifiers;parameterAmount;loc;comment;code
true;public;0;5;/**  * Calls the elasticsearch nodes info api, parses the response and returns all the found http hosts  */ ;/**  * Calls the elasticsearch nodes info api, parses the response and returns all the found http hosts  */ @Override public List<Node> sniff() throws IOException {     Response response = restClient.performRequest(request).     return readHosts(response.getEntity(), scheme, jsonFactory). }
false;static;3;27;;static List<Node> readHosts(HttpEntity entity, Scheme scheme, JsonFactory jsonFactory) throws IOException {     try (InputStream inputStream = entity.getContent()) {         JsonParser parser = jsonFactory.createParser(inputStream).         if (parser.nextToken() != JsonToken.START_OBJECT) {             throw new IOException("expected data to start with an object").         }         List<Node> nodes = new ArrayList<>().         while (parser.nextToken() != JsonToken.END_OBJECT) {             if (parser.getCurrentToken() == JsonToken.START_OBJECT) {                 if ("nodes".equals(parser.getCurrentName())) {                     while (parser.nextToken() != JsonToken.END_OBJECT) {                         JsonToken token = parser.nextToken().                         assert token == JsonToken.START_OBJECT.                         String nodeId = parser.getCurrentName().                         Node node = readNode(nodeId, parser, scheme).                         if (node != null) {                             nodes.add(node).                         }                     }                 } else {                     parser.skipChildren().                 }             }         }         return nodes.     } }
false;private,static;3;134;;private static Node readNode(String nodeId, JsonParser parser, Scheme scheme) throws IOException {     HttpHost publishedHost = null.     /*          * We sniff the bound hosts so we can look up the node based on any          * address on which it is listening. This is useful in Elasticsearch's          * test framework where we sometimes publish ipv6 addresses but the          * tests contact the node on ipv4.          */     Set<HttpHost> boundHosts = new HashSet<>().     String name = null.     String version = null.     /*          * Multi-valued attributes come with key = `real_key.index` and we          * unflip them after reading them because we can't rely on the order          * that they arive.          */     final Map<String, String> protoAttributes = new HashMap<String, String>().     boolean sawRoles = false.     boolean master = false.     boolean data = false.     boolean ingest = false.     String fieldName = null.     while (parser.nextToken() != JsonToken.END_OBJECT) {         if (parser.getCurrentToken() == JsonToken.FIELD_NAME) {             fieldName = parser.getCurrentName().         } else if (parser.getCurrentToken() == JsonToken.START_OBJECT) {             if ("http".equals(fieldName)) {                 while (parser.nextToken() != JsonToken.END_OBJECT) {                     if (parser.getCurrentToken() == JsonToken.VALUE_STRING && "publish_address".equals(parser.getCurrentName())) {                         URI publishAddressAsURI = URI.create(scheme + "://" + parser.getValueAsString()).                         publishedHost = new HttpHost(publishAddressAsURI.getHost(), publishAddressAsURI.getPort(), publishAddressAsURI.getScheme()).                     } else if (parser.currentToken() == JsonToken.START_ARRAY && "bound_address".equals(parser.getCurrentName())) {                         while (parser.nextToken() != JsonToken.END_ARRAY) {                             URI boundAddressAsURI = URI.create(scheme + "://" + parser.getValueAsString()).                             boundHosts.add(new HttpHost(boundAddressAsURI.getHost(), boundAddressAsURI.getPort(), boundAddressAsURI.getScheme())).                         }                     } else if (parser.getCurrentToken() == JsonToken.START_OBJECT) {                         parser.skipChildren().                     }                 }             } else if ("attributes".equals(fieldName)) {                 while (parser.nextToken() != JsonToken.END_OBJECT) {                     if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {                         String oldValue = protoAttributes.put(parser.getCurrentName(), parser.getValueAsString()).                         if (oldValue != null) {                             throw new IOException("repeated attribute key [" + parser.getCurrentName() + "]").                         }                     } else {                         parser.skipChildren().                     }                 }             } else {                 parser.skipChildren().             }         } else if (parser.currentToken() == JsonToken.START_ARRAY) {             if ("roles".equals(fieldName)) {                 sawRoles = true.                 while (parser.nextToken() != JsonToken.END_ARRAY) {                     switch(parser.getText()) {                         case "master":                             master = true.                             break.                         case "data":                             data = true.                             break.                         case "ingest":                             ingest = true.                             break.                         default:                             logger.warn("unknown role [" + parser.getText() + "] on node [" + nodeId + "]").                     }                 }             } else {                 parser.skipChildren().             }         } else if (parser.currentToken().isScalarValue()) {             if ("version".equals(fieldName)) {                 version = parser.getText().             } else if ("name".equals(fieldName)) {                 name = parser.getText().             }         }     }     // http section is not present if http is not enabled on the node, ignore such nodes     if (publishedHost == null) {         logger.debug("skipping node [" + nodeId + "] with http disabled").         return null.     }     Map<String, List<String>> realAttributes = new HashMap<>(protoAttributes.size()).     List<String> keys = new ArrayList<>(protoAttributes.keySet()).     for (String key : keys) {         if (key.endsWith(".0")) {             String realKey = key.substring(0, key.length() - 2).             List<String> values = new ArrayList<>().             int i = 0.             while (true) {                 String value = protoAttributes.remove(realKey + "." + i).                 if (value == null) {                     break.                 }                 values.add(value).                 i++.             }             realAttributes.put(realKey, unmodifiableList(values)).         }     }     for (Map.Entry<String, String> entry : protoAttributes.entrySet()) {         realAttributes.put(entry.getKey(), singletonList(entry.getValue())).     }     if (version.startsWith("2.")) {         /*              * 2.x doesn't send roles, instead we try to read them from              * attributes.              */         boolean clientAttribute = v2RoleAttributeValue(realAttributes, "client", false).         Boolean masterAttribute = v2RoleAttributeValue(realAttributes, "master", null).         Boolean dataAttribute = v2RoleAttributeValue(realAttributes, "data", null).         master = masterAttribute == null ? false == clientAttribute : masterAttribute.         data = dataAttribute == null ? false == clientAttribute : dataAttribute.     } else {         assert sawRoles : "didn't see roles for [" + nodeId + "]".     }     assert boundHosts.contains(publishedHost) : "[" + nodeId + "] doesn't make sense! publishedHost should be in boundHosts".     logger.trace("adding node [" + nodeId + "]").     return new Node(publishedHost, boundHosts, name, version, new Roles(master, data, ingest), unmodifiableMap(realAttributes)). }
true;private,static;3;20;/**  * Returns {@code defaultValue} if the attribute didn't come back,  * {@code true} or {@code false} if it did come back as  * either of those, or throws an IOException if the attribute  * came back in a strange way.  */ ;/**  * Returns {@code defaultValue} if the attribute didn't come back,  * {@code true} or {@code false} if it did come back as  * either of those, or throws an IOException if the attribute  * came back in a strange way.  */ private static Boolean v2RoleAttributeValue(Map<String, List<String>> attributes, String name, Boolean defaultValue) throws IOException {     List<String> valueList = attributes.remove(name).     if (valueList == null) {         return defaultValue.     }     if (valueList.size() != 1) {         throw new IOException("expected only a single attribute value for [" + name + "] but got " + valueList).     }     switch(valueList.get(0)) {         case "true":             return true.         case "false":             return false.         default:             throw new IOException("expected [" + name + "] to be either [true] or [false] but was [" + valueList.get(0) + "]").     } }
false;public;0;4;;@Override public String toString() {     return name. }
