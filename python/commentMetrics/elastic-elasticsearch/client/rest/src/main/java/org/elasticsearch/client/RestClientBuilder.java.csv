commented;modifiers;parameterAmount;loc;comment;code
true;public;1;8;/**  * Sets the default request headers, which will be sent along with each request.  * <p>  * Request-time headers will always overwrite any default headers.  *  * @throws NullPointerException if {@code defaultHeaders} or any header is {@code null}.  */ ;/**  * Sets the default request headers, which will be sent along with each request.  * <p>  * Request-time headers will always overwrite any default headers.  *  * @throws NullPointerException if {@code defaultHeaders} or any header is {@code null}.  */ public RestClientBuilder setDefaultHeaders(Header[] defaultHeaders) {     Objects.requireNonNull(defaultHeaders, "defaultHeaders must not be null").     for (Header defaultHeader : defaultHeaders) {         Objects.requireNonNull(defaultHeader, "default header must not be null").     }     this.defaultHeaders = defaultHeaders.     return this. }
true;public;1;5;/**  * Sets the {@link RestClient.FailureListener} to be notified for each request failure  *  * @throws NullPointerException if {@code failureListener} is {@code null}.  */ ;/**  * Sets the {@link RestClient.FailureListener} to be notified for each request failure  *  * @throws NullPointerException if {@code failureListener} is {@code null}.  */ public RestClientBuilder setFailureListener(RestClient.FailureListener failureListener) {     Objects.requireNonNull(failureListener, "failureListener must not be null").     this.failureListener = failureListener.     return this. }
true;public;1;5;/**  * Sets the {@link HttpClientConfigCallback} to be used to customize http client configuration  *  * @throws NullPointerException if {@code httpClientConfigCallback} is {@code null}.  */ ;/**  * Sets the {@link HttpClientConfigCallback} to be used to customize http client configuration  *  * @throws NullPointerException if {@code httpClientConfigCallback} is {@code null}.  */ public RestClientBuilder setHttpClientConfigCallback(HttpClientConfigCallback httpClientConfigCallback) {     Objects.requireNonNull(httpClientConfigCallback, "httpClientConfigCallback must not be null").     this.httpClientConfigCallback = httpClientConfigCallback.     return this. }
true;public;1;5;/**  * Sets the {@link RequestConfigCallback} to be used to customize http client configuration  *  * @throws NullPointerException if {@code requestConfigCallback} is {@code null}.  */ ;/**  * Sets the {@link RequestConfigCallback} to be used to customize http client configuration  *  * @throws NullPointerException if {@code requestConfigCallback} is {@code null}.  */ public RestClientBuilder setRequestConfigCallback(RequestConfigCallback requestConfigCallback) {     Objects.requireNonNull(requestConfigCallback, "requestConfigCallback must not be null").     this.requestConfigCallback = requestConfigCallback.     return this. }
true;public;1;25;/**  * Sets the path's prefix for every request used by the http client.  * <p>  * For example, if this is set to "/my/path", then any client request will become <code>"/my/path/" + endpoint</code>.  * <p>  * In essence, every request's {@code endpoint} is prefixed by this {@code pathPrefix}. The path prefix is useful for when  * Elasticsearch is behind a proxy that provides a base path or a proxy that requires all paths to start with '/'.  * it is not intended for other purposes and it should not be supplied in other scenarios.  *  * @throws NullPointerException if {@code pathPrefix} is {@code null}.  * @throws IllegalArgumentException if {@code pathPrefix} is empty, or ends with more than one '/'.  */ ;/**  * Sets the path's prefix for every request used by the http client.  * <p>  * For example, if this is set to "/my/path", then any client request will become <code>"/my/path/" + endpoint</code>.  * <p>  * In essence, every request's {@code endpoint} is prefixed by this {@code pathPrefix}. The path prefix is useful for when  * Elasticsearch is behind a proxy that provides a base path or a proxy that requires all paths to start with '/'.  * it is not intended for other purposes and it should not be supplied in other scenarios.  *  * @throws NullPointerException if {@code pathPrefix} is {@code null}.  * @throws IllegalArgumentException if {@code pathPrefix} is empty, or ends with more than one '/'.  */ public RestClientBuilder setPathPrefix(String pathPrefix) {     Objects.requireNonNull(pathPrefix, "pathPrefix must not be null").     if (pathPrefix.isEmpty()) {         throw new IllegalArgumentException("pathPrefix must not be empty").     }     String cleanPathPrefix = pathPrefix.     if (cleanPathPrefix.startsWith("/") == false) {         cleanPathPrefix = "/" + cleanPathPrefix.     }     // best effort to ensure that it looks like "/base/path" rather than "/base/path/"     if (cleanPathPrefix.endsWith("/") && cleanPathPrefix.length() > 1) {         cleanPathPrefix = cleanPathPrefix.substring(0, cleanPathPrefix.length() - 1).         if (cleanPathPrefix.endsWith("/")) {             throw new IllegalArgumentException("pathPrefix is malformed. too many trailing slashes: [" + pathPrefix + "]").         }     }     this.pathPrefix = cleanPathPrefix.     return this. }
true;public;1;5;/**  * Sets the {@link NodeSelector} to be used for all requests.  * @throws NullPointerException if the provided nodeSelector is null  */ ;/**  * Sets the {@link NodeSelector} to be used for all requests.  * @throws NullPointerException if the provided nodeSelector is null  */ public RestClientBuilder setNodeSelector(NodeSelector nodeSelector) {     Objects.requireNonNull(nodeSelector, "nodeSelector must not be null").     this.nodeSelector = nodeSelector.     return this. }
true;public;1;4;/**  * Whether the REST client should return any response containing at least  * one warning header as a failure.  */ ;/**  * Whether the REST client should return any response containing at least  * one warning header as a failure.  */ public RestClientBuilder setStrictDeprecationMode(boolean strictDeprecationMode) {     this.strictDeprecationMode = strictDeprecationMode.     return this. }
false;public;0;4;;@Override public CloseableHttpAsyncClient run() {     return createHttpClient(). }
true;public;0;15;/**  * Creates a new {@link RestClient} based on the provided configuration.  */ ;/**  * Creates a new {@link RestClient} based on the provided configuration.  */ public RestClient build() {     if (failureListener == null) {         failureListener = new RestClient.FailureListener().     }     CloseableHttpAsyncClient httpClient = AccessController.doPrivileged(new PrivilegedAction<CloseableHttpAsyncClient>() {          @Override         public CloseableHttpAsyncClient run() {             return createHttpClient().         }     }).     RestClient restClient = new RestClient(httpClient, defaultHeaders, nodes, pathPrefix, failureListener, nodeSelector, strictDeprecationMode).     httpClient.start().     return restClient. }
false;public;0;4;;@Override public CloseableHttpAsyncClient run() {     return finalBuilder.build(). }
false;private;0;30;;private CloseableHttpAsyncClient createHttpClient() {     // default timeouts are all infinite     RequestConfig.Builder requestConfigBuilder = RequestConfig.custom().setConnectTimeout(DEFAULT_CONNECT_TIMEOUT_MILLIS).setSocketTimeout(DEFAULT_SOCKET_TIMEOUT_MILLIS).     if (requestConfigCallback != null) {         requestConfigBuilder = requestConfigCallback.customizeRequestConfig(requestConfigBuilder).     }     try {         HttpAsyncClientBuilder httpClientBuilder = HttpAsyncClientBuilder.create().setDefaultRequestConfig(requestConfigBuilder.build()).setMaxConnPerRoute(DEFAULT_MAX_CONN_PER_ROUTE).setMaxConnTotal(DEFAULT_MAX_CONN_TOTAL).setSSLContext(SSLContext.getDefault()).setTargetAuthenticationStrategy(new PersistentCredentialsAuthenticationStrategy()).         if (httpClientConfigCallback != null) {             httpClientBuilder = httpClientConfigCallback.customizeHttpClient(httpClientBuilder).         }         final HttpAsyncClientBuilder finalBuilder = httpClientBuilder.         return AccessController.doPrivileged(new PrivilegedAction<CloseableHttpAsyncClient>() {              @Override             public CloseableHttpAsyncClient run() {                 return finalBuilder.build().             }         }).     } catch (NoSuchAlgorithmException e) {         throw new IllegalStateException("could not create the default ssl context", e).     } }
true;;1;1;/**  * Allows to customize the {@link RequestConfig} that will be used with each request.  * It is common to customize the different timeout values through this method without losing any other useful default  * value that the {@link RestClientBuilder} internally sets.  */ ;/**  * Allows to customize the {@link RequestConfig} that will be used with each request.  * It is common to customize the different timeout values through this method without losing any other useful default  * value that the {@link RestClientBuilder} internally sets.  */ RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder).
true;;1;1;/**  * Allows to customize the {@link CloseableHttpAsyncClient} being created and used by the {@link RestClient}.  * Commonly used to customize the default {@link org.apache.http.client.CredentialsProvider} for authentication  * or the {@link SchemeIOSessionStrategy} for communication through ssl without losing any other useful default  * value that the {@link RestClientBuilder} internally sets, like connection pooling.  */ ;/**  * Allows to customize the {@link CloseableHttpAsyncClient} being created and used by the {@link RestClient}.  * Commonly used to customize the default {@link org.apache.http.client.CredentialsProvider} for authentication  * or the {@link SchemeIOSessionStrategy} for communication through ssl without losing any other useful default  * value that the {@link RestClientBuilder} internally sets, like connection pooling.  */ HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder).
