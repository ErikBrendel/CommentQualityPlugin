# id;timestamp;commentText;codeText;commentWords;codeWords
RestClient -> private static void addParameters(Request request, Map<String, String> parameters);1525248068;Add all parameters from a map to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;private static void addParameters(Request request, Map<String, String> parameters) {_        Objects.requireNonNull(parameters, "parameters cannot be null")__        for (Map.Entry<String, String> entry : parameters.entrySet()) {_            request.addParameter(entry.getKey(), entry.getValue())__        }_    };add,all,parameters,from,a,map,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;private,static,void,add,parameters,request,request,map,string,string,parameters,objects,require,non,null,parameters,parameters,cannot,be,null,for,map,entry,string,string,entry,parameters,entry,set,request,add,parameter,entry,get,key,entry,get,value
RestClient -> private static void addParameters(Request request, Map<String, String> parameters);1525859433;Add all parameters from a map to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;private static void addParameters(Request request, Map<String, String> parameters) {_        Objects.requireNonNull(parameters, "parameters cannot be null")__        for (Map.Entry<String, String> entry : parameters.entrySet()) {_            request.addParameter(entry.getKey(), entry.getValue())__        }_    };add,all,parameters,from,a,map,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;private,static,void,add,parameters,request,request,map,string,string,parameters,objects,require,non,null,parameters,parameters,cannot,be,null,for,map,entry,string,string,entry,parameters,entry,set,request,add,parameter,entry,get,key,entry,get,value
RestClient -> public static RestClientBuilder builder(Node... nodes);1528762805;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> public static RestClientBuilder builder(Node... nodes);1529687475;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> public static RestClientBuilder builder(Node... nodes);1531179852;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> public static RestClientBuilder builder(Node... nodes);1535965276;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> public static RestClientBuilder builder(Node... nodes);1538170812;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> public static RestClientBuilder builder(Node... nodes);1544364228;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> public static RestClientBuilder builder(Node... nodes);1544448720;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> public static RestClientBuilder builder(Node... nodes);1548457070;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> public static RestClientBuilder builder(Node... nodes);1548869519;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> public static RestClientBuilder builder(Node... nodes);1549439027;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to._<p>_Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes._If you don't either one is fine.;public static RestClientBuilder builder(Node... nodes) {_        return new RestClientBuilder(nodes == null ? null : Arrays.asList(nodes))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to,p,prefer,this,to,link,builder,http,host,if,you,have,metadata,up,front,about,the,nodes,if,you,don,t,either,one,is,fine;public,static,rest,client,builder,builder,node,nodes,return,new,rest,client,builder,nodes,null,null,arrays,as,list,nodes
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException;1525859433;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setHeaders(headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,headers,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException;1527096592;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException;1527840262;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException;1528762805;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException;1529687475;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException;1531179852;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,return,perform,request,request
RestClient -> public synchronized void setHosts(HttpHost... hosts);1524684173;Replaces the hosts that the client communicates with._@see HttpHost;public synchronized void setHosts(HttpHost... hosts) {_        if (hosts == null || hosts.length == 0) {_            throw new IllegalArgumentException("hosts must not be null nor empty")__        }_        Set<HttpHost> httpHosts = new HashSet<>()__        AuthCache authCache = new BasicAuthCache()__        for (HttpHost host : hosts) {_            Objects.requireNonNull(host, "host cannot be null")__            httpHosts.add(host)__            authCache.put(host, new BasicScheme())__        }_        this.hostTuple = new HostTuple<>(Collections.unmodifiableSet(httpHosts), authCache)__        this.blacklist.clear()__    };replaces,the,hosts,that,the,client,communicates,with,see,http,host;public,synchronized,void,set,hosts,http,host,hosts,if,hosts,null,hosts,length,0,throw,new,illegal,argument,exception,hosts,must,not,be,null,nor,empty,set,http,host,http,hosts,new,hash,set,auth,cache,auth,cache,new,basic,auth,cache,for,http,host,host,hosts,objects,require,non,null,host,host,cannot,be,null,http,hosts,add,host,auth,cache,put,host,new,basic,scheme,this,host,tuple,new,host,tuple,collections,unmodifiable,set,http,hosts,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setHosts(HttpHost... hosts);1525248068;Replaces the hosts that the client communicates with._@see HttpHost;public synchronized void setHosts(HttpHost... hosts) {_        if (hosts == null || hosts.length == 0) {_            throw new IllegalArgumentException("hosts must not be null nor empty")__        }_        Set<HttpHost> httpHosts = new HashSet<>()__        AuthCache authCache = new BasicAuthCache()__        for (HttpHost host : hosts) {_            Objects.requireNonNull(host, "host cannot be null")__            httpHosts.add(host)__            authCache.put(host, new BasicScheme())__        }_        this.hostTuple = new HostTuple<>(Collections.unmodifiableSet(httpHosts), authCache)__        this.blacklist.clear()__    };replaces,the,hosts,that,the,client,communicates,with,see,http,host;public,synchronized,void,set,hosts,http,host,hosts,if,hosts,null,hosts,length,0,throw,new,illegal,argument,exception,hosts,must,not,be,null,nor,empty,set,http,host,http,hosts,new,hash,set,auth,cache,auth,cache,new,basic,auth,cache,for,http,host,host,hosts,objects,require,non,null,host,host,cannot,be,null,http,hosts,add,host,auth,cache,put,host,new,basic,scheme,this,host,tuple,new,host,tuple,collections,unmodifiable,set,http,hosts,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setHosts(HttpHost... hosts);1525859433;Replaces the hosts that the client communicates with._@see HttpHost;public synchronized void setHosts(HttpHost... hosts) {_        if (hosts == null || hosts.length == 0) {_            throw new IllegalArgumentException("hosts must not be null nor empty")__        }_        Set<HttpHost> httpHosts = new HashSet<>()__        AuthCache authCache = new BasicAuthCache()__        for (HttpHost host : hosts) {_            Objects.requireNonNull(host, "host cannot be null")__            httpHosts.add(host)__            authCache.put(host, new BasicScheme())__        }_        this.hostTuple = new HostTuple<>(Collections.unmodifiableSet(httpHosts), authCache)__        this.blacklist.clear()__    };replaces,the,hosts,that,the,client,communicates,with,see,http,host;public,synchronized,void,set,hosts,http,host,hosts,if,hosts,null,hosts,length,0,throw,new,illegal,argument,exception,hosts,must,not,be,null,nor,empty,set,http,host,http,hosts,new,hash,set,auth,cache,auth,cache,new,basic,auth,cache,for,http,host,host,hosts,objects,require,non,null,host,host,cannot,be,null,http,hosts,add,host,auth,cache,put,host,new,basic,scheme,this,host,tuple,new,host,tuple,collections,unmodifiable,set,http,hosts,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setHosts(HttpHost... hosts);1527096592;Replaces the hosts that the client communicates with._@see HttpHost;public synchronized void setHosts(HttpHost... hosts) {_        if (hosts == null || hosts.length == 0) {_            throw new IllegalArgumentException("hosts must not be null nor empty")__        }_        Set<HttpHost> httpHosts = new HashSet<>()__        AuthCache authCache = new BasicAuthCache()__        for (HttpHost host : hosts) {_            Objects.requireNonNull(host, "host cannot be null")__            httpHosts.add(host)__            authCache.put(host, new BasicScheme())__        }_        this.hostTuple = new HostTuple<>(Collections.unmodifiableSet(httpHosts), authCache)__        this.blacklist.clear()__    };replaces,the,hosts,that,the,client,communicates,with,see,http,host;public,synchronized,void,set,hosts,http,host,hosts,if,hosts,null,hosts,length,0,throw,new,illegal,argument,exception,hosts,must,not,be,null,nor,empty,set,http,host,http,hosts,new,hash,set,auth,cache,auth,cache,new,basic,auth,cache,for,http,host,host,hosts,objects,require,non,null,host,host,cannot,be,null,http,hosts,add,host,auth,cache,put,host,new,basic,scheme,this,host,tuple,new,host,tuple,collections,unmodifiable,set,http,hosts,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setHosts(HttpHost... hosts);1527840262;Replaces the hosts that the client communicates with._@see HttpHost;public synchronized void setHosts(HttpHost... hosts) {_        if (hosts == null || hosts.length == 0) {_            throw new IllegalArgumentException("hosts must not be null nor empty")__        }_        Set<HttpHost> httpHosts = new LinkedHashSet<>()__        AuthCache authCache = new BasicAuthCache()__        for (HttpHost host : hosts) {_            Objects.requireNonNull(host, "host cannot be null")__            httpHosts.add(host)__            authCache.put(host, new BasicScheme())__        }_        this.hostTuple = new HostTuple<>(Collections.unmodifiableSet(httpHosts), authCache)__        this.blacklist.clear()__    };replaces,the,hosts,that,the,client,communicates,with,see,http,host;public,synchronized,void,set,hosts,http,host,hosts,if,hosts,null,hosts,length,0,throw,new,illegal,argument,exception,hosts,must,not,be,null,nor,empty,set,http,host,http,hosts,new,linked,hash,set,auth,cache,auth,cache,new,basic,auth,cache,for,http,host,host,hosts,objects,require,non,null,host,host,cannot,be,null,http,hosts,add,host,auth,cache,put,host,new,basic,scheme,this,host,tuple,new,host,tuple,collections,unmodifiable,set,http,hosts,auth,cache,this,blacklist,clear
RestClient -> FailureListener -> public void onFailure(Node node);1528762805;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> FailureListener -> public void onFailure(Node node);1529687475;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> FailureListener -> public void onFailure(Node node);1531179852;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> FailureListener -> public void onFailure(Node node);1535965276;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> FailureListener -> public void onFailure(Node node);1538170812;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> FailureListener -> public void onFailure(Node node);1544364228;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> FailureListener -> public void onFailure(Node node);1544448720;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> FailureListener -> public void onFailure(Node node);1548457070;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> FailureListener -> public void onFailure(Node node);1548869519;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> FailureListener -> public void onFailure(Node node);1549439027;Notifies that the node provided as argument has just failed;public void onFailure(Node node) {};notifies,that,the,node,provided,as,argument,has,just,failed;public,void,on,failure,node,node
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                     ResponseListener responseListener, Header... headers);1525859433;Sends a request to the Elasticsearch cluster that the client points to. The request is executed asynchronously_and the provided {@link ResponseListener} gets notified upon request completion or failure._Selects a host out of the provided ones in a round-robin fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously failed (the more failures,_the later they will be retried). In case of failures all of the alive nodes (or dead nodes that deserve a retry) are retried_until one responds or none of them does, in which case an {@link IOException} will be thrown.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            request.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__            request.setHeaders(headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,http,async,response,consumer,factory,http,async,response,consumer,factory,request,set,headers,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                     ResponseListener responseListener, Header... headers);1527096592;Sends a request to the Elasticsearch cluster that the client points to. The request is executed asynchronously_and the provided {@link ResponseListener} gets notified upon request completion or failure._Selects a host out of the provided ones in a round-robin fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously failed (the more failures,_the later they will be retried). In case of failures all of the alive nodes (or dead nodes that deserve a retry) are retried_until one responds or none of them does, in which case an {@link IOException} will be thrown.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            request.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,http,async,response,consumer,factory,http,async,response,consumer,factory,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                     ResponseListener responseListener, Header... headers);1527840262;Sends a request to the Elasticsearch cluster that the client points to. The request is executed asynchronously_and the provided {@link ResponseListener} gets notified upon request completion or failure._Selects a host out of the provided ones in a round-robin fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously failed (the more failures,_the later they will be retried). In case of failures all of the alive nodes (or dead nodes that deserve a retry) are retried_until one responds or none of them does, in which case an {@link IOException} will be thrown.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            setOptions(request, httpAsyncResponseConsumerFactory, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,set,options,request,http,async,response,consumer,factory,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                     ResponseListener responseListener, Header... headers);1528762805;Sends a request to the Elasticsearch cluster that the client points to. The request is executed asynchronously_and the provided {@link ResponseListener} gets notified upon request completion or failure._Selects a host out of the provided ones in a round-robin fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously failed (the more failures,_the later they will be retried). In case of failures all of the alive nodes (or dead nodes that deserve a retry) are retried_until one responds or none of them does, in which case an {@link IOException} will be thrown.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            setOptions(request, httpAsyncResponseConsumerFactory, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,set,options,request,http,async,response,consumer,factory,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                     ResponseListener responseListener, Header... headers);1529687475;Sends a request to the Elasticsearch cluster that the client points to. The request is executed asynchronously_and the provided {@link ResponseListener} gets notified upon request completion or failure._Selects a host out of the provided ones in a round-robin fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously failed (the more failures,_the later they will be retried). In case of failures all of the alive nodes (or dead nodes that deserve a retry) are retried_until one responds or none of them does, in which case an {@link IOException} will be thrown.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            setOptions(request, httpAsyncResponseConsumerFactory, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,set,options,request,http,async,response,consumer,factory,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                     ResponseListener responseListener, Header... headers);1531179852;Sends a request to the Elasticsearch cluster that the client points to. The request is executed asynchronously_and the provided {@link ResponseListener} gets notified upon request completion or failure._Selects a host out of the provided ones in a round-robin fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously failed (the more failures,_the later they will be retried). In case of failures all of the alive nodes (or dead nodes that deserve a retry) are retried_until one responds or none of them does, in which case an {@link IOException} will be thrown.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            setOptions(request, httpAsyncResponseConsumerFactory, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,set,options,request,http,async,response,consumer,factory,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                    Header... headers) throws IOException;1524684173;Sends a request to the Elasticsearch cluster that the client points to. Blocks until the request is completed and returns_its response or fails by throwing an exception. Selects a host out of the provided ones in a round-robin fashion. Failing hosts_are marked dead and retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times_they previously failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                   Header... headers) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(method, endpoint, params, entity, httpAsyncResponseConsumerFactory,_            listener, headers)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,method,endpoint,params,entity,http,async,response,consumer,factory,listener,headers,return,listener,get
RestClient -> public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                    Header... headers) throws IOException;1525248068;Sends a request to the Elasticsearch cluster that the client points to. Blocks until the request is completed and returns_its response or fails by throwing an exception. Selects a host out of the provided ones in a round-robin fashion. Failing hosts_are marked dead and retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times_they previously failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                   Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        request.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__        request.setHeaders(headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,http,async,response,consumer,factory,http,async,response,consumer,factory,request,set,headers,headers,return,perform,request,request
RestClient -> static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,                                       AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException;1531179852;Select nodes to try and sorts them so that the first one will be tried initially, then the following ones_if the previous attempt failed and so on. Package private for testing.;static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,_                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(nodeTuple.nodes.size() - blacklist.size())__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,nodes,to,try,and,sorts,them,so,that,the,first,one,will,be,tried,initially,then,the,following,ones,if,the,previous,attempt,failed,and,so,on,package,private,for,testing;static,iterable,node,select,nodes,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,                                       AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException;1535965276;Select nodes to try and sorts them so that the first one will be tried initially, then the following ones_if the previous attempt failed and so on. Package private for testing.;static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,_                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(nodeTuple.nodes.size() - blacklist.size())__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,nodes,to,try,and,sorts,them,so,that,the,first,one,will,be,tried,initially,then,the,following,ones,if,the,previous,attempt,failed,and,so,on,package,private,for,testing;static,iterable,node,select,nodes,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,                                       AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException;1538170812;Select nodes to try and sorts them so that the first one will be tried initially, then the following ones_if the previous attempt failed and so on. Package private for testing.;static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,_                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(nodeTuple.nodes.size() - blacklist.size())__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,nodes,to,try,and,sorts,them,so,that,the,first,one,will,be,tried,initially,then,the,following,ones,if,the,previous,attempt,failed,and,so,on,package,private,for,testing;static,iterable,node,select,nodes,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,                                       AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException;1544364228;Select nodes to try and sorts them so that the first one will be tried initially, then the following ones_if the previous attempt failed and so on. Package private for testing.;static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,_                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(nodeTuple.nodes.size() - blacklist.size())__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,nodes,to,try,and,sorts,them,so,that,the,first,one,will,be,tried,initially,then,the,following,ones,if,the,previous,attempt,failed,and,so,on,package,private,for,testing;static,iterable,node,select,nodes,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,                                       AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException;1544448720;Select nodes to try and sorts them so that the first one will be tried initially, then the following ones_if the previous attempt failed and so on. Package private for testing.;static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,_                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(nodeTuple.nodes.size() - blacklist.size())__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,nodes,to,try,and,sorts,them,so,that,the,first,one,will,be,tried,initially,then,the,following,ones,if,the,previous,attempt,failed,and,so,on,package,private,for,testing;static,iterable,node,select,nodes,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,                                       AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException;1548457070;Select nodes to try and sorts them so that the first one will be tried initially, then the following ones_if the previous attempt failed and so on. Package private for testing.;static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,_                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(Math.max(0, nodeTuple.nodes.size() - blacklist.size()))__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,nodes,to,try,and,sorts,them,so,that,the,first,one,will,be,tried,initially,then,the,following,ones,if,the,previous,attempt,failed,and,so,on,package,private,for,testing;static,iterable,node,select,nodes,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,math,max,0,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,                                       AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException;1548869519;Select nodes to try and sorts them so that the first one will be tried initially, then the following ones_if the previous attempt failed and so on. Package private for testing.;static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,_                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(Math.max(0, nodeTuple.nodes.size() - blacklist.size()))__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,nodes,to,try,and,sorts,them,so,that,the,first,one,will,be,tried,initially,then,the,following,ones,if,the,previous,attempt,failed,and,so,on,package,private,for,testing;static,iterable,node,select,nodes,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,math,max,0,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,                                       AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException;1549439027;Select nodes to try and sorts them so that the first one will be tried initially, then the following ones_if the previous attempt failed and so on. Package private for testing.;static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,_                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(Math.max(0, nodeTuple.nodes.size() - blacklist.size()))__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,nodes,to,try,and,sorts,them,so,that,the,first,one,will,be,tried,initially,then,the,following,ones,if,the,previous,attempt,failed,and,so,on,package,private,for,testing;static,iterable,node,select,nodes,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,math,max,0,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1524684173;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1525248068;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1525859433;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1527096592;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1527840262;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1528762805;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1529687475;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1531179852;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1535965276;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1538170812;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1544364228;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1544448720;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1548457070;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1548869519;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> FailureTrackingResponseListener -> void onDefinitiveFailure(Exception exception);1549439027;Tracks one last definitive failure and returns to the caller by notifying the wrapped listener;void onDefinitiveFailure(Exception exception) {_            trackFailure(exception)__            responseListener.onFailure(this.exception)__        };tracks,one,last,definitive,failure,and,returns,to,the,caller,by,notifying,the,wrapped,listener;void,on,definitive,failure,exception,exception,track,failure,exception,response,listener,on,failure,this,exception
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, ResponseListener responseListener, Header... headers);1525859433;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure._Shortcut to {@link #performRequestAsync(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, ResponseListener,_Header...)} which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            request.setHeaders(headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,http,async,response,consumer,factory,response,listener,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,headers,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, ResponseListener responseListener, Header... headers);1527096592;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure._Shortcut to {@link #performRequestAsync(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, ResponseListener,_Header...)} which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,http,async,response,consumer,factory,response,listener,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, ResponseListener responseListener, Header... headers);1527840262;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure._Shortcut to {@link #performRequestAsync(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, ResponseListener,_Header...)} which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,http,async,response,consumer,factory,response,listener,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, ResponseListener responseListener, Header... headers);1528762805;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure._Shortcut to {@link #performRequestAsync(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, ResponseListener,_Header...)} which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,http,async,response,consumer,factory,response,listener,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, ResponseListener responseListener, Header... headers);1529687475;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure._Shortcut to {@link #performRequestAsync(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, ResponseListener,_Header...)} which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,http,async,response,consumer,factory,response,listener,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, ResponseListener responseListener, Header... headers);1531179852;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure._Shortcut to {@link #performRequestAsync(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, ResponseListener,_Header...)} which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,http,async,response,consumer,factory,response,listener,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers);1525859433;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without parameters and  request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            request.setHeaders(headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,request,set,headers,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers);1527096592;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without parameters and  request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers);1527840262;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without parameters and  request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers);1528762805;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without parameters and  request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers);1529687475;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without parameters and  request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers);1531179852;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without parameters and  request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1528762805;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1529687475;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1531179852;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1535965276;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1538170812;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1544364228;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1544448720;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1548457070;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1548869519;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public synchronized void setNodes(Collection<Node> nodes);1549439027;Replaces the nodes with which the client communicates.;public synchronized void setNodes(Collection<Node> nodes) {_        if (nodes == null || nodes.isEmpty()) {_            throw new IllegalArgumentException("nodes must not be null or empty")__        }_        AuthCache authCache = new BasicAuthCache()___        Map<HttpHost, Node> nodesByHost = new LinkedHashMap<>()__        for (Node node : nodes) {_            Objects.requireNonNull(node, "node cannot be null")__            _            nodesByHost.put(node.getHost(), node)__            authCache.put(node.getHost(), new BasicScheme())__        }_        this.nodeTuple = new NodeTuple<>(_                Collections.unmodifiableList(new ArrayList<>(nodesByHost.values())), authCache)__        this.blacklist.clear()__    };replaces,the,nodes,with,which,the,client,communicates;public,synchronized,void,set,nodes,collection,node,nodes,if,nodes,null,nodes,is,empty,throw,new,illegal,argument,exception,nodes,must,not,be,null,or,empty,auth,cache,auth,cache,new,basic,auth,cache,map,http,host,node,nodes,by,host,new,linked,hash,map,for,node,node,nodes,objects,require,non,null,node,node,cannot,be,null,nodes,by,host,put,node,get,host,node,auth,cache,put,node,get,host,new,basic,scheme,this,node,tuple,new,node,tuple,collections,unmodifiable,list,new,array,list,nodes,by,host,values,auth,cache,this,blacklist,clear
RestClient -> public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers);1524684173;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without parameters and  request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers;public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers) {_        performRequestAsync(method, endpoint, Collections.<String, String>emptyMap(), null, responseListener, headers)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers;public,void,perform,request,async,string,method,string,endpoint,response,listener,response,listener,header,headers,perform,request,async,method,endpoint,collections,string,string,empty,map,null,response,listener,headers
RestClient -> public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers);1525248068;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without parameters and  request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers;public void performRequestAsync(String method, String endpoint, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            request.setHeaders(headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers;public,void,perform,request,async,string,method,string,endpoint,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,request,set,headers,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                     ResponseListener responseListener, Header... headers);1524684173;Sends a request to the Elasticsearch cluster that the client points to. The request is executed asynchronously_and the provided {@link ResponseListener} gets notified upon request completion or failure._Selects a host out of the provided ones in a round-robin fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously failed (the more failures,_the later they will be retried). In case of failures all of the alive nodes (or dead nodes that deserve a retry) are retried_until one responds or none of them does, in which case an {@link IOException} will be thrown.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers;public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                    ResponseListener responseListener, Header... headers) {_        try {_            performRequestAsyncNoCatch(method, endpoint, params, entity, httpAsyncResponseConsumerFactory,_                responseListener, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers;public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,response,listener,response,listener,header,headers,try,perform,request,async,no,catch,method,endpoint,params,entity,http,async,response,consumer,factory,response,listener,headers,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                     ResponseListener responseListener, Header... headers);1525248068;Sends a request to the Elasticsearch cluster that the client points to. The request is executed asynchronously_and the provided {@link ResponseListener} gets notified upon request completion or failure._Selects a host out of the provided ones in a round-robin fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously failed (the more failures,_the later they will be retried). In case of failures all of the alive nodes (or dead nodes that deserve a retry) are retried_until one responds or none of them does, in which case an {@link IOException} will be thrown.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers;public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            request.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__            request.setHeaders(headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers;public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,http,async,response,consumer,factory,http,async,response,consumer,factory,request,set,headers,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1524684173;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1525248068;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1525859433;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1527096592;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1527840262;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1528762805;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1529687475;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1531179852;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1535965276;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1538170812;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1544364228;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1544448720;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1548457070;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1548869519;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            this.exception = addSuppressedException(this.exception, exception)__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,this,exception,add,suppressed,exception,this,exception,exception
RestClient -> FailureTrackingResponseListener -> void trackFailure(Exception exception);1549439027;Tracks an exception, which caused a retry hence we should not return yet to the caller;void trackFailure(Exception exception) {_            addSuppressedException(this.exception, exception)__            this.exception = exception__        };tracks,an,exception,which,caused,a,retry,hence,we,should,not,return,yet,to,the,caller;void,track,failure,exception,exception,add,suppressed,exception,this,exception,exception,this,exception,exception
RestClient -> private NodeTuple<Iterator<Node>> nextNode() throws IOException;1529687475;Returns a non-empty {@link Iterator} of nodes to be used for a request_that match the {@link NodeSelector}._<p>_If there are no living nodes that match the {@link NodeSelector}_this will return the dead node that matches the {@link NodeSelector}_that is closest to being revived._@throws IOException if no nodes are available;private NodeTuple<Iterator<Node>> nextNode() throws IOException {_        NodeTuple<List<Node>> nodeTuple = this.nodeTuple__        List<Node> hosts = selectHosts(nodeTuple, blacklist, lastNodeIndex, nodeSelector)__        return new NodeTuple<>(hosts.iterator(), nodeTuple.authCache)__    };returns,a,non,empty,link,iterator,of,nodes,to,be,used,for,a,request,that,match,the,link,node,selector,p,if,there,are,no,living,nodes,that,match,the,link,node,selector,this,will,return,the,dead,node,that,matches,the,link,node,selector,that,is,closest,to,being,revived,throws,ioexception,if,no,nodes,are,available;private,node,tuple,iterator,node,next,node,throws,ioexception,node,tuple,list,node,node,tuple,this,node,tuple,list,node,hosts,select,hosts,node,tuple,blacklist,last,node,index,node,selector,return,new,node,tuple,hosts,iterator,node,tuple,auth,cache
RestClient -> private NodeTuple<Iterator<Node>> nextNode() throws IOException;1531179852;Returns a non-empty {@link Iterator} of nodes to be used for a request_that match the {@link NodeSelector}._<p>_If there are no living nodes that match the {@link NodeSelector}_this will return the dead node that matches the {@link NodeSelector}_that is closest to being revived._@throws IOException if no nodes are available;private NodeTuple<Iterator<Node>> nextNode() throws IOException {_        NodeTuple<List<Node>> nodeTuple = this.nodeTuple__        Iterable<Node> hosts = selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector)__        return new NodeTuple<>(hosts.iterator(), nodeTuple.authCache)__    };returns,a,non,empty,link,iterator,of,nodes,to,be,used,for,a,request,that,match,the,link,node,selector,p,if,there,are,no,living,nodes,that,match,the,link,node,selector,this,will,return,the,dead,node,that,matches,the,link,node,selector,that,is,closest,to,being,revived,throws,ioexception,if,no,nodes,are,available;private,node,tuple,iterator,node,next,node,throws,ioexception,node,tuple,list,node,node,tuple,this,node,tuple,iterable,node,hosts,select,nodes,node,tuple,blacklist,last,node,index,node,selector,return,new,node,tuple,hosts,iterator,node,tuple,auth,cache
RestClient -> private NodeTuple<Iterator<Node>> nextNode() throws IOException;1535965276;Returns a non-empty {@link Iterator} of nodes to be used for a request_that match the {@link NodeSelector}._<p>_If there are no living nodes that match the {@link NodeSelector}_this will return the dead node that matches the {@link NodeSelector}_that is closest to being revived._@throws IOException if no nodes are available;private NodeTuple<Iterator<Node>> nextNode() throws IOException {_        NodeTuple<List<Node>> nodeTuple = this.nodeTuple__        Iterable<Node> hosts = selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector)__        return new NodeTuple<>(hosts.iterator(), nodeTuple.authCache)__    };returns,a,non,empty,link,iterator,of,nodes,to,be,used,for,a,request,that,match,the,link,node,selector,p,if,there,are,no,living,nodes,that,match,the,link,node,selector,this,will,return,the,dead,node,that,matches,the,link,node,selector,that,is,closest,to,being,revived,throws,ioexception,if,no,nodes,are,available;private,node,tuple,iterator,node,next,node,throws,ioexception,node,tuple,list,node,node,tuple,this,node,tuple,iterable,node,hosts,select,nodes,node,tuple,blacklist,last,node,index,node,selector,return,new,node,tuple,hosts,iterator,node,tuple,auth,cache
RestClient -> private NodeTuple<Iterator<Node>> nextNode() throws IOException;1538170812;Returns a non-empty {@link Iterator} of nodes to be used for a request_that match the {@link NodeSelector}._<p>_If there are no living nodes that match the {@link NodeSelector}_this will return the dead node that matches the {@link NodeSelector}_that is closest to being revived._@throws IOException if no nodes are available;private NodeTuple<Iterator<Node>> nextNode() throws IOException {_        NodeTuple<List<Node>> nodeTuple = this.nodeTuple__        Iterable<Node> hosts = selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector)__        return new NodeTuple<>(hosts.iterator(), nodeTuple.authCache)__    };returns,a,non,empty,link,iterator,of,nodes,to,be,used,for,a,request,that,match,the,link,node,selector,p,if,there,are,no,living,nodes,that,match,the,link,node,selector,this,will,return,the,dead,node,that,matches,the,link,node,selector,that,is,closest,to,being,revived,throws,ioexception,if,no,nodes,are,available;private,node,tuple,iterator,node,next,node,throws,ioexception,node,tuple,list,node,node,tuple,this,node,tuple,iterable,node,hosts,select,nodes,node,tuple,blacklist,last,node,index,node,selector,return,new,node,tuple,hosts,iterator,node,tuple,auth,cache
RestClient -> private NodeTuple<Iterator<Node>> nextNode() throws IOException;1544364228;Returns a non-empty {@link Iterator} of nodes to be used for a request_that match the {@link NodeSelector}._<p>_If there are no living nodes that match the {@link NodeSelector}_this will return the dead node that matches the {@link NodeSelector}_that is closest to being revived._@throws IOException if no nodes are available;private NodeTuple<Iterator<Node>> nextNode() throws IOException {_        NodeTuple<List<Node>> nodeTuple = this.nodeTuple__        Iterable<Node> hosts = selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector)__        return new NodeTuple<>(hosts.iterator(), nodeTuple.authCache)__    };returns,a,non,empty,link,iterator,of,nodes,to,be,used,for,a,request,that,match,the,link,node,selector,p,if,there,are,no,living,nodes,that,match,the,link,node,selector,this,will,return,the,dead,node,that,matches,the,link,node,selector,that,is,closest,to,being,revived,throws,ioexception,if,no,nodes,are,available;private,node,tuple,iterator,node,next,node,throws,ioexception,node,tuple,list,node,node,tuple,this,node,tuple,iterable,node,hosts,select,nodes,node,tuple,blacklist,last,node,index,node,selector,return,new,node,tuple,hosts,iterator,node,tuple,auth,cache
RestClient -> private NodeTuple<Iterator<Node>> nextNode() throws IOException;1544448720;Returns a non-empty {@link Iterator} of nodes to be used for a request_that match the {@link NodeSelector}._<p>_If there are no living nodes that match the {@link NodeSelector}_this will return the dead node that matches the {@link NodeSelector}_that is closest to being revived._@throws IOException if no nodes are available;private NodeTuple<Iterator<Node>> nextNode() throws IOException {_        NodeTuple<List<Node>> nodeTuple = this.nodeTuple__        Iterable<Node> hosts = selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector)__        return new NodeTuple<>(hosts.iterator(), nodeTuple.authCache)__    };returns,a,non,empty,link,iterator,of,nodes,to,be,used,for,a,request,that,match,the,link,node,selector,p,if,there,are,no,living,nodes,that,match,the,link,node,selector,this,will,return,the,dead,node,that,matches,the,link,node,selector,that,is,closest,to,being,revived,throws,ioexception,if,no,nodes,are,available;private,node,tuple,iterator,node,next,node,throws,ioexception,node,tuple,list,node,node,tuple,this,node,tuple,iterable,node,hosts,select,nodes,node,tuple,blacklist,last,node,index,node,selector,return,new,node,tuple,hosts,iterator,node,tuple,auth,cache
RestClient -> private NodeTuple<Iterator<Node>> nextNode() throws IOException;1548457070;Returns a non-empty {@link Iterator} of nodes to be used for a request_that match the {@link NodeSelector}._<p>_If there are no living nodes that match the {@link NodeSelector}_this will return the dead node that matches the {@link NodeSelector}_that is closest to being revived._@throws IOException if no nodes are available;private NodeTuple<Iterator<Node>> nextNode() throws IOException {_        NodeTuple<List<Node>> nodeTuple = this.nodeTuple__        Iterable<Node> hosts = selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector)__        return new NodeTuple<>(hosts.iterator(), nodeTuple.authCache)__    };returns,a,non,empty,link,iterator,of,nodes,to,be,used,for,a,request,that,match,the,link,node,selector,p,if,there,are,no,living,nodes,that,match,the,link,node,selector,this,will,return,the,dead,node,that,matches,the,link,node,selector,that,is,closest,to,being,revived,throws,ioexception,if,no,nodes,are,available;private,node,tuple,iterator,node,next,node,throws,ioexception,node,tuple,list,node,node,tuple,this,node,tuple,iterable,node,hosts,select,nodes,node,tuple,blacklist,last,node,index,node,selector,return,new,node,tuple,hosts,iterator,node,tuple,auth,cache
RestClient -> private NodeTuple<Iterator<Node>> nextNode() throws IOException;1548869519;Returns a non-empty {@link Iterator} of nodes to be used for a request_that match the {@link NodeSelector}._<p>_If there are no living nodes that match the {@link NodeSelector}_this will return the dead node that matches the {@link NodeSelector}_that is closest to being revived._@throws IOException if no nodes are available;private NodeTuple<Iterator<Node>> nextNode() throws IOException {_        NodeTuple<List<Node>> nodeTuple = this.nodeTuple__        Iterable<Node> hosts = selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector)__        return new NodeTuple<>(hosts.iterator(), nodeTuple.authCache)__    };returns,a,non,empty,link,iterator,of,nodes,to,be,used,for,a,request,that,match,the,link,node,selector,p,if,there,are,no,living,nodes,that,match,the,link,node,selector,this,will,return,the,dead,node,that,matches,the,link,node,selector,that,is,closest,to,being,revived,throws,ioexception,if,no,nodes,are,available;private,node,tuple,iterator,node,next,node,throws,ioexception,node,tuple,list,node,node,tuple,this,node,tuple,iterable,node,hosts,select,nodes,node,tuple,blacklist,last,node,index,node,selector,return,new,node,tuple,hosts,iterator,node,tuple,auth,cache
RestClient -> private HostTuple<Iterator<HttpHost>> nextHost();1524684173;Returns an {@link Iterable} of hosts to be used for a request call._Ideally, the first host is retrieved from the iterable and used successfully for the request._Otherwise, after each failure the next host has to be retrieved from the iterator so that the request can be retried until_there are no more hosts available to retry against. The maximum total of attempts is equal to the number of hosts in the iterable._The iterator returned will never be empty. In case there are no healthy hosts available, or dead ones to be be retried,_one dead host gets returned so that it can be retried.;private HostTuple<Iterator<HttpHost>> nextHost() {_        final HostTuple<Set<HttpHost>> hostTuple = this.hostTuple__        Collection<HttpHost> nextHosts = Collections.emptySet()__        do {_            Set<HttpHost> filteredHosts = new HashSet<>(hostTuple.hosts)__            for (Map.Entry<HttpHost, DeadHostState> entry : blacklist.entrySet()) {_                if (entry.getValue().shallBeRetried() == false) {_                    filteredHosts.remove(entry.getKey())__                }_            }_            if (filteredHosts.isEmpty()) {_                _                List<Map.Entry<HttpHost, DeadHostState>> sortedHosts = new ArrayList<>(blacklist.entrySet())__                if (sortedHosts.size() > 0) {_                    Collections.sort(sortedHosts, new Comparator<Map.Entry<HttpHost, DeadHostState>>() {_                        @Override_                        public int compare(Map.Entry<HttpHost, DeadHostState> o1, Map.Entry<HttpHost, DeadHostState> o2) {_                            return o1.getValue().compareTo(o2.getValue())__                        }_                    })__                    HttpHost deadHost = sortedHosts.get(0).getKey()__                    logger.trace("resurrecting host [" + deadHost + "]")__                    nextHosts = Collections.singleton(deadHost)__                }_            } else {_                List<HttpHost> rotatedHosts = new ArrayList<>(filteredHosts)__                Collections.rotate(rotatedHosts, rotatedHosts.size() - lastHostIndex.getAndIncrement())__                nextHosts = rotatedHosts__            }_        } while(nextHosts.isEmpty())__        return new HostTuple<>(nextHosts.iterator(), hostTuple.authCache)__    };returns,an,link,iterable,of,hosts,to,be,used,for,a,request,call,ideally,the,first,host,is,retrieved,from,the,iterable,and,used,successfully,for,the,request,otherwise,after,each,failure,the,next,host,has,to,be,retrieved,from,the,iterator,so,that,the,request,can,be,retried,until,there,are,no,more,hosts,available,to,retry,against,the,maximum,total,of,attempts,is,equal,to,the,number,of,hosts,in,the,iterable,the,iterator,returned,will,never,be,empty,in,case,there,are,no,healthy,hosts,available,or,dead,ones,to,be,be,retried,one,dead,host,gets,returned,so,that,it,can,be,retried;private,host,tuple,iterator,http,host,next,host,final,host,tuple,set,http,host,host,tuple,this,host,tuple,collection,http,host,next,hosts,collections,empty,set,do,set,http,host,filtered,hosts,new,hash,set,host,tuple,hosts,for,map,entry,http,host,dead,host,state,entry,blacklist,entry,set,if,entry,get,value,shall,be,retried,false,filtered,hosts,remove,entry,get,key,if,filtered,hosts,is,empty,list,map,entry,http,host,dead,host,state,sorted,hosts,new,array,list,blacklist,entry,set,if,sorted,hosts,size,0,collections,sort,sorted,hosts,new,comparator,map,entry,http,host,dead,host,state,override,public,int,compare,map,entry,http,host,dead,host,state,o1,map,entry,http,host,dead,host,state,o2,return,o1,get,value,compare,to,o2,get,value,http,host,dead,host,sorted,hosts,get,0,get,key,logger,trace,resurrecting,host,dead,host,next,hosts,collections,singleton,dead,host,else,list,http,host,rotated,hosts,new,array,list,filtered,hosts,collections,rotate,rotated,hosts,rotated,hosts,size,last,host,index,get,and,increment,next,hosts,rotated,hosts,while,next,hosts,is,empty,return,new,host,tuple,next,hosts,iterator,host,tuple,auth,cache
RestClient -> private HostTuple<Iterator<HttpHost>> nextHost();1525248068;Returns an {@link Iterable} of hosts to be used for a request call._Ideally, the first host is retrieved from the iterable and used successfully for the request._Otherwise, after each failure the next host has to be retrieved from the iterator so that the request can be retried until_there are no more hosts available to retry against. The maximum total of attempts is equal to the number of hosts in the iterable._The iterator returned will never be empty. In case there are no healthy hosts available, or dead ones to be be retried,_one dead host gets returned so that it can be retried.;private HostTuple<Iterator<HttpHost>> nextHost() {_        final HostTuple<Set<HttpHost>> hostTuple = this.hostTuple__        Collection<HttpHost> nextHosts = Collections.emptySet()__        do {_            Set<HttpHost> filteredHosts = new HashSet<>(hostTuple.hosts)__            for (Map.Entry<HttpHost, DeadHostState> entry : blacklist.entrySet()) {_                if (entry.getValue().shallBeRetried() == false) {_                    filteredHosts.remove(entry.getKey())__                }_            }_            if (filteredHosts.isEmpty()) {_                _                List<Map.Entry<HttpHost, DeadHostState>> sortedHosts = new ArrayList<>(blacklist.entrySet())__                if (sortedHosts.size() > 0) {_                    Collections.sort(sortedHosts, new Comparator<Map.Entry<HttpHost, DeadHostState>>() {_                        @Override_                        public int compare(Map.Entry<HttpHost, DeadHostState> o1, Map.Entry<HttpHost, DeadHostState> o2) {_                            return o1.getValue().compareTo(o2.getValue())__                        }_                    })__                    HttpHost deadHost = sortedHosts.get(0).getKey()__                    logger.trace("resurrecting host [" + deadHost + "]")__                    nextHosts = Collections.singleton(deadHost)__                }_            } else {_                List<HttpHost> rotatedHosts = new ArrayList<>(filteredHosts)__                Collections.rotate(rotatedHosts, rotatedHosts.size() - lastHostIndex.getAndIncrement())__                nextHosts = rotatedHosts__            }_        } while(nextHosts.isEmpty())__        return new HostTuple<>(nextHosts.iterator(), hostTuple.authCache)__    };returns,an,link,iterable,of,hosts,to,be,used,for,a,request,call,ideally,the,first,host,is,retrieved,from,the,iterable,and,used,successfully,for,the,request,otherwise,after,each,failure,the,next,host,has,to,be,retrieved,from,the,iterator,so,that,the,request,can,be,retried,until,there,are,no,more,hosts,available,to,retry,against,the,maximum,total,of,attempts,is,equal,to,the,number,of,hosts,in,the,iterable,the,iterator,returned,will,never,be,empty,in,case,there,are,no,healthy,hosts,available,or,dead,ones,to,be,be,retried,one,dead,host,gets,returned,so,that,it,can,be,retried;private,host,tuple,iterator,http,host,next,host,final,host,tuple,set,http,host,host,tuple,this,host,tuple,collection,http,host,next,hosts,collections,empty,set,do,set,http,host,filtered,hosts,new,hash,set,host,tuple,hosts,for,map,entry,http,host,dead,host,state,entry,blacklist,entry,set,if,entry,get,value,shall,be,retried,false,filtered,hosts,remove,entry,get,key,if,filtered,hosts,is,empty,list,map,entry,http,host,dead,host,state,sorted,hosts,new,array,list,blacklist,entry,set,if,sorted,hosts,size,0,collections,sort,sorted,hosts,new,comparator,map,entry,http,host,dead,host,state,override,public,int,compare,map,entry,http,host,dead,host,state,o1,map,entry,http,host,dead,host,state,o2,return,o1,get,value,compare,to,o2,get,value,http,host,dead,host,sorted,hosts,get,0,get,key,logger,trace,resurrecting,host,dead,host,next,hosts,collections,singleton,dead,host,else,list,http,host,rotated,hosts,new,array,list,filtered,hosts,collections,rotate,rotated,hosts,rotated,hosts,size,last,host,index,get,and,increment,next,hosts,rotated,hosts,while,next,hosts,is,empty,return,new,host,tuple,next,hosts,iterator,host,tuple,auth,cache
RestClient -> private HostTuple<Iterator<HttpHost>> nextHost();1525859433;Returns an {@link Iterable} of hosts to be used for a request call._Ideally, the first host is retrieved from the iterable and used successfully for the request._Otherwise, after each failure the next host has to be retrieved from the iterator so that the request can be retried until_there are no more hosts available to retry against. The maximum total of attempts is equal to the number of hosts in the iterable._The iterator returned will never be empty. In case there are no healthy hosts available, or dead ones to be be retried,_one dead host gets returned so that it can be retried.;private HostTuple<Iterator<HttpHost>> nextHost() {_        final HostTuple<Set<HttpHost>> hostTuple = this.hostTuple__        Collection<HttpHost> nextHosts = Collections.emptySet()__        do {_            Set<HttpHost> filteredHosts = new HashSet<>(hostTuple.hosts)__            for (Map.Entry<HttpHost, DeadHostState> entry : blacklist.entrySet()) {_                if (entry.getValue().shallBeRetried() == false) {_                    filteredHosts.remove(entry.getKey())__                }_            }_            if (filteredHosts.isEmpty()) {_                _                List<Map.Entry<HttpHost, DeadHostState>> sortedHosts = new ArrayList<>(blacklist.entrySet())__                if (sortedHosts.size() > 0) {_                    Collections.sort(sortedHosts, new Comparator<Map.Entry<HttpHost, DeadHostState>>() {_                        @Override_                        public int compare(Map.Entry<HttpHost, DeadHostState> o1, Map.Entry<HttpHost, DeadHostState> o2) {_                            return o1.getValue().compareTo(o2.getValue())__                        }_                    })__                    HttpHost deadHost = sortedHosts.get(0).getKey()__                    logger.trace("resurrecting host [" + deadHost + "]")__                    nextHosts = Collections.singleton(deadHost)__                }_            } else {_                List<HttpHost> rotatedHosts = new ArrayList<>(filteredHosts)__                Collections.rotate(rotatedHosts, rotatedHosts.size() - lastHostIndex.getAndIncrement())__                nextHosts = rotatedHosts__            }_        } while(nextHosts.isEmpty())__        return new HostTuple<>(nextHosts.iterator(), hostTuple.authCache)__    };returns,an,link,iterable,of,hosts,to,be,used,for,a,request,call,ideally,the,first,host,is,retrieved,from,the,iterable,and,used,successfully,for,the,request,otherwise,after,each,failure,the,next,host,has,to,be,retrieved,from,the,iterator,so,that,the,request,can,be,retried,until,there,are,no,more,hosts,available,to,retry,against,the,maximum,total,of,attempts,is,equal,to,the,number,of,hosts,in,the,iterable,the,iterator,returned,will,never,be,empty,in,case,there,are,no,healthy,hosts,available,or,dead,ones,to,be,be,retried,one,dead,host,gets,returned,so,that,it,can,be,retried;private,host,tuple,iterator,http,host,next,host,final,host,tuple,set,http,host,host,tuple,this,host,tuple,collection,http,host,next,hosts,collections,empty,set,do,set,http,host,filtered,hosts,new,hash,set,host,tuple,hosts,for,map,entry,http,host,dead,host,state,entry,blacklist,entry,set,if,entry,get,value,shall,be,retried,false,filtered,hosts,remove,entry,get,key,if,filtered,hosts,is,empty,list,map,entry,http,host,dead,host,state,sorted,hosts,new,array,list,blacklist,entry,set,if,sorted,hosts,size,0,collections,sort,sorted,hosts,new,comparator,map,entry,http,host,dead,host,state,override,public,int,compare,map,entry,http,host,dead,host,state,o1,map,entry,http,host,dead,host,state,o2,return,o1,get,value,compare,to,o2,get,value,http,host,dead,host,sorted,hosts,get,0,get,key,logger,trace,resurrecting,host,dead,host,next,hosts,collections,singleton,dead,host,else,list,http,host,rotated,hosts,new,array,list,filtered,hosts,collections,rotate,rotated,hosts,rotated,hosts,size,last,host,index,get,and,increment,next,hosts,rotated,hosts,while,next,hosts,is,empty,return,new,host,tuple,next,hosts,iterator,host,tuple,auth,cache
RestClient -> private HostTuple<Iterator<HttpHost>> nextHost();1527096592;Returns an {@link Iterable} of hosts to be used for a request call._Ideally, the first host is retrieved from the iterable and used successfully for the request._Otherwise, after each failure the next host has to be retrieved from the iterator so that the request can be retried until_there are no more hosts available to retry against. The maximum total of attempts is equal to the number of hosts in the iterable._The iterator returned will never be empty. In case there are no healthy hosts available, or dead ones to be be retried,_one dead host gets returned so that it can be retried.;private HostTuple<Iterator<HttpHost>> nextHost() {_        final HostTuple<Set<HttpHost>> hostTuple = this.hostTuple__        Collection<HttpHost> nextHosts = Collections.emptySet()__        do {_            Set<HttpHost> filteredHosts = new HashSet<>(hostTuple.hosts)__            for (Map.Entry<HttpHost, DeadHostState> entry : blacklist.entrySet()) {_                if (entry.getValue().shallBeRetried() == false) {_                    filteredHosts.remove(entry.getKey())__                }_            }_            if (filteredHosts.isEmpty()) {_                _                List<Map.Entry<HttpHost, DeadHostState>> sortedHosts = new ArrayList<>(blacklist.entrySet())__                if (sortedHosts.size() > 0) {_                    Collections.sort(sortedHosts, new Comparator<Map.Entry<HttpHost, DeadHostState>>() {_                        @Override_                        public int compare(Map.Entry<HttpHost, DeadHostState> o1, Map.Entry<HttpHost, DeadHostState> o2) {_                            return o1.getValue().compareTo(o2.getValue())__                        }_                    })__                    HttpHost deadHost = sortedHosts.get(0).getKey()__                    logger.trace("resurrecting host [" + deadHost + "]")__                    nextHosts = Collections.singleton(deadHost)__                }_            } else {_                List<HttpHost> rotatedHosts = new ArrayList<>(filteredHosts)__                Collections.rotate(rotatedHosts, rotatedHosts.size() - lastHostIndex.getAndIncrement())__                nextHosts = rotatedHosts__            }_        } while(nextHosts.isEmpty())__        return new HostTuple<>(nextHosts.iterator(), hostTuple.authCache)__    };returns,an,link,iterable,of,hosts,to,be,used,for,a,request,call,ideally,the,first,host,is,retrieved,from,the,iterable,and,used,successfully,for,the,request,otherwise,after,each,failure,the,next,host,has,to,be,retrieved,from,the,iterator,so,that,the,request,can,be,retried,until,there,are,no,more,hosts,available,to,retry,against,the,maximum,total,of,attempts,is,equal,to,the,number,of,hosts,in,the,iterable,the,iterator,returned,will,never,be,empty,in,case,there,are,no,healthy,hosts,available,or,dead,ones,to,be,be,retried,one,dead,host,gets,returned,so,that,it,can,be,retried;private,host,tuple,iterator,http,host,next,host,final,host,tuple,set,http,host,host,tuple,this,host,tuple,collection,http,host,next,hosts,collections,empty,set,do,set,http,host,filtered,hosts,new,hash,set,host,tuple,hosts,for,map,entry,http,host,dead,host,state,entry,blacklist,entry,set,if,entry,get,value,shall,be,retried,false,filtered,hosts,remove,entry,get,key,if,filtered,hosts,is,empty,list,map,entry,http,host,dead,host,state,sorted,hosts,new,array,list,blacklist,entry,set,if,sorted,hosts,size,0,collections,sort,sorted,hosts,new,comparator,map,entry,http,host,dead,host,state,override,public,int,compare,map,entry,http,host,dead,host,state,o1,map,entry,http,host,dead,host,state,o2,return,o1,get,value,compare,to,o2,get,value,http,host,dead,host,sorted,hosts,get,0,get,key,logger,trace,resurrecting,host,dead,host,next,hosts,collections,singleton,dead,host,else,list,http,host,rotated,hosts,new,array,list,filtered,hosts,collections,rotate,rotated,hosts,rotated,hosts,size,last,host,index,get,and,increment,next,hosts,rotated,hosts,while,next,hosts,is,empty,return,new,host,tuple,next,hosts,iterator,host,tuple,auth,cache
RestClient -> private HostTuple<Iterator<HttpHost>> nextHost();1527840262;Returns an {@link Iterable} of hosts to be used for a request call._Ideally, the first host is retrieved from the iterable and used successfully for the request._Otherwise, after each failure the next host has to be retrieved from the iterator so that the request can be retried until_there are no more hosts available to retry against. The maximum total of attempts is equal to the number of hosts in the iterable._The iterator returned will never be empty. In case there are no healthy hosts available, or dead ones to be be retried,_one dead host gets returned so that it can be retried.;private HostTuple<Iterator<HttpHost>> nextHost() {_        final HostTuple<Set<HttpHost>> hostTuple = this.hostTuple__        Collection<HttpHost> nextHosts = Collections.emptySet()__        do {_            Set<HttpHost> filteredHosts = new HashSet<>(hostTuple.hosts)__            for (Map.Entry<HttpHost, DeadHostState> entry : blacklist.entrySet()) {_                if (entry.getValue().shallBeRetried() == false) {_                    filteredHosts.remove(entry.getKey())__                }_            }_            if (filteredHosts.isEmpty()) {_                _                List<Map.Entry<HttpHost, DeadHostState>> sortedHosts = new ArrayList<>(blacklist.entrySet())__                if (sortedHosts.size() > 0) {_                    Collections.sort(sortedHosts, new Comparator<Map.Entry<HttpHost, DeadHostState>>() {_                        @Override_                        public int compare(Map.Entry<HttpHost, DeadHostState> o1, Map.Entry<HttpHost, DeadHostState> o2) {_                            return o1.getValue().compareTo(o2.getValue())__                        }_                    })__                    HttpHost deadHost = sortedHosts.get(0).getKey()__                    logger.trace("resurrecting host [" + deadHost + "]")__                    nextHosts = Collections.singleton(deadHost)__                }_            } else {_                List<HttpHost> rotatedHosts = new ArrayList<>(filteredHosts)__                Collections.rotate(rotatedHosts, rotatedHosts.size() - lastHostIndex.getAndIncrement())__                nextHosts = rotatedHosts__            }_        } while(nextHosts.isEmpty())__        return new HostTuple<>(nextHosts.iterator(), hostTuple.authCache)__    };returns,an,link,iterable,of,hosts,to,be,used,for,a,request,call,ideally,the,first,host,is,retrieved,from,the,iterable,and,used,successfully,for,the,request,otherwise,after,each,failure,the,next,host,has,to,be,retrieved,from,the,iterator,so,that,the,request,can,be,retried,until,there,are,no,more,hosts,available,to,retry,against,the,maximum,total,of,attempts,is,equal,to,the,number,of,hosts,in,the,iterable,the,iterator,returned,will,never,be,empty,in,case,there,are,no,healthy,hosts,available,or,dead,ones,to,be,be,retried,one,dead,host,gets,returned,so,that,it,can,be,retried;private,host,tuple,iterator,http,host,next,host,final,host,tuple,set,http,host,host,tuple,this,host,tuple,collection,http,host,next,hosts,collections,empty,set,do,set,http,host,filtered,hosts,new,hash,set,host,tuple,hosts,for,map,entry,http,host,dead,host,state,entry,blacklist,entry,set,if,entry,get,value,shall,be,retried,false,filtered,hosts,remove,entry,get,key,if,filtered,hosts,is,empty,list,map,entry,http,host,dead,host,state,sorted,hosts,new,array,list,blacklist,entry,set,if,sorted,hosts,size,0,collections,sort,sorted,hosts,new,comparator,map,entry,http,host,dead,host,state,override,public,int,compare,map,entry,http,host,dead,host,state,o1,map,entry,http,host,dead,host,state,o2,return,o1,get,value,compare,to,o2,get,value,http,host,dead,host,sorted,hosts,get,0,get,key,logger,trace,resurrecting,host,dead,host,next,hosts,collections,singleton,dead,host,else,list,http,host,rotated,hosts,new,array,list,filtered,hosts,collections,rotate,rotated,hosts,rotated,hosts,size,last,host,index,get,and,increment,next,hosts,rotated,hosts,while,next,hosts,is,empty,return,new,host,tuple,next,hosts,iterator,host,tuple,auth,cache
RestClient -> public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException;1524684173;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException {_        return performRequest(method, endpoint, params, (HttpEntity)null, headers)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,string,method,string,endpoint,map,string,string,params,header,headers,throws,ioexception,return,perform,request,method,endpoint,params,http,entity,null,headers
RestClient -> public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException;1525248068;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(String method, String endpoint, Map<String, String> params, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setHeaders(headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,string,method,string,endpoint,map,string,string,params,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,headers,headers,return,perform,request,request
RestClient -> static List<Node> selectHosts(NodeTuple<List<Node>> nodeTuple,             Map<HttpHost, DeadHostState> blacklist, AtomicInteger lastNodeIndex,             NodeSelector nodeSelector) throws IOException;1528762805;Select hosts to try. Package private for testing.;static List<Node> selectHosts(NodeTuple<List<Node>> nodeTuple,_            Map<HttpHost, DeadHostState> blacklist, AtomicInteger lastNodeIndex,_            NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(nodeTuple.nodes.size() - blacklist.size())__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,hosts,to,try,package,private,for,testing;static,list,node,select,hosts,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> static List<Node> selectHosts(NodeTuple<List<Node>> nodeTuple,             Map<HttpHost, DeadHostState> blacklist, AtomicInteger lastNodeIndex,             NodeSelector nodeSelector) throws IOException;1529687475;Select hosts to try. Package private for testing.;static List<Node> selectHosts(NodeTuple<List<Node>> nodeTuple,_            Map<HttpHost, DeadHostState> blacklist, AtomicInteger lastNodeIndex,_            NodeSelector nodeSelector) throws IOException {_        _        List<Node> livingNodes = new ArrayList<>(nodeTuple.nodes.size() - blacklist.size())__        List<DeadNode> deadNodes = new ArrayList<>(blacklist.size())__        for (Node node : nodeTuple.nodes) {_            DeadHostState deadness = blacklist.get(node.getHost())__            if (deadness == null) {_                livingNodes.add(node)__                continue__            }_            if (deadness.shallBeRetried()) {_                livingNodes.add(node)__                continue__            }_            deadNodes.add(new DeadNode(node, deadness))__        }__        if (false == livingNodes.isEmpty()) {_            _            List<Node> selectedLivingNodes = new ArrayList<>(livingNodes)__            nodeSelector.select(selectedLivingNodes)__            if (false == selectedLivingNodes.isEmpty()) {_                _                Collections.rotate(selectedLivingNodes, lastNodeIndex.getAndIncrement())__                return selectedLivingNodes__            }_        }__        _        if (false == deadNodes.isEmpty()) {_            final List<DeadNode> selectedDeadNodes = new ArrayList<>(deadNodes)__            _            nodeSelector.select(new Iterable<Node>() {_                @Override_                public Iterator<Node> iterator() {_                    return new DeadNodeIteratorAdapter(selectedDeadNodes.iterator())__                }_            })__            if (false == selectedDeadNodes.isEmpty()) {_                return singletonList(Collections.min(selectedDeadNodes).node)__            }_        }_        throw new IOException("NodeSelector [" + nodeSelector + "] rejected all nodes, "_                + "living " + livingNodes + " and dead " + deadNodes)__    };select,hosts,to,try,package,private,for,testing;static,list,node,select,hosts,node,tuple,list,node,node,tuple,map,http,host,dead,host,state,blacklist,atomic,integer,last,node,index,node,selector,node,selector,throws,ioexception,list,node,living,nodes,new,array,list,node,tuple,nodes,size,blacklist,size,list,dead,node,dead,nodes,new,array,list,blacklist,size,for,node,node,node,tuple,nodes,dead,host,state,deadness,blacklist,get,node,get,host,if,deadness,null,living,nodes,add,node,continue,if,deadness,shall,be,retried,living,nodes,add,node,continue,dead,nodes,add,new,dead,node,node,deadness,if,false,living,nodes,is,empty,list,node,selected,living,nodes,new,array,list,living,nodes,node,selector,select,selected,living,nodes,if,false,selected,living,nodes,is,empty,collections,rotate,selected,living,nodes,last,node,index,get,and,increment,return,selected,living,nodes,if,false,dead,nodes,is,empty,final,list,dead,node,selected,dead,nodes,new,array,list,dead,nodes,node,selector,select,new,iterable,node,override,public,iterator,node,iterator,return,new,dead,node,iterator,adapter,selected,dead,nodes,iterator,if,false,selected,dead,nodes,is,empty,return,singleton,list,collections,min,selected,dead,nodes,node,throw,new,ioexception,node,selector,node,selector,rejected,all,nodes,living,living,nodes,and,dead,dead,nodes
RestClient -> public Response performRequest(String method, String endpoint, Header... headers) throws IOException;1524684173;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without parameters_and request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(String method, String endpoint, Header... headers) throws IOException {_        return performRequest(method, endpoint, Collections.<String, String>emptyMap(), null, headers)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,string,method,string,endpoint,header,headers,throws,ioexception,return,perform,request,method,endpoint,collections,string,string,empty,map,null,headers
RestClient -> public Response performRequest(String method, String endpoint, Header... headers) throws IOException;1525248068;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without parameters_and request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(String method, String endpoint, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        request.setHeaders(headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,string,method,string,endpoint,header,headers,throws,ioexception,request,request,new,request,method,endpoint,request,set,headers,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, Header... headers) throws IOException;1525859433;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, Header...)}_which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        request.setHeaders(headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,http,async,response,consumer,factory,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,headers,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, Header... headers) throws IOException;1527096592;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, Header...)}_which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,http,async,response,consumer,factory,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, Header... headers) throws IOException;1527840262;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, Header...)}_which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,http,async,response,consumer,factory,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, Header... headers) throws IOException;1528762805;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, Header...)}_which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,http,async,response,consumer,factory,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, Header... headers) throws IOException;1529687475;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, Header...)}_which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,http,async,response,consumer,factory,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, Header... headers) throws IOException;1531179852;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, Header...)}_which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,http,async,response,consumer,factory,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,add,headers,request,headers,return,perform,request,request
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1524684173;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to.;public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hosts)__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1525248068;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to.;public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hosts)__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1525859433;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to.;public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hosts)__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1527096592;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to.;public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hosts)__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1527840262;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the hosts that the client will send requests to.;public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hosts)__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,hosts,that,the,client,will,send,requests,to;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1528762805;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1529687475;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1531179852;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1535965276;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1538170812;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1544364228;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1544448720;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1548457070;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1548869519;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> public static RestClientBuilder builder(HttpHost... hosts);1549439027;Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation._Creates a new builder instance and sets the nodes that the client will send requests to._<p>_You can use this if you do not have metadata up front about the nodes. If you do, prefer_{@link #builder(Node...)}._@see Node#Node(HttpHost);public static RestClientBuilder builder(HttpHost... hosts) {_        return new RestClientBuilder(hostsToNodes(hosts))__    };returns,a,new,link,rest,client,builder,to,help,with,link,rest,client,creation,creates,a,new,builder,instance,and,sets,the,nodes,that,the,client,will,send,requests,to,p,you,can,use,this,if,you,do,not,have,metadata,up,front,about,the,nodes,if,you,do,prefer,link,builder,node,see,node,node,http,host;public,static,rest,client,builder,builder,http,host,hosts,return,new,rest,client,builder,hosts,to,nodes,hosts
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                    Header... headers) throws IOException;1525859433;Sends a request to the Elasticsearch cluster that the client points to. Blocks until the request is completed and returns_its response or fails by throwing an exception. Selects a host out of the provided ones in a round-robin fashion. Failing hosts_are marked dead and retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times_they previously failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                   Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        request.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__        request.setHeaders(headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,http,async,response,consumer,factory,http,async,response,consumer,factory,request,set,headers,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                    Header... headers) throws IOException;1527096592;Sends a request to the Elasticsearch cluster that the client points to. Blocks until the request is completed and returns_its response or fails by throwing an exception. Selects a host out of the provided ones in a round-robin fashion. Failing hosts_are marked dead and retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times_they previously failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                   Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        request.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,http,async,response,consumer,factory,http,async,response,consumer,factory,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                    Header... headers) throws IOException;1527840262;Sends a request to the Elasticsearch cluster that the client points to. Blocks until the request is completed and returns_its response or fails by throwing an exception. Selects a host out of the provided ones in a round-robin fashion. Failing hosts_are marked dead and retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times_they previously failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                   Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        setOptions(request, httpAsyncResponseConsumerFactory, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,set,options,request,http,async,response,consumer,factory,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                    Header... headers) throws IOException;1528762805;Sends a request to the Elasticsearch cluster that the client points to. Blocks until the request is completed and returns_its response or fails by throwing an exception. Selects a host out of the provided ones in a round-robin fashion. Failing hosts_are marked dead and retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times_they previously failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                   Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        setOptions(request, httpAsyncResponseConsumerFactory, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,set,options,request,http,async,response,consumer,factory,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                    Header... headers) throws IOException;1529687475;Sends a request to the Elasticsearch cluster that the client points to. Blocks until the request is completed and returns_its response or fails by throwing an exception. Selects a host out of the provided ones in a round-robin fashion. Failing hosts_are marked dead and retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times_they previously failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                   Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        setOptions(request, httpAsyncResponseConsumerFactory, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,set,options,request,http,async,response,consumer,factory,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,                                    Header... headers) throws IOException;1531179852;Sends a request to the Elasticsearch cluster that the client points to. Blocks until the request is completed and returns_its response or fails by throwing an exception. Selects a host out of the provided ones in a round-robin fashion. Failing hosts_are marked dead and retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times_they previously failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param httpAsyncResponseConsumerFactory the {@link HttpAsyncResponseConsumerFactory} used to create one_{@link HttpAsyncResponseConsumer} callback per retry. Controls how the response body gets streamed from a non-blocking HTTP_connection on the client side._@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_                                   Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        setOptions(request, httpAsyncResponseConsumerFactory, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,http,async,response,consumer,factory,the,link,http,async,response,consumer,factory,used,to,create,one,link,http,async,response,consumer,callback,per,retry,controls,how,the,response,body,gets,streamed,from,a,non,blocking,http,connection,on,the,client,side,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,set,options,request,http,async,response,consumer,factory,headers,return,perform,request,request
RestClient -> @Deprecated     private static void addParameters(Request request, Map<String, String> parameters);1527096592;Add all parameters from a map to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addParameters(Request request, Map<String, String> parameters) {_        Objects.requireNonNull(parameters, "parameters cannot be null")__        for (Map.Entry<String, String> entry : parameters.entrySet()) {_            request.addParameter(entry.getKey(), entry.getValue())__        }_    };add,all,parameters,from,a,map,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,parameters,request,request,map,string,string,parameters,objects,require,non,null,parameters,parameters,cannot,be,null,for,map,entry,string,string,entry,parameters,entry,set,request,add,parameter,entry,get,key,entry,get,value
RestClient -> @Deprecated     private static void addParameters(Request request, Map<String, String> parameters);1527840262;Add all parameters from a map to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addParameters(Request request, Map<String, String> parameters) {_        Objects.requireNonNull(parameters, "parameters cannot be null")__        for (Map.Entry<String, String> entry : parameters.entrySet()) {_            request.addParameter(entry.getKey(), entry.getValue())__        }_    };add,all,parameters,from,a,map,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,parameters,request,request,map,string,string,parameters,objects,require,non,null,parameters,parameters,cannot,be,null,for,map,entry,string,string,entry,parameters,entry,set,request,add,parameter,entry,get,key,entry,get,value
RestClient -> @Deprecated     private static void addParameters(Request request, Map<String, String> parameters);1528762805;Add all parameters from a map to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addParameters(Request request, Map<String, String> parameters) {_        Objects.requireNonNull(parameters, "parameters cannot be null")__        for (Map.Entry<String, String> entry : parameters.entrySet()) {_            request.addParameter(entry.getKey(), entry.getValue())__        }_    };add,all,parameters,from,a,map,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,parameters,request,request,map,string,string,parameters,objects,require,non,null,parameters,parameters,cannot,be,null,for,map,entry,string,string,entry,parameters,entry,set,request,add,parameter,entry,get,key,entry,get,value
RestClient -> @Deprecated     private static void addParameters(Request request, Map<String, String> parameters);1529687475;Add all parameters from a map to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addParameters(Request request, Map<String, String> parameters) {_        Objects.requireNonNull(parameters, "parameters cannot be null")__        for (Map.Entry<String, String> entry : parameters.entrySet()) {_            request.addParameter(entry.getKey(), entry.getValue())__        }_    };add,all,parameters,from,a,map,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,parameters,request,request,map,string,string,parameters,objects,require,non,null,parameters,parameters,cannot,be,null,for,map,entry,string,string,entry,parameters,entry,set,request,add,parameter,entry,get,key,entry,get,value
RestClient -> @Deprecated     private static void addParameters(Request request, Map<String, String> parameters);1531179852;Add all parameters from a map to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addParameters(Request request, Map<String, String> parameters) {_        Objects.requireNonNull(parameters, "parameters cannot be null")__        for (Map.Entry<String, String> entry : parameters.entrySet()) {_            request.addParameter(entry.getKey(), entry.getValue())__        }_    };add,all,parameters,from,a,map,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,parameters,request,request,map,string,string,parameters,objects,require,non,null,parameters,parameters,cannot,be,null,for,map,entry,string,string,entry,parameters,entry,set,request,add,parameter,entry,get,key,entry,get,value
RestClient -> FailureListener -> public void onFailure(HttpHost host);1524684173;Notifies that the host provided as argument has just failed;public void onFailure(HttpHost host) {__        };notifies,that,the,host,provided,as,argument,has,just,failed;public,void,on,failure,http,host,host
RestClient -> FailureListener -> public void onFailure(HttpHost host);1525248068;Notifies that the host provided as argument has just failed;public void onFailure(HttpHost host) {__        };notifies,that,the,host,provided,as,argument,has,just,failed;public,void,on,failure,http,host,host
RestClient -> FailureListener -> public void onFailure(HttpHost host);1525859433;Notifies that the host provided as argument has just failed;public void onFailure(HttpHost host) {__        };notifies,that,the,host,provided,as,argument,has,just,failed;public,void,on,failure,http,host,host
RestClient -> FailureListener -> public void onFailure(HttpHost host);1527096592;Notifies that the host provided as argument has just failed;public void onFailure(HttpHost host) {__        };notifies,that,the,host,provided,as,argument,has,just,failed;public,void,on,failure,http,host,host
RestClient -> FailureListener -> public void onFailure(HttpHost host);1527840262;Notifies that the host provided as argument has just failed;public void onFailure(HttpHost host) {__        };notifies,that,the,host,provided,as,argument,has,just,failed;public,void,on,failure,http,host,host
RestClient -> SyncResponseListener -> Response get() throws IOException;1524684173;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1525248068;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1525859433;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1527096592;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1527840262;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1528762805;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectException) {_                    ConnectException e = new ConnectException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connect,exception,connect,exception,e,new,connect,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1529687475;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectException) {_                    ConnectException e = new ConnectException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connect,exception,connect,exception,e,new,connect,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1531179852;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectException) {_                    ConnectException e = new ConnectException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connect,exception,connect,exception,e,new,connect,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1535965276;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectException) {_                    ConnectException e = new ConnectException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connect,exception,connect,exception,e,new,connect,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1538170812;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectException) {_                    ConnectException e = new ConnectException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connect,exception,connect,exception,e,new,connect,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1544364228;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectException) {_                    ConnectException e = new ConnectException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connect,exception,connect,exception,e,new,connect,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1544448720;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectException) {_                    ConnectException e = new ConnectException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connect,exception,connect,exception,e,new,connect,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1548457070;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectException) {_                    ConnectException e = new ConnectException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connect,exception,connect,exception,e,new,connect,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> SyncResponseListener -> Response get() throws IOException;1548869519;Waits (up to a timeout) for some result of the request: either a response, or an exception.;Response get() throws IOException {_            try {_                _                _                if (latch.await(timeout, TimeUnit.MILLISECONDS) == false) {_                    throw new IOException("listener timeout after waiting for [" + timeout + "] ms")__                }_            } catch (InterruptedException e) {_                throw new RuntimeException("thread waiting for the response was interrupted", e)__            }__            Exception exception = this.exception.get()__            Response response = this.response.get()__            if (exception != null) {_                if (response != null) {_                    IllegalStateException e = new IllegalStateException("response and exception are unexpectedly set at the same time")__                    e.addSuppressed(exception)__                    throw e__                }_                _                if (exception instanceof WarningFailureException) {_                    throw new WarningFailureException((WarningFailureException) exception)__                }_                if (exception instanceof ResponseException) {_                    throw new ResponseException((ResponseException) exception)__                }_                if (exception instanceof ConnectTimeoutException) {_                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SocketTimeoutException) {_                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectionClosedException) {_                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof SSLHandshakeException) {_                    SSLHandshakeException e = new SSLHandshakeException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof ConnectException) {_                    ConnectException e = new ConnectException(exception.getMessage())__                    e.initCause(exception)__                    throw e__                }_                if (exception instanceof IOException) {_                    throw new IOException(exception.getMessage(), exception)__                }_                if (exception instanceof RuntimeException){_                    throw new RuntimeException(exception.getMessage(), exception)__                }_                throw new RuntimeException("error while performing request", exception)__            }__            if (response == null) {_                throw new IllegalStateException("response not set and no exception caught either")__            }_            return response__        };waits,up,to,a,timeout,for,some,result,of,the,request,either,a,response,or,an,exception;response,get,throws,ioexception,try,if,latch,await,timeout,time,unit,milliseconds,false,throw,new,ioexception,listener,timeout,after,waiting,for,timeout,ms,catch,interrupted,exception,e,throw,new,runtime,exception,thread,waiting,for,the,response,was,interrupted,e,exception,exception,this,exception,get,response,response,this,response,get,if,exception,null,if,response,null,illegal,state,exception,e,new,illegal,state,exception,response,and,exception,are,unexpectedly,set,at,the,same,time,e,add,suppressed,exception,throw,e,if,exception,instanceof,warning,failure,exception,throw,new,warning,failure,exception,warning,failure,exception,exception,if,exception,instanceof,response,exception,throw,new,response,exception,response,exception,exception,if,exception,instanceof,connect,timeout,exception,connect,timeout,exception,e,new,connect,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,socket,timeout,exception,socket,timeout,exception,e,new,socket,timeout,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connection,closed,exception,connection,closed,exception,e,new,connection,closed,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,sslhandshake,exception,sslhandshake,exception,e,new,sslhandshake,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,connect,exception,connect,exception,e,new,connect,exception,exception,get,message,e,init,cause,exception,throw,e,if,exception,instanceof,ioexception,throw,new,ioexception,exception,get,message,exception,if,exception,instanceof,runtime,exception,throw,new,runtime,exception,exception,get,message,exception,throw,new,runtime,exception,error,while,performing,request,exception,if,response,null,throw,new,illegal,state,exception,response,not,set,and,no,exception,caught,either,return,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1524684173;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1525248068;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1525859433;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1527096592;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1527840262;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1528762805;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1529687475;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1531179852;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1535965276;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1538170812;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1544364228;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1544448720;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1548457070;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1548869519;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> FailureTrackingResponseListener -> void onSuccess(Response response);1549439027;Notifies the caller of a response through the wrapped listener;void onSuccess(Response response) {_            responseListener.onSuccess(response)__        };notifies,the,caller,of,a,response,through,the,wrapped,listener;void,on,success,response,response,response,listener,on,success,response
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     ResponseListener responseListener, Header... headers);1525859433;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setHeaders(headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,headers,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     ResponseListener responseListener, Header... headers);1527096592;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     ResponseListener responseListener, Header... headers);1527840262;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     ResponseListener responseListener, Header... headers);1528762805;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     ResponseListener responseListener, Header... headers);1529687475;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     ResponseListener responseListener, Header... headers);1531179852;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers_@deprecated prefer {@link #performRequestAsync(Request, ResponseListener)};@Deprecated_    public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            addHeaders(request, headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers,deprecated,prefer,link,perform,request,async,request,response,listener;deprecated,public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,add,headers,request,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> private void onResponse(HttpHost host);1524684173;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(HttpHost host) {_        DeadHostState removedHost = this.blacklist.remove(host)__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed host [" + host + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,http,host,host,dead,host,state,removed,host,this,blacklist,remove,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,host,host,from,blacklist
RestClient -> private void onResponse(HttpHost host);1525248068;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(HttpHost host) {_        DeadHostState removedHost = this.blacklist.remove(host)__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed host [" + host + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,http,host,host,dead,host,state,removed,host,this,blacklist,remove,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,host,host,from,blacklist
RestClient -> private void onResponse(HttpHost host);1525859433;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(HttpHost host) {_        DeadHostState removedHost = this.blacklist.remove(host)__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed host [" + host + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,http,host,host,dead,host,state,removed,host,this,blacklist,remove,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,host,host,from,blacklist
RestClient -> private void onResponse(HttpHost host);1527096592;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(HttpHost host) {_        DeadHostState removedHost = this.blacklist.remove(host)__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed host [" + host + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,http,host,host,dead,host,state,removed,host,this,blacklist,remove,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,host,host,from,blacklist
RestClient -> private void onResponse(HttpHost host);1527840262;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(HttpHost host) {_        DeadHostState removedHost = this.blacklist.remove(host)__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed host [" + host + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,http,host,host,dead,host,state,removed,host,this,blacklist,remove,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,host,host,from,blacklist
RestClient -> private void onFailure(HttpHost host);1524684173;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(HttpHost host) {_        while(true) {_            DeadHostState previousDeadHostState = blacklist.putIfAbsent(host, new DeadHostState(DeadHostState.TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                logger.debug("added host [" + host + "] to blacklist")__                break__            }_            if (blacklist.replace(host, previousDeadHostState,_                    new DeadHostState(previousDeadHostState, DeadHostState.TimeSupplier.DEFAULT))) {_                logger.debug("updated host [" + host + "] already in blacklist")__                break__            }_        }_        failureListener.onFailure(host)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,http,host,host,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,host,new,dead,host,state,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,logger,debug,added,host,host,to,blacklist,break,if,blacklist,replace,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,dead,host,state,time,supplier,default,logger,debug,updated,host,host,already,in,blacklist,break,failure,listener,on,failure,host
RestClient -> private void onFailure(HttpHost host);1525248068;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(HttpHost host) {_        while(true) {_            DeadHostState previousDeadHostState = blacklist.putIfAbsent(host, new DeadHostState(DeadHostState.TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                logger.debug("added host [" + host + "] to blacklist")__                break__            }_            if (blacklist.replace(host, previousDeadHostState,_                    new DeadHostState(previousDeadHostState, DeadHostState.TimeSupplier.DEFAULT))) {_                logger.debug("updated host [" + host + "] already in blacklist")__                break__            }_        }_        failureListener.onFailure(host)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,http,host,host,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,host,new,dead,host,state,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,logger,debug,added,host,host,to,blacklist,break,if,blacklist,replace,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,dead,host,state,time,supplier,default,logger,debug,updated,host,host,already,in,blacklist,break,failure,listener,on,failure,host
RestClient -> private void onFailure(HttpHost host);1525859433;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(HttpHost host) {_        while(true) {_            DeadHostState previousDeadHostState = blacklist.putIfAbsent(host, new DeadHostState(DeadHostState.TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                logger.debug("added host [" + host + "] to blacklist")__                break__            }_            if (blacklist.replace(host, previousDeadHostState,_                    new DeadHostState(previousDeadHostState, DeadHostState.TimeSupplier.DEFAULT))) {_                logger.debug("updated host [" + host + "] already in blacklist")__                break__            }_        }_        failureListener.onFailure(host)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,http,host,host,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,host,new,dead,host,state,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,logger,debug,added,host,host,to,blacklist,break,if,blacklist,replace,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,dead,host,state,time,supplier,default,logger,debug,updated,host,host,already,in,blacklist,break,failure,listener,on,failure,host
RestClient -> private void onFailure(HttpHost host);1527096592;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(HttpHost host) {_        while(true) {_            DeadHostState previousDeadHostState = blacklist.putIfAbsent(host, new DeadHostState(DeadHostState.TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                logger.debug("added host [" + host + "] to blacklist")__                break__            }_            if (blacklist.replace(host, previousDeadHostState,_                    new DeadHostState(previousDeadHostState, DeadHostState.TimeSupplier.DEFAULT))) {_                logger.debug("updated host [" + host + "] already in blacklist")__                break__            }_        }_        failureListener.onFailure(host)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,http,host,host,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,host,new,dead,host,state,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,logger,debug,added,host,host,to,blacklist,break,if,blacklist,replace,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,dead,host,state,time,supplier,default,logger,debug,updated,host,host,already,in,blacklist,break,failure,listener,on,failure,host
RestClient -> private void onFailure(HttpHost host);1527840262;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(HttpHost host) {_        while(true) {_            DeadHostState previousDeadHostState = blacklist.putIfAbsent(host, new DeadHostState(DeadHostState.TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                logger.debug("added host [" + host + "] to blacklist")__                break__            }_            if (blacklist.replace(host, previousDeadHostState,_                    new DeadHostState(previousDeadHostState, DeadHostState.TimeSupplier.DEFAULT))) {_                logger.debug("updated host [" + host + "] already in blacklist")__                break__            }_        }_        failureListener.onFailure(host)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,http,host,host,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,host,new,dead,host,state,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,logger,debug,added,host,host,to,blacklist,break,if,blacklist,replace,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,dead,host,state,time,supplier,default,logger,debug,updated,host,host,already,in,blacklist,break,failure,listener,on,failure,host
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1525248068;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1525859433;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1527096592;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1527840262;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1528762805;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1529687475;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1531179852;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1535965276;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1538170812;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1544364228;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1544448720;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1548457070;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1548869519;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            performRequestAsyncNoCatch(request, responseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,perform,request,async,no,catch,request,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public void performRequestAsync(Request request, ResponseListener responseListener);1549439027;Sends a request to the Elasticsearch cluster that the client points to._The request is executed asynchronously and the provided_{@link ResponseListener} gets notified upon request completion or_failure. Selects a host out of the provided ones in a round-robin_fashion. Failing hosts are marked dead and retried after a certain_amount of time (minimum 1 minute, maximum 30 minutes), depending on how_many times they previously failed (the more failures, the later they_will be retried). In case of failures all of the alive nodes (or dead_nodes that deserve a retry) are retried until one responds or none of_them does, in which case an {@link IOException} will be thrown.__@param request the request to perform_@param responseListener the {@link ResponseListener} to notify when the_request is completed or fails;public void performRequestAsync(Request request, ResponseListener responseListener) {_        try {_            FailureTrackingResponseListener failureTrackingResponseListener = new FailureTrackingResponseListener(responseListener)__            InternalRequest internalRequest = new InternalRequest(request)__            performRequestAsync(nextNodes(), internalRequest, failureTrackingResponseListener)__        } catch (Exception e) {_            responseListener.onFailure(e)__        }_    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,the,request,is,executed,asynchronously,and,the,provided,link,response,listener,gets,notified,upon,request,completion,or,failure,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,param,request,the,request,to,perform,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails;public,void,perform,request,async,request,request,response,listener,response,listener,try,failure,tracking,response,listener,failure,tracking,response,listener,new,failure,tracking,response,listener,response,listener,internal,request,internal,request,new,internal,request,request,perform,request,async,next,nodes,internal,request,failure,tracking,response,listener,catch,exception,e,response,listener,on,failure,e
RestClient -> public List<Node> getNodes();1528762805;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public List<Node> getNodes();1529687475;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public List<Node> getNodes();1531179852;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public List<Node> getNodes();1535965276;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public List<Node> getNodes();1538170812;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public List<Node> getNodes();1544364228;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public List<Node> getNodes();1544448720;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public List<Node> getNodes();1548457070;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public List<Node> getNodes();1548869519;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public List<Node> getNodes();1549439027;Get the list of nodes that the client knows about. The list is_unmodifiable.;public List<Node> getNodes() {_        return nodeTuple.nodes__    };get,the,list,of,nodes,that,the,client,knows,about,the,list,is,unmodifiable;public,list,node,get,nodes,return,node,tuple,nodes
RestClient -> public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, ResponseListener responseListener, Header... headers);1524684173;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure._Shortcut to {@link #performRequestAsync(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, ResponseListener,_Header...)} which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers;public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, ResponseListener responseListener, Header... headers) {_        performRequestAsync(method, endpoint, params, entity, HttpAsyncResponseConsumerFactory.DEFAULT, responseListener, headers)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,http,async,response,consumer,factory,response,listener,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers;public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,response,listener,response,listener,header,headers,perform,request,async,method,endpoint,params,entity,http,async,response,consumer,factory,default,response,listener,headers
RestClient -> public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     HttpEntity entity, ResponseListener responseListener, Header... headers);1525248068;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure._Shortcut to {@link #performRequestAsync(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, ResponseListener,_Header...)} which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers;public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    HttpEntity entity, ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setEntity(entity)__            request.setHeaders(headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,http,async,response,consumer,factory,response,listener,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers;public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,http,entity,entity,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,headers,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> public Response performRequest(Request request) throws IOException;1525248068;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1525859433;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1527096592;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1527840262;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1528762805;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1529687475;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1531179852;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1535965276;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1538170812;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1544364228;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1544448720;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1548457070;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1548869519;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        SyncResponseListener listener = new SyncResponseListener(maxRetryTimeoutMillis)__        performRequestAsyncNoCatch(request, listener)__        return listener.get()__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,sync,response,listener,listener,new,sync,response,listener,max,retry,timeout,millis,perform,request,async,no,catch,request,listener,return,listener,get
RestClient -> public Response performRequest(Request request) throws IOException;1549439027;Sends a request to the Elasticsearch cluster that the client points to._Blocks until the request is completed and returns its response or fails_by throwing an exception. Selects a host out of the provided ones in a_round-robin fashion. Failing hosts are marked dead and retried after a_certain amount of time (minimum 1 minute, maximum 30 minutes), depending_on how many times they previously failed (the more failures, the later_they will be retried). In case of failures all of the alive nodes (or_dead nodes that deserve a retry) are retried until one responds or none_of them does, in which case an {@link IOException} will be thrown.__This method works by performing an asynchronous call and waiting_for the result. If the asynchronous call throws an exception we wrap_it and rethrow it so that the stack trace attached to the exception_contains the call site. While we attempt to preserve the original_exception this isn't always possible and likely haven't covered all of_the cases. You can get the original exception from_{@link Exception#getCause()}.__@param request the request to perform_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(Request request) throws IOException {_        InternalRequest internalRequest = new InternalRequest(request)__        return performRequest(nextNodes(), internalRequest, null)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,blocks,until,the,request,is,completed,and,returns,its,response,or,fails,by,throwing,an,exception,selects,a,host,out,of,the,provided,ones,in,a,round,robin,fashion,failing,hosts,are,marked,dead,and,retried,after,a,certain,amount,of,time,minimum,1,minute,maximum,30,minutes,depending,on,how,many,times,they,previously,failed,the,more,failures,the,later,they,will,be,retried,in,case,of,failures,all,of,the,alive,nodes,or,dead,nodes,that,deserve,a,retry,are,retried,until,one,responds,or,none,of,them,does,in,which,case,an,link,ioexception,will,be,thrown,this,method,works,by,performing,an,asynchronous,call,and,waiting,for,the,result,if,the,asynchronous,call,throws,an,exception,we,wrap,it,and,rethrow,it,so,that,the,stack,trace,attached,to,the,exception,contains,the,call,site,while,we,attempt,to,preserve,the,original,exception,this,isn,t,always,possible,and,likely,haven,t,covered,all,of,the,cases,you,can,get,the,original,exception,from,link,exception,get,cause,param,request,the,request,to,perform,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,request,request,throws,ioexception,internal,request,internal,request,new,internal,request,request,return,perform,request,next,nodes,internal,request,null
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Header... headers) throws IOException;1525859433;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without parameters_and request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        request.setHeaders(headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,header,headers,throws,ioexception,request,request,new,request,method,endpoint,request,set,headers,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Header... headers) throws IOException;1527096592;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without parameters_and request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Header... headers) throws IOException;1527840262;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without parameters_and request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Header... headers) throws IOException;1528762805;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without parameters_and request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Header... headers) throws IOException;1529687475;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without parameters_and request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     public Response performRequest(String method, String endpoint, Header... headers) throws IOException;1531179852;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, Header...)} but without parameters_and request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error_@deprecated prefer {@link #performRequest(Request)};@Deprecated_    public Response performRequest(String method, String endpoint, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addHeaders(request, headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,header,but,without,parameters,and,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error,deprecated,prefer,link,perform,request,request;deprecated,public,response,perform,request,string,method,string,endpoint,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,headers,request,headers,return,perform,request,request
RestClient -> @Deprecated     private static void setOptions(Request request, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,             Header... headers);1527840262;Add all headers from the provided varargs argument to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void setOptions(Request request, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_            Header... headers) {_        Objects.requireNonNull(headers, "headers cannot be null")__        RequestOptions.Builder options = request.getOptions().toBuilder()__        for (Header header : headers) {_            Objects.requireNonNull(header, "header cannot be null")__            options.addHeader(header.getName(), header.getValue())__        }_        options.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__        request.setOptions(options)__    };add,all,headers,from,the,provided,varargs,argument,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,set,options,request,request,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,objects,require,non,null,headers,headers,cannot,be,null,request,options,builder,options,request,get,options,to,builder,for,header,header,headers,objects,require,non,null,header,header,cannot,be,null,options,add,header,header,get,name,header,get,value,options,set,http,async,response,consumer,factory,http,async,response,consumer,factory,request,set,options,options
RestClient -> @Deprecated     private static void setOptions(Request request, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,             Header... headers);1528762805;Add all headers from the provided varargs argument to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void setOptions(Request request, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_            Header... headers) {_        Objects.requireNonNull(headers, "headers cannot be null")__        RequestOptions.Builder options = request.getOptions().toBuilder()__        for (Header header : headers) {_            Objects.requireNonNull(header, "header cannot be null")__            options.addHeader(header.getName(), header.getValue())__        }_        options.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__        request.setOptions(options)__    };add,all,headers,from,the,provided,varargs,argument,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,set,options,request,request,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,objects,require,non,null,headers,headers,cannot,be,null,request,options,builder,options,request,get,options,to,builder,for,header,header,headers,objects,require,non,null,header,header,cannot,be,null,options,add,header,header,get,name,header,get,value,options,set,http,async,response,consumer,factory,http,async,response,consumer,factory,request,set,options,options
RestClient -> @Deprecated     private static void setOptions(Request request, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,             Header... headers);1529687475;Add all headers from the provided varargs argument to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void setOptions(Request request, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_            Header... headers) {_        Objects.requireNonNull(headers, "headers cannot be null")__        RequestOptions.Builder options = request.getOptions().toBuilder()__        for (Header header : headers) {_            Objects.requireNonNull(header, "header cannot be null")__            options.addHeader(header.getName(), header.getValue())__        }_        options.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__        request.setOptions(options)__    };add,all,headers,from,the,provided,varargs,argument,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,set,options,request,request,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,objects,require,non,null,headers,headers,cannot,be,null,request,options,builder,options,request,get,options,to,builder,for,header,header,headers,objects,require,non,null,header,header,cannot,be,null,options,add,header,header,get,name,header,get,value,options,set,http,async,response,consumer,factory,http,async,response,consumer,factory,request,set,options,options
RestClient -> @Deprecated     private static void setOptions(Request request, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,             Header... headers);1531179852;Add all headers from the provided varargs argument to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void setOptions(Request request, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,_            Header... headers) {_        Objects.requireNonNull(headers, "headers cannot be null")__        RequestOptions.Builder options = request.getOptions().toBuilder()__        for (Header header : headers) {_            Objects.requireNonNull(header, "header cannot be null")__            options.addHeader(header.getName(), header.getValue())__        }_        options.setHttpAsyncResponseConsumerFactory(httpAsyncResponseConsumerFactory)__        request.setOptions(options)__    };add,all,headers,from,the,provided,varargs,argument,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,set,options,request,request,http,async,response,consumer,factory,http,async,response,consumer,factory,header,headers,objects,require,non,null,headers,headers,cannot,be,null,request,options,builder,options,request,get,options,to,builder,for,header,header,headers,objects,require,non,null,header,header,cannot,be,null,options,add,header,header,get,name,header,get,value,options,set,http,async,response,consumer,factory,http,async,response,consumer,factory,request,set,options,options
RestClient -> public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, Header... headers) throws IOException;1524684173;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, Header...)}_which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, Header... headers) throws IOException {_        return performRequest(method, endpoint, params, entity, HttpAsyncResponseConsumerFactory.DEFAULT, headers)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,http,async,response,consumer,factory,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,header,headers,throws,ioexception,return,perform,request,method,endpoint,params,entity,http,async,response,consumer,factory,default,headers
RestClient -> public Response performRequest(String method, String endpoint, Map<String, String> params,                                    HttpEntity entity, Header... headers) throws IOException;1525248068;Sends a request to the Elasticsearch cluster that the client points to and waits for the corresponding response_to be returned. Shortcut to {@link #performRequest(String, String, Map, HttpEntity, HttpAsyncResponseConsumerFactory, Header...)}_which doesn't require specifying an {@link HttpAsyncResponseConsumerFactory} instance,_{@link HttpAsyncResponseConsumerFactory} will be used to create the needed instances of {@link HttpAsyncResponseConsumer}.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param entity the body of the request, null if not applicable_@param headers the optional request headers_@return the response returned by Elasticsearch_@throws IOException in case of a problem or the connection was aborted_@throws ClientProtocolException in case of an http protocol error_@throws ResponseException in case Elasticsearch responded with a status code that indicated an error;public Response performRequest(String method, String endpoint, Map<String, String> params,_                                   HttpEntity entity, Header... headers) throws IOException {_        Request request = new Request(method, endpoint)__        addParameters(request, params)__        request.setEntity(entity)__        request.setHeaders(headers)__        return performRequest(request)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,and,waits,for,the,corresponding,response,to,be,returned,shortcut,to,link,perform,request,string,string,map,http,entity,http,async,response,consumer,factory,header,which,doesn,t,require,specifying,an,link,http,async,response,consumer,factory,instance,link,http,async,response,consumer,factory,will,be,used,to,create,the,needed,instances,of,link,http,async,response,consumer,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,entity,the,body,of,the,request,null,if,not,applicable,param,headers,the,optional,request,headers,return,the,response,returned,by,elasticsearch,throws,ioexception,in,case,of,a,problem,or,the,connection,was,aborted,throws,client,protocol,exception,in,case,of,an,http,protocol,error,throws,response,exception,in,case,elasticsearch,responded,with,a,status,code,that,indicated,an,error;public,response,perform,request,string,method,string,endpoint,map,string,string,params,http,entity,entity,header,headers,throws,ioexception,request,request,new,request,method,endpoint,add,parameters,request,params,request,set,entity,entity,request,set,headers,headers,return,perform,request,request
RestClient -> @Deprecated     private static void addHeaders(Request request, Header... headers);1527096592;Add all headers from the provided varargs argument to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addHeaders(Request request, Header... headers) {_        Objects.requireNonNull(headers, "headers cannot be null")__        for (Header header : headers) {_            Objects.requireNonNull(header, "header cannot be null")__            request.addHeader(header.getName(), header.getValue())__        }_    };add,all,headers,from,the,provided,varargs,argument,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,headers,request,request,header,headers,objects,require,non,null,headers,headers,cannot,be,null,for,header,header,headers,objects,require,non,null,header,header,cannot,be,null,request,add,header,header,get,name,header,get,value
RestClient -> @Deprecated     private static void addHeaders(Request request, Header... headers);1527840262;Add all headers from the provided varargs argument to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addHeaders(Request request, Header... headers) {_        setOptions(request, RequestOptions.DEFAULT.getHttpAsyncResponseConsumerFactory(), headers)__    };add,all,headers,from,the,provided,varargs,argument,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,headers,request,request,header,headers,set,options,request,request,options,default,get,http,async,response,consumer,factory,headers
RestClient -> @Deprecated     private static void addHeaders(Request request, Header... headers);1528762805;Add all headers from the provided varargs argument to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addHeaders(Request request, Header... headers) {_        setOptions(request, RequestOptions.DEFAULT.getHttpAsyncResponseConsumerFactory(), headers)__    };add,all,headers,from,the,provided,varargs,argument,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,headers,request,request,header,headers,set,options,request,request,options,default,get,http,async,response,consumer,factory,headers
RestClient -> @Deprecated     private static void addHeaders(Request request, Header... headers);1529687475;Add all headers from the provided varargs argument to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addHeaders(Request request, Header... headers) {_        setOptions(request, RequestOptions.DEFAULT.getHttpAsyncResponseConsumerFactory(), headers)__    };add,all,headers,from,the,provided,varargs,argument,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,headers,request,request,header,headers,set,options,request,request,options,default,get,http,async,response,consumer,factory,headers
RestClient -> @Deprecated     private static void addHeaders(Request request, Header... headers);1531179852;Add all headers from the provided varargs argument to a {@link Request}. This only exists_to support methods that exist for backwards compatibility.;@Deprecated_    private static void addHeaders(Request request, Header... headers) {_        setOptions(request, RequestOptions.DEFAULT.getHttpAsyncResponseConsumerFactory(), headers)__    };add,all,headers,from,the,provided,varargs,argument,to,a,link,request,this,only,exists,to,support,methods,that,exist,for,backwards,compatibility;deprecated,private,static,void,add,headers,request,request,header,headers,set,options,request,request,options,default,get,http,async,response,consumer,factory,headers
RestClient -> public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     ResponseListener responseListener, Header... headers);1524684173;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers;public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    ResponseListener responseListener, Header... headers) {_        performRequestAsync(method, endpoint, params, null, responseListener, headers)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers;public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,response,listener,response,listener,header,headers,perform,request,async,method,endpoint,params,null,response,listener,headers
RestClient -> public void performRequestAsync(String method, String endpoint, Map<String, String> params,                                     ResponseListener responseListener, Header... headers);1525248068;Sends a request to the Elasticsearch cluster that the client points to. Doesn't wait for the response, instead_the provided {@link ResponseListener} will be notified upon completion or failure. Shortcut to_{@link #performRequestAsync(String, String, Map, HttpEntity, ResponseListener, Header...)} but without request body.__@param method the http method_@param endpoint the path of the request (without host and port)_@param params the query_string parameters_@param responseListener the {@link ResponseListener} to notify when the request is completed or fails_@param headers the optional request headers;public void performRequestAsync(String method, String endpoint, Map<String, String> params,_                                    ResponseListener responseListener, Header... headers) {_        Request request__        try {_            request = new Request(method, endpoint)__            addParameters(request, params)__            request.setHeaders(headers)__        } catch (Exception e) {_            responseListener.onFailure(e)__            return__        }_        performRequestAsync(request, responseListener)__    };sends,a,request,to,the,elasticsearch,cluster,that,the,client,points,to,doesn,t,wait,for,the,response,instead,the,provided,link,response,listener,will,be,notified,upon,completion,or,failure,shortcut,to,link,perform,request,async,string,string,map,http,entity,response,listener,header,but,without,request,body,param,method,the,http,method,param,endpoint,the,path,of,the,request,without,host,and,port,param,params,the,parameters,param,response,listener,the,link,response,listener,to,notify,when,the,request,is,completed,or,fails,param,headers,the,optional,request,headers;public,void,perform,request,async,string,method,string,endpoint,map,string,string,params,response,listener,response,listener,header,headers,request,request,try,request,new,request,method,endpoint,add,parameters,request,params,request,set,headers,headers,catch,exception,e,response,listener,on,failure,e,return,perform,request,async,request,response,listener
RestClient -> @Deprecated     public void setHosts(HttpHost... hosts);1528762805;Replaces the hosts with which the client communicates.__@deprecated prefer {@link setNodes} because it allows you_to set metadata for use with {@link NodeSelector}s;@Deprecated_    public void setHosts(HttpHost... hosts) {_        setNodes(hostsToNodes(hosts))__    };replaces,the,hosts,with,which,the,client,communicates,deprecated,prefer,link,set,nodes,because,it,allows,you,to,set,metadata,for,use,with,link,node,selector,s;deprecated,public,void,set,hosts,http,host,hosts,set,nodes,hosts,to,nodes,hosts
RestClient -> @Deprecated     public void setHosts(HttpHost... hosts);1529687475;Replaces the hosts with which the client communicates.__@deprecated prefer {@link #setNodes(Collection)} because it allows you_to set metadata for use with {@link NodeSelector}s;@Deprecated_    public void setHosts(HttpHost... hosts) {_        setNodes(hostsToNodes(hosts))__    };replaces,the,hosts,with,which,the,client,communicates,deprecated,prefer,link,set,nodes,collection,because,it,allows,you,to,set,metadata,for,use,with,link,node,selector,s;deprecated,public,void,set,hosts,http,host,hosts,set,nodes,hosts,to,nodes,hosts
RestClient -> @Deprecated     public void setHosts(HttpHost... hosts);1531179852;Replaces the hosts with which the client communicates.__@deprecated prefer {@link #setNodes(Collection)} because it allows you_to set metadata for use with {@link NodeSelector}s;@Deprecated_    public void setHosts(HttpHost... hosts) {_        setNodes(hostsToNodes(hosts))__    };replaces,the,hosts,with,which,the,client,communicates,deprecated,prefer,link,set,nodes,collection,because,it,allows,you,to,set,metadata,for,use,with,link,node,selector,s;deprecated,public,void,set,hosts,http,host,hosts,set,nodes,hosts,to,nodes,hosts
RestClient -> private void onResponse(Node node);1528762805;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onResponse(Node node);1529687475;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onResponse(Node node);1531179852;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onResponse(Node node);1535965276;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onResponse(Node node);1538170812;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onResponse(Node node);1544364228;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onResponse(Node node);1544448720;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onResponse(Node node);1548457070;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onResponse(Node node);1548869519;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onResponse(Node node);1549439027;Called after each successful request call._Receives as an argument the host that was used for the successful request.;private void onResponse(Node node) {_        DeadHostState removedHost = this.blacklist.remove(node.getHost())__        if (logger.isDebugEnabled() && removedHost != null) {_            logger.debug("removed [" + node + "] from blacklist")__        }_    };called,after,each,successful,request,call,receives,as,an,argument,the,host,that,was,used,for,the,successful,request;private,void,on,response,node,node,dead,host,state,removed,host,this,blacklist,remove,node,get,host,if,logger,is,debug,enabled,removed,host,null,logger,debug,removed,node,from,blacklist
RestClient -> private void onFailure(Node node);1528762805;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
RestClient -> private void onFailure(Node node);1529687475;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
RestClient -> private void onFailure(Node node);1531179852;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
RestClient -> private void onFailure(Node node);1535965276;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
RestClient -> private void onFailure(Node node);1538170812;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
RestClient -> private void onFailure(Node node);1544364228;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
RestClient -> private void onFailure(Node node);1544448720;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
RestClient -> private void onFailure(Node node);1548457070;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
RestClient -> private void onFailure(Node node);1548869519;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
RestClient -> private void onFailure(Node node);1549439027;Called after each failed attempt._Receives as an argument the host that was used for the failed attempt.;private void onFailure(Node node) {_        while(true) {_            DeadHostState previousDeadHostState =_                blacklist.putIfAbsent(node.getHost(), new DeadHostState(TimeSupplier.DEFAULT))__            if (previousDeadHostState == null) {_                if (logger.isDebugEnabled()) {_                    logger.debug("added [" + node + "] to blacklist")__                }_                break__            }_            if (blacklist.replace(node.getHost(), previousDeadHostState,_                    new DeadHostState(previousDeadHostState))) {_                if (logger.isDebugEnabled()) {_                    logger.debug("updated [" + node + "] already in blacklist")__                }_                break__            }_        }_        failureListener.onFailure(node)__    };called,after,each,failed,attempt,receives,as,an,argument,the,host,that,was,used,for,the,failed,attempt;private,void,on,failure,node,node,while,true,dead,host,state,previous,dead,host,state,blacklist,put,if,absent,node,get,host,new,dead,host,state,time,supplier,default,if,previous,dead,host,state,null,if,logger,is,debug,enabled,logger,debug,added,node,to,blacklist,break,if,blacklist,replace,node,get,host,previous,dead,host,state,new,dead,host,state,previous,dead,host,state,if,logger,is,debug,enabled,logger,debug,updated,node,already,in,blacklist,break,failure,listener,on,failure,node
