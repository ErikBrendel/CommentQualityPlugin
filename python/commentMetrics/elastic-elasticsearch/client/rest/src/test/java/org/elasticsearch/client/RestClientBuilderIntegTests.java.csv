commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;7;;@BeforeClass public static void startHttpServer() throws Exception {     httpsServer = MockHttpServer.createHttps(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0).     httpsServer.setHttpsConfigurator(new HttpsConfigurator(getSslContext())).     httpsServer.createContext("/", new ResponseHandler()).     httpsServer.start(). }
false;public;1;5;;@Override public void handle(HttpExchange httpExchange) throws IOException {     httpExchange.sendResponseHeaders(200, -1).     httpExchange.close(). }
false;public,static;0;5;;@AfterClass public static void stopHttpServers() throws IOException {     httpsServer.stop(0).     httpsServer = null. }
false;public;0;21;;public void testBuilderUsesDefaultSSLContext() throws Exception {     final SSLContext defaultSSLContext = SSLContext.getDefault().     try {         try (RestClient client = buildRestClient()) {             try {                 client.performRequest(new Request("GET", "/")).                 fail("connection should have been rejected due to SSL handshake").             } catch (Exception e) {                 assertThat(e, instanceOf(SSLHandshakeException.class)).             }         }         SSLContext.setDefault(getSslContext()).         try (RestClient client = buildRestClient()) {             Response response = client.performRequest(new Request("GET", "/")).             assertEquals(200, response.getStatusLine().getStatusCode()).         }     } finally {         SSLContext.setDefault(defaultSSLContext).     } }
false;private;0;4;;private RestClient buildRestClient() {     InetSocketAddress address = httpsServer.getAddress().     return RestClient.builder(new HttpHost(address.getHostString(), address.getPort(), "https")).build(). }
false;private,static;0;21;;private static SSLContext getSslContext() throws Exception {     SSLContext sslContext = SSLContext.getInstance("TLS").     try (InputStream certFile = RestClientBuilderIntegTests.class.getResourceAsStream("/test.crt")) {         // Build a keystore of default type programmatically since we can't use JKS keystores to         // init a KeyManagerFactory in FIPS 140 JVMs.         KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()).         keyStore.load(null, "password".toCharArray()).         CertificateFactory certFactory = CertificateFactory.getInstance("X.509").         PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(Files.readAllBytes(Paths.get(RestClientBuilderIntegTests.class.getResource("/test.der").toURI()))).         KeyFactory keyFactory = KeyFactory.getInstance("RSA").         keyStore.setKeyEntry("mykey", keyFactory.generatePrivate(privateKeySpec), "password".toCharArray(), new Certificate[] { certFactory.generateCertificate(certFile) }).         KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()).         kmf.init(keyStore, "password".toCharArray()).         TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()).         tmf.init(keyStore).         sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null).     }     return sslContext. }
