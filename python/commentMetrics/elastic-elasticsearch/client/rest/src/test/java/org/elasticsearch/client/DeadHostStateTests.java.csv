commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public void testInitialDeadHostStateDefaultTimeSupplier() {     DeadHostState deadHostState = new DeadHostState(DeadHostState.TimeSupplier.DEFAULT).     long currentTime = System.nanoTime().     assertThat(deadHostState.getDeadUntilNanos(), greaterThanOrEqualTo(currentTime)).     assertThat(deadHostState.getFailedAttempts(), equalTo(1)). }
false;public;0;10;;public void testDeadHostStateFromPreviousDefaultTimeSupplier() {     DeadHostState previous = new DeadHostState(DeadHostState.TimeSupplier.DEFAULT).     int iters = randomIntBetween(5, 30).     for (int i = 0. i < iters. i++) {         DeadHostState deadHostState = new DeadHostState(previous).         assertThat(deadHostState.getDeadUntilNanos(), greaterThan(previous.getDeadUntilNanos())).         assertThat(deadHostState.getFailedAttempts(), equalTo(previous.getFailedAttempts() + 1)).         previous = deadHostState.     } }
false;public;0;16;;public void testCompareToTimeSupplier() {     int numObjects = randomIntBetween(EXPECTED_TIMEOUTS_SECONDS.length, 30).     DeadHostState[] deadHostStates = new DeadHostState[numObjects].     for (int i = 0. i < numObjects. i++) {         if (i == 0) {             // this test requires a strictly increasing timer             deadHostStates[i] = new DeadHostState(new StrictMonotonicTimeSupplier()).         } else {             deadHostStates[i] = new DeadHostState(deadHostStates[i - 1]).         }     }     for (int k = 1. k < deadHostStates.length. k++) {         assertThat(deadHostStates[k - 1].getDeadUntilNanos(), lessThan(deadHostStates[k].getDeadUntilNanos())).         assertThat(deadHostStates[k - 1], lessThan(deadHostStates[k])).     } }
false;public;0;10;;public void testCompareToDifferingTimeSupplier() {     try {         new DeadHostState(TimeSupplier.DEFAULT).compareTo(new DeadHostState(new ConfigurableTimeSupplier())).         fail("expected failure").     } catch (IllegalArgumentException e) {         assertEquals("can't compare DeadHostStates with different clocks [nanoTime != configured[0]]", e.getMessage()).     } }
false;public;0;22;;public void testShallBeRetried() {     ConfigurableTimeSupplier timeSupplier = new ConfigurableTimeSupplier().     DeadHostState deadHostState = null.     for (int i = 0. i < EXPECTED_TIMEOUTS_SECONDS.length. i++) {         long expectedTimeoutSecond = EXPECTED_TIMEOUTS_SECONDS[i].         timeSupplier.nanoTime = 0.         if (i == 0) {             deadHostState = new DeadHostState(timeSupplier).         } else {             deadHostState = new DeadHostState(deadHostState).         }         for (int j = 0. j < expectedTimeoutSecond. j++) {             timeSupplier.nanoTime += TimeUnit.SECONDS.toNanos(1).             assertThat(deadHostState.shallBeRetried(), is(false)).         }         int iters = randomIntBetween(5, 30).         for (int j = 0. j < iters. j++) {             timeSupplier.nanoTime += TimeUnit.SECONDS.toNanos(1).             assertThat(deadHostState.shallBeRetried(), is(true)).         }     } }
false;public;0;17;;public void testDeadHostStateTimeouts() {     ConfigurableTimeSupplier zeroTimeSupplier = new ConfigurableTimeSupplier().     zeroTimeSupplier.nanoTime = 0L.     DeadHostState previous = new DeadHostState(zeroTimeSupplier).     for (long expectedTimeoutsSecond : EXPECTED_TIMEOUTS_SECONDS) {         assertThat(TimeUnit.NANOSECONDS.toSeconds(previous.getDeadUntilNanos()), equalTo(expectedTimeoutsSecond)).         previous = new DeadHostState(previous).     }     // check that from here on the timeout does not increase     int iters = randomIntBetween(5, 30).     for (int i = 0. i < iters. i++) {         DeadHostState deadHostState = new DeadHostState(previous).         assertThat(TimeUnit.NANOSECONDS.toSeconds(deadHostState.getDeadUntilNanos()), equalTo(EXPECTED_TIMEOUTS_SECONDS[EXPECTED_TIMEOUTS_SECONDS.length - 1])).         previous = deadHostState.     } }
false;public;0;4;;@Override public long nanoTime() {     return nanoTime. }
false;public;0;4;;@Override public String toString() {     return "configured[" + nanoTime + "]". }
false;public;0;4;;@Override public long nanoTime() {     return time.incrementAndGet(). }
false;public;0;4;;@Override public String toString() {     return "strict monotonic[" + time.get() + "]". }
