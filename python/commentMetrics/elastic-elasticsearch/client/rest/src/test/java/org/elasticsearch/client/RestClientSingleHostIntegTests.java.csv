commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void startHttpServer() throws Exception {     pathPrefix = randomBoolean() ? "/testPathPrefix/" + randomAsciiLettersOfLengthBetween(1, 5) : "".     httpServer = createHttpServer().     defaultHeaders = RestClientTestUtil.randomHeaders(getRandom(), "Header-default").     restClient = createRestClient(false, true). }
false;private;0;9;;private HttpServer createHttpServer() throws Exception {     HttpServer httpServer = MockHttpServer.createHttp(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0).     httpServer.start().     // returns a different status code depending on the path     for (int statusCode : getAllStatusCodes()) {         httpServer.createContext(pathPrefix + "/" + statusCode, new ResponseHandler(statusCode)).     }     return httpServer. }
false;public;1;26;;@Override public void handle(HttpExchange httpExchange) throws IOException {     // copy request body to response body so we can verify it was sent     StringBuilder body = new StringBuilder().     try (InputStreamReader reader = new InputStreamReader(httpExchange.getRequestBody(), Consts.UTF_8)) {         char[] buffer = new char[256].         int read.         while ((read = reader.read(buffer)) != -1) {             body.append(buffer, 0, read).         }     }     // copy request headers to response headers so we can verify they were sent     Headers requestHeaders = httpExchange.getRequestHeaders().     Headers responseHeaders = httpExchange.getResponseHeaders().     for (Map.Entry<String, List<String>> header : requestHeaders.entrySet()) {         responseHeaders.put(header.getKey(), header.getValue()).     }     httpExchange.getRequestBody().close().     httpExchange.sendResponseHeaders(statusCode, body.length() == 0 ? -1 : body.length()).     if (body.length() > 0) {         try (OutputStream out = httpExchange.getResponseBody()) {             out.write(body.toString().getBytes(Consts.UTF_8)).         }     }     httpExchange.close(). }
false;public;1;11;;@Override public HttpAsyncClientBuilder customizeHttpClient(final HttpAsyncClientBuilder httpClientBuilder) {     if (usePreemptiveAuth == false) {         // disable preemptive auth by ignoring any authcache         httpClientBuilder.disableAuthCaching().         // don't use the "persistent credentials strategy"         httpClientBuilder.setTargetAuthenticationStrategy(new TargetAuthenticationStrategy()).     }     return httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider). }
false;private;2;29;;private RestClient createRestClient(final boolean useAuth, final boolean usePreemptiveAuth) {     // provide the username/password for every request     final BasicCredentialsProvider credentialsProvider = new BasicCredentialsProvider().     credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials("user", "pass")).     final RestClientBuilder restClientBuilder = RestClient.builder(new HttpHost(httpServer.getAddress().getHostString(), httpServer.getAddress().getPort())).setDefaultHeaders(defaultHeaders).     if (pathPrefix.length() > 0) {         restClientBuilder.setPathPrefix(pathPrefix).     }     if (useAuth) {         restClientBuilder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {              @Override             public HttpAsyncClientBuilder customizeHttpClient(final HttpAsyncClientBuilder httpClientBuilder) {                 if (usePreemptiveAuth == false) {                     // disable preemptive auth by ignoring any authcache                     httpClientBuilder.disableAuthCaching().                     // don't use the "persistent credentials strategy"                     httpClientBuilder.setTargetAuthenticationStrategy(new TargetAuthenticationStrategy()).                 }                 return httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider).             }         }).     }     return restClientBuilder.build(). }
false;public;0;7;;@After public void stopHttpServers() throws IOException {     restClient.close().     restClient = null.     httpServer.stop(0).     httpServer = null. }
false;public;1;4;;@Override public void onSuccess(Response response) {     latch.countDown(). }
false;public;1;5;;@Override public void onFailure(Exception exception) {     exceptions.add(exception).     latch.countDown(). }
true;public;0;31;/**  * Tests sending a bunch of async requests works well (e.g. no TimeoutException from the leased pool)  * See https://github.com/elastic/elasticsearch/issues/24069  */ ;/**  * Tests sending a bunch of async requests works well (e.g. no TimeoutException from the leased pool)  * See https://github.com/elastic/elasticsearch/issues/24069  */ public void testManyAsyncRequests() throws Exception {     int iters = randomIntBetween(500, 1000).     final CountDownLatch latch = new CountDownLatch(iters).     final List<Exception> exceptions = new CopyOnWriteArrayList<>().     for (int i = 0. i < iters. i++) {         Request request = new Request("PUT", "/200").         request.setEntity(new NStringEntity("{}", ContentType.APPLICATION_JSON)).         restClient.performRequestAsync(request, new ResponseListener() {              @Override             public void onSuccess(Response response) {                 latch.countDown().             }              @Override             public void onFailure(Exception exception) {                 exceptions.add(exception).                 latch.countDown().             }         }).     }     assertTrue("timeout waiting for requests to be sent", latch.await(10, TimeUnit.SECONDS)).     if (exceptions.isEmpty() == false) {         AssertionError error = new AssertionError("expected no failures but got some. see suppressed for first 10 of [" + exceptions.size() + "] failures").         for (Exception exception : exceptions.subList(0, Math.min(10, exceptions.size()))) {             error.addSuppressed(exception).         }         throw error.     } }
true;public;0;34;/**  * End to end test for headers. We test it explicitly against a real http client as there are different ways  * to set/add headers to the {@link org.apache.http.client.HttpClient}.  * Exercises the test http server ability to send back whatever headers it received.  */ ;/**  * End to end test for headers. We test it explicitly against a real http client as there are different ways  * to set/add headers to the {@link org.apache.http.client.HttpClient}.  * Exercises the test http server ability to send back whatever headers it received.  */ public void testHeaders() throws Exception {     for (String method : getHttpMethods()) {         final Set<String> standardHeaders = new HashSet<>(Arrays.asList("Connection", "Host", "User-agent", "Date")).         if (method.equals("HEAD") == false) {             standardHeaders.add("Content-length").         }         final Header[] requestHeaders = RestClientTestUtil.randomHeaders(getRandom(), "Header").         final int statusCode = randomStatusCode(getRandom()).         Request request = new Request(method, "/" + statusCode).         RequestOptions.Builder options = request.getOptions().toBuilder().         for (Header header : requestHeaders) {             options.addHeader(header.getName(), header.getValue()).         }         request.setOptions(options).         Response esResponse.         try {             esResponse = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).         } catch (ResponseException e) {             esResponse = e.getResponse().         }         assertEquals(method, esResponse.getRequestLine().getMethod()).         assertEquals(statusCode, esResponse.getStatusLine().getStatusCode()).         assertEquals(pathPrefix + "/" + statusCode, esResponse.getRequestLine().getUri()).         assertHeaders(defaultHeaders, requestHeaders, esResponse.getHeaders(), standardHeaders).         for (final Header responseHeader : esResponse.getHeaders()) {             String name = responseHeader.getName().             if (name.startsWith("Header") == false) {                 assertTrue("unknown header was returned " + name, standardHeaders.remove(name)).             }         }         assertTrue("some expected standard headers weren't returned: " + standardHeaders, standardHeaders.isEmpty()).     } }
true;public;0;3;/**  * End to end test for delete with body. We test it explicitly as it is not supported  * out of the box by {@link org.apache.http.client.HttpClient}.  * Exercises the test http server ability to send back whatever body it received.  */ ;/**  * End to end test for delete with body. We test it explicitly as it is not supported  * out of the box by {@link org.apache.http.client.HttpClient}.  * Exercises the test http server ability to send back whatever body it received.  */ public void testDeleteWithBody() throws Exception {     bodyTest("DELETE"). }
true;public;0;3;/**  * End to end test for get with body. We test it explicitly as it is not supported  * out of the box by {@link org.apache.http.client.HttpClient}.  * Exercises the test http server ability to send back whatever body it received.  */ ;/**  * End to end test for get with body. We test it explicitly as it is not supported  * out of the box by {@link org.apache.http.client.HttpClient}.  * Exercises the test http server ability to send back whatever body it received.  */ public void testGetWithBody() throws Exception {     bodyTest("GET"). }
false;public;0;50;;public void testEncodeParams() throws Exception {     {         Request request = new Request("PUT", "/200").         request.addParameter("routing", "this/is/the/routing").         Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).         assertEquals(pathPrefix + "/200?routing=this%2Fis%2Fthe%2Frouting", response.getRequestLine().getUri()).     }     {         Request request = new Request("PUT", "/200").         request.addParameter("routing", "this|is|the|routing").         Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).         assertEquals(pathPrefix + "/200?routing=this%7Cis%7Cthe%7Crouting", response.getRequestLine().getUri()).     }     {         Request request = new Request("PUT", "/200").         request.addParameter("routing", "routing#1").         Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).         assertEquals(pathPrefix + "/200?routing=routing%231", response.getRequestLine().getUri()).     }     {         Request request = new Request("PUT", "/200").         request.addParameter("routing", "中文").         Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).         assertEquals(pathPrefix + "/200?routing=%E4%B8%AD%E6%96%87", response.getRequestLine().getUri()).     }     {         Request request = new Request("PUT", "/200").         request.addParameter("routing", "foo bar").         Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).         assertEquals(pathPrefix + "/200?routing=foo+bar", response.getRequestLine().getUri()).     }     {         Request request = new Request("PUT", "/200").         request.addParameter("routing", "foo+bar").         Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).         assertEquals(pathPrefix + "/200?routing=foo%2Bbar", response.getRequestLine().getUri()).     }     {         Request request = new Request("PUT", "/200").         request.addParameter("routing", "foo/bar").         Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).         assertEquals(pathPrefix + "/200?routing=foo%2Fbar", response.getRequestLine().getUri()).     }     {         Request request = new Request("PUT", "/200").         request.addParameter("routing", "foo^bar").         Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).         assertEquals(pathPrefix + "/200?routing=foo%5Ebar", response.getRequestLine().getUri()).     } }
true;public;0;11;/**  * Verify that credentials are sent on the first request with preemptive auth enabled (default when provided with credentials).  */ ;/**  * Verify that credentials are sent on the first request with preemptive auth enabled (default when provided with credentials).  */ public void testPreemptiveAuthEnabled() throws Exception {     final String[] methods = { "POST", "PUT", "GET", "DELETE" }.     try (RestClient restClient = createRestClient(true, true)) {         for (final String method : methods) {             final Response response = bodyTest(restClient, method).             assertThat(response.getHeader("Authorization"), startsWith("Basic")).         }     } }
true;public;0;11;/**  * Verify that credentials are <em>not</em> sent on the first request with preemptive auth disabled.  */ ;/**  * Verify that credentials are <em>not</em> sent on the first request with preemptive auth disabled.  */ public void testPreemptiveAuthDisabled() throws Exception {     final String[] methods = { "POST", "PUT", "GET", "DELETE" }.     try (RestClient restClient = createRestClient(true, false)) {         for (final String method : methods) {             final Response response = bodyTest(restClient, method).             assertThat(response.getHeader("Authorization"), nullValue()).         }     } }
true;public;0;15;/**  * Verify that credentials continue to be sent even if a 401 (Unauthorized) response is received  */ ;/**  * Verify that credentials continue to be sent even if a 401 (Unauthorized) response is received  */ public void testAuthCredentialsAreNotClearedOnAuthChallenge() throws Exception {     final String[] methods = { "POST", "PUT", "GET", "DELETE" }.     try (RestClient restClient = createRestClient(true, true)) {         for (final String method : methods) {             Header realmHeader = new BasicHeader("WWW-Authenticate", "Basic realm=\"test\"").             final Response response401 = bodyTest(restClient, method, 401, new Header[] { realmHeader }).             assertThat(response401.getHeader("Authorization"), startsWith("Basic")).             final Response response200 = bodyTest(restClient, method, 200, new Header[0]).             assertThat(response200.getHeader("Authorization"), startsWith("Basic")).         }     } }
false;public;0;26;;public void testUrlWithoutLeadingSlash() throws Exception {     if (pathPrefix.length() == 0) {         try {             RestClientSingleHostTests.performRequestSyncOrAsync(restClient, new Request("GET", "200")).             fail("request should have failed").         } catch (ResponseException e) {             assertEquals(404, e.getResponse().getStatusLine().getStatusCode()).         }     } else {         {             Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, new Request("GET", "200")).             // a trailing slash gets automatically added if a pathPrefix is configured             assertEquals(200, response.getStatusLine().getStatusCode()).         }         {             // pathPrefix is not required to start with '/', will be added automatically             try (RestClient restClient = RestClient.builder(new HttpHost(httpServer.getAddress().getHostString(), httpServer.getAddress().getPort())).setPathPrefix(pathPrefix.substring(1)).build()) {                 Response response = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, new Request("GET", "200")).                 // a trailing slash gets automatically added if a pathPrefix is configured                 assertEquals(200, response.getStatusLine().getStatusCode()).             }         }     } }
false;private;1;3;;private Response bodyTest(final String method) throws Exception {     return bodyTest(restClient, method). }
false;private;2;4;;private Response bodyTest(final RestClient restClient, final String method) throws Exception {     int statusCode = randomStatusCode(getRandom()).     return bodyTest(restClient, method, statusCode, new Header[0]). }
false;private;4;22;;private Response bodyTest(RestClient restClient, String method, int statusCode, Header[] headers) throws Exception {     String requestBody = "{ \"field\": \"value\" }".     Request request = new Request(method, "/" + statusCode).     request.setJsonEntity(requestBody).     RequestOptions.Builder options = request.getOptions().toBuilder().     for (Header header : headers) {         options.addHeader(header.getName(), header.getValue()).     }     request.setOptions(options).     Response esResponse.     try {         esResponse = RestClientSingleHostTests.performRequestSyncOrAsync(restClient, request).     } catch (ResponseException e) {         esResponse = e.getResponse().     }     assertEquals(method, esResponse.getRequestLine().getMethod()).     assertEquals(statusCode, esResponse.getStatusLine().getStatusCode()).     assertEquals(pathPrefix + "/" + statusCode, esResponse.getRequestLine().getUri()).     assertEquals(requestBody, EntityUtils.toString(esResponse.getEntity())).     return esResponse. }
