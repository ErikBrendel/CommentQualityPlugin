commented;modifiers;parameterAmount;loc;comment;code
false;public;1;26;;@Override public void select(Iterable<Node> nodes) {     /*                      * Prefer any node that belongs to rack_one. If none is around                      * we will go to another rack till it's time to try and revive                      * some of the nodes that belong to rack_one.                      */     boolean foundOne = false.     for (Node node : nodes) {         String rackId = node.getAttributes().get("rack_id").get(0).         if ("rack_one".equals(rackId)) {             foundOne = true.             break.         }     }     if (foundOne) {         Iterator<Node> nodesIt = nodes.iterator().         while (nodesIt.hasNext()) {             Node node = nodesIt.next().             String rackId = node.getAttributes().get("rack_id").get(0).             if ("rack_one".equals(rackId) == false) {                 nodesIt.remove().             }         }     } }
false;public;1;4;;@Override public void onFailure(Node node) { // <1> }
false;public;1;5;;@Override public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {     // <1>     return requestConfigBuilder.setSocketTimeout(10000). }
false;public;1;6;;@Override public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {     return httpClientBuilder.setProxy(// <1>     new HttpHost("proxy", 9000, "http")). }
false;public;1;4;;@Override public void onSuccess(Response response) { // <3> }
false;public;1;4;;@Override public void onFailure(Exception exception) { // <4> }
false;public;1;5;;@Override public void onSuccess(Response response) {     // <1>     latch.countDown(). }
false;public;1;5;;@Override public void onFailure(Exception exception) {     // <2>     latch.countDown(). }
false;public;0;192;;// end::rest-client-options-singleton @SuppressWarnings("unused") public void usage() throws IOException, InterruptedException {     // tag::rest-client-init     RestClient restClient = RestClient.builder(new HttpHost("localhost", 9200, "http"), new HttpHost("localhost", 9201, "http")).build().     // end::rest-client-init     // tag::rest-client-close     restClient.close().     // end::rest-client-close     {         // tag::rest-client-init-default-headers         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200, "http")).         Header[] defaultHeaders = new Header[] { new BasicHeader("header", "value") }.         // <1>         builder.setDefaultHeaders(defaultHeaders).     // end::rest-client-init-default-headers     }     {         // tag::rest-client-init-node-selector         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200, "http")).         // <1>         builder.setNodeSelector(NodeSelector.SKIP_DEDICATED_MASTERS).     // end::rest-client-init-node-selector     }     {         // tag::rest-client-init-allocation-aware-selector         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200, "http")).         builder.setNodeSelector(new // <1>         NodeSelector() {              @Override             public void select(Iterable<Node> nodes) {                 /*                      * Prefer any node that belongs to rack_one. If none is around                      * we will go to another rack till it's time to try and revive                      * some of the nodes that belong to rack_one.                      */                 boolean foundOne = false.                 for (Node node : nodes) {                     String rackId = node.getAttributes().get("rack_id").get(0).                     if ("rack_one".equals(rackId)) {                         foundOne = true.                         break.                     }                 }                 if (foundOne) {                     Iterator<Node> nodesIt = nodes.iterator().                     while (nodesIt.hasNext()) {                         Node node = nodesIt.next().                         String rackId = node.getAttributes().get("rack_id").get(0).                         if ("rack_one".equals(rackId) == false) {                             nodesIt.remove().                         }                     }                 }             }         }).     // end::rest-client-init-allocation-aware-selector     }     {         // tag::rest-client-init-failure-listener         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200, "http")).         builder.setFailureListener(new RestClient.FailureListener() {              @Override             public void onFailure(Node node) {             // <1>             }         }).     // end::rest-client-init-failure-listener     }     {         // tag::rest-client-init-request-config-callback         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200, "http")).         builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {              @Override             public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {                 // <1>                 return requestConfigBuilder.setSocketTimeout(10000).             }         }).     // end::rest-client-init-request-config-callback     }     {         // tag::rest-client-init-client-config-callback         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200, "http")).         builder.setHttpClientConfigCallback(new HttpClientConfigCallback() {              @Override             public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {                 return httpClientBuilder.setProxy(// <1>                 new HttpHost("proxy", 9000, "http")).             }         }).     // end::rest-client-init-client-config-callback     }     {         // tag::rest-client-sync         Request request = new Request(// <1>         "GET", // <2>         "/").         Response response = restClient.performRequest(request).     // end::rest-client-sync     }     {         // tag::rest-client-async         Request request = new Request(// <1>         "GET", // <2>         "/").         restClient.performRequestAsync(request, new ResponseListener() {              @Override             public void onSuccess(Response response) {             // <3>             }              @Override             public void onFailure(Exception exception) {             // <4>             }         }).     // end::rest-client-async     }     {         Request request = new Request("GET", "/").         // tag::rest-client-parameters         request.addParameter("pretty", "true").         // end::rest-client-parameters         // tag::rest-client-body         request.setEntity(new NStringEntity("{\"json\":\"text\"}", ContentType.APPLICATION_JSON)).         // end::rest-client-body         // tag::rest-client-body-shorter         request.setJsonEntity("{\"json\":\"text\"}").         // end::rest-client-body-shorter         // tag::rest-client-options-set-singleton         request.setOptions(COMMON_OPTIONS).         // end::rest-client-options-set-singleton         {             // tag::rest-client-options-customize-header             RequestOptions.Builder options = COMMON_OPTIONS.toBuilder().             options.addHeader("cats", "knock things off of other things").             request.setOptions(options).         // end::rest-client-options-customize-header         }     }     {         HttpEntity[] documents = new HttpEntity[10].         // tag::rest-client-async-example         final CountDownLatch latch = new CountDownLatch(documents.length).         for (int i = 0. i < documents.length. i++) {             Request request = new Request("PUT", "/posts/doc/" + i).             // let's assume that the documents are stored in an HttpEntity array             request.setEntity(documents[i]).             restClient.performRequestAsync(request, new ResponseListener() {                  @Override                 public void onSuccess(Response response) {                     // <1>                     latch.countDown().                 }                  @Override                 public void onFailure(Exception exception) {                     // <2>                     latch.countDown().                 }             }).         }         latch.await().     // end::rest-client-async-example     }     {         // tag::rest-client-response2         Response response = restClient.performRequest(new Request("GET", "/")).         // <1>         RequestLine requestLine = response.getRequestLine().         // <2>         HttpHost host = response.getHost().         // <3>         int statusCode = response.getStatusLine().getStatusCode().         // <4>         Header[] headers = response.getHeaders().         // <5>         String responseBody = EntityUtils.toString(response.getEntity()).     // end::rest-client-response2     } }
false;public;1;7;;@Override public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {     return requestConfigBuilder.setConnectTimeout(5000).setSocketTimeout(60000). }
false;public;1;8;;@Override public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {     return httpClientBuilder.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build()). }
false;public;1;6;;@Override public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {     return httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider). }
false;public;1;7;;@Override public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {     // <1>     httpClientBuilder.disableAuthCaching().     return httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider). }
false;public;1;5;;@Override public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {     return httpClientBuilder.setSSLContext(sslContext). }
false;public;0;96;;@SuppressWarnings("unused") public void commonConfiguration() throws Exception {     {         // tag::rest-client-config-timeouts         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200)).setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {              @Override             public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {                 return requestConfigBuilder.setConnectTimeout(5000).setSocketTimeout(60000).             }         }).     // end::rest-client-config-timeouts     }     {         // tag::rest-client-config-threads         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200)).setHttpClientConfigCallback(new HttpClientConfigCallback() {              @Override             public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {                 return httpClientBuilder.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build()).             }         }).     // end::rest-client-config-threads     }     {         // tag::rest-client-config-basic-auth         final CredentialsProvider credentialsProvider = new BasicCredentialsProvider().         credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials("user", "password")).         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200)).setHttpClientConfigCallback(new HttpClientConfigCallback() {              @Override             public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {                 return httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider).             }         }).     // end::rest-client-config-basic-auth     }     {         // tag::rest-client-config-disable-preemptive-auth         final CredentialsProvider credentialsProvider = new BasicCredentialsProvider().         credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials("user", "password")).         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200)).setHttpClientConfigCallback(new HttpClientConfigCallback() {              @Override             public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {                 // <1>                 httpClientBuilder.disableAuthCaching().                 return httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider).             }         }).     // end::rest-client-config-disable-preemptive-auth     }     {         Path keyStorePath = Paths.get("").         String keyStorePass = "".         // tag::rest-client-config-encrypted-communication         KeyStore truststore = KeyStore.getInstance("jks").         try (InputStream is = Files.newInputStream(keyStorePath)) {             truststore.load(is, keyStorePass.toCharArray()).         }         SSLContextBuilder sslBuilder = SSLContexts.custom().loadTrustMaterial(truststore, null).         final SSLContext sslContext = sslBuilder.build().         RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200, "https")).setHttpClientConfigCallback(new HttpClientConfigCallback() {              @Override             public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {                 return httpClientBuilder.setSSLContext(sslContext).             }         }).     // end::rest-client-config-encrypted-communication     } }
