commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;9;;@ParametersFactory public static Iterable<Object[]> parameters() throws Exception {     List<NamedXContentRegistry.Entry> entries = new ArrayList<>(ExecutableSection.DEFAULT_EXECUTABLE_CONTEXTS.size() + 1).     entries.addAll(ExecutableSection.DEFAULT_EXECUTABLE_CONTEXTS).     entries.add(new NamedXContentRegistry.Entry(ExecutableSection.class, new ParseField("compare_analyzers"), CompareAnalyzers::parse)).     NamedXContentRegistry executableSectionRegistry = new NamedXContentRegistry(entries).     return ESClientYamlSuiteTestCase.createParameters(executableSectionRegistry). }
false;protected;1;9;;@Override protected void afterIfFailed(List<Throwable> errors) {     super.afterIfFailed(errors).     String name = getTestName().split("=")[1].     name = name.substring(0, name.length() - 1).     name = name.replaceAll("/([^/]+)$", ".asciidoc:$1").     logger.error("This failing test was generated by documentation starting at {}. It may include many snippets. " + "See docs/README.asciidoc for an explanation of test generation.", name). }
false;protected;0;4;;@Override protected boolean randomizeContentType() {     return false. }
false;protected;5;9;;@Override protected ClientYamlTestClient initClientYamlTestClient(final ClientYamlSuiteRestSpec restSpec, final RestClient restClient, final List<HttpHost> hosts, final Version esVersion, final Version masterVersion) {     return new ClientYamlDocsTestClient(restSpec, restClient, hosts, esVersion, masterVersion, this::getClientBuilderWithSniffedHosts). }
false;private,static;1;7;;private static CompareAnalyzers parse(XContentParser parser) throws IOException {     XContentLocation location = parser.getTokenLocation().     CompareAnalyzers section = PARSER.parse(parser, location).     assert parser.currentToken() == Token.END_OBJECT : "End of object required".     // throw out the END_OBJECT to conform with other ExecutableSections     parser.nextToken().     return section. }
false;public;0;4;;@Override public XContentLocation getLocation() {     return location. }
false;public;1;65;;@Override public void execute(ClientYamlTestExecutionContext executionContext) throws IOException {     int size = 100.     int maxLength = 15.     List<String> testText = new ArrayList<>(size).     for (int i = 0. i < size. i++) {         /**          * Build a string with a few unicode sequences separated by          * spaces. The unicode sequences aren't going to be of the same          * code page which is a shame because it makes the entire          * string less realistic. But this still provides a fairly          * nice string to compare.          */         int spaces = between(0, 5).         StringBuilder b = new StringBuilder((spaces + 1) * maxLength).         b.append(randomRealisticUnicodeOfCodepointLengthBetween(1, maxLength)).         for (int t = 0. t < spaces. t++) {             b.append(' ').             b.append(randomRealisticUnicodeOfCodepointLengthBetween(1, maxLength)).         }         testText.add(b.toString().replace("$", "\\$")).     }     Map<String, Object> body = new HashMap<>(2).     body.put("analyzer", first).     body.put("text", testText).     ClientYamlTestResponse response = executionContext.callApi("indices.analyze", singletonMap("index", index), singletonList(body), emptyMap()).     Iterator<?> firstTokens = ((List<?>) response.evaluate("tokens")).iterator().     body.put("analyzer", second).     response = executionContext.callApi("indices.analyze", singletonMap("index", index), singletonList(body), emptyMap()).     Iterator<?> secondTokens = ((List<?>) response.evaluate("tokens")).iterator().     Object previousFirst = null.     Object previousSecond = null.     while (firstTokens.hasNext()) {         if (false == secondTokens.hasNext()) {             fail(second + " has fewer tokens than " + first + ". " + first + " has [" + firstTokens.next() + "] but " + second + " is out of tokens. " + first + "'s last token was [" + previousFirst + "] and " + second + "'s last token was' [" + previousSecond + "]").         }         Map<?, ?> firstToken = (Map<?, ?>) firstTokens.next().         Map<?, ?> secondToken = (Map<?, ?>) secondTokens.next().         String firstText = (String) firstToken.get("token").         String secondText = (String) secondToken.get("token").         // Check the text and produce an error message with the utf8 sequence if they don't match.         if (false == secondText.equals(firstText)) {             fail("text differs: " + first + " was [" + firstText + "] but " + second + " was [" + secondText + "]. In utf8 those are\n" + new BytesRef(firstText) + " and\n" + new BytesRef(secondText)).         }         // Now check the whole map just in case the text matches but something else differs         assertEquals(firstToken, secondToken).         previousFirst = firstToken.         previousSecond = secondToken.     }     if (secondTokens.hasNext()) {         fail(second + " has more tokens than " + first + ". " + second + " has [" + secondTokens.next() + "] but " + first + " is out of tokens. " + first + "'s last token was [" + previousFirst + "] and " + second + "'s last token was' [" + previousSecond + "]").     } }
