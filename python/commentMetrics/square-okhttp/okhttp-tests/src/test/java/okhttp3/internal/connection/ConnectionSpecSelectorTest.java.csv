commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;@Test public void nonRetryableIOException() throws Exception {     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS).     SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0).     connectionSpecSelector.configureSecureSocket(socket).     boolean retry = connectionSpecSelector.connectionFailed(new IOException("Non-handshake exception")).     assertFalse(retry).     socket.close(). }
false;public;0;14;;@Test public void nonRetryableSSLHandshakeException() throws Exception {     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS).     SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0).     connectionSpecSelector.configureSecureSocket(socket).     SSLHandshakeException trustIssueException = new SSLHandshakeException("Certificate handshake exception").     trustIssueException.initCause(new CertificateException()).     boolean retry = connectionSpecSelector.connectionFailed(trustIssueException).     assertFalse(retry).     socket.close(). }
false;public;0;12;;@Test public void retryableSSLHandshakeException() throws Exception {     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS).     SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0).     connectionSpecSelector.configureSecureSocket(socket).     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION).     assertTrue(retry).     socket.close(). }
false;public;0;33;;@Test public void someFallbacksSupported() throws Exception {     ConnectionSpec sslV3 = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS).tlsVersions(TlsVersion.SSL_3_0).build().     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3).     TlsVersion[] enabledSocketTlsVersions = { TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0 }.     SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions).     // MODERN_TLS is used here.     connectionSpecSelector.configureSecureSocket(socket).     assertEnabledProtocols(socket, TlsVersion.TLS_1_2).     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION).     assertTrue(retry).     socket.close().     // COMPATIBLE_TLS is used here.     socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions).     connectionSpecSelector.configureSecureSocket(socket).     assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0).     retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION).     assertFalse(retry).     socket.close(). // sslV3 is not used because SSLv3 is not enabled on the socket. }
false;private,static;1;4;;private static ConnectionSpecSelector createConnectionSpecSelector(ConnectionSpec... connectionSpecs) {     return new ConnectionSpecSelector(Arrays.asList(connectionSpecs)). }
false;private;1;5;;private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {     SSLSocket socket = (SSLSocket) handshakeCertificates.sslSocketFactory().createSocket().     socket.setEnabledProtocols(javaNames(tlsVersions)).     return socket. }
false;private,static;2;5;;private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {     Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols())).     Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required))).     assertEquals(expected, actual). }
false;private,static;1;7;;private static String[] javaNames(TlsVersion... tlsVersions) {     String[] protocols = new String[tlsVersions.length].     for (int i = 0. i < tlsVersions.length. i++) {         protocols[i] = tlsVersions[i].javaName().     }     return protocols. }
