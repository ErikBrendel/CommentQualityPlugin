commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@After public void tearDown() {     TestUtil.ensureAllConnectionsReleased(client). }
false;public;0;9;;@Test public void connectionsAreReused() throws Exception {     server.enqueue(new MockResponse().setBody("a")).     server.enqueue(new MockResponse().setBody("b")).     Request request = new Request.Builder().url(server.url("/")).build().     assertConnectionReused(request, request). }
false;public;0;10;;@Test public void connectionsAreReusedWithHttp2() throws Exception {     enableHttp2().     server.enqueue(new MockResponse().setBody("a")).     server.enqueue(new MockResponse().setBody("b")).     Request request = new Request.Builder().url(server.url("/")).build().     assertConnectionReused(request, request). }
false;public;0;13;;@Test public void connectionsAreNotReusedWithRequestConnectionClose() throws Exception {     server.enqueue(new MockResponse().setBody("a")).     server.enqueue(new MockResponse().setBody("b")).     Request requestA = new Request.Builder().url(server.url("/")).header("Connection", "close").build().     Request requestB = new Request.Builder().url(server.url("/")).build().     assertConnectionNotReused(requestA, requestB). }
false;public;0;14;;@Test public void connectionsAreNotReusedWithResponseConnectionClose() throws Exception {     server.enqueue(new MockResponse().addHeader("Connection", "close").setBody("a")).     server.enqueue(new MockResponse().setBody("b")).     Request requestA = new Request.Builder().url(server.url("/")).build().     Request requestB = new Request.Builder().url(server.url("/")).build().     assertConnectionNotReused(requestA, requestB). }
false;public;0;12;;@Test public void connectionsAreNotReusedWithUnknownLengthResponseBody() throws Exception {     server.enqueue(new MockResponse().setBody("a").setSocketPolicy(SocketPolicy.DISCONNECT_AT_END).clearHeaders()).     server.enqueue(new MockResponse().setBody("b")).     Request request = new Request.Builder().url(server.url("/")).build().     assertConnectionNotReused(request, request). }
false;public;0;12;;@Test public void connectionsAreNotReusedIfPoolIsSizeZero() throws Exception {     client = client.newBuilder().connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS)).build().     server.enqueue(new MockResponse().setBody("a")).     server.enqueue(new MockResponse().setBody("b")).     Request request = new Request.Builder().url(server.url("/")).build().     assertConnectionNotReused(request, request). }
false;public;0;18;;@Test public void connectionsReusedWithRedirectEvenIfPoolIsSizeZero() throws Exception {     client = client.newBuilder().connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS)).build().     server.enqueue(new MockResponse().setResponseCode(301).addHeader("Location: /b").setBody("a")).     server.enqueue(new MockResponse().setBody("b")).     Request request = new Request.Builder().url(server.url("/")).build().     Response response = client.newCall(request).execute().     assertEquals("b", response.body().string()).     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(1, server.takeRequest().getSequenceNumber()). }
false;public;0;19;;@Test public void connectionsNotReusedWithRedirectIfDiscardingResponseIsSlow() throws Exception {     client = client.newBuilder().connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS)).build().     server.enqueue(new MockResponse().setResponseCode(301).addHeader("Location: /b").setBodyDelay(1, TimeUnit.SECONDS).setBody("a")).     server.enqueue(new MockResponse().setBody("b")).     Request request = new Request.Builder().url(server.url("/")).build().     Response response = client.newCall(request).execute().     assertEquals("b", response.body().string()).     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(0, server.takeRequest().getSequenceNumber()). }
false;public;0;18;;@Test public void silentRetryWhenIdempotentRequestFailsOnReusedConnection() throws Exception {     server.enqueue(new MockResponse().setBody("a")).     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST)).     server.enqueue(new MockResponse().setBody("b")).     Request request = new Request.Builder().url(server.url("/")).build().     Response responseA = client.newCall(request).execute().     assertEquals("a", responseA.body().string()).     assertEquals(0, server.takeRequest().getSequenceNumber()).     Response responseB = client.newCall(request).execute().     assertEquals("b", responseB.body().string()).     assertEquals(1, server.takeRequest().getSequenceNumber()).     assertEquals(0, server.takeRequest().getSequenceNumber()). }
false;public;0;23;;@Test public void staleConnectionNotReusedForNonIdempotentRequest() throws Exception {     server.enqueue(new MockResponse().setBody("a").setSocketPolicy(SocketPolicy.SHUTDOWN_OUTPUT_AT_END)).     server.enqueue(new MockResponse().setBody("b")).     Request requestA = new Request.Builder().url(server.url("/")).build().     Response responseA = client.newCall(requestA).execute().     assertEquals("a", responseA.body().string()).     assertEquals(0, server.takeRequest().getSequenceNumber()).     // Give the socket a chance to become stale.     Thread.sleep(250).     Request requestB = new Request.Builder().url(server.url("/")).post(RequestBody.create(MediaType.get("text/plain"), "b")).build().     Response responseB = client.newCall(requestB).execute().     assertEquals("b", responseB.body().string()).     assertEquals(0, server.takeRequest().getSequenceNumber()). }
false;public;0;15;;@Test public void http2ConnectionsAreSharedBeforeResponseIsConsumed() throws Exception {     enableHttp2().     server.enqueue(new MockResponse().setBody("a")).     server.enqueue(new MockResponse().setBody("b")).     Request request = new Request.Builder().url(server.url("/")).build().     Response response1 = client.newCall(request).execute().     Response response2 = client.newCall(request).execute().     // Discard the response body.     response1.body().string().     // Discard the response body.     response2.body().string().     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(1, server.takeRequest().getSequenceNumber()). }
false;public;0;23;;@Test public void connectionsAreEvicted() throws Exception {     server.enqueue(new MockResponse().setBody("a")).     server.enqueue(new MockResponse().setBody("b")).     client = client.newBuilder().connectionPool(new ConnectionPool(5, 250, TimeUnit.MILLISECONDS)).build().     Request request = new Request.Builder().url(server.url("/")).build().     Response response1 = client.newCall(request).execute().     assertEquals("a", response1.body().string()).     // Give the thread pool a chance to evict.     Thread.sleep(500).     Response response2 = client.newCall(request).execute().     assertEquals("b", response2.body().string()).     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(0, server.takeRequest().getSequenceNumber()). }
false;public;0;26;;@Test public void connectionsAreNotReusedIfSslSocketFactoryChanges() throws Exception {     enableHttps().     server.enqueue(new MockResponse()).     server.enqueue(new MockResponse()).     Request request = new Request.Builder().url(server.url("/")).build().     Response response = client.newCall(request).execute().     response.body().close().     // This client shares a connection pool but has a different SSL socket factory.     HandshakeCertificates handshakeCertificates2 = new HandshakeCertificates.Builder().build().     OkHttpClient anotherClient = client.newBuilder().sslSocketFactory(handshakeCertificates2.sslSocketFactory(), handshakeCertificates2.trustManager()).build().     // This client fails to connect because the new SSL socket factory refuses.     try {         anotherClient.newCall(request).execute().         fail().     } catch (SSLException expected) {     } }
false;public;0;23;;@Test public void connectionsAreNotReusedIfHostnameVerifierChanges() throws Exception {     enableHttps().     server.enqueue(new MockResponse()).     server.enqueue(new MockResponse()).     Request request = new Request.Builder().url(server.url("/")).build().     Response response1 = client.newCall(request).execute().     response1.body().close().     // This client shares a connection pool but has a different SSL socket factory.     OkHttpClient anotherClient = client.newBuilder().hostnameVerifier(new RecordingHostnameVerifier()).build().     Response response2 = anotherClient.newCall(request).execute().     response2.body().close().     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(0, server.takeRequest().getSequenceNumber()). }
true;public;0;39;/**  * Regression test for an edge case where closing response body in the HTTP engine doesn't release  * the corresponding stream allocation. This test keeps those response bodies alive and reads  * them after the redirect has completed. This forces a connection to not be reused where it would  * be otherwise.  *  * <p>This test leaks a response body by not closing it.  *  * https://github.com/square/okhttp/issues/2409  */ ;/**  * Regression test for an edge case where closing response body in the HTTP engine doesn't release  * the corresponding stream allocation. This test keeps those response bodies alive and reads  * them after the redirect has completed. This forces a connection to not be reused where it would  * be otherwise.  *  * <p>This test leaks a response body by not closing it.  *  * https://github.com/square/okhttp/issues/2409  */ @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {     List<Response> responsesNotClosed = new ArrayList<>().     client = client.newBuilder().connectionPool(new ConnectionPool()).addNetworkInterceptor(chain -> {         Response response = chain.proceed(chain.request()).         responsesNotClosed.add(response).         return response.newBuilder().body(ResponseBody.create(null, "unrelated response body!")).build().     }).build().     server.enqueue(new MockResponse().setResponseCode(301).addHeader("Location: /b").setBody("/a has moved!")).     server.enqueue(new MockResponse().setBody("/b is here")).     Request request = new Request.Builder().url(server.url("/")).build().     Call call = client.newCall(request).     try (Response response = call.execute()) {         assertEquals("unrelated response body!", response.body().string()).     }     assertEquals(0, server.takeRequest().getSequenceNumber()).     // No connection reuse.     assertEquals(0, server.takeRequest().getSequenceNumber()).     for (Response response : responsesNotClosed) {         Util.closeQuietly(response).     } }
false;private;0;3;;private void enableHttps() {     enableHttpsAndAlpn(Protocol.HTTP_1_1). }
false;private;0;3;;private void enableHttp2() {     enableHttpsAndAlpn(Protocol.HTTP_2, Protocol.HTTP_1_1). }
false;private;1;10;;private void enableHttpsAndAlpn(Protocol... protocols) {     client = client.newBuilder().sslSocketFactory(handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager()).hostnameVerifier(new RecordingHostnameVerifier()).protocols(Arrays.asList(protocols)).build().     server.useHttps(handshakeCertificates.sslSocketFactory(), false).     server.setProtocols(client.protocols()). }
false;private;1;7;;private void assertConnectionReused(Request... requests) throws Exception {     for (int i = 0. i < requests.length. i++) {         Response response = client.newCall(requests[i]).execute().         // Discard the response body.         response.body().string().         assertEquals(i, server.takeRequest().getSequenceNumber()).     } }
false;private;1;7;;private void assertConnectionNotReused(Request... requests) throws Exception {     for (Request request : requests) {         Response response = client.newCall(request).execute().         // Discard the response body.         response.body().string().         assertEquals(0, server.takeRequest().getSequenceNumber()).     } }
