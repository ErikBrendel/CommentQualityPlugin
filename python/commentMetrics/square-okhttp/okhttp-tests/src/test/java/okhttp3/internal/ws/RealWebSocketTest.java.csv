commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void setUp() throws IOException {     client.initWebSocket(random, 0).     server.initWebSocket(random, 0). }
false;public;0;8;;@After public void tearDown() throws Exception {     client.listener.assertExhausted().     server.listener.assertExhausted().     server.source.close().     client.source.close().     server.webSocket.tearDown().     client.webSocket.tearDown(). }
false;public;0;10;;@Test public void close() throws IOException {     client.webSocket.close(1000, "Hello!").     // This will trigger a close response.     assertFalse(server.processNextFrame()).     server.listener.assertClosing(1000, "Hello!").     server.webSocket.close(1000, "Goodbye!").     assertFalse(client.processNextFrame()).     client.listener.assertClosing(1000, "Goodbye!").     server.listener.assertClosed(1000, "Hello!").     client.listener.assertClosed(1000, "Goodbye!"). }
false;public;0;6;;@Test public void clientCloseThenMethodsReturnFalse() throws IOException {     client.webSocket.close(1000, "Hello!").     assertFalse(client.webSocket.close(1000, "Hello!")).     assertFalse(client.webSocket.send("Hello!")). }
false;public;0;8;;@Test public void clientCloseWith0Fails() throws IOException {     try {         client.webSocket.close(0, null).         fail().     } catch (IllegalArgumentException expected) {         assertEquals(expected.getMessage(), "Code must be in range [1000,5000): 0").     } }
false;public;0;7;;@Test public void afterSocketClosedPingFailsWebSocket() throws IOException {     client2Server.source().close().     client.webSocket.pong(ByteString.encodeUtf8("Ping!")).     client.listener.assertFailure(IOException.class, "source is closed").     assertFalse(client.webSocket.send("Hello!")). }
false;public;0;10;;@Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {     client2Server.source().close().     assertTrue(client.webSocket.send("Hello!")).     client.listener.assertFailure(IOException.class, "source is closed").     // A failed write prevents further use of the WebSocket instance.     assertFalse(client.webSocket.send("Hello!")).     assertFalse(client.webSocket.pong(ByteString.encodeUtf8("Ping!"))). }
false;public;0;7;;@Test public void serverCloseThenWritingPingSucceeds() throws IOException {     server.webSocket.close(1000, "Hello!").     client.processNextFrame().     client.listener.assertClosing(1000, "Hello!").     assertTrue(client.webSocket.pong(ByteString.encodeUtf8("Pong?"))). }
false;public;0;9;;@Test public void clientCanWriteMessagesAfterServerClose() throws IOException {     server.webSocket.close(1000, "Hello!").     client.processNextFrame().     client.listener.assertClosing(1000, "Hello!").     assertTrue(client.webSocket.send("Hi!")).     server.processNextFrame().     server.listener.assertTextMessage("Hi!"). }
false;public;0;6;;@Test public void serverCloseThenClientClose() throws IOException {     server.webSocket.close(1000, "Hello!").     client.processNextFrame().     client.listener.assertClosing(1000, "Hello!").     assertTrue(client.webSocket.close(1000, "Bye!")). }
false;public;0;11;;@Test public void emptyCloseInitiatesShutdown() throws IOException {     // Close without code.     server.sink.write(ByteString.decodeHex("8800")).emit().     client.processNextFrame().     client.listener.assertClosing(1005, "").     assertTrue(client.webSocket.close(1000, "Bye!")).     server.processNextFrame().     server.listener.assertClosing(1000, "Bye!").     client.listener.assertClosed(1005, ""). }
false;public;0;15;;@Test public void clientCloseClosesConnection() throws IOException {     client.webSocket.close(1000, "Hello!").     assertFalse(client.closed).     // Read client closing, send server close.     server.processNextFrame().     server.listener.assertClosing(1000, "Hello!").     server.webSocket.close(1000, "Goodbye!").     // Read server closing, close connection.     client.processNextFrame().     assertTrue(client.closed).     client.listener.assertClosing(1000, "Goodbye!").     // Server and client both finished closing, connection is closed.     server.listener.assertClosed(1000, "Hello!").     client.listener.assertClosed(1000, "Goodbye!"). }
false;public;0;14;;@Test public void serverCloseClosesConnection() throws IOException {     server.webSocket.close(1000, "Hello!").     // Read server close, send client close, close connection.     client.processNextFrame().     assertFalse(client.closed).     client.listener.assertClosing(1000, "Hello!").     client.webSocket.close(1000, "Hello!").     server.processNextFrame().     server.listener.assertClosing(1000, "Hello!").     client.listener.assertClosed(1000, "Hello!").     server.listener.assertClosed(1000, "Hello!"). }
false;public;0;19;;@Test public void clientAndServerCloseClosesConnection() throws Exception {     // Send close from both sides at the same time.     server.webSocket.close(1000, "Hello!").     // Read close, close connection close.     client.processNextFrame().     assertFalse(client.closed).     client.webSocket.close(1000, "Hi!").     server.processNextFrame().     client.listener.assertClosing(1000, "Hello!").     server.listener.assertClosing(1000, "Hi!").     client.listener.assertClosed(1000, "Hello!").     server.listener.assertClosed(1000, "Hi!").     client.webSocket.awaitTermination(5, TimeUnit.SECONDS).     assertTrue(client.closed).     // Client should not have sent second close.     server.listener.assertExhausted().     // Server should not have sent second close.     client.listener.assertExhausted(). }
false;public;0;8;;@Test public void serverCloseBreaksReadMessageLoop() throws IOException {     server.webSocket.send("Hello!").     server.webSocket.close(1000, "Bye!").     assertTrue(client.processNextFrame()).     client.listener.assertTextMessage("Hello!").     assertFalse(client.processNextFrame()).     client.listener.assertClosing(1000, "Bye!"). }
false;public;0;10;;@Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {     // Invalid non-final ping frame.     server.sink.write(ByteString.decodeHex("0a00")).emit().     // Detects error, send close, close connection.     client.processNextFrame().     assertTrue(client.closed).     client.listener.assertFailure(ProtocolException.class, "Control frames must be final.").     server.processNextFrame().     server.listener.assertFailure(EOFException.class). }
false;public;0;16;;@Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {     client.webSocket.close(1000, "Hello").     server.processNextFrame().     // Not closed until close reply is received.     assertFalse(client.closed).     // Manually write an invalid masked close frame.     server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit().     // Detects error, disconnects immediately since close already sent.     client.processNextFrame().     assertTrue(client.closed).     client.listener.assertFailure(ProtocolException.class, "Server-sent frames must not be masked.").     server.listener.assertClosing(1000, "Hello").     // Client should not have sent second close.     server.listener.assertExhausted(). }
false;public;0;15;;@Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {     client.webSocket.close(1000, "Hello!").     server.processNextFrame().     // Not closed until close reply is received.     assertFalse(client.closed).     // Invalid non-final ping frame.     server.sink.write(ByteString.decodeHex("0a00")).emit().     // Detects error, disconnects immediately since close already sent.     client.processNextFrame().     assertTrue(client.closed).     client.listener.assertFailure(ProtocolException.class, "Control frames must be final.").     server.listener.assertClosing(1000, "Hello!").     // Client should not have sent second close.     server.listener.assertExhausted(). }
false;public;0;5;;@Test public void networkErrorReportedAsFailure() throws IOException {     server.sink.close().     client.processNextFrame().     client.listener.assertFailure(EOFException.class). }
false;public;0;5;;@Test public void closeThrowingFailsConnection() throws IOException {     client2Server.source().close().     client.webSocket.close(1000, null).     client.listener.assertFailure(IOException.class, "source is closed"). }
false;public;0;9;;// TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread. @Ignore @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {     client.sink.close().     client.closeThrows = true.     client.webSocket.close(1000, "Bye!").     client.listener.assertFailure(IOException.class, "failure").     assertTrue(client.closed). }
false;public;0;12;;// TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread. @Ignore @Test public void peerConnectionCloseThrowingPropagates() throws IOException {     client.closeThrows = true.     server.webSocket.close(1000, "Bye from Server!").     client.processNextFrame().     client.listener.assertClosing(1000, "Bye from Server!").     client.webSocket.close(1000, "Bye from Client!").     server.processNextFrame().     server.listener.assertClosing(1000, "Bye from Client!"). }
false;public;0;19;;@Test public void pingOnInterval() throws IOException {     long startNanos = System.nanoTime().     client.initWebSocket(random, 500).     // Ping.     server.processNextFrame().     // Pong.     client.processNextFrame().     long elapsedUntilPing1 = System.nanoTime() - startNanos.     assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1), 250d).     // Ping.     server.processNextFrame().     // Pong.     client.processNextFrame().     long elapsedUntilPing2 = System.nanoTime() - startNanos.     assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2), 250d).     // Ping.     server.processNextFrame().     // Pong.     client.processNextFrame().     long elapsedUntilPing3 = System.nanoTime() - startNanos.     assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d). }
false;public;0;10;;@Test public void unacknowledgedPingFailsConnection() throws IOException {     long startNanos = System.nanoTime().     client.initWebSocket(random, 500).     // Don't process the ping and pong frames!     client.listener.assertFailure(SocketTimeoutException.class, "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)").     long elapsedUntilFailure = System.nanoTime() - startNanos.     assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d). }
false;public;0;25;;@Test public void unexpectedPongsDoNotInterfereWithFailureDetection() throws IOException {     long startNanos = System.nanoTime().     client.initWebSocket(random, 500).     // At 0ms the server sends 3 unexpected pongs. The client accepts 'em and ignores em.     server.webSocket.pong(ByteString.encodeUtf8("pong 1")).     client.processNextFrame().     server.webSocket.pong(ByteString.encodeUtf8("pong 2")).     client.processNextFrame().     server.webSocket.pong(ByteString.encodeUtf8("pong 3")).     client.processNextFrame().     // After 500ms the client automatically pings and the server pongs back.     // Ping.     server.processNextFrame().     // Pong.     client.processNextFrame().     long elapsedUntilPing = System.nanoTime() - startNanos.     assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing), 250d).     // After 1000ms the client will attempt a ping 2, but we don't process it. That'll cause the     // client to fail at 1500ms when it's time to send ping 3 because pong 2 hasn't been received.     client.listener.assertFailure(SocketTimeoutException.class, "sent ping but didn't receive pong within 500ms (after 1 successful ping/pongs)").     long elapsedUntilFailure = System.nanoTime() - startNanos.     assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d). }
false;public;2;11;;public void initWebSocket(Random random, int pingIntervalMillis) throws IOException {     String url = "http://example.com/websocket".     Response response = new Response.Builder().code(101).message("OK").request(new Request.Builder().url(url).build()).protocol(Protocol.HTTP_1_1).build().     webSocket = new RealWebSocket(response.request(), listener, random, pingIntervalMillis).     webSocket.initReaderAndWriter(name, this). }
false;public;0;3;;public boolean processNextFrame() throws IOException {     return webSocket.processNextFrame(). }
false;public;0;12;;@Override public void close() throws IOException {     source.close().     sink.close().     if (closed) {         throw new AssertionError("Already closed").     }     closed = true.     if (closeThrows) {         throw new RuntimeException("Oops!").     } }
