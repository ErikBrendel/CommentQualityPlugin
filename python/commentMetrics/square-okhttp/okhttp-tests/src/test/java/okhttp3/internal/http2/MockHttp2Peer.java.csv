commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;public void setClient(boolean client) {     if (this.client == client) {         return.     }     this.client = client.     this.writer = new Http2Writer(bytesOut, client). }
false;public;0;3;;public void acceptFrame() {     frameCount++. }
true;public;0;3;/**  * Maximum length of an outbound data frame.  */ ;/**  * Maximum length of an outbound data frame.  */ public int maxOutboundDataLength() {     return writer.maxDataLength(). }
true;public;0;3;/**  * Count of frames sent or received.  */ ;/**  * Count of frames sent or received.  */ public int frameCount() {     return frameCount. }
false;public;0;4;;public Http2Writer sendFrame() {     outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false)).     return writer. }
true;public;1;14;/**  * Shortens the last frame from its original length to {@code length}. This will cause the peer to  * close the socket as soon as this frame has been written. otherwise the peer stays open until  * explicitly closed.  */ ;/**  * Shortens the last frame from its original length to {@code length}. This will cause the peer to  * close the socket as soon as this frame has been written. otherwise the peer stays open until  * explicitly closed.  */ public Http2Writer truncateLastFrame(int length) {     OutFrame lastFrame = outFrames.remove(outFrames.size() - 1).     if (length >= bytesOut.size() - lastFrame.start)         throw new IllegalArgumentException().     // Move everything from bytesOut into a new buffer.     Buffer fullBuffer = new Buffer().     bytesOut.read(fullBuffer, bytesOut.size()).     // Copy back all but what we're truncating.     fullBuffer.read(bytesOut, lastFrame.start + length).     outFrames.add(new OutFrame(lastFrame.sequence, lastFrame.start, true)).     return writer. }
false;public;0;3;;public InFrame takeFrame() throws Exception {     return inFrames.take(). }
false;public;0;15;;public void play() throws IOException {     if (serverSocket != null)         throw new IllegalStateException().     serverSocket = new ServerSocket().     serverSocket.setReuseAddress(false).     serverSocket.bind(new InetSocketAddress("localhost", 0), 1).     port = serverSocket.getLocalPort().     executor.execute(() -> {         try {             readAndWriteFrames().         } catch (IOException e) {             Util.closeQuietly(MockHttp2Peer.this).             logger.info(MockHttp2Peer.this + " done: " + e.getMessage()).         }     }). }
false;private;0;54;;private void readAndWriteFrames() throws IOException {     if (socket != null)         throw new IllegalStateException().     socket = serverSocket.accept().     // Bail out now if this instance was closed while waiting for the socket to accept.     synchronized (this) {         if (executor.isShutdown()) {             socket.close().             return.         }     }     OutputStream out = socket.getOutputStream().     InputStream in = socket.getInputStream().     Http2Reader reader = new Http2Reader(Okio.buffer(Okio.source(in)), client).     Iterator<OutFrame> outFramesIterator = outFrames.iterator().     byte[] outBytes = bytesOut.readByteArray().     OutFrame nextOutFrame = null.     for (int i = 0. i < frameCount. i++) {         if (nextOutFrame == null && outFramesIterator.hasNext()) {             nextOutFrame = outFramesIterator.next().         }         if (nextOutFrame != null && nextOutFrame.sequence == i) {             long start = nextOutFrame.start.             boolean truncated.             long end.             if (outFramesIterator.hasNext()) {                 nextOutFrame = outFramesIterator.next().                 end = nextOutFrame.start.                 truncated = false.             } else {                 end = outBytes.length.                 truncated = nextOutFrame.truncated.             }             // Write a frame.             int length = (int) (end - start).             out.write(outBytes, (int) start, length).             // If the last frame was truncated, immediately close the connection.             if (truncated) {                 socket.close().             }         } else {             // read a frame             InFrame inFrame = new InFrame(i, reader).             reader.nextFrame(false, inFrame).             inFrames.add(inFrame).         }     } }
false;public;0;3;;public Socket openSocket() throws IOException {     return new Socket("localhost", port). }
false;public,synchronized;0;5;;@Override public synchronized void close() throws IOException {     executor.shutdown().     Util.closeQuietly(socket).     Util.closeQuietly(serverSocket). }
false;public;0;3;;@Override public String toString() {     return "MockHttp2Peer[" + port + "]". }
false;public;2;6;;@Override public void settings(boolean clearPrevious, Settings settings) {     if (this.type != -1)         throw new IllegalStateException().     this.type = Http2.TYPE_SETTINGS.     this.clearPrevious = clearPrevious.     this.settings = settings. }
false;public;0;5;;@Override public void ackSettings() {     if (this.type != -1)         throw new IllegalStateException().     this.type = Http2.TYPE_SETTINGS.     this.ack = true. }
false;public;4;9;;@Override public void headers(boolean inFinished, int streamId, int associatedStreamId, List<Header> headerBlock) {     if (this.type != -1)         throw new IllegalStateException().     this.type = Http2.TYPE_HEADERS.     this.inFinished = inFinished.     this.streamId = streamId.     this.associatedStreamId = associatedStreamId.     this.headerBlock = headerBlock. }
false;public;4;8;;@Override public void data(boolean inFinished, int streamId, BufferedSource source, int length) throws IOException {     if (this.type != -1)         throw new IllegalStateException().     this.type = Http2.TYPE_DATA.     this.inFinished = inFinished.     this.streamId = streamId.     this.data = source.readByteString(length).toByteArray(). }
false;public;2;6;;@Override public void rstStream(int streamId, ErrorCode errorCode) {     if (this.type != -1)         throw new IllegalStateException().     this.type = Http2.TYPE_RST_STREAM.     this.streamId = streamId.     this.errorCode = errorCode. }
false;public;3;7;;@Override public void ping(boolean ack, int payload1, int payload2) {     if (this.type != -1)         throw new IllegalStateException().     this.type = Http2.TYPE_PING.     this.ack = ack.     this.payload1 = payload1.     this.payload2 = payload2. }
false;public;3;7;;@Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {     if (this.type != -1)         throw new IllegalStateException().     this.type = Http2.TYPE_GOAWAY.     this.streamId = lastGoodStreamId.     this.errorCode = errorCode.     this.data = debugData.toByteArray(). }
false;public;2;6;;@Override public void windowUpdate(int streamId, long windowSizeIncrement) {     if (this.type != -1)         throw new IllegalStateException().     this.type = Http2.TYPE_WINDOW_UPDATE.     this.streamId = streamId.     this.windowSizeIncrement = windowSizeIncrement. }
false;public;4;4;;@Override public void priority(int streamId, int streamDependency, int weight, boolean exclusive) {     throw new UnsupportedOperationException(). }
false;public;3;7;;@Override public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {     this.type = Http2.TYPE_PUSH_PROMISE.     this.streamId = streamId.     this.associatedStreamId = associatedStreamId.     this.headerBlock = headerBlock. }
false;public;6;4;;@Override public void alternateService(int streamId, String origin, ByteString protocol, String host, int port, long maxAge) {     throw new UnsupportedOperationException(). }
