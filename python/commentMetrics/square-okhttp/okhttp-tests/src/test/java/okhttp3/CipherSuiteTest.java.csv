commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Test public void nullCipherName() {     try {         forJavaName(null).         fail("Should have thrown").     } catch (NullPointerException expected) {     } }
false;public;0;4;;@Test public void hashCode_usesIdentityHashCode_legacyCase() {     // This one's javaName starts with "SSL_".     CipherSuite cs = TLS_RSA_EXPORT_WITH_RC4_40_MD5.     assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode()). }
false;public;0;4;;@Test public void hashCode_usesIdentityHashCode_regularCase() {     // This one's javaName matches the identifier.     CipherSuite cs = TLS_RSA_WITH_AES_128_CBC_SHA256.     assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode()). }
false;public;0;5;;@Test public void instancesAreInterned() {     assertSame(forJavaName("TestCipherSuite"), forJavaName("TestCipherSuite")).     assertSame(TLS_KRB5_WITH_DES_CBC_MD5, forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName())). }
true;public;0;7;/**  * Tests that interned CipherSuite instances remain the case across garbage collections, even if  * the String used to construct them is no longer strongly referenced outside of the CipherSuite.  */ ;/**  * Tests that interned CipherSuite instances remain the case across garbage collections, even if  * the String used to construct them is no longer strongly referenced outside of the CipherSuite.  */ @SuppressWarnings("RedundantStringConstructorCall") @Test public void instancesAreInterned_survivesGarbageCollection() {     // We're not holding onto a reference to this String instance outside of the CipherSuite...     CipherSuite cs = forJavaName(new String("FakeCipherSuite_instancesAreInterned")).     // Unless cs references the String instance, it may now be garbage collected.     System.gc().     assertSame(cs, forJavaName(new String(cs.javaName()))). }
false;public;0;6;;@Test public void equals() {     assertEquals(forJavaName("cipher"), forJavaName("cipher")).     assertNotEquals(forJavaName("cipherA"), forJavaName("cipherB")).     assertEquals(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"), TLS_RSA_EXPORT_WITH_RC4_40_MD5).     assertNotEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5, TLS_RSA_WITH_AES_128_CBC_SHA256). }
false;public;0;4;;@Test public void forJavaName_acceptsArbitraryStrings() {     // Shouldn't throw.     forJavaName("example CipherSuite name that is not in the whitelist"). }
false;public;0;5;;@Test public void javaName_examples() {     assertEquals("SSL_RSA_EXPORT_WITH_RC4_40_MD5", TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()).     assertEquals("TLS_RSA_WITH_AES_128_CBC_SHA256", TLS_RSA_WITH_AES_128_CBC_SHA256.javaName()).     assertEquals("TestCipherSuite", forJavaName("TestCipherSuite").javaName()). }
false;public;0;6;;@Test public void javaName_equalsToString() {     assertEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName, TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString()).     assertEquals(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName, TLS_RSA_WITH_AES_128_CBC_SHA256.toString()). }
true;public;0;12;/**  * On the Oracle JVM some older cipher suites have the "SSL_" prefix and others have the "TLS_"  * prefix. On the IBM JVM all cipher suites have the "SSL_" prefix.  *  * <p>Prior to OkHttp 3.3.1 we accepted either form and consider them equivalent. And since OkHttp  * 3.7.0 this is also true. But OkHttp 3.3.1 through 3.6.0 treated these as different.  */ ;/**  * On the Oracle JVM some older cipher suites have the "SSL_" prefix and others have the "TLS_"  * prefix. On the IBM JVM all cipher suites have the "SSL_" prefix.  *  * <p>Prior to OkHttp 3.3.1 we accepted either form and consider them equivalent. And since OkHttp  * 3.7.0 this is also true. But OkHttp 3.3.1 through 3.6.0 treated these as different.  */ @Test public void forJavaName_fromLegacyEnumName() {     // These would have been considered equal in OkHttp 3.3.1, but now aren't.     assertEquals(forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"), forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5")).     assertEquals(forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"), forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA")).     assertEquals(forJavaName("TLS_FAKE_NEW_CIPHER"), forJavaName("SSL_FAKE_NEW_CIPHER")). }
false;public;0;14;;@Test public void applyIntersectionRetainsSslPrefixes() throws Exception {     FakeSslSocket socket = new FakeSslSocket().     socket.setEnabledProtocols(new String[] { "TLSv1" }).     socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C", "SSL_D", "SSL_E" }).     socket.setEnabledCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C" }).     ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true).tlsVersions(TlsVersion.TLS_1_0).cipherSuites("TLS_A", "TLS_C", "TLS_E").build().     connectionSpec.apply(socket, false).     assertArrayEquals(new String[] { "SSL_A", "SSL_C" }, socket.enabledCipherSuites). }
false;public;0;14;;@Test public void applyIntersectionRetainsTlsPrefixes() throws Exception {     FakeSslSocket socket = new FakeSslSocket().     socket.setEnabledProtocols(new String[] { "TLSv1" }).     socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C", "TLS_D", "TLS_E" }).     socket.setEnabledCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C" }).     ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true).tlsVersions(TlsVersion.TLS_1_0).cipherSuites("SSL_A", "SSL_C", "SSL_E").build().     connectionSpec.apply(socket, false).     assertArrayEquals(new String[] { "TLS_A", "TLS_C" }, socket.enabledCipherSuites). }
false;public;0;14;;@Test public void applyIntersectionAddsSslScsvForFallback() throws Exception {     FakeSslSocket socket = new FakeSslSocket().     socket.setEnabledProtocols(new String[] { "TLSv1" }).     socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }).     socket.setEnabledCipherSuites(new String[] { "SSL_A" }).     ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true).tlsVersions(TlsVersion.TLS_1_0).cipherSuites("SSL_A").build().     connectionSpec.apply(socket, true).     assertArrayEquals(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }, socket.enabledCipherSuites). }
false;public;0;14;;@Test public void applyIntersectionAddsTlsScsvForFallback() throws Exception {     FakeSslSocket socket = new FakeSslSocket().     socket.setEnabledProtocols(new String[] { "TLSv1" }).     socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }).     socket.setEnabledCipherSuites(new String[] { "TLS_A" }).     ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true).tlsVersions(TlsVersion.TLS_1_0).cipherSuites("TLS_A").build().     connectionSpec.apply(socket, true).     assertArrayEquals(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }, socket.enabledCipherSuites). }
false;public;0;14;;@Test public void applyIntersectionToProtocolVersion() throws Exception {     FakeSslSocket socket = new FakeSslSocket().     socket.setEnabledProtocols(new String[] { "TLSv1", "TLSv1.1", "TLSv1.2" }).     socket.setSupportedCipherSuites(new String[] { "TLS_A" }).     socket.setEnabledCipherSuites(new String[] { "TLS_A" }).     ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true).tlsVersions(TlsVersion.TLS_1_1, TlsVersion.TLS_1_2, TlsVersion.TLS_1_3).cipherSuites("TLS_A").build().     connectionSpec.apply(socket, false).     assertArrayEquals(new String[] { "TLSv1.1", "TLSv1.2" }, socket.enabledProtocols). }
false;public;0;3;;@Override public String[] getEnabledProtocols() {     return enabledProtocols. }
false;public;1;3;;@Override public void setEnabledProtocols(String[] enabledProtocols) {     this.enabledProtocols = enabledProtocols. }
false;public;0;3;;@Override public String[] getSupportedCipherSuites() {     return supportedCipherSuites. }
false;public;1;3;;public void setSupportedCipherSuites(String[] supportedCipherSuites) {     this.supportedCipherSuites = supportedCipherSuites. }
false;public;0;3;;@Override public String[] getEnabledCipherSuites() {     return enabledCipherSuites. }
false;public;1;3;;@Override public void setEnabledCipherSuites(String[] enabledCipherSuites) {     this.enabledCipherSuites = enabledCipherSuites. }
