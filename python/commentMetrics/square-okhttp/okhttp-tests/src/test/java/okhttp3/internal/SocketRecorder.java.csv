commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {     RecordedSocket recordedSocket = new RecordedSocket().     recordedSockets.add(recordedSocket).     return new RecordingSSLSocket(sslSocket, recordedSocket). }
true;public;1;9;/**  * Returns an SSLSocketFactory whose sockets will record all transmitted bytes.  */ ;/**  * Returns an SSLSocketFactory whose sockets will record all transmitted bytes.  */ public SSLSocketFactory sslSocketFactory(SSLSocketFactory delegate) {     return new DelegatingSSLSocketFactory(delegate) {          @Override         protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {             RecordedSocket recordedSocket = new RecordedSocket().             recordedSockets.add(recordedSocket).             return new RecordingSSLSocket(sslSocket, recordedSocket).         }     }. }
false;public;0;3;;public RecordedSocket takeSocket() {     return recordedSockets.remove(). }
false;synchronized;1;3;;synchronized void byteWritten(int b) {     bytesWritten.writeByte(b). }
false;synchronized;1;3;;synchronized void byteRead(int b) {     bytesRead.writeByte(b). }
false;synchronized;3;3;;synchronized void bytesWritten(byte[] bytes, int offset, int length) {     bytesWritten.write(bytes, offset, length). }
false;synchronized;3;3;;synchronized void bytesRead(byte[] bytes, int offset, int length) {     bytesRead.write(bytes, offset, length). }
true;public,synchronized;0;3;/**  * Returns all bytes that have been written to this socket.  */ ;/**  * Returns all bytes that have been written to this socket.  */ public synchronized ByteString bytesWritten() {     return bytesWritten.readByteString(). }
true;public,synchronized;0;3;/**  * Returns all bytes that have been read from this socket.  */ ;/**  * Returns all bytes that have been read from this socket.  */ public synchronized ByteString bytesRead() {     return bytesRead.readByteString(). }
false;public;0;6;;@Override public int read() throws IOException {     int b = socket.getInputStream().read().     if (b == -1)         return -1.     recordedSocket.byteRead(b).     return b. }
false;public;3;6;;@Override public int read(byte[] b, int off, int len) throws IOException {     int read = socket.getInputStream().read(b, off, len).     if (read == -1)         return -1.     recordedSocket.bytesRead(b, off, read).     return read. }
false;public;0;3;;@Override public void close() throws IOException {     socket.getInputStream().close(). }
false;public;1;4;;@Override public void write(int b) throws IOException {     socket.getOutputStream().write(b).     recordedSocket.byteWritten(b). }
false;public;3;4;;@Override public void write(byte[] b, int off, int len) throws IOException {     socket.getOutputStream().write(b, off, len).     recordedSocket.bytesWritten(b, off, len). }
false;public;0;3;;@Override public void close() throws IOException {     socket.getOutputStream().close(). }
false;public;0;3;;@Override public void flush() throws IOException {     socket.getOutputStream().flush(). }
false;public;0;47;;@Override public void startHandshake() throws IOException {     // Intercept the handshake to properly configure TLS extensions with Jetty ALPN. Jetty ALPN     // expects the real SSLSocket to be placed in the global map. Because we are wrapping the real     // SSLSocket, it confuses Jetty ALPN. This patches that up so things work as expected.     Class<?> alpn = null.     Class<?> provider = null.     try {         alpn = Class.forName("org.eclipse.jetty.alpn.ALPN").         provider = Class.forName("org.eclipse.jetty.alpn.ALPN$Provider").     } catch (ClassNotFoundException ignored) {     }     if (alpn == null || provider == null) {         // No Jetty, so nothing to worry about.         super.startHandshake().         return.     }     Object providerInstance = null.     Method putMethod = null.     try {         Method getMethod = alpn.getMethod("get", SSLSocket.class).         putMethod = alpn.getMethod("put", SSLSocket.class, provider).         providerInstance = getMethod.invoke(null, this).         if (providerInstance == null) {             // Jetty's on the classpath but TLS extensions weren't used.             super.startHandshake().             return.         }         // TLS extensions were used. replace with the real SSLSocket to make Jetty ALPN happy.         putMethod.invoke(null, delegate, providerInstance).         super.startHandshake().     } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {         throw new AssertionError().     } finally {         // everything to work inside OkHttp.         if (providerInstance != null) {             try {                 putMethod.invoke(null, this, providerInstance).             } catch (IllegalAccessException | InvocationTargetException e) {                 throw new AssertionError().             }         }     } }
false;public;0;3;;@Override public InputStream getInputStream() throws IOException {     return inputStream. }
false;public;0;3;;@Override public OutputStream getOutputStream() throws IOException {     return outputStream. }
