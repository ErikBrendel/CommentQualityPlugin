commented;modifiers;parameterAmount;loc;comment;code
false;public;0;31;;@Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {     RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS).     // Prevent the cleanup runnable from being started.     pool.cleanupRunning = true.     RealConnection c1 = newConnection(pool, routeA1, 50L).     // Running at time 50, the pool returns that nothing can be evicted until time 150.     assertEquals(100L, pool.cleanup(50L)).     assertEquals(1, pool.connectionCount()).     assertFalse(c1.socket().isClosed()).     // Running at time 60, the pool returns that nothing can be evicted until time 150.     assertEquals(90L, pool.cleanup(60L)).     assertEquals(1, pool.connectionCount()).     assertFalse(c1.socket().isClosed()).     // Running at time 149, the pool returns that nothing can be evicted until time 150.     assertEquals(1L, pool.cleanup(149L)).     assertEquals(1, pool.connectionCount()).     assertFalse(c1.socket().isClosed()).     // Running at time 150, the pool evicts.     assertEquals(0, pool.cleanup(150L)).     assertEquals(0, pool.connectionCount()).     assertTrue(c1.socket().isClosed()).     // Running again, the pool reports that no further runs are necessary.     assertEquals(-1, pool.cleanup(150L)).     assertEquals(0, pool.connectionCount()).     assertTrue(c1.socket().isClosed()). }
false;public;0;31;;@Test public void inUseConnectionsNotEvicted() throws Exception {     ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS).     RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi).     // Prevent the cleanup runnable from being started.     pool.cleanupRunning = true.     RealConnection c1 = newConnection(pool, routeA1, 50L).     synchronized (pool) {         OkHttpClient client = new OkHttpClient.Builder().connectionPool(poolApi).build().         Call call = client.newCall(newRequest(addressA)).         Transmitter transmitter = new Transmitter(client, call).         transmitter.prepareToConnect(call.request()).         transmitter.acquireConnectionNoEvents(c1).     }     // Running at time 50, the pool returns that nothing can be evicted until time 150.     assertEquals(100L, pool.cleanup(50L)).     assertEquals(1, pool.connectionCount()).     assertFalse(c1.socket().isClosed()).     // Running at time 60, the pool returns that nothing can be evicted until time 160.     assertEquals(100L, pool.cleanup(60L)).     assertEquals(1, pool.connectionCount()).     assertFalse(c1.socket().isClosed()).     // Running at time 160, the pool returns that nothing can be evicted until time 260.     assertEquals(100L, pool.cleanup(160L)).     assertEquals(1, pool.connectionCount()).     assertFalse(c1.socket().isClosed()). }
false;public;0;31;;@Test public void cleanupPrioritizesEarliestEviction() throws Exception {     RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS).     // Prevent the cleanup runnable from being started.     pool.cleanupRunning = true.     RealConnection c1 = newConnection(pool, routeA1, 75L).     RealConnection c2 = newConnection(pool, routeB1, 50L).     // Running at time 75, the pool returns that nothing can be evicted until time 150.     assertEquals(75L, pool.cleanup(75L)).     assertEquals(2, pool.connectionCount()).     // Running at time 149, the pool returns that nothing can be evicted until time 150.     assertEquals(1L, pool.cleanup(149L)).     assertEquals(2, pool.connectionCount()).     // Running at time 150, the pool evicts c2.     assertEquals(0L, pool.cleanup(150L)).     assertEquals(1, pool.connectionCount()).     assertFalse(c1.socket().isClosed()).     assertTrue(c2.socket().isClosed()).     // Running at time 150, the pool returns that nothing can be evicted until time 175.     assertEquals(25L, pool.cleanup(150L)).     assertEquals(1, pool.connectionCount()).     // Running at time 175, the pool evicts c1.     assertEquals(0L, pool.cleanup(175L)).     assertEquals(0, pool.connectionCount()).     assertTrue(c1.socket().isClosed()).     assertTrue(c2.socket().isClosed()). }
false;public;0;23;;@Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {     RealConnectionPool pool = new RealConnectionPool(2, 100L, TimeUnit.NANOSECONDS).     // Prevent the cleanup runnable from being started.     pool.cleanupRunning = true.     RealConnection c1 = newConnection(pool, routeA1, 50L).     RealConnection c2 = newConnection(pool, routeB1, 75L).     // With 2 connections, there's no need to evict until the connections time out.     assertEquals(50L, pool.cleanup(100L)).     assertEquals(2, pool.connectionCount()).     assertFalse(c1.socket().isClosed()).     assertFalse(c2.socket().isClosed()).     // Add a third connection     RealConnection c3 = newConnection(pool, routeC1, 75L).     // The third connection bounces the first.     assertEquals(0L, pool.cleanup(100L)).     assertEquals(2, pool.connectionCount()).     assertTrue(c1.socket().isClosed()).     assertFalse(c2.socket().isClosed()).     assertFalse(c3.socket().isClosed()). }
false;public;0;14;;@Test public void leakedAllocation() throws Exception {     ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS).     RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi).     // Prevent the cleanup runnable from being started.     pool.cleanupRunning = true.     RealConnection c1 = newConnection(pool, routeA1, 0L).     allocateAndLeakAllocation(poolApi, c1).     awaitGarbageCollection().     assertEquals(0L, pool.cleanup(100L)).     assertEquals(Collections.emptyList(), c1.transmitters).     // Can't allocate once a leak has been detected.     assertTrue(c1.noNewExchanges). }
true;private;2;11;/**  * Use a helper method so there's no hidden reference remaining on the stack.  */ ;/**  * Use a helper method so there's no hidden reference remaining on the stack.  */ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {     synchronized (Internal.instance.realConnectionPool(pool)) {         OkHttpClient client = new OkHttpClient.Builder().connectionPool(pool).build().         Call call = client.newCall(newRequest(connection.route().address())).         Transmitter transmitter = new Transmitter(client, call).         transmitter.prepareToConnect(call.request()).         transmitter.acquireConnectionNoEvents(connection).     } }
false;private;3;7;;private RealConnection newConnection(RealConnectionPool pool, Route route, long idleAtNanos) {     RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos).     synchronized (pool) {         pool.put(result).     }     return result. }
false;private;1;5;;private Address newAddress(String name) {     return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null, new RecordingOkAuthenticator("password", null), null, Collections.emptyList(), Collections.emptyList(), ProxySelector.getDefault()). }
false;private;1;4;;private Route newRoute(Address address) {     return new Route(address, Proxy.NO_PROXY, InetSocketAddress.createUnresolved(address.url().host(), address.url().port())). }
false;private;1;5;;private Request newRequest(Address address) {     return new Request.Builder().url(address.url()).build(). }
