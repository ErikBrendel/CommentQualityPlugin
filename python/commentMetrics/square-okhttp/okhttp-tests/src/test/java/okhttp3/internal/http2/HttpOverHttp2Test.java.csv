commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@Parameters(name = "{0}") public static Collection<Protocol> data() {     return Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2). }
false;private,static;0;5;;private static OkHttpClient buildH2PriorKnowledgeClient() {     return defaultClient().newBuilder().protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE)).build(). }
false;private,static;0;8;;private static OkHttpClient buildHttp2Client() {     return defaultClient().newBuilder().protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1)).sslSocketFactory(handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager()).hostnameVerifier(new RecordingHostnameVerifier()).build(). }
false;public;0;13;;@Before public void setUp() {     if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {         server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE)).     } else {         server.useHttps(handshakeCertificates.sslSocketFactory(), false).     }     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE).     http2Logger.addHandler(http2Handler).     previousLevel = http2Logger.getLevel().     http2Logger.setLevel(Level.FINE). }
false;public;0;7;;@After public void tearDown() {     Authenticator.setDefault(null).     http2Logger.removeHandler(http2Handler).     http2Logger.setLevel(previousLevel).     TestUtil.ensureAllConnectionsReleased(client). }
false;public;0;20;;@Test public void get() throws Exception {     server.enqueue(new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet")).     Call call = client.newCall(new Request.Builder().url(server.url("/foo")).build()).     Response response = call.execute().     assertEquals("ABCDE", response.body().string()).     assertEquals(200, response.code()).     assertEquals("", response.message()).     assertEquals(protocol, response.protocol()).     RecordedRequest request = server.takeRequest().     assertEquals("GET /foo HTTP/1.1", request.getRequestLine()).     assertEquals(scheme, request.getHeader(":scheme")).     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority")). }
false;public;0;11;;@Test public void emptyResponse() throws IOException {     server.enqueue(new MockResponse()).     Call call = client.newCall(new Request.Builder().url(server.url("/foo")).build()).     Response response = call.execute().     assertEquals(-1, response.body().byteStream().read()).     response.body().close(). }
false;public;0;3;;@Override public MediaType contentType() {     return MediaType.get("text/plain. charset=utf-8"). }
false;public;1;3;;@Override public void writeTo(BufferedSink sink) throws IOException {     sink.write(postBytes). }
false;public;0;26;;@Test public void noDefaultContentLengthOnStreamingPost() throws Exception {     byte[] postBytes = "FGHIJ".getBytes(UTF_8).     server.enqueue(new MockResponse().setBody("ABCDE")).     Call call = client.newCall(new Request.Builder().url(server.url("/foo")).post(new RequestBody() {          @Override         public MediaType contentType() {             return MediaType.get("text/plain. charset=utf-8").         }          @Override         public void writeTo(BufferedSink sink) throws IOException {             sink.write(postBytes).         }     }).build()).     Response response = call.execute().     assertEquals("ABCDE", response.body().string()).     RecordedRequest request = server.takeRequest().     assertEquals("POST /foo HTTP/1.1", request.getRequestLine()).     assertArrayEquals(postBytes, request.getBody().readByteArray()).     assertNull(request.getHeader("Content-Length")). }
false;public;0;3;;@Override public MediaType contentType() {     return MediaType.get("text/plain. charset=utf-8"). }
false;public;0;3;;@Override public long contentLength() {     return postBytes.length. }
false;public;1;3;;@Override public void writeTo(BufferedSink sink) throws IOException {     sink.write(postBytes). }
false;public;0;30;;@Test public void userSuppliedContentLengthHeader() throws Exception {     byte[] postBytes = "FGHIJ".getBytes(UTF_8).     server.enqueue(new MockResponse().setBody("ABCDE")).     Call call = client.newCall(new Request.Builder().url(server.url("/foo")).post(new RequestBody() {          @Override         public MediaType contentType() {             return MediaType.get("text/plain. charset=utf-8").         }          @Override         public long contentLength() {             return postBytes.length.         }          @Override         public void writeTo(BufferedSink sink) throws IOException {             sink.write(postBytes).         }     }).build()).     Response response = call.execute().     assertEquals("ABCDE", response.body().string()).     RecordedRequest request = server.takeRequest().     assertEquals("POST /foo HTTP/1.1", request.getRequestLine()).     assertArrayEquals(postBytes, request.getBody().readByteArray()).     assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length"))). }
false;public;0;3;;@Override public MediaType contentType() {     return MediaType.get("text/plain. charset=utf-8"). }
false;public;0;3;;@Override public long contentLength() {     return postBytes.length. }
false;public;1;5;;@Override public void writeTo(BufferedSink sink) throws IOException {     // push bytes into the stream's buffer     sink.write(postBytes).     // Http2Connection.writeData subject to write window     sink.flush().     // Http2Connection.writeData empty frame     sink.close(). }
false;public;0;32;;@Test public void closeAfterFlush() throws Exception {     byte[] postBytes = "FGHIJ".getBytes(UTF_8).     server.enqueue(new MockResponse().setBody("ABCDE")).     Call call = client.newCall(new Request.Builder().url(server.url("/foo")).post(new RequestBody() {          @Override         public MediaType contentType() {             return MediaType.get("text/plain. charset=utf-8").         }          @Override         public long contentLength() {             return postBytes.length.         }          @Override         public void writeTo(BufferedSink sink) throws IOException {             // push bytes into the stream's buffer             sink.write(postBytes).             // Http2Connection.writeData subject to write window             sink.flush().             // Http2Connection.writeData empty frame             sink.close().         }     }).build()).     Response response = call.execute().     assertEquals("ABCDE", response.body().string()).     RecordedRequest request = server.takeRequest().     assertEquals("POST /foo HTTP/1.1", request.getRequestLine()).     assertArrayEquals(postBytes, request.getBody().readByteArray()).     assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length"))). }
false;public;0;23;;@Test public void connectionReuse() throws Exception {     server.enqueue(new MockResponse().setBody("ABCDEF")).     server.enqueue(new MockResponse().setBody("GHIJKL")).     Call call1 = client.newCall(new Request.Builder().url(server.url("/r1")).build()).     Call call2 = client.newCall(new Request.Builder().url(server.url("/r1")).build()).     Response response1 = call1.execute().     Response response2 = call2.execute().     assertEquals("ABC", response1.body().source().readUtf8(3)).     assertEquals("GHI", response2.body().source().readUtf8(3)).     assertEquals("DEF", response1.body().source().readUtf8(3)).     assertEquals("JKL", response2.body().source().readUtf8(3)).     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(1, server.takeRequest().getSequenceNumber()).     response1.close().     response2.close(). }
false;public;0;25;;@Test public void connectionWindowUpdateAfterCanceling() throws Exception {     server.enqueue(new MockResponse().setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1]))).     server.enqueue(new MockResponse().setBody("abc")).     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE).     // Cancel the call and discard what we've buffered for the response body. This should free up     // the connection flow-control window so new requests can proceed.     call1.cancel().     assertFalse("Call should not have completed successfully.", Util.discard(response1.body().source(), 1, TimeUnit.SECONDS)).     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals("abc", response2.body().string()). }
true;private;1;10;/**  * Wait for the client to receive {@code dataLength} DATA frames.  */ ;/**  * Wait for the client to receive {@code dataLength} DATA frames.  */ private void waitForDataFrames(int dataLength) throws Exception {     int expectedFrameCount = dataLength / 16384.     int dataFrameCount = 0.     while (dataFrameCount < expectedFrameCount) {         String log = http2Handler.take().         if (log.equals("FINE: << 0x00000003 16384 DATA          ")) {             dataFrameCount++.         }     } }
false;public;0;24;;@Test public void connectionWindowUpdateOnClose() throws Exception {     server.enqueue(new MockResponse().setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1]))).     server.enqueue(new MockResponse().setBody("abc")).     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE).     // Cancel the call and close the response body. This should discard the buffered data and update     // the connection flow-control window.     call1.cancel().     response1.close().     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals("abc", response2.body().string()). }
false;public;0;31;;@Test public void concurrentRequestWithEmptyFlowControlWindow() throws Exception {     server.enqueue(new MockResponse().setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE]))).     server.enqueue(new MockResponse().setBody("abc")).     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE).     assertEquals(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE, response1.body().contentLength()).     int read = response1.body().source().read(new byte[8192]).     assertEquals(8192, read).     // Make a second call that should transmit the response headers. The response body won't be     // transmitted until the flow-control window is updated from the first request.     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals(200, response2.code()).     // Close the response body. This should discard the buffered data and update the connection     // flow-control window.     response1.close().     assertEquals("abc", response2.body().string()). }
true;public;0;12;/**  * https://github.com/square/okhttp/issues/373  */ ;/**  * https://github.com/square/okhttp/issues/373  */ @Test @Ignore public void synchronousRequest() throws Exception {     server.enqueue(new MockResponse().setBody("A")).     server.enqueue(new MockResponse().setBody("A")).     ExecutorService executor = Executors.newCachedThreadPool().     CountDownLatch countDownLatch = new CountDownLatch(2).     executor.execute(new AsyncRequest("/r1", countDownLatch)).     executor.execute(new AsyncRequest("/r2", countDownLatch)).     countDownLatch.await().     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(1, server.takeRequest().getSequenceNumber()). }
false;public;0;12;;@Test public void gzippedResponseBody() throws Exception {     server.enqueue(new MockResponse().addHeader("Content-Encoding: gzip").setBody(gzip("ABCABCABC"))).     Call call = client.newCall(new Request.Builder().url(server.url("/r1")).build()).     Response response = call.execute().     assertEquals("ABCABCABC", response.body().string()). }
false;public;0;25;;@Test public void authenticate() throws Exception {     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED).addHeader("www-authenticate: Basic realm=\"protected area\"").setBody("Please authenticate.")).     server.enqueue(new MockResponse().setBody("Successful auth!")).     String credential = Credentials.basic("username", "password").     client = client.newBuilder().authenticator(new RecordingOkAuthenticator(credential, "Basic")).build().     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("Successful auth!", response.body().string()).     RecordedRequest denied = server.takeRequest().     assertNull(denied.getHeader("Authorization")).     RecordedRequest accepted = server.takeRequest().     assertEquals("GET / HTTP/1.1", accepted.getRequestLine()).     assertEquals(credential, accepted.getHeader("Authorization")). }
false;public;0;18;;@Test public void redirect() throws Exception {     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /foo").setBody("This page has moved!")).     server.enqueue(new MockResponse().setBody("This is the new location!")).     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("This is the new location!", response.body().string()).     RecordedRequest request1 = server.takeRequest().     assertEquals("/", request1.getPath()).     RecordedRequest request2 = server.takeRequest().     assertEquals("/foo", request2.getPath()). }
false;public;0;17;;@Test public void readAfterLastByte() throws Exception {     server.enqueue(new MockResponse().setBody("ABC")).     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     InputStream in = response.body().byteStream().     assertEquals('A', in.read()).     assertEquals('B', in.read()).     assertEquals('C', in.read()).     assertEquals(-1, in.read()).     assertEquals(-1, in.read()).     in.close(). }
false;public;0;30;;@Test public void readResponseHeaderTimeout() throws Exception {     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE)).     server.enqueue(new MockResponse().setBody("A")).     client = client.newBuilder().readTimeout(1000, MILLISECONDS).build().     // Make a call expecting a timeout reading the response headers.     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     try {         call1.execute().         fail("Should have timed out!").     } catch (SocketTimeoutException expected) {         assertEquals("timeout", expected.getMessage()).     }     // Confirm that a subsequent request on the same connection is not impacted.     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals("A", response2.body().string()).     // Confirm that the connection was reused.     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(1, server.takeRequest().getSequenceNumber()). }
true;public;0;17;/**  * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this  * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two  * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.  */ ;/**  * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this  * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two  * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.  */ @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {     // 4KiB to read.     char[] body = new char[4096].     Arrays.fill(body, 'y').     server.enqueue(new MockResponse().setBody(new String(body)).throttleBody(1024, 1, // Slow connection 1KiB/second.     SECONDS)).     client = client.newBuilder().readTimeout(2, SECONDS).build().     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals(new String(body), response.body().string()). }
true;public;0;35;/**  * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this  * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a  * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in  * time.  */ ;/**  * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this  * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a  * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in  * time.  */ @Test public void readTimeoutOnSlowConnection() throws Exception {     String body = TestUtil.repeat('y', 2048).     server.enqueue(new MockResponse().setBody(body).throttleBody(1024, 1, // Slow connection 1KiB/second.     SECONDS)).     server.enqueue(new MockResponse().setBody(body)).     client = client.newBuilder().readTimeout(500, // Half a second to read something.     MILLISECONDS).build().     // Make a call expecting a timeout reading the response body.     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     try {         response1.body().string().         fail("Should have timed out!").     } catch (SocketTimeoutException expected) {         assertEquals("timeout", expected.getMessage()).     }     // Confirm that a subsequent request on the same connection is not impacted.     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals(body, response2.body().string()).     // Confirm that the connection was reused.     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(1, server.takeRequest().getSequenceNumber()). }
false;public;0;34;;@Test public void connectionTimeout() throws Exception {     server.enqueue(new MockResponse().setBody("A").setBodyDelay(1, SECONDS)).     OkHttpClient client1 = client.newBuilder().readTimeout(2000, MILLISECONDS).build().     Call call1 = client1.newCall(new Request.Builder().url(server.url("/")).build()).     OkHttpClient client2 = client.newBuilder().readTimeout(200, MILLISECONDS).build().     Call call2 = client2.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     assertEquals("A", response1.body().string()).     try {         call2.execute().         fail().     } catch (IOException expected) {     }     // Confirm that the connection was reused.     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(1, server.takeRequest().getSequenceNumber()). }
false;public;0;35;;@Test public void responsesAreCached() throws IOException {     client = client.newBuilder().cache(cache).build().     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A")).     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     assertEquals("A", response1.body().string()).     assertEquals(1, cache.requestCount()).     assertEquals(1, cache.networkCount()).     assertEquals(0, cache.hitCount()).     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals("A", response2.body().string()).     Call call3 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response3 = call3.execute().     assertEquals("A", response3.body().string()).     assertEquals(3, cache.requestCount()).     assertEquals(1, cache.networkCount()).     assertEquals(2, cache.hitCount()). }
false;public;0;31;;@Test public void conditionalCache() throws IOException {     client = client.newBuilder().cache(cache).build().     server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A")).     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)).     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     assertEquals("A", response1.body().string()).     assertEquals(1, cache.requestCount()).     assertEquals(1, cache.networkCount()).     assertEquals(0, cache.hitCount()).     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals("A", response2.body().string()).     assertEquals(2, cache.requestCount()).     assertEquals(2, cache.networkCount()).     assertEquals(1, cache.hitCount()). }
false;public;0;26;;@Test public void responseCachedWithoutConsumingFullBody() throws IOException {     client = client.newBuilder().cache(cache).build().     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD")).     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH")).     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     assertEquals("AB", response1.body().source().readUtf8(2)).     response1.body().close().     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals("ABCD", response2.body().source().readUtf8()).     response2.body().close(). }
false;public;0;22;;@Test public void sendRequestCookies() throws Exception {     RecordingCookieJar cookieJar = new RecordingCookieJar().     Cookie requestCookie = new Cookie.Builder().name("a").value("b").domain(server.getHostName()).build().     cookieJar.enqueueRequestCookies(requestCookie).     client = client.newBuilder().cookieJar(cookieJar).build().     server.enqueue(new MockResponse()).     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("", response.body().string()).     RecordedRequest request = server.takeRequest().     assertEquals("a=b", request.getHeader("Cookie")). }
false;public;0;17;;@Test public void receiveResponseCookies() throws Exception {     RecordingCookieJar cookieJar = new RecordingCookieJar().     client = client.newBuilder().cookieJar(cookieJar).build().     server.enqueue(new MockResponse().addHeader("set-cookie: a=b")).     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("", response.body().string()).     cookieJar.assertResponseCookies("a=b. path=/"). }
false;public;0;25;;@Test public void cancelWithStreamNotCompleted() throws Exception {     server.enqueue(new MockResponse().setBody("abc")).     server.enqueue(new MockResponse().setBody("def")).     // Disconnect before the stream is created. A connection is still established!     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call1.execute().     call1.cancel().     // That connection is pooled, and it works.     assertEquals(1, client.connectionPool().connectionCount()).     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals("def", response2.body().string()).     assertEquals(0, server.takeRequest().getSequenceNumber()).     // Clean up the connection.     response.close(). }
false;public;0;16;;@Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode)).     server.enqueue(new MockResponse().setBody("abc")).     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("abc", response.body().string()).     // New connection.     assertEquals(0, server.takeRequest().getSequenceNumber()).     // Reused connection.     assertEquals(1, server.takeRequest().getSequenceNumber()). }
false;public;0;20;;@Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode)).     server.enqueue(new MockResponse().setBody("abc")).     client = client.newBuilder().dns(new DoubleInetAddressDns()).build().     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("abc", response.body().string()).     // New connection.     assertEquals(0, server.takeRequest().getSequenceNumber()).     // New connection.     assertEquals(0, server.takeRequest().getSequenceNumber()). }
false;public;0;24;;@Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode)).     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode)).     server.enqueue(new MockResponse().setBody("abc")).     client = client.newBuilder().dns(new DoubleInetAddressDns()).build().     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("abc", response.body().string()).     // New connection.     assertEquals(0, server.takeRequest().getSequenceNumber()).     // Reused connection.     assertEquals(1, server.takeRequest().getSequenceNumber()).     // New connection.     assertEquals(0, server.takeRequest().getSequenceNumber()). }
false;public;0;21;;@Test public void recoverFromCancelReusesConnection() throws Exception {     server.enqueue(new MockResponse().setBodyDelay(10, TimeUnit.SECONDS).setBody("abc")).     server.enqueue(new MockResponse().setBody("def")).     client = client.newBuilder().dns(new DoubleInetAddressDns()).build().     callAndCancel(0).     // Make a second request to ensure the connection is reused.     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("def", response.body().string()).     assertEquals(1, server.takeRequest().getSequenceNumber()). }
false;public;0;25;;@Test public void recoverFromMultipleCancelReusesConnection() throws Exception {     server.enqueue(new MockResponse().setBodyDelay(10, TimeUnit.SECONDS).setBody("abc")).     server.enqueue(new MockResponse().setBodyDelay(10, TimeUnit.SECONDS).setBody("def")).     server.enqueue(new MockResponse().setBody("ghi")).     client = client.newBuilder().dns(new DoubleInetAddressDns()).build().     callAndCancel(0).     callAndCancel(1).     // Make a third request to ensure the connection is reused.     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("ghi", response.body().string()).     assertEquals(2, server.takeRequest().getSequenceNumber()). }
false;public;2;3;;@Override public void onFailure(Call call1, IOException e) {     latch.countDown(). }
false;public;2;2;;@Override public void onResponse(Call call1, Response response) { }
true;private;1;17;/**  * Make a call and canceling it as soon as it's accepted by the server.  */ ;/**  * Make a call and canceling it as soon as it's accepted by the server.  */ private void callAndCancel(int expectedSequenceNumber) throws Exception {     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     CountDownLatch latch = new CountDownLatch(1).     call.enqueue(new Callback() {          @Override         public void onFailure(Call call1, IOException e) {             latch.countDown().         }          @Override         public void onResponse(Call call1, Response response) {         }     }).     assertEquals(expectedSequenceNumber, server.takeRequest().getSequenceNumber()).     call.cancel().     latch.await(). }
false;public;0;3;;@Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {     noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM). }
false;public;0;3;;@Test public void noRecoveryFromInternalErrorWithRetryDisabled() throws Exception {     noRecoveryFromErrorWithRetryDisabled(ErrorCode.INTERNAL_ERROR). }
false;private;1;21;;private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Exception {     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(errorCode.httpCode)).     server.enqueue(new MockResponse().setBody("abc")).     client = client.newBuilder().retryOnConnectionFailure(false).build().     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     try {         call.execute().         fail().     } catch (StreamResetException expected) {         assertEquals(errorCode, expected.errorCode).     } }
false;public;2;3;;@Override public void onFailure(Call call, IOException e) {     fail(). }
false;public;2;3;;@Override public void onResponse(Call call, Response response) throws IOException {     responses.offer(response.body().string()). }
false;public;0;65;;@Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws Exception {     server.enqueue(new MockResponse().setResponseCode(401)).     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode)).     server.enqueue(new MockResponse().setBody("DEF")).     server.enqueue(new MockResponse().setResponseCode(301).addHeader("Location", "/foo")).     server.enqueue(new MockResponse().setBody("ABC")).     CountDownLatch latch = new CountDownLatch(1).     BlockingQueue<String> responses = new SynchronousQueue<>().     okhttp3.Authenticator authenticator = (route, response) -> {         responses.offer(response.body().string()).         try {             latch.await().         } catch (InterruptedException e) {             throw new AssertionError().         }         return response.request().     }.     OkHttpClient blockingAuthClient = client.newBuilder().authenticator(authenticator).build().     Callback callback = new Callback() {          @Override         public void onFailure(Call call, IOException e) {             fail().         }          @Override         public void onResponse(Call call, Response response) throws IOException {             responses.offer(response.body().string()).         }     }.     // Make the first request waiting until we get our auth challenge.     Request request = new Request.Builder().url(server.url("/")).build().     blockingAuthClient.newCall(request).enqueue(callback).     String response1 = responses.take().     assertEquals("", response1).     assertEquals(0, server.takeRequest().getSequenceNumber()).     // Now make the second request which will restrict the first HTTP/2 connection from creating new     // streams.     client.newCall(request).enqueue(callback).     String response2 = responses.take().     assertEquals("DEF", response2).     assertEquals(1, server.takeRequest().getSequenceNumber()).     assertEquals(0, server.takeRequest().getSequenceNumber()).     // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new     // one.     latch.countDown().     String response3 = responses.take().     assertEquals("ABC", response3).     assertEquals(1, server.takeRequest().getSequenceNumber()).     assertEquals(2, server.takeRequest().getSequenceNumber()). }
false;public;0;14;;@Test public void nonAsciiResponseHeader() throws Exception {     server.enqueue(new MockResponse().addHeaderLenient("Alpha", "α").addHeaderLenient("β", "Beta")).     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     response.close().     assertEquals("α", response.header("Alpha")).     assertEquals("Beta", response.header("β")). }
false;public;0;26;;@Test public void serverSendsPushPromise_GET() throws Exception {     PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"), new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet")).     server.enqueue(new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet").withPush(pushPromise)).     Call call = client.newCall(new Request.Builder().url(server.url("/foo")).build()).     Response response = call.execute().     assertEquals("ABCDE", response.body().string()).     assertEquals(200, response.code()).     assertEquals("", response.message()).     RecordedRequest request = server.takeRequest().     assertEquals("GET /foo HTTP/1.1", request.getRequestLine()).     assertEquals(scheme, request.getHeader(":scheme")).     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority")).     RecordedRequest pushedRequest = server.takeRequest().     assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine()).     assertEquals("bar", pushedRequest.getHeader("foo")). }
false;public;0;25;;@Test public void serverSendsPushPromise_HEAD() throws Exception {     PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"), new MockResponse().setStatus("HTTP/1.1 204 Sweet")).     server.enqueue(new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet").withPush(pushPromise)).     Call call = client.newCall(new Request.Builder().url(server.url("/foo")).build()).     Response response = call.execute().     assertEquals("ABCDE", response.body().string()).     assertEquals(200, response.code()).     assertEquals("", response.message()).     RecordedRequest request = server.takeRequest().     assertEquals("GET /foo HTTP/1.1", request.getRequestLine()).     assertEquals(scheme, request.getHeader(":scheme")).     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority")).     RecordedRequest pushedRequest = server.takeRequest().     assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine()).     assertEquals("bar", pushedRequest.getHeader("foo")). }
false;public;0;17;;@Test public void noDataFramesSentWithNullRequestBody() throws Exception {     server.enqueue(new MockResponse().setBody("ABC")).     Call call = client.newCall(new Request.Builder().url(server.url("/")).method("DELETE", null).build()).     Response response = call.execute().     assertEquals("ABC", response.body().string()).     assertEquals(protocol, response.protocol()).     List<String> logs = http2Handler.takeAll().     assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_STREAM|END_HEADERS")). }
false;public;0;18;;@Test public void emptyDataFrameSentWithEmptyBody() throws Exception {     server.enqueue(new MockResponse().setBody("ABC")).     Call call = client.newCall(new Request.Builder().url(server.url("/")).method("DELETE", Util.EMPTY_REQUEST).build()).     Response response = call.execute().     assertEquals("ABC", response.body().string()).     assertEquals(protocol, response.protocol()).     List<String> logs = http2Handler.takeAll().     assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_HEADERS")).     assertThat("data logged", firstFrame(logs, "DATA"), containsString("0 DATA          END_STREAM")). }
false;public;0;26;;@Test public void pingsTransmitted() throws Exception {     // Ping every 500 ms, starting at 500 ms.     client = client.newBuilder().pingInterval(500, TimeUnit.MILLISECONDS).build().     // Delay the response to give 1 ping enough time to be sent and replied to.     server.enqueue(new MockResponse().setBodyDelay(750, TimeUnit.MILLISECONDS).setBody("ABC")).     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("ABC", response.body().string()).     assertEquals(protocol, response.protocol()).     // Confirm a single ping was sent and received, and its reply was sent and received.     List<String> logs = http2Handler.takeAll().     assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).     assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          ")).     assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK")).     assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")). }
false;public;0;31;;@Test public void missingPongsFailsConnection() throws Exception {     // Ping every 500 ms, starting at 500 ms.     client = client.newBuilder().readTimeout(10, // Confirm we fail before the read timeout.     TimeUnit.SECONDS).pingInterval(500, TimeUnit.MILLISECONDS).build().     // Set up the server to ignore the socket. It won't respond to pings!     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START)).     // Make a call. It'll fail as soon as our pings detect a problem.     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     long executeAtNanos = System.nanoTime().     try {         call.execute().         fail().     } catch (StreamResetException expected) {         assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage()).     }     long elapsedUntilFailure = System.nanoTime() - executeAtNanos.     assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d).     // Confirm a single ping was sent but not acknowledged.     List<String> logs = http2Handler.takeAll().     assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).     assertEquals(0, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")). }
false;private;2;8;;private String firstFrame(List<String> logs, String type) {     for (String log : logs) {         if (log.contains(type)) {             return log.         }     }     return null. }
false;private;2;9;;private int countFrames(List<String> logs, String message) {     int result = 0.     for (String log : logs) {         if (log.equals(message)) {             result++.         }     }     return result. }
true;public;0;43;/**  * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and  * confirm that the third concurrent request prepared a new connection.  */ ;/**  * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and  * confirm that the third concurrent request prepared a new connection.  */ @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {     Settings settings = new Settings().     settings.set(Settings.MAX_CONCURRENT_STREAMS, 2).     // Read & write a full request to confirm settings are accepted.     server.enqueue(new MockResponse().withSettings(settings)).     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("", response.body().string()).     server.enqueue(new MockResponse().setBody("ABC")).     server.enqueue(new MockResponse().setBody("DEF")).     server.enqueue(new MockResponse().setBody("GHI")).     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     Call call3 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response3 = call3.execute().     assertEquals("ABC", response1.body().string()).     assertEquals("DEF", response2.body().string()).     assertEquals("GHI", response3.body().string()).     // Settings connection.     assertEquals(0, server.takeRequest().getSequenceNumber()).     // Reuse settings connection.     assertEquals(1, server.takeRequest().getSequenceNumber()).     // Reuse settings connection.     assertEquals(2, server.takeRequest().getSequenceNumber()).     // New connection!     assertEquals(0, server.takeRequest().getSequenceNumber()). }
false;public;0;21;;@Test public void connectionNotReusedAfterShutdown() throws Exception {     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_END).setBody("ABC")).     server.enqueue(new MockResponse().setBody("DEF")).     Call call1 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response1 = call1.execute().     assertEquals("ABC", response1.body().string()).     Call call2 = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response2 = call2.execute().     assertEquals("DEF", response2.body().string()).     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(0, server.takeRequest().getSequenceNumber()). }
false;public;1;16;;@Override public Response intercept(Chain chain) throws IOException {     if (!executedCall) {         // At this point, we have a healthy HTTP/2 connection. This call will trigger the         // server to send a GOAWAY frame, leaving the connection in a shutdown state.         executedCall = true.         Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).         Response response = call.execute().         assertEquals("ABC", response.body().string()).         // Wait until the GOAWAY has been processed.         RealConnection connection = (RealConnection) chain.connection().         while (connection.isHealthy(false)) .     }     return chain.proceed(chain.request()). }
true;public;0;39;/**  * This simulates a race condition where we receive a healthy HTTP/2 connection and just prior to  * writing our request, we get a GOAWAY frame from the server.  */ ;/**  * This simulates a race condition where we receive a healthy HTTP/2 connection and just prior to  * writing our request, we get a GOAWAY frame from the server.  */ @Test public void connectionShutdownAfterHealthCheck() throws Exception {     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_END).setBody("ABC")).     server.enqueue(new MockResponse().setBody("DEF")).     OkHttpClient client2 = client.newBuilder().addNetworkInterceptor(new Interceptor() {          boolean executedCall.          @Override         public Response intercept(Chain chain) throws IOException {             if (!executedCall) {                 // At this point, we have a healthy HTTP/2 connection. This call will trigger the                 // server to send a GOAWAY frame, leaving the connection in a shutdown state.                 executedCall = true.                 Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).                 Response response = call.execute().                 assertEquals("ABC", response.body().string()).                 // Wait until the GOAWAY has been processed.                 RealConnection connection = (RealConnection) chain.connection().                 while (connection.isHealthy(false)) .             }             return chain.proceed(chain.request()).         }     }).build().     Call call = client2.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("DEF", response.body().string()).     assertEquals(0, server.takeRequest().getSequenceNumber()).     assertEquals(0, server.takeRequest().getSequenceNumber()). }
false;public;2;3;;@Override public void onResponse(Call call, Response response) throws IOException {     bodies.add(response.body().string()). }
false;public;2;3;;@Override public void onFailure(Call call, IOException e) {     System.out.println(e). }
false;public;0;24;;@Test public void responseHeadersAfterGoaway() throws Exception {     server.enqueue(new MockResponse().setHeadersDelay(1, SECONDS).setBody("ABC")).     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_END).setBody("DEF")).     BlockingQueue<String> bodies = new SynchronousQueue<>().     Callback callback = new Callback() {          @Override         public void onResponse(Call call, Response response) throws IOException {             bodies.add(response.body().string()).         }          @Override         public void onFailure(Call call, IOException e) {             System.out.println(e).         }     }.     client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback).     client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback).     assertEquals("DEF", bodies.poll(2, SECONDS)).     assertEquals("ABC", bodies.poll(2, SECONDS)).     assertEquals(2, server.getRequestCount()). }
false;public;1;19;;@Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {     MockResponse result = queueDispatcher.dispatch(request).     requestCount++.     if (requestCount == 1) {         // Before handling call1's CONNECT we do all of call2. This part re-entrant!         try {             Call call2 = client.newCall(new Request.Builder().url("https://android.com/call2").build()).             Response response2 = call2.execute().             assertEquals("call2 response", response2.body().string()).         } catch (IOException e) {             throw new RuntimeException(e).         }     }     return result. }
false;public;0;3;;@Override public MockResponse peek() {     return queueDispatcher.peek(). }
false;public;0;3;;@Override public void shutdown() {     queueDispatcher.shutdown(). }
true;public;0;80;/**  * We don't know if the connection will support HTTP/2 until after we've connected. When multiple  * connections are requested concurrently OkHttp will pessimistically connect multiple times, then  * close any unnecessary connections. This test confirms that behavior works as intended.  *  * <p>This test uses proxy tunnels to get a hook while a connection is being established.  */ ;/**  * We don't know if the connection will support HTTP/2 until after we've connected. When multiple  * connections are requested concurrently OkHttp will pessimistically connect multiple times, then  * close any unnecessary connections. This test confirms that behavior works as intended.  *  * <p>This test uses proxy tunnels to get a hook while a connection is being established.  */ @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {     assumeTrue(protocol == Protocol.HTTP_2).     server.useHttps(handshakeCertificates.sslSocketFactory(), true).     QueueDispatcher queueDispatcher = new QueueDispatcher().     queueDispatcher.enqueueResponse(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders()).     queueDispatcher.enqueueResponse(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders()).     queueDispatcher.enqueueResponse(new MockResponse().setBody("call2 response")).     queueDispatcher.enqueueResponse(new MockResponse().setBody("call1 response")).     // We use a re-entrant dispatcher to initiate one HTTPS connection while the other is in flight.     server.setDispatcher(new Dispatcher() {          int requestCount.          @Override         public MockResponse dispatch(RecordedRequest request) throws InterruptedException {             MockResponse result = queueDispatcher.dispatch(request).             requestCount++.             if (requestCount == 1) {                 // Before handling call1's CONNECT we do all of call2. This part re-entrant!                 try {                     Call call2 = client.newCall(new Request.Builder().url("https://android.com/call2").build()).                     Response response2 = call2.execute().                     assertEquals("call2 response", response2.body().string()).                 } catch (IOException e) {                     throw new RuntimeException(e).                 }             }             return result.         }          @Override         public MockResponse peek() {             return queueDispatcher.peek().         }          @Override         public void shutdown() {             queueDispatcher.shutdown().         }     }).     client = client.newBuilder().proxy(server.toProxyAddress()).build().     Call call1 = client.newCall(new Request.Builder().url("https://android.com/call1").build()).     Response response2 = call1.execute().     assertEquals("call1 response", response2.body().string()).     RecordedRequest call1Connect = server.takeRequest().     assertEquals("CONNECT", call1Connect.getMethod()).     assertEquals(0, call1Connect.getSequenceNumber()).     RecordedRequest call2Connect = server.takeRequest().     assertEquals("CONNECT", call2Connect.getMethod()).     assertEquals(0, call2Connect.getSequenceNumber()).     RecordedRequest call2Get = server.takeRequest().     assertEquals("GET", call2Get.getMethod()).     assertEquals("/call2", call2Get.getPath()).     assertEquals(0, call2Get.getSequenceNumber()).     RecordedRequest call1Get = server.takeRequest().     assertEquals("GET", call1Get.getMethod()).     assertEquals("/call1", call1Get.getPath()).     assertEquals(1, call1Get.getSequenceNumber()).     assertEquals(1, client.connectionPool().connectionCount()). }
false;public;1;6;;@Override public Response intercept(Chain chain) throws IOException {     Request request = chain.request().newBuilder().header("Host", "privateobject.com").build().     return chain.proceed(request). }
true;public;0;24;/**  * https://github.com/square/okhttp/issues/3103  */ ;/**  * https://github.com/square/okhttp/issues/3103  */ @Test public void domainFronting() throws Exception {     client = client.newBuilder().addNetworkInterceptor(new Interceptor() {          @Override         public Response intercept(Chain chain) throws IOException {             Request request = chain.request().newBuilder().header("Host", "privateobject.com").build().             return chain.proceed(request).         }     }).build().     server.enqueue(new MockResponse()).     Call call = client.newCall(new Request.Builder().url(server.url("/")).build()).     Response response = call.execute().     assertEquals("", response.body().string()).     RecordedRequest recordedRequest = server.takeRequest().     assertEquals("privateobject.com", recordedRequest.getHeader(":authority")). }
false;private;1;7;;private Buffer gzip(String bytes) throws IOException {     Buffer bytesOut = new Buffer().     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut)).     sink.writeUtf8(bytes).     sink.close().     return bytesOut. }
false;public;0;12;;@Override public void run() {     try {         Call call = client.newCall(new Request.Builder().url(server.url(path)).build()).         Response response = call.execute().         assertEquals("A", response.body().string()).         countDownLatch.countDown().     } catch (Exception e) {         throw new RuntimeException(e).     } }
