commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static void main(String... args) throws IOException {     new AutobahnTester().run(). }
false;private;2;4;;private WebSocket newWebSocket(String path, WebSocketListener listener) {     Request request = new Request.Builder().url(HOST + path).build().     return client.newWebSocket(request, listener). }
false;public;0;14;;public void run() throws IOException {     try {         long count = getTestCount().         System.out.println("Test count: " + count).         for (long number = 1. number <= count. number++) {             runTest(number, count).         }         updateReports().     } finally {         client.dispatcher().executorService().shutdown().     } }
false;public;2;4;;@Override public void onOpen(WebSocket webSocket, Response response) {     System.out.println("Executing test case " + number + "/" + count).     startNanos.set(System.nanoTime()). }
false;public;2;3;;@Override public void onMessage(final WebSocket webSocket, final ByteString bytes) {     webSocket.send(bytes). }
false;public;2;3;;@Override public void onMessage(final WebSocket webSocket, final String text) {     webSocket.send(text). }
false;public;3;4;;@Override public void onClosing(WebSocket webSocket, int code, String reason) {     webSocket.close(1000, null).     latch.countDown(). }
false;public;3;4;;@Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {     t.printStackTrace(System.out).     latch.countDown(). }
false;private;2;39;;private void runTest(final long number, final long count) {     final CountDownLatch latch = new CountDownLatch(1).     final AtomicLong startNanos = new AtomicLong().     newWebSocket("/runCase?case=" + number + "&agent=okhttp", new WebSocketListener() {          @Override         public void onOpen(WebSocket webSocket, Response response) {             System.out.println("Executing test case " + number + "/" + count).             startNanos.set(System.nanoTime()).         }          @Override         public void onMessage(final WebSocket webSocket, final ByteString bytes) {             webSocket.send(bytes).         }          @Override         public void onMessage(final WebSocket webSocket, final String text) {             webSocket.send(text).         }          @Override         public void onClosing(WebSocket webSocket, int code, String reason) {             webSocket.close(1000, null).             latch.countDown().         }          @Override         public void onFailure(WebSocket webSocket, Throwable t, Response response) {             t.printStackTrace(System.out).             latch.countDown().         }     }).     try {         if (!latch.await(30, TimeUnit.SECONDS)) {             throw new IllegalStateException("Timed out waiting for test " + number + " to finish.").         }     } catch (InterruptedException e) {         throw new AssertionError().     }     long endNanos = System.nanoTime().     long tookMs = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos.get()).     System.out.println("Took " + tookMs + "ms"). }
false;public;2;3;;@Override public void onMessage(WebSocket webSocket, String text) {     countRef.set(Long.parseLong(text)). }
false;public;3;4;;@Override public void onClosing(WebSocket webSocket, int code, String reason) {     webSocket.close(1000, null).     latch.countDown(). }
false;public;3;4;;@Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {     failureRef.set(t).     latch.countDown(). }
false;private;0;32;;private long getTestCount() throws IOException {     final CountDownLatch latch = new CountDownLatch(1).     final AtomicLong countRef = new AtomicLong().     final AtomicReference<Throwable> failureRef = new AtomicReference<>().     newWebSocket("/getCaseCount", new WebSocketListener() {          @Override         public void onMessage(WebSocket webSocket, String text) {             countRef.set(Long.parseLong(text)).         }          @Override         public void onClosing(WebSocket webSocket, int code, String reason) {             webSocket.close(1000, null).             latch.countDown().         }          @Override         public void onFailure(WebSocket webSocket, Throwable t, Response response) {             failureRef.set(t).             latch.countDown().         }     }).     try {         if (!latch.await(10, TimeUnit.SECONDS)) {             throw new IllegalStateException("Timed out waiting for count.").         }     } catch (InterruptedException e) {         throw new AssertionError().     }     Throwable failure = failureRef.get().     if (failure != null) {         throw new RuntimeException(failure).     }     return countRef.get(). }
false;public;3;4;;@Override public void onClosing(WebSocket webSocket, int code, String reason) {     webSocket.close(1000, null).     latch.countDown(). }
false;public;3;3;;@Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {     latch.countDown(). }
false;private;0;20;;private void updateReports() {     final CountDownLatch latch = new CountDownLatch(1).     newWebSocket("/updateReports?agent=" + Version.userAgent(), new WebSocketListener() {          @Override         public void onClosing(WebSocket webSocket, int code, String reason) {             webSocket.close(1000, null).             latch.countDown().         }          @Override         public void onFailure(WebSocket webSocket, Throwable t, Response response) {             latch.countDown().         }     }).     try {         if (!latch.await(10, TimeUnit.SECONDS)) {             throw new IllegalStateException("Timed out waiting for count.").         }     } catch (InterruptedException e) {         throw new AssertionError().     } }
