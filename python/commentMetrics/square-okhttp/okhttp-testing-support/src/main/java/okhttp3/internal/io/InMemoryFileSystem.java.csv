commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void evaluate() throws Throwable {     base.evaluate().     ensureResourcesClosed(). }
false;public;2;8;;@Override public Statement apply(final Statement base, Description description) {     return new Statement() {          @Override         public void evaluate() throws Throwable {             base.evaluate().             ensureResourcesClosed().         }     }. }
false;public;0;16;;public void ensureResourcesClosed() {     List<String> openResources = new ArrayList<>().     for (File file : openSources.values()) {         openResources.add("Source for " + file).     }     for (File file : openSinks.values()) {         openResources.add("Sink for " + file).     }     if (!openResources.isEmpty()) {         StringBuilder builder = new StringBuilder("Resources acquired but not closed:").         for (String resource : openResources) {             builder.append("\n * ").append(resource).         }         throw new IllegalStateException(builder.toString()).     } }
false;public;0;4;;@Override public void close() throws IOException {     openSources.remove(source).     super.close(). }
false;public;1;14;;@Override public Source source(File file) throws FileNotFoundException {     Buffer result = files.get(file).     if (result == null)         throw new FileNotFoundException().     final Source source = result.clone().     openSources.put(source, file).     return new ForwardingSource(source) {          @Override         public void close() throws IOException {             openSources.remove(source).             super.close().         }     }. }
false;public;1;3;;@Override public Sink sink(File file) throws FileNotFoundException {     return sink(file, false). }
false;public;1;3;;@Override public Sink appendingSink(File file) throws FileNotFoundException {     return sink(file, true). }
false;public;0;4;;@Override public void close() throws IOException {     openSinks.remove(sink).     super.close(). }
false;private;2;20;;private Sink sink(File file, boolean appending) {     Buffer result = null.     if (appending) {         result = files.get(file).     }     if (result == null) {         result = new Buffer().     }     files.put(file, result).     final Sink sink = result.     openSinks.put(sink, file).     return new ForwardingSink(sink) {          @Override         public void close() throws IOException {             openSinks.remove(sink).             super.close().         }     }. }
false;public;1;3;;@Override public void delete(File file) throws IOException {     files.remove(file). }
false;public;1;3;;@Override public boolean exists(File file) {     return files.containsKey(file). }
false;public;1;4;;@Override public long size(File file) {     Buffer buffer = files.get(file).     return buffer != null ? buffer.size() : 0L. }
false;public;2;5;;@Override public void rename(File from, File to) throws IOException {     Buffer buffer = files.remove(from).     if (buffer == null)         throw new FileNotFoundException().     files.put(to, buffer). }
false;public;1;7;;@Override public void deleteContents(File directory) throws IOException {     String prefix = directory.toString() + "/".     for (Iterator<File> i = files.keySet().iterator(). i.hasNext(). ) {         File file = i.next().         if (file.toString().startsWith(prefix))             i.remove().     } }
