commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;@Before public void setUp() {     executorService = Executors.newCachedThreadPool(). }
false;public;0;4;;@After public void tearDown() {     executorService.shutdown().     closeQuietly(serverSocket). }
false;public;0;50;;@Test public void clientAndServer() throws Exception {     HeldCertificate clientRoot = new HeldCertificate.Builder().certificateAuthority(1).build().     HeldCertificate clientIntermediate = new HeldCertificate.Builder().certificateAuthority(0).signedBy(clientRoot).build().     HeldCertificate clientCertificate = new HeldCertificate.Builder().signedBy(clientIntermediate).build().     HeldCertificate serverRoot = new HeldCertificate.Builder().certificateAuthority(1).build().     HeldCertificate serverIntermediate = new HeldCertificate.Builder().certificateAuthority(0).signedBy(serverRoot).build().     HeldCertificate serverCertificate = new HeldCertificate.Builder().signedBy(serverIntermediate).build().     HandshakeCertificates server = new HandshakeCertificates.Builder().addTrustedCertificate(clientRoot.certificate()).heldCertificate(serverCertificate, serverIntermediate.certificate()).build().     HandshakeCertificates client = new HandshakeCertificates.Builder().addTrustedCertificate(serverRoot.certificate()).heldCertificate(clientCertificate, clientIntermediate.certificate()).build().     InetSocketAddress serverAddress = startTlsServer().     Future<Handshake> serverHandshakeFuture = doServerHandshake(server).     Future<Handshake> clientHandshakeFuture = doClientHandshake(client, serverAddress).     Handshake serverHandshake = serverHandshakeFuture.get().     assertEquals(serverHandshake.peerCertificates(), Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate())).     assertEquals(serverHandshake.localCertificates(), Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate())).     Handshake clientHandshake = clientHandshakeFuture.get().     assertEquals(clientHandshake.peerCertificates(), Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate())).     assertEquals(clientHandshake.localCertificates(), Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate())). }
false;public;0;20;;@Test public void keyManager() {     HeldCertificate root = new HeldCertificate.Builder().certificateAuthority(1).build().     HeldCertificate intermediate = new HeldCertificate.Builder().certificateAuthority(0).signedBy(root).build().     HeldCertificate certificate = new HeldCertificate.Builder().signedBy(intermediate).build().     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().heldCertificate(certificate, intermediate.certificate()).build().     assertPrivateKeysEquals(certificate.keyPair().getPrivate(), handshakeCertificates.keyManager().getPrivateKey("private")).     assertEquals(Arrays.asList(certificate.certificate(), intermediate.certificate()), Arrays.asList(handshakeCertificates.keyManager().getCertificateChain("private"))). }
false;public;0;13;;@Test public void platformTrustedCertificates() {     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().addPlatformTrustedCertificates().build().     Set<String> names = new LinkedHashSet<>().     for (X509Certificate certificate : handshakeCertificates.trustManager().getAcceptedIssuers()) {         // Abbreviate a long name like "CN=Entrust Root Certification Authority - G2, OU=..."         String name = certificate.getSubjectDN().getName().         names.add(name.substring(0, name.indexOf(" "))).     }     // It's safe to assume all platforms will have a major Internet certificate issuer.     assertTrue(names.toString(), names.contains("CN=Entrust")). }
false;private;0;7;;private InetSocketAddress startTlsServer() throws IOException {     ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault().     serverSocket = serverSocketFactory.createServerSocket().     InetAddress serverAddress = InetAddress.getByName("localhost").     serverSocket.bind(new InetSocketAddress(serverAddress, 0), 50).     return new InetSocketAddress(serverAddress, serverSocket.getLocalPort()). }
false;private;1;18;;private Future<Handshake> doServerHandshake(HandshakeCertificates server) {     return executorService.submit(() -> {         Socket rawSocket = null.         SSLSocket sslSocket = null.         try {             rawSocket = serverSocket.accept().             sslSocket = (SSLSocket) server.sslSocketFactory().createSocket(rawSocket, rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true).             sslSocket.setUseClientMode(false).             sslSocket.setWantClientAuth(true).             sslSocket.startHandshake().             return Handshake.get(sslSocket.getSession()).         } finally {             closeQuietly(rawSocket).             closeQuietly(sslSocket).         }     }). }
false;private;2;17;;private Future<Handshake> doClientHandshake(HandshakeCertificates client, InetSocketAddress serverAddress) {     return executorService.submit(() -> {         Socket rawSocket = SocketFactory.getDefault().createSocket().         rawSocket.connect(serverAddress).         SSLSocket sslSocket = null.         try {             sslSocket = (SSLSocket) client.sslSocketFactory().createSocket(rawSocket, rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true).             sslSocket.startHandshake().             return Handshake.get(sslSocket.getSession()).         } finally {             closeQuietly(rawSocket).             closeQuietly(sslSocket).         }     }). }
false;private;2;3;;private void assertPrivateKeysEquals(PrivateKey expected, PrivateKey actual) {     assertEquals(ByteString.of(expected.getEncoded()), ByteString.of(actual.getEncoded())). }
