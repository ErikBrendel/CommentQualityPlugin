commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public X509KeyManager keyManager() {     return keyManager. }
false;public;0;3;;public X509TrustManager trustManager() {     return trustManager. }
false;public;0;3;;public SSLSocketFactory sslSocketFactory() {     return sslContext().getSocketFactory(). }
false;public;0;10;;public SSLContext sslContext() {     try {         SSLContext sslContext = Platform.get().getSSLContext().         sslContext.init(new KeyManager[] { keyManager }, new TrustManager[] { trustManager }, new SecureRandom()).         return sslContext.     } catch (KeyManagementException e) {         throw new AssertionError(e).     } }
true;public;2;6;/**  * Configure the certificate chain to use when being authenticated. The first certificate is  * the held certificate, further certificates are included in the handshake so the peer can  * build a trusted path to a trusted root certificate.  *  * <p>The chain should include all intermediate certificates but does not need the root  * certificate that we expect to be known by the remote peer. The peer already has that  * certificate so transmitting it is unnecessary.  */ ;/**  * Configure the certificate chain to use when being authenticated. The first certificate is  * the held certificate, further certificates are included in the handshake so the peer can  * build a trusted path to a trusted root certificate.  *  * <p>The chain should include all intermediate certificates but does not need the root  * certificate that we expect to be known by the remote peer. The peer already has that  * certificate so transmitting it is unnecessary.  */ public Builder heldCertificate(HeldCertificate heldCertificate, X509Certificate... intermediates) {     this.heldCertificate = heldCertificate.     // Defensive copy.     this.intermediates = intermediates.clone().     return this. }
true;public;1;4;/**  * Add a trusted root certificate to use when authenticating a peer. Peers must provide  * a chain of certificates whose root is one of these.  */ ;/**  * Add a trusted root certificate to use when authenticating a peer. Peers must provide  * a chain of certificates whose root is one of these.  */ public Builder addTrustedCertificate(X509Certificate certificate) {     this.trustedCertificates.add(certificate).     return this. }
true;public;0;5;/**  * Add all of the host platform's trusted root certificates. This set varies by platform  * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user  * customizations.  *  * <p>Most TLS clients that connect to hosts on the public Internet should call this method.  * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.  *  * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root  * certificates. Applications that connect to a known set of servers may be able to mitigate  * this problem with {@linkplain CertificatePinner certificate pinning}.  */ ;/**  * Add all of the host platform's trusted root certificates. This set varies by platform  * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user  * customizations.  *  * <p>Most TLS clients that connect to hosts on the public Internet should call this method.  * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.  *  * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root  * certificates. Applications that connect to a known set of servers may be able to mitigate  * this problem with {@linkplain CertificatePinner certificate pinning}.  */ public Builder addPlatformTrustedCertificates() {     X509TrustManager platformTrustManager = Util.platformTrustManager().     Collections.addAll(trustedCertificates, platformTrustManager.getAcceptedIssuers()).     return this. }
false;public;0;9;;public HandshakeCertificates build() {     try {         X509KeyManager keyManager = newKeyManager(null, heldCertificate, intermediates).         X509TrustManager trustManager = newTrustManager(null, trustedCertificates).         return new HandshakeCertificates(keyManager, trustManager).     } catch (GeneralSecurityException gse) {         throw new AssertionError(gse).     } }
