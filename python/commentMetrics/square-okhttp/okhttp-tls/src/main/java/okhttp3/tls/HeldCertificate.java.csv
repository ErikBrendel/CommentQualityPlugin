commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public X509Certificate certificate() {     return certificate. }
false;public;0;3;;public KeyPair keyPair() {     return keyPair. }
true;public;0;11;/**  * Returns the certificate encoded in <a href="https://tools.ietf.org/html/rfc7468">PEM  * format</a>.  */ ;/**  * Returns the certificate encoded in <a href="https://tools.ietf.org/html/rfc7468">PEM  * format</a>.  */ public String certificatePem() {     try {         StringBuilder result = new StringBuilder().         result.append("-----BEGIN CERTIFICATE-----\n").         encodeBase64Lines(result, ByteString.of(certificate.getEncoded())).         result.append("-----END CERTIFICATE-----\n").         return result.toString().     } catch (CertificateEncodingException e) {         throw new AssertionError(e).     } }
true;public;0;7;/**  * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc5208">PKCS  * #8</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.  */ ;/**  * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc5208">PKCS  * #8</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.  */ public String privateKeyPkcs8Pem() {     StringBuilder result = new StringBuilder().     result.append("-----BEGIN PRIVATE KEY-----\n").     encodeBase64Lines(result, ByteString.of(keyPair.getPrivate().getEncoded())).     result.append("-----END PRIVATE KEY-----\n").     return result.toString(). }
true;public;0;10;/**  * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc8017">PKCS  * #1</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.  */ ;/**  * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc8017">PKCS  * #1</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.  */ public String privateKeyPkcs1Pem() {     if (!(keyPair.getPrivate() instanceof RSAPrivateKey)) {         throw new IllegalStateException("PKCS1 only supports RSA keys").     }     StringBuilder result = new StringBuilder().     result.append("-----BEGIN RSA PRIVATE KEY-----\n").     encodeBase64Lines(result, pkcs1Bytes()).     result.append("-----END RSA PRIVATE KEY-----\n").     return result.toString(). }
false;private;0;8;;private ByteString pkcs1Bytes() {     try {         PrivateKeyInfo privateKeyInfo = PrivateKeyInfo.getInstance(keyPair.getPrivate().getEncoded()).         return ByteString.of(privateKeyInfo.parsePrivateKey().toASN1Primitive().getEncoded()).     } catch (IOException e) {         throw new AssertionError(e).     } }
false;private;2;6;;private void encodeBase64Lines(StringBuilder out, ByteString data) {     String base64 = data.base64().     for (int i = 0. i < base64.length(). i += 64) {         out.append(base64, i, Math.min(i + 64, base64.length())).append('\n').     } }
true;public;2;8;/**  * Sets the certificate to be valid in {@code [notBefore..notAfter]}. Both endpoints are  * specified in the format of {@link System#currentTimeMillis()}. Specify -1L for both values  * to use the default interval, 24 hours starting when the certificate is created.  */ ;/**  * Sets the certificate to be valid in {@code [notBefore..notAfter]}. Both endpoints are  * specified in the format of {@link System#currentTimeMillis()}. Specify -1L for both values  * to use the default interval, 24 hours starting when the certificate is created.  */ public Builder validityInterval(long notBefore, long notAfter) {     if (notBefore > notAfter || (notBefore == -1L) != (notAfter == -1L)) {         throw new IllegalArgumentException("invalid interval: " + notBefore + ".." + notAfter).     }     this.notBefore = notBefore.     this.notAfter = notAfter.     return this. }
true;public;2;4;/**  * Sets the certificate to be valid immediately and until the specified duration has elapsed.  * The precision of this field is seconds. further precision will be truncated.  */ ;/**  * Sets the certificate to be valid immediately and until the specified duration has elapsed.  * The precision of this field is seconds. further precision will be truncated.  */ public Builder duration(long duration, TimeUnit unit) {     long now = System.currentTimeMillis().     return validityInterval(now, now + unit.toMillis(duration)). }
true;public;1;5;/**  * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,  * a literal IP address, or a hostname pattern. If no subject alternative names are added that  * extension will be omitted.  */ ;/**  * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,  * a literal IP address, or a hostname pattern. If no subject alternative names are added that  * extension will be omitted.  */ public Builder addSubjectAlternativeName(String altName) {     if (altName == null)         throw new NullPointerException("altName == null").     altNames.add(altName).     return this. }
true;public;1;4;/**  * Set this certificate's common name (CN). Historically this held the hostname of TLS  * certificate, but that practice was deprecated by <a  * href="https://tools.ietf.org/html/rfc2818">RFC 2818</a> and replaced with {@link  * #addSubjectAlternativeName(String) subject alternative names}. If unset a random string will  * be used.  */ ;/**  * Set this certificate's common name (CN). Historically this held the hostname of TLS  * certificate, but that practice was deprecated by <a  * href="https://tools.ietf.org/html/rfc2818">RFC 2818</a> and replaced with {@link  * #addSubjectAlternativeName(String) subject alternative names}. If unset a random string will  * be used.  */ public Builder commonName(String cn) {     this.cn = cn.     return this. }
true;public;1;4;/**  * Sets the certificate's organizational unit (OU). If unset this field will be omitted.  */ ;/**  * Sets the certificate's organizational unit (OU). If unset this field will be omitted.  */ public Builder organizationalUnit(String ou) {     this.ou = ou.     return this. }
true;public;1;4;/**  * Sets this certificate's serial number. If unset the serial number will be 1.  */ ;/**  * Sets this certificate's serial number. If unset the serial number will be 1.  */ public Builder serialNumber(BigInteger serialNumber) {     this.serialNumber = serialNumber.     return this. }
true;public;1;3;/**  * Sets this certificate's serial number. If unset the serial number will be 1.  */ ;/**  * Sets this certificate's serial number. If unset the serial number will be 1.  */ public Builder serialNumber(long serialNumber) {     return serialNumber(BigInteger.valueOf(serialNumber)). }
true;public;1;4;/**  * Sets the public/private key pair used for this certificate. If unset a key pair will be  * generated.  */ ;/**  * Sets the public/private key pair used for this certificate. If unset a key pair will be  * generated.  */ public Builder keyPair(KeyPair keyPair) {     this.keyPair = keyPair.     return this. }
true;public;2;3;/**  * Sets the public/private key pair used for this certificate. If unset a key pair will be  * generated.  */ ;/**  * Sets the public/private key pair used for this certificate. If unset a key pair will be  * generated.  */ public Builder keyPair(PublicKey publicKey, PrivateKey privateKey) {     return keyPair(new KeyPair(publicKey, privateKey)). }
true;public;1;4;/**  * Set the certificate that will issue this certificate. If unset the certificate will be  * self-signed.  */ ;/**  * Set the certificate that will issue this certificate. If unset the certificate will be  * self-signed.  */ public Builder signedBy(HeldCertificate signedBy) {     this.signedBy = signedBy.     return this. }
true;public;1;7;/**  * Set this certificate to be a signing certificate, with up to {@code maxIntermediateCas}  * intermediate signing certificates beneath it.  *  * <p>By default this certificate cannot not sign other certificates. Set this to 0 so this  * certificate can sign other certificates (but those certificates cannot themselves sign  * certificates). Set this to 1 so this certificate can sign intermediate certificates that can  * themselves sign certificates. Add one for each additional layer of intermediates to permit.  */ ;/**  * Set this certificate to be a signing certificate, with up to {@code maxIntermediateCas}  * intermediate signing certificates beneath it.  *  * <p>By default this certificate cannot not sign other certificates. Set this to 0 so this  * certificate can sign other certificates (but those certificates cannot themselves sign  * certificates). Set this to 1 so this certificate can sign intermediate certificates that can  * themselves sign certificates. Add one for each additional layer of intermediates to permit.  */ public Builder certificateAuthority(int maxIntermediateCas) {     if (maxIntermediateCas < 0) {         throw new IllegalArgumentException("maxIntermediateCas < 0: " + maxIntermediateCas).     }     this.maxIntermediateCas = maxIntermediateCas.     return this. }
true;public;0;5;/**  * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of  * security. ECDSA keys are noticeably faster than RSA keys.  *  * <p>This is the default configuration and has been since this API was introduced in OkHttp  * 3.11.0. Note that the default may change in future releases.  */ ;/**  * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of  * security. ECDSA keys are noticeably faster than RSA keys.  *  * <p>This is the default configuration and has been since this API was introduced in OkHttp  * 3.11.0. Note that the default may change in future releases.  */ public Builder ecdsa256() {     keyAlgorithm = "EC".     keySize = 256.     return this. }
true;public;0;5;/**  * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of  * security. RSA keys are interoperable with very old clients that don't support ECDSA.  */ ;/**  * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of  * security. RSA keys are interoperable with very old clients that don't support ECDSA.  */ public Builder rsa2048() {     keyAlgorithm = "RSA".     keySize = 2048.     return this. }
false;public;0;59;;public HeldCertificate build() {     // Subject, public & private keys for this certificate.     KeyPair heldKeyPair = keyPair != null ? keyPair : generateKeyPair().     X500Principal subject = buildSubject().     // Subject, public & private keys for this certificate's signer. It may be self signed!     KeyPair signedByKeyPair.     X500Principal signedByPrincipal.     if (signedBy != null) {         signedByKeyPair = signedBy.keyPair.         signedByPrincipal = signedBy.certificate.getSubjectX500Principal().     } else {         signedByKeyPair = heldKeyPair.         signedByPrincipal = subject.     }     // Generate & sign the certificate.     long notBefore = this.notBefore != -1L ? this.notBefore : System.currentTimeMillis().     long notAfter = this.notAfter != -1L ? this.notAfter : notBefore + DEFAULT_DURATION_MILLIS.     BigInteger serialNumber = this.serialNumber != null ? this.serialNumber : BigInteger.ONE.     X509V3CertificateGenerator generator = new X509V3CertificateGenerator().     generator.setSerialNumber(serialNumber).     generator.setIssuerDN(signedByPrincipal).     generator.setNotBefore(new Date(notBefore)).     generator.setNotAfter(new Date(notAfter)).     generator.setSubjectDN(subject).     generator.setPublicKey(heldKeyPair.getPublic()).     generator.setSignatureAlgorithm(signedByKeyPair.getPrivate() instanceof RSAPrivateKey ? "SHA256WithRSAEncryption" : "SHA256withECDSA").     if (maxIntermediateCas != -1) {         generator.addExtension(X509Extensions.BasicConstraints, true, new BasicConstraints(maxIntermediateCas)).     }     if (!altNames.isEmpty()) {         ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()].         for (int i = 0, size = altNames.size(). i < size. i++) {             String altName = altNames.get(i).             int tag = verifyAsIpAddress(altName) ? GeneralName.iPAddress : GeneralName.dNSName.             encodableAltNames[i] = new GeneralName(tag, altName).         }         generator.addExtension(X509Extensions.SubjectAlternativeName, true, new DERSequence(encodableAltNames)).     }     try {         X509Certificate certificate = generator.generate(signedByKeyPair.getPrivate()).         return new HeldCertificate(heldKeyPair, certificate).     } catch (GeneralSecurityException e) {         throw new AssertionError(e).     } }
false;private;0;12;;private X500Principal buildSubject() {     StringBuilder nameBuilder = new StringBuilder().     if (cn != null) {         nameBuilder.append("CN=").append(cn).     } else {         nameBuilder.append("CN=").append(UUID.randomUUID()).     }     if (ou != null) {         nameBuilder.append(", OU=").append(ou).     }     return new X500Principal(nameBuilder.toString()). }
false;private;0;9;;private KeyPair generateKeyPair() {     try {         KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm).         keyPairGenerator.initialize(keySize, new SecureRandom()).         return keyPairGenerator.generateKeyPair().     } catch (GeneralSecurityException e) {         throw new AssertionError(e).     } }
