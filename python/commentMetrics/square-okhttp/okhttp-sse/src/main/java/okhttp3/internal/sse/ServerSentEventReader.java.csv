commented;modifiers;parameterAmount;loc;comment;code
false;;3;1;;void onEvent(@Nullable String id, @Nullable String type, String data).
false;;1;1;;void onRetryChange(long timeMs).
true;;0;50;/**  * Process the next event. This will result in a single call to {@link Callback#onEvent}  * <em>unless</em> the data section was empty. Any number of calls to  * {@link Callback#onRetryChange} may occur while processing an event.  *  * @return false when EOF is reached  */ ;/**  * Process the next event. This will result in a single call to {@link Callback#onEvent}  * <em>unless</em> the data section was empty. Any number of calls to  * {@link Callback#onRetryChange} may occur while processing an event.  *  * @return false when EOF is reached  */ boolean processNextEvent() throws IOException {     String id = lastId.     String type = null.     Buffer data = new Buffer().     while (true) {         long lineEnd = source.indexOfElement(CRLF).         if (lineEnd == -1L) {             return false.         }         switch(source.getBuffer().getByte(0)) {             case '\r':             case '\n':                 completeEvent(id, type, data).                 return true.             case 'd':                 if (isKey(DATA)) {                     parseData(data, lineEnd).                     continue.                 }                 break.             case 'e':                 if (isKey(EVENT)) {                     type = parseEvent(lineEnd).                     continue.                 }                 break.             case 'i':                 if (isKey(ID)) {                     id = parseId(lineEnd).                     continue.                 }                 break.             case 'r':                 if (isKey(RETRY)) {                     parseRetry(lineEnd).                     continue.                 }                 break.         }         source.skip(lineEnd).         skipCrAndOrLf().     } }
false;private;3;9;;private void completeEvent(String id, String type, Buffer data) throws IOException {     skipCrAndOrLf().     if (data.size() != 0L) {         lastId = id.         // Leading newline.         data.skip(1L).         callback.onEvent(id, type, data.readUtf8()).     } }
false;private;2;6;;private void parseData(Buffer data, long end) throws IOException {     data.writeByte('\n').     end -= skipNameAndDivider(4L).     source.readFully(data, end).     skipCrAndOrLf(). }
false;private;1;9;;private String parseEvent(long end) throws IOException {     String type = null.     end -= skipNameAndDivider(5L).     if (end != 0L) {         type = source.readUtf8(end).     }     skipCrAndOrLf().     return type. }
false;private;1;11;;private String parseId(long end) throws IOException {     String id.     end -= skipNameAndDivider(2L).     if (end != 0L) {         id = source.readUtf8(end).     } else {         id = null.     }     skipCrAndOrLf().     return id. }
false;private;1;13;;private void parseRetry(long end) throws IOException {     end -= skipNameAndDivider(5L).     String retryString = source.readUtf8(end).     long retryMs = -1L.     try {         retryMs = Long.parseLong(retryString).     } catch (NumberFormatException ignored) {     }     if (retryMs != -1L) {         callback.onRetryChange(retryMs).     }     skipCrAndOrLf(). }
true;private;1;9;/**  * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or  * a newline.  */ ;/**  * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or  * a newline.  */ private boolean isKey(ByteString key) throws IOException {     if (source.rangeEquals(0, key)) {         byte nextByte = source.getBuffer().getByte(key.size()).         return nextByte == ':' || nextByte == '\r' || nextByte == '\n'.     }     return false. }
true;private;0;7;/**  * Consumes {@code \r}, {@code \r\n}, or {@code \n} from {@link #source}.  */ ;/**  * Consumes {@code \r}, {@code \r\n}, or {@code \n} from {@link #source}.  */ private void skipCrAndOrLf() throws IOException {     if ((source.readByte() & 0xff) == '\r' && source.request(1) && source.getBuffer().getByte(0) == '\n') {         source.skip(1).     } }
true;private;1;15;/**  * Consumes the field name of the specified length and the optional colon and its optional  * trailing space. Returns the number of bytes skipped.  */ ;/**  * Consumes the field name of the specified length and the optional colon and its optional  * trailing space. Returns the number of bytes skipped.  */ private long skipNameAndDivider(long length) throws IOException {     source.skip(length).     if (source.getBuffer().getByte(0) == ':') {         source.skip(1L).         length++.         if (source.getBuffer().getByte(0) == ' ') {             source.skip(1).             length++.         }     }     return length. }
