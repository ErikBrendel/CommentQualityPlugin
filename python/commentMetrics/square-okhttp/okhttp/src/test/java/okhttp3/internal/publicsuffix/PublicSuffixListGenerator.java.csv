commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;50;;public static void main(String... args) throws IOException {     OkHttpClient client = new OkHttpClient.Builder().build().     Request request = new Request.Builder().url("https://publicsuffix.org/list/public_suffix_list.dat").build().     SortedSet<ByteString> sortedRules = new TreeSet<>().     SortedSet<ByteString> sortedExceptionRules = new TreeSet<>().     try (Response response = client.newCall(request).execute()) {         BufferedSource source = response.body().source().         int totalRuleBytes = 0.         int totalExceptionRuleBytes = 0.         while (!source.exhausted()) {             String line = source.readUtf8LineStrict().             if (line.trim().isEmpty() || line.startsWith("//"))                 continue.             if (line.contains(WILDCARD_CHAR)) {                 assertWildcardRule(line).             }             ByteString rule = ByteString.encodeUtf8(line).             if (rule.startsWith(EXCEPTION_RULE_MARKER)) {                 rule = rule.substring(1).                 // We use '\n' for end of value.                 totalExceptionRuleBytes += rule.size() + 1.                 sortedExceptionRules.add(rule).             } else {                 // We use '\n' for end of value.                 totalRuleBytes += rule.size() + 1.                 sortedRules.add(rule).             }         }         File resources = new File(OKHTTP_RESOURCE_DIR).         if (!resources.mkdirs() && !resources.exists()) {             throw new RuntimeException("Unable to create resource directory!").         }         Sink fileSink = Okio.sink(new File(resources, PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE)).         try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {             sink.writeInt(totalRuleBytes).             for (ByteString domain : sortedRules) {                 sink.write(domain).writeByte('\n').             }             sink.writeInt(totalExceptionRuleBytes).             for (ByteString domain : sortedExceptionRules) {                 sink.write(domain).writeByte('\n').             }         }     } }
true;private,static;1;17;/**  * These assertions ensure the {@link PublicSuffixDatabase} remains correct. The specification is  * very flexible regarding wildcard rules, but this flexibility is not something currently used  * in practice. To simplify the implementation, we've avoided implementing the flexible rules in  * favor of supporting what's actually used in practice. That means if these assertions ever fail,  * the implementation will need to be revisited to support a more flexible rule.  */ ;/**  * These assertions ensure the {@link PublicSuffixDatabase} remains correct. The specification is  * very flexible regarding wildcard rules, but this flexibility is not something currently used  * in practice. To simplify the implementation, we've avoided implementing the flexible rules in  * favor of supporting what's actually used in practice. That means if these assertions ever fail,  * the implementation will need to be revisited to support a more flexible rule.  */ private static void assertWildcardRule(String rule) {     if (rule.indexOf(WILDCARD_CHAR) != 0) {         throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was " + "added with a wildcard that is not in leftmost position! We'll need to change the " + PublicSuffixDatabase.class.getName() + " to handle this.").     }     if (rule.indexOf(WILDCARD_CHAR, 1) != -1) {         throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was " + "added with multiple wildcards! We'll need to change " + PublicSuffixDatabase.class.getName() + " to handle this.").     }     if (rule.length() == 1) {         throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was " + "added that wildcards the first level! We'll need to change the " + PublicSuffixDatabase.class.getName() + " to handle this.").     } }
