commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;11;/**  * Creates a new relay that reads a live stream from {@code upstream}, using {@code file} to share  * that data with other sources.  *  * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to  * create a source and close that when they're done. Otherwise a handle to {@code file} will be  * leaked.  */ ;/**  * Creates a new relay that reads a live stream from {@code upstream}, using {@code file} to share  * that data with other sources.  *  * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to  * create a source and close that when they're done. Otherwise a handle to {@code file} will be  * leaked.  */ public static Relay edit(File file, Source upstream, ByteString metadata, long bufferMaxSize) throws IOException {     RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw").     Relay result = new Relay(randomAccessFile, upstream, 0L, metadata, bufferMaxSize).     // Write a dirty header. That way if we crash we won't attempt to recover this.     randomAccessFile.setLength(0L).     result.writeHeader(PREFIX_DIRTY, -1L, -1L).     return result. }
true;public,static;1;20;/**  * Creates a relay that reads a recorded stream from {@code file}.  *  * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to  * create a source and close that when they're done. Otherwise a handle to {@code file} will be  * leaked.  */ ;/**  * Creates a relay that reads a recorded stream from {@code file}.  *  * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to  * create a source and close that when they're done. Otherwise a handle to {@code file} will be  * leaked.  */ public static Relay read(File file) throws IOException {     RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw").     FileOperator fileOperator = new FileOperator(randomAccessFile.getChannel()).     // Read the header.     Buffer header = new Buffer().     fileOperator.read(0, header, FILE_HEADER_SIZE).     ByteString prefix = header.readByteString(PREFIX_CLEAN.size()).     if (!prefix.equals(PREFIX_CLEAN))         throw new IOException("unreadable cache file").     long upstreamSize = header.readLong().     long metadataSize = header.readLong().     // Read the metadata.     Buffer metadataBuffer = new Buffer().     fileOperator.read(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadataSize).     ByteString metadata = metadataBuffer.readByteString().     // Return the result.     return new Relay(randomAccessFile, null, upstreamSize, metadata, 0L). }
false;private;3;11;;private void writeHeader(ByteString prefix, long upstreamSize, long metadataSize) throws IOException {     Buffer header = new Buffer().     header.write(prefix).     header.writeLong(upstreamSize).     header.writeLong(metadataSize).     if (header.size() != FILE_HEADER_SIZE)         throw new IllegalArgumentException().     FileOperator fileOperator = new FileOperator(file.getChannel()).     fileOperator.write(0, header, FILE_HEADER_SIZE). }
false;private;1;7;;private void writeMetadata(long upstreamSize) throws IOException {     Buffer metadataBuffer = new Buffer().     metadataBuffer.write(metadata).     FileOperator fileOperator = new FileOperator(file.getChannel()).     fileOperator.write(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadata.size()). }
false;;1;17;;void commit(long upstreamSize) throws IOException {     // Write metadata to the end of the file.     writeMetadata(upstreamSize).     file.getChannel().force(false).     // Once everything else is in place we can swap the dirty header for a clean one.     writeHeader(PREFIX_CLEAN, upstreamSize, metadata.size()).     file.getChannel().force(false).     // This file is complete.     synchronized (Relay.this) {         complete = true.     }     closeQuietly(upstream).     upstream = null. }
false;;0;3;;boolean isClosed() {     return file == null. }
false;public;0;3;;public ByteString metadata() {     return metadata. }
true;public;0;8;/**  * Returns a new source that returns the same bytes as upstream. Returns null if this relay has  * been closed and no further sources are possible. In that case callers should retry after  * building a new relay with {@link #read}.  */ ;/**  * Returns a new source that returns the same bytes as upstream. Returns null if this relay has  * been closed and no further sources are possible. In that case callers should retry after  * building a new relay with {@link #read}.  */ public Source newSource() {     synchronized (Relay.this) {         if (file == null)             return null.         sourceCount++.     }     return new RelaySource(). }
true;public;2;87;/**  * Selects where to find the bytes for a read and read them. This is one of three sources.  *  * <h3>Upstream:</h3>  * In this case the current thread is assigned as the upstream reader. We read bytes from  * upstream and copy them to both the file and to the buffer. Finally we release the upstream  * reader lock and return the new bytes.  *  * <h3>The file</h3>  * In this case we copy bytes from the file to the {@code sink}.  *  * <h3>The buffer</h3>  * In this case the bytes are immediately copied into {@code sink} and the number of bytes  * copied is returned.  *  * <p>If upstream would be selected but another thread is already reading upstream this will  * block until that read completes. It is possible to time out while waiting for that.  */ ;/**  * Selects where to find the bytes for a read and read them. This is one of three sources.  *  * <h3>Upstream:</h3>  * In this case the current thread is assigned as the upstream reader. We read bytes from  * upstream and copy them to both the file and to the buffer. Finally we release the upstream  * reader lock and return the new bytes.  *  * <h3>The file</h3>  * In this case we copy bytes from the file to the {@code sink}.  *  * <h3>The buffer</h3>  * In this case the bytes are immediately copied into {@code sink} and the number of bytes  * copied is returned.  *  * <p>If upstream would be selected but another thread is already reading upstream this will  * block until that read completes. It is possible to time out while waiting for that.  */ @Override public long read(Buffer sink, long byteCount) throws IOException {     if (fileOperator == null)         throw new IllegalStateException("closed").     long upstreamPos.     int source.     selectSource: synchronized (Relay.this) {         // We need new data from upstream.         while (sourcePos == (upstreamPos = Relay.this.upstreamPos)) {             // No more data upstream. We're done.             if (complete)                 return -1L.             // Another thread is already reading. Wait for that.             if (upstreamReader != null) {                 timeout.waitUntilNotified(Relay.this).                 continue.             }             // We will do the read.             upstreamReader = Thread.currentThread().             source = SOURCE_UPSTREAM.             break selectSource.         }         long bufferPos = upstreamPos - buffer.size().         // Bytes of the read precede the buffer. Read from the file.         if (sourcePos < bufferPos) {             source = SOURCE_FILE.             break selectSource.         }         // The buffer has the data we need. Read from there and return immediately.         long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos).         buffer.copyTo(sink, sourcePos - bufferPos, bytesToRead).         sourcePos += bytesToRead.         return bytesToRead.     }     // Read from the file.     if (source == SOURCE_FILE) {         long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos).         fileOperator.read(FILE_HEADER_SIZE + sourcePos, sink, bytesToRead).         sourcePos += bytesToRead.         return bytesToRead.     }     // current call to Source.read() has requested.     try {         long upstreamBytesRead = upstream.read(upstreamBuffer, bufferMaxSize).         // If we've exhausted upstream, we're done.         if (upstreamBytesRead == -1L) {             commit(upstreamPos).             return -1L.         }         // Update this source and prepare this call's result.         long bytesRead = Math.min(upstreamBytesRead, byteCount).         upstreamBuffer.copyTo(sink, 0, bytesRead).         sourcePos += bytesRead.         // Append the upstream bytes to the file.         fileOperator.write(FILE_HEADER_SIZE + upstreamPos, upstreamBuffer.clone(), upstreamBytesRead).         synchronized (Relay.this) {             // Append new upstream bytes into the buffer. Trim it to its max size.             buffer.write(upstreamBuffer, upstreamBytesRead).             if (buffer.size() > bufferMaxSize) {                 buffer.skip(buffer.size() - bufferMaxSize).             }             // Now that the file and buffer have bytes, adjust upstreamPos.             Relay.this.upstreamPos += upstreamBytesRead.         }         return bytesRead.     } finally {         synchronized (Relay.this) {             upstreamReader = null.             Relay.this.notifyAll().         }     } }
false;public;0;3;;@Override public Timeout timeout() {     return timeout. }
false;public;0;17;;@Override public void close() throws IOException {     // Already closed.     if (fileOperator == null)         return.     fileOperator = null.     RandomAccessFile fileToClose = null.     synchronized (Relay.this) {         sourceCount--.         if (sourceCount == 0) {             fileToClose = file.             file = null.         }     }     if (fileToClose != null) {         closeQuietly(fileToClose).     } }
