commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static long contentLength(Response response) {     return contentLength(response.headers()). }
false;public,static;1;3;;public static long contentLength(Headers headers) {     return stringToLong(headers.get("Content-Length")). }
false;private,static;1;8;;private static long stringToLong(String s) {     if (s == null)         return -1.     try {         return Long.parseLong(s).     } catch (NumberFormatException e) {         return -1.     } }
true;public,static;3;7;/**  * Returns true if none of the Vary headers have changed between {@code cachedRequest} and {@code  * newRequest}.  */ ;/**  * Returns true if none of the Vary headers have changed between {@code cachedRequest} and {@code  * newRequest}.  */ public static boolean varyMatches(Response cachedResponse, Headers cachedRequest, Request newRequest) {     for (String field : varyFields(cachedResponse)) {         if (!Objects.equals(cachedRequest.values(field), newRequest.headers(field)))             return false.     }     return true. }
true;public,static;1;3;/**  * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.  */ ;/**  * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.  */ public static boolean hasVaryAll(Response response) {     return hasVaryAll(response.headers()). }
true;public,static;1;3;/**  * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.  */ ;/**  * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.  */ public static boolean hasVaryAll(Headers responseHeaders) {     return varyFields(responseHeaders).contains("*"). }
false;private,static;1;3;;private static Set<String> varyFields(Response response) {     return varyFields(response.headers()). }
true;public,static;1;15;/**  * Returns the names of the request headers that need to be checked for equality when caching.  */ ;/**  * Returns the names of the request headers that need to be checked for equality when caching.  */ public static Set<String> varyFields(Headers responseHeaders) {     Set<String> result = Collections.emptySet().     for (int i = 0, size = responseHeaders.size(). i < size. i++) {         if (!"Vary".equalsIgnoreCase(responseHeaders.name(i)))             continue.         String value = responseHeaders.value(i).         if (result.isEmpty()) {             result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER).         }         for (String varyField : value.split(",")) {             result.add(varyField.trim()).         }     }     return result. }
true;public,static;1;8;/**  * Returns the subset of the headers in {@code response}'s request that impact the content of  * response's body.  */ ;/**  * Returns the subset of the headers in {@code response}'s request that impact the content of  * response's body.  */ public static Headers varyHeaders(Response response) {     // Use the request headers sent over the network, since that's what the     // response varies on. Otherwise OkHttp-supplied headers like     // "Accept-Encoding: gzip" may be lost.     Headers requestHeaders = response.networkResponse().request().headers().     Headers responseHeaders = response.headers().     return varyHeaders(requestHeaders, responseHeaders). }
true;public,static;2;13;/**  * Returns the subset of the headers in {@code requestHeaders} that impact the content of  * response's body.  */ ;/**  * Returns the subset of the headers in {@code requestHeaders} that impact the content of  * response's body.  */ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {     Set<String> varyFields = varyFields(responseHeaders).     if (varyFields.isEmpty())         return EMPTY_HEADERS.     Headers.Builder result = new Headers.Builder().     for (int i = 0, size = requestHeaders.size(). i < size. i++) {         String fieldName = requestHeaders.name(i).         if (varyFields.contains(fieldName)) {             result.add(fieldName, requestHeaders.value(i)).         }     }     return result.build(). }
true;public,static;2;10;/**  * Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to  * interpret a token.  *  * <p>For example, the first line has a parameter name/value pair and the second line has a single  * token68:  *  * <pre>   {@code  *  *   WWW-Authenticate: Digest foo=bar  *   WWW-Authenticate: Digest foo=  * }</pre>  *  * <p>Similarly, the first line has one challenge and the second line has two challenges:  *  * <pre>   {@code  *  *   WWW-Authenticate: Digest ,foo=bar  *   WWW-Authenticate: Digest ,foo  * }</pre>  */ ;/**  * Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to  * interpret a token.  *  * <p>For example, the first line has a parameter name/value pair and the second line has a single  * token68:  *  * <pre>   {@code  *  *   WWW-Authenticate: Digest foo=bar  *   WWW-Authenticate: Digest foo=  * }</pre>  *  * <p>Similarly, the first line has one challenge and the second line has two challenges:  *  * <pre>   {@code  *  *   WWW-Authenticate: Digest ,foo=bar  *   WWW-Authenticate: Digest ,foo  * }</pre>  */ public static List<Challenge> parseChallenges(Headers responseHeaders, String headerName) {     List<Challenge> result = new ArrayList<>().     for (int h = 0. h < responseHeaders.size(). h++) {         if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {             Buffer header = new Buffer().writeUtf8(responseHeaders.value(h)).             parseChallengeHeader(result, header).         }     }     return result. }
false;private,static;2;58;;private static void parseChallengeHeader(List<Challenge> result, Buffer header) {     String peek = null.     while (true) {         // Read a scheme name for this challenge if we don't have one already.         if (peek == null) {             skipWhitespaceAndCommas(header).             peek = readToken(header).             if (peek == null)                 return.         }         String schemeName = peek.         // Read a token68, a sequence of parameters, or nothing.         boolean commaPrefixed = skipWhitespaceAndCommas(header).         peek = readToken(header).         if (peek == null) {             // Expected a token. got something else.             if (!header.exhausted())                 return.             result.add(new Challenge(schemeName, Collections.emptyMap())).             return.         }         int eqCount = skipAll(header, (byte) '=').         boolean commaSuffixed = skipWhitespaceAndCommas(header).         // It's a token68 because there isn't a value after it.         if (!commaPrefixed && (commaSuffixed || header.exhausted())) {             result.add(new Challenge(schemeName, Collections.singletonMap(null, peek + repeat('=', eqCount)))).             peek = null.             continue.         }         // It's a series of parameter names and values.         Map<String, String> parameters = new LinkedHashMap<>().         eqCount += skipAll(header, (byte) '=').         while (true) {             if (peek == null) {                 peek = readToken(header).                 // We peeked a scheme name followed by ','.                 if (skipWhitespaceAndCommas(header))                     break.                 eqCount = skipAll(header, (byte) '=').             }             // We peeked a scheme name.             if (eqCount == 0)                 break.             // Unexpected '=' characters.             if (eqCount > 1)                 return.             // Unexpected ','.             if (skipWhitespaceAndCommas(header))                 return.             String parameterValue = !header.exhausted() && header.getByte(0) == '"' ? readQuotedString(header) : readToken(header).             // Expected a value.             if (parameterValue == null)                 return.             String replaced = parameters.put(peek, parameterValue).             peek = null.             // Unexpected duplicate parameter.             if (replaced != null)                 return.             // Expected ',' or EOF.             if (!skipWhitespaceAndCommas(header) && !header.exhausted())                 return.         }         result.add(new Challenge(schemeName, parameters)).     } }
true;private,static;1;15;/**  * Returns true if any commas were skipped.  */ ;/**  * Returns true if any commas were skipped.  */ private static boolean skipWhitespaceAndCommas(Buffer buffer) {     boolean commaFound = false.     while (!buffer.exhausted()) {         byte b = buffer.getByte(0).         if (b == ',') {             // Consume ','.             buffer.readByte().             commaFound = true.         } else if (b == ' ' || b == '\t') {             // Consume space or tab.             buffer.readByte().         } else {             break.         }     }     return commaFound. }
false;private,static;2;8;;private static int skipAll(Buffer buffer, byte b) {     int count = 0.     while (!buffer.exhausted() && buffer.getByte(0) == b) {         count++.         buffer.readByte().     }     return count. }
true;private,static;1;19;/**  * Reads a double-quoted string, unescaping quoted pairs like {@code \"} to the 2nd character in  * each sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a  * double-quoted string.  */ ;/**  * Reads a double-quoted string, unescaping quoted pairs like {@code \"} to the 2nd character in  * each sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a  * double-quoted string.  */ private static String readQuotedString(Buffer buffer) {     if (buffer.readByte() != '\"')         throw new IllegalArgumentException().     Buffer result = new Buffer().     while (true) {         long i = buffer.indexOfElement(QUOTED_STRING_DELIMITERS).         // Unterminated quoted string.         if (i == -1L)             return null.         if (buffer.getByte(i) == '"') {             result.write(buffer, i).             // Consume '"'.             buffer.readByte().             return result.readUtf8().         }         // Dangling escape.         if (buffer.size() == i + 1L)             return null.         result.write(buffer, i).         // Consume '\'.         buffer.readByte().         // The escaped character.         result.write(buffer, 1L).     } }
true;private,static;1;12;/**  * Consumes and returns a non-empty token, terminating at special characters in {@link  * #TOKEN_DELIMITERS}. Returns null if the buffer is empty or prefixed with a delimiter.  */ ;/**  * Consumes and returns a non-empty token, terminating at special characters in {@link  * #TOKEN_DELIMITERS}. Returns null if the buffer is empty or prefixed with a delimiter.  */ private static String readToken(Buffer buffer) {     try {         long tokenSize = buffer.indexOfElement(TOKEN_DELIMITERS).         if (tokenSize == -1L)             tokenSize = buffer.size().         return tokenSize != 0L ? buffer.readUtf8(tokenSize) : null.     } catch (EOFException e) {         throw new AssertionError().     } }
false;private,static;2;5;;private static String repeat(char c, int count) {     char[] array = new char[count].     Arrays.fill(array, c).     return new String(array). }
false;public,static;3;8;;public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {     if (cookieJar == CookieJar.NO_COOKIES)         return.     List<Cookie> cookies = Cookie.parseAll(url, headers).     if (cookies.isEmpty())         return.     cookieJar.saveFromResponse(url, cookies). }
true;public,static;1;22;/**  * Returns true if the response must have a (possibly 0-length) body. See RFC 7231.  */ ;/**  * Returns true if the response must have a (possibly 0-length) body. See RFC 7231.  */ public static boolean hasBody(Response response) {     // HEAD requests never yield a body regardless of the response headers.     if (response.request().method().equals("HEAD")) {         return false.     }     int responseCode = response.code().     if ((responseCode < HTTP_CONTINUE || responseCode >= 200) && responseCode != HTTP_NO_CONTENT && responseCode != HTTP_NOT_MODIFIED) {         return true.     }     // response is malformed. For best compatibility, we honor the headers.     if (contentLength(response) != -1 || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {         return true.     }     return false. }
true;public,static;3;8;/**  * Returns the next index in {@code input} at or after {@code pos} that contains a character from  * {@code characters}. Returns the input length if none of the requested characters can be found.  */ ;/**  * Returns the next index in {@code input} at or after {@code pos} that contains a character from  * {@code characters}. Returns the input length if none of the requested characters can be found.  */ public static int skipUntil(String input, int pos, String characters) {     for (. pos < input.length(). pos++) {         if (characters.indexOf(input.charAt(pos)) != -1) {             break.         }     }     return pos. }
true;public,static;2;9;/**  * Returns the next non-whitespace character in {@code input} that is white space. Result is  * undefined if input contains newline characters.  */ ;/**  * Returns the next non-whitespace character in {@code input} that is white space. Result is  * undefined if input contains newline characters.  */ public static int skipWhitespace(String input, int pos) {     for (. pos < input.length(). pos++) {         char c = input.charAt(pos).         if (c != ' ' && c != '\t') {             break.         }     }     return pos. }
true;public,static;2;14;/**  * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if  * it cannot be parsed.  */ ;/**  * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if  * it cannot be parsed.  */ public static int parseSeconds(String value, int defaultValue) {     try {         long seconds = Long.parseLong(value).         if (seconds > Integer.MAX_VALUE) {             return Integer.MAX_VALUE.         } else if (seconds < 0) {             return 0.         } else {             return (int) seconds.         }     } catch (NumberFormatException e) {         return defaultValue.     } }
