commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;int maxDynamicTableByteCount() {     return maxDynamicTableByteCount. }
false;private;0;9;;private void adjustDynamicTableByteCount() {     if (maxDynamicTableByteCount < dynamicTableByteCount) {         if (maxDynamicTableByteCount == 0) {             clearDynamicTable().         } else {             evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount).         }     } }
false;private;0;6;;private void clearDynamicTable() {     Arrays.fill(dynamicTable, null).     nextHeaderIndex = dynamicTable.length - 1.     headerCount = 0.     dynamicTableByteCount = 0. }
true;private;1;16;/**  * Returns the count of entries evicted.  */ ;/**  * Returns the count of entries evicted.  */ private int evictToRecoverBytes(int bytesToRecover) {     int entriesToEvict = 0.     if (bytesToRecover > 0) {         // determine how many headers need to be evicted.         for (int j = dynamicTable.length - 1. j >= nextHeaderIndex && bytesToRecover > 0. j--) {             bytesToRecover -= dynamicTable[j].hpackSize.             dynamicTableByteCount -= dynamicTable[j].hpackSize.             headerCount--.             entriesToEvict++.         }         System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable, nextHeaderIndex + 1 + entriesToEvict, headerCount).         nextHeaderIndex += entriesToEvict.     }     return entriesToEvict. }
true;;0;28;/**  * Read {@code byteCount} bytes of headers from the source stream. This implementation does not  * propagate the never indexed flag of a header.  */ ;/**  * Read {@code byteCount} bytes of headers from the source stream. This implementation does not  * propagate the never indexed flag of a header.  */ void readHeaders() throws IOException {     while (!source.exhausted()) {         int b = source.readByte() & 0xff.         if (b == 0x80) {             // 10000000             throw new IOException("index == 0").         } else if ((b & 0x80) == 0x80) {             // 1NNNNNNN             int index = readInt(b, PREFIX_7_BITS).             readIndexedHeader(index - 1).         } else if (b == 0x40) {             // 01000000             readLiteralHeaderWithIncrementalIndexingNewName().         } else if ((b & 0x40) == 0x40) {             // 01NNNNNN             int index = readInt(b, PREFIX_6_BITS).             readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1).         } else if ((b & 0x20) == 0x20) {             // 001NNNNN             maxDynamicTableByteCount = readInt(b, PREFIX_5_BITS).             if (maxDynamicTableByteCount < 0 || maxDynamicTableByteCount > headerTableSizeSetting) {                 throw new IOException("Invalid dynamic table size update " + maxDynamicTableByteCount).             }             adjustDynamicTableByteCount().         } else if (b == 0x10 || b == 0) {             // 000?0000 - Ignore never indexed bit.             readLiteralHeaderWithoutIndexingNewName().         } else {             // 000?NNNN - Ignore never indexed bit.             int index = readInt(b, PREFIX_4_BITS).             readLiteralHeaderWithoutIndexingIndexedName(index - 1).         }     } }
false;public;0;5;;public List<Header> getAndResetHeaderList() {     List<Header> result = new ArrayList<>(headerList).     headerList.clear().     return result. }
false;private;1;12;;private void readIndexedHeader(int index) throws IOException {     if (isStaticHeader(index)) {         Header staticEntry = STATIC_HEADER_TABLE[index].         headerList.add(staticEntry).     } else {         int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length).         if (dynamicTableIndex < 0 || dynamicTableIndex >= dynamicTable.length) {             throw new IOException("Header index too large " + (index + 1)).         }         headerList.add(dynamicTable[dynamicTableIndex]).     } }
true;private;1;3;// referencedHeaders is relative to nextHeaderIndex + 1. ;// referencedHeaders is relative to nextHeaderIndex + 1. private int dynamicTableIndex(int index) {     return nextHeaderIndex + 1 + index. }
false;private;1;5;;private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {     ByteString name = getName(index).     ByteString value = readByteString().     headerList.add(new Header(name, value)). }
false;private;0;5;;private void readLiteralHeaderWithoutIndexingNewName() throws IOException {     ByteString name = checkLowercase(readByteString()).     ByteString value = readByteString().     headerList.add(new Header(name, value)). }
false;private;1;6;;private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex) throws IOException {     ByteString name = getName(nameIndex).     ByteString value = readByteString().     insertIntoDynamicTable(-1, new Header(name, value)). }
false;private;0;5;;private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {     ByteString name = checkLowercase(readByteString()).     ByteString value = readByteString().     insertIntoDynamicTable(-1, new Header(name, value)). }
false;private;1;12;;private ByteString getName(int index) throws IOException {     if (isStaticHeader(index)) {         return STATIC_HEADER_TABLE[index].name.     } else {         int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length).         if (dynamicTableIndex < 0 || dynamicTableIndex >= dynamicTable.length) {             throw new IOException("Header index too large " + (index + 1)).         }         return dynamicTable[dynamicTableIndex].name.     } }
false;private;1;3;;private boolean isStaticHeader(int index) {     return index >= 0 && index <= STATIC_HEADER_TABLE.length - 1. }
true;private;2;34;/**  * index == -1 when new.  */ ;/**  * index == -1 when new.  */ private void insertIntoDynamicTable(int index, Header entry) {     headerList.add(entry).     int delta = entry.hpackSize.     if (index != -1) {         // Index -1 == new header.         delta -= dynamicTable[dynamicTableIndex(index)].hpackSize.     }     // if the new or replacement header is too big, drop all entries.     if (delta > maxDynamicTableByteCount) {         clearDynamicTable().         return.     }     // Evict headers to the required length.     int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount.     int entriesEvicted = evictToRecoverBytes(bytesToRecover).     if (index == -1) {         // Adding a value to the dynamic table.         if (headerCount + 1 > dynamicTable.length) {             // Need to grow the dynamic table.             Header[] doubled = new Header[dynamicTable.length * 2].             System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length).             nextHeaderIndex = dynamicTable.length - 1.             dynamicTable = doubled.         }         index = nextHeaderIndex--.         dynamicTable[index] = entry.         headerCount++.     } else {         // Replace value at same position.         index += dynamicTableIndex(index) + entriesEvicted.         dynamicTable[index] = entry.     }     dynamicTableByteCount += delta. }
false;private;0;3;;private int readByte() throws IOException {     return source.readByte() & 0xff. }
false;;2;21;;int readInt(int firstByte, int prefixMask) throws IOException {     int prefix = firstByte & prefixMask.     if (prefix < prefixMask) {         // This was a single byte value.         return prefix.     }     // This is a multibyte value. Read 7 bits at a time.     int result = prefixMask.     int shift = 0.     while (true) {         int b = readByte().         if ((b & 0x80) != 0) {             // Equivalent to (b >= 128) since b is in [0..255].             result += (b & 0x7f) << shift.             shift += 7.         } else {             // Last byte.             result += b << shift.             break.         }     }     return result. }
true;;0;11;/**  * Reads a potentially Huffman encoded byte string.  */ ;/**  * Reads a potentially Huffman encoded byte string.  */ ByteString readByteString() throws IOException {     int firstByte = readByte().     // 1NNNNNNN     boolean huffmanDecode = (firstByte & 0x80) == 0x80.     int length = readInt(firstByte, PREFIX_7_BITS).     if (huffmanDecode) {         return ByteString.of(Huffman.get().decode(source.readByteArray(length))).     } else {         return source.readByteString(length).     } }
false;private,static;0;9;;private static Map<ByteString, Integer> nameToFirstIndex() {     Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length).     for (int i = 0. i < STATIC_HEADER_TABLE.length. i++) {         if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {             result.put(STATIC_HEADER_TABLE[i].name, i).         }     }     return Collections.unmodifiableMap(result). }
false;private;0;6;;private void clearDynamicTable() {     Arrays.fill(dynamicTable, null).     nextHeaderIndex = dynamicTable.length - 1.     headerCount = 0.     dynamicTableByteCount = 0. }
true;private;1;17;/**  * Returns the count of entries evicted.  */ ;/**  * Returns the count of entries evicted.  */ private int evictToRecoverBytes(int bytesToRecover) {     int entriesToEvict = 0.     if (bytesToRecover > 0) {         // determine how many headers need to be evicted.         for (int j = dynamicTable.length - 1. j >= nextHeaderIndex && bytesToRecover > 0. j--) {             bytesToRecover -= dynamicTable[j].hpackSize.             dynamicTableByteCount -= dynamicTable[j].hpackSize.             headerCount--.             entriesToEvict++.         }         System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable, nextHeaderIndex + 1 + entriesToEvict, headerCount).         Arrays.fill(dynamicTable, nextHeaderIndex + 1, nextHeaderIndex + 1 + entriesToEvict, null).         nextHeaderIndex += entriesToEvict.     }     return entriesToEvict. }
false;private;1;24;;private void insertIntoDynamicTable(Header entry) {     int delta = entry.hpackSize.     // if the new or replacement header is too big, drop all entries.     if (delta > maxDynamicTableByteCount) {         clearDynamicTable().         return.     }     // Evict headers to the required length.     int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount.     evictToRecoverBytes(bytesToRecover).     if (headerCount + 1 > dynamicTable.length) {         // Need to grow the dynamic table.         Header[] doubled = new Header[dynamicTable.length * 2].         System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length).         nextHeaderIndex = dynamicTable.length - 1.         dynamicTable = doubled.     }     int index = nextHeaderIndex--.     dynamicTable[index] = entry.     headerCount++.     dynamicTableByteCount += delta. }
true;;1;69;// http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3 ;/**  * This does not use "never indexed" semantics for sensitive headers.  */ // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3 void writeHeaders(List<Header> headerBlock) throws IOException {     if (emitDynamicTableSizeUpdate) {         if (smallestHeaderTableSizeSetting < maxDynamicTableByteCount) {             // Multiple dynamic table size updates!             writeInt(smallestHeaderTableSizeSetting, PREFIX_5_BITS, 0x20).         }         emitDynamicTableSizeUpdate = false.         smallestHeaderTableSizeSetting = Integer.MAX_VALUE.         writeInt(maxDynamicTableByteCount, PREFIX_5_BITS, 0x20).     }     for (int i = 0, size = headerBlock.size(). i < size. i++) {         Header header = headerBlock.get(i).         ByteString name = header.name.toAsciiLowercase().         ByteString value = header.value.         int headerIndex = -1.         int headerNameIndex = -1.         Integer staticIndex = NAME_TO_FIRST_INDEX.get(name).         if (staticIndex != null) {             headerNameIndex = staticIndex + 1.             if (headerNameIndex > 1 && headerNameIndex < 8) {                 // always know the first index of the pair.                 if (Objects.equals(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {                     headerIndex = headerNameIndex.                 } else if (Objects.equals(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {                     headerIndex = headerNameIndex + 1.                 }             }         }         if (headerIndex == -1) {             for (int j = nextHeaderIndex + 1, length = dynamicTable.length. j < length. j++) {                 if (Objects.equals(dynamicTable[j].name, name)) {                     if (Objects.equals(dynamicTable[j].value, value)) {                         headerIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length.                         break.                     } else if (headerNameIndex == -1) {                         headerNameIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length.                     }                 }             }         }         if (headerIndex != -1) {             // Indexed Header Field.             writeInt(headerIndex, PREFIX_7_BITS, 0x80).         } else if (headerNameIndex == -1) {             // Literal Header Field with Incremental Indexing - New Name.             out.writeByte(0x40).             writeByteString(name).             writeByteString(value).             insertIntoDynamicTable(header).         } else if (name.startsWith(Header.PSEUDO_PREFIX) && !Header.TARGET_AUTHORITY.equals(name)) {             // Follow Chromes lead - only include the :authority pseudo header, but exclude all other             // pseudo headers. Literal Header Field without Indexing - Indexed Name.             writeInt(headerNameIndex, PREFIX_4_BITS, 0).             writeByteString(value).         } else {             // Literal Header Field with Incremental Indexing - Indexed Name.             writeInt(headerNameIndex, PREFIX_6_BITS, 0x40).             writeByteString(value).             insertIntoDynamicTable(header).         }     } }
true;;3;19;// http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1 ;// http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1 void writeInt(int value, int prefixMask, int bits) {     // Write the raw value for a single byte value.     if (value < prefixMask) {         out.writeByte(bits | value).         return.     }     // Write the mask to start a multibyte value.     out.writeByte(bits | prefixMask).     value -= prefixMask.     // Write 7 bits at a time 'til we're done.     while (value >= 0x80) {         int b = value & 0x7f.         out.writeByte(b | 0x80).         value >>>= 7.     }     out.writeByte(value). }
false;;1;12;;void writeByteString(ByteString data) throws IOException {     if (useCompression && Huffman.get().encodedLength(data) < data.size()) {         Buffer huffmanBuffer = new Buffer().         Huffman.get().encode(data, huffmanBuffer).         ByteString huffmanBytes = huffmanBuffer.readByteString().         writeInt(huffmanBytes.size(), PREFIX_7_BITS, 0x80).         out.write(huffmanBytes).     } else {         writeInt(data.size(), PREFIX_7_BITS, 0).         out.write(data).     } }
false;;1;15;;void setHeaderTableSizeSetting(int headerTableSizeSetting) {     this.headerTableSizeSetting = headerTableSizeSetting.     int effectiveHeaderTableSize = Math.min(headerTableSizeSetting, SETTINGS_HEADER_TABLE_SIZE_LIMIT).     // No change.     if (maxDynamicTableByteCount == effectiveHeaderTableSize)         return.     if (effectiveHeaderTableSize < maxDynamicTableByteCount) {         smallestHeaderTableSizeSetting = Math.min(smallestHeaderTableSizeSetting, effectiveHeaderTableSize).     }     emitDynamicTableSizeUpdate = true.     maxDynamicTableByteCount = effectiveHeaderTableSize.     adjustDynamicTableByteCount(). }
false;private;0;9;;private void adjustDynamicTableByteCount() {     if (maxDynamicTableByteCount < dynamicTableByteCount) {         if (maxDynamicTableByteCount == 0) {             clearDynamicTable().         } else {             evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount).         }     } }
true;static;1;9;/**  * An HTTP/2 response cannot contain uppercase header characters and must be treated as  * malformed.  */ ;/**  * An HTTP/2 response cannot contain uppercase header characters and must be treated as  * malformed.  */ static ByteString checkLowercase(ByteString name) throws IOException {     for (int i = 0, length = name.size(). i < length. i++) {         byte c = name.getByte(i).         if (c >= 'A' && c <= 'Z') {             throw new IOException("PROTOCOL_ERROR response malformed: mixed case name: " + name.utf8()).         }     }     return name. }
