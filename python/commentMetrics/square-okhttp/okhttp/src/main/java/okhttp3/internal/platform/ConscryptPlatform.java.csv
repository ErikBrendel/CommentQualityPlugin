commented;modifiers;parameterAmount;loc;comment;code
false;private;0;5;;@SuppressWarnings("deprecation") private Provider getProvider() {     // new form with boolean is only present in >= 2.0.0     return Conscrypt.newProviderBuilder().provideTrustManager().build(). }
false;public;1;20;;@Override @Nullable public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {     if (!Conscrypt.isConscrypt(sslSocketFactory)) {         return super.trustManager(sslSocketFactory).     }     try {         // org.conscrypt.SSLParametersImpl         Object sp = readFieldOrNull(sslSocketFactory, Object.class, "sslParameters").         if (sp != null) {             return readFieldOrNull(sp, X509TrustManager.class, "x509TrustManager").         }         return null.     } catch (Exception e) {         throw new UnsupportedOperationException("clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on Conscrypt", e).     } }
false;public;3;16;;@Override public void configureTlsExtensions(SSLSocket sslSocket, String hostname, List<Protocol> protocols) {     if (Conscrypt.isConscrypt(sslSocket)) {         // Enable SNI and session tickets.         if (hostname != null) {             Conscrypt.setUseSessionTickets(sslSocket, true).             Conscrypt.setHostname(sslSocket, hostname).         }         // Enable ALPN.         List<String> names = Platform.alpnProtocolNames(protocols).         Conscrypt.setApplicationProtocols(sslSocket, names.toArray(new String[0])).     } else {         super.configureTlsExtensions(sslSocket, hostname, protocols).     } }
false;public;1;7;;@Override @Nullable public String getSelectedProtocol(SSLSocket sslSocket) {     if (Conscrypt.isConscrypt(sslSocket)) {         return Conscrypt.getApplicationProtocol(sslSocket).     } else {         return super.getSelectedProtocol(sslSocket).     } }
false;public;0;12;;@Override public SSLContext getSSLContext() {     try {         return SSLContext.getInstance("TLSv1.3", getProvider()).     } catch (NoSuchAlgorithmException e) {         try {             // Allow for Conscrypt 1.2             return SSLContext.getInstance("TLS", getProvider()).         } catch (NoSuchAlgorithmException e2) {             throw new IllegalStateException("No TLS provider", e).         }     } }
false;public,static;0;14;;public static ConscryptPlatform buildIfSupported() {     try {         // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.         Class.forName("org.conscrypt.Conscrypt").         if (!Conscrypt.isAvailable()) {             return null.         }         return new ConscryptPlatform().     } catch (ClassNotFoundException e) {         return null.     } }
false;public;1;6;;@Override public void configureSslSocketFactory(SSLSocketFactory socketFactory) {     if (Conscrypt.isConscrypt(socketFactory)) {         Conscrypt.setUseEngineSocket(socketFactory, true).     } }
