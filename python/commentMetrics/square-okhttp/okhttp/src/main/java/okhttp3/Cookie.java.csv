commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns a non-empty string with this cookie's name.  */ ;/**  * Returns a non-empty string with this cookie's name.  */ public String name() {     return name. }
true;public;0;3;/**  * Returns a possibly-empty string with this cookie's value.  */ ;/**  * Returns a possibly-empty string with this cookie's value.  */ public String value() {     return value. }
true;public;0;3;/**  * Returns true if this cookie does not expire at the end of the current session.  */ ;/**  * Returns true if this cookie does not expire at the end of the current session.  */ public boolean persistent() {     return persistent. }
true;public;0;3;/**  * Returns the time that this cookie expires, in the same format as {@link  * System#currentTimeMillis()}. This is December 31, 9999 if the cookie is {@linkplain  * #persistent() not persistent}, in which case it will expire at the end of the current session.  *  * <p>This may return a value less than the current time, in which case the cookie is already  * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies  * that may or may not themselves be expired.  */ ;/**  * Returns the time that this cookie expires, in the same format as {@link  * System#currentTimeMillis()}. This is December 31, 9999 if the cookie is {@linkplain  * #persistent() not persistent}, in which case it will expire at the end of the current session.  *  * <p>This may return a value less than the current time, in which case the cookie is already  * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies  * that may or may not themselves be expired.  */ public long expiresAt() {     return expiresAt. }
true;public;0;3;/**  * Returns true if this cookie's domain should be interpreted as a single host name, or false if  * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header  * included a {@code domain} attribute.  *  * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it  * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code  * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and  * {@code beta.api.example.com}.  */ ;/**  * Returns true if this cookie's domain should be interpreted as a single host name, or false if  * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header  * included a {@code domain} attribute.  *  * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it  * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code  * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and  * {@code beta.api.example.com}.  */ public boolean hostOnly() {     return hostOnly. }
true;public;0;3;/**  * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that  * matches this cookie. otherwise it matches this domain and all subdomains.  */ ;/**  * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that  * matches this cookie. otherwise it matches this domain and all subdomains.  */ public String domain() {     return domain. }
true;public;0;3;/**  * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match  * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to  * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.  */ ;/**  * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match  * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to  * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.  */ public String path() {     return path. }
true;public;0;3;/**  * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents  * the cookie from being accessible to scripts.  */ ;/**  * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents  * the cookie from being accessible to scripts.  */ public boolean httpOnly() {     return httpOnly. }
true;public;0;3;/**  * Returns true if this cookie should be limited to only HTTPS requests.  */ ;/**  * Returns true if this cookie should be limited to only HTTPS requests.  */ public boolean secure() {     return secure. }
true;public;1;12;/**  * Returns true if this cookie should be included on a request to {@code url}. In addition to this  * check callers should also confirm that this cookie has not expired.  */ ;/**  * Returns true if this cookie should be included on a request to {@code url}. In addition to this  * check callers should also confirm that this cookie has not expired.  */ public boolean matches(HttpUrl url) {     boolean domainMatch = hostOnly ? url.host().equals(domain) : domainMatch(url.host(), domain).     if (!domainMatch)         return false.     if (!pathMatch(url, path))         return false.     if (secure && !url.isHttps())         return false.     return true. }
false;private,static;2;13;;private static boolean domainMatch(String urlHost, String domain) {     if (urlHost.equals(domain)) {         // As in 'example.com' matching 'example.com'.         return true.     }     if (urlHost.endsWith(domain) && urlHost.charAt(urlHost.length() - domain.length() - 1) == '.' && !verifyAsIpAddress(urlHost)) {         // As in 'example.com' matching 'www.example.com'.         return true.     }     return false. }
false;private,static;2;14;;private static boolean pathMatch(HttpUrl url, String path) {     String urlPath = url.encodedPath().     if (urlPath.equals(path)) {         // As in '/foo' matching '/foo'.         return true.     }     if (urlPath.startsWith(path)) {         // As in '/' matching '/foo'.         if (path.endsWith("/"))             return true.         // As in '/foo' matching '/foo/bar'.         if (urlPath.charAt(path.length()) == '/')             return true.     }     return false. }
true;public,static;2;3;/**  * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns  * null if {@code setCookie} is not a well-formed cookie.  */ ;/**  * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns  * null if {@code setCookie} is not a well-formed cookie.  */ @Nullable public static Cookie parse(HttpUrl url, String setCookie) {     return parse(System.currentTimeMillis(), url, setCookie). }
false;static;3;104;;@Nullable static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {     int pos = 0.     int limit = setCookie.length().     int cookiePairEnd = delimiterOffset(setCookie, pos, limit, '.').     int pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=').     if (pairEqualsSign == cookiePairEnd)         return null.     String cookieName = trimSubstring(setCookie, pos, pairEqualsSign).     if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1)         return null.     String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd).     if (indexOfControlOrNonAscii(cookieValue) != -1)         return null.     long expiresAt = HttpDate.MAX_DATE.     long deltaSeconds = -1L.     String domain = null.     String path = null.     boolean secureOnly = false.     boolean httpOnly = false.     boolean hostOnly = true.     boolean persistent = false.     pos = cookiePairEnd + 1.     while (pos < limit) {         int attributePairEnd = delimiterOffset(setCookie, pos, limit, '.').         int attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=').         String attributeName = trimSubstring(setCookie, pos, attributeEqualsSign).         String attributeValue = attributeEqualsSign < attributePairEnd ? trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd) : "".         if (attributeName.equalsIgnoreCase("expires")) {             try {                 expiresAt = parseExpires(attributeValue, 0, attributeValue.length()).                 persistent = true.             } catch (IllegalArgumentException e) {             // Ignore this attribute, it isn't recognizable as a date.             }         } else if (attributeName.equalsIgnoreCase("max-age")) {             try {                 deltaSeconds = parseMaxAge(attributeValue).                 persistent = true.             } catch (NumberFormatException e) {             // Ignore this attribute, it isn't recognizable as a max age.             }         } else if (attributeName.equalsIgnoreCase("domain")) {             try {                 domain = parseDomain(attributeValue).                 hostOnly = false.             } catch (IllegalArgumentException e) {             // Ignore this attribute, it isn't recognizable as a domain.             }         } else if (attributeName.equalsIgnoreCase("path")) {             path = attributeValue.         } else if (attributeName.equalsIgnoreCase("secure")) {             secureOnly = true.         } else if (attributeName.equalsIgnoreCase("httponly")) {             httpOnly = true.         }         pos = attributePairEnd + 1.     }     // attributes are declared in the cookie string.     if (deltaSeconds == Long.MIN_VALUE) {         expiresAt = Long.MIN_VALUE.     } else if (deltaSeconds != -1L) {         long deltaMilliseconds = deltaSeconds <= (Long.MAX_VALUE / 1000) ? deltaSeconds * 1000 : Long.MAX_VALUE.         expiresAt = currentTimeMillis + deltaMilliseconds.         if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {             // Handle overflow & limit the date range.             expiresAt = HttpDate.MAX_DATE.         }     }     // If the domain is present, it must domain match. Otherwise we have a host-only cookie.     String urlHost = url.host().     if (domain == null) {         domain = urlHost.     } else if (!domainMatch(urlHost, domain)) {         // No domain match? This is either incompetence or malice!         return null.     }     // If the domain is a suffix of the url host, it must not be a public suffix.     if (urlHost.length() != domain.length() && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {         return null.     }     // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.     if (path == null || !path.startsWith("/")) {         String encodedPath = url.encodedPath().         int lastSlash = encodedPath.lastIndexOf('/').         path = lastSlash != 0 ? encodedPath.substring(0, lastSlash) : "/".     }     return new Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly, hostOnly, persistent). }
true;private,static;3;55;/**  * Parse a date as specified in RFC 6265, section 5.1.1.  */ ;/**  * Parse a date as specified in RFC 6265, section 5.1.1.  */ private static long parseExpires(String s, int pos, int limit) {     pos = dateCharacterOffset(s, pos, limit, false).     int hour = -1.     int minute = -1.     int second = -1.     int dayOfMonth = -1.     int month = -1.     int year = -1.     Matcher matcher = TIME_PATTERN.matcher(s).     while (pos < limit) {         int end = dateCharacterOffset(s, pos + 1, limit, true).         matcher.region(pos, end).         if (hour == -1 && matcher.usePattern(TIME_PATTERN).matches()) {             hour = Integer.parseInt(matcher.group(1)).             minute = Integer.parseInt(matcher.group(2)).             second = Integer.parseInt(matcher.group(3)).         } else if (dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches()) {             dayOfMonth = Integer.parseInt(matcher.group(1)).         } else if (month == -1 && matcher.usePattern(MONTH_PATTERN).matches()) {             String monthString = matcher.group(1).toLowerCase(Locale.US).             // Sneaky! jan=1, dec=12.             month = MONTH_PATTERN.pattern().indexOf(monthString) / 4.         } else if (year == -1 && matcher.usePattern(YEAR_PATTERN).matches()) {             year = Integer.parseInt(matcher.group(1)).         }         pos = dateCharacterOffset(s, end + 1, limit, false).     }     // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.     if (year >= 70 && year <= 99)         year += 1900.     if (year >= 0 && year <= 69)         year += 2000.     // seconds are not supported by this syntax.     if (year < 1601)         throw new IllegalArgumentException().     if (month == -1)         throw new IllegalArgumentException().     if (dayOfMonth < 1 || dayOfMonth > 31)         throw new IllegalArgumentException().     if (hour < 0 || hour > 23)         throw new IllegalArgumentException().     if (minute < 0 || minute > 59)         throw new IllegalArgumentException().     if (second < 0 || second > 59)         throw new IllegalArgumentException().     Calendar calendar = new GregorianCalendar(UTC).     calendar.setLenient(false).     calendar.set(Calendar.YEAR, year).     calendar.set(Calendar.MONTH, month - 1).     calendar.set(Calendar.DAY_OF_MONTH, dayOfMonth).     calendar.set(Calendar.HOUR_OF_DAY, hour).     calendar.set(Calendar.MINUTE, minute).     calendar.set(Calendar.SECOND, second).     calendar.set(Calendar.MILLISECOND, 0).     return calendar.getTimeInMillis(). }
true;private,static;4;12;/**  * Returns the index of the next date character in {@code input}, or if {@code invert} the index  * of the next non-date character in {@code input}.  */ ;/**  * Returns the index of the next date character in {@code input}, or if {@code invert} the index  * of the next non-date character in {@code input}.  */ private static int dateCharacterOffset(String input, int pos, int limit, boolean invert) {     for (int i = pos. i < limit. i++) {         int c = input.charAt(i).         boolean dateCharacter = (c < ' ' && c != '\t') || (c >= '\u007f') || (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c == ':').         if (dateCharacter == !invert)             return i.     }     return limit. }
true;private,static;1;12;/**  * Returns the positive value if {@code attributeValue} is positive, or {@link Long#MIN_VALUE} if  * it is either 0 or negative. If the value is positive but out of range, this returns {@link  * Long#MAX_VALUE}.  *  * @throws NumberFormatException if {@code s} is not an integer of any precision.  */ ;/**  * Returns the positive value if {@code attributeValue} is positive, or {@link Long#MIN_VALUE} if  * it is either 0 or negative. If the value is positive but out of range, this returns {@link  * Long#MAX_VALUE}.  *  * @throws NumberFormatException if {@code s} is not an integer of any precision.  */ private static long parseMaxAge(String s) {     try {         long parsed = Long.parseLong(s).         return parsed <= 0L ? Long.MIN_VALUE : parsed.     } catch (NumberFormatException e) {         // Check if the value is an integer (positive or negative) that's too big for a long.         if (s.matches("-?\\d+")) {             return s.startsWith("-") ? Long.MIN_VALUE : Long.MAX_VALUE.         }         throw e.     } }
true;private,static;1;13;/**  * Returns a domain string like {@code example.com} for an input domain like {@code EXAMPLE.COM}  * or {@code .example.com}.  */ ;/**  * Returns a domain string like {@code example.com} for an input domain like {@code EXAMPLE.COM}  * or {@code .example.com}.  */ private static String parseDomain(String s) {     if (s.endsWith(".")) {         throw new IllegalArgumentException().     }     if (s.startsWith(".")) {         s = s.substring(1).     }     String canonicalDomain = canonicalizeHost(s).     if (canonicalDomain == null) {         throw new IllegalArgumentException().     }     return canonicalDomain. }
true;public,static;2;15;/**  * Returns all of the cookies from a set of HTTP response headers.  */ ;/**  * Returns all of the cookies from a set of HTTP response headers.  */ public static List<Cookie> parseAll(HttpUrl url, Headers headers) {     List<String> cookieStrings = headers.values("Set-Cookie").     List<Cookie> cookies = null.     for (int i = 0, size = cookieStrings.size(). i < size. i++) {         Cookie cookie = Cookie.parse(url, cookieStrings.get(i)).         if (cookie == null)             continue.         if (cookies == null)             cookies = new ArrayList<>().         cookies.add(cookie).     }     return cookies != null ? Collections.unmodifiableList(cookies) : Collections.emptyList(). }
false;public;1;6;;public Builder name(String name) {     if (name == null)         throw new NullPointerException("name == null").     if (!name.trim().equals(name))         throw new IllegalArgumentException("name is not trimmed").     this.name = name.     return this. }
false;public;1;6;;public Builder value(String value) {     if (value == null)         throw new NullPointerException("value == null").     if (!value.trim().equals(value))         throw new IllegalArgumentException("value is not trimmed").     this.value = value.     return this. }
false;public;1;7;;public Builder expiresAt(long expiresAt) {     if (expiresAt <= 0)         expiresAt = Long.MIN_VALUE.     if (expiresAt > HttpDate.MAX_DATE)         expiresAt = HttpDate.MAX_DATE.     this.expiresAt = expiresAt.     this.persistent = true.     return this. }
true;public;1;3;/**  * Set the domain pattern for this cookie. The cookie will match {@code domain} and all of its  * subdomains.  */ ;/**  * Set the domain pattern for this cookie. The cookie will match {@code domain} and all of its  * subdomains.  */ public Builder domain(String domain) {     return domain(domain, false). }
true;public;1;3;/**  * Set the host-only domain for this cookie. The cookie will match {@code domain} but none of  * its subdomains.  */ ;/**  * Set the host-only domain for this cookie. The cookie will match {@code domain} but none of  * its subdomains.  */ public Builder hostOnlyDomain(String domain) {     return domain(domain, true). }
false;private;2;10;;private Builder domain(String domain, boolean hostOnly) {     if (domain == null)         throw new NullPointerException("domain == null").     String canonicalDomain = Util.canonicalizeHost(domain).     if (canonicalDomain == null) {         throw new IllegalArgumentException("unexpected domain: " + domain).     }     this.domain = canonicalDomain.     this.hostOnly = hostOnly.     return this. }
false;public;1;5;;public Builder path(String path) {     if (!path.startsWith("/"))         throw new IllegalArgumentException("path must start with '/'").     this.path = path.     return this. }
false;public;0;4;;public Builder secure() {     this.secure = true.     return this. }
false;public;0;4;;public Builder httpOnly() {     this.httpOnly = true.     return this. }
false;public;0;3;;public Cookie build() {     return new Cookie(this). }
false;public;0;3;;@Override public String toString() {     return toString(false). }
true;;1;34;/**  * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is  *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This  *     extra dot is ignored by more recent specifications.  */ ;/**  * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is  *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This  *     extra dot is ignored by more recent specifications.  */ String toString(boolean forObsoleteRfc2965) {     StringBuilder result = new StringBuilder().     result.append(name).     result.append('=').     result.append(value).     if (persistent) {         if (expiresAt == Long.MIN_VALUE) {             result.append(". max-age=0").         } else {             result.append(". expires=").append(HttpDate.format(new Date(expiresAt))).         }     }     if (!hostOnly) {         result.append(". domain=").         if (forObsoleteRfc2965) {             result.append(".").         }         result.append(domain).     }     result.append(". path=").append(path).     if (secure) {         result.append(". secure").     }     if (httpOnly) {         result.append(". httponly").     }     return result.toString(). }
false;public;1;13;;@Override public boolean equals(@Nullable Object other) {     if (!(other instanceof Cookie))         return false.     Cookie that = (Cookie) other.     return that.name.equals(name) && that.value.equals(value) && that.domain.equals(domain) && that.path.equals(path) && that.expiresAt == expiresAt && that.secure == secure && that.httpOnly == httpOnly && that.persistent == persistent && that.hostOnly == hostOnly. }
false;public;0;13;;@Override public int hashCode() {     int hash = 17.     hash = 31 * hash + name.hashCode().     hash = 31 * hash + value.hashCode().     hash = 31 * hash + domain.hashCode().     hash = 31 * hash + path.hashCode().     hash = 31 * hash + (int) (expiresAt ^ (expiresAt >>> 32)).     hash = 31 * hash + (secure ? 0 : 1).     hash = 31 * hash + (httpOnly ? 0 : 1).     hash = 31 * hash + (persistent ? 0 : 1).     hash = 31 * hash + (hostOnly ? 0 : 1).     return hash. }
