commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The number of key-value pairs in this form-encoded body.  */ ;/**  * The number of key-value pairs in this form-encoded body.  */ public int size() {     return encodedNames.size(). }
false;public;1;3;;public String encodedName(int index) {     return encodedNames.get(index). }
false;public;1;3;;public String name(int index) {     return percentDecode(encodedName(index), true). }
false;public;1;3;;public String encodedValue(int index) {     return encodedValues.get(index). }
false;public;1;3;;public String value(int index) {     return percentDecode(encodedValue(index), true). }
false;public;0;3;;@Override public MediaType contentType() {     return CONTENT_TYPE. }
false;public;0;3;;@Override public long contentLength() {     return writeOrCountBytes(null, true). }
false;public;1;3;;@Override public void writeTo(BufferedSink sink) throws IOException {     writeOrCountBytes(sink, false). }
true;private;2;24;/**  * Either writes this request to {@code sink} or measures its content length. We have one method  * do double-duty to make sure the counting and content are consistent, particularly when it comes  * to awkward operations like measuring the encoded length of header strings, or the  * length-in-digits of an encoded integer.  */ ;/**  * Either writes this request to {@code sink} or measures its content length. We have one method  * do double-duty to make sure the counting and content are consistent, particularly when it comes  * to awkward operations like measuring the encoded length of header strings, or the  * length-in-digits of an encoded integer.  */ private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {     long byteCount = 0L.     Buffer buffer.     if (countBytes) {         buffer = new Buffer().     } else {         buffer = sink.buffer().     }     for (int i = 0, size = encodedNames.size(). i < size. i++) {         if (i > 0)             buffer.writeByte('&').         buffer.writeUtf8(encodedNames.get(i)).         buffer.writeByte('=').         buffer.writeUtf8(encodedValues.get(i)).     }     if (countBytes) {         byteCount = buffer.size().         buffer.clear().     }     return byteCount. }
false;public;2;8;;public Builder add(String name, String value) {     if (name == null)         throw new NullPointerException("name == null").     if (value == null)         throw new NullPointerException("value == null").     names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset)).     values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset)).     return this. }
false;public;2;8;;public Builder addEncoded(String name, String value) {     if (name == null)         throw new NullPointerException("name == null").     if (value == null)         throw new NullPointerException("value == null").     names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset)).     values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset)).     return this. }
false;public;0;3;;public FormBody build() {     return new FormBody(names, values). }
