commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;@Override protected DateFormat initialValue() {     // Date format specified by RFC 7231 section 7.1.1.1.     DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US).     rfc1123.setLenient(false).     rfc1123.setTimeZone(UTC).     return rfc1123. }
true;public,static;1;36;/**  * Returns the date for {@code value}. Returns null if the value couldn't be parsed.  */ ;/**  * Returns the date for {@code value}. Returns null if the value couldn't be parsed.  */ public static Date parse(String value) {     if (value.length() == 0) {         return null.     }     ParsePosition position = new ParsePosition(0).     Date result = STANDARD_DATE_FORMAT.get().parse(value, position).     if (position.getIndex() == value.length()) {         // non-standard trailing "+01:00". Those cases are covered below.         return result.     }     synchronized (BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {         for (int i = 0, count = BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length. i < count. i++) {             DateFormat format = BROWSER_COMPATIBLE_DATE_FORMATS[i].             if (format == null) {                 format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US).                 // Set the timezone to use when interpreting formats that don't have a timezone. GMT is                 // specified by RFC 7231.                 format.setTimeZone(UTC).                 BROWSER_COMPATIBLE_DATE_FORMATS[i] = format.             }             position.setIndex(0).             result = format.parse(value, position).             if (position.getIndex() != 0) {                 // trailing junk is ignored.                 return result.             }         }     }     return null. }
true;public,static;1;3;/**  * Returns the string for {@code value}.  */ ;/**  * Returns the string for {@code value}.  */ public static String format(Date value) {     return STANDARD_DATE_FORMAT.get().format(value). }
