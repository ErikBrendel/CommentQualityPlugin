commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isTls() {     return tls. }
true;public;0;3;/**  * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's  * enabled cipher suites should be used.  */ ;/**  * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's  * enabled cipher suites should be used.  */ @Nullable public List<CipherSuite> cipherSuites() {     return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null. }
true;public;0;3;/**  * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL  * socket's enabled TLS versions should be used.  */ ;/**  * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL  * socket's enabled TLS versions should be used.  */ @Nullable public List<TlsVersion> tlsVersions() {     return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null. }
false;public;0;3;;public boolean supportsTlsExtensions() {     return supportsTlsExtensions. }
true;;2;10;/**  * Applies this spec to {@code sslSocket}.  */ ;/**  * Applies this spec to {@code sslSocket}.  */ void apply(SSLSocket sslSocket, boolean isFallback) {     ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback).     if (specToApply.tlsVersions != null) {         sslSocket.setEnabledProtocols(specToApply.tlsVersions).     }     if (specToApply.cipherSuites != null) {         sslSocket.setEnabledCipherSuites(specToApply.cipherSuites).     } }
true;private;2;23;/**  * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code  * sslSocket}.  */ ;/**  * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code  * sslSocket}.  */ private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {     String[] cipherSuitesIntersection = cipherSuites != null ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites) : sslSocket.getEnabledCipherSuites().     String[] tlsVersionsIntersection = tlsVersions != null ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions) : sslSocket.getEnabledProtocols().     // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00     // the SCSV cipher is added to signal that a protocol fallback has taken place.     String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites().     int indexOfFallbackScsv = indexOf(CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV").     if (isFallback && indexOfFallbackScsv != -1) {         cipherSuitesIntersection = concat(cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]).     }     return new Builder(this).cipherSuites(cipherSuitesIntersection).tlsVersions(tlsVersionsIntersection).build(). }
true;public;1;17;/**  * Returns {@code true} if the socket, as currently configured, supports this connection spec. In  * order for a socket to be compatible the enabled cipher suites and protocols must intersect.  *  * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must  * match the socket's enabled cipher suites. If there are no required cipher suites the socket  * must have at least one cipher suite enabled.  *  * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the  * socket's enabled protocols.  */ ;/**  * Returns {@code true} if the socket, as currently configured, supports this connection spec. In  * order for a socket to be compatible the enabled cipher suites and protocols must intersect.  *  * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must  * match the socket's enabled cipher suites. If there are no required cipher suites the socket  * must have at least one cipher suite enabled.  *  * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the  * socket's enabled protocols.  */ public boolean isCompatible(SSLSocket socket) {     if (!tls) {         return false.     }     if (tlsVersions != null && !nonEmptyIntersection(Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {         return false.     }     if (cipherSuites != null && !nonEmptyIntersection(CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {         return false.     }     return true. }
false;public;1;15;;@Override public boolean equals(@Nullable Object other) {     if (!(other instanceof ConnectionSpec))         return false.     if (other == this)         return true.     ConnectionSpec that = (ConnectionSpec) other.     if (this.tls != that.tls)         return false.     if (tls) {         if (!Arrays.equals(this.cipherSuites, that.cipherSuites))             return false.         if (!Arrays.equals(this.tlsVersions, that.tlsVersions))             return false.         if (this.supportsTlsExtensions != that.supportsTlsExtensions)             return false.     }     return true. }
false;public;0;9;;@Override public int hashCode() {     int result = 17.     if (tls) {         result = 31 * result + Arrays.hashCode(cipherSuites).         result = 31 * result + Arrays.hashCode(tlsVersions).         result = 31 * result + (supportsTlsExtensions ? 0 : 1).     }     return result. }
false;public;0;11;;@Override public String toString() {     if (!tls) {         return "ConnectionSpec()".     }     return "ConnectionSpec(" + "cipherSuites=" + Objects.toString(cipherSuites(), "[all enabled]") + ", tlsVersions=" + Objects.toString(tlsVersions(), "[all enabled]") + ", supportsTlsExtensions=" + supportsTlsExtensions + ")". }
false;public;0;5;;public Builder allEnabledCipherSuites() {     if (!tls)         throw new IllegalStateException("no cipher suites for cleartext connections").     this.cipherSuites = null.     return this. }
false;public;1;9;;public Builder cipherSuites(CipherSuite... cipherSuites) {     if (!tls)         throw new IllegalStateException("no cipher suites for cleartext connections").     String[] strings = new String[cipherSuites.length].     for (int i = 0. i < cipherSuites.length. i++) {         strings[i] = cipherSuites[i].javaName.     }     return cipherSuites(strings). }
false;public;1;10;;public Builder cipherSuites(String... cipherSuites) {     if (!tls)         throw new IllegalStateException("no cipher suites for cleartext connections").     if (cipherSuites.length == 0) {         throw new IllegalArgumentException("At least one cipher suite is required").     }     // Defensive copy.     this.cipherSuites = cipherSuites.clone().     return this. }
false;public;0;5;;public Builder allEnabledTlsVersions() {     if (!tls)         throw new IllegalStateException("no TLS versions for cleartext connections").     this.tlsVersions = null.     return this. }
false;public;1;10;;public Builder tlsVersions(TlsVersion... tlsVersions) {     if (!tls)         throw new IllegalStateException("no TLS versions for cleartext connections").     String[] strings = new String[tlsVersions.length].     for (int i = 0. i < tlsVersions.length. i++) {         strings[i] = tlsVersions[i].javaName.     }     return tlsVersions(strings). }
false;public;1;10;;public Builder tlsVersions(String... tlsVersions) {     if (!tls)         throw new IllegalStateException("no TLS versions for cleartext connections").     if (tlsVersions.length == 0) {         throw new IllegalArgumentException("At least one TLS version is required").     }     // Defensive copy.     this.tlsVersions = tlsVersions.clone().     return this. }
true;public;1;5;/**  * @deprecated since OkHttp 3.13 all TLS-connections are expected to support TLS extensions.  *     In a future release setting this to true will be unnecessary and setting it to false will  *     have no effect.  */ ;/**  * @deprecated since OkHttp 3.13 all TLS-connections are expected to support TLS extensions.  *     In a future release setting this to true will be unnecessary and setting it to false will  *     have no effect.  */ public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {     if (!tls)         throw new IllegalStateException("no TLS extensions for cleartext connections").     this.supportsTlsExtensions = supportsTlsExtensions.     return this. }
false;public;0;3;;public ConnectionSpec build() {     return new ConnectionSpec(this). }
