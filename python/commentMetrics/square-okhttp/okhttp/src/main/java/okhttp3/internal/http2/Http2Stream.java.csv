commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public int getId() {     return id. }
true;public,synchronized;0;11;/**  * Returns true if this stream is open. A stream is open until either:  *  * <ul>  *     <li>A {@code SYN_RESET} frame abnormally terminates the stream.  *     <li>Both input and output streams have transmitted all data and headers.  * </ul>  *  * <p>Note that the input stream may continue to yield data even after a stream reports itself as  * not open. This is because input data is buffered.  */ ;/**  * Returns true if this stream is open. A stream is open until either:  *  * <ul>  *     <li>A {@code SYN_RESET} frame abnormally terminates the stream.  *     <li>Both input and output streams have transmitted all data and headers.  * </ul>  *  * <p>Note that the input stream may continue to yield data even after a stream reports itself as  * not open. This is because input data is buffered.  */ public synchronized boolean isOpen() {     if (errorCode != null) {         return false.     }     if ((source.finished || source.closed) && (sink.finished || sink.closed) && hasResponseHeaders) {         return false.     }     return true. }
true;public;0;4;/**  * Returns true if this stream was created by this peer.  */ ;/**  * Returns true if this stream was created by this peer.  */ public boolean isLocallyInitiated() {     boolean streamIsClient = ((id & 1) == 1).     return connection.client == streamIsClient. }
false;public;0;3;;public Http2Connection getConnection() {     return connection. }
true;public,synchronized;0;14;/**  * Removes and returns the stream's received response headers, blocking if necessary until headers  * have been received. If the returned list contains multiple blocks of headers the blocks will be  * delimited by 'null'.  */ ;/**  * Removes and returns the stream's received response headers, blocking if necessary until headers  * have been received. If the returned list contains multiple blocks of headers the blocks will be  * delimited by 'null'.  */ public synchronized Headers takeHeaders() throws IOException {     readTimeout.enter().     try {         while (headersQueue.isEmpty() && errorCode == null) {             waitForIo().         }     } finally {         readTimeout.exitAndThrowIfTimedOut().     }     if (!headersQueue.isEmpty()) {         return headersQueue.removeFirst().     }     throw new StreamResetException(errorCode). }
true;public,synchronized;0;9;/**  * Returns the trailers. It is only safe to call this once the source stream has been completely  * exhausted.  */ ;/**  * Returns the trailers. It is only safe to call this once the source stream has been completely  * exhausted.  */ public synchronized Headers trailers() throws IOException {     if (errorCode != null) {         throw new StreamResetException(errorCode).     }     if (!source.finished || !source.receiveBuffer.exhausted() || !source.readBuffer.exhausted()) {         throw new IllegalStateException("too early. can't read the trailers yet").     }     return source.trailers != null ? source.trailers : Util.EMPTY_HEADERS. }
true;public,synchronized;0;3;/**  * Returns the reason why this stream was closed, or null if it closed normally or has not yet  * been closed.  */ ;/**  * Returns the reason why this stream was closed, or null if it closed normally or has not yet  * been closed.  */ public synchronized ErrorCode getErrorCode() {     return errorCode. }
true;public;3;27;/**  * Sends a reply to an incoming stream.  *  * @param outFinished true to eagerly finish the output stream to send data to the remote peer.  *     Corresponds to {@code FLAG_FIN}.  * @param flushHeaders true to force flush the response headers. This should be true unless the  *     response body exists and will be written immediately.  */ ;/**  * Sends a reply to an incoming stream.  *  * @param outFinished true to eagerly finish the output stream to send data to the remote peer.  *     Corresponds to {@code FLAG_FIN}.  * @param flushHeaders true to force flush the response headers. This should be true unless the  *     response body exists and will be written immediately.  */ public void writeHeaders(List<Header> responseHeaders, boolean outFinished, boolean flushHeaders) throws IOException {     assert (!Thread.holdsLock(Http2Stream.this)).     if (responseHeaders == null) {         throw new NullPointerException("headers == null").     }     synchronized (this) {         this.hasResponseHeaders = true.         if (outFinished) {             this.sink.finished = true.         }     }     // flow-control window is fully depleted.     if (!flushHeaders) {         synchronized (connection) {             flushHeaders = connection.bytesLeftInWriteWindow == 0L.         }     }     connection.writeHeaders(id, outFinished, responseHeaders).     if (flushHeaders) {         connection.flush().     } }
false;public;1;7;;public void enqueueTrailers(Headers trailers) {     synchronized (this) {         if (sink.finished)             throw new IllegalStateException("already finished").         if (trailers.size() == 0)             throw new IllegalArgumentException("trailers.size() == 0").         this.sink.trailers = trailers.     } }
false;public;0;3;;public Timeout readTimeout() {     return readTimeout. }
false;public;0;3;;public Timeout writeTimeout() {     return writeTimeout. }
true;public;0;3;/**  * Returns a source that reads data from the peer.  */ ;/**  * Returns a source that reads data from the peer.  */ public Source getSource() {     return source. }
true;public;0;8;/**  * Returns a sink that can be used to write data to the peer.  *  * @throws IllegalStateException if this stream was initiated by the peer and a {@link  *     #writeHeaders} has not yet been sent.  */ ;/**  * Returns a sink that can be used to write data to the peer.  *  * @throws IllegalStateException if this stream was initiated by the peer and a {@link  *     #writeHeaders} has not yet been sent.  */ public Sink getSink() {     synchronized (this) {         if (!hasResponseHeaders && !isLocallyInitiated()) {             throw new IllegalStateException("reply before requesting the sink").         }     }     return sink. }
true;public;1;6;/**  * Abnormally terminate this stream. This blocks until the {@code RST_STREAM} frame has been  * transmitted.  */ ;/**  * Abnormally terminate this stream. This blocks until the {@code RST_STREAM} frame has been  * transmitted.  */ public void close(ErrorCode rstStatusCode) throws IOException {     if (!closeInternal(rstStatusCode)) {         // Already closed.         return.     }     connection.writeSynReset(id, rstStatusCode). }
true;public;1;6;/**  * Abnormally terminate this stream. This enqueues a {@code RST_STREAM} frame and returns  * immediately.  */ ;/**  * Abnormally terminate this stream. This enqueues a {@code RST_STREAM} frame and returns  * immediately.  */ public void closeLater(ErrorCode errorCode) {     if (!closeInternal(errorCode)) {         // Already closed.         return.     }     connection.writeSynResetLater(id, errorCode). }
true;private;1;15;/**  * Returns true if this stream was closed.  */ ;/**  * Returns true if this stream was closed.  */ private boolean closeInternal(ErrorCode errorCode) {     assert (!Thread.holdsLock(this)).     synchronized (this) {         if (this.errorCode != null) {             return false.         }         if (source.finished && sink.finished) {             return false.         }         this.errorCode = errorCode.         notifyAll().     }     connection.removeStream(id).     return true. }
false;;2;4;;void receiveData(BufferedSource in, int length) throws IOException {     assert (!Thread.holdsLock(Http2Stream.this)).     this.source.receive(in, length). }
true;;2;20;/**  * Accept headers from the network and store them until the client calls {@link #takeHeaders}, or  * {@link FramingSource#read} them.  */ ;/**  * Accept headers from the network and store them until the client calls {@link #takeHeaders}, or  * {@link FramingSource#read} them.  */ void receiveHeaders(Headers headers, boolean inFinished) {     assert (!Thread.holdsLock(Http2Stream.this)).     boolean open.     synchronized (this) {         if (!hasResponseHeaders || !inFinished) {             hasResponseHeaders = true.             headersQueue.add(headers).         } else {             this.source.trailers = headers.         }         if (inFinished) {             this.source.finished = true.         }         open = isOpen().         notifyAll().     }     if (!open) {         connection.removeStream(id).     } }
false;synchronized;1;6;;synchronized void receiveRstStream(ErrorCode errorCode) {     if (this.errorCode == null) {         this.errorCode = errorCode.         notifyAll().     } }
false;public;2;62;;@Override public long read(Buffer sink, long byteCount) throws IOException {     if (byteCount < 0)         throw new IllegalArgumentException("byteCount < 0: " + byteCount).     while (true) {         long readBytesDelivered = -1.         ErrorCode errorCodeToDeliver = null.         synchronized (Http2Stream.this) {             readTimeout.enter().             try {                 if (errorCode != null) {                     // Prepare to deliver an error.                     errorCodeToDeliver = errorCode.                 }                 if (closed) {                     throw new IOException("stream closed").                 } else if (readBuffer.size() > 0) {                     // Prepare to read bytes. Start by moving them to the caller's buffer.                     readBytesDelivered = readBuffer.read(sink, Math.min(byteCount, readBuffer.size())).                     unacknowledgedBytesRead += readBytesDelivered.                     if (errorCodeToDeliver == null && unacknowledgedBytesRead >= connection.okHttpSettings.getInitialWindowSize() / 2) {                         // Flow control: notify the peer that we're ready for more data! Only send a                         // WINDOW_UPDATE if the stream isn't in error.                         connection.writeWindowUpdateLater(id, unacknowledgedBytesRead).                         unacknowledgedBytesRead = 0.                     }                 } else if (!finished && errorCodeToDeliver == null) {                     // Nothing to do. Wait until that changes then try again.                     waitForIo().                     continue.                 }             } finally {                 readTimeout.exitAndThrowIfTimedOut().             }         }         if (readBytesDelivered != -1) {             // Update connection.unacknowledgedBytesRead outside the synchronized block.             updateConnectionFlowControl(readBytesDelivered).             return readBytesDelivered.         }         if (errorCodeToDeliver != null) {             // flow-control window, we risk having it go to 0 preventing the server from sending data.             throw new StreamResetException(errorCodeToDeliver).         }         // This source is exhausted.         return -1.     } }
false;private;1;4;;private void updateConnectionFlowControl(long read) {     assert (!Thread.holdsLock(Http2Stream.this)).     connection.updateConnectionFlowControl(read). }
false;;2;39;;void receive(BufferedSource in, long byteCount) throws IOException {     assert (!Thread.holdsLock(Http2Stream.this)).     while (byteCount > 0) {         boolean finished.         boolean flowControlError.         synchronized (Http2Stream.this) {             finished = this.finished.             flowControlError = byteCount + readBuffer.size() > maxByteCount.         }         // If the peer sends more data than we can handle, discard it and close the connection.         if (flowControlError) {             in.skip(byteCount).             closeLater(ErrorCode.FLOW_CONTROL_ERROR).             return.         }         // Discard data received after the stream is finished. It's probably a benign race.         if (finished) {             in.skip(byteCount).             return.         }         // Fill the receive buffer without holding any locks.         long read = in.read(receiveBuffer, byteCount).         if (read == -1)             throw new EOFException().         byteCount -= read.         // Move the received data to the read buffer to the reader can read it.         synchronized (Http2Stream.this) {             boolean wasEmpty = readBuffer.size() == 0.             readBuffer.writeAll(receiveBuffer).             if (wasEmpty) {                 Http2Stream.this.notifyAll().             }         }     } }
false;public;0;3;;@Override public Timeout timeout() {     return readTimeout. }
false;public;0;13;;@Override public void close() throws IOException {     long bytesDiscarded.     synchronized (Http2Stream.this) {         closed = true.         bytesDiscarded = readBuffer.size().         readBuffer.clear().         // TODO(jwilson): Unnecessary?         Http2Stream.this.notifyAll().     }     if (bytesDiscarded > 0) {         updateConnectionFlowControl(bytesDiscarded).     }     cancelStreamIfNecessary(). }
false;;0;18;;void cancelStreamIfNecessary() throws IOException {     assert (!Thread.holdsLock(Http2Stream.this)).     boolean open.     boolean cancel.     synchronized (this) {         cancel = !source.finished && source.closed && (sink.finished || sink.closed).         open = isOpen().     }     if (cancel) {         // RST this stream to prevent additional data from being sent. This         // is safe because the input stream is closed (we won't use any         // further bytes) and the output stream is either finished or closed         // (so RSTing both streams doesn't cause harm).         Http2Stream.this.close(ErrorCode.CANCEL).     } else if (!open) {         connection.removeStream(id).     } }
false;public;2;7;;@Override public void write(Buffer source, long byteCount) throws IOException {     assert (!Thread.holdsLock(Http2Stream.this)).     sendBuffer.write(source, byteCount).     while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {         emitFrame(false).     } }
true;private;1;25;/**  * Emit a single data frame to the connection. The frame's size be limited by this stream's  * write window. This method will block until the write window is nonempty.  */ ;/**  * Emit a single data frame to the connection. The frame's size be limited by this stream's  * write window. This method will block until the write window is nonempty.  */ private void emitFrame(boolean outFinishedOnLastFrame) throws IOException {     long toWrite.     synchronized (Http2Stream.this) {         writeTimeout.enter().         try {             while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {                 // Wait until we receive a WINDOW_UPDATE for this stream.                 waitForIo().             }         } finally {             writeTimeout.exitAndThrowIfTimedOut().         }         // Kick out if the stream was reset or closed while waiting.         checkOutNotClosed().         toWrite = Math.min(bytesLeftInWriteWindow, sendBuffer.size()).         bytesLeftInWriteWindow -= toWrite.     }     writeTimeout.enter().     try {         boolean outFinished = outFinishedOnLastFrame && toWrite == sendBuffer.size().         connection.writeData(id, outFinished, sendBuffer, toWrite).     } finally {         writeTimeout.exitAndThrowIfTimedOut().     } }
false;public;0;10;;@Override public void flush() throws IOException {     assert (!Thread.holdsLock(Http2Stream.this)).     synchronized (Http2Stream.this) {         checkOutNotClosed().     }     while (sendBuffer.size() > 0) {         emitFrame(false).         connection.flush().     } }
false;public;0;3;;@Override public Timeout timeout() {     return writeTimeout. }
false;public;0;30;;@Override public void close() throws IOException {     assert (!Thread.holdsLock(Http2Stream.this)).     synchronized (Http2Stream.this) {         if (closed)             return.     }     if (!sink.finished) {         // We have 0 or more frames of data, and 0 or more frames of trailers. We need to send at         // least one frame with the END_STREAM flag set. That must be the last frame, and the         // trailers must be sent after all of the data.         boolean hasData = sendBuffer.size() > 0.         boolean hasTrailers = trailers != null.         if (hasTrailers) {             while (sendBuffer.size() > 0) {                 emitFrame(false).             }             connection.writeHeaders(id, true, Util.toHeaderBlock(trailers)).         } else if (hasData) {             while (sendBuffer.size() > 0) {                 emitFrame(true).             }         } else {             connection.writeData(id, true, null, 0).         }     }     synchronized (Http2Stream.this) {         closed = true.     }     connection.flush().     cancelStreamIfNecessary(). }
true;;1;4;/**  * {@code delta} will be negative if a settings frame initial window is smaller than the last.  */ ;/**  * {@code delta} will be negative if a settings frame initial window is smaller than the last.  */ void addBytesToWriteWindow(long delta) {     bytesLeftInWriteWindow += delta.     if (delta > 0)         Http2Stream.this.notifyAll(). }
false;;0;9;;void checkOutNotClosed() throws IOException {     if (sink.closed) {         throw new IOException("stream closed").     } else if (sink.finished) {         throw new IOException("stream finished").     } else if (errorCode != null) {         throw new StreamResetException(errorCode).     } }
true;;0;8;/**  * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of  * the more awkward {@link InterruptedException}.  */ ;/**  * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of  * the more awkward {@link InterruptedException}.  */ void waitForIo() throws InterruptedIOException {     try {         wait().     } catch (InterruptedException e) {         // Retain interrupted status.         Thread.currentThread().interrupt().         throw new InterruptedIOException().     } }
false;protected;0;3;;@Override protected void timedOut() {     closeLater(ErrorCode.CANCEL). }
false;protected;1;7;;@Override protected IOException newTimeoutException(IOException cause) {     SocketTimeoutException socketTimeoutException = new SocketTimeoutException("timeout").     if (cause != null) {         socketTimeoutException.initCause(cause).     }     return socketTimeoutException. }
false;public;0;3;;public void exitAndThrowIfTimedOut() throws IOException {     if (exit())         throw newTimeoutException(null). }
