commented;modifiers;parameterAmount;loc;comment;code
false;static;2;3;;static IllegalArgumentException illegalArgument(String message, Object... args) {     throw new IllegalArgumentException(format(message, args)). }
false;static;2;3;;static IOException ioException(String message, Object... args) throws IOException {     throw new IOException(format(message, args)). }
true;static;5;6;/**  * Returns human-readable representation of HTTP/2 frame headers.  *  * <p>The format is:  *  * <pre>  *   direction streamID length type flags  * </pre>  *  * Where direction is {@code <<} for inbound and {@code >>} for outbound.  *  * <p>For example, the following would indicate a HEAD request sent from the client.  * <pre>  * {@code  *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM  * }  * </pre>  */ ;/**  * Returns human-readable representation of HTTP/2 frame headers.  *  * <p>The format is:  *  * <pre>  *   direction streamID length type flags  * </pre>  *  * Where direction is {@code <<} for inbound and {@code >>} for outbound.  *  * <p>For example, the following would indicate a HEAD request sent from the client.  * <pre>  * {@code  *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM  * }  * </pre>  */ static String frameLog(boolean inbound, int streamId, int length, byte type, byte flags) {     String formattedType = type < FRAME_NAMES.length ? FRAME_NAMES[type] : format("0x%02x", type).     String formattedFlags = formatFlags(type, flags).     return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length, formattedType, formattedFlags). }
true;static;2;21;// Visible for testing. ;/**  * Looks up valid string representing flags from the table. Invalid combinations are represented  * in binary.  */ // Visible for testing. static String formatFlags(byte type, byte flags) {     if (flags == 0)         return "".     switch(// Special case types that have 0 or 1 flag.     type) {         case TYPE_SETTINGS:         case TYPE_PING:             return flags == FLAG_ACK ? "ACK" : BINARY[flags].         case TYPE_PRIORITY:         case TYPE_RST_STREAM:         case TYPE_GOAWAY:         case TYPE_WINDOW_UPDATE:             return BINARY[flags].     }     String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags].     // Special case types that have overlap flag values.     if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {         // TODO: Avoid allocation.         return result.replace("HEADERS", "PUSH_PROMISE").     } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {         // TODO: Avoid allocation.         return result.replace("PRIORITY", "COMPRESSED").     }     return result. }
