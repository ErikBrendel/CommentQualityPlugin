commented;modifiers;parameterAmount;loc;comment;code
false;public,synchronized;0;7;;public synchronized int idleConnectionCount() {     int total = 0.     for (RealConnection connection : connections) {         if (connection.transmitters.isEmpty())             total++.     }     return total. }
false;public,synchronized;0;3;;public synchronized int connectionCount() {     return connections.size(). }
true;;4;11;/**  * Attempts to acquire a recycled connection to {@code address} for {@code transmitter}. Returns  * true if a connection was acquired.  *  * <p>If {@code routes} is non-null these are the resolved routes (ie. IP addresses) for the  * connection. This is used to coalesce related domains to the same HTTP/2 connection, such as  * {@code square.com} and {@code square.ca}.  */ ;/**  * Attempts to acquire a recycled connection to {@code address} for {@code transmitter}. Returns  * true if a connection was acquired.  *  * <p>If {@code routes} is non-null these are the resolved routes (ie. IP addresses) for the  * connection. This is used to coalesce related domains to the same HTTP/2 connection, such as  * {@code square.com} and {@code square.ca}.  */ boolean transmitterAcquirePooledConnection(Address address, Transmitter transmitter, @Nullable List<Route> routes, boolean requireMultiplexed) {     assert (Thread.holdsLock(this)).     for (RealConnection connection : connections) {         if (requireMultiplexed && !connection.isMultiplexed())             continue.         if (!connection.isEligible(address, routes))             continue.         transmitter.acquireConnectionNoEvents(connection).         return true.     }     return false. }
false;;1;8;;void put(RealConnection connection) {     assert (Thread.holdsLock(this)).     if (!cleanupRunning) {         cleanupRunning = true.         executor.execute(cleanupRunnable).     }     connections.add(connection). }
true;;1;10;/**  * Notify this pool that {@code connection} has become idle. Returns true if the connection has  * been removed from the pool and should be closed.  */ ;/**  * Notify this pool that {@code connection} has become idle. Returns true if the connection has  * been removed from the pool and should be closed.  */ boolean connectionBecameIdle(RealConnection connection) {     assert (Thread.holdsLock(this)).     if (connection.noNewExchanges || maxIdleConnections == 0) {         connections.remove(connection).         return true.     } else {         // Awake the cleanup thread: we may have exceeded the idle connection limit.         notifyAll().         return false.     } }
false;public;0;17;;public void evictAll() {     List<RealConnection> evictedConnections = new ArrayList<>().     synchronized (this) {         for (Iterator<RealConnection> i = connections.iterator(). i.hasNext(). ) {             RealConnection connection = i.next().             if (connection.transmitters.isEmpty()) {                 connection.noNewExchanges = true.                 evictedConnections.add(connection).                 i.remove().             }         }     }     for (RealConnection connection : evictedConnections) {         closeQuietly(connection.socket()).     } }
true;;1;50;/**  * Performs maintenance on this pool, evicting the connection that has been idle the longest if  * either it has exceeded the keep alive limit or the idle connections limit.  *  * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns  * -1 if no further cleanups are required.  */ ;/**  * Performs maintenance on this pool, evicting the connection that has been idle the longest if  * either it has exceeded the keep alive limit or the idle connections limit.  *  * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns  * -1 if no further cleanups are required.  */ long cleanup(long now) {     int inUseConnectionCount = 0.     int idleConnectionCount = 0.     RealConnection longestIdleConnection = null.     long longestIdleDurationNs = Long.MIN_VALUE.     // Find either a connection to evict, or the time that the next eviction is due.     synchronized (this) {         for (Iterator<RealConnection> i = connections.iterator(). i.hasNext(). ) {             RealConnection connection = i.next().             // If the connection is in use, keep searching.             if (pruneAndGetAllocationCount(connection, now) > 0) {                 inUseConnectionCount++.                 continue.             }             idleConnectionCount++.             // If the connection is ready to be evicted, we're done.             long idleDurationNs = now - connection.idleAtNanos.             if (idleDurationNs > longestIdleDurationNs) {                 longestIdleDurationNs = idleDurationNs.                 longestIdleConnection = connection.             }         }         if (longestIdleDurationNs >= this.keepAliveDurationNs || idleConnectionCount > this.maxIdleConnections) {             // We've found a connection to evict. Remove it from the list, then close it below (outside             // of the synchronized block).             connections.remove(longestIdleConnection).         } else if (idleConnectionCount > 0) {             // A connection will be ready to evict soon.             return keepAliveDurationNs - longestIdleDurationNs.         } else if (inUseConnectionCount > 0) {             // All connections are in use. It'll be at least the keep alive duration 'til we run again.             return keepAliveDurationNs.         } else {             // No connections, idle or in use.             cleanupRunning = false.             return -1.         }     }     closeQuietly(longestIdleConnection.socket()).     // Cleanup again immediately.     return 0. }
true;private;2;28;/**  * Prunes any leaked transmitters and then returns the number of remaining live transmitters on  * {@code connection}. Transmitters are leaked if the connection is tracking them but the  * application code has abandoned them. Leak detection is imprecise and relies on garbage  * collection.  */ ;/**  * Prunes any leaked transmitters and then returns the number of remaining live transmitters on  * {@code connection}. Transmitters are leaked if the connection is tracking them but the  * application code has abandoned them. Leak detection is imprecise and relies on garbage  * collection.  */ private int pruneAndGetAllocationCount(RealConnection connection, long now) {     List<Reference<Transmitter>> references = connection.transmitters.     for (int i = 0. i < references.size(). ) {         Reference<Transmitter> reference = references.get(i).         if (reference.get() != null) {             i++.             continue.         }         // We've discovered a leaked transmitter. This is an application bug.         TransmitterReference transmitterRef = (TransmitterReference) reference.         String message = "A connection to " + connection.route().address().url() + " was leaked. Did you forget to close a response body?".         Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace).         references.remove(i).         connection.noNewExchanges = true.         // If this was the last allocation, the connection is eligible for immediate eviction.         if (references.isEmpty()) {             connection.idleAtNanos = now - keepAliveDurationNs.             return 0.         }     }     return references.size(). }
true;public;2;10;/**  * Track a bad route in the route database. Other routes will be attempted first.  */ ;/**  * Track a bad route in the route database. Other routes will be attempted first.  */ public void connectFailed(Route failedRoute, IOException failure) {     // Tell the proxy selector when we fail to connect on a fresh connection.     if (failedRoute.proxy().type() != Proxy.Type.DIRECT) {         Address address = failedRoute.address().         address.proxySelector().connectFailed(address.url().uri(), failedRoute.proxy().address(), failure).     }     routeDatabase.failed(failedRoute). }
