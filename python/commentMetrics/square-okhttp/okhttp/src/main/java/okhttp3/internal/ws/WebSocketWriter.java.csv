commented;modifiers;parameterAmount;loc;comment;code
true;;1;3;/**  * Send a ping with the supplied {@code payload}.  */ ;/**  * Send a ping with the supplied {@code payload}.  */ void writePing(ByteString payload) throws IOException {     writeControlFrame(OPCODE_CONTROL_PING, payload). }
true;;1;3;/**  * Send a pong with the supplied {@code payload}.  */ ;/**  * Send a pong with the supplied {@code payload}.  */ void writePong(ByteString payload) throws IOException {     writeControlFrame(OPCODE_CONTROL_PONG, payload). }
true;;2;20;/**  * Send a close frame with optional code and reason.  *  * @param code Status code as defined by <a  * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.  * @param reason Reason for shutting down or {@code null}.  */ ;/**  * Send a close frame with optional code and reason.  *  * @param code Status code as defined by <a  * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.  * @param reason Reason for shutting down or {@code null}.  */ void writeClose(int code, ByteString reason) throws IOException {     ByteString payload = ByteString.EMPTY.     if (code != 0 || reason != null) {         if (code != 0) {             validateCloseCode(code).         }         Buffer buffer = new Buffer().         buffer.writeShort(code).         if (reason != null) {             buffer.write(reason).         }         payload = buffer.readByteString().     }     try {         writeControlFrame(OPCODE_CONTROL_CLOSE, payload).     } finally {         writerClosed = true.     } }
false;private;2;36;;private void writeControlFrame(int opcode, ByteString payload) throws IOException {     if (writerClosed)         throw new IOException("closed").     int length = payload.size().     if (length > PAYLOAD_BYTE_MAX) {         throw new IllegalArgumentException("Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX).     }     int b0 = B0_FLAG_FIN | opcode.     sinkBuffer.writeByte(b0).     int b1 = length.     if (isClient) {         b1 |= B1_FLAG_MASK.         sinkBuffer.writeByte(b1).         random.nextBytes(maskKey).         sinkBuffer.write(maskKey).         if (length > 0) {             long payloadStart = sinkBuffer.size().             sinkBuffer.write(payload).             sinkBuffer.readAndWriteUnsafe(maskCursor).             maskCursor.seek(payloadStart).             toggleMask(maskCursor, maskKey).             maskCursor.close().         }     } else {         sinkBuffer.writeByte(b1).         sinkBuffer.write(payload).     }     sink.flush(). }
true;;2;14;/**  * Stream a message payload as a series of frames. This allows control frames to be interleaved  * between parts of the message.  */ ;/**  * Stream a message payload as a series of frames. This allows control frames to be interleaved  * between parts of the message.  */ Sink newMessageSink(int formatOpcode, long contentLength) {     if (activeWriter) {         throw new IllegalStateException("Another message writer is active. Did you call close()?").     }     activeWriter = true.     // Reset FrameSink state for a new writer.     frameSink.formatOpcode = formatOpcode.     frameSink.contentLength = contentLength.     frameSink.isFirstFrame = true.     frameSink.closed = false.     return frameSink. }
false;;4;46;;void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame, boolean isFinal) throws IOException {     if (writerClosed)         throw new IOException("closed").     int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION.     if (isFinal) {         b0 |= B0_FLAG_FIN.     }     sinkBuffer.writeByte(b0).     int b1 = 0.     if (isClient) {         b1 |= B1_FLAG_MASK.     }     if (byteCount <= PAYLOAD_BYTE_MAX) {         b1 |= (int) byteCount.         sinkBuffer.writeByte(b1).     } else if (byteCount <= PAYLOAD_SHORT_MAX) {         b1 |= PAYLOAD_SHORT.         sinkBuffer.writeByte(b1).         sinkBuffer.writeShort((int) byteCount).     } else {         b1 |= PAYLOAD_LONG.         sinkBuffer.writeByte(b1).         sinkBuffer.writeLong(byteCount).     }     if (isClient) {         random.nextBytes(maskKey).         sinkBuffer.write(maskKey).         if (byteCount > 0) {             long bufferStart = sinkBuffer.size().             sinkBuffer.write(buffer, byteCount).             sinkBuffer.readAndWriteUnsafe(maskCursor).             maskCursor.seek(bufferStart).             toggleMask(maskCursor, maskKey).             maskCursor.close().         }     } else {         sinkBuffer.write(buffer, byteCount).     }     sink.emit(). }
false;public;2;16;;@Override public void write(Buffer source, long byteCount) throws IOException {     if (closed)         throw new IOException("closed").     buffer.write(source, byteCount).     // Determine if this is a buffered write which we can defer until close() flushes.     boolean deferWrite = isFirstFrame && contentLength != -1 && buffer.size() > contentLength - 8192.     long emitCount = buffer.completeSegmentByteCount().     if (emitCount > 0 && !deferWrite) {         writeMessageFrame(formatOpcode, emitCount, isFirstFrame, false).         isFirstFrame = false.     } }
false;public;0;6;;@Override public void flush() throws IOException {     if (closed)         throw new IOException("closed").     writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, false).     isFirstFrame = false. }
false;public;0;3;;@Override public Timeout timeout() {     return sink.timeout(). }
false;public;0;7;;@Override public void close() throws IOException {     if (closed)         throw new IOException("closed").     writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, true).     closed = true.     activeWriter = false. }
