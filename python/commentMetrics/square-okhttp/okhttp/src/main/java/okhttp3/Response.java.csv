commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The wire-level request that initiated this HTTP response. This is not necessarily the same  * request issued by the application:  *  * <ul>  *     <li>It may be transformed by the HTTP client. For example, the client may copy headers like  *         {@code Content-Length} from the request body.  *     <li>It may be the request generated in response to an HTTP redirect or authentication  *         challenge. In this case the request URL may be different than the initial request URL.  * </ul>  */ ;/**  * The wire-level request that initiated this HTTP response. This is not necessarily the same  * request issued by the application:  *  * <ul>  *     <li>It may be transformed by the HTTP client. For example, the client may copy headers like  *         {@code Content-Length} from the request body.  *     <li>It may be the request generated in response to an HTTP redirect or authentication  *         challenge. In this case the request URL may be different than the initial request URL.  * </ul>  */ public Request request() {     return request. }
true;public;0;3;/**  * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}.  */ ;/**  * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}.  */ public Protocol protocol() {     return protocol. }
true;public;0;3;/**  * Returns the HTTP status code.  */ ;/**  * Returns the HTTP status code.  */ public int code() {     return code. }
true;public;0;3;/**  * Returns true if the code is in [200..300), which means the request was successfully received,  * understood, and accepted.  */ ;/**  * Returns true if the code is in [200..300), which means the request was successfully received,  * understood, and accepted.  */ public boolean isSuccessful() {     return code >= 200 && code < 300. }
true;public;0;3;/**  * Returns the HTTP status message.  */ ;/**  * Returns the HTTP status message.  */ public String message() {     return message. }
true;public;0;3;/**  * Returns the TLS handshake of the connection that carried this response, or null if the response  * was received without TLS.  */ ;/**  * Returns the TLS handshake of the connection that carried this response, or null if the response  * was received without TLS.  */ @Nullable public Handshake handshake() {     return handshake. }
false;public;1;3;;public List<String> headers(String name) {     return headers.values(name). }
false;public;1;3;;@Nullable public String header(String name) {     return header(name, null). }
false;public;2;4;;@Nullable public String header(String name, @Nullable String defaultValue) {     String result = headers.get(name).     return result != null ? result : defaultValue. }
false;public;0;3;;public Headers headers() {     return headers. }
true;public;0;4;/**  * Returns the trailers after the HTTP response, which may be empty. It is an error to call this  * before the entire HTTP response body has been consumed.  */ ;/**  * Returns the trailers after the HTTP response, which may be empty. It is an error to call this  * before the entire HTTP response body has been consumed.  */ public Headers trailers() throws IOException {     if (exchange == null)         throw new IllegalStateException("trailers not available").     return exchange.trailers(). }
true;public;1;7;/**  * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response  * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is  * returned. If more than {@code byteCount} bytes are in the response body, the returned value  * will be truncated to {@code byteCount} bytes.  *  * <p>It is an error to call this method after the body has been consumed.  *  * <p><strong>Warning:</strong> this method loads the requested bytes into memory. Most  * applications should set a modest limit on {@code byteCount}, such as 1 MiB.  */ ;/**  * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response  * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is  * returned. If more than {@code byteCount} bytes are in the response body, the returned value  * will be truncated to {@code byteCount} bytes.  *  * <p>It is an error to call this method after the body has been consumed.  *  * <p><strong>Warning:</strong> this method loads the requested bytes into memory. Most  * applications should set a modest limit on {@code byteCount}, such as 1 MiB.  */ public ResponseBody peekBody(long byteCount) throws IOException {     BufferedSource peeked = body.source().peek().     Buffer buffer = new Buffer().     peeked.request(byteCount).     buffer.write(peeked, Math.min(byteCount, peeked.getBuffer().size())).     return ResponseBody.create(body.contentType(), buffer.size(), buffer). }
true;public;0;3;/**  * Returns a non-null value if this response was passed to {@link Callback#onResponse} or returned  * from {@link Call#execute()}. Response bodies must be {@linkplain ResponseBody closed} and may  * be consumed only once.  *  * <p>This always returns null on responses returned from {@link #cacheResponse}, {@link  * #networkResponse}, and {@link #priorResponse()}.  */ ;/**  * Returns a non-null value if this response was passed to {@link Callback#onResponse} or returned  * from {@link Call#execute()}. Response bodies must be {@linkplain ResponseBody closed} and may  * be consumed only once.  *  * <p>This always returns null on responses returned from {@link #cacheResponse}, {@link  * #networkResponse}, and {@link #priorResponse()}.  */ @Nullable public ResponseBody body() {     return body. }
false;public;0;3;;public Builder newBuilder() {     return new Builder(this). }
true;public;0;13;/**  * Returns true if this response redirects to another resource.  */ ;/**  * Returns true if this response redirects to another resource.  */ public boolean isRedirect() {     switch(code) {         case HTTP_PERM_REDIRECT:         case HTTP_TEMP_REDIRECT:         case HTTP_MULT_CHOICE:         case HTTP_MOVED_PERM:         case HTTP_MOVED_TEMP:         case HTTP_SEE_OTHER:             return true.         default:             return false.     } }
true;public;0;3;/**  * Returns the raw response received from the network. Will be null if this response didn't use  * the network, such as when the response is fully cached. The body of the returned response  * should not be read.  */ ;/**  * Returns the raw response received from the network. Will be null if this response didn't use  * the network, such as when the response is fully cached. The body of the returned response  * should not be read.  */ @Nullable public Response networkResponse() {     return networkResponse. }
true;public;0;3;/**  * Returns the raw response received from the cache. Will be null if this response didn't use the  * cache. For conditional get requests the cache response and network response may both be  * non-null. The body of the returned response should not be read.  */ ;/**  * Returns the raw response received from the cache. Will be null if this response didn't use the  * cache. For conditional get requests the cache response and network response may both be  * non-null. The body of the returned response should not be read.  */ @Nullable public Response cacheResponse() {     return cacheResponse. }
true;public;0;3;/**  * Returns the response for the HTTP redirect or authorization challenge that triggered this  * response, or null if this response wasn't triggered by an automatic retry. The body of the  * returned response should not be read because it has already been consumed by the redirecting  * client.  */ ;/**  * Returns the response for the HTTP redirect or authorization challenge that triggered this  * response, or null if this response wasn't triggered by an automatic retry. The body of the  * returned response should not be read because it has already been consumed by the redirecting  * client.  */ @Nullable public Response priorResponse() {     return priorResponse. }
true;public;0;11;/**  * Returns the RFC 7235 authorization challenges appropriate for this response's code. If the  * response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the  * response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.  * Otherwise this returns an empty list of challenges.  *  * <p>If a challenge uses the {@code token68} variant instead of auth params, there is exactly one  * auth param in the challenge at key {@code null}. Invalid headers and challenges are ignored.  * No semantic validation is done, for example that {@code Basic} auth must have a {@code realm}  * auth param, this is up to the caller that interprets these challenges.  */ ;/**  * Returns the RFC 7235 authorization challenges appropriate for this response's code. If the  * response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the  * response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.  * Otherwise this returns an empty list of challenges.  *  * <p>If a challenge uses the {@code token68} variant instead of auth params, there is exactly one  * auth param in the challenge at key {@code null}. Invalid headers and challenges are ignored.  * No semantic validation is done, for example that {@code Basic} auth must have a {@code realm}  * auth param, this is up to the caller that interprets these challenges.  */ public List<Challenge> challenges() {     String responseField.     if (code == HTTP_UNAUTHORIZED) {         responseField = "WWW-Authenticate".     } else if (code == HTTP_PROXY_AUTH) {         responseField = "Proxy-Authenticate".     } else {         return Collections.emptyList().     }     return HttpHeaders.parseChallenges(headers(), responseField). }
true;public;0;4;/**  * Returns the cache control directives for this response. This is never null, even if this  * response contains no {@code Cache-Control} header.  */ ;/**  * Returns the cache control directives for this response. This is never null, even if this  * response contains no {@code Cache-Control} header.  */ public CacheControl cacheControl() {     CacheControl result = cacheControl.     return result != null ? result : (cacheControl = CacheControl.parse(headers)). }
true;public;0;3;/**  * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately before OkHttp  * transmitted the initiating request over the network. If this response is being served from the  * cache then this is the timestamp of the original request.  */ ;/**  * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately before OkHttp  * transmitted the initiating request over the network. If this response is being served from the  * cache then this is the timestamp of the original request.  */ public long sentRequestAtMillis() {     return sentRequestAtMillis. }
true;public;0;3;/**  * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately after OkHttp  * received this response's headers from the network. If this response is being served from the  * cache then this is the timestamp of the original response.  */ ;/**  * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately after OkHttp  * received this response's headers from the network. If this response is being served from the  * cache then this is the timestamp of the original response.  */ public long receivedResponseAtMillis() {     return receivedResponseAtMillis. }
true;public;0;6;/**  * Closes the response body. Equivalent to {@code body().close()}.  *  * <p>It is an error to close a response that is not eligible for a body. This includes the  * responses returned from {@link #cacheResponse}, {@link #networkResponse}, and {@link  * #priorResponse()}.  */ ;/**  * Closes the response body. Equivalent to {@code body().close()}.  *  * <p>It is an error to close a response that is not eligible for a body. This includes the  * responses returned from {@link #cacheResponse}, {@link #networkResponse}, and {@link  * #priorResponse()}.  */ @Override public void close() {     if (body == null) {         throw new IllegalStateException("response is not eligible for a body and must not be closed").     }     body.close(). }
false;public;0;11;;@Override public String toString() {     return "Response{protocol=" + protocol + ", code=" + code + ", message=" + message + ", url=" + request.url() + '}'. }
false;public;1;4;;public Builder request(Request request) {     this.request = request.     return this. }
false;public;1;4;;public Builder protocol(Protocol protocol) {     this.protocol = protocol.     return this. }
false;public;1;4;;public Builder code(int code) {     this.code = code.     return this. }
false;public;1;4;;public Builder message(String message) {     this.message = message.     return this. }
false;public;1;4;;public Builder handshake(@Nullable Handshake handshake) {     this.handshake = handshake.     return this. }
true;public;2;4;/**  * Sets the header named {@code name} to {@code value}. If this request already has any headers  * with that name, they are all replaced.  */ ;/**  * Sets the header named {@code name} to {@code value}. If this request already has any headers  * with that name, they are all replaced.  */ public Builder header(String name, String value) {     headers.set(name, value).     return this. }
true;public;2;4;/**  * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued  * headers like "Set-Cookie".  */ ;/**  * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued  * headers like "Set-Cookie".  */ public Builder addHeader(String name, String value) {     headers.add(name, value).     return this. }
true;public;1;4;/**  * Removes all headers named {@code name} on this builder.  */ ;/**  * Removes all headers named {@code name} on this builder.  */ public Builder removeHeader(String name) {     headers.removeAll(name).     return this. }
true;public;1;4;/**  * Removes all headers on this builder and adds {@code headers}.  */ ;/**  * Removes all headers on this builder and adds {@code headers}.  */ public Builder headers(Headers headers) {     this.headers = headers.newBuilder().     return this. }
false;public;1;4;;public Builder body(@Nullable ResponseBody body) {     this.body = body.     return this. }
false;public;1;5;;public Builder networkResponse(@Nullable Response networkResponse) {     if (networkResponse != null)         checkSupportResponse("networkResponse", networkResponse).     this.networkResponse = networkResponse.     return this. }
false;public;1;5;;public Builder cacheResponse(@Nullable Response cacheResponse) {     if (cacheResponse != null)         checkSupportResponse("cacheResponse", cacheResponse).     this.cacheResponse = cacheResponse.     return this. }
false;private;2;11;;private void checkSupportResponse(String name, Response response) {     if (response.body != null) {         throw new IllegalArgumentException(name + ".body != null").     } else if (response.networkResponse != null) {         throw new IllegalArgumentException(name + ".networkResponse != null").     } else if (response.cacheResponse != null) {         throw new IllegalArgumentException(name + ".cacheResponse != null").     } else if (response.priorResponse != null) {         throw new IllegalArgumentException(name + ".priorResponse != null").     } }
false;public;1;5;;public Builder priorResponse(@Nullable Response priorResponse) {     if (priorResponse != null)         checkPriorResponse(priorResponse).     this.priorResponse = priorResponse.     return this. }
false;private;1;5;;private void checkPriorResponse(Response response) {     if (response.body != null) {         throw new IllegalArgumentException("priorResponse.body != null").     } }
false;public;1;4;;public Builder sentRequestAtMillis(long sentRequestAtMillis) {     this.sentRequestAtMillis = sentRequestAtMillis.     return this. }
false;public;1;4;;public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {     this.receivedResponseAtMillis = receivedResponseAtMillis.     return this. }
false;;1;3;;void initExchange(Exchange deferredTrailers) {     this.exchange = deferredTrailers. }
false;public;0;7;;public Response build() {     if (request == null)         throw new IllegalStateException("request == null").     if (protocol == null)         throw new IllegalStateException("protocol == null").     if (code < 0)         throw new IllegalStateException("code < 0: " + code).     if (message == null)         throw new IllegalStateException("message == null").     return new Response(this). }
