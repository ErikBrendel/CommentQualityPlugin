commented;modifiers;parameterAmount;loc;comment;code
true;private;0;54;// gets next attribute type: (ALPHA 1*keychar) / oid ;// gets next attribute type: (ALPHA 1*keychar) / oid private String nextAT() {     // comma or semicolon (compatibility with RFC 1779)     for (. pos < length && chars[pos] == ' '. pos++) {     }     if (pos == length) {         // reached the end of DN         return null.     }     // mark the beginning of attribute type     beg = pos.     // attribute type chars     pos++.     for (. pos < length && chars[pos] != '=' && chars[pos] != ' '. pos++) {     // we don't follow exact BNF syntax here:     // accept any char except space and '='     }     if (pos >= length) {         throw new IllegalStateException("Unexpected end of DN: " + dn).     }     // mark the end of attribute type     end = pos.     // (compatibility with RFC 1779)     if (chars[pos] == ' ') {         for (. pos < length && chars[pos] != '=' && chars[pos] == ' '. pos++) {         }         if (chars[pos] != '=' || pos == length) {             throw new IllegalStateException("Unexpected end of DN: " + dn).         }     }     // skip '=' char     pos++.     // (compatibility with RFC 1779)     for (. pos < length && chars[pos] == ' '. pos++) {     }     // (compatibility with RFC 1779)     if ((end - beg > 4) && (chars[beg + 3] == '.') && (chars[beg] == 'O' || chars[beg] == 'o') && (chars[beg + 1] == 'I' || chars[beg + 1] == 'i') && (chars[beg + 2] == 'D' || chars[beg + 2] == 'd')) {         beg += 4.     }     return new String(chars, beg, end - beg). }
true;private;0;31;// gets quoted attribute value: QUOTATION *( quotechar / pair ) QUOTATION ;// gets quoted attribute value: QUOTATION *( quotechar / pair ) QUOTATION private String quotedAV() {     pos++.     beg = pos.     end = beg.     while (true) {         if (pos == length) {             throw new IllegalStateException("Unexpected end of DN: " + dn).         }         if (chars[pos] == '"') {             // enclosing quotation was found             pos++.             break.         } else if (chars[pos] == '\\') {             chars[end] = getEscaped().         } else {             // shift char: required for string with escaped chars             chars[end] = chars[pos].         }         pos++.         end++.     }     // (compatibility with RFC 1779)     for (. pos < length && chars[pos] == ' '. pos++) {     }     return new String(chars, beg, end - beg). }
true;private;0;48;// gets hex string attribute value: "#" hexstring ;// gets hex string attribute value: "#" hexstring private String hexAV() {     if (pos + 4 >= length) {         // encoded byte array  must be not less then 4 c         throw new IllegalStateException("Unexpected end of DN: " + dn).     }     // store '#' position     beg = pos.     pos++.     while (true) {         // looks for space and component separators         if (pos == length || chars[pos] == '+' || chars[pos] == ',' || chars[pos] == '.') {             end = pos.             break.         }         if (chars[pos] == ' ') {             end = pos.             pos++.             // (compatibility with RFC 1779)             for (. pos < length && chars[pos] == ' '. pos++) {             }             break.         } else if (chars[pos] >= 'A' && chars[pos] <= 'F') {             // to low case             chars[pos] += 32.         }         pos++.     }     // verify length of hex string     // encoded byte array  must be not less then 4 and must be even number     // skip first '#' char     int hexLen = end - beg.     if (hexLen < 5 || (hexLen & 1) == 0) {         throw new IllegalStateException("Unexpected end of DN: " + dn).     }     // get byte encoding from string representation     byte[] encoded = new byte[hexLen / 2].     for (int i = 0, p = beg + 1. i < encoded.length. p += 2, i++) {         encoded[i] = (byte) getByte(p).     }     return new String(chars, beg, hexLen). }
true;private;0;43;// gets string attribute value: *( stringchar / pair ) ;// gets string attribute value: *( stringchar / pair ) private String escapedAV() {     beg = pos.     end = pos.     while (true) {         if (pos >= length) {             // the end of DN has been found             return new String(chars, beg, end - beg).         }         switch(chars[pos]) {             case '+':             case ',':             case '.':                 // separator char has been found                 return new String(chars, beg, end - beg).             case '\\':                 // escaped char                 chars[end++] = getEscaped().                 pos++.                 break.             case ' ':                 // need to figure out whether space defines                 // the end of attribute value or not                 cur = end.                 pos++.                 chars[end++] = ' '.                 for (. pos < length && chars[pos] == ' '. pos++) {                     chars[end++] = ' '.                 }                 if (pos == length || chars[pos] == ',' || chars[pos] == '+' || chars[pos] == '.') {                     // separator char or the end of DN has been found                     return new String(chars, beg, cur - beg).                 }                 break.             default:                 chars[end++] = chars[pos].                 pos++.         }     } }
true;private;0;28;// returns escaped char ;// returns escaped char private char getEscaped() {     pos++.     if (pos == length) {         throw new IllegalStateException("Unexpected end of DN: " + dn).     }     switch(chars[pos]) {         case '"':         case '\\':         case ',':         case '=':         case '+':         case '<':         case '>':         case '#':         case '.':         case ' ':         case '*':         case '%':         case '_':             // FIXME: escaping is allowed only for leading or trailing space char             return chars[pos].         default:             // interpreted as UTF-8 char. It only contains an example of such DN.             return getUTF8().     } }
true;private;0;41;// see http://www.unicode.org for UTF-8 bit distribution table ;// decodes UTF-8 char // see http://www.unicode.org for UTF-8 bit distribution table private char getUTF8() {     int res = getByte(pos).     // FIXME tmp     pos++.     if (res < 128) {         // one byte: 0-7F         return (char) res.     } else if (res >= 192 && res <= 247) {         int count.         if (res <= 223) {             // two bytes: C0-DF             count = 1.             res = res & 0x1F.         } else if (res <= 239) {             // three bytes: E0-EF             count = 2.             res = res & 0x0F.         } else {             // four bytes: F0-F7             count = 3.             res = res & 0x07.         }         int b.         for (int i = 0. i < count. i++) {             pos++.             if (pos == length || chars[pos] != '\\') {                 // FIXME failed to decode UTF-8 char - return '?'                 return 0x3F.             }             pos++.             b = getByte(pos).             // FIXME tmp             pos++.             if ((b & 0xC0) != 0x80) {                 // FIXME failed to decode UTF-8 char - return '?'                 return 0x3F.             }             res = (res << 6) + (b & 0x3F).         }         return (char) res.     } else {         // FIXME failed to decode UTF-8 char - return '?'         return 0x3F.     } }
true;private;1;31;// / "a" / "b" / "c" / "d" / "e" / "f" ;// Returns byte representation of a char pair // The char pair is composed of DN char in // specified 'position' and the next char // According to BNF syntax: // hexchar    = DIGIT / "A" / "B" / "C" / "D" / "E" / "F" // / "a" / "b" / "c" / "d" / "e" / "f" private int getByte(int position) {     if (position + 1 >= length) {         throw new IllegalStateException("Malformed DN: " + dn).     }     int b1, b2.     b1 = chars[position].     if (b1 >= '0' && b1 <= '9') {         b1 = b1 - '0'.     } else if (b1 >= 'a' && b1 <= 'f') {         // 87 = 'a' - 10         b1 = b1 - 87.     } else if (b1 >= 'A' && b1 <= 'F') {         // 55 = 'A' - 10         b1 = b1 - 55.     } else {         throw new IllegalStateException("Malformed DN: " + dn).     }     b2 = chars[position + 1].     if (b2 >= '0' && b2 <= '9') {         b2 = b2 - '0'.     } else if (b2 >= 'a' && b2 <= 'f') {         // 87 = 'a' - 10         b2 = b2 - 87.     } else if (b2 >= 'A' && b2 <= 'F') {         // 55 = 'A' - 10         b2 = b2 - 55.     } else {         throw new IllegalStateException("Malformed DN: " + dn).     }     return (b1 << 4) + b2. }
true;public;1;58;/**  * Parses the DN and returns the most significant attribute value for an attribute type, or null  * if none found.  *  * @param attributeType attribute type to look for (e.g. "ca")  */ ;/**  * Parses the DN and returns the most significant attribute value for an attribute type, or null  * if none found.  *  * @param attributeType attribute type to look for (e.g. "ca")  */ public String findMostSpecific(String attributeType) {     // Initialize internal state.     pos = 0.     beg = 0.     end = 0.     cur = 0.     chars = dn.toCharArray().     String attType = nextAT().     if (attType == null) {         return null.     }     while (true) {         String attValue = "".         if (pos == length) {             return null.         }         switch(chars[pos]) {             case '"':                 attValue = quotedAV().                 break.             case '#':                 attValue = hexAV().                 break.             case '+':             case ',':             case // compatibility with RFC 1779: semicolon can separate RDNs             '.':                 // empty attribute value                 break.             default:                 attValue = escapedAV().         }         // we see.         if (attributeType.equalsIgnoreCase(attType)) {             return attValue.         }         if (pos >= length) {             return null.         }         if (chars[pos] == ',' || chars[pos] == '.') {         } else if (chars[pos] != '+') {             throw new IllegalStateException("Malformed DN: " + dn).         }         pos++.         attType = nextAT().         if (attType == null) {             throw new IllegalStateException("Malformed DN: " + dn).         }     } }
