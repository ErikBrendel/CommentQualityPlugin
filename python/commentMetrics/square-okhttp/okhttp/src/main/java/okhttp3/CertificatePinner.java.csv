commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public boolean equals(@Nullable Object other) {     if (other == this)         return true.     return other instanceof CertificatePinner && (Objects.equals(certificateChainCleaner, ((CertificatePinner) other).certificateChainCleaner) && pins.equals(((CertificatePinner) other).pins)). }
false;public;0;5;;@Override public int hashCode() {     int result = Objects.hashCode(certificateChainCleaner).     result = 31 * result + pins.hashCode().     return result. }
true;public;2;46;/**  * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code  * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.  * OkHttp calls this after a successful TLS handshake, but before the connection is used.  *  * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match the certificates  * pinned for {@code hostname}.  */ ;/**  * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code  * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.  * OkHttp calls this after a successful TLS handshake, but before the connection is used.  *  * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match the certificates  * pinned for {@code hostname}.  */ public void check(String hostname, List<Certificate> peerCertificates) throws SSLPeerUnverifiedException {     List<Pin> pins = findMatchingPins(hostname).     if (pins.isEmpty())         return.     if (certificateChainCleaner != null) {         peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname).     }     for (int c = 0, certsSize = peerCertificates.size(). c < certsSize. c++) {         X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c).         // Lazily compute the hashes for each certificate.         ByteString sha1 = null.         ByteString sha256 = null.         for (int p = 0, pinsSize = pins.size(). p < pinsSize. p++) {             Pin pin = pins.get(p).             if (pin.hashAlgorithm.equals("sha256/")) {                 if (sha256 == null)                     sha256 = sha256(x509Certificate).                 // Success!                 if (pin.hash.equals(sha256))                     return.             } else if (pin.hashAlgorithm.equals("sha1/")) {                 if (sha1 == null)                     sha1 = sha1(x509Certificate).                 // Success!                 if (pin.hash.equals(sha1))                     return.             } else {                 throw new AssertionError("unsupported hashAlgorithm: " + pin.hashAlgorithm).             }         }     }     // If we couldn't find a matching pin, format a nice exception.     StringBuilder message = new StringBuilder().append("Certificate pinning failure!").append("\n  Peer certificate chain:").     for (int c = 0, certsSize = peerCertificates.size(). c < certsSize. c++) {         X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c).         message.append("\n    ").append(pin(x509Certificate)).append(": ").append(x509Certificate.getSubjectDN().getName()).     }     message.append("\n  Pinned certificates for ").append(hostname).append(":").     for (int p = 0, pinsSize = pins.size(). p < pinsSize. p++) {         Pin pin = pins.get(p).         message.append("\n    ").append(pin).     }     throw new SSLPeerUnverifiedException(message.toString()). }
true;public;2;4;/**  * @deprecated replaced with {@link #check(String, List)}.  */ ;/**  * @deprecated replaced with {@link #check(String, List)}.  */ public void check(String hostname, Certificate... peerCertificates) throws SSLPeerUnverifiedException {     check(hostname, Arrays.asList(peerCertificates)). }
true;;1;10;/**  * Returns list of matching certificates' pins for the hostname. Returns an empty list if the  * hostname does not have pinned certificates.  */ ;/**  * Returns list of matching certificates' pins for the hostname. Returns an empty list if the  * hostname does not have pinned certificates.  */ List<Pin> findMatchingPins(String hostname) {     List<Pin> result = Collections.emptyList().     for (Pin pin : pins) {         if (pin.matches(hostname)) {             if (result.isEmpty())                 result = new ArrayList<>().             result.add(pin).         }     }     return result. }
true;;1;6;/**  * Returns a certificate pinner that uses {@code certificateChainCleaner}.  */ ;/**  * Returns a certificate pinner that uses {@code certificateChainCleaner}.  */ CertificatePinner withCertificateChainCleaner(@Nullable CertificateChainCleaner certificateChainCleaner) {     return Objects.equals(this.certificateChainCleaner, certificateChainCleaner) ? this : new CertificatePinner(pins, certificateChainCleaner). }
true;public,static;1;6;/**  * Returns the SHA-256 of {@code certificate}'s public key.  *  * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are  * supported, but SHA-256 is preferred.  */ ;/**  * Returns the SHA-256 of {@code certificate}'s public key.  *  * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are  * supported, but SHA-256 is preferred.  */ public static String pin(Certificate certificate) {     if (!(certificate instanceof X509Certificate)) {         throw new IllegalArgumentException("Certificate pinning requires X509 certificates").     }     return "sha256/" + sha256((X509Certificate) certificate).base64(). }
false;static;1;3;;static ByteString sha1(X509Certificate x509Certificate) {     return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha1(). }
false;static;1;3;;static ByteString sha256(X509Certificate x509Certificate) {     return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha256(). }
false;;1;10;;boolean matches(String hostname) {     if (pattern.startsWith(WILDCARD)) {         int firstDot = hostname.indexOf('.').         return (hostname.length() - firstDot - 1) == canonicalHostname.length() && hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0, canonicalHostname.length()).     }     return hostname.equals(canonicalHostname). }
false;public;1;6;;@Override public boolean equals(Object other) {     return other instanceof Pin && pattern.equals(((Pin) other).pattern) && hashAlgorithm.equals(((Pin) other).hashAlgorithm) && hash.equals(((Pin) other).hash). }
false;public;0;7;;@Override public int hashCode() {     int result = 17.     result = 31 * result + pattern.hashCode().     result = 31 * result + hashAlgorithm.hashCode().     result = 31 * result + hash.hashCode().     return result. }
false;public;0;3;;@Override public String toString() {     return hashAlgorithm + hash.base64(). }
true;public;2;9;/**  * Pins certificates for {@code pattern}.  *  * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.  * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key  * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.  */ ;/**  * Pins certificates for {@code pattern}.  *  * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.  * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key  * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.  */ public Builder add(String pattern, String... pins) {     if (pattern == null)         throw new NullPointerException("pattern == null").     for (String pin : pins) {         this.pins.add(new Pin(pattern, pin)).     }     return this. }
false;public;0;3;;public CertificatePinner build() {     return new CertificatePinner(new LinkedHashSet<>(pins), null). }
