commented;modifiers;parameterAmount;loc;comment;code
false;public;3;20;;public ExchangeCodec find(OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {     int connectTimeout = chain.connectTimeoutMillis().     int readTimeout = chain.readTimeoutMillis().     int writeTimeout = chain.writeTimeoutMillis().     int pingIntervalMillis = client.pingIntervalMillis().     boolean connectionRetryEnabled = client.retryOnConnectionFailure().     try {         RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks).         return resultConnection.newCodec(client, chain).     } catch (RouteException e) {         trackFailure().         throw e.     } catch (IOException e) {         trackFailure().         throw new RouteException(e).     } }
true;private;6;24;/**  * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated  * until a healthy connection is found.  */ ;/**  * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated  * until a healthy connection is found.  */ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException {     while (true) {         RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled).         // If this is a brand new connection, we can skip the extensive health checks.         synchronized (connectionPool) {             if (candidate.successCount == 0) {                 return candidate.             }         }         // isn't, take it out of the pool and start again.         if (!candidate.isHealthy(doExtensiveHealthChecks)) {             candidate.noNewExchanges().             continue.         }         return candidate.     } }
true;private;5;116;/**  * Returns a connection to host a new stream. This prefers the existing connection if it exists,  * then the pool, finally building a new connection.  */ ;/**  * Returns a connection to host a new stream. This prefers the existing connection if it exists,  * then the pool, finally building a new connection.  */ private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {     boolean foundPooledConnection = false.     RealConnection result = null.     Route selectedRoute = null.     RealConnection releasedConnection.     Socket toClose.     synchronized (connectionPool) {         if (transmitter.isCanceled())             throw new IOException("Canceled").         // This is a fresh attempt.         hasStreamFailure = false.         Route previousRoute = retryCurrentRoute() ? transmitter.connection.route() : null.         // Attempt to use an already-allocated connection. We need to be careful here because our         // already-allocated connection may have been restricted from creating new exchanges.         releasedConnection = transmitter.connection.         toClose = transmitter.connection != null && transmitter.connection.noNewExchanges ? transmitter.releaseConnectionNoEvents() : null.         if (transmitter.connection != null) {             // We had an already-allocated connection and it's good.             result = transmitter.connection.             releasedConnection = null.         }         if (result == null) {             // Attempt to get a connection from the pool.             if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {                 foundPooledConnection = true.                 result = transmitter.connection.             } else {                 selectedRoute = previousRoute.             }         }     }     closeQuietly(toClose).     if (releasedConnection != null) {         eventListener.connectionReleased(call, releasedConnection).     }     if (foundPooledConnection) {         eventListener.connectionAcquired(call, result).     }     if (result != null) {         // If we found an already-allocated or pooled connection, we're done.         return result.     }     // If we need a route selection, make one. This is a blocking operation.     boolean newRouteSelection = false.     if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {         newRouteSelection = true.         routeSelection = routeSelector.next().     }     List<Route> routes = null.     synchronized (connectionPool) {         if (transmitter.isCanceled())             throw new IOException("Canceled").         if (newRouteSelection) {             // Now that we have a set of IP addresses, make another attempt at getting a connection from             // the pool. This could match due to connection coalescing.             routes = routeSelection.getAll().             if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, false)) {                 foundPooledConnection = true.                 result = transmitter.connection.             }         }         if (!foundPooledConnection) {             if (selectedRoute == null) {                 selectedRoute = routeSelection.next().             }             // Create a connection and assign it to this allocation immediately. This makes it possible             // for an asynchronous cancel() to interrupt the handshake we're about to do.             result = new RealConnection(connectionPool, selectedRoute).             connectingConnection = result.         }     }     // If we found a pooled connection on the 2nd time around, we're done.     if (foundPooledConnection) {         eventListener.connectionAcquired(call, result).         return result.     }     // Do TCP + TLS handshakes. This is a blocking operation.     result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener).     connectionPool.routeDatabase.connected(result.route()).     Socket socket = null.     synchronized (connectionPool) {         connectingConnection = null.         // concurrent connections to the same host.         if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {             // We lost the race! Close the connection we created and return the pooled connection.             result.noNewExchanges = true.             socket = result.socket().             result = transmitter.connection.         } else {             connectionPool.put(result).             transmitter.acquireConnectionNoEvents(result).         }     }     closeQuietly(socket).     eventListener.connectionAcquired(call, result).     return result. }
false;;0;4;;RealConnection connectingConnection() {     assert (Thread.holdsLock(connectionPool)).     return connectingConnection. }
false;;0;6;;void trackFailure() {     assert (!Thread.holdsLock(connectionPool)).     synchronized (connectionPool) {         // Permit retries.         hasStreamFailure = true.     } }
false;;0;10;;boolean canRetry() {     synchronized (connectionPool) {         // Don't try if the failure wasn't our fault!         if (!hasStreamFailure)             return false.         return retryCurrentRoute() || (routeSelection != null && routeSelection.hasNext()) || routeSelector.hasNext().     } }
true;private;0;5;/**  * Return true if the route used for the current connection should be retried, even if the  * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from  * coalesced connections.  */ ;/**  * Return true if the route used for the current connection should be retried, even if the  * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from  * coalesced connections.  */ private boolean retryCurrentRoute() {     return transmitter.connection != null && transmitter.connection.routeFailureCount == 0 && Util.sameConnection(transmitter.connection.route().address().url(), address.url()). }
