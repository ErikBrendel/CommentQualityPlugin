commented;modifiers;parameterAmount;loc;comment;code
false;public,synchronized;0;7;;public synchronized ExecutorService executorService() {     if (executorService == null) {         executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<>(), Util.threadFactory("OkHttp Dispatcher", false)).     }     return executorService. }
true;public;1;9;/**  * Set the maximum number of requests to execute concurrently. Above this requests queue in  * memory, waiting for the running calls to complete.  *  * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests  * will remain in flight.  */ ;/**  * Set the maximum number of requests to execute concurrently. Above this requests queue in  * memory, waiting for the running calls to complete.  *  * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests  * will remain in flight.  */ public void setMaxRequests(int maxRequests) {     if (maxRequests < 1) {         throw new IllegalArgumentException("max < 1: " + maxRequests).     }     synchronized (this) {         this.maxRequests = maxRequests.     }     promoteAndExecute(). }
false;public,synchronized;0;3;;public synchronized int getMaxRequests() {     return maxRequests. }
true;public;1;9;/**  * Set the maximum number of requests for each host to execute concurrently. This limits requests  * by the URL's host name. Note that concurrent requests to a single IP address may still exceed  * this limit: multiple hostnames may share an IP address or be routed through the same HTTP  * proxy.  *  * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those  * requests will remain in flight.  *  * <p>WebSocket connections to hosts <b>do not</b> count against this limit.  */ ;/**  * Set the maximum number of requests for each host to execute concurrently. This limits requests  * by the URL's host name. Note that concurrent requests to a single IP address may still exceed  * this limit: multiple hostnames may share an IP address or be routed through the same HTTP  * proxy.  *  * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those  * requests will remain in flight.  *  * <p>WebSocket connections to hosts <b>do not</b> count against this limit.  */ public void setMaxRequestsPerHost(int maxRequestsPerHost) {     if (maxRequestsPerHost < 1) {         throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost).     }     synchronized (this) {         this.maxRequestsPerHost = maxRequestsPerHost.     }     promoteAndExecute(). }
false;public,synchronized;0;3;;public synchronized int getMaxRequestsPerHost() {     return maxRequestsPerHost. }
true;public,synchronized;1;3;/**  * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running  * calls returns to zero).  *  * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending  * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or  * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the  * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has  * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This  * means that if you are doing synchronous calls the network layer will not truly be idle until  * every returned {@link Response} has been closed.  */ ;/**  * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running  * calls returns to zero).  *  * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending  * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or  * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the  * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has  * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This  * means that if you are doing synchronous calls the network layer will not truly be idle until  * every returned {@link Response} has been closed.  */ public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {     this.idleCallback = idleCallback. }
false;;1;13;;void enqueue(AsyncCall call) {     synchronized (this) {         readyAsyncCalls.add(call).         // the same host.         if (!call.get().forWebSocket) {             AsyncCall existingCall = findExistingCallWithHost(call.host()).             if (existingCall != null)                 call.reuseCallsPerHostFrom(existingCall).         }     }     promoteAndExecute(). }
false;private;1;9;;@Nullable private AsyncCall findExistingCallWithHost(String host) {     for (AsyncCall existingCall : runningAsyncCalls) {         if (existingCall.host().equals(host))             return existingCall.     }     for (AsyncCall existingCall : readyAsyncCalls) {         if (existingCall.host().equals(host))             return existingCall.     }     return null. }
true;public,synchronized;0;13;/**  * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain  * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.  */ ;/**  * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain  * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.  */ public synchronized void cancelAll() {     for (AsyncCall call : readyAsyncCalls) {         call.get().cancel().     }     for (AsyncCall call : runningAsyncCalls) {         call.get().cancel().     }     for (RealCall call : runningSyncCalls) {         call.cancel().     } }
true;private;0;27;/**  * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs  * them on the executor service. Must not be called with synchronization because executing calls  * can call into user code.  *  * @return true if the dispatcher is currently running calls.  */ ;/**  * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs  * them on the executor service. Must not be called with synchronization because executing calls  * can call into user code.  *  * @return true if the dispatcher is currently running calls.  */ private boolean promoteAndExecute() {     assert (!Thread.holdsLock(this)).     List<AsyncCall> executableCalls = new ArrayList<>().     boolean isRunning.     synchronized (this) {         for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(). i.hasNext(). ) {             AsyncCall asyncCall = i.next().             // Max capacity.             if (runningAsyncCalls.size() >= maxRequests)                 break.             // Host max capacity.             if (asyncCall.callsPerHost().get() >= maxRequestsPerHost)                 continue.             i.remove().             asyncCall.callsPerHost().incrementAndGet().             executableCalls.add(asyncCall).             runningAsyncCalls.add(asyncCall).         }         isRunning = runningCallsCount() > 0.     }     for (int i = 0, size = executableCalls.size(). i < size. i++) {         AsyncCall asyncCall = executableCalls.get(i).         asyncCall.executeOn(executorService()).     }     return isRunning. }
true;synchronized;1;3;/**  * Used by {@code Call#execute} to signal it is in-flight.  */ ;/**  * Used by {@code Call#execute} to signal it is in-flight.  */ synchronized void executed(RealCall call) {     runningSyncCalls.add(call). }
true;;1;4;/**  * Used by {@code AsyncCall#run} to signal completion.  */ ;/**  * Used by {@code AsyncCall#run} to signal completion.  */ void finished(AsyncCall call) {     call.callsPerHost().decrementAndGet().     finished(runningAsyncCalls, call). }
true;;1;3;/**  * Used by {@code Call#execute} to signal completion.  */ ;/**  * Used by {@code Call#execute} to signal completion.  */ void finished(RealCall call) {     finished(runningSyncCalls, call). }
false;private;2;13;;private <T> void finished(Deque<T> calls, T call) {     Runnable idleCallback.     synchronized (this) {         if (!calls.remove(call))             throw new AssertionError("Call wasn't in-flight!").         idleCallback = this.idleCallback.     }     boolean isRunning = promoteAndExecute().     if (!isRunning && idleCallback != null) {         idleCallback.run().     } }
true;public,synchronized;0;7;/**  * Returns a snapshot of the calls currently awaiting execution.  */ ;/**  * Returns a snapshot of the calls currently awaiting execution.  */ public synchronized List<Call> queuedCalls() {     List<Call> result = new ArrayList<>().     for (AsyncCall asyncCall : readyAsyncCalls) {         result.add(asyncCall.get()).     }     return Collections.unmodifiableList(result). }
true;public,synchronized;0;8;/**  * Returns a snapshot of the calls currently being executed.  */ ;/**  * Returns a snapshot of the calls currently being executed.  */ public synchronized List<Call> runningCalls() {     List<Call> result = new ArrayList<>().     result.addAll(runningSyncCalls).     for (AsyncCall asyncCall : runningAsyncCalls) {         result.add(asyncCall.get()).     }     return Collections.unmodifiableList(result). }
false;public,synchronized;0;3;;public synchronized int queuedCallsCount() {     return readyAsyncCalls.size(). }
false;public,synchronized;0;3;;public synchronized int runningCallsCount() {     return runningAsyncCalls.size() + runningSyncCalls.size(). }
