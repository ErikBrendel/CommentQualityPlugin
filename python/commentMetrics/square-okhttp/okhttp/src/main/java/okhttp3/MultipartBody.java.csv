commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public MediaType type() {     return originalType. }
false;public;0;3;;public String boundary() {     return boundary.utf8(). }
true;public;0;3;/**  * The number of parts in this multipart body.  */ ;/**  * The number of parts in this multipart body.  */ public int size() {     return parts.size(). }
false;public;0;3;;public List<Part> parts() {     return parts. }
false;public;1;3;;public Part part(int index) {     return parts.get(index). }
true;public;0;3;/**  * A combination of {@link #type()} and {@link #boundary()}.  */ ;/**  * A combination of {@link #type()} and {@link #boundary()}.  */ @Override public MediaType contentType() {     return contentType. }
false;public;0;5;;@Override public long contentLength() throws IOException {     long result = contentLength.     if (result != -1L)         return result.     return contentLength = writeOrCountBytes(null, true). }
false;public;1;3;;@Override public void writeTo(BufferedSink sink) throws IOException {     writeOrCountBytes(sink, false). }
true;private;2;68;/**  * Either writes this request to {@code sink} or measures its content length. We have one method  * do double-duty to make sure the counting and content are consistent, particularly when it comes  * to awkward operations like measuring the encoded length of header strings, or the  * length-in-digits of an encoded integer.  */ ;/**  * Either writes this request to {@code sink} or measures its content length. We have one method  * do double-duty to make sure the counting and content are consistent, particularly when it comes  * to awkward operations like measuring the encoded length of header strings, or the  * length-in-digits of an encoded integer.  */ private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) throws IOException {     long byteCount = 0L.     Buffer byteCountBuffer = null.     if (countBytes) {         sink = byteCountBuffer = new Buffer().     }     for (int p = 0, partCount = parts.size(). p < partCount. p++) {         Part part = parts.get(p).         Headers headers = part.headers.         RequestBody body = part.body.         sink.write(DASHDASH).         sink.write(boundary).         sink.write(CRLF).         if (headers != null) {             for (int h = 0, headerCount = headers.size(). h < headerCount. h++) {                 sink.writeUtf8(headers.name(h)).write(COLONSPACE).writeUtf8(headers.value(h)).write(CRLF).             }         }         MediaType contentType = body.contentType().         if (contentType != null) {             sink.writeUtf8("Content-Type: ").writeUtf8(contentType.toString()).write(CRLF).         }         long contentLength = body.contentLength().         if (contentLength != -1) {             sink.writeUtf8("Content-Length: ").writeDecimalLong(contentLength).write(CRLF).         } else if (countBytes) {             // We can't measure the body's size without the sizes of its components.             byteCountBuffer.clear().             return -1L.         }         sink.write(CRLF).         if (countBytes) {             byteCount += contentLength.         } else {             body.writeTo(sink).         }         sink.write(CRLF).     }     sink.write(DASHDASH).     sink.write(boundary).     sink.write(DASHDASH).     sink.write(CRLF).     if (countBytes) {         byteCount += byteCountBuffer.size().         byteCountBuffer.clear().     }     return byteCount. }
true;static;2;21;/**  * Appends a quoted-string to a StringBuilder.  *  * <p>RFC 2388 is rather vague about how one should escape special characters in form-data  * parameters, and as it turns out Firefox and Chrome actually do rather different things, and  * both say in their comments that they're not really sure what the right approach is. We go with  * Chrome's behavior (which also experimentally seems to match what IE does), but if you actually  * want to have a good chance of things working, please avoid double-quotes, newlines, percent  * signs, and the like in your field names.  */ ;/**  * Appends a quoted-string to a StringBuilder.  *  * <p>RFC 2388 is rather vague about how one should escape special characters in form-data  * parameters, and as it turns out Firefox and Chrome actually do rather different things, and  * both say in their comments that they're not really sure what the right approach is. We go with  * Chrome's behavior (which also experimentally seems to match what IE does), but if you actually  * want to have a good chance of things working, please avoid double-quotes, newlines, percent  * signs, and the like in your field names.  */ static void appendQuotedString(StringBuilder target, String key) {     target.append('"').     for (int i = 0, len = key.length(). i < len. i++) {         char ch = key.charAt(i).         switch(ch) {             case '\n':                 target.append("%0A").                 break.             case '\r':                 target.append("%0D").                 break.             case '"':                 target.append("%22").                 break.             default:                 target.append(ch).                 break.         }     }     target.append('"'). }
false;public,static;1;3;;public static Part create(RequestBody body) {     return create(null, body). }
false;public,static;2;12;;public static Part create(@Nullable Headers headers, RequestBody body) {     if (body == null) {         throw new NullPointerException("body == null").     }     if (headers != null && headers.get("Content-Type") != null) {         throw new IllegalArgumentException("Unexpected header: Content-Type").     }     if (headers != null && headers.get("Content-Length") != null) {         throw new IllegalArgumentException("Unexpected header: Content-Length").     }     return new Part(headers, body). }
false;public,static;2;3;;public static Part createFormData(String name, String value) {     return createFormData(name, null, RequestBody.create(null, value)). }
false;public,static;3;18;;public static Part createFormData(String name, @Nullable String filename, RequestBody body) {     if (name == null) {         throw new NullPointerException("name == null").     }     StringBuilder disposition = new StringBuilder("form-data. name=").     appendQuotedString(disposition, name).     if (filename != null) {         disposition.append(". filename=").         appendQuotedString(disposition, filename).     }     Headers headers = new Headers.Builder().addUnsafeNonAscii("Content-Disposition", disposition.toString()).build().     return create(headers, body). }
false;public;0;3;;@Nullable public Headers headers() {     return headers. }
false;public;0;3;;public RequestBody body() {     return body. }
true;public;1;10;/**  * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the default), {@link  * #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and {@link #FORM}.  */ ;/**  * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the default), {@link  * #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and {@link #FORM}.  */ public Builder setType(MediaType type) {     if (type == null) {         throw new NullPointerException("type == null").     }     if (!type.type().equals("multipart")) {         throw new IllegalArgumentException("multipart != " + type).     }     this.type = type.     return this. }
true;public;1;3;/**  * Add a part to the body.  */ ;/**  * Add a part to the body.  */ public Builder addPart(RequestBody body) {     return addPart(Part.create(body)). }
true;public;2;3;/**  * Add a part to the body.  */ ;/**  * Add a part to the body.  */ public Builder addPart(@Nullable Headers headers, RequestBody body) {     return addPart(Part.create(headers, body)). }
true;public;2;3;/**  * Add a form data part to the body.  */ ;/**  * Add a form data part to the body.  */ public Builder addFormDataPart(String name, String value) {     return addPart(Part.createFormData(name, value)). }
true;public;3;3;/**  * Add a form data part to the body.  */ ;/**  * Add a form data part to the body.  */ public Builder addFormDataPart(String name, @Nullable String filename, RequestBody body) {     return addPart(Part.createFormData(name, filename, body)). }
true;public;1;5;/**  * Add a part to the body.  */ ;/**  * Add a part to the body.  */ public Builder addPart(Part part) {     if (part == null)         throw new NullPointerException("part == null").     parts.add(part).     return this. }
true;public;0;6;/**  * Assemble the specified parts into a request body.  */ ;/**  * Assemble the specified parts into a request body.  */ public MultipartBody build() {     if (parts.isEmpty()) {         throw new IllegalStateException("Multipart body must have at least one part.").     }     return new MultipartBody(boundary, type, parts). }
