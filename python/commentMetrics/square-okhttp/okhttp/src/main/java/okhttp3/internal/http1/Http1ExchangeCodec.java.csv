commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;@Override public RealConnection connection() {     return realConnection. }
false;public;2;18;;@Override public Sink createRequestBody(Request request, long contentLength) throws IOException {     if (request.body() != null && request.body().isDuplex()) {         throw new ProtocolException("Duplex connections are not supported for HTTP/1").     }     if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {         // Stream a request body of unknown length.         return newChunkedSink().     }     if (contentLength != -1L) {         // Stream a request body of a known length.         return newKnownLengthSink().     }     throw new IllegalStateException("Cannot stream a request body without chunked encoding or a known content length!"). }
false;public;0;3;;@Override public void cancel() {     if (realConnection != null)         realConnection.cancel(). }
true;public;1;5;/**  * Prepares the HTTP headers and sends them to the server.  *  * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the  * output stream has been written to. Otherwise the body would need to be buffered!  *  * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the  * output stream has been written to and closed. This ensures that the {@code Content-Length}  * header field receives the proper value.  */ ;/**  * Prepares the HTTP headers and sends them to the server.  *  * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the  * output stream has been written to. Otherwise the body would need to be buffered!  *  * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the  * output stream has been written to and closed. This ensures that the {@code Content-Length}  * header field receives the proper value.  */ @Override public void writeRequestHeaders(Request request) throws IOException {     String requestLine = RequestLine.get(request, realConnection.route().proxy().type()).     writeRequest(request.headers(), requestLine). }
false;public;1;11;;@Override public long reportedContentLength(Response response) {     if (!HttpHeaders.hasBody(response)) {         return 0L.     }     if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {         return -1L.     }     return HttpHeaders.contentLength(response). }
false;public;1;16;;@Override public Source openResponseBodySource(Response response) {     if (!HttpHeaders.hasBody(response)) {         return newFixedLengthSource(0).     }     if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {         return newChunkedSource(response.request().url()).     }     long contentLength = HttpHeaders.contentLength(response).     if (contentLength != -1) {         return newFixedLengthSource(contentLength).     }     return newUnknownLengthSource(). }
false;public;0;6;;@Override public Headers trailers() {     if (state != STATE_CLOSED) {         throw new IllegalStateException("too early. can't read the trailers yet").     }     return trailers != null ? trailers : Util.EMPTY_HEADERS. }
true;public;0;3;/**  * Returns true if this connection is closed.  */ ;/**  * Returns true if this connection is closed.  */ public boolean isClosed() {     return state == STATE_CLOSED. }
false;public;0;3;;@Override public void flushRequest() throws IOException {     sink.flush(). }
false;public;0;3;;@Override public void finishRequest() throws IOException {     sink.flush(). }
true;public;2;12;/**  * Returns bytes of a request header for sending on an HTTP transport.  */ ;/**  * Returns bytes of a request header for sending on an HTTP transport.  */ public void writeRequest(Headers headers, String requestLine) throws IOException {     if (state != STATE_IDLE)         throw new IllegalStateException("state: " + state).     sink.writeUtf8(requestLine).writeUtf8("\r\n").     for (int i = 0, size = headers.size(). i < size. i++) {         sink.writeUtf8(headers.name(i)).writeUtf8(": ").writeUtf8(headers.value(i)).writeUtf8("\r\n").     }     sink.writeUtf8("\r\n").     state = STATE_OPEN_REQUEST_BODY. }
false;public;1;29;;@Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {     if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {         throw new IllegalStateException("state: " + state).     }     try {         StatusLine statusLine = StatusLine.parse(readHeaderLine()).         Response.Builder responseBuilder = new Response.Builder().protocol(statusLine.protocol).code(statusLine.code).message(statusLine.message).headers(readHeaders()).         if (expectContinue && statusLine.code == HTTP_CONTINUE) {             return null.         } else if (statusLine.code == HTTP_CONTINUE) {             state = STATE_READ_RESPONSE_HEADERS.             return responseBuilder.         }         state = STATE_OPEN_RESPONSE_BODY.         return responseBuilder.     } catch (EOFException e) {         // Provide more context if the server ends the stream before sending a response.         throw new IOException("unexpected end of stream on " + realConnection.route().address().url().redact(), e).     } }
false;private;0;5;;private String readHeaderLine() throws IOException {     String line = source.readUtf8LineStrict(headerLimit).     headerLimit -= line.length().     return line. }
true;private;0;8;/**  * Reads headers or trailers.  */ ;/**  * Reads headers or trailers.  */ private Headers readHeaders() throws IOException {     Headers.Builder headers = new Headers.Builder().     // parse the result headers until the first blank line     for (String line. (line = readHeaderLine()).length() != 0. ) {         Internal.instance.addLenient(headers, line).     }     return headers.build(). }
false;private;0;5;;private Sink newChunkedSink() {     if (state != STATE_OPEN_REQUEST_BODY)         throw new IllegalStateException("state: " + state).     state = STATE_WRITING_REQUEST_BODY.     return new ChunkedSink(). }
false;private;0;5;;private Sink newKnownLengthSink() {     if (state != STATE_OPEN_REQUEST_BODY)         throw new IllegalStateException("state: " + state).     state = STATE_WRITING_REQUEST_BODY.     return new KnownLengthSink(). }
false;private;1;5;;private Source newFixedLengthSource(long length) {     if (state != STATE_OPEN_RESPONSE_BODY)         throw new IllegalStateException("state: " + state).     state = STATE_READING_RESPONSE_BODY.     return new FixedLengthSource(length). }
false;private;1;5;;private Source newChunkedSource(HttpUrl url) {     if (state != STATE_OPEN_RESPONSE_BODY)         throw new IllegalStateException("state: " + state).     state = STATE_READING_RESPONSE_BODY.     return new ChunkedSource(url). }
false;private;0;6;;private Source newUnknownLengthSource() {     if (state != STATE_OPEN_RESPONSE_BODY)         throw new IllegalStateException("state: " + state).     state = STATE_READING_RESPONSE_BODY.     realConnection.noNewExchanges().     return new UnknownLengthSource(). }
true;private;1;6;/**  * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout  * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled  * connections.  */ ;/**  * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout  * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled  * connections.  */ private void detachTimeout(ForwardingTimeout timeout) {     Timeout oldDelegate = timeout.delegate().     timeout.setDelegate(Timeout.NONE).     oldDelegate.clearDeadline().     oldDelegate.clearTimeout(). }
true;public;1;7;/**  * The response body from a CONNECT should be empty, but if it is not then we should consume it  * before proceeding.  */ ;/**  * The response body from a CONNECT should be empty, but if it is not then we should consume it  * before proceeding.  */ public void skipConnectBody(Response response) throws IOException {     long contentLength = HttpHeaders.contentLength(response).     if (contentLength == -1L)         return.     Source body = newFixedLengthSource(contentLength).     Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS).     body.close(). }
false;public;0;3;;@Override public Timeout timeout() {     return timeout. }
false;public;2;5;;@Override public void write(Buffer source, long byteCount) throws IOException {     if (closed)         throw new IllegalStateException("closed").     checkOffsetAndCount(source.size(), 0, byteCount).     sink.write(source, byteCount). }
false;public;0;4;;@Override public void flush() throws IOException {     // Don't throw. this stream might have been closed on the caller's behalf.     if (closed)         return.     sink.flush(). }
false;public;0;6;;@Override public void close() throws IOException {     if (closed)         return.     closed = true.     detachTimeout(timeout).     state = STATE_READ_RESPONSE_HEADERS. }
false;public;0;3;;@Override public Timeout timeout() {     return timeout. }
false;public;2;9;;@Override public void write(Buffer source, long byteCount) throws IOException {     if (closed)         throw new IllegalStateException("closed").     if (byteCount == 0)         return.     sink.writeHexadecimalUnsignedLong(byteCount).     sink.writeUtf8("\r\n").     sink.write(source, byteCount).     sink.writeUtf8("\r\n"). }
false;public,synchronized;0;4;;@Override public synchronized void flush() throws IOException {     // Don't throw. this stream might have been closed on the caller's behalf.     if (closed)         return.     sink.flush(). }
false;public,synchronized;0;7;;@Override public synchronized void close() throws IOException {     if (closed)         return.     closed = true.     sink.writeUtf8("0\r\n\r\n").     detachTimeout(timeout).     state = STATE_READ_RESPONSE_HEADERS. }
false;public;0;3;;@Override public Timeout timeout() {     return timeout. }
false;public;2;9;;@Override public long read(Buffer sink, long byteCount) throws IOException {     try {         return source.read(sink, byteCount).     } catch (IOException e) {         realConnection.noNewExchanges().         responseBodyComplete().         throw e.     } }
true;final;0;8;/**  * Closes the cache entry and makes the socket available for reuse. This should be invoked when  * the end of the body has been reached.  */ ;/**  * Closes the cache entry and makes the socket available for reuse. This should be invoked when  * the end of the body has been reached.  */ final void responseBodyComplete() {     if (state == STATE_CLOSED)         return.     if (state != STATE_READING_RESPONSE_BODY)         throw new IllegalStateException("state: " + state).     detachTimeout(timeout).     state = STATE_CLOSED. }
false;public;2;19;;@Override public long read(Buffer sink, long byteCount) throws IOException {     if (byteCount < 0)         throw new IllegalArgumentException("byteCount < 0: " + byteCount).     if (closed)         throw new IllegalStateException("closed").     if (bytesRemaining == 0)         return -1.     long read = super.read(sink, Math.min(bytesRemaining, byteCount)).     if (read == -1) {         // The server didn't supply the promised content length.         realConnection.noNewExchanges().         ProtocolException e = new ProtocolException("unexpected end of stream").         responseBodyComplete().         throw e.     }     bytesRemaining -= read.     if (bytesRemaining == 0) {         responseBodyComplete().     }     return read. }
false;public;0;10;;@Override public void close() throws IOException {     if (closed)         return.     if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {         // Unread bytes remain on the stream.         realConnection.noNewExchanges().         responseBodyComplete().     }     closed = true. }
false;public;2;20;;@Override public long read(Buffer sink, long byteCount) throws IOException {     if (byteCount < 0)         throw new IllegalArgumentException("byteCount < 0: " + byteCount).     if (closed)         throw new IllegalStateException("closed").     if (!hasMoreChunks)         return -1.     if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {         readChunkSize().         if (!hasMoreChunks)             return -1.     }     long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk)).     if (read == -1) {         // The server didn't supply the promised chunk length.         realConnection.noNewExchanges().         ProtocolException e = new ProtocolException("unexpected end of stream").         responseBodyComplete().         throw e.     }     bytesRemainingInChunk -= read.     return read. }
false;private;0;22;;private void readChunkSize() throws IOException {     // Read the suffix of the previous chunk.     if (bytesRemainingInChunk != NO_CHUNK_YET) {         source.readUtf8LineStrict().     }     try {         bytesRemainingInChunk = source.readHexadecimalUnsignedLong().         String extensions = source.readUtf8LineStrict().trim().         if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith("."))) {             throw new ProtocolException("expected chunk size and optional extensions but was \"" + bytesRemainingInChunk + extensions + "\"").         }     } catch (NumberFormatException e) {         throw new ProtocolException(e.getMessage()).     }     if (bytesRemainingInChunk == 0L) {         hasMoreChunks = false.         trailers = readHeaders().         HttpHeaders.receiveHeaders(client.cookieJar(), url, trailers).         responseBodyComplete().     } }
false;public;0;8;;@Override public void close() throws IOException {     if (closed)         return.     if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {         // Unread bytes remain on the stream.         realConnection.noNewExchanges().         responseBodyComplete().     }     closed = true. }
false;public;2;14;;@Override public long read(Buffer sink, long byteCount) throws IOException {     if (byteCount < 0)         throw new IllegalArgumentException("byteCount < 0: " + byteCount).     if (closed)         throw new IllegalStateException("closed").     if (inputExhausted)         return -1.     long read = super.read(sink, byteCount).     if (read == -1) {         inputExhausted = true.         responseBodyComplete().         return -1.     }     return read. }
false;public;0;7;;@Override public void close() throws IOException {     if (closed)         return.     if (!inputExhausted) {         responseBodyComplete().     }     closed = true. }
