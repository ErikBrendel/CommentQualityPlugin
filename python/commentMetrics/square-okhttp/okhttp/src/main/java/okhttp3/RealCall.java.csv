commented;modifiers;parameterAmount;loc;comment;code
false;static;3;6;;static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {     // Safely publish the Call instance to the EventListener.     RealCall call = new RealCall(client, originalRequest, forWebSocket).     call.transmitter = new Transmitter(client, call).     return call. }
false;public;0;3;;@Override public Request request() {     return originalRequest. }
false;public;0;14;;@Override public Response execute() throws IOException {     synchronized (this) {         if (executed)             throw new IllegalStateException("Already Executed").         executed = true.     }     transmitter.timeoutEnter().     transmitter.callStart().     try {         client.dispatcher().executed(this).         return getResponseWithInterceptorChain().     } finally {         client.dispatcher().finished(this).     } }
false;public;1;8;;@Override public void enqueue(Callback responseCallback) {     synchronized (this) {         if (executed)             throw new IllegalStateException("Already Executed").         executed = true.     }     transmitter.callStart().     client.dispatcher().enqueue(new AsyncCall(responseCallback)). }
false;public;0;3;;@Override public void cancel() {     transmitter.cancel(). }
false;public;0;3;;@Override public Timeout timeout() {     return transmitter.timeout(). }
false;public,synchronized;0;3;;@Override public synchronized boolean isExecuted() {     return executed. }
false;public;0;3;;@Override public boolean isCanceled() {     return transmitter.isCanceled(). }
false;public;0;4;;// We are a final type & this saves clearing state. @SuppressWarnings("CloneDoesntCallSuperClone") @Override public RealCall clone() {     return RealCall.newRealCall(client, originalRequest, forWebSocket). }
false;;0;3;;AtomicInteger callsPerHost() {     return callsPerHost. }
false;;1;3;;void reuseCallsPerHostFrom(AsyncCall other) {     this.callsPerHost = other.callsPerHost. }
false;;0;3;;String host() {     return originalRequest.url().host(). }
false;;0;3;;Request request() {     return originalRequest. }
false;;0;3;;RealCall get() {     return RealCall.this. }
true;;1;17;/**  * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up  * if the executor has been shut down by reporting the call as failed.  */ ;/**  * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up  * if the executor has been shut down by reporting the call as failed.  */ void executeOn(ExecutorService executorService) {     assert (!Thread.holdsLock(client.dispatcher())).     boolean success = false.     try {         executorService.execute(this).         success = true.     } catch (RejectedExecutionException e) {         InterruptedIOException ioException = new InterruptedIOException("executor rejected").         ioException.initCause(e).         transmitter.noMoreExchanges(ioException).         responseCallback.onFailure(RealCall.this, ioException).     } finally {         if (!success) {             // This call is no longer running!             client.dispatcher().finished(this).         }     } }
false;protected;0;18;;@Override protected void execute() {     boolean signalledCallback = false.     transmitter.timeoutEnter().     try {         Response response = getResponseWithInterceptorChain().         signalledCallback = true.         responseCallback.onResponse(RealCall.this, response).     } catch (IOException e) {         if (signalledCallback) {             // Do not signal the callback twice!             Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e).         } else {             responseCallback.onFailure(RealCall.this, e).         }     } finally {         client.dispatcher().finished(this).     } }
true;;0;5;/**  * Returns a string that describes this call. Doesn't include a full URL as that might contain  * sensitive information.  */ ;/**  * Returns a string that describes this call. Doesn't include a full URL as that might contain  * sensitive information.  */ String toLoggableString() {     return (isCanceled() ? "canceled " : "") + (forWebSocket ? "web socket" : "call") + " to " + redactedUrl(). }
false;;0;3;;String redactedUrl() {     return originalRequest.url().redact(). }
false;;0;34;;Response getResponseWithInterceptorChain() throws IOException {     // Build a full stack of interceptors.     List<Interceptor> interceptors = new ArrayList<>().     interceptors.addAll(client.interceptors()).     interceptors.add(new RetryAndFollowUpInterceptor(client)).     interceptors.add(new BridgeInterceptor(client.cookieJar())).     interceptors.add(new CacheInterceptor(client.internalCache())).     interceptors.add(new ConnectInterceptor(client)).     if (!forWebSocket) {         interceptors.addAll(client.networkInterceptors()).     }     interceptors.add(new CallServerInterceptor(forWebSocket)).     Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()).     boolean calledNoMoreExchanges = false.     try {         Response response = chain.proceed(originalRequest).         if (transmitter.isCanceled()) {             closeQuietly(response).             throw new IOException("Canceled").         }         return response.     } catch (IOException e) {         calledNoMoreExchanges = true.         throw transmitter.noMoreExchanges(e).     } finally {         if (!calledNoMoreExchanges) {             transmitter.noMoreExchanges(null).         }     } }
