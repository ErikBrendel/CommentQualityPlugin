commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;@Override public void addLenient(Headers.Builder builder, String line) {     builder.addLenient(line). }
false;public;3;3;;@Override public void addLenient(Headers.Builder builder, String name, String value) {     builder.addLenient(name, value). }
false;public;1;3;;@Override public RealConnectionPool realConnectionPool(ConnectionPool connectionPool) {     return connectionPool.delegate. }
false;public;2;3;;@Override public boolean equalsNonHost(Address a, Address b) {     return a.equalsNonHost(b). }
false;public;1;3;;@Override public int code(Response.Builder responseBuilder) {     return responseBuilder.code. }
false;public;3;4;;@Override public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {     tlsConfiguration.apply(sslSocket, isFallback). }
false;public;2;3;;@Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {     return RealCall.newRealCall(client, originalRequest, true). }
false;public;2;4;;@Override public void initExchange(Response.Builder responseBuilder, Exchange exchange) {     responseBuilder.initExchange(exchange). }
false;public;1;3;;@Override @Nullable public Exchange exchange(Response response) {     return response.exchange. }
false;private,static;1;9;;private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {     try {         SSLContext sslContext = Platform.get().getSSLContext().         sslContext.init(null, new TrustManager[] { trustManager }, null).         return sslContext.getSocketFactory().     } catch (GeneralSecurityException e) {         // The system has no TLS. Just give up.         throw new AssertionError("No System TLS", e).     } }
true;public;0;3;/**  * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but  * there is for the connect, write, and read actions within a call.  */ ;/**  * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but  * there is for the connect, write, and read actions within a call.  */ public int callTimeoutMillis() {     return callTimeout. }
true;public;0;3;/**  * Default connect timeout (in milliseconds). The default is 10 seconds.  */ ;/**  * Default connect timeout (in milliseconds). The default is 10 seconds.  */ public int connectTimeoutMillis() {     return connectTimeout. }
true;public;0;3;/**  * Default read timeout (in milliseconds). The default is 10 seconds.  */ ;/**  * Default read timeout (in milliseconds). The default is 10 seconds.  */ public int readTimeoutMillis() {     return readTimeout. }
true;public;0;3;/**  * Default write timeout (in milliseconds). The default is 10 seconds.  */ ;/**  * Default write timeout (in milliseconds). The default is 10 seconds.  */ public int writeTimeoutMillis() {     return writeTimeout. }
true;public;0;3;/**  * Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent.  */ ;/**  * Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent.  */ public int pingIntervalMillis() {     return pingInterval. }
false;public;0;3;;@Nullable public Proxy proxy() {     return proxy. }
false;public;0;3;;public ProxySelector proxySelector() {     return proxySelector. }
false;public;0;3;;public CookieJar cookieJar() {     return cookieJar. }
false;public;0;3;;@Nullable public Cache cache() {     return cache. }
false;;0;3;;@Nullable InternalCache internalCache() {     return cache != null ? cache.internalCache : internalCache. }
false;public;0;3;;public Dns dns() {     return dns. }
false;public;0;3;;public SocketFactory socketFactory() {     return socketFactory. }
false;public;0;3;;public SSLSocketFactory sslSocketFactory() {     return sslSocketFactory. }
false;public;0;3;;public HostnameVerifier hostnameVerifier() {     return hostnameVerifier. }
false;public;0;3;;public CertificatePinner certificatePinner() {     return certificatePinner. }
false;public;0;3;;public Authenticator authenticator() {     return authenticator. }
false;public;0;3;;public Authenticator proxyAuthenticator() {     return proxyAuthenticator. }
false;public;0;3;;public ConnectionPool connectionPool() {     return connectionPool. }
false;public;0;3;;public boolean followSslRedirects() {     return followSslRedirects. }
false;public;0;3;;public boolean followRedirects() {     return followRedirects. }
false;public;0;3;;public boolean retryOnConnectionFailure() {     return retryOnConnectionFailure. }
false;public;0;3;;public Dispatcher dispatcher() {     return dispatcher. }
false;public;0;3;;public List<Protocol> protocols() {     return protocols. }
false;public;0;3;;public List<ConnectionSpec> connectionSpecs() {     return connectionSpecs. }
true;public;0;3;/**  * Returns an immutable list of interceptors that observe the full span of each call: from before  * the connection is established (if any) until after the response source is selected (either the  * origin server, cache, or both).  */ ;/**  * Returns an immutable list of interceptors that observe the full span of each call: from before  * the connection is established (if any) until after the response source is selected (either the  * origin server, cache, or both).  */ public List<Interceptor> interceptors() {     return interceptors. }
true;public;0;3;/**  * Returns an immutable list of interceptors that observe a single network request and response.  * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for  * a network interceptor to short-circuit or repeat a network request.  */ ;/**  * Returns an immutable list of interceptors that observe a single network request and response.  * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for  * a network interceptor to short-circuit or repeat a network request.  */ public List<Interceptor> networkInterceptors() {     return networkInterceptors. }
false;public;0;3;;public EventListener.Factory eventListenerFactory() {     return eventListenerFactory. }
true;public;1;3;/**  * Prepares the {@code request} to be executed at some point in the future.  */ ;/**  * Prepares the {@code request} to be executed at some point in the future.  */ @Override public Call newCall(Request request) {     return RealCall.newRealCall(this, request, false). }
true;public;2;5;/**  * Uses {@code request} to connect a new web socket.  */ ;/**  * Uses {@code request} to connect a new web socket.  */ @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {     RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval).     webSocket.connect(this).     return webSocket. }
false;public;0;3;;public Builder newBuilder() {     return new Builder(this). }
true;public;2;4;/**  * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values  * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request  * body, server processing, and reading the response body. If the call requires redirects or  * retries all must complete within one timeout period.  *  * <p>The default value is 0 which imposes no timeout.  */ ;/**  * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values  * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request  * body, server processing, and reading the response body. If the call requires redirects or  * retries all must complete within one timeout period.  *  * <p>The default value is 0 which imposes no timeout.  */ public Builder callTimeout(long timeout, TimeUnit unit) {     callTimeout = checkDuration("timeout", timeout, unit).     return this. }
true;public;1;5;/**  * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values  * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request  * body, server processing, and reading the response body. If the call requires redirects or  * retries all must complete within one timeout period.  *  * <p>The default value is 0 which imposes no timeout.  */ ;/**  * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values  * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request  * body, server processing, and reading the response body. If the call requires redirects or  * retries all must complete within one timeout period.  *  * <p>The default value is 0 which imposes no timeout.  */ @IgnoreJRERequirement public Builder callTimeout(Duration duration) {     callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS).     return this. }
true;public;2;4;/**  * Sets the default connect timeout for new connections. A value of 0 means no timeout,  * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to  * milliseconds.  *  * <p>The connect timeout is applied when connecting a TCP socket to the target host.  * The default value is 10 seconds.  */ ;/**  * Sets the default connect timeout for new connections. A value of 0 means no timeout,  * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to  * milliseconds.  *  * <p>The connect timeout is applied when connecting a TCP socket to the target host.  * The default value is 10 seconds.  */ public Builder connectTimeout(long timeout, TimeUnit unit) {     connectTimeout = checkDuration("timeout", timeout, unit).     return this. }
true;public;1;5;/**  * Sets the default connect timeout for new connections. A value of 0 means no timeout,  * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to  * milliseconds.  *  * <p>The connect timeout is applied when connecting a TCP socket to the target host.  * The default value is 10 seconds.  */ ;/**  * Sets the default connect timeout for new connections. A value of 0 means no timeout,  * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to  * milliseconds.  *  * <p>The connect timeout is applied when connecting a TCP socket to the target host.  * The default value is 10 seconds.  */ @IgnoreJRERequirement public Builder connectTimeout(Duration duration) {     connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS).     return this. }
true;public;2;4;/**  * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise  * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The read timeout is applied to both the TCP socket and for individual read IO operations  * including on {@link Source} of the {@link Response}. The default value is 10 seconds.  *  * @see Socket#setSoTimeout(int)  * @see Source#timeout()  */ ;/**  * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise  * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The read timeout is applied to both the TCP socket and for individual read IO operations  * including on {@link Source} of the {@link Response}. The default value is 10 seconds.  *  * @see Socket#setSoTimeout(int)  * @see Source#timeout()  */ public Builder readTimeout(long timeout, TimeUnit unit) {     readTimeout = checkDuration("timeout", timeout, unit).     return this. }
true;public;1;5;/**  * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise  * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The read timeout is applied to both the TCP socket and for individual read IO operations  * including on {@link Source} of the {@link Response}. The default value is 10 seconds.  *  * @see Socket#setSoTimeout(int)  * @see Source#timeout()  */ ;/**  * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise  * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The read timeout is applied to both the TCP socket and for individual read IO operations  * including on {@link Source} of the {@link Response}. The default value is 10 seconds.  *  * @see Socket#setSoTimeout(int)  * @see Source#timeout()  */ @IgnoreJRERequirement public Builder readTimeout(Duration duration) {     readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS).     return this. }
true;public;2;4;/**  * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise  * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The write timeout is applied for individual write IO operations.  * The default value is 10 seconds.  *  * @see Sink#timeout()  */ ;/**  * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise  * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The write timeout is applied for individual write IO operations.  * The default value is 10 seconds.  *  * @see Sink#timeout()  */ public Builder writeTimeout(long timeout, TimeUnit unit) {     writeTimeout = checkDuration("timeout", timeout, unit).     return this. }
true;public;1;5;/**  * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise  * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The write timeout is applied for individual write IO operations.  * The default value is 10 seconds.  *  * @see Sink#timeout()  */ ;/**  * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise  * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.  *  * <p>The write timeout is applied for individual write IO operations.  * The default value is 10 seconds.  *  * @see Sink#timeout()  */ @IgnoreJRERequirement public Builder writeTimeout(Duration duration) {     writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS).     return this. }
true;public;2;4;/**  * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to  * automatically send ping frames until either the connection fails or it is closed. This keeps  * the connection alive and may detect connectivity failures.  *  * <p>If the server does not respond to each ping with a pong within {@code interval}, this  * client will assume that connectivity has been lost. When this happens on a web socket the  * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified  * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any  * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.  *  * <p>The default value of 0 disables client-initiated pings.  */ ;/**  * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to  * automatically send ping frames until either the connection fails or it is closed. This keeps  * the connection alive and may detect connectivity failures.  *  * <p>If the server does not respond to each ping with a pong within {@code interval}, this  * client will assume that connectivity has been lost. When this happens on a web socket the  * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified  * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any  * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.  *  * <p>The default value of 0 disables client-initiated pings.  */ public Builder pingInterval(long interval, TimeUnit unit) {     pingInterval = checkDuration("interval", interval, unit).     return this. }
true;public;1;5;/**  * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to  * automatically send ping frames until either the connection fails or it is closed. This keeps  * the connection alive and may detect connectivity failures.  *  * <p>If the server does not respond to each ping with a pong within {@code interval}, this  * client will assume that connectivity has been lost. When this happens on a web socket the  * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified  * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any  * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.  *  * <p>The default value of 0 disables client-initiated pings.  */ ;/**  * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to  * automatically send ping frames until either the connection fails or it is closed. This keeps  * the connection alive and may detect connectivity failures.  *  * <p>If the server does not respond to each ping with a pong within {@code interval}, this  * client will assume that connectivity has been lost. When this happens on a web socket the  * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified  * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any  * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.  *  * <p>The default value of 0 disables client-initiated pings.  */ @IgnoreJRERequirement public Builder pingInterval(Duration duration) {     pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS).     return this. }
true;public;1;4;/**  * Sets the HTTP proxy that will be used by connections created by this client. This takes  * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which  * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.  */ ;/**  * Sets the HTTP proxy that will be used by connections created by this client. This takes  * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which  * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.  */ public Builder proxy(@Nullable Proxy proxy) {     this.proxy = proxy.     return this. }
true;public;1;5;/**  * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified  * explicitly. The proxy selector may return multiple proxies. in that case they will be tried  * in sequence until a successful connection is established.  *  * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will  * be used.  */ ;/**  * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified  * explicitly. The proxy selector may return multiple proxies. in that case they will be tried  * in sequence until a successful connection is established.  *  * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will  * be used.  */ public Builder proxySelector(ProxySelector proxySelector) {     if (proxySelector == null)         throw new NullPointerException("proxySelector == null").     this.proxySelector = proxySelector.     return this. }
true;public;1;5;/**  * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to  * outgoing HTTP requests.  *  * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.  */ ;/**  * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to  * outgoing HTTP requests.  *  * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.  */ public Builder cookieJar(CookieJar cookieJar) {     if (cookieJar == null)         throw new NullPointerException("cookieJar == null").     this.cookieJar = cookieJar.     return this. }
true;public;1;5;/**  * Sets the response cache to be used to read and write cached responses.  */ ;/**  * Sets the response cache to be used to read and write cached responses.  */ public Builder cache(@Nullable Cache cache) {     this.cache = cache.     this.internalCache = null.     return this. }
true;public;1;5;/**  * Sets the DNS service used to lookup IP addresses for hostnames.  *  * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.  */ ;/**  * Sets the DNS service used to lookup IP addresses for hostnames.  *  * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.  */ public Builder dns(Dns dns) {     if (dns == null)         throw new NullPointerException("dns == null").     this.dns = dns.     return this. }
true;public;1;8;/**  * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link  * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding  * this method, e. g., allows the socket to be bound to a specific local address.  *  * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will  * be used.  */ ;/**  * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link  * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding  * this method, e. g., allows the socket to be bound to a specific local address.  *  * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will  * be used.  */ public Builder socketFactory(SocketFactory socketFactory) {     if (socketFactory == null)         throw new NullPointerException("socketFactory == null").     if (socketFactory instanceof SSLSocketFactory) {         throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory").     }     this.socketFactory = socketFactory.     return this. }
true;public;1;6;/**  * Sets the socket factory used to secure HTTPS connections. If unset, the system default will  * be used.  *  * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is  *     a field that OkHttp needs to build a clean certificate chain. This method instead must  *     use reflection to extract the trust manager. Applications should prefer to call {@link  *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.  */ ;/**  * Sets the socket factory used to secure HTTPS connections. If unset, the system default will  * be used.  *  * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is  *     a field that OkHttp needs to build a clean certificate chain. This method instead must  *     use reflection to extract the trust manager. Applications should prefer to call {@link  *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.  */ public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {     if (sslSocketFactory == null)         throw new NullPointerException("sslSocketFactory == null").     this.sslSocketFactory = sslSocketFactory.     this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory).     return this. }
true;public;2;8;/**  * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the  * system defaults will be used.  *  * <p>Most applications should not call this method, and instead use the system defaults. Those  * classes include special optimizations that can be lost if the implementations are decorated.  *  * <p>If necessary, you can create and configure the defaults yourself with the following code:  *  * <pre>   {@code  *  *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(  *       TrustManagerFactory.getDefaultAlgorithm()).  *   trustManagerFactory.init((KeyStore) null).  *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers().  *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {  *     throw new IllegalStateException("Unexpected default trust managers:"  *         + Arrays.toString(trustManagers)).  *   }  *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0].  *  *   SSLContext sslContext = SSLContext.getInstance("TLS").  *   sslContext.init(null, new TrustManager[] { trustManager }, null).  *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory().  *  *   OkHttpClient client = new OkHttpClient.Builder()  *       .sslSocketFactory(sslSocketFactory, trustManager)  *       .build().  * }</pre>  */ ;/**  * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the  * system defaults will be used.  *  * <p>Most applications should not call this method, and instead use the system defaults. Those  * classes include special optimizations that can be lost if the implementations are decorated.  *  * <p>If necessary, you can create and configure the defaults yourself with the following code:  *  * <pre>   {@code  *  *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(  *       TrustManagerFactory.getDefaultAlgorithm()).  *   trustManagerFactory.init((KeyStore) null).  *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers().  *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {  *     throw new IllegalStateException("Unexpected default trust managers:"  *         + Arrays.toString(trustManagers)).  *   }  *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0].  *  *   SSLContext sslContext = SSLContext.getInstance("TLS").  *   sslContext.init(null, new TrustManager[] { trustManager }, null).  *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory().  *  *   OkHttpClient client = new OkHttpClient.Builder()  *       .sslSocketFactory(sslSocketFactory, trustManager)  *       .build().  * }</pre>  */ public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {     if (sslSocketFactory == null)         throw new NullPointerException("sslSocketFactory == null").     if (trustManager == null)         throw new NullPointerException("trustManager == null").     this.sslSocketFactory = sslSocketFactory.     this.certificateChainCleaner = CertificateChainCleaner.get(trustManager).     return this. }
true;public;1;5;/**  * Sets the verifier used to confirm that response certificates apply to requested hostnames for  * HTTPS connections.  *  * <p>If unset, a default hostname verifier will be used.  */ ;/**  * Sets the verifier used to confirm that response certificates apply to requested hostnames for  * HTTPS connections.  *  * <p>If unset, a default hostname verifier will be used.  */ public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {     if (hostnameVerifier == null)         throw new NullPointerException("hostnameVerifier == null").     this.hostnameVerifier = hostnameVerifier.     return this. }
true;public;1;5;/**  * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS  * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.  * Pinning certificates avoids the need to trust certificate authorities.  */ ;/**  * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS  * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.  * Pinning certificates avoids the need to trust certificate authorities.  */ public Builder certificatePinner(CertificatePinner certificatePinner) {     if (certificatePinner == null)         throw new NullPointerException("certificatePinner == null").     this.certificatePinner = certificatePinner.     return this. }
true;public;1;5;/**  * Sets the authenticator used to respond to challenges from origin servers. Use {@link  * #proxyAuthenticator} to set the authenticator for proxy servers.  *  * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.  */ ;/**  * Sets the authenticator used to respond to challenges from origin servers. Use {@link  * #proxyAuthenticator} to set the authenticator for proxy servers.  *  * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.  */ public Builder authenticator(Authenticator authenticator) {     if (authenticator == null)         throw new NullPointerException("authenticator == null").     this.authenticator = authenticator.     return this. }
true;public;1;5;/**  * Sets the authenticator used to respond to challenges from proxy servers. Use {@link  * #authenticator} to set the authenticator for origin servers.  *  * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.  */ ;/**  * Sets the authenticator used to respond to challenges from proxy servers. Use {@link  * #authenticator} to set the authenticator for origin servers.  *  * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.  */ public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {     if (proxyAuthenticator == null)         throw new NullPointerException("proxyAuthenticator == null").     this.proxyAuthenticator = proxyAuthenticator.     return this. }
true;public;1;5;/**  * Sets the connection pool used to recycle HTTP and HTTPS connections.  *  * <p>If unset, a new connection pool will be used.  */ ;/**  * Sets the connection pool used to recycle HTTP and HTTPS connections.  *  * <p>If unset, a new connection pool will be used.  */ public Builder connectionPool(ConnectionPool connectionPool) {     if (connectionPool == null)         throw new NullPointerException("connectionPool == null").     this.connectionPool = connectionPool.     return this. }
true;public;1;4;/**  * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.  *  * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code  * HttpURLConnection}'s default.  */ ;/**  * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.  *  * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code  * HttpURLConnection}'s default.  */ public Builder followSslRedirects(boolean followProtocolRedirects) {     this.followSslRedirects = followProtocolRedirects.     return this. }
true;public;1;4;/**  * Configure this client to follow redirects. If unset, redirects will be followed.  */ ;/**  * Configure this client to follow redirects. If unset, redirects will be followed.  */ public Builder followRedirects(boolean followRedirects) {     this.followRedirects = followRedirects.     return this. }
true;public;1;4;/**  * Configure this client to retry or not when a connectivity problem is encountered. By default,  * this client silently recovers from the following problems:  *  * <ul>  *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,  *       failure to reach any individual IP address doesn't fail the overall request. This can  *       increase availability of multi-homed services.  *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets  *       to decrease request latency, but these connections will occasionally time out.  *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to  *       attempt multiple proxy servers in sequence, eventually falling back to a direct  *       connection.  * </ul>  *  * Set this to false to avoid retrying requests when doing so is destructive. In this case the  * calling application should do its own recovery of connectivity failures.  */ ;/**  * Configure this client to retry or not when a connectivity problem is encountered. By default,  * this client silently recovers from the following problems:  *  * <ul>  *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,  *       failure to reach any individual IP address doesn't fail the overall request. This can  *       increase availability of multi-homed services.  *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets  *       to decrease request latency, but these connections will occasionally time out.  *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to  *       attempt multiple proxy servers in sequence, eventually falling back to a direct  *       connection.  * </ul>  *  * Set this to false to avoid retrying requests when doing so is destructive. In this case the  * calling application should do its own recovery of connectivity failures.  */ public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {     this.retryOnConnectionFailure = retryOnConnectionFailure.     return this. }
true;public;1;5;/**  * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.  */ ;/**  * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.  */ public Builder dispatcher(Dispatcher dispatcher) {     if (dispatcher == null)         throw new IllegalArgumentException("dispatcher == null").     this.dispatcher = dispatcher.     return this. }
true;public;1;28;/**  * Configure the protocols used by this client to communicate with remote servers. By default  * this client will prefer the most efficient transport available, falling back to more  * ubiquitous protocols. Applications should only call this method to avoid specific  * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.  *  * <p>The following protocols are currently supported:  *  * <ul>  *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>  *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>  *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge  *         (cleartext only)</a>  * </ul>  *  * <p><strong>This is an evolving set.</strong> Future releases include support for transitional  * protocols. The http/1.1 transport will never be dropped.  *  * <p>If multiple protocols are specified, <a  * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to  * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.  *  * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code  * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link  * Response#protocol()}.  *  * @param protocols the protocols to use, in order of preference. If the list contains {@link  *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not  *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must  *     not contain null or {@link Protocol#HTTP_1_0}.  */ ;/**  * Configure the protocols used by this client to communicate with remote servers. By default  * this client will prefer the most efficient transport available, falling back to more  * ubiquitous protocols. Applications should only call this method to avoid specific  * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.  *  * <p>The following protocols are currently supported:  *  * <ul>  *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>  *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>  *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge  *         (cleartext only)</a>  * </ul>  *  * <p><strong>This is an evolving set.</strong> Future releases include support for transitional  * protocols. The http/1.1 transport will never be dropped.  *  * <p>If multiple protocols are specified, <a  * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to  * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.  *  * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code  * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link  * Response#protocol()}.  *  * @param protocols the protocols to use, in order of preference. If the list contains {@link  *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not  *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must  *     not contain null or {@link Protocol#HTTP_1_0}.  */ public Builder protocols(List<Protocol> protocols) {     // Create a private copy of the list.     protocols = new ArrayList<>(protocols).     // Validate that the list has everything we require and nothing we forbid.     if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && !protocols.contains(Protocol.HTTP_1_1)) {         throw new IllegalArgumentException("protocols must contain h2_prior_knowledge or http/1.1: " + protocols).     }     if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {         throw new IllegalArgumentException("protocols containing h2_prior_knowledge cannot use other protocols: " + protocols).     }     if (protocols.contains(Protocol.HTTP_1_0)) {         throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols).     }     if (protocols.contains(null)) {         throw new IllegalArgumentException("protocols must not contain null").     }     // Remove protocols that we no longer support.     protocols.remove(Protocol.SPDY_3).     // Assign as an unmodifiable list. This is effectively immutable.     this.protocols = Collections.unmodifiableList(protocols).     return this. }
false;public;1;4;;public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {     this.connectionSpecs = Util.immutableList(connectionSpecs).     return this. }
true;public;0;3;/**  * Returns a modifiable list of interceptors that observe the full span of each call: from  * before the connection is established (if any) until after the response source is selected  * (either the origin server, cache, or both).  */ ;/**  * Returns a modifiable list of interceptors that observe the full span of each call: from  * before the connection is established (if any) until after the response source is selected  * (either the origin server, cache, or both).  */ public List<Interceptor> interceptors() {     return interceptors. }
false;public;1;5;;public Builder addInterceptor(Interceptor interceptor) {     if (interceptor == null)         throw new IllegalArgumentException("interceptor == null").     interceptors.add(interceptor).     return this. }
true;public;0;3;/**  * Returns a modifiable list of interceptors that observe a single network request and response.  * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error  * for a network interceptor to short-circuit or repeat a network request.  */ ;/**  * Returns a modifiable list of interceptors that observe a single network request and response.  * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error  * for a network interceptor to short-circuit or repeat a network request.  */ public List<Interceptor> networkInterceptors() {     return networkInterceptors. }
false;public;1;5;;public Builder addNetworkInterceptor(Interceptor interceptor) {     if (interceptor == null)         throw new IllegalArgumentException("interceptor == null").     networkInterceptors.add(interceptor).     return this. }
true;public;1;5;/**  * Configure a single client scoped listener that will receive all analytic events  * for this client.  *  * @see EventListener for semantics and restrictions on listener implementations.  */ ;/**  * Configure a single client scoped listener that will receive all analytic events  * for this client.  *  * @see EventListener for semantics and restrictions on listener implementations.  */ public Builder eventListener(EventListener eventListener) {     if (eventListener == null)         throw new NullPointerException("eventListener == null").     this.eventListenerFactory = EventListener.factory(eventListener).     return this. }
true;public;1;7;/**  * Configure a factory to provide per-call scoped listeners that will receive analytic events  * for this client.  *  * @see EventListener for semantics and restrictions on listener implementations.  */ ;/**  * Configure a factory to provide per-call scoped listeners that will receive analytic events  * for this client.  *  * @see EventListener for semantics and restrictions on listener implementations.  */ public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {     if (eventListenerFactory == null) {         throw new NullPointerException("eventListenerFactory == null").     }     this.eventListenerFactory = eventListenerFactory.     return this. }
false;public;0;3;;public OkHttpClient build() {     return new OkHttpClient(this). }
