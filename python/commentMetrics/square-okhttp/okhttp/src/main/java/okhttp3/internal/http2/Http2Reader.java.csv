commented;modifiers;parameterAmount;loc;comment;code
false;public;1;15;;public void readConnectionPreface(Handler handler) throws IOException {     if (client) {         // The client reads the initial SETTINGS frame.         if (!nextFrame(true, handler)) {             throw ioException("Required SETTINGS preface not received").         }     } else {         // The server reads the CONNECTION_PREFACE byte string.         ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size()).         if (logger.isLoggable(FINE))             logger.fine(format("<< CONNECTION %s", connectionPreface.hex())).         if (!CONNECTION_PREFACE.equals(connectionPreface)) {             throw ioException("Expected a connection header but was %s", connectionPreface.utf8()).         }     } }
false;public;2;73;;public boolean nextFrame(boolean requireSettings, Handler handler) throws IOException {     try {         // Frame header size         source.require(9).     } catch (IOException e) {         // This might be a normal socket close.         return false.     }     // 0                   1                   2                   3     // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     // |                 Length (24)                   |     // +---------------+---------------+---------------+     // |   Type (8)    |   Flags (8)   |     // +-+-+-----------+---------------+-------------------------------+     // |R|                 Stream Identifier (31)                      |     // +=+=============================================================+     // |                   Frame Payload (0...)                      ...     // +---------------------------------------------------------------+     int length = readMedium(source).     if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {         throw ioException("FRAME_SIZE_ERROR: %s", length).     }     byte type = (byte) (source.readByte() & 0xff).     if (requireSettings && type != TYPE_SETTINGS) {         throw ioException("Expected a SETTINGS frame but was %s", type).     }     byte flags = (byte) (source.readByte() & 0xff).     // Ignore reserved bit.     int streamId = (source.readInt() & 0x7fffffff).     if (logger.isLoggable(FINE))         logger.fine(frameLog(true, streamId, length, type, flags)).     switch(type) {         case TYPE_DATA:             readData(handler, length, flags, streamId).             break.         case TYPE_HEADERS:             readHeaders(handler, length, flags, streamId).             break.         case TYPE_PRIORITY:             readPriority(handler, length, flags, streamId).             break.         case TYPE_RST_STREAM:             readRstStream(handler, length, flags, streamId).             break.         case TYPE_SETTINGS:             readSettings(handler, length, flags, streamId).             break.         case TYPE_PUSH_PROMISE:             readPushPromise(handler, length, flags, streamId).             break.         case TYPE_PING:             readPing(handler, length, flags, streamId).             break.         case TYPE_GOAWAY:             readGoAway(handler, length, flags, streamId).             break.         case TYPE_WINDOW_UPDATE:             readWindowUpdate(handler, length, flags, streamId).             break.         default:             // Implementations MUST discard frames that have unknown or unsupported types.             source.skip(length).     }     return true. }
false;private;4;19;;private void readHeaders(Handler handler, int length, byte flags, int streamId) throws IOException {     if (streamId == 0)         throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0").     boolean endStream = (flags & FLAG_END_STREAM) != 0.     short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0.     if ((flags & FLAG_PRIORITY) != 0) {         readPriority(handler, streamId).         // account for above read.         length -= 5.     }     length = lengthWithoutPadding(length, flags, padding).     List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId).     handler.headers(endStream, streamId, -1, headerBlock). }
false;private;4;12;;private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId) throws IOException {     continuation.length = continuation.left = length.     continuation.padding = padding.     continuation.flags = flags.     continuation.streamId = streamId.     // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5     hpackReader.readHeaders().     return hpackReader.getAndResetHeaderList(). }
false;private;4;17;;private void readData(Handler handler, int length, byte flags, int streamId) throws IOException {     if (streamId == 0)         throw ioException("PROTOCOL_ERROR: TYPE_DATA streamId == 0").     // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED     boolean inFinished = (flags & FLAG_END_STREAM) != 0.     boolean gzipped = (flags & FLAG_COMPRESSED) != 0.     if (gzipped) {         throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA").     }     short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0.     length = lengthWithoutPadding(length, flags, padding).     handler.data(inFinished, streamId, source, length).     source.skip(padding). }
false;private;4;6;;private void readPriority(Handler handler, int length, byte flags, int streamId) throws IOException {     if (length != 5)         throw ioException("TYPE_PRIORITY length: %d != 5", length).     if (streamId == 0)         throw ioException("TYPE_PRIORITY streamId == 0").     readPriority(handler, streamId). }
false;private;2;7;;private void readPriority(Handler handler, int streamId) throws IOException {     int w1 = source.readInt().     boolean exclusive = (w1 & 0x80000000) != 0.     int streamDependency = (w1 & 0x7fffffff).     int weight = (source.readByte() & 0xff) + 1.     handler.priority(streamId, streamDependency, weight, exclusive). }
false;private;4;11;;private void readRstStream(Handler handler, int length, byte flags, int streamId) throws IOException {     if (length != 4)         throw ioException("TYPE_RST_STREAM length: %d != 4", length).     if (streamId == 0)         throw ioException("TYPE_RST_STREAM streamId == 0").     int errorCodeInt = source.readInt().     ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt).     if (errorCode == null) {         throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt).     }     handler.rstStream(streamId, errorCode). }
false;private;4;46;;private void readSettings(Handler handler, int length, byte flags, int streamId) throws IOException {     if (streamId != 0)         throw ioException("TYPE_SETTINGS streamId != 0").     if ((flags & FLAG_ACK) != 0) {         if (length != 0)             throw ioException("FRAME_SIZE_ERROR ack frame should be empty!").         handler.ackSettings().         return.     }     if (length % 6 != 0)         throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length).     Settings settings = new Settings().     for (int i = 0. i < length. i += 6) {         int id = source.readShort() & 0xFFFF.         int value = source.readInt().         switch(id) {             case // SETTINGS_HEADER_TABLE_SIZE             1:                 break.             case // SETTINGS_ENABLE_PUSH             2:                 if (value != 0 && value != 1) {                     throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1").                 }                 break.             case // SETTINGS_MAX_CONCURRENT_STREAMS             3:                 // Renumbered in draft 10.                 id = 4.                 break.             case // SETTINGS_INITIAL_WINDOW_SIZE             4:                 // Renumbered in draft 10.                 id = 7.                 if (value < 0) {                     throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1").                 }                 break.             case // SETTINGS_MAX_FRAME_SIZE             5:                 if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {                     throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value).                 }                 break.             case // SETTINGS_MAX_HEADER_LIST_SIZE             6:                 // Advisory only, so ignored.                 break.             default:                 // Must ignore setting with unknown id.                 break.         }         settings.set(id, value).     }     handler.settings(false, settings). }
false;private;4;12;;private void readPushPromise(Handler handler, int length, byte flags, int streamId) throws IOException {     if (streamId == 0) {         throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0").     }     short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0.     int promisedStreamId = source.readInt() & 0x7fffffff.     // account for above read.     length -= 4.     length = lengthWithoutPadding(length, flags, padding).     List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId).     handler.pushPromise(streamId, promisedStreamId, headerBlock). }
false;private;4;9;;private void readPing(Handler handler, int length, byte flags, int streamId) throws IOException {     if (length != 8)         throw ioException("TYPE_PING length != 8: %s", length).     if (streamId != 0)         throw ioException("TYPE_PING streamId != 0").     int payload1 = source.readInt().     int payload2 = source.readInt().     boolean ack = (flags & FLAG_ACK) != 0.     handler.ping(ack, payload1, payload2). }
false;private;4;17;;private void readGoAway(Handler handler, int length, byte flags, int streamId) throws IOException {     if (length < 8)         throw ioException("TYPE_GOAWAY length < 8: %s", length).     if (streamId != 0)         throw ioException("TYPE_GOAWAY streamId != 0").     int lastStreamId = source.readInt().     int errorCodeInt = source.readInt().     int opaqueDataLength = length - 8.     ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt).     if (errorCode == null) {         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt).     }     ByteString debugData = EMPTY.     if (opaqueDataLength > 0) {         // Must read debug data in order to not corrupt the connection.         debugData = source.readByteString(opaqueDataLength).     }     handler.goAway(lastStreamId, errorCode, debugData). }
false;private;4;7;;private void readWindowUpdate(Handler handler, int length, byte flags, int streamId) throws IOException {     if (length != 4)         throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length).     long increment = (source.readInt() & 0x7fffffffL).     if (increment == 0)         throw ioException("windowSizeIncrement was 0", increment).     handler.windowUpdate(streamId, increment). }
false;public;0;3;;@Override public void close() throws IOException {     source.close(). }
false;public;2;14;;@Override public long read(Buffer sink, long byteCount) throws IOException {     while (left == 0) {         source.skip(padding).         padding = 0.         if ((flags & FLAG_END_HEADERS) != 0)             return -1.         readContinuationHeader().     // TODO: test case for empty continuation header?     }     long read = source.read(sink, Math.min(byteCount, left)).     if (read == -1)         return -1.     left -= read.     return read. }
false;public;0;3;;@Override public Timeout timeout() {     return source.timeout(). }
false;public;0;2;;@Override public void close() throws IOException { }
false;private;0;11;;private void readContinuationHeader() throws IOException {     int previousStreamId = streamId.     length = left = readMedium(source).     byte type = (byte) (source.readByte() & 0xff).     flags = (byte) (source.readByte() & 0xff).     if (logger.isLoggable(FINE))         logger.fine(frameLog(true, streamId, length, type, flags)).     streamId = (source.readInt() & 0x7fffffff).     if (type != TYPE_CONTINUATION)         throw ioException("%s != TYPE_CONTINUATION", type).     if (streamId != previousStreamId)         throw ioException("TYPE_CONTINUATION streamId changed"). }
false;static;1;5;;static int readMedium(BufferedSource source) throws IOException {     return (source.readByte() & 0xff) << 16 | (source.readByte() & 0xff) << 8 | (source.readByte() & 0xff). }
false;static;3;8;;static int lengthWithoutPadding(int length, byte flags, short padding) throws IOException {     // Account for reading the padding length.     if ((flags & FLAG_PADDED) != 0)         length--.     if (padding > length) {         throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length).     }     return (short) (length - padding). }
false;;4;2;;void data(boolean inFinished, int streamId, BufferedSource source, int length) throws IOException.
true;;4;2;/**  * Create or update incoming headers, creating the corresponding streams if necessary. Frames  * that trigger this are HEADERS and PUSH_PROMISE.  *  * @param inFinished true if the sender will not send further frames.  * @param streamId the stream owning these headers.  * @param associatedStreamId the stream that triggered the sender to create this stream.  */ ;/**  * Create or update incoming headers, creating the corresponding streams if necessary. Frames  * that trigger this are HEADERS and PUSH_PROMISE.  *  * @param inFinished true if the sender will not send further frames.  * @param streamId the stream owning these headers.  * @param associatedStreamId the stream that triggered the sender to create this stream.  */ void headers(boolean inFinished, int streamId, int associatedStreamId, List<Header> headerBlock).
false;;2;1;;void rstStream(int streamId, ErrorCode errorCode).
false;;2;1;;void settings(boolean clearPrevious, Settings settings).
true;;0;1;/**  * HTTP/2 only.  */ ;/**  * HTTP/2 only.  */ void ackSettings().
true;;3;1;/**  * Read a connection-level ping from the peer. {@code ack} indicates this is a reply. The data  * in {@code payload1} and {@code payload2} opaque binary, and there are no rules on the  * content.  */ ;/**  * Read a connection-level ping from the peer. {@code ack} indicates this is a reply. The data  * in {@code payload1} and {@code payload2} opaque binary, and there are no rules on the  * content.  */ void ping(boolean ack, int payload1, int payload2).
true;;3;1;/**  * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >  * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=  * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.  *  * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If  * {@code lastGoodStreamId} is zero, the peer processed no frames.  * @param errorCode reason for closing the connection.  * @param debugData only valid for HTTP/2. opaque debug data to send.  */ ;/**  * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >  * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=  * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.  *  * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If  * {@code lastGoodStreamId} is zero, the peer processed no frames.  * @param errorCode reason for closing the connection.  * @param debugData only valid for HTTP/2. opaque debug data to send.  */ void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData).
true;;2;1;/**  * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code  * streamId}, or the connection if {@code streamId} is zero.  */ ;/**  * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code  * streamId}, or the connection if {@code streamId} is zero.  */ void windowUpdate(int streamId, long windowSizeIncrement).
true;;4;1;/**  * Called when reading a headers or priority frame. This may be used to change the stream's  * weight from the default (16) to a new value.  *  * @param streamId stream which has a priority change.  * @param streamDependency the stream ID this stream is dependent on.  * @param weight relative proportion of priority in [1..256].  * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.  */ ;/**  * Called when reading a headers or priority frame. This may be used to change the stream's  * weight from the default (16) to a new value.  *  * @param streamId stream which has a priority change.  * @param streamDependency the stream ID this stream is dependent on.  * @param weight relative proportion of priority in [1..256].  * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.  */ void priority(int streamId, int streamDependency, int weight, boolean exclusive).
true;;3;2;/**  * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers  * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response  * frames will be delivered. Push promise frames are sent as a part of the response to {@code  * streamId}.  *  * @param streamId client-initiated stream ID.  Must be an odd number.  * @param promisedStreamId server-initiated stream ID.  Must be an even number.  * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code  * :authority}, and (@code :path}.  */ ;/**  * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers  * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response  * frames will be delivered. Push promise frames are sent as a part of the response to {@code  * streamId}.  *  * @param streamId client-initiated stream ID.  Must be an odd number.  * @param promisedStreamId server-initiated stream ID.  Must be an even number.  * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code  * :authority}, and (@code :path}.  */ void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) throws IOException.
true;;6;2;/**  * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are  * available from a different network location or protocol configuration.  *  * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>  *  * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate  * service is the origin of the stream. When zero, the origin is specified in the {@code origin}  * parameter.  * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is  * typically represented as a combination of scheme, host and port. When empty, the origin is  * that of the {@code streamId}.  * @param protocol an ALPN protocol, such as {@code h2}.  * @param host an IP address or hostname.  * @param port the IP port associated with the service.  * @param maxAge time in seconds that this alternative is considered fresh.  */ ;/**  * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are  * available from a different network location or protocol configuration.  *  * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>  *  * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate  * service is the origin of the stream. When zero, the origin is specified in the {@code origin}  * parameter.  * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is  * typically represented as a combination of scheme, host and port. When empty, the origin is  * that of the {@code streamId}.  * @param protocol an ALPN protocol, such as {@code h2}.  * @param host an IP address or hostname.  * @param port the IP port associated with the service.  * @param maxAge time in seconds that this alternative is considered fresh.  */ void alternateService(int streamId, String origin, ByteString protocol, String host, int port, long maxAge).
