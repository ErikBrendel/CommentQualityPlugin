commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;@Override public RealConnection connection() {     return realConnection. }
false;public;2;3;;@Override public Sink createRequestBody(Request request, long contentLength) {     return stream.getSink(). }
false;public;1;15;;@Override public void writeRequestHeaders(Request request) throws IOException {     if (stream != null)         return.     boolean hasRequestBody = request.body() != null.     List<Header> requestHeaders = http2HeadersList(request).     stream = connection.newStream(requestHeaders, hasRequestBody).     // headers, but there was still no stream to close.     if (canceled) {         stream.closeLater(ErrorCode.CANCEL).         throw new IOException("Canceled").     }     stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS).     stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS). }
false;public;0;3;;@Override public void flushRequest() throws IOException {     connection.flush(). }
false;public;0;3;;@Override public void finishRequest() throws IOException {     stream.getSink().close(). }
false;public;1;8;;@Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {     Headers headers = stream.takeHeaders().     Response.Builder responseBuilder = readHttp2HeadersList(headers, protocol).     if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {         return null.     }     return responseBuilder. }
false;public,static;1;21;;public static List<Header> http2HeadersList(Request request) {     Headers headers = request.headers().     List<Header> result = new ArrayList<>(headers.size() + 4).     result.add(new Header(TARGET_METHOD, request.method())).     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url()))).     String host = request.header("Host").     if (host != null) {         // Optional.         result.add(new Header(TARGET_AUTHORITY, host)).     }     result.add(new Header(TARGET_SCHEME, request.url().scheme())).     for (int i = 0, size = headers.size(). i < size. i++) {         // header names must be lowercase.         String name = headers.name(i).toLowerCase(Locale.US).         if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name) || name.equals(TE) && headers.value(i).equals("trailers")) {             result.add(new Header(name, headers.value(i))).         }     }     return result. }
true;public,static;2;21;/**  * Returns headers for a name value block containing an HTTP/2 response.  */ ;/**  * Returns headers for a name value block containing an HTTP/2 response.  */ public static Response.Builder readHttp2HeadersList(Headers headerBlock, Protocol protocol) throws IOException {     StatusLine statusLine = null.     Headers.Builder headersBuilder = new Headers.Builder().     for (int i = 0, size = headerBlock.size(). i < size. i++) {         String name = headerBlock.name(i).         String value = headerBlock.value(i).         if (name.equals(RESPONSE_STATUS_UTF8)) {             statusLine = StatusLine.parse("HTTP/1.1 " + value).         } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {             Internal.instance.addLenient(headersBuilder, name, value).         }     }     if (statusLine == null)         throw new ProtocolException("Expected ':status' header not present").     return new Response.Builder().protocol(protocol).code(statusLine.code).message(statusLine.message).headers(headersBuilder.build()). }
false;public;1;3;;@Override public long reportedContentLength(Response response) {     return HttpHeaders.contentLength(response). }
false;public;1;3;;@Override public Source openResponseBodySource(Response response) {     return stream.getSource(). }
false;public;0;3;;@Override public Headers trailers() throws IOException {     return stream.trailers(). }
false;public;0;4;;@Override public void cancel() {     canceled = true.     if (stream != null)         stream.closeLater(ErrorCode.CANCEL). }
