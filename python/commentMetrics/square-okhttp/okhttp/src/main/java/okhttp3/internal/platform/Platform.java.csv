commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;3;;public static Platform get() {     return PLATFORM. }
true;public;0;3;/**  * Prefix used on custom headers.  */ ;/**  * Prefix used on custom headers.  */ public String getPrefix() {     return "OkHttp". }
false;protected;1;13;;@Nullable protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {     // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.     try {         Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl").         Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context").         if (context == null)             return null.         return readFieldOrNull(context, X509TrustManager.class, "trustManager").     } catch (ClassNotFoundException e) {         return null.     } }
true;public;3;3;/**  * Configure TLS extensions on {@code sslSocket} for {@code route}.  *  * @param hostname non-null for client-side handshakes. null for server-side handshakes.  */ ;/**  * Configure TLS extensions on {@code sslSocket} for {@code route}.  *  * @param hostname non-null for client-side handshakes. null for server-side handshakes.  */ public void configureTlsExtensions(SSLSocket sslSocket, @Nullable String hostname, List<Protocol> protocols) { }
true;public;1;2;/**  * Called after the TLS handshake to release resources allocated by {@link  * #configureTlsExtensions}.  */ ;/**  * Called after the TLS handshake to release resources allocated by {@link  * #configureTlsExtensions}.  */ public void afterHandshake(SSLSocket sslSocket) { }
true;public;1;3;/**  * Returns the negotiated protocol, or null if no protocol was negotiated.  */ ;/**  * Returns the negotiated protocol, or null if no protocol was negotiated.  */ @Nullable public String getSelectedProtocol(SSLSocket socket) {     return null. }
false;public;3;4;;public void connectSocket(Socket socket, InetSocketAddress address, int connectTimeout) throws IOException {     socket.connect(address, connectTimeout). }
false;public;3;4;;public void log(int level, String message, @Nullable Throwable t) {     Level logLevel = level == WARN ? Level.WARNING : Level.INFO.     logger.log(logLevel, message, t). }
false;public;1;3;;public boolean isCleartextTrafficPermitted(String hostname) {     return true. }
true;public;1;6;/**  * Returns an object that holds a stack trace created at the moment this method is executed. This  * should be used specifically for {@link java.io.Closeable} objects and in conjunction with  * {@link #logCloseableLeak(String, Object)}.  */ ;/**  * Returns an object that holds a stack trace created at the moment this method is executed. This  * should be used specifically for {@link java.io.Closeable} objects and in conjunction with  * {@link #logCloseableLeak(String, Object)}.  */ @Nullable public Object getStackTraceForCloseable(String closer) {     if (logger.isLoggable(Level.FINE)) {         // These are expensive to allocate.         return new Throwable(closer).     }     return null. }
false;public;2;7;;public void logCloseableLeak(String message, Object stackTrace) {     if (stackTrace == null) {         message += " To see where this was allocated, set the OkHttpClient logger level to FINE: " + "Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE).".     }     log(WARN, message, (Throwable) stackTrace). }
false;public,static;1;9;;public static List<String> alpnProtocolNames(List<Protocol> protocols) {     List<String> names = new ArrayList<>(protocols.size()).     for (int i = 0, size = protocols.size(). i < size. i++) {         Protocol protocol = protocols.get(i).         // No HTTP/1.0 for ALPN.         if (protocol == Protocol.HTTP_1_0)             continue.         names.add(protocol.toString()).     }     return names. }
false;public;1;3;;public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {     return new BasicCertificateChainCleaner(buildTrustRootIndex(trustManager)). }
false;public;1;12;;public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory sslSocketFactory) {     X509TrustManager trustManager = trustManager(sslSocketFactory).     if (trustManager == null) {         throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get() + ", sslSocketFactory is " + sslSocketFactory.getClass()).     }     return buildCertificateChainCleaner(trustManager). }
false;public,static;0;10;;public static boolean isConscryptPreferred() {     // mainly to allow tests to run cleanly     if ("conscrypt".equals(Util.getSystemProperty("okhttp.platform", null))) {         return true.     }     // check if Provider manually installed     String preferredProvider = Security.getProviders()[0].getName().     return "Conscrypt".equals(preferredProvider). }
true;private,static;0;30;/**  * Attempt to match the host runtime to a capable Platform implementation.  */ ;/**  * Attempt to match the host runtime to a capable Platform implementation.  */ private static Platform findPlatform() {     Platform android = AndroidPlatform.buildIfSupported().     if (android != null) {         return android.     }     if (isConscryptPreferred()) {         Platform conscrypt = ConscryptPlatform.buildIfSupported().         if (conscrypt != null) {             return conscrypt.         }     }     Platform jdk9 = Jdk9Platform.buildIfSupported().     if (jdk9 != null) {         return jdk9.     }     Platform jdkWithJettyBoot = Jdk8WithJettyBootPlatform.buildIfSupported().     if (jdkWithJettyBoot != null) {         return jdkWithJettyBoot.     }     // Probably an Oracle JDK like OpenJDK.     return new Platform(). }
true;static;1;10;/**  * Returns the concatenation of 8-bit, length prefixed protocol names.  * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4  */ ;/**  * Returns the concatenation of 8-bit, length prefixed protocol names.  * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4  */ static byte[] concatLengthPrefixed(List<Protocol> protocols) {     Buffer result = new Buffer().     for (int i = 0, size = protocols.size(). i < size. i++) {         Protocol protocol = protocols.get(i).         // No HTTP/1.0 for ALPN.         if (protocol == Protocol.HTTP_1_0)             continue.         result.writeByte(protocol.toString().length()).         result.writeUtf8(protocol.toString()).     }     return result.readByteArray(). }
false;static;3;22;;@Nullable static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {     for (Class<?> c = instance.getClass(). c != Object.class. c = c.getSuperclass()) {         try {             Field field = c.getDeclaredField(fieldName).             field.setAccessible(true).             Object value = field.get(instance).             if (!fieldType.isInstance(value))                 return null.             return fieldType.cast(value).         } catch (NoSuchFieldException ignored) {         } catch (IllegalAccessException e) {             throw new AssertionError().         }     }     // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.     if (!fieldName.equals("delegate")) {         Object delegate = readFieldOrNull(instance, Object.class, "delegate").         if (delegate != null)             return readFieldOrNull(delegate, fieldType, fieldName).     }     return null. }
false;public;0;7;;public SSLContext getSSLContext() {     try {         return SSLContext.getInstance("TLS").     } catch (NoSuchAlgorithmException e) {         throw new IllegalStateException("No TLS provider", e).     } }
false;public;1;3;;public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {     return new BasicTrustRootIndex(trustManager.getAcceptedIssuers()). }
false;public;1;2;;public void configureSslSocketFactory(SSLSocketFactory socketFactory) { }
false;public;0;3;;@Override public String toString() {     return getClass().getSimpleName(). }
