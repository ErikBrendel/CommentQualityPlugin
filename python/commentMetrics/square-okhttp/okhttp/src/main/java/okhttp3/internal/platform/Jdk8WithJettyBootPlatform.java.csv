commented;modifiers;parameterAmount;loc;comment;code
false;public;3;12;;@Override public void configureTlsExtensions(SSLSocket sslSocket, String hostname, List<Protocol> protocols) {     List<String> names = alpnProtocolNames(protocols).     try {         Object alpnProvider = Proxy.newProxyInstance(Platform.class.getClassLoader(), new Class[] { clientProviderClass, serverProviderClass }, new AlpnProvider(names)).         putMethod.invoke(null, sslSocket, alpnProvider).     } catch (InvocationTargetException | IllegalAccessException e) {         throw new AssertionError("failed to set ALPN", e).     } }
false;public;1;7;;@Override public void afterHandshake(SSLSocket sslSocket) {     try {         removeMethod.invoke(null, sslSocket).     } catch (IllegalAccessException | InvocationTargetException e) {         throw new AssertionError("failed to remove ALPN", e).     } }
false;public;1;14;;@Override @Nullable public String getSelectedProtocol(SSLSocket socket) {     try {         AlpnProvider provider = (AlpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket)).         if (!provider.unsupported && provider.selected == null) {             Platform.get().log(INFO, "ALPN callback dropped: HTTP/2 is disabled. " + "Is alpn-boot on the boot class path?", null).             return null.         }         return provider.unsupported ? null : provider.selected.     } catch (InvocationTargetException | IllegalAccessException e) {         throw new AssertionError("failed to get ALPN selected protocol", e).     } }
false;public,static;0;18;;public static Platform buildIfSupported() {     // Find Jetty's ALPN extension for OpenJDK.     try {         String alpnClassName = "org.eclipse.jetty.alpn.ALPN".         Class<?> alpnClass = Class.forName(alpnClassName, true, null).         Class<?> providerClass = Class.forName(alpnClassName + "$Provider", true, null).         Class<?> clientProviderClass = Class.forName(alpnClassName + "$ClientProvider", true, null).         Class<?> serverProviderClass = Class.forName(alpnClassName + "$ServerProvider", true, null).         Method putMethod = alpnClass.getMethod("put", SSLSocket.class, providerClass).         Method getMethod = alpnClass.getMethod("get", SSLSocket.class).         Method removeMethod = alpnClass.getMethod("remove", SSLSocket.class).         return new Jdk8WithJettyBootPlatform(putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass).     } catch (ClassNotFoundException | NoSuchMethodException ignored) {     }     return null. }
false;public;3;32;;@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     String methodName = method.getName().     Class<?> returnType = method.getReturnType().     if (args == null) {         args = Util.EMPTY_STRING_ARRAY.     }     if (methodName.equals("supports") && boolean.class == returnType) {         // ALPN is supported.         return true.     } else if (methodName.equals("unsupported") && void.class == returnType) {         // Peer doesn't support ALPN.         this.unsupported = true.         return null.     } else if (methodName.equals("protocols") && args.length == 0) {         // Client advertises these protocols.         return protocols.     } else if ((methodName.equals("selectProtocol") || methodName.equals("select")) && String.class == returnType && args.length == 1 && args[0] instanceof List) {         List<?> peerProtocols = (List) args[0].         // Pick the first known protocol the peer advertises.         for (int i = 0, size = peerProtocols.size(). i < size. i++) {             String protocol = (String) peerProtocols.get(i).             if (protocols.contains(protocol)) {                 return selected = protocol.             }         }         // On no intersection, try peer's first protocol.         return selected = protocols.get(0).     } else if ((methodName.equals("protocolSelected") || methodName.equals("selected")) && args.length == 1) {         // Server selected this protocol.         this.selected = (String) args[0].         return null.     } else {         return method.invoke(this, args).     } }
