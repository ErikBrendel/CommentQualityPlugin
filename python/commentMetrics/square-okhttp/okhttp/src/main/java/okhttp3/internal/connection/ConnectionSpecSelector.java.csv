commented;modifiers;parameterAmount;loc;comment;code
true;;1;27;/**  * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate  * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.  *  * @throws IOException if the socket does not support any of the TLS modes available  */ ;/**  * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate  * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.  *  * @throws IOException if the socket does not support any of the TLS modes available  */ ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {     ConnectionSpec tlsConfiguration = null.     for (int i = nextModeIndex, size = connectionSpecs.size(). i < size. i++) {         ConnectionSpec connectionSpec = connectionSpecs.get(i).         if (connectionSpec.isCompatible(sslSocket)) {             tlsConfiguration = connectionSpec.             nextModeIndex = i + 1.             break.         }     }     if (tlsConfiguration == null) {         // protocols than was suggested by a prior socket).         throw new UnknownServiceException("Unable to find acceptable protocols. isFallback=" + isFallback + ", modes=" + connectionSpecs + ", supported protocols=" + Arrays.toString(sslSocket.getEnabledProtocols())).     }     isFallbackPossible = isFallbackPossible(sslSocket).     Internal.instance.apply(tlsConfiguration, sslSocket, isFallback).     return tlsConfiguration. }
true;;1;36;/**  * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to try,  * if any.  *  * @return {@code true} if the connection should be retried using {@link  * #configureSecureSocket(SSLSocket)} or {@code false} if not  */ ;/**  * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to try,  * if any.  *  * @return {@code true} if the connection should be retried using {@link  * #configureSecureSocket(SSLSocket)} or {@code false} if not  */ boolean connectionFailed(IOException e) {     // Any future attempt to connect using this strategy will be a fallback attempt.     isFallback = true.     if (!isFallbackPossible) {         return false.     }     // If there was a protocol problem, don't recover.     if (e instanceof ProtocolException) {         return false.     }     // ConnectionSpec: we assume it is unreachable.     if (e instanceof InterruptedIOException) {         return false.     }     // again with a different connection spec.     if (e instanceof SSLHandshakeException) {         // If the problem was a CertificateException from the X509TrustManager, do not retry.         if (e.getCause() instanceof CertificateException) {             return false.         }     }     if (e instanceof SSLPeerUnverifiedException) {         // e.g. a certificate pinning error.         return false.     }     // Retry for all other SSL failures.     return e instanceof SSLException. }
true;private;1;8;/**  * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks  * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the  * same capabilities as the supplied socket.  */ ;/**  * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks  * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the  * same capabilities as the supplied socket.  */ private boolean isFallbackPossible(SSLSocket socket) {     for (int i = nextModeIndex. i < connectionSpecs.size(). i++) {         if (connectionSpecs.get(i).isCompatible(socket)) {             return true.         }     }     return false. }
