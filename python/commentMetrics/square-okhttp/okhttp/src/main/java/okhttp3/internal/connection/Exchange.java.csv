commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public RealConnection connection() {     return codec.connection(). }
true;public;0;3;/**  * Returns true if the request body need not complete before the response body starts.  */ ;/**  * Returns true if the request body need not complete before the response body starts.  */ public boolean isDuplex() {     return duplex. }
false;public;1;11;;public void writeRequestHeaders(Request request) throws IOException {     try {         eventListener.requestHeadersStart(call).         codec.writeRequestHeaders(request).         eventListener.requestHeadersEnd(call, request).     } catch (IOException e) {         eventListener.requestFailed(call, e).         trackFailure(e).         throw e.     } }
false;public;2;7;;public Sink createRequestBody(Request request, boolean duplex) throws IOException {     this.duplex = duplex.     long contentLength = request.body().contentLength().     eventListener.requestBodyStart(call).     Sink rawRequestBody = codec.createRequestBody(request, contentLength).     return new RequestBodySink(rawRequestBody, contentLength). }
false;public;0;9;;public void flushRequest() throws IOException {     try {         codec.flushRequest().     } catch (IOException e) {         eventListener.requestFailed(call, e).         trackFailure(e).         throw e.     } }
false;public;0;9;;public void finishRequest() throws IOException {     try {         codec.finishRequest().     } catch (IOException e) {         eventListener.requestFailed(call, e).         trackFailure(e).         throw e.     } }
false;public;0;3;;public void responseHeadersStart() {     eventListener.responseHeadersStart(call). }
false;public;1;13;;@Nullable public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {     try {         Response.Builder result = codec.readResponseHeaders(expectContinue).         if (result != null) {             Internal.instance.initExchange(result, this).         }         return result.     } catch (IOException e) {         eventListener.responseFailed(call, e).         trackFailure(e).         throw e.     } }
false;public;1;3;;public void responseHeadersEnd(Response response) {     eventListener.responseHeadersEnd(call, response). }
false;public;1;14;;public ResponseBody openResponseBody(Response response) throws IOException {     try {         eventListener.responseBodyStart(call).         String contentType = response.header("Content-Type").         long contentLength = codec.reportedContentLength(response).         Source rawSource = codec.openResponseBodySource(response).         ResponseBodySource source = new ResponseBodySource(rawSource, contentLength).         return new RealResponseBody(contentType, contentLength, Okio.buffer(source)).     } catch (IOException e) {         eventListener.responseFailed(call, e).         trackFailure(e).         throw e.     } }
false;public;0;3;;public Headers trailers() throws IOException {     return codec.trailers(). }
false;public;0;4;;public RealWebSocket.Streams newWebSocketStreams() throws SocketException {     transmitter.timeoutEarlyExit().     return codec.connection().newWebSocketStreams(this). }
false;public;0;3;;public void noNewExchangesOnConnection() {     codec.connection().noNewExchanges(). }
false;public;0;3;;public void cancel() {     codec.cancel(). }
true;public;0;4;/**  * Revoke this exchange's access to streams. This is necessary when a follow-up request is  * required but the preceding exchange hasn't completed yet.  */ ;/**  * Revoke this exchange's access to streams. This is necessary when a follow-up request is  * required but the preceding exchange hasn't completed yet.  */ public void detachWithViolence() {     codec.cancel().     transmitter.exchangeMessageDone(this, true, true, null). }
false;;1;4;;void trackFailure(IOException e) {     finder.trackFailure().     codec.connection().trackFailure(e). }
false;;4;21;;@Nullable IOException bodyComplete(long bytesRead, boolean responseDone, boolean requestDone, @Nullable IOException e) {     if (e != null) {         trackFailure(e).     }     if (requestDone) {         if (e != null) {             eventListener.requestFailed(call, e).         } else {             eventListener.requestBodyEnd(call, bytesRead).         }     }     if (responseDone) {         if (e != null) {             eventListener.responseFailed(call, e).         } else {             eventListener.responseBodyEnd(call, bytesRead).         }     }     return transmitter.exchangeMessageDone(this, requestDone, responseDone, e). }
false;public;0;3;;public void noRequestBody() {     transmitter.exchangeMessageDone(this, true, false, null). }
false;public;2;13;;@Override public void write(Buffer source, long byteCount) throws IOException {     if (closed)         throw new IllegalStateException("closed").     if (contentLength != -1L && bytesReceived + byteCount > contentLength) {         throw new ProtocolException("expected " + contentLength + " bytes but received " + (bytesReceived + byteCount)).     }     try {         super.write(source, byteCount).         this.bytesReceived += byteCount.     } catch (IOException e) {         throw complete(e).     } }
false;public;0;7;;@Override public void flush() throws IOException {     try {         super.flush().     } catch (IOException e) {         throw complete(e).     } }
false;public;0;13;;@Override public void close() throws IOException {     if (closed)         return.     closed = true.     if (contentLength != -1L && bytesReceived != contentLength) {         throw new ProtocolException("unexpected end of stream").     }     try {         super.close().         complete(null).     } catch (IOException e) {         throw complete(e).     } }
false;private;1;5;;@Nullable private IOException complete(@Nullable IOException e) {     if (completed)         return e.     completed = true.     return bodyComplete(bytesReceived, false, true, e). }
false;public;2;25;;@Override public long read(Buffer sink, long byteCount) throws IOException {     if (closed)         throw new IllegalStateException("closed").     try {         long read = delegate().read(sink, byteCount).         if (read == -1L) {             complete(null).             return -1L.         }         long newBytesReceived = bytesReceived + read.         if (contentLength != -1L && newBytesReceived > contentLength) {             throw new ProtocolException("expected " + contentLength + " bytes but received " + newBytesReceived).         }         bytesReceived = newBytesReceived.         if (newBytesReceived == contentLength) {             complete(null).         }         return read.     } catch (IOException e) {         throw complete(e).     } }
false;public;0;10;;@Override public void close() throws IOException {     if (closed)         return.     closed = true.     try {         super.close().         complete(null).     } catch (IOException e) {         throw complete(e).     } }
false;;1;5;;@Nullable IOException complete(@Nullable IOException e) {     if (completed)         return e.     completed = true.     return bodyComplete(bytesReceived, true, false, e). }
