commented;modifiers;parameterAmount;loc;comment;code
true;public,synchronized;0;3;/**  * Returns the number of {@link Http2Stream#isOpen() open streams} on this connection.  */ ;/**  * Returns the number of {@link Http2Stream#isOpen() open streams} on this connection.  */ public synchronized int openStreamCount() {     return streams.size(). }
false;synchronized;1;3;;synchronized Http2Stream getStream(int id) {     return streams.get(id). }
false;synchronized;1;5;;synchronized Http2Stream removeStream(int streamId) {     Http2Stream stream = streams.remove(streamId).     // The removed stream may be blocked on a connection-wide window update.     notifyAll().     return stream. }
false;public,synchronized;0;3;;public synchronized int maxConcurrentStreams() {     return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE). }
false;synchronized;1;7;;synchronized void updateConnectionFlowControl(long read) {     unacknowledgedBytesRead += read.     if (unacknowledgedBytesRead >= okHttpSettings.getInitialWindowSize() / 2) {         writeWindowUpdateLater(0, unacknowledgedBytesRead).         unacknowledgedBytesRead = 0.     } }
true;public;3;5;/**  * Returns a new server-initiated stream.  *  * @param associatedStreamId the stream that triggered the sender to create this stream.  * @param out true to create an output stream that we can use to send data to the remote peer.  * Corresponds to {@code FLAG_FIN}.  */ ;/**  * Returns a new server-initiated stream.  *  * @param associatedStreamId the stream that triggered the sender to create this stream.  * @param out true to create an output stream that we can use to send data to the remote peer.  * Corresponds to {@code FLAG_FIN}.  */ public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {     if (client)         throw new IllegalStateException("Client cannot push requests.").     return newStream(associatedStreamId, requestHeaders, out). }
true;public;2;3;/**  * Returns a new locally-initiated stream.  * @param out true to create an output stream that we can use to send data to the remote peer.  * Corresponds to {@code FLAG_FIN}.  */ ;/**  * Returns a new locally-initiated stream.  * @param out true to create an output stream that we can use to send data to the remote peer.  * Corresponds to {@code FLAG_FIN}.  */ public Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {     return newStream(0, requestHeaders, out). }
false;private;3;39;;private Http2Stream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {     boolean outFinished = !out.     boolean inFinished = false.     boolean flushHeaders.     Http2Stream stream.     int streamId.     synchronized (writer) {         synchronized (this) {             if (nextStreamId > Integer.MAX_VALUE / 2) {                 shutdown(REFUSED_STREAM).             }             if (shutdown) {                 throw new ConnectionShutdownException().             }             streamId = nextStreamId.             nextStreamId += 2.             stream = new Http2Stream(streamId, this, outFinished, inFinished, null).             flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L.             if (stream.isOpen()) {                 streams.put(streamId, stream).             }         }         if (associatedStreamId == 0) {             writer.headers(outFinished, streamId, requestHeaders).         } else if (client) {             throw new IllegalArgumentException("client streams shouldn't have associated stream IDs").         } else {             // HTTP/2 has a PUSH_PROMISE frame.             writer.pushPromise(associatedStreamId, streamId, requestHeaders).         }     }     if (flushHeaders) {         writer.flush().     }     return stream. }
false;;3;4;;void writeHeaders(int streamId, boolean outFinished, List<Header> alternating) throws IOException {     writer.headers(outFinished, streamId, alternating). }
true;public;4;33;/**  * Callers of this method are not thread safe, and sometimes on application threads. Most often,  * this method will be called to send a buffer worth of data to the peer.  *  * <p>Writes are subject to the write window of the stream and the connection. Until there is a  * window sufficient to send {@code byteCount}, the caller will block. For example, a user of  * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's  * write window will block.  *  * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only  * use case for zero {@code byteCount} is closing a flushed output stream.  */ ;/**  * Callers of this method are not thread safe, and sometimes on application threads. Most often,  * this method will be called to send a buffer worth of data to the peer.  *  * <p>Writes are subject to the write window of the stream and the connection. Until there is a  * window sufficient to send {@code byteCount}, the caller will block. For example, a user of  * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's  * write window will block.  *  * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only  * use case for zero {@code byteCount} is closing a flushed output stream.  */ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount) throws IOException {     if (byteCount == 0) {         // Empty data frames are not flow-controlled.         writer.data(outFinished, streamId, buffer, 0).         return.     }     while (byteCount > 0) {         int toWrite.         synchronized (Http2Connection.this) {             try {                 while (bytesLeftInWriteWindow <= 0) {                     // that the stream has since been closed (such as if this write timed out.)                     if (!streams.containsKey(streamId)) {                         throw new IOException("stream closed").                     }                     // Wait until we receive a WINDOW_UPDATE.                     Http2Connection.this.wait().                 }             } catch (InterruptedException e) {                 // Retain interrupted status.                 Thread.currentThread().interrupt().                 throw new InterruptedIOException().             }             toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow).             toWrite = Math.min(toWrite, writer.maxDataLength()).             bytesLeftInWriteWindow -= toWrite.         }         byteCount -= toWrite.         writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite).     } }
false;public;0;7;;@Override public void execute() {     try {         writeSynReset(streamId, errorCode).     } catch (IOException e) {         failConnection().     } }
false;;2;15;;void writeSynResetLater(final int streamId, final ErrorCode errorCode) {     try {         writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", connectionName, streamId) {              @Override             public void execute() {                 try {                     writeSynReset(streamId, errorCode).                 } catch (IOException e) {                     failConnection().                 }             }         }).     } catch (RejectedExecutionException ignored) {     // This connection has been closed.     } }
false;;2;3;;void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {     writer.rstStream(streamId, statusCode). }
false;public;0;7;;@Override public void execute() {     try {         writer.windowUpdate(streamId, unacknowledgedBytesRead).     } catch (IOException e) {         failConnection().     } }
false;;2;16;;void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {     try {         writerExecutor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", connectionName, streamId) {              @Override             public void execute() {                 try {                     writer.windowUpdate(streamId, unacknowledgedBytesRead).                 } catch (IOException e) {                     failConnection().                 }             }         }).     } catch (RejectedExecutionException ignored) {     // This connection has been closed.     } }
false;public;0;3;;@Override public void execute() {     writePing(reply, payload1, payload2). }
false;;3;19;;void writePing(boolean reply, int payload1, int payload2) {     if (!reply) {         boolean failedDueToMissingPong.         synchronized (this) {             failedDueToMissingPong = awaitingPong.             awaitingPong = true.         }         if (failedDueToMissingPong) {             failConnection().             return.         }     }     try {         writer.ping(reply, payload1, payload2).     } catch (IOException e) {         failConnection().     } }
true;;0;4;/**  * For testing: sends a ping and waits for a pong.  */ ;/**  * For testing: sends a ping and waits for a pong.  */ void writePingAndAwaitPong() throws InterruptedException {     writePing(false, 0x4f4b6f6b, /* "OKok" */     0xf09f8da9).     awaitPong(). }
true;synchronized;0;5;/**  * For testing: waits until {@code requiredPongCount} pings have been received from the peer.  */ ;/**  * For testing: waits until {@code requiredPongCount} pings have been received from the peer.  */ synchronized void awaitPong() throws InterruptedException {     while (awaitingPong) {         wait().     } }
false;public;0;3;;public void flush() throws IOException {     writer.flush(). }
true;public;1;15;/**  * Degrades this connection such that new streams can neither be created locally, nor accepted  * from the remote peer. Existing streams are not impacted. This is intended to permit an endpoint  * to gracefully stop accepting new requests without harming previously established streams.  */ ;/**  * Degrades this connection such that new streams can neither be created locally, nor accepted  * from the remote peer. Existing streams are not impacted. This is intended to permit an endpoint  * to gracefully stop accepting new requests without harming previously established streams.  */ public void shutdown(ErrorCode statusCode) throws IOException {     synchronized (writer) {         int lastGoodStreamId.         synchronized (this) {             if (shutdown) {                 return.             }             shutdown = true.             lastGoodStreamId = this.lastGoodStreamId.         }         // TODO: propagate exception message into debugData.         // TODO: configure a timeout on the reader so that it doesnâ€™t block forever.         writer.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY).     } }
true;public;0;3;/**  * Closes this connection. This cancels all open streams and unanswered pings. It closes the  * underlying input and output streams and shuts down internal executor services.  */ ;/**  * Closes this connection. This cancels all open streams and unanswered pings. It closes the  * underlying input and output streams and shuts down internal executor services.  */ @Override public void close() throws IOException {     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL). }
false;;2;47;;void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {     assert (!Thread.holdsLock(this)).     IOException thrown = null.     try {         shutdown(connectionCode).     } catch (IOException e) {         thrown = e.     }     Http2Stream[] streamsToClose = null.     synchronized (this) {         if (!streams.isEmpty()) {             streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]).             streams.clear().         }     }     if (streamsToClose != null) {         for (Http2Stream stream : streamsToClose) {             try {                 stream.close(streamCode).             } catch (IOException e) {                 if (thrown != null)                     thrown = e.             }         }     }     // Close the writer to release its resources (such as deflaters).     try {         writer.close().     } catch (IOException e) {         if (thrown == null)             thrown = e.     }     // Close the socket to break out the reader thread, which will clean up after itself.     try {         socket.close().     } catch (IOException e) {         thrown = e.     }     // Release the threads.     writerExecutor.shutdown().     pushExecutor.shutdown().     if (thrown != null)         throw thrown. }
false;private;0;6;;private void failConnection() {     try {         close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR).     } catch (IOException ignored) {     } }
true;public;0;3;/**  * Sends any initial frames and starts reading frames from the remote peer. This should be called  * after {@link Builder#build} for all new connections.  */ ;/**  * Sends any initial frames and starts reading frames from the remote peer. This should be called  * after {@link Builder#build} for all new connections.  */ public void start() throws IOException {     start(true). }
true;;1;11;/**  * @param sendConnectionPreface true to send connection preface frames. This should always be true  *     except for in tests that don't check for a connection preface.  */ ;/**  * @param sendConnectionPreface true to send connection preface frames. This should always be true  *     except for in tests that don't check for a connection preface.  */ void start(boolean sendConnectionPreface) throws IOException {     if (sendConnectionPreface) {         writer.connectionPreface().         writer.settings(okHttpSettings).         int windowSize = okHttpSettings.getInitialWindowSize().         if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {             writer.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE).         }     }     // Not a daemon thread.     new Thread(readerRunnable).start(). }
true;public;1;11;/**  * Merges {@code settings} into this peer's settings and sends them to the remote peer.  */ ;/**  * Merges {@code settings} into this peer's settings and sends them to the remote peer.  */ public void setSettings(Settings settings) throws IOException {     synchronized (writer) {         synchronized (this) {             if (shutdown) {                 throw new ConnectionShutdownException().             }             okHttpSettings.merge(settings).         }         writer.settings(settings).     } }
false;public,synchronized;0;3;;public synchronized boolean isShutdown() {     return shutdown. }
false;public;1;8;;public Builder socket(Socket socket) throws IOException {     SocketAddress remoteSocketAddress = socket.getRemoteSocketAddress().     String connectionName = remoteSocketAddress instanceof InetSocketAddress ? ((InetSocketAddress) remoteSocketAddress).getHostName() : remoteSocketAddress.toString().     return socket(socket, connectionName, Okio.buffer(Okio.source(socket)), Okio.buffer(Okio.sink(socket))). }
false;public;4;8;;public Builder socket(Socket socket, String connectionName, BufferedSource source, BufferedSink sink) {     this.socket = socket.     this.connectionName = connectionName.     this.source = source.     this.sink = sink.     return this. }
false;public;1;4;;public Builder listener(Listener listener) {     this.listener = listener.     return this. }
false;public;1;4;;public Builder pushObserver(PushObserver pushObserver) {     this.pushObserver = pushObserver.     return this. }
false;public;1;4;;public Builder pingIntervalMillis(int pingIntervalMillis) {     this.pingIntervalMillis = pingIntervalMillis.     return this. }
false;public;0;3;;public Http2Connection build() {     return new Http2Connection(this). }
false;protected;0;20;;@Override protected void execute() {     ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR.     ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR.     try {         reader.readConnectionPreface(this).         while (reader.nextFrame(false, this)) {         }         connectionErrorCode = ErrorCode.NO_ERROR.         streamErrorCode = ErrorCode.CANCEL.     } catch (IOException e) {         connectionErrorCode = ErrorCode.PROTOCOL_ERROR.         streamErrorCode = ErrorCode.PROTOCOL_ERROR.     } finally {         try {             close(connectionErrorCode, streamErrorCode).         } catch (IOException ignored) {         }         Util.closeQuietly(reader).     } }
false;public;4;18;;@Override public void data(boolean inFinished, int streamId, BufferedSource source, int length) throws IOException {     if (pushedStream(streamId)) {         pushDataLater(streamId, source, length, inFinished).         return.     }     Http2Stream dataStream = getStream(streamId).     if (dataStream == null) {         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR).         updateConnectionFlowControl(length).         source.skip(length).         return.     }     dataStream.receiveData(source, length).     if (inFinished) {         dataStream.receiveHeaders(Util.EMPTY_HEADERS, true).     } }
false;public;0;12;;@Override public void execute() {     try {         listener.onStream(newStream).     } catch (IOException e) {         Platform.get().log(INFO, "Http2Connection.Listener failure for " + connectionName, e).         try {             newStream.close(ErrorCode.PROTOCOL_ERROR).         } catch (IOException ignored) {         }     } }
false;public;4;48;;@Override public void headers(boolean inFinished, int streamId, int associatedStreamId, List<Header> headerBlock) {     if (pushedStream(streamId)) {         pushHeadersLater(streamId, headerBlock, inFinished).         return.     }     Http2Stream stream.     synchronized (Http2Connection.this) {         stream = getStream(streamId).         if (stream == null) {             // If we're shutdown, don't bother with this stream.             if (shutdown)                 return.             // If the stream ID is less than the last created ID, assume it's already closed.             if (streamId <= lastGoodStreamId)                 return.             // If the stream ID is in the client's namespace, assume it's already closed.             if (streamId % 2 == nextStreamId % 2)                 return.             // Create a stream.             Headers headers = Util.toHeaders(headerBlock).             final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this, false, inFinished, headers).             lastGoodStreamId = streamId.             streams.put(streamId, newStream).             listenerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", connectionName, streamId) {                  @Override                 public void execute() {                     try {                         listener.onStream(newStream).                     } catch (IOException e) {                         Platform.get().log(INFO, "Http2Connection.Listener failure for " + connectionName, e).                         try {                             newStream.close(ErrorCode.PROTOCOL_ERROR).                         } catch (IOException ignored) {                         }                     }                 }             }).             return.         }     }     // Update an existing stream.     stream.receiveHeaders(Util.toHeaders(headerBlock), inFinished). }
false;public;2;10;;@Override public void rstStream(int streamId, ErrorCode errorCode) {     if (pushedStream(streamId)) {         pushResetLater(streamId, errorCode).         return.     }     Http2Stream rstStream = removeStream(streamId).     if (rstStream != null) {         rstStream.receiveRstStream(errorCode).     } }
false;public;0;3;;@Override public void execute() {     listener.onSettings(Http2Connection.this). }
false;public;2;32;;@Override public void settings(boolean clearPrevious, Settings newSettings) {     long delta = 0.     Http2Stream[] streamsToNotify = null.     synchronized (Http2Connection.this) {         int priorWriteWindowSize = peerSettings.getInitialWindowSize().         if (clearPrevious)             peerSettings.clear().         peerSettings.merge(newSettings).         applyAndAckSettings(newSettings).         int peerInitialWindowSize = peerSettings.getInitialWindowSize().         if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {             delta = peerInitialWindowSize - priorWriteWindowSize.             if (!receivedInitialPeerSettings) {                 receivedInitialPeerSettings = true.             }             if (!streams.isEmpty()) {                 streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]).             }         }         listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", connectionName) {              @Override             public void execute() {                 listener.onSettings(Http2Connection.this).             }         }).     }     if (streamsToNotify != null && delta != 0) {         for (Http2Stream stream : streamsToNotify) {             synchronized (stream) {                 stream.addBytesToWriteWindow(delta).             }         }     } }
false;public;0;7;;@Override public void execute() {     try {         writer.applyAndAckSettings(peerSettings).     } catch (IOException e) {         failConnection().     } }
false;private;1;15;;private void applyAndAckSettings(final Settings peerSettings) {     try {         writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", connectionName) {              @Override             public void execute() {                 try {                     writer.applyAndAckSettings(peerSettings).                 } catch (IOException e) {                     failConnection().                 }             }         }).     } catch (RejectedExecutionException ignored) {     // This connection has been closed.     } }
false;public;0;3;;@Override public void ackSettings() { // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT. }
false;public;3;15;;@Override public void ping(boolean reply, int payload1, int payload2) {     if (reply) {         synchronized (Http2Connection.this) {             awaitingPong = false.             Http2Connection.this.notifyAll().         }     } else {         try {             // Send a reply to a client ping if this is a server and vice versa.             writerExecutor.execute(new PingRunnable(true, payload1, payload2)).         } catch (RejectedExecutionException ignored) {         // This connection has been closed.         }     } }
false;public;3;19;;@Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {     if (debugData.size() > 0) {     // TODO: log the debugData     }     // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().     Http2Stream[] streamsCopy.     synchronized (Http2Connection.this) {         streamsCopy = streams.values().toArray(new Http2Stream[streams.size()]).         shutdown = true.     }     // Fail all streams created after the last good stream ID.     for (Http2Stream http2Stream : streamsCopy) {         if (http2Stream.getId() > lastGoodStreamId && http2Stream.isLocallyInitiated()) {             http2Stream.receiveRstStream(REFUSED_STREAM).             removeStream(http2Stream.getId()).         }     } }
false;public;2;15;;@Override public void windowUpdate(int streamId, long windowSizeIncrement) {     if (streamId == 0) {         synchronized (Http2Connection.this) {             bytesLeftInWriteWindow += windowSizeIncrement.             Http2Connection.this.notifyAll().         }     } else {         Http2Stream stream = getStream(streamId).         if (stream != null) {             synchronized (stream) {                 stream.addBytesToWriteWindow(windowSizeIncrement).             }         }     } }
false;public;4;4;;@Override public void priority(int streamId, int streamDependency, int weight, boolean exclusive) { // TODO: honor priority. }
false;public;3;4;;@Override public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {     pushRequestLater(promisedStreamId, requestHeaders). }
false;public;6;4;;@Override public void alternateService(int streamId, String origin, ByteString protocol, String host, int port, long maxAge) { // TODO: register alternate service. }
true;;1;3;/**  * Even, positive numbered streams are pushed streams in HTTP/2.  */ ;/**  * Even, positive numbered streams are pushed streams in HTTP/2.  */ boolean pushedStream(int streamId) {     return streamId != 0 && (streamId & 1) == 0. }
false;public;0;12;;@Override public void execute() {     boolean cancel = pushObserver.onRequest(streamId, requestHeaders).     try {         if (cancel) {             writer.rstStream(streamId, ErrorCode.CANCEL).             synchronized (Http2Connection.this) {                 currentPushRequests.remove(streamId).             }         }     } catch (IOException ignored) {     } }
false;;2;28;;void pushRequestLater(final int streamId, final List<Header> requestHeaders) {     synchronized (this) {         if (currentPushRequests.contains(streamId)) {             writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR).             return.         }         currentPushRequests.add(streamId).     }     try {         pushExecutorExecute(new NamedRunnable("OkHttp %s Push Request[%s]", connectionName, streamId) {              @Override             public void execute() {                 boolean cancel = pushObserver.onRequest(streamId, requestHeaders).                 try {                     if (cancel) {                         writer.rstStream(streamId, ErrorCode.CANCEL).                         synchronized (Http2Connection.this) {                             currentPushRequests.remove(streamId).                         }                     }                 } catch (IOException ignored) {                 }             }         }).     } catch (RejectedExecutionException ignored) {     // This connection has been closed.     } }
false;public;0;12;;@Override public void execute() {     boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished).     try {         if (cancel)             writer.rstStream(streamId, ErrorCode.CANCEL).         if (cancel || inFinished) {             synchronized (Http2Connection.this) {                 currentPushRequests.remove(streamId).             }         }     } catch (IOException ignored) {     } }
false;;3;22;;void pushHeadersLater(final int streamId, final List<Header> requestHeaders, final boolean inFinished) {     try {         pushExecutorExecute(new NamedRunnable("OkHttp %s Push Headers[%s]", connectionName, streamId) {              @Override             public void execute() {                 boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished).                 try {                     if (cancel)                         writer.rstStream(streamId, ErrorCode.CANCEL).                     if (cancel || inFinished) {                         synchronized (Http2Connection.this) {                             currentPushRequests.remove(streamId).                         }                     }                 } catch (IOException ignored) {                 }             }         }).     } catch (RejectedExecutionException ignored) {     // This connection has been closed.     } }
false;public;0;12;;@Override public void execute() {     try {         boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished).         if (cancel)             writer.rstStream(streamId, ErrorCode.CANCEL).         if (cancel || inFinished) {             synchronized (Http2Connection.this) {                 currentPushRequests.remove(streamId).             }         }     } catch (IOException ignored) {     } }
true;;4;21;/**  * Eagerly reads {@code byteCount} bytes from the source before launching a background task to  * process the data.  This avoids corrupting the stream.  */ ;/**  * Eagerly reads {@code byteCount} bytes from the source before launching a background task to  * process the data.  This avoids corrupting the stream.  */ void pushDataLater(final int streamId, final BufferedSource source, final int byteCount, final boolean inFinished) throws IOException {     final Buffer buffer = new Buffer().     // Eagerly read the frame before firing client thread.     source.require(byteCount).     source.read(buffer, byteCount).     if (buffer.size() != byteCount)         throw new IOException(buffer.size() + " != " + byteCount).     pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", connectionName, streamId) {          @Override         public void execute() {             try {                 boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished).                 if (cancel)                     writer.rstStream(streamId, ErrorCode.CANCEL).                 if (cancel || inFinished) {                     synchronized (Http2Connection.this) {                         currentPushRequests.remove(streamId).                     }                 }             } catch (IOException ignored) {             }         }     }). }
false;public;0;6;;@Override public void execute() {     pushObserver.onReset(streamId, errorCode).     synchronized (Http2Connection.this) {         currentPushRequests.remove(streamId).     } }
false;;2;10;;void pushResetLater(final int streamId, final ErrorCode errorCode) {     pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", connectionName, streamId) {          @Override         public void execute() {             pushObserver.onReset(streamId, errorCode).             synchronized (Http2Connection.this) {                 currentPushRequests.remove(streamId).             }         }     }). }
false;private,synchronized;1;5;;private synchronized void pushExecutorExecute(NamedRunnable namedRunnable) {     if (!isShutdown()) {         pushExecutor.execute(namedRunnable).     } }
false;public;1;3;;@Override public void onStream(Http2Stream stream) throws IOException {     stream.close(REFUSED_STREAM). }
true;public,abstract;1;1;/**  * Handle a new stream from this connection's peer. Implementations should respond by either  * {@linkplain Http2Stream#writeHeaders replying to the stream} or {@linkplain  * Http2Stream#close closing it}. This response does not need to be synchronous.  */ ;/**  * Handle a new stream from this connection's peer. Implementations should respond by either  * {@linkplain Http2Stream#writeHeaders replying to the stream} or {@linkplain  * Http2Stream#close closing it}. This response does not need to be synchronous.  */ public abstract void onStream(Http2Stream stream) throws IOException.
true;public;1;2;/**  * Notification that the connection's peer's settings may have changed. Implementations should  * take appropriate action to handle the updated settings.  *  * <p>It is the implementation's responsibility to handle concurrent calls to this method. A  * remote peer that sends multiple settings frames will trigger multiple calls to this method,  * and those calls are not necessarily serialized.  */ ;/**  * Notification that the connection's peer's settings may have changed. Implementations should  * take appropriate action to handle the updated settings.  *  * <p>It is the implementation's responsibility to handle concurrent calls to this method. A  * remote peer that sends multiple settings frames will trigger multiple calls to this method,  * and those calls are not necessarily serialized.  */ public void onSettings(Http2Connection connection) { }
