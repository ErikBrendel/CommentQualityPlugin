commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;@Override @Nullable public Response get(Request request) throws IOException {     return Cache.this.get(request). }
false;public;1;3;;@Override @Nullable public CacheRequest put(Response response) throws IOException {     return Cache.this.put(response). }
false;public;1;3;;@Override public void remove(Request request) throws IOException {     Cache.this.remove(request). }
false;public;2;3;;@Override public void update(Response cached, Response network) {     Cache.this.update(cached, network). }
false;public;0;3;;@Override public void trackConditionalCacheHit() {     Cache.this.trackConditionalCacheHit(). }
false;public;1;3;;@Override public void trackResponse(CacheStrategy cacheStrategy) {     Cache.this.trackResponse(cacheStrategy). }
false;public,static;1;3;;public static String key(HttpUrl url) {     return ByteString.encodeUtf8(url.toString()).md5().hex(). }
false;;1;30;;@Nullable Response get(Request request) {     String key = key(request.url()).     DiskLruCache.Snapshot snapshot.     Entry entry.     try {         snapshot = cache.get(key).         if (snapshot == null) {             return null.         }     } catch (IOException e) {         // Give up because the cache cannot be read.         return null.     }     try {         entry = new Entry(snapshot.getSource(ENTRY_METADATA)).     } catch (IOException e) {         Util.closeQuietly(snapshot).         return null.     }     Response response = entry.response(snapshot).     if (!entry.matches(request, response)) {         Util.closeQuietly(response.body()).         return null.     }     return response. }
false;;1;36;;@Nullable CacheRequest put(Response response) {     String requestMethod = response.request().method().     if (HttpMethod.invalidatesCache(response.request().method())) {         try {             remove(response.request()).         } catch (IOException ignored) {         // The cache cannot be written.         }         return null.     }     if (!requestMethod.equals("GET")) {         // so is high and the benefit is low.         return null.     }     if (HttpHeaders.hasVaryAll(response)) {         return null.     }     Entry entry = new Entry(response).     DiskLruCache.Editor editor = null.     try {         editor = cache.edit(key(response.request().url())).         if (editor == null) {             return null.         }         entry.writeTo(editor).         return new CacheRequestImpl(editor).     } catch (IOException e) {         abortQuietly(editor).         return null.     } }
false;;1;3;;void remove(Request request) throws IOException {     cache.remove(key(request.url())). }
false;;2;14;;void update(Response cached, Response network) {     Entry entry = new Entry(network).     DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot.     DiskLruCache.Editor editor = null.     try {         // Returns null if snapshot is not current.         editor = snapshot.edit().         if (editor != null) {             entry.writeTo(editor).             editor.commit().         }     } catch (IOException e) {         abortQuietly(editor).     } }
false;private;1;9;;private void abortQuietly(@Nullable DiskLruCache.Editor editor) {     // Give up because the cache cannot be written.     try {         if (editor != null) {             editor.abort().         }     } catch (IOException ignored) {     } }
true;public;0;3;/**  * Initialize the cache. This will include reading the journal files from the storage and building  * up the necessary in-memory cache information.  *  * <p>The initialization time may vary depending on the journal file size and the current actual  * cache size. The application needs to be aware of calling this function during the  * initialization phase and preferably in a background worker thread.  *  * <p>Note that if the application chooses to not call this method to initialize the cache. By  * default, the okhttp will perform lazy initialization upon the first usage of the cache.  */ ;/**  * Initialize the cache. This will include reading the journal files from the storage and building  * up the necessary in-memory cache information.  *  * <p>The initialization time may vary depending on the journal file size and the current actual  * cache size. The application needs to be aware of calling this function during the  * initialization phase and preferably in a background worker thread.  *  * <p>Note that if the application chooses to not call this method to initialize the cache. By  * default, the okhttp will perform lazy initialization upon the first usage of the cache.  */ public void initialize() throws IOException {     cache.initialize(). }
true;public;0;3;/**  * Closes the cache and deletes all of its stored values. This will delete all files in the cache  * directory including files that weren't created by the cache.  */ ;/**  * Closes the cache and deletes all of its stored values. This will delete all files in the cache  * directory including files that weren't created by the cache.  */ public void delete() throws IOException {     cache.delete(). }
true;public;0;3;/**  * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,  * but the corresponding responses will not be stored.  */ ;/**  * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,  * but the corresponding responses will not be stored.  */ public void evictAll() throws IOException {     cache.evictAll(). }
false;public;0;17;;@Override public boolean hasNext() {     if (nextUrl != null)         return true.     // Prevent delegate.remove() on the wrong item!     canRemove = false.     while (delegate.hasNext()) {         try (DiskLruCache.Snapshot snapshot = delegate.next()) {             BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA)).             nextUrl = metadata.readUtf8LineStrict().             return true.         } catch (IOException ignored) {         // We couldn't read the metadata for this snapshot. possibly because the host filesystem         // has disappeared! Skip it.         }     }     return false. }
false;public;0;7;;@Override public String next() {     if (!hasNext())         throw new NoSuchElementException().     String result = nextUrl.     nextUrl = null.     canRemove = true.     return result. }
false;public;0;4;;@Override public void remove() {     if (!canRemove)         throw new IllegalStateException("remove() before next()").     delegate.remove(). }
true;public;0;39;/**  * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code  * ConcurrentModificationException}, but if new responses are added while iterating, their URLs  * will not be returned. If existing responses are evicted during iteration, they will be absent  * (unless they were already returned).  *  * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts  * the corresponding response from the cache. Use this to evict selected responses.  */ ;/**  * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code  * ConcurrentModificationException}, but if new responses are added while iterating, their URLs  * will not be returned. If existing responses are evicted during iteration, they will be absent  * (unless they were already returned).  *  * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts  * the corresponding response from the cache. Use this to evict selected responses.  */ public Iterator<String> urls() throws IOException {     return new Iterator<String>() {          final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots().          @Nullable         String nextUrl.          boolean canRemove.          @Override         public boolean hasNext() {             if (nextUrl != null)                 return true.             // Prevent delegate.remove() on the wrong item!             canRemove = false.             while (delegate.hasNext()) {                 try (DiskLruCache.Snapshot snapshot = delegate.next()) {                     BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA)).                     nextUrl = metadata.readUtf8LineStrict().                     return true.                 } catch (IOException ignored) {                 // We couldn't read the metadata for this snapshot. possibly because the host filesystem                 // has disappeared! Skip it.                 }             }             return false.         }          @Override         public String next() {             if (!hasNext())                 throw new NoSuchElementException().             String result = nextUrl.             nextUrl = null.             canRemove = true.             return result.         }          @Override         public void remove() {             if (!canRemove)                 throw new IllegalStateException("remove() before next()").             delegate.remove().         }     }. }
false;public,synchronized;0;3;;public synchronized int writeAbortCount() {     return writeAbortCount. }
false;public,synchronized;0;3;;public synchronized int writeSuccessCount() {     return writeSuccessCount. }
false;public;0;3;;public long size() throws IOException {     return cache.size(). }
true;public;0;3;/**  * Max size of the cache (in bytes).  */ ;/**  * Max size of the cache (in bytes).  */ public long maxSize() {     return cache.getMaxSize(). }
false;public;0;3;;@Override public void flush() throws IOException {     cache.flush(). }
false;public;0;3;;@Override public void close() throws IOException {     cache.close(). }
false;public;0;3;;public File directory() {     return cache.getDirectory(). }
false;public;0;3;;public boolean isClosed() {     return cache.isClosed(). }
false;synchronized;1;11;;synchronized void trackResponse(CacheStrategy cacheStrategy) {     requestCount++.     if (cacheStrategy.networkRequest != null) {         // If this is a conditional request, we'll increment hitCount if/when it hits.         networkCount++.     } else if (cacheStrategy.cacheResponse != null) {         // This response uses the cache and not the network. That's a cache hit.         hitCount++.     } }
false;synchronized;0;3;;synchronized void trackConditionalCacheHit() {     hitCount++. }
false;public,synchronized;0;3;;public synchronized int networkCount() {     return networkCount. }
false;public,synchronized;0;3;;public synchronized int hitCount() {     return hitCount. }
false;public,synchronized;0;3;;public synchronized int requestCount() {     return requestCount. }
false;public;0;11;;@Override public void close() throws IOException {     synchronized (Cache.this) {         if (done) {             return.         }         done = true.         writeSuccessCount++.     }     super.close().     editor.commit(). }
false;public;0;14;;@Override public void abort() {     synchronized (Cache.this) {         if (done) {             return.         }         done = true.         writeAbortCount++.     }     Util.closeQuietly(cacheOut).     try {         editor.abort().     } catch (IOException ignored) {     } }
false;public;0;3;;@Override public Sink body() {     return body. }
false;public;1;45;;public void writeTo(DiskLruCache.Editor editor) throws IOException {     BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA)).     sink.writeUtf8(url).writeByte('\n').     sink.writeUtf8(requestMethod).writeByte('\n').     sink.writeDecimalLong(varyHeaders.size()).writeByte('\n').     for (int i = 0, size = varyHeaders.size(). i < size. i++) {         sink.writeUtf8(varyHeaders.name(i)).writeUtf8(": ").writeUtf8(varyHeaders.value(i)).writeByte('\n').     }     sink.writeUtf8(new StatusLine(protocol, code, message).toString()).writeByte('\n').     sink.writeDecimalLong(responseHeaders.size() + 2).writeByte('\n').     for (int i = 0, size = responseHeaders.size(). i < size. i++) {         sink.writeUtf8(responseHeaders.name(i)).writeUtf8(": ").writeUtf8(responseHeaders.value(i)).writeByte('\n').     }     sink.writeUtf8(SENT_MILLIS).writeUtf8(": ").writeDecimalLong(sentRequestMillis).writeByte('\n').     sink.writeUtf8(RECEIVED_MILLIS).writeUtf8(": ").writeDecimalLong(receivedResponseMillis).writeByte('\n').     if (isHttps()) {         sink.writeByte('\n').         sink.writeUtf8(handshake.cipherSuite().javaName()).writeByte('\n').         writeCertList(sink, handshake.peerCertificates()).         writeCertList(sink, handshake.localCertificates()).         sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n').     }     sink.close(). }
false;private;0;3;;private boolean isHttps() {     return url.startsWith("https://"). }
false;private;1;18;;private List<Certificate> readCertificateList(BufferedSource source) throws IOException {     int length = readInt(source).     // OkHttp v1.2 used -1 to indicate null.     if (length == -1)         return Collections.emptyList().     try {         CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509").         List<Certificate> result = new ArrayList<>(length).         for (int i = 0. i < length. i++) {             String line = source.readUtf8LineStrict().             Buffer bytes = new Buffer().             bytes.write(ByteString.decodeBase64(line)).             result.add(certificateFactory.generateCertificate(bytes.inputStream())).         }         return result.     } catch (CertificateException e) {         throw new IOException(e.getMessage()).     } }
false;private;2;15;;private void writeCertList(BufferedSink sink, List<Certificate> certificates) throws IOException {     try {         sink.writeDecimalLong(certificates.size()).writeByte('\n').         for (int i = 0, size = certificates.size(). i < size. i++) {             byte[] bytes = certificates.get(i).getEncoded().             String line = ByteString.of(bytes).base64().             sink.writeUtf8(line).writeByte('\n').         }     } catch (CertificateEncodingException e) {         throw new IOException(e.getMessage()).     } }
false;public;2;5;;public boolean matches(Request request, Response response) {     return url.equals(request.url().toString()) && requestMethod.equals(request.method()) && HttpHeaders.varyMatches(response, varyHeaders, request). }
false;public;1;20;;public Response response(DiskLruCache.Snapshot snapshot) {     String contentType = responseHeaders.get("Content-Type").     String contentLength = responseHeaders.get("Content-Length").     Request cacheRequest = new Request.Builder().url(url).method(requestMethod, null).headers(varyHeaders).build().     return new Response.Builder().request(cacheRequest).protocol(protocol).code(code).message(message).headers(responseHeaders).body(new CacheResponseBody(snapshot, contentType, contentLength)).handshake(handshake).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(receivedResponseMillis).build(). }
false;static;1;12;;static int readInt(BufferedSource source) throws IOException {     try {         long result = source.readDecimalLong().         String line = source.readUtf8LineStrict().         if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {             throw new IOException("expected an int but was \"" + result + line + "\"").         }         return (int) result.     } catch (NumberFormatException e) {         throw new IOException(e.getMessage()).     } }
false;public;0;4;;@Override public void close() throws IOException {     snapshot.close().     super.close(). }
false;public;0;3;;@Override public MediaType contentType() {     return contentType != null ? MediaType.parse(contentType) : null. }
false;public;0;7;;@Override public long contentLength() {     try {         return contentLength != null ? Long.parseLong(contentLength) : -1.     } catch (NumberFormatException e) {         return -1.     } }
false;public;0;3;;@Override public BufferedSource source() {     return bodySource. }
