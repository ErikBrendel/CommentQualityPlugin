commented;modifiers;parameterAmount;loc;comment;code
false;;1;1;;void onReadMessage(String text) throws IOException.
false;;1;1;;void onReadMessage(ByteString bytes) throws IOException.
false;;1;1;;void onReadPing(ByteString buffer).
false;;1;1;;void onReadPong(ByteString buffer).
false;;2;1;;void onReadClose(int code, String reason).
true;;0;8;/**  * Process the next protocol frame.  *  * <ul>  *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.  *     <li>If it is a message frame this will result in a single call to {@link  *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved  *         control frame will result in a corresponding call to {@link FrameCallback}.  * </ul>  */ ;/**  * Process the next protocol frame.  *  * <ul>  *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.  *     <li>If it is a message frame this will result in a single call to {@link  *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved  *         control frame will result in a corresponding call to {@link FrameCallback}.  * </ul>  */ void processNextFrame() throws IOException {     readHeader().     if (isControlFrame) {         readControlFrame().     } else {         readMessageFrame().     } }
false;private;0;61;;private void readHeader() throws IOException {     if (closed)         throw new IOException("closed").     // Disable the timeout to read the first byte of a new frame.     int b0.     long timeoutBefore = source.timeout().timeoutNanos().     source.timeout().clearTimeout().     try {         b0 = source.readByte() & 0xff.     } finally {         source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS).     }     opcode = b0 & B0_MASK_OPCODE.     isFinalFrame = (b0 & B0_FLAG_FIN) != 0.     isControlFrame = (b0 & OPCODE_FLAG_CONTROL) != 0.     // Control frames must be final frames (cannot contain continuations).     if (isControlFrame && !isFinalFrame) {         throw new ProtocolException("Control frames must be final.").     }     boolean reservedFlag1 = (b0 & B0_FLAG_RSV1) != 0.     boolean reservedFlag2 = (b0 & B0_FLAG_RSV2) != 0.     boolean reservedFlag3 = (b0 & B0_FLAG_RSV3) != 0.     if (reservedFlag1 || reservedFlag2 || reservedFlag3) {         // Reserved flags are for extensions which we currently do not support.         throw new ProtocolException("Reserved flags are unsupported.").     }     int b1 = source.readByte() & 0xff.     boolean isMasked = (b1 & B1_FLAG_MASK) != 0.     if (isMasked == isClient) {         // Masked payloads must be read on the server. Unmasked payloads must be read on the client.         throw new ProtocolException(isClient ? "Server-sent frames must not be masked." : "Client-sent frames must be masked.").     }     // Get frame length, optionally reading from follow-up bytes if indicated by special values.     frameLength = b1 & B1_MASK_LENGTH.     if (frameLength == PAYLOAD_SHORT) {         // Value is unsigned.         frameLength = source.readShort() & 0xffffL.     } else if (frameLength == PAYLOAD_LONG) {         frameLength = source.readLong().         if (frameLength < 0) {             throw new ProtocolException("Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF").         }     }     if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {         throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.").     }     if (isMasked) {         // Read the masking key as bytes so that they can be used directly for unmasking.         source.readFully(maskKey).     } }
false;private;0;38;;private void readControlFrame() throws IOException {     if (frameLength > 0) {         source.readFully(controlFrameBuffer, frameLength).         if (!isClient) {             controlFrameBuffer.readAndWriteUnsafe(maskCursor).             maskCursor.seek(0).             toggleMask(maskCursor, maskKey).             maskCursor.close().         }     }     switch(opcode) {         case OPCODE_CONTROL_PING:             frameCallback.onReadPing(controlFrameBuffer.readByteString()).             break.         case OPCODE_CONTROL_PONG:             frameCallback.onReadPong(controlFrameBuffer.readByteString()).             break.         case OPCODE_CONTROL_CLOSE:             int code = CLOSE_NO_STATUS_CODE.             String reason = "".             long bufferSize = controlFrameBuffer.size().             if (bufferSize == 1) {                 throw new ProtocolException("Malformed close payload length of 1.").             } else if (bufferSize != 0) {                 code = controlFrameBuffer.readShort().                 reason = controlFrameBuffer.readUtf8().                 String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code).                 if (codeExceptionMessage != null)                     throw new ProtocolException(codeExceptionMessage).             }             frameCallback.onReadClose(code, reason).             closed = true.             break.         default:             throw new ProtocolException("Unknown control opcode: " + toHexString(opcode)).     } }
false;private;0;14;;private void readMessageFrame() throws IOException {     int opcode = this.opcode.     if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {         throw new ProtocolException("Unknown opcode: " + toHexString(opcode)).     }     readMessage().     if (opcode == OPCODE_TEXT) {         frameCallback.onReadMessage(messageFrameBuffer.readUtf8()).     } else {         frameCallback.onReadMessage(messageFrameBuffer.readByteString()).     } }
true;private;0;9;/**  * Read headers and process any control frames until we reach a non-control frame.  */ ;/**  * Read headers and process any control frames until we reach a non-control frame.  */ private void readUntilNonControlFrame() throws IOException {     while (!closed) {         readHeader().         if (!isControlFrame) {             break.         }         readControlFrame().     } }
true;private;0;23;/**  * Reads a message body into across one or more frames. Control frames that occur between  * fragments will be processed. If the message payload is masked this will unmask as it's being  * processed.  */ ;/**  * Reads a message body into across one or more frames. Control frames that occur between  * fragments will be processed. If the message payload is masked this will unmask as it's being  * processed.  */ private void readMessage() throws IOException {     while (true) {         if (closed)             throw new IOException("closed").         if (frameLength > 0) {             source.readFully(messageFrameBuffer, frameLength).             if (!isClient) {                 messageFrameBuffer.readAndWriteUnsafe(maskCursor).                 maskCursor.seek(messageFrameBuffer.size() - frameLength).                 toggleMask(maskCursor, maskKey).                 maskCursor.close().             }         }         // We are exhausted and have no continuations.         if (isFinalFrame)             break.         readUntilNonControlFrame().         if (opcode != OPCODE_CONTINUATION) {             throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode)).         }     } }
