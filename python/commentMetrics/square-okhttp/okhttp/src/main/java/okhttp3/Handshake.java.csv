commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;30;;public static Handshake get(SSLSession session) throws IOException {     String cipherSuiteString = session.getCipherSuite().     if (cipherSuiteString == null)         throw new IllegalStateException("cipherSuite == null").     if ("SSL_NULL_WITH_NULL_NULL".equals(cipherSuiteString)) {         throw new IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL").     }     CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString).     String tlsVersionString = session.getProtocol().     if (tlsVersionString == null)         throw new IllegalStateException("tlsVersion == null").     if ("NONE".equals(tlsVersionString))         throw new IOException("tlsVersion == NONE").     TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString).     Certificate[] peerCertificates.     try {         peerCertificates = session.getPeerCertificates().     } catch (SSLPeerUnverifiedException ignored) {         peerCertificates = null.     }     List<Certificate> peerCertificatesList = peerCertificates != null ? Util.immutableList(peerCertificates) : Collections.emptyList().     Certificate[] localCertificates = session.getLocalCertificates().     List<Certificate> localCertificatesList = localCertificates != null ? Util.immutableList(localCertificates) : Collections.emptyList().     return new Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList). }
false;public,static;4;7;;public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {     if (tlsVersion == null)         throw new NullPointerException("tlsVersion == null").     if (cipherSuite == null)         throw new NullPointerException("cipherSuite == null").     return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates), Util.immutableList(localCertificates)). }
true;public;0;3;/**  * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp  * 3.0. For responses cached by preceding versions this returns {@link TlsVersion#SSL_3_0}.  */ ;/**  * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp  * 3.0. For responses cached by preceding versions this returns {@link TlsVersion#SSL_3_0}.  */ public TlsVersion tlsVersion() {     return tlsVersion. }
true;public;0;3;/**  * Returns the cipher suite used for the connection.  */ ;/**  * Returns the cipher suite used for the connection.  */ public CipherSuite cipherSuite() {     return cipherSuite. }
true;public;0;3;/**  * Returns a possibly-empty list of certificates that identify the remote peer.  */ ;/**  * Returns a possibly-empty list of certificates that identify the remote peer.  */ public List<Certificate> peerCertificates() {     return peerCertificates. }
true;public;0;5;/**  * Returns the remote peer's principle, or null if that peer is anonymous.  */ ;/**  * Returns the remote peer's principle, or null if that peer is anonymous.  */ @Nullable public Principal peerPrincipal() {     return !peerCertificates.isEmpty() ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal() : null. }
true;public;0;3;/**  * Returns a possibly-empty list of certificates that identify this peer.  */ ;/**  * Returns a possibly-empty list of certificates that identify this peer.  */ public List<Certificate> localCertificates() {     return localCertificates. }
true;public;0;5;/**  * Returns the local principle, or null if this peer is anonymous.  */ ;/**  * Returns the local principle, or null if this peer is anonymous.  */ @Nullable public Principal localPrincipal() {     return !localCertificates.isEmpty() ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal() : null. }
false;public;1;8;;@Override public boolean equals(@Nullable Object other) {     if (!(other instanceof Handshake))         return false.     Handshake that = (Handshake) other.     return tlsVersion.equals(that.tlsVersion) && cipherSuite.equals(that.cipherSuite) && peerCertificates.equals(that.peerCertificates) && localCertificates.equals(that.localCertificates). }
false;public;0;8;;@Override public int hashCode() {     int result = 17.     result = 31 * result + tlsVersion.hashCode().     result = 31 * result + cipherSuite.hashCode().     result = 31 * result + peerCertificates.hashCode().     result = 31 * result + localCertificates.hashCode().     return result. }
false;public;0;12;;@Override public String toString() {     return "Handshake{" + "tlsVersion=" + tlsVersion + " cipherSuite=" + cipherSuite + " peerCertificates=" + names(peerCertificates) + " localCertificates=" + names(localCertificates) + '}'. }
false;private;1;13;;private List<String> names(List<Certificate> certificates) {     ArrayList<String> strings = new ArrayList<>().     for (Certificate cert : certificates) {         if (cert instanceof X509Certificate) {             strings.add(String.valueOf(((X509Certificate) cert).getSubjectDN())).         } else {             strings.add(cert.getType()).         }     }     return strings. }
