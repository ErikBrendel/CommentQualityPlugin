commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;@Override public Request request() {     return originalRequest. }
false;public,synchronized;0;3;;@Override public synchronized long queueSize() {     return queueSize. }
false;public;0;3;;@Override public void cancel() {     call.cancel(). }
false;public;2;20;;@Override public void onResponse(Call call, Response response) {     Streams streams.     try {         streams = extractStreamsFromResponse(response).     } catch (IOException e) {         failWebSocket(e, response).         closeQuietly(response).         return.     }     // Process all web socket messages.     try {         String name = "OkHttp WebSocket " + request.url().redact().         initReaderAndWriter(name, streams).         listener.onOpen(RealWebSocket.this, response).         loopReader().     } catch (Exception e) {         failWebSocket(e, null).     } }
false;public;2;3;;@Override public void onFailure(Call call, IOException e) {     failWebSocket(e, null). }
false;public;1;39;;public void connect(OkHttpClient client) {     client = client.newBuilder().eventListener(EventListener.NONE).protocols(ONLY_HTTP1).build().     final Request request = originalRequest.newBuilder().header("Upgrade", "websocket").header("Connection", "Upgrade").header("Sec-WebSocket-Key", key).header("Sec-WebSocket-Version", "13").build().     call = Internal.instance.newWebSocketCall(client, request).     call.enqueue(new Callback() {          @Override         public void onResponse(Call call, Response response) {             Streams streams.             try {                 streams = extractStreamsFromResponse(response).             } catch (IOException e) {                 failWebSocket(e, response).                 closeQuietly(response).                 return.             }             // Process all web socket messages.             try {                 String name = "OkHttp WebSocket " + request.url().redact().                 initReaderAndWriter(name, streams).                 listener.onOpen(RealWebSocket.this, response).                 loopReader().             } catch (Exception e) {                 failWebSocket(e, null).             }         }          @Override         public void onFailure(Call call, IOException e) {             failWebSocket(e, null).         }     }). }
false;;1;32;;Streams extractStreamsFromResponse(Response response) throws IOException {     if (response.code() != 101) {         throw new ProtocolException("Expected HTTP 101 response but was '" + response.code() + " " + response.message() + "'").     }     String headerConnection = response.header("Connection").     if (!"Upgrade".equalsIgnoreCase(headerConnection)) {         throw new ProtocolException("Expected 'Connection' header value 'Upgrade' but was '" + headerConnection + "'").     }     String headerUpgrade = response.header("Upgrade").     if (!"websocket".equalsIgnoreCase(headerUpgrade)) {         throw new ProtocolException("Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'").     }     String headerAccept = response.header("Sec-WebSocket-Accept").     String acceptExpected = ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC).sha1().base64().     if (!acceptExpected.equals(headerAccept)) {         throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '" + acceptExpected + "' but was '" + headerAccept + "'").     }     Exchange exchange = Internal.instance.exchange(response).     if (exchange == null) {         throw new ProtocolException("Web Socket exchange missing: bad interceptor?").     }     return exchange.newWebSocketStreams(). }
false;public;2;16;;public void initReaderAndWriter(String name, Streams streams) throws IOException {     synchronized (this) {         this.streams = streams.         this.writer = new WebSocketWriter(streams.client, streams.sink, random).         this.executor = new ScheduledThreadPoolExecutor(1, Util.threadFactory(name, false)).         if (pingIntervalMillis != 0) {             executor.scheduleAtFixedRate(new PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS).         }         if (!messageAndCloseQueue.isEmpty()) {             // Send messages that were enqueued before we were connected.             runWriter().         }     }     reader = new WebSocketReader(streams.client, streams.source, this). }
true;public;0;6;/**  * Receive frames until there are no more. Invoked only by the reader thread.  */ ;/**  * Receive frames until there are no more. Invoked only by the reader thread.  */ public void loopReader() throws IOException {     while (receivedCloseCode == -1) {         // This method call results in one or more onRead* methods being called on this thread.         reader.processNextFrame().     } }
true;;0;9;/**  * For testing: receive a single frame and return true if there are more frames to read. Invoked  * only by the reader thread.  */ ;/**  * For testing: receive a single frame and return true if there are more frames to read. Invoked  * only by the reader thread.  */ boolean processNextFrame() throws IOException {     try {         reader.processNextFrame().         return receivedCloseCode == -1.     } catch (Exception e) {         failWebSocket(e, null).         return false.     } }
true;;2;3;/**  * For testing: wait until the web socket's executor has terminated.  */ ;/**  * For testing: wait until the web socket's executor has terminated.  */ void awaitTermination(int timeout, TimeUnit timeUnit) throws InterruptedException {     executor.awaitTermination(timeout, timeUnit). }
true;;0;7;/**  * For testing: force this web socket to release its threads.  */ ;/**  * For testing: force this web socket to release its threads.  */ void tearDown() throws InterruptedException {     if (cancelFuture != null) {         cancelFuture.cancel(false).     }     executor.shutdown().     executor.awaitTermination(10, TimeUnit.SECONDS). }
false;synchronized;0;3;;synchronized int sentPingCount() {     return sentPingCount. }
false;synchronized;0;3;;synchronized int receivedPingCount() {     return receivedPingCount. }
false;synchronized;0;3;;synchronized int receivedPongCount() {     return receivedPongCount. }
false;public;1;3;;@Override public void onReadMessage(String text) throws IOException {     listener.onMessage(this, text). }
false;public;1;3;;@Override public void onReadMessage(ByteString bytes) throws IOException {     listener.onMessage(this, bytes). }
false;public,synchronized;1;8;;@Override public synchronized void onReadPing(ByteString payload) {     // Don't respond to pings after we've failed or sent the close frame.     if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty()))         return.     pongQueue.add(payload).     runWriter().     receivedPingCount++. }
false;public,synchronized;1;5;;@Override public synchronized void onReadPong(ByteString buffer) {     // This API doesn't expose pings.     receivedPongCount++.     awaitingPong = false. }
false;public;2;26;;@Override public void onReadClose(int code, String reason) {     if (code == -1)         throw new IllegalArgumentException().     Streams toClose = null.     synchronized (this) {         if (receivedCloseCode != -1)             throw new IllegalStateException("already closed").         receivedCloseCode = code.         receivedCloseReason = reason.         if (enqueuedClose && messageAndCloseQueue.isEmpty()) {             toClose = this.streams.             this.streams = null.             if (cancelFuture != null)                 cancelFuture.cancel(false).             this.executor.shutdown().         }     }     try {         listener.onClosing(this, code, reason).         if (toClose != null) {             listener.onClosed(this, code, reason).         }     } finally {         closeQuietly(toClose).     } }
false;public;1;4;;// Writer methods to enqueue frames. They'll be sent asynchronously by the writer thread. @Override public boolean send(String text) {     if (text == null)         throw new NullPointerException("text == null").     return send(ByteString.encodeUtf8(text), OPCODE_TEXT). }
false;public;1;4;;@Override public boolean send(ByteString bytes) {     if (bytes == null)         throw new NullPointerException("bytes == null").     return send(bytes, OPCODE_BINARY). }
false;private,synchronized;2;16;;private synchronized boolean send(ByteString data, int formatOpcode) {     // Don't send new frames after we've failed or enqueued a close frame.     if (failed || enqueuedClose)         return false.     // If this frame overflows the buffer, reject it and close the web socket.     if (queueSize + data.size() > MAX_QUEUE_SIZE) {         close(CLOSE_CLIENT_GOING_AWAY, null).         return false.     }     // Enqueue the message frame.     queueSize += data.size().     messageAndCloseQueue.add(new Message(formatOpcode, data)).     runWriter().     return true. }
false;synchronized;1;8;;synchronized boolean pong(ByteString payload) {     // Don't send pongs after we've failed or sent the close frame.     if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty()))         return false.     pongQueue.add(payload).     runWriter().     return true. }
false;public;2;3;;@Override public boolean close(int code, String reason) {     return close(code, reason, CANCEL_AFTER_CLOSE_MILLIS). }
false;synchronized;3;21;;synchronized boolean close(int code, String reason, long cancelAfterCloseMillis) {     validateCloseCode(code).     ByteString reasonBytes = null.     if (reason != null) {         reasonBytes = ByteString.encodeUtf8(reason).         if (reasonBytes.size() > CLOSE_MESSAGE_MAX) {             throw new IllegalArgumentException("reason.size() > " + CLOSE_MESSAGE_MAX + ": " + reason).         }     }     if (failed || enqueuedClose)         return false.     // Immediately prevent further frames from being enqueued.     enqueuedClose = true.     // Enqueue the close frame.     messageAndCloseQueue.add(new Close(code, reasonBytes, cancelAfterCloseMillis)).     runWriter().     return true. }
false;private;0;7;;private void runWriter() {     assert (Thread.holdsLock(this)).     if (executor != null) {         executor.execute(writerRunnable).     } }
true;;0;67;/**  * Attempts to remove a single frame from a queue and send it. This prefers to write urgent pongs  * before less urgent messages and close frames. For example it's possible that a caller will  * enqueue messages followed by pongs, but this sends pongs followed by messages. Pongs are always  * written in the order they were enqueued.  *  * <p>If a frame cannot be sent - because there are none enqueued or because the web socket is not  * connected - this does nothing and returns false. Otherwise this returns true and the caller  * should immediately invoke this method again until it returns false.  *  * <p>This method may only be invoked by the writer thread. There may be only thread invoking this  * method at a time.  */ ;/**  * Attempts to remove a single frame from a queue and send it. This prefers to write urgent pongs  * before less urgent messages and close frames. For example it's possible that a caller will  * enqueue messages followed by pongs, but this sends pongs followed by messages. Pongs are always  * written in the order they were enqueued.  *  * <p>If a frame cannot be sent - because there are none enqueued or because the web socket is not  * connected - this does nothing and returns false. Otherwise this returns true and the caller  * should immediately invoke this method again until it returns false.  *  * <p>This method may only be invoked by the writer thread. There may be only thread invoking this  * method at a time.  */ boolean writeOneFrame() throws IOException {     WebSocketWriter writer.     ByteString pong.     Object messageOrClose = null.     int receivedCloseCode = -1.     String receivedCloseReason = null.     Streams streamsToClose = null.     synchronized (RealWebSocket.this) {         if (failed) {             // Failed web socket.             return false.         }         writer = this.writer.         pong = pongQueue.poll().         if (pong == null) {             messageOrClose = messageAndCloseQueue.poll().             if (messageOrClose instanceof Close) {                 receivedCloseCode = this.receivedCloseCode.                 receivedCloseReason = this.receivedCloseReason.                 if (receivedCloseCode != -1) {                     streamsToClose = this.streams.                     this.streams = null.                     this.executor.shutdown().                 } else {                     // When we request a graceful close also schedule a cancel of the websocket.                     cancelFuture = executor.schedule(new CancelRunnable(), ((Close) messageOrClose).cancelAfterCloseMillis, MILLISECONDS).                 }             } else if (messageOrClose == null) {                 // The queue is exhausted.                 return false.             }         }     }     try {         if (pong != null) {             writer.writePong(pong).         } else if (messageOrClose instanceof Message) {             ByteString data = ((Message) messageOrClose).data.             BufferedSink sink = Okio.buffer(writer.newMessageSink(((Message) messageOrClose).formatOpcode, data.size())).             sink.write(data).             sink.close().             synchronized (this) {                 queueSize -= data.size().             }         } else if (messageOrClose instanceof Close) {             Close close = (Close) messageOrClose.             writer.writeClose(close.code, close.reason).             // We closed the writer: now both reader and writer are closed.             if (streamsToClose != null) {                 listener.onClosed(this, receivedCloseCode, receivedCloseReason).             }         } else {             throw new AssertionError().         }         return true.     } finally {         closeQuietly(streamsToClose).     } }
false;public;0;3;;@Override public void run() {     writePingFrame(). }
false;;0;24;;void writePingFrame() {     WebSocketWriter writer.     int failedPing.     synchronized (this) {         if (failed)             return.         writer = this.writer.         failedPing = awaitingPong ? sentPingCount : -1.         sentPingCount++.         awaitingPong = true.     }     if (failedPing != -1) {         failWebSocket(new SocketTimeoutException("sent ping but didn't receive pong within " + pingIntervalMillis + "ms (after " + (failedPing - 1) + " successful ping/pongs)"), null).         return.     }     try {         writer.writePing(ByteString.EMPTY).     } catch (IOException e) {         failWebSocket(e, null).     } }
false;public;2;17;;public void failWebSocket(Exception e, @Nullable Response response) {     Streams streamsToClose.     synchronized (this) {         // Already failed.         if (failed)             return.         failed = true.         streamsToClose = this.streams.         this.streams = null.         if (cancelFuture != null)             cancelFuture.cancel(false).         if (executor != null)             executor.shutdown().     }     try {         listener.onFailure(this, e, response).     } finally {         closeQuietly(streamsToClose).     } }
false;public;0;3;;@Override public void run() {     cancel(). }
