commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;@Override protected void timedOut() {     cancel(). }
false;public;0;3;;public Timeout timeout() {     return timeout. }
false;public;0;3;;public void timeoutEnter() {     timeout.enter(). }
true;public;0;5;/**  * Stops applying the timeout before the call is entirely complete. This is used for WebSockets  * and duplex calls where the timeout only applies to the initial setup.  */ ;/**  * Stops applying the timeout before the call is entirely complete. This is used for WebSockets  * and duplex calls where the timeout only applies to the initial setup.  */ public void timeoutEarlyExit() {     if (timeoutEarlyExit)         throw new IllegalStateException().     timeoutEarlyExit = true.     timeout.exit(). }
false;private;1;9;;@Nullable private IOException timeoutExit(@Nullable IOException cause) {     if (timeoutEarlyExit)         return cause.     if (!timeout.exit())         return cause.     InterruptedIOException e = new InterruptedIOException("timeout").     if (cause != null)         e.initCause(cause).     return e. }
false;public;0;4;;public void callStart() {     this.callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()").     eventListener.callStart(call). }
true;public;1;15;/**  * Prepare to create a stream to carry {@code request}. This prefers to use the existing  * connection if it exists.  */ ;/**  * Prepare to create a stream to carry {@code request}. This prefers to use the existing  * connection if it exists.  */ public void prepareToConnect(Request request) {     if (this.request != null) {         // Already ready.         if (sameConnection(this.request.url(), request.url()))             return.         if (exchange != null)             throw new IllegalStateException().         if (exchangeFinder != null) {             maybeReleaseConnection(null, true).             exchangeFinder = null.         }     }     this.request = request.     this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()), call, eventListener). }
false;private;1;14;;private Address createAddress(HttpUrl url) {     SSLSocketFactory sslSocketFactory = null.     HostnameVerifier hostnameVerifier = null.     CertificatePinner certificatePinner = null.     if (url.isHttps()) {         sslSocketFactory = client.sslSocketFactory().         hostnameVerifier = client.hostnameVerifier().         certificatePinner = client.certificatePinner().     }     return new Address(url.host(), url.port(), client.dns(), client.socketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(), client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector()). }
true;;2;16;/**  * Returns a new exchange to carry a new request and response.  */ ;/**  * Returns a new exchange to carry a new request and response.  */ Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {     synchronized (connectionPool) {         if (noMoreExchanges)             throw new IllegalStateException("released").         if (exchange != null)             throw new IllegalStateException("exchange != null").     }     ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks).     Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec).     synchronized (connectionPool) {         this.exchange = result.         this.exchangeRequestDone = false.         this.exchangeResponseDone = false.         return result.     } }
false;;1;7;;void acquireConnectionNoEvents(RealConnection connection) {     assert (Thread.holdsLock(connectionPool)).     if (this.connection != null)         throw new IllegalStateException().     this.connection = connection.     connection.transmitters.add(new TransmitterReference(this, callStackTrace)). }
true;;0;27;/**  * Remove the transmitter from the connection's list of allocations. Returns a socket that the  * caller should close.  */ ;/**  * Remove the transmitter from the connection's list of allocations. Returns a socket that the  * caller should close.  */ @Nullable Socket releaseConnectionNoEvents() {     assert (Thread.holdsLock(connectionPool)).     int index = -1.     for (int i = 0, size = this.connection.transmitters.size(). i < size. i++) {         Reference<Transmitter> reference = this.connection.transmitters.get(i).         if (reference.get() == this) {             index = i.             break.         }     }     if (index == -1)         throw new IllegalStateException().     RealConnection released = this.connection.     released.transmitters.remove(index).     this.connection = null.     if (released.transmitters.isEmpty()) {         released.idleAtNanos = System.nanoTime().         if (connectionPool.connectionBecameIdle(released)) {             return released.socket().         }     }     return null. }
false;public;0;6;;public void exchangeDoneDueToException() {     synchronized (connectionPool) {         if (noMoreExchanges)             throw new IllegalStateException().         exchange = null.     } }
true;;4;27;/**  * Releases resources held with the request or response of {@code exchange}. This should be called  * when the request completes normally or when it fails due to an exception, in which case {@code  * e} should be non-null.  *  * <p>If the exchange was canceled or timed out, this will wrap {@code e} in an exception that  * provides that additional context. Otherwise {@code e} is returned as-is.  */ ;/**  * Releases resources held with the request or response of {@code exchange}. This should be called  * when the request completes normally or when it fails due to an exception, in which case {@code  * e} should be non-null.  *  * <p>If the exchange was canceled or timed out, this will wrap {@code e} in an exception that  * provides that additional context. Otherwise {@code e} is returned as-is.  */ @Nullable IOException exchangeMessageDone(Exchange exchange, boolean requestDone, boolean responseDone, @Nullable IOException e) {     boolean exchangeDone = false.     synchronized (connectionPool) {         if (exchange != this.exchange) {             // This exchange was detached violently!             return e.         }         boolean changed = false.         if (requestDone) {             if (!exchangeRequestDone)                 changed = true.             this.exchangeRequestDone = true.         }         if (responseDone) {             if (!exchangeResponseDone)                 changed = true.             this.exchangeResponseDone = true.         }         if (exchangeRequestDone && exchangeResponseDone && changed) {             exchangeDone = true.             this.exchange.connection().successCount++.             this.exchange = null.         }     }     if (exchangeDone) {         e = maybeReleaseConnection(e, false).     }     return e. }
false;public;1;6;;@Nullable public IOException noMoreExchanges(@Nullable IOException e) {     synchronized (connectionPool) {         noMoreExchanges = true.     }     return maybeReleaseConnection(e, false). }
true;private;2;32;/**  * Release the connection if it is no longer needed. This is called after each exchange completes  * and after the call signals that no more exchanges are expected.  *  * <p>If the transmitter was canceled or timed out, this will wrap {@code e} in an exception that  * provides that additional context. Otherwise {@code e} is returned as-is.  *  * @param force true to release the connection even if more exchanges are expected for the call.  */ ;/**  * Release the connection if it is no longer needed. This is called after each exchange completes  * and after the call signals that no more exchanges are expected.  *  * <p>If the transmitter was canceled or timed out, this will wrap {@code e} in an exception that  * provides that additional context. Otherwise {@code e} is returned as-is.  *  * @param force true to release the connection even if more exchanges are expected for the call.  */ @Nullable private IOException maybeReleaseConnection(@Nullable IOException e, boolean force) {     Socket socket.     Connection releasedConnection.     boolean callEnd.     synchronized (connectionPool) {         if (force && exchange != null) {             throw new IllegalStateException("cannot release connection while it is in use").         }         releasedConnection = this.connection.         socket = this.connection != null && exchange == null && (force || noMoreExchanges) ? releaseConnectionNoEvents() : null.         if (this.connection != null)             releasedConnection = null.         callEnd = noMoreExchanges && exchange == null.     }     closeQuietly(socket).     if (releasedConnection != null) {         eventListener.connectionReleased(call, releasedConnection).     }     if (callEnd) {         boolean callFailed = (e != null).         e = timeoutExit(e).         if (callFailed) {             eventListener.callFailed(call, e).         } else {             eventListener.callEnd(call).         }     }     return e. }
false;public;0;3;;public boolean canRetry() {     return exchangeFinder.canRetry(). }
false;public;0;5;;public boolean hasExchange() {     synchronized (connectionPool) {         return exchange != null.     } }
true;public;0;16;/**  * Immediately closes the socket connection if it's currently held. Use this to interrupt an  * in-flight request from any thread. It's the caller's responsibility to close the request body  * and response body streams. otherwise resources may be leaked.  *  * <p>This method is safe to be called concurrently, but provides limited guarantees. If a  * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.  * Otherwise if a socket connection is being established, that is terminated.  */ ;/**  * Immediately closes the socket connection if it's currently held. Use this to interrupt an  * in-flight request from any thread. It's the caller's responsibility to close the request body  * and response body streams. otherwise resources may be leaked.  *  * <p>This method is safe to be called concurrently, but provides limited guarantees. If a  * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.  * Otherwise if a socket connection is being established, that is terminated.  */ public void cancel() {     Exchange exchangeToCancel.     RealConnection connectionToCancel.     synchronized (connectionPool) {         canceled = true.         exchangeToCancel = exchange.         connectionToCancel = exchangeFinder != null && exchangeFinder.connectingConnection() != null ? exchangeFinder.connectingConnection() : connection.     }     if (exchangeToCancel != null) {         exchangeToCancel.cancel().     } else if (connectionToCancel != null) {         connectionToCancel.cancel().     } }
false;public;0;5;;public boolean isCanceled() {     synchronized (connectionPool) {         return canceled.     } }
