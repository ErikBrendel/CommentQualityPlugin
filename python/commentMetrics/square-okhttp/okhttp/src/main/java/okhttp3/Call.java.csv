commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Returns the original request that initiated this call.  */ ;/**  * Returns the original request that initiated this call.  */ Request request().
true;;0;1;/**  * Invokes the request immediately, and blocks until the response can be processed or is in  * error.  *  * <p>To avoid leaking resources callers should close the {@link Response} which in turn will  * close the underlying {@link ResponseBody}.  *  * <pre>{@code  *  *   // ensure the response (and underlying response body) is closed  *   try (Response response = client.newCall(request).execute()) {  *     ...  *   }  *  * }</pre>  *  * <p>The caller may read the response body with the response's {@link Response#body} method. To  * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the  * Response.  *  * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does  * not necessarily indicate application-layer success: {@code response} may still indicate an  * unhappy HTTP response code like 404 or 500.  *  * @throws IOException if the request could not be executed due to cancellation, a connectivity  * problem or timeout. Because networks can fail during an exchange, it is possible that the  * remote server accepted the request before the failure.  * @throws IllegalStateException when the call has already been executed.  */ ;/**  * Invokes the request immediately, and blocks until the response can be processed or is in  * error.  *  * <p>To avoid leaking resources callers should close the {@link Response} which in turn will  * close the underlying {@link ResponseBody}.  *  * <pre>{@code  *  *   // ensure the response (and underlying response body) is closed  *   try (Response response = client.newCall(request).execute()) {  *     ...  *   }  *  * }</pre>  *  * <p>The caller may read the response body with the response's {@link Response#body} method. To  * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the  * Response.  *  * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does  * not necessarily indicate application-layer success: {@code response} may still indicate an  * unhappy HTTP response code like 404 or 500.  *  * @throws IOException if the request could not be executed due to cancellation, a connectivity  * problem or timeout. Because networks can fail during an exchange, it is possible that the  * remote server accepted the request before the failure.  * @throws IllegalStateException when the call has already been executed.  */ Response execute() throws IOException.
true;;1;1;/**  * Schedules the request to be executed at some point in the future.  *  * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually  * immediately unless there are several other requests currently being executed.  *  * <p>This client will later call back {@code responseCallback} with either an HTTP response or a  * failure exception.  *  * @throws IllegalStateException when the call has already been executed.  */ ;/**  * Schedules the request to be executed at some point in the future.  *  * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually  * immediately unless there are several other requests currently being executed.  *  * <p>This client will later call back {@code responseCallback} with either an HTTP response or a  * failure exception.  *  * @throws IllegalStateException when the call has already been executed.  */ void enqueue(Callback responseCallback).
true;;0;1;/**  * Cancels the request, if possible. Requests that are already complete cannot be canceled.  */ ;/**  * Cancels the request, if possible. Requests that are already complete cannot be canceled.  */ void cancel().
true;;0;1;/**  * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain  * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.  */ ;/**  * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain  * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.  */ boolean isExecuted().
false;;0;1;;boolean isCanceled().
true;;0;1;/**  * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request  * body, server processing, and reading the response body. If the call requires redirects or  * retries all must complete within one timeout period.  *  * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.  */ ;/**  * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request  * body, server processing, and reading the response body. If the call requires redirects or  * retries all must complete within one timeout period.  *  * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.  */ Timeout timeout().
true;;0;1;/**  * Create a new, identical call to this one which can be enqueued or executed even if this call  * has already been.  */ ;/**  * Create a new, identical call to this one which can be enqueued or executed even if this call  * has already been.  */ Call clone().
false;;1;1;;Call newCall(Request request).
