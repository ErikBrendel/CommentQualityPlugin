commented;modifiers;parameterAmount;loc;comment;code
true;public;2;49;/**  * Returns a cleaned chain for {@code chain}.  *  * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.  * This is unexpected unless the trust root index in this class has a different trust manager than  * what was used to establish {@code chain}.  */ ;/**  * Returns a cleaned chain for {@code chain}.  *  * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.  * This is unexpected unless the trust root index in this class has a different trust manager than  * what was used to establish {@code chain}.  */ @Override public List<Certificate> clean(List<Certificate> chain, String hostname) throws SSLPeerUnverifiedException {     Deque<Certificate> queue = new ArrayDeque<>(chain).     List<Certificate> result = new ArrayList<>().     result.add(queue.removeFirst()).     boolean foundTrustedCertificate = false.     followIssuerChain: for (int c = 0. c < MAX_SIGNERS. c++) {         X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1).         // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to         // the end of the chain unless it's already present. (That would happen if the first         // certificate in the chain is itself a self-signed and trusted CA certificate.)         X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify).         if (trustedCert != null) {             if (result.size() > 1 || !toVerify.equals(trustedCert)) {                 result.add(trustedCert).             }             if (verifySignature(trustedCert, trustedCert)) {                 // The self-signed cert is a root CA. We're done.                 return result.             }             foundTrustedCertificate = true.             continue.         }         // the next element in the chain, but it could be any element.         for (Iterator<Certificate> i = queue.iterator(). i.hasNext(). ) {             X509Certificate signingCert = (X509Certificate) i.next().             if (verifySignature(toVerify, signingCert)) {                 i.remove().                 result.add(signingCert).                 continue followIssuerChain.             }         }         // We've reached the end of the chain. If any cert in the chain is trusted, we're done.         if (foundTrustedCertificate) {             return result.         }         // The last link isn't trusted. Fail.         throw new SSLPeerUnverifiedException("Failed to find a trusted cert that signed " + toVerify).     }     throw new SSLPeerUnverifiedException("Certificate chain too long: " + result). }
true;private;2;9;/**  * Returns true if {@code toVerify} was signed by {@code signingCert}'s public key.  */ ;/**  * Returns true if {@code toVerify} was signed by {@code signingCert}'s public key.  */ private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {     if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN()))         return false.     try {         toVerify.verify(signingCert.getPublicKey()).         return true.     } catch (GeneralSecurityException verifyFailed) {         return false.     } }
false;public;0;3;;@Override public int hashCode() {     return trustRootIndex.hashCode(). }
false;public;1;5;;@Override public boolean equals(Object other) {     if (other == this)         return true.     return other instanceof BasicCertificateChainCleaner && ((BasicCertificateChainCleaner) other).trustRootIndex.equals(trustRootIndex). }
