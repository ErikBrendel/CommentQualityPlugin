commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns true if there's another set of routes to attempt. Every address has at least one route.  */ ;/**  * Returns true if there's another set of routes to attempt. Every address has at least one route.  */ public boolean hasNext() {     return hasNextProxy() || !postponedRoutes.isEmpty(). }
false;public;0;34;;public Selection next() throws IOException {     if (!hasNext()) {         throw new NoSuchElementException().     }     // Compute the next set of routes to attempt.     List<Route> routes = new ArrayList<>().     while (hasNextProxy()) {         // Postponed routes are always tried last. For example, if we have 2 proxies and all the         // routes for proxy1 should be postponed, we'll move to proxy2. Only after we've exhausted         // all the good routes will we attempt the postponed routes.         Proxy proxy = nextProxy().         for (int i = 0, size = inetSocketAddresses.size(). i < size. i++) {             Route route = new Route(address, proxy, inetSocketAddresses.get(i)).             if (routeDatabase.shouldPostpone(route)) {                 postponedRoutes.add(route).             } else {                 routes.add(route).             }         }         if (!routes.isEmpty()) {             break.         }     }     if (routes.isEmpty()) {         // We've exhausted all Proxies so fallback to the postponed routes.         routes.addAll(postponedRoutes).         postponedRoutes.clear().     }     return new Selection(routes). }
true;private;2;13;/**  * Prepares the proxy servers to try.  */ ;/**  * Prepares the proxy servers to try.  */ private void resetNextProxy(HttpUrl url, Proxy proxy) {     if (proxy != null) {         // If the user specifies a proxy, try that and only that.         proxies = Collections.singletonList(proxy).     } else {         // Try each of the ProxySelector choices until one connection succeeds.         List<Proxy> proxiesOrNull = address.proxySelector().select(url.uri()).         proxies = proxiesOrNull != null && !proxiesOrNull.isEmpty() ? Util.immutableList(proxiesOrNull) : Util.immutableList(Proxy.NO_PROXY).     }     nextProxyIndex = 0. }
true;private;0;3;/**  * Returns true if there's another proxy to try.  */ ;/**  * Returns true if there's another proxy to try.  */ private boolean hasNextProxy() {     return nextProxyIndex < proxies.size(). }
true;private;0;9;/**  * Returns the next proxy to try. May be PROXY.NO_PROXY but never null.  */ ;/**  * Returns the next proxy to try. May be PROXY.NO_PROXY but never null.  */ private Proxy nextProxy() throws IOException {     if (!hasNextProxy()) {         throw new SocketException("No route to " + address.url().host() + ". exhausted proxy configurations: " + proxies).     }     Proxy result = proxies.get(nextProxyIndex++).     resetNextInetSocketAddress(result).     return result. }
true;private;1;44;/**  * Prepares the socket addresses to attempt for the current proxy or host.  */ ;/**  * Prepares the socket addresses to attempt for the current proxy or host.  */ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {     // Clear the addresses. Necessary if getAllByName() below throws!     inetSocketAddresses = new ArrayList<>().     String socketHost.     int socketPort.     if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {         socketHost = address.url().host().         socketPort = address.url().port().     } else {         SocketAddress proxyAddress = proxy.address().         if (!(proxyAddress instanceof InetSocketAddress)) {             throw new IllegalArgumentException("Proxy.address() is not an " + "InetSocketAddress: " + proxyAddress.getClass()).         }         InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress.         socketHost = getHostString(proxySocketAddress).         socketPort = proxySocketAddress.getPort().     }     if (socketPort < 1 || socketPort > 65535) {         throw new SocketException("No route to " + socketHost + ":" + socketPort + ". port is out of range").     }     if (proxy.type() == Proxy.Type.SOCKS) {         inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort)).     } else {         eventListener.dnsStart(call, socketHost).         // Try each address for best behavior in mixed IPv4/IPv6 environments.         List<InetAddress> addresses = address.dns().lookup(socketHost).         if (addresses.isEmpty()) {             throw new UnknownHostException(address.dns() + " returned no addresses for " + socketHost).         }         eventListener.dnsEnd(call, socketHost, addresses).         for (int i = 0, size = addresses.size(). i < size. i++) {             InetAddress inetAddress = addresses.get(i).             inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort)).         }     } }
true;static;1;12;// Visible for testing ;/**  * Obtain a "host" from an {@link InetSocketAddress}. This returns a string containing either an  * actual host name or a numeric IP address.  */ // Visible for testing static String getHostString(InetSocketAddress socketAddress) {     InetAddress address = socketAddress.getAddress().     if (address == null) {         // address should be tried.         return socketAddress.getHostName().     }     // return the address and ignore any host name that may be available.     return address.getHostAddress(). }
false;public;0;3;;public boolean hasNext() {     return nextRouteIndex < routes.size(). }
false;public;0;6;;public Route next() {     if (!hasNext()) {         throw new NoSuchElementException().     }     return routes.get(nextRouteIndex++). }
false;public;0;3;;public List<Route> getAll() {     return new ArrayList<>(routes). }
