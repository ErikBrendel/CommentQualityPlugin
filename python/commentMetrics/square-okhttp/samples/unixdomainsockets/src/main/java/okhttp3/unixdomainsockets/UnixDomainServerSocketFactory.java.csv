commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;@Override public ServerSocket createServerSocket() throws IOException {     return new UnixDomainServerSocket(). }
false;public;1;3;;@Override public ServerSocket createServerSocket(int port) throws IOException {     return createServerSocket(). }
false;public;2;3;;@Override public ServerSocket createServerSocket(int port, int backlog) throws IOException {     return createServerSocket(). }
false;public;3;4;;@Override public ServerSocket createServerSocket(int port, int backlog, InetAddress inetAddress) throws IOException {     return createServerSocket(). }
false;public;2;8;;@Override public void bind(SocketAddress endpoint, int backlog) throws IOException {     this.endpoint = (InetSocketAddress) endpoint.     UnixSocketAddress address = new UnixSocketAddress(path).     serverSocketChannel = UnixServerSocketChannel.open().     serverSocketChannel.configureBlocking(true).     serverSocketChannel.socket().bind(address). }
false;public;0;3;;@Override public int getLocalPort() {     // A white lie. There is no local port.     return 1. }
false;public;0;3;;@Override public SocketAddress getLocalSocketAddress() {     return endpoint. }
false;public;0;10;;@Override public Socket accept() throws IOException {     try {         UnixSocketChannel channel = serverSocketChannel.accept().         return new TunnelingUnixSocket(path, channel, endpoint).     } catch (ClosedChannelException e) {         SocketException exception = new SocketException().         exception.initCause(e).         throw exception.     } }
false;public;0;3;;@Override public void close() throws IOException {     serverSocketChannel.close(). }
