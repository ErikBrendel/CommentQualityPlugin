# id;timestamp;commentText;codeText;commentWords;codeWords
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1467726666;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int NUM_ELEMENTS = 10____		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())____		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1472663071;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int NUM_ELEMENTS = 10____		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())____		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1473347848;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int NUM_ELEMENTS = 10____		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())____		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1476448412;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int NUM_ELEMENTS = 10____		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())____		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1477069385;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int NUM_ELEMENTS = 10____		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())____		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1477989375;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int NUM_ELEMENTS = 10____		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())____		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1482249704;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int NUM_ELEMENTS = 10____		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())____		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1491500150;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int NUM_ELEMENTS = 10____		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())____		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1493975167;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int NUM_ELEMENTS = 10____		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())____		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1499899067;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, numElements))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,num,elements,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1509404699;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, numElements))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,num,elements,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1515177485;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, numElements))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,num,elements,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1521828710;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, numElements))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,num,elements,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1529682304;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, numElements))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,num,elements,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1529682304;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, numElements))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,num,elements,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1530798894;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, numElements))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,num,elements,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampHandling() throws Exception;1540389860;These check whether timestamps are properly assigned at the sources and handled in_network transmission and between chained operators when timestamps are enabled.;@Test_	public void testTimestampHandling() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0L, numElements))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(0L, numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,assigned,at,the,sources,and,handled,in,network,transmission,and,between,chained,operators,when,timestamps,are,enabled;test,public,void,test,timestamp,handling,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0l,num,elements,data,stream,integer,source2,env,add,source,new,my,timestamp,source,0l,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1467726666;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {_					_					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1472663071;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {_					_					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1473347848;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {_					_					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1476448412;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {_					_					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1477069385;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {_					_					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1477989375;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {_					_					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1482249704;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {_					_					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1491500150;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {_					_					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1493975167;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {_					_					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1499899067;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1509404699;This thests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,thests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1515177485;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1521828710;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1529682304;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1529682304;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1530798894;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception;1540389860;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermark are correctly forwarded from the custom watermark emit_function.;@Test_	public void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermark,are,correctly,forwarded,from,the,custom,watermark,emit,function;test,public,void,test,timestamp,extractor,with,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1467726666;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int NUM_ELEMENTS = 10__		_		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()__		_		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())__		_		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1472663071;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int NUM_ELEMENTS = 10__		_		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()__		_		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())__		_		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1473347848;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int NUM_ELEMENTS = 10__		_		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()__		_		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())__		_		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1476448412;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int NUM_ELEMENTS = 10__		_		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()__		_		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())__		_		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1477069385;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int NUM_ELEMENTS = 10__		_		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()__		_		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())__		_		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1477989375;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int NUM_ELEMENTS = 10__		_		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()__		_		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())__		_		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1482249704;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int NUM_ELEMENTS = 10__		_		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()__		_		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())__		_		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1491500150;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int NUM_ELEMENTS = 10__		_		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()__		_		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())__		_		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1493975167;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int NUM_ELEMENTS = 10__		_		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()__		_		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(NUM_ELEMENTS))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())__		_		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1499899067;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(numElements))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,num,elements,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1509404699;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(numElements))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,num,elements,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1515177485;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(numElements))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,num,elements,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1521828710;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(numElements))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,num,elements,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1529682304;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(numElements))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,num,elements,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1529682304;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(numElements))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,num,elements,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1530798894;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(numElements))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,num,elements,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testDisabledTimestamps() throws Exception;1540389860;These check whether timestamps are properly ignored when they are disabled.;@Test_	public void testDisabledTimestamps() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyNonWatermarkingSource(numElements))__		DataStream<Integer> source2 = env.addSource(new MyNonWatermarkingSource(numElements))___		source1_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new DisabledTimestampCheckingOperator())_				.addSink(new DiscardingSink<Integer>())___		env.execute()__	};these,check,whether,timestamps,are,properly,ignored,when,they,are,disabled;test,public,void,test,disabled,timestamps,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,processing,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,non,watermarking,source,num,elements,data,stream,integer,source2,env,add,source,new,my,non,watermarking,source,num,elements,source1,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,disabled,timestamp,checking,operator,add,sink,new,discarding,sink,integer,env,execute
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1467726666;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>_This also checks whether watermarks keep propagating if a source closes early.__<p>_This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int NUM_WATERMARKS = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < NUM_WATERMARKS / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= NUM_WATERMARKS / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}_			_			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size()-1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1472663071;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>_This also checks whether watermarks keep propagating if a source closes early.__<p>_This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int NUM_WATERMARKS = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < NUM_WATERMARKS / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= NUM_WATERMARKS / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}_			_			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size()-1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1473347848;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>_This also checks whether watermarks keep propagating if a source closes early.__<p>_This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int NUM_WATERMARKS = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < NUM_WATERMARKS / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= NUM_WATERMARKS / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}_			_			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size()-1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1476448412;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>_This also checks whether watermarks keep propagating if a source closes early.__<p>_This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int NUM_WATERMARKS = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < NUM_WATERMARKS / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= NUM_WATERMARKS / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}_			_			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size()-1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1477069385;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>_This also checks whether watermarks keep propagating if a source closes early.__<p>_This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int NUM_WATERMARKS = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < NUM_WATERMARKS / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= NUM_WATERMARKS / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}_			_			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size()-1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1477989375;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>_This also checks whether watermarks keep propagating if a source closes early.__<p>_This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int NUM_WATERMARKS = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < NUM_WATERMARKS / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= NUM_WATERMARKS / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}_			_			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size()-1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1482249704;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>_This also checks whether watermarks keep propagating if a source closes early.__<p>_This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int NUM_WATERMARKS = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < NUM_WATERMARKS / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= NUM_WATERMARKS / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}_			_			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size()-1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1491500150;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>_This also checks whether watermarks keep propagating if a source closes early.__<p>_This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int NUM_WATERMARKS = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(_				"localhost", cluster.getLeaderRPCPort())__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < NUM_WATERMARKS / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= NUM_WATERMARKS / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}_			_			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size()-1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1493975167;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>_This also checks whether watermarks keep propagating if a source closes early.__<p>_This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int NUM_WATERMARKS = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		_		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, NUM_WATERMARKS / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < NUM_WATERMARKS / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= NUM_WATERMARKS / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}_			_			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size()-1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1499899067;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>This also checks whether watermarks keep propagating if a source closes early.__<p>This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int numWatermarks = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, numWatermarks))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, numWatermarks / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < numWatermarks / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= numWatermarks / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}__			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size() - 1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,num,watermarks,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,num,watermarks,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,num,watermarks,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1509404699;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>This also checks whether watermarks keep propagating if a source closes early.__<p>This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int numWatermarks = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, numWatermarks))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, numWatermarks / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < numWatermarks / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= numWatermarks / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}__			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size() - 1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,num,watermarks,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,num,watermarks,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,num,watermarks,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1515177485;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>This also checks whether watermarks keep propagating if a source closes early.__<p>This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int numWatermarks = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, numWatermarks))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, numWatermarks / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < numWatermarks / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= numWatermarks / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}__			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size() - 1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,num,watermarks,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,num,watermarks,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,num,watermarks,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1521828710;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>This also checks whether watermarks keep propagating if a source closes early.__<p>This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int numWatermarks = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, numWatermarks))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, numWatermarks / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < numWatermarks / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= numWatermarks / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}__			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size() - 1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,num,watermarks,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,num,watermarks,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,num,watermarks,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1529682304;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>This also checks whether watermarks keep propagating if a source closes early.__<p>This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int numWatermarks = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, numWatermarks))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, numWatermarks / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < numWatermarks / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= numWatermarks / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}__			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size() - 1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,num,watermarks,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,num,watermarks,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,num,watermarks,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1529682304;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>This also checks whether watermarks keep propagating if a source closes early.__<p>This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int numWatermarks = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, numWatermarks))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, numWatermarks / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < numWatermarks / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= numWatermarks / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}__			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size() - 1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,num,watermarks,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,num,watermarks,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,num,watermarks,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1530798894;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>This also checks whether watermarks keep propagating if a source closes early.__<p>This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int numWatermarks = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, numWatermarks))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, numWatermarks / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < numWatermarks / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= numWatermarks / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}__			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size() - 1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,num,watermarks,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,num,watermarks,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,num,watermarks,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testWatermarkPropagation() throws Exception;1540389860;These check whether custom timestamp emission works at sources and also whether timestamps_arrive at operators throughout a topology.__<p>This also checks whether watermarks keep propagating if a source closes early.__<p>This only uses map to test the workings of watermarks in a complete, running topology. All_tasks and stream operators have dedicated tests that test the watermark propagation_behaviour.;@Test_	public void testWatermarkPropagation() throws Exception {_		final int numWatermarks = 10___		long initialTime = 0L___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.setParallelism(PARALLELISM)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(initialTime, numWatermarks))__		DataStream<Integer> source2 = env.addSource(new MyTimestampSource(initialTime, numWatermarks / 2))___		source1.union(source2)_				.map(new IdentityMap())_				.connect(source2).map(new IdentityCoMap())_				.transform("Custom Operator", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.addSink(new DiscardingSink<Integer>())___		env.execute()___		_		for (int i = 0_ i < PARALLELISM_ i++) {_			_			_			for (int j = 0_ j < numWatermarks / 2_ j++) {_				if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {_					System.err.println("All Watermarks: ")__					for (int k = 0_ k <= numWatermarks / 2_ k++) {_						System.err.println(CustomOperator.finalWatermarks[i].get(k))__					}__					fail("Wrong watermark.")__				}_			}__			assertEquals(Watermark.MAX_WATERMARK,_					CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size() - 1))__		}_	};these,check,whether,custom,timestamp,emission,works,at,sources,and,also,whether,timestamps,arrive,at,operators,throughout,a,topology,p,this,also,checks,whether,watermarks,keep,propagating,if,a,source,closes,early,p,this,only,uses,map,to,test,the,workings,of,watermarks,in,a,complete,running,topology,all,tasks,and,stream,operators,have,dedicated,tests,that,test,the,watermark,propagation,behaviour;test,public,void,test,watermark,propagation,throws,exception,final,int,num,watermarks,10,long,initial,time,0l,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,set,parallelism,parallelism,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,data,stream,integer,source2,env,add,source,new,my,timestamp,source,initial,time,num,watermarks,2,source1,union,source2,map,new,identity,map,connect,source2,map,new,identity,co,map,transform,custom,operator,basic,type,info,new,custom,operator,true,add,sink,new,discarding,sink,integer,env,execute,for,int,i,0,i,parallelism,i,for,int,j,0,j,num,watermarks,2,j,if,custom,operator,final,watermarks,i,get,j,equals,new,watermark,initial,time,j,system,err,println,all,watermarks,for,int,k,0,k,num,watermarks,2,k,system,err,println,custom,operator,final,watermarks,i,get,k,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,i,get,custom,operator,final,watermarks,i,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1467726666;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__Same test as before, but using a different timestamp extractor;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))__		_		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1472663071;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__Same test as before, but using a different timestamp extractor;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))__		_		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1473347848;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__Same test as before, but using a different timestamp extractor;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))__		_		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1476448412;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__Same test as before, but using a different timestamp extractor;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))__		_		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1477069385;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__Same test as before, but using a different timestamp extractor;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))__		_		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1477989375;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__Same test as before, but using a different timestamp extractor;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))__		_		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1482249704;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__Same test as before, but using a different timestamp extractor;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))__		_		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1491500150;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__Same test as before, but using a different timestamp extractor;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))__		_		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1493975167;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__Same test as before, but using a different timestamp extractor;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))__		_		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1499899067;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__<p>Same test as before, but using a different timestamp extractor.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,p,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1509404699;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__<p>Same test as before, but using a different timestamp extractor.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,p,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1515177485;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__<p>Same test as before, but using a different timestamp extractor.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,p,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1521828710;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__<p>Same test as before, but using a different timestamp extractor.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,p,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1529682304;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__<p>Same test as before, but using a different timestamp extractor.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,p,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1529682304;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__<p>Same test as before, but using a different timestamp extractor.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,p,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1530798894;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__<p>Same test as before, but using a different timestamp extractor.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,p,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception;1540389860;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.__<p>Same test as before, but using a different timestamp extractor.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment_				.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark getCurrentWatermark() {_						return null__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks,p,same,test,as,before,but,using,a,different,timestamp,extractor;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source2,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,periodic,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,get,current,watermark,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1467726666;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env = _				StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())__		_		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1472663071;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env = _				StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())__		_		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1473347848;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env = _				StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())__		_		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1476448412;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env = _				StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())__		_		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1477069385;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env = _				StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())__		_		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1477989375;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env = _				StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())__		_		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1482249704;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env = _				StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())__		_		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1491500150;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env = _				StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())__		_		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1493975167;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env = _				StreamExecutionEnvironment.getExecutionEnvironment()__		_		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1499899067;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env =_				StreamExecutionEnvironment.getExecutionEnvironment()___		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1509404699;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env =_				StreamExecutionEnvironment.getExecutionEnvironment()___		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1515177485;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env =_				StreamExecutionEnvironment.getExecutionEnvironment()___		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1521828710;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env =_				StreamExecutionEnvironment.getExecutionEnvironment()___		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1529682304;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env =_				StreamExecutionEnvironment.getExecutionEnvironment()___		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1529682304;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env =_				StreamExecutionEnvironment.getExecutionEnvironment()___		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1530798894;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env =_				StreamExecutionEnvironment.getExecutionEnvironment()___		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testEventTimeSourceWithProcessingTime() throws Exception;1540389860;This verifies that an event time source works when setting stream time characteristic to_processing time. In this case, the watermarks should just be swallowed.;@Test_	public void testEventTimeSourceWithProcessingTime() throws Exception {_		StreamExecutionEnvironment env =_				StreamExecutionEnvironment.getExecutionEnvironment()___		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()__		env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		DataStream<Integer> source1 = env.addSource(new MyTimestampSource(0, 10))___		source1_			.map(new IdentityMap())_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(false))___		env.execute()___		_		_		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 0)__	};this,verifies,that,an,event,time,source,works,when,setting,stream,time,characteristic,to,processing,time,in,this,case,the,watermarks,should,just,be,swallowed;test,public,void,test,event,time,source,with,processing,time,throws,exception,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,2,env,get,config,disable,sysout,logging,env,set,stream,time,characteristic,time,characteristic,processing,time,data,stream,integer,source1,env,add,source,new,my,timestamp,source,0,10,source1,map,new,identity,map,transform,watermark,check,basic,type,info,new,custom,operator,false,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,0
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1467726666;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))____		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1472663071;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))____		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1473347848;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))____		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1476448412;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))____		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1477069385;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))____		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1477989375;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))____		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1482249704;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))____		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1491500150;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))____		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1493975167;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index-2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))____		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1499899067;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1509404699;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1515177485;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1521828710;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1529682304;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1529682304;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1530798894;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception;1540389860;This test verifies that the timestamp extractor forwards Long.MAX_VALUE watermarks.;@Test_	public void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(2)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collectWithTimestamp(index, index)__					ctx.collectWithTimestamp(index - 1, index - 1)__					index++__					ctx.emitWatermark(new Watermark(index - 2))__				}__				_				_				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__				ctx.emitWatermark(new Watermark(Long.MAX_VALUE))__			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long currentTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return null__					}_				})_			.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))___		env.execute()___		Assert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1)__		Assert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE)__	};this,test,verifies,that,the,timestamp,extractor,forwards,long,watermarks;test,public,void,test,timestamp,extractor,with,long,max,watermark,from,source,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,2,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,with,timestamp,index,index,ctx,collect,with,timestamp,index,1,index,1,index,ctx,emit,watermark,new,watermark,index,2,ctx,emit,watermark,new,watermark,long,ctx,emit,watermark,new,watermark,long,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,current,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,null,transform,watermark,check,basic,type,info,new,custom,operator,true,env,execute,assert,assert,true,custom,operator,final,watermarks,0,size,1,assert,assert,true,custom,operator,final,watermarks,0,get,0,get,timestamp,long
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1467726666;This test verifies that the timestamp extractor does not emit decreasing watermarks even;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks,even;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1472663071;This test verifies that the timestamp extractor does not emit decreasing watermarks even;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks,even;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1473347848;This test verifies that the timestamp extractor does not emit decreasing watermarks even;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks,even;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1476448412;This test verifies that the timestamp extractor does not emit decreasing watermarks even;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks,even;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1477069385;This test verifies that the timestamp extractor does not emit decreasing watermarks even;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks,even;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1477989375;This test verifies that the timestamp extractor does not emit decreasing watermarks even;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks,even;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1482249704;This test verifies that the timestamp extractor does not emit decreasing watermarks even;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks,even;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1491500150;This test verifies that the timestamp extractor does not emit decreasing watermarks even;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks,even;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1493975167;This test verifies that the timestamp extractor does not emit decreasing watermarks even;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())____		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks,even;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1499899067;This test verifies that the timestamp extractor does not emit decreasing watermarks.;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1509404699;This test verifies that the timestamp extractor does not emit decreasing watermarks.;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1515177485;This test verifies that the timestamp extractor does not emit decreasing watermarks.;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1521828710;This test verifies that the timestamp extractor does not emit decreasing watermarks.;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1529682304;This test verifies that the timestamp extractor does not emit decreasing watermarks.;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1529682304;This test verifies that the timestamp extractor does not emit decreasing watermarks.;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1530798894;This test verifies that the timestamp extractor does not emit decreasing watermarks.;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception;1540389860;This test verifies that the timestamp extractor does not emit decreasing watermarks.;@Test_	public void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(1)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					Thread.sleep(100)__					ctx.collect(index - 1)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		source1_				.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {__					@Override_					public long extractTimestamp(Integer element, long previousTimestamp) {_						return element__					}__					@Override_					public Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {_						return new Watermark(extractedTimestamp - 1)__					}_				})_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				Assert.fail("Wrong watermark.")__			}_		}_		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,test,verifies,that,the,timestamp,extractor,does,not,emit,decreasing,watermarks;test,public,void,test,timestamp,extractor,with,decreasing,custom,watermark,emit,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,1,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,thread,sleep,100,ctx,collect,index,1,latch,await,index,override,public,void,cancel,source1,assign,timestamps,and,watermarks,new,assigner,with,punctuated,watermarks,integer,override,public,long,extract,timestamp,integer,element,long,previous,timestamp,return,element,override,public,watermark,check,and,get,next,watermark,integer,element,long,extracted,timestamp,return,new,watermark,extracted,timestamp,1,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,assert,fail,wrong,watermark,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1467726666;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}_		_		_		assertEquals(Watermark.MAX_WATERMARK, _				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1472663071;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}_		_		_		assertEquals(Watermark.MAX_WATERMARK, _				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1473347848;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}_		_		_		assertEquals(Watermark.MAX_WATERMARK, _				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1476448412;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}_		_		_		assertEquals(Watermark.MAX_WATERMARK, _				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1477069385;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}_		_		_		assertEquals(Watermark.MAX_WATERMARK, _				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1477989375;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}_		_		_		assertEquals(Watermark.MAX_WATERMARK, _				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1482249704;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}_		_		_		assertEquals(Watermark.MAX_WATERMARK, _				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1491500150;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", cluster.getLeaderRPCPort())___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}_		_		_		assertEquals(Watermark.MAX_WATERMARK, _				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,create,remote,environment,localhost,cluster,get,leader,rpcport,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1493975167;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int NUM_ELEMENTS = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()____		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= NUM_ELEMENTS) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < NUM_ELEMENTS_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}_		_		_		assertEquals(Watermark.MAX_WATERMARK, _				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1499899067;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1509404699;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwared from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwared,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1515177485;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwarded from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwarded,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1521828710;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwarded from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwarded,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1529682304;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwarded from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwarded,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1529682304;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwarded from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwarded,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1530798894;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwarded from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwarded,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
TimestampITCase -> @Test 	public void testTimestampExtractorWithAutoInterval() throws Exception;1540389860;This tests whether timestamps are properly extracted in the timestamp_extractor and whether watermarks are also correctly forwarded from this with the auto watermark_interval.;@Test_	public void testTimestampExtractorWithAutoInterval() throws Exception {_		final int numElements = 10___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()___		env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)__		env.getConfig().setAutoWatermarkInterval(10)__		env.setParallelism(1)__		env.getConfig().disableSysoutLogging()___		DataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {_			@Override_			public void run(SourceContext<Integer> ctx) throws Exception {_				int index = 1__				while (index <= numElements) {_					ctx.collect(index)__					latch.await()__					index++__				}_			}__			@Override_			public void cancel() {}_		})___		DataStream<Integer> extractOp = source1.assignTimestampsAndWatermarks(_				new AscendingTimestampExtractor<Integer>() {_					@Override_					public long extractAscendingTimestamp(Integer element) {_						return element__					}_				})___		extractOp_				.transform("Watermark Check", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))_				.transform("Timestamp Check",_						BasicTypeInfo.INT_TYPE_INFO,_						new TimestampCheckingOperator())___		_		Assert.assertEquals(extractOp.getTransformation().getParallelism(), source1.getTransformation().getParallelism())___		env.execute()___		_		for (int j = 0_ j < numElements_ j++) {_			if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {_				long wm = CustomOperator.finalWatermarks[0].get(j).getTimestamp()__				Assert.fail("Wrong watermark. Expected: " + j + " Found: " + wm + " All: " + CustomOperator.finalWatermarks[0])__			}_		}__		_		assertEquals(Watermark.MAX_WATERMARK,_				CustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1))__	};this,tests,whether,timestamps,are,properly,extracted,in,the,timestamp,extractor,and,whether,watermarks,are,also,correctly,forwarded,from,this,with,the,auto,watermark,interval;test,public,void,test,timestamp,extractor,with,auto,interval,throws,exception,final,int,num,elements,10,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,stream,time,characteristic,time,characteristic,event,time,env,get,config,set,auto,watermark,interval,10,env,set,parallelism,1,env,get,config,disable,sysout,logging,data,stream,integer,source1,env,add,source,new,source,function,integer,override,public,void,run,source,context,integer,ctx,throws,exception,int,index,1,while,index,num,elements,ctx,collect,index,latch,await,index,override,public,void,cancel,data,stream,integer,extract,op,source1,assign,timestamps,and,watermarks,new,ascending,timestamp,extractor,integer,override,public,long,extract,ascending,timestamp,integer,element,return,element,extract,op,transform,watermark,check,basic,type,info,new,custom,operator,true,transform,timestamp,check,basic,type,info,new,timestamp,checking,operator,assert,assert,equals,extract,op,get,transformation,get,parallelism,source1,get,transformation,get,parallelism,env,execute,for,int,j,0,j,num,elements,j,if,custom,operator,final,watermarks,0,get,j,equals,new,watermark,j,long,wm,custom,operator,final,watermarks,0,get,j,get,timestamp,assert,fail,wrong,watermark,expected,j,found,wm,all,custom,operator,final,watermarks,0,assert,equals,watermark,custom,operator,final,watermarks,0,get,custom,operator,final,watermarks,0,size,1
