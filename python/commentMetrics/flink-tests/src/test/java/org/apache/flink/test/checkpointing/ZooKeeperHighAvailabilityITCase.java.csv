# id;timestamp;commentText;codeText;commentWords;codeWords
ZooKeeperHighAvailabilityITCase -> @Test 	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception;1534779647;Verify that we don't start a job from scratch if we cannot restore any of the_CompletedCheckpoints.__<p>Synchronization for the different steps and things we want to observe happens via_latches in the test method and the methods of {@link CheckpointBlockingFunction}.__<p>The test follows these steps:_<ol>_<li>Start job and block on a latch until we have done some checkpoints_<li>Block in the special function_<li>Move away the contents of the ZooKeeper HA directory to make restoring from_checkpoints impossible_<li>Unblock the special function, which now induces a failure_<li>Make sure that the job does not recover successfully_<li>Move back the HA directory_<li>Make sure that the job recovers, we use a latch to ensure that the operator_restored successfully_</ol>;@Test_	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception {_		CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.set(1)__		CheckpointBlockingFunction.successfulRestores.set(0)__		CheckpointBlockingFunction.illegalRestores.set(0)__		CheckpointBlockingFunction.afterMessWithZooKeeper.set(false)__		CheckpointBlockingFunction.failedAlready.set(false)___		waitForCheckpointLatch = new OneShotLatch()__		failInCheckpointLatch = new OneShotLatch()___		ClusterClient<?> clusterClient = miniClusterResource.getClusterClient()__		final Deadline deadline = Deadline.now().plus(TEST_TIMEOUT)___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)__		env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0))__		env.enableCheckpointing(10)_ __		File checkpointLocation = TEMPORARY_FOLDER.newFolder()__		env.setStateBackend((StateBackend) new FsStateBackend(checkpointLocation.toURI()))___		DataStreamSource<String> source = env.addSource(new UnboundedSource())___		source_			.keyBy((str) -> str)_			.map(new CheckpointBlockingFunction())___		JobGraph jobGraph = env.getStreamGraph().getJobGraph()__		JobID jobID = Preconditions.checkNotNull(jobGraph.getJobID())___		clusterClient.setDetached(true)__		clusterClient.submitJob(jobGraph, ZooKeeperHighAvailabilityITCase.class.getClassLoader())___		_		waitForCheckpointLatch.await()___		log.debug("Messing with HA directory")__		_		File movedCheckpointLocation = TEMPORARY_FOLDER.newFolder()__		AtomicInteger numCheckpoints = new AtomicInteger()__		Files.walkFileTree(haStorageDir.toPath(), new SimpleFileVisitor<Path>() {_			@Override_			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {_				if (file.getFileName().toString().startsWith("completedCheckpoint")) {_					log.debug("Moving original checkpoint file {}.", file)__					try {_						Files.move(file, movedCheckpointLocation.toPath().resolve(file.getFileName()))__						numCheckpoints.incrementAndGet()__					} catch (IOException ioe) {_						_						log.debug("Exception while moving HA files.", ioe)__					}_				}_				return FileVisitResult.CONTINUE__			}_		})___		_		_		_		_		_		_		assertTrue(numCheckpoints.get() > 0)___		log.debug("Resuming job")__		failInCheckpointLatch.trigger()___		assertNotNull("fullRestarts metric could not be accessed.", RestartReporter.numRestarts)__		while (RestartReporter.numRestarts.getValue() < 5 && deadline.hasTimeLeft()) {_			Thread.sleep(50)__		}_		assertThat(RestartReporter.numRestarts.getValue(), is(greaterThan(4L)))___		_		CheckpointBlockingFunction.afterMessWithZooKeeper.set(true)__		log.debug("Restored zookeeper")___		Files.walkFileTree(movedCheckpointLocation.toPath(), new SimpleFileVisitor<Path>() {_			@Override_			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {_				Files.move(file, haStorageDir.toPath().resolve(file.getFileName()))__				return FileVisitResult.CONTINUE__			}_		})___		_		_		CompletableFuture<JobStatus> jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(50),_			deadline,_			JobStatus::isGloballyTerminalState,_			TestingUtils.defaultScheduledExecutor())__		try {_			assertEquals(JobStatus.FINISHED, jobStatusFuture.get())__		} catch (Throwable e) {_			_			StringWriter error = new StringWriter()__			try (PrintWriter out = new PrintWriter(error)) {_				out.println("The job did not finish in time.")__				out.println("allowedInitializeCallsWithoutRestore= " + CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.get())__				out.println("illegalRestores= " + CheckpointBlockingFunction.illegalRestores.get())__				out.println("successfulRestores= " + CheckpointBlockingFunction.successfulRestores.get())__				out.println("afterMessWithZooKeeper= " + CheckpointBlockingFunction.afterMessWithZooKeeper.get())__				out.println("failedAlready= " + CheckpointBlockingFunction.failedAlready.get())__				out.println("currentJobStatus= " + clusterClient.getJobStatus(jobID).get())__				out.println("numRestarts= " + RestartReporter.numRestarts.getValue())__				out.println("threadDump= " + generateThreadDump())__			}_			throw new AssertionError(error.toString(), ExceptionUtils.stripCompletionException(e))__		}__		assertThat("We saw illegal restores.", CheckpointBlockingFunction.illegalRestores.get(), is(0))__	};verify,that,we,don,t,start,a,job,from,scratch,if,we,cannot,restore,any,of,the,completed,checkpoints,p,synchronization,for,the,different,steps,and,things,we,want,to,observe,happens,via,latches,in,the,test,method,and,the,methods,of,link,checkpoint,blocking,function,p,the,test,follows,these,steps,ol,li,start,job,and,block,on,a,latch,until,we,have,done,some,checkpoints,li,block,in,the,special,function,li,move,away,the,contents,of,the,zoo,keeper,ha,directory,to,make,restoring,from,checkpoints,impossible,li,unblock,the,special,function,which,now,induces,a,failure,li,make,sure,that,the,job,does,not,recover,successfully,li,move,back,the,ha,directory,li,make,sure,that,the,job,recovers,we,use,a,latch,to,ensure,that,the,operator,restored,successfully,ol;test,public,void,test,restore,behaviour,with,faulty,state,handles,throws,exception,checkpoint,blocking,function,allowed,initialize,calls,without,restore,set,1,checkpoint,blocking,function,successful,restores,set,0,checkpoint,blocking,function,illegal,restores,set,0,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,false,checkpoint,blocking,function,failed,already,set,false,wait,for,checkpoint,latch,new,one,shot,latch,fail,in,checkpoint,latch,new,one,shot,latch,cluster,client,cluster,client,mini,cluster,resource,get,cluster,client,final,deadline,deadline,deadline,now,plus,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,env,set,restart,strategy,restart,strategies,fixed,delay,restart,integer,0,env,enable,checkpointing,10,file,checkpoint,location,new,folder,env,set,state,backend,state,backend,new,fs,state,backend,checkpoint,location,to,uri,data,stream,source,string,source,env,add,source,new,unbounded,source,source,key,by,str,str,map,new,checkpoint,blocking,function,job,graph,job,graph,env,get,stream,graph,get,job,graph,job,id,job,id,preconditions,check,not,null,job,graph,get,job,id,cluster,client,set,detached,true,cluster,client,submit,job,job,graph,zoo,keeper,high,availability,itcase,class,get,class,loader,wait,for,checkpoint,latch,await,log,debug,messing,with,ha,directory,file,moved,checkpoint,location,new,folder,atomic,integer,num,checkpoints,new,atomic,integer,files,walk,file,tree,ha,storage,dir,to,path,new,simple,file,visitor,path,override,public,file,visit,result,visit,file,path,file,basic,file,attributes,attrs,if,file,get,file,name,to,string,starts,with,completed,checkpoint,log,debug,moving,original,checkpoint,file,file,try,files,move,file,moved,checkpoint,location,to,path,resolve,file,get,file,name,num,checkpoints,increment,and,get,catch,ioexception,ioe,log,debug,exception,while,moving,ha,files,ioe,return,file,visit,result,continue,assert,true,num,checkpoints,get,0,log,debug,resuming,job,fail,in,checkpoint,latch,trigger,assert,not,null,full,restarts,metric,could,not,be,accessed,restart,reporter,num,restarts,while,restart,reporter,num,restarts,get,value,5,deadline,has,time,left,thread,sleep,50,assert,that,restart,reporter,num,restarts,get,value,is,greater,than,4l,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,true,log,debug,restored,zookeeper,files,walk,file,tree,moved,checkpoint,location,to,path,new,simple,file,visitor,path,override,public,file,visit,result,visit,file,path,file,basic,file,attributes,attrs,throws,ioexception,files,move,file,ha,storage,dir,to,path,resolve,file,get,file,name,return,file,visit,result,continue,completable,future,job,status,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,50,deadline,job,status,is,globally,terminal,state,testing,utils,default,scheduled,executor,try,assert,equals,job,status,finished,job,status,future,get,catch,throwable,e,string,writer,error,new,string,writer,try,print,writer,out,new,print,writer,error,out,println,the,job,did,not,finish,in,time,out,println,allowed,initialize,calls,without,restore,checkpoint,blocking,function,allowed,initialize,calls,without,restore,get,out,println,illegal,restores,checkpoint,blocking,function,illegal,restores,get,out,println,successful,restores,checkpoint,blocking,function,successful,restores,get,out,println,after,mess,with,zoo,keeper,checkpoint,blocking,function,after,mess,with,zoo,keeper,get,out,println,failed,already,checkpoint,blocking,function,failed,already,get,out,println,current,job,status,cluster,client,get,job,status,job,id,get,out,println,num,restarts,restart,reporter,num,restarts,get,value,out,println,thread,dump,generate,thread,dump,throw,new,assertion,error,error,to,string,exception,utils,strip,completion,exception,e,assert,that,we,saw,illegal,restores,checkpoint,blocking,function,illegal,restores,get,is,0
ZooKeeperHighAvailabilityITCase -> @Test 	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception;1540216840;Verify that we don't start a job from scratch if we cannot restore any of the_CompletedCheckpoints.__<p>Synchronization for the different steps and things we want to observe happens via_latches in the test method and the methods of {@link CheckpointBlockingFunction}.__<p>The test follows these steps:_<ol>_<li>Start job and block on a latch until we have done some checkpoints_<li>Block in the special function_<li>Move away the contents of the ZooKeeper HA directory to make restoring from_checkpoints impossible_<li>Unblock the special function, which now induces a failure_<li>Make sure that the job does not recover successfully_<li>Move back the HA directory_<li>Make sure that the job recovers, we use a latch to ensure that the operator_restored successfully_</ol>;@Test_	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception {_		CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.set(1)__		CheckpointBlockingFunction.successfulRestores.set(0)__		CheckpointBlockingFunction.illegalRestores.set(0)__		CheckpointBlockingFunction.afterMessWithZooKeeper.set(false)__		CheckpointBlockingFunction.failedAlready.set(false)___		waitForCheckpointLatch = new OneShotLatch()__		failInCheckpointLatch = new OneShotLatch()___		ClusterClient<?> clusterClient = miniClusterResource.getClusterClient()__		final Deadline deadline = Deadline.now().plus(TEST_TIMEOUT)___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)__		env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0))__		env.enableCheckpointing(10)_ __		File checkpointLocation = TEMPORARY_FOLDER.newFolder()__		env.setStateBackend((StateBackend) new FsStateBackend(checkpointLocation.toURI()))___		DataStreamSource<String> source = env.addSource(new UnboundedSource())___		source_			.keyBy((str) -> str)_			.map(new CheckpointBlockingFunction())___		JobGraph jobGraph = env.getStreamGraph().getJobGraph()__		JobID jobID = Preconditions.checkNotNull(jobGraph.getJobID())___		clusterClient.setDetached(true)__		clusterClient.submitJob(jobGraph, ZooKeeperHighAvailabilityITCase.class.getClassLoader())___		_		waitForCheckpointLatch.await()___		log.debug("Messing with HA directory")__		_		File movedCheckpointLocation = TEMPORARY_FOLDER.newFolder()__		AtomicInteger numCheckpoints = new AtomicInteger()__		Files.walkFileTree(haStorageDir.toPath(), new SimpleFileVisitor<Path>() {_			@Override_			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {_				if (file.getFileName().toString().startsWith("completedCheckpoint")) {_					log.debug("Moving original checkpoint file {}.", file)__					try {_						Files.move(file, movedCheckpointLocation.toPath().resolve(file.getFileName()))__						numCheckpoints.incrementAndGet()__					} catch (IOException ioe) {_						_						log.debug("Exception while moving HA files.", ioe)__					}_				}_				return FileVisitResult.CONTINUE__			}_		})___		_		_		_		_		_		_		assertTrue(numCheckpoints.get() > 0)___		log.debug("Resuming job")__		failInCheckpointLatch.trigger()___		assertNotNull("fullRestarts metric could not be accessed.", RestartReporter.numRestarts)__		while (RestartReporter.numRestarts.getValue() < 5 && deadline.hasTimeLeft()) {_			Thread.sleep(50)__		}_		assertThat(RestartReporter.numRestarts.getValue(), is(greaterThan(4L)))___		_		CheckpointBlockingFunction.afterMessWithZooKeeper.set(true)__		log.debug("Restored zookeeper")___		Files.walkFileTree(movedCheckpointLocation.toPath(), new SimpleFileVisitor<Path>() {_			@Override_			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {_				Files.move(file, haStorageDir.toPath().resolve(file.getFileName()))__				return FileVisitResult.CONTINUE__			}_		})___		_		_		CompletableFuture<JobStatus> jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(50),_			deadline,_			JobStatus::isGloballyTerminalState,_			TestingUtils.defaultScheduledExecutor())__		try {_			assertEquals(JobStatus.FINISHED, jobStatusFuture.get())__		} catch (Throwable e) {_			_			StringWriter error = new StringWriter()__			try (PrintWriter out = new PrintWriter(error)) {_				out.println("The job did not finish in time.")__				out.println("allowedInitializeCallsWithoutRestore= " + CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.get())__				out.println("illegalRestores= " + CheckpointBlockingFunction.illegalRestores.get())__				out.println("successfulRestores= " + CheckpointBlockingFunction.successfulRestores.get())__				out.println("afterMessWithZooKeeper= " + CheckpointBlockingFunction.afterMessWithZooKeeper.get())__				out.println("failedAlready= " + CheckpointBlockingFunction.failedAlready.get())__				out.println("currentJobStatus= " + clusterClient.getJobStatus(jobID).get())__				out.println("numRestarts= " + RestartReporter.numRestarts.getValue())__				out.println("threadDump= " + generateThreadDump())__			}_			throw new AssertionError(error.toString(), ExceptionUtils.stripCompletionException(e))__		}__		assertThat("We saw illegal restores.", CheckpointBlockingFunction.illegalRestores.get(), is(0))__	};verify,that,we,don,t,start,a,job,from,scratch,if,we,cannot,restore,any,of,the,completed,checkpoints,p,synchronization,for,the,different,steps,and,things,we,want,to,observe,happens,via,latches,in,the,test,method,and,the,methods,of,link,checkpoint,blocking,function,p,the,test,follows,these,steps,ol,li,start,job,and,block,on,a,latch,until,we,have,done,some,checkpoints,li,block,in,the,special,function,li,move,away,the,contents,of,the,zoo,keeper,ha,directory,to,make,restoring,from,checkpoints,impossible,li,unblock,the,special,function,which,now,induces,a,failure,li,make,sure,that,the,job,does,not,recover,successfully,li,move,back,the,ha,directory,li,make,sure,that,the,job,recovers,we,use,a,latch,to,ensure,that,the,operator,restored,successfully,ol;test,public,void,test,restore,behaviour,with,faulty,state,handles,throws,exception,checkpoint,blocking,function,allowed,initialize,calls,without,restore,set,1,checkpoint,blocking,function,successful,restores,set,0,checkpoint,blocking,function,illegal,restores,set,0,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,false,checkpoint,blocking,function,failed,already,set,false,wait,for,checkpoint,latch,new,one,shot,latch,fail,in,checkpoint,latch,new,one,shot,latch,cluster,client,cluster,client,mini,cluster,resource,get,cluster,client,final,deadline,deadline,deadline,now,plus,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,env,set,restart,strategy,restart,strategies,fixed,delay,restart,integer,0,env,enable,checkpointing,10,file,checkpoint,location,new,folder,env,set,state,backend,state,backend,new,fs,state,backend,checkpoint,location,to,uri,data,stream,source,string,source,env,add,source,new,unbounded,source,source,key,by,str,str,map,new,checkpoint,blocking,function,job,graph,job,graph,env,get,stream,graph,get,job,graph,job,id,job,id,preconditions,check,not,null,job,graph,get,job,id,cluster,client,set,detached,true,cluster,client,submit,job,job,graph,zoo,keeper,high,availability,itcase,class,get,class,loader,wait,for,checkpoint,latch,await,log,debug,messing,with,ha,directory,file,moved,checkpoint,location,new,folder,atomic,integer,num,checkpoints,new,atomic,integer,files,walk,file,tree,ha,storage,dir,to,path,new,simple,file,visitor,path,override,public,file,visit,result,visit,file,path,file,basic,file,attributes,attrs,if,file,get,file,name,to,string,starts,with,completed,checkpoint,log,debug,moving,original,checkpoint,file,file,try,files,move,file,moved,checkpoint,location,to,path,resolve,file,get,file,name,num,checkpoints,increment,and,get,catch,ioexception,ioe,log,debug,exception,while,moving,ha,files,ioe,return,file,visit,result,continue,assert,true,num,checkpoints,get,0,log,debug,resuming,job,fail,in,checkpoint,latch,trigger,assert,not,null,full,restarts,metric,could,not,be,accessed,restart,reporter,num,restarts,while,restart,reporter,num,restarts,get,value,5,deadline,has,time,left,thread,sleep,50,assert,that,restart,reporter,num,restarts,get,value,is,greater,than,4l,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,true,log,debug,restored,zookeeper,files,walk,file,tree,moved,checkpoint,location,to,path,new,simple,file,visitor,path,override,public,file,visit,result,visit,file,path,file,basic,file,attributes,attrs,throws,ioexception,files,move,file,ha,storage,dir,to,path,resolve,file,get,file,name,return,file,visit,result,continue,completable,future,job,status,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,50,deadline,job,status,is,globally,terminal,state,testing,utils,default,scheduled,executor,try,assert,equals,job,status,finished,job,status,future,get,catch,throwable,e,string,writer,error,new,string,writer,try,print,writer,out,new,print,writer,error,out,println,the,job,did,not,finish,in,time,out,println,allowed,initialize,calls,without,restore,checkpoint,blocking,function,allowed,initialize,calls,without,restore,get,out,println,illegal,restores,checkpoint,blocking,function,illegal,restores,get,out,println,successful,restores,checkpoint,blocking,function,successful,restores,get,out,println,after,mess,with,zoo,keeper,checkpoint,blocking,function,after,mess,with,zoo,keeper,get,out,println,failed,already,checkpoint,blocking,function,failed,already,get,out,println,current,job,status,cluster,client,get,job,status,job,id,get,out,println,num,restarts,restart,reporter,num,restarts,get,value,out,println,thread,dump,generate,thread,dump,throw,new,assertion,error,error,to,string,exception,utils,strip,completion,exception,e,assert,that,we,saw,illegal,restores,checkpoint,blocking,function,illegal,restores,get,is,0
ZooKeeperHighAvailabilityITCase -> @Test 	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception;1542192035;Verify that we don't start a job from scratch if we cannot restore any of the_CompletedCheckpoints.__<p>Synchronization for the different steps and things we want to observe happens via_latches in the test method and the methods of {@link CheckpointBlockingFunction}.__<p>The test follows these steps:_<ol>_<li>Start job and block on a latch until we have done some checkpoints_<li>Block in the special function_<li>Move away the contents of the ZooKeeper HA directory to make restoring from_checkpoints impossible_<li>Unblock the special function, which now induces a failure_<li>Make sure that the job does not recover successfully_<li>Move back the HA directory_<li>Make sure that the job recovers, we use a latch to ensure that the operator_restored successfully_</ol>;@Test_	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception {_		CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.set(1)__		CheckpointBlockingFunction.successfulRestores.set(0)__		CheckpointBlockingFunction.illegalRestores.set(0)__		CheckpointBlockingFunction.afterMessWithZooKeeper.set(false)__		CheckpointBlockingFunction.failedAlready.set(false)___		waitForCheckpointLatch = new OneShotLatch()__		failInCheckpointLatch = new OneShotLatch()___		ClusterClient<?> clusterClient = miniClusterResource.getClusterClient()__		final Deadline deadline = Deadline.now().plus(TEST_TIMEOUT)___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)__		env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0))__		env.enableCheckpointing(10)_ __		File checkpointLocation = TEMPORARY_FOLDER.newFolder()__		env.setStateBackend((StateBackend) new FsStateBackend(checkpointLocation.toURI()))___		DataStreamSource<String> source = env.addSource(new UnboundedSource())___		source_			.keyBy((str) -> str)_			.map(new CheckpointBlockingFunction())___		JobGraph jobGraph = env.getStreamGraph().getJobGraph()__		JobID jobID = Preconditions.checkNotNull(jobGraph.getJobID())___		clusterClient.setDetached(true)__		clusterClient.submitJob(jobGraph, ZooKeeperHighAvailabilityITCase.class.getClassLoader())___		_		waitForCheckpointLatch.await()___		log.debug("Messing with HA directory")__		_		File movedCheckpointLocation = TEMPORARY_FOLDER.newFolder()__		AtomicInteger numCheckpoints = new AtomicInteger()__		Files.walkFileTree(haStorageDir.toPath(), new SimpleFileVisitor<Path>() {_			@Override_			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {_				if (file.getFileName().toString().startsWith("completedCheckpoint")) {_					log.debug("Moving original checkpoint file {}.", file)__					try {_						Files.move(file, movedCheckpointLocation.toPath().resolve(file.getFileName()))__						numCheckpoints.incrementAndGet()__					} catch (IOException ioe) {_						_						log.debug("Exception while moving HA files.", ioe)__					}_				}_				return FileVisitResult.CONTINUE__			}_		})___		_		_		_		_		_		_		assertTrue(numCheckpoints.get() > 0)___		log.debug("Resuming job")__		failInCheckpointLatch.trigger()___		assertNotNull("fullRestarts metric could not be accessed.", RestartReporter.numRestarts)__		while (RestartReporter.numRestarts.getValue() < 5 && deadline.hasTimeLeft()) {_			Thread.sleep(50)__		}_		assertThat(RestartReporter.numRestarts.getValue(), is(greaterThan(4L)))___		_		CheckpointBlockingFunction.afterMessWithZooKeeper.set(true)__		log.debug("Restored zookeeper")___		Files.walkFileTree(movedCheckpointLocation.toPath(), new SimpleFileVisitor<Path>() {_			@Override_			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {_				Files.move(file, haStorageDir.toPath().resolve(file.getFileName()))__				return FileVisitResult.CONTINUE__			}_		})___		_		_		CompletableFuture<JobStatus> jobStatusFuture = FutureUtils.retrySuccessfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(50),_			deadline,_			JobStatus::isGloballyTerminalState,_			TestingUtils.defaultScheduledExecutor())__		try {_			assertEquals(JobStatus.FINISHED, jobStatusFuture.get())__		} catch (Throwable e) {_			_			StringWriter error = new StringWriter()__			try (PrintWriter out = new PrintWriter(error)) {_				out.println("The job did not finish in time.")__				out.println("allowedInitializeCallsWithoutRestore= " + CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.get())__				out.println("illegalRestores= " + CheckpointBlockingFunction.illegalRestores.get())__				out.println("successfulRestores= " + CheckpointBlockingFunction.successfulRestores.get())__				out.println("afterMessWithZooKeeper= " + CheckpointBlockingFunction.afterMessWithZooKeeper.get())__				out.println("failedAlready= " + CheckpointBlockingFunction.failedAlready.get())__				out.println("currentJobStatus= " + clusterClient.getJobStatus(jobID).get())__				out.println("numRestarts= " + RestartReporter.numRestarts.getValue())__				out.println("threadDump= " + generateThreadDump())__			}_			throw new AssertionError(error.toString(), ExceptionUtils.stripCompletionException(e))__		}__		assertThat("We saw illegal restores.", CheckpointBlockingFunction.illegalRestores.get(), is(0))__	};verify,that,we,don,t,start,a,job,from,scratch,if,we,cannot,restore,any,of,the,completed,checkpoints,p,synchronization,for,the,different,steps,and,things,we,want,to,observe,happens,via,latches,in,the,test,method,and,the,methods,of,link,checkpoint,blocking,function,p,the,test,follows,these,steps,ol,li,start,job,and,block,on,a,latch,until,we,have,done,some,checkpoints,li,block,in,the,special,function,li,move,away,the,contents,of,the,zoo,keeper,ha,directory,to,make,restoring,from,checkpoints,impossible,li,unblock,the,special,function,which,now,induces,a,failure,li,make,sure,that,the,job,does,not,recover,successfully,li,move,back,the,ha,directory,li,make,sure,that,the,job,recovers,we,use,a,latch,to,ensure,that,the,operator,restored,successfully,ol;test,public,void,test,restore,behaviour,with,faulty,state,handles,throws,exception,checkpoint,blocking,function,allowed,initialize,calls,without,restore,set,1,checkpoint,blocking,function,successful,restores,set,0,checkpoint,blocking,function,illegal,restores,set,0,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,false,checkpoint,blocking,function,failed,already,set,false,wait,for,checkpoint,latch,new,one,shot,latch,fail,in,checkpoint,latch,new,one,shot,latch,cluster,client,cluster,client,mini,cluster,resource,get,cluster,client,final,deadline,deadline,deadline,now,plus,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,env,set,restart,strategy,restart,strategies,fixed,delay,restart,integer,0,env,enable,checkpointing,10,file,checkpoint,location,new,folder,env,set,state,backend,state,backend,new,fs,state,backend,checkpoint,location,to,uri,data,stream,source,string,source,env,add,source,new,unbounded,source,source,key,by,str,str,map,new,checkpoint,blocking,function,job,graph,job,graph,env,get,stream,graph,get,job,graph,job,id,job,id,preconditions,check,not,null,job,graph,get,job,id,cluster,client,set,detached,true,cluster,client,submit,job,job,graph,zoo,keeper,high,availability,itcase,class,get,class,loader,wait,for,checkpoint,latch,await,log,debug,messing,with,ha,directory,file,moved,checkpoint,location,new,folder,atomic,integer,num,checkpoints,new,atomic,integer,files,walk,file,tree,ha,storage,dir,to,path,new,simple,file,visitor,path,override,public,file,visit,result,visit,file,path,file,basic,file,attributes,attrs,if,file,get,file,name,to,string,starts,with,completed,checkpoint,log,debug,moving,original,checkpoint,file,file,try,files,move,file,moved,checkpoint,location,to,path,resolve,file,get,file,name,num,checkpoints,increment,and,get,catch,ioexception,ioe,log,debug,exception,while,moving,ha,files,ioe,return,file,visit,result,continue,assert,true,num,checkpoints,get,0,log,debug,resuming,job,fail,in,checkpoint,latch,trigger,assert,not,null,full,restarts,metric,could,not,be,accessed,restart,reporter,num,restarts,while,restart,reporter,num,restarts,get,value,5,deadline,has,time,left,thread,sleep,50,assert,that,restart,reporter,num,restarts,get,value,is,greater,than,4l,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,true,log,debug,restored,zookeeper,files,walk,file,tree,moved,checkpoint,location,to,path,new,simple,file,visitor,path,override,public,file,visit,result,visit,file,path,file,basic,file,attributes,attrs,throws,ioexception,files,move,file,ha,storage,dir,to,path,resolve,file,get,file,name,return,file,visit,result,continue,completable,future,job,status,job,status,future,future,utils,retry,successful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,50,deadline,job,status,is,globally,terminal,state,testing,utils,default,scheduled,executor,try,assert,equals,job,status,finished,job,status,future,get,catch,throwable,e,string,writer,error,new,string,writer,try,print,writer,out,new,print,writer,error,out,println,the,job,did,not,finish,in,time,out,println,allowed,initialize,calls,without,restore,checkpoint,blocking,function,allowed,initialize,calls,without,restore,get,out,println,illegal,restores,checkpoint,blocking,function,illegal,restores,get,out,println,successful,restores,checkpoint,blocking,function,successful,restores,get,out,println,after,mess,with,zoo,keeper,checkpoint,blocking,function,after,mess,with,zoo,keeper,get,out,println,failed,already,checkpoint,blocking,function,failed,already,get,out,println,current,job,status,cluster,client,get,job,status,job,id,get,out,println,num,restarts,restart,reporter,num,restarts,get,value,out,println,thread,dump,generate,thread,dump,throw,new,assertion,error,error,to,string,exception,utils,strip,completion,exception,e,assert,that,we,saw,illegal,restores,checkpoint,blocking,function,illegal,restores,get,is,0
ZooKeeperHighAvailabilityITCase -> @Test(timeout = 120_000L) 	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception;1520066096;Verify that we don't start a job from scratch if we cannot restore any of the_CompletedCheckpoints.__<p>Synchronization for the different steps and things we want to observe happens via_latches in the test method and the methods of {@link CheckpointBlockingFunction}.__<p>The test follows these steps:_<ol>_<li>Start job and block on a latch until we have done some checkpoints_<li>Block in the special function_<li>Move away the contents of the ZooKeeper HA directory to make restoring from_checkpoints impossible_<li>Unblock the special function, which now induces a failure_<li>Make sure that the job does not recover successfully_<li>Move back the HA directory_<li>Make sure that the job recovers, we use a latch to ensure that the operator_restored successfully_</ol>;@Test(timeout = 120_000L)_	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception {_		CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.set(1)__		CheckpointBlockingFunction.successfulRestores.set(0)__		CheckpointBlockingFunction.illegalRestores.set(0)__		CheckpointBlockingFunction.afterMessWithZooKeeper.set(false)__		CheckpointBlockingFunction.failedAlready.set(false)___		waitForCheckpointLatch = new OneShotLatch()__		failInCheckpointLatch = new OneShotLatch()___		ClusterClient<?> clusterClient = miniClusterResource.getClusterClient()__		final Deadline deadline = Deadline.now().plus(TEST_TIMEOUT)___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)__		env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0))__		env.enableCheckpointing(10)_ __		File checkpointLocation = TEMPORARY_FOLDER.newFolder()__		env.setStateBackend((StateBackend) new FsStateBackend(checkpointLocation.toURI()))___		DataStreamSource<String> source = env.addSource(new UnboundedSource())___		source_			.keyBy((str) -> str)_			.map(new CheckpointBlockingFunction())___		JobGraph jobGraph = env.getStreamGraph().getJobGraph()__		JobID jobID = Preconditions.checkNotNull(jobGraph.getJobID())___		clusterClient.setDetached(true)__		clusterClient.submitJob(jobGraph, ZooKeeperHighAvailabilityITCase.class.getClassLoader())___		_		waitForCheckpointLatch.await()___		_		File movedCheckpointLocation = TEMPORARY_FOLDER.newFolder()__		int numCheckpoints = 0__		File[] files = haStorageDir.listFiles()__		assertNotNull(files)__		for (File file : files) {_			if (file.getName().startsWith("completedCheckpoint")) {_				assertTrue(file.renameTo(new File(movedCheckpointLocation, file.getName())))__				numCheckpoints++__			}_		}_		_		_		_		_		_		_		assertTrue(numCheckpoints > 0)___		failInCheckpointLatch.trigger()___		_		CompletableFuture<JobStatus> jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(1),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.RESTARTING,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.RESTARTING, jobStatusFuture.get())___		jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(1),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.FAILING,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.FAILING, jobStatusFuture.get())___		_		CheckpointBlockingFunction.afterMessWithZooKeeper.set(true)___		files = movedCheckpointLocation.listFiles()__		assertNotNull(files)__		for (File file : files) {_			if (file.getName().startsWith("completedCheckpoint")) {_				assertTrue(file.renameTo(new File(haStorageDir, file.getName())))__			}_		}__		_		_		jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(50),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.FINISHED,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.FINISHED, jobStatusFuture.get())___		assertThat("We saw illegal restores.", CheckpointBlockingFunction.illegalRestores.get(), is(0))__	};verify,that,we,don,t,start,a,job,from,scratch,if,we,cannot,restore,any,of,the,completed,checkpoints,p,synchronization,for,the,different,steps,and,things,we,want,to,observe,happens,via,latches,in,the,test,method,and,the,methods,of,link,checkpoint,blocking,function,p,the,test,follows,these,steps,ol,li,start,job,and,block,on,a,latch,until,we,have,done,some,checkpoints,li,block,in,the,special,function,li,move,away,the,contents,of,the,zoo,keeper,ha,directory,to,make,restoring,from,checkpoints,impossible,li,unblock,the,special,function,which,now,induces,a,failure,li,make,sure,that,the,job,does,not,recover,successfully,li,move,back,the,ha,directory,li,make,sure,that,the,job,recovers,we,use,a,latch,to,ensure,that,the,operator,restored,successfully,ol;test,timeout,public,void,test,restore,behaviour,with,faulty,state,handles,throws,exception,checkpoint,blocking,function,allowed,initialize,calls,without,restore,set,1,checkpoint,blocking,function,successful,restores,set,0,checkpoint,blocking,function,illegal,restores,set,0,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,false,checkpoint,blocking,function,failed,already,set,false,wait,for,checkpoint,latch,new,one,shot,latch,fail,in,checkpoint,latch,new,one,shot,latch,cluster,client,cluster,client,mini,cluster,resource,get,cluster,client,final,deadline,deadline,deadline,now,plus,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,env,set,restart,strategy,restart,strategies,fixed,delay,restart,integer,0,env,enable,checkpointing,10,file,checkpoint,location,new,folder,env,set,state,backend,state,backend,new,fs,state,backend,checkpoint,location,to,uri,data,stream,source,string,source,env,add,source,new,unbounded,source,source,key,by,str,str,map,new,checkpoint,blocking,function,job,graph,job,graph,env,get,stream,graph,get,job,graph,job,id,job,id,preconditions,check,not,null,job,graph,get,job,id,cluster,client,set,detached,true,cluster,client,submit,job,job,graph,zoo,keeper,high,availability,itcase,class,get,class,loader,wait,for,checkpoint,latch,await,file,moved,checkpoint,location,new,folder,int,num,checkpoints,0,file,files,ha,storage,dir,list,files,assert,not,null,files,for,file,file,files,if,file,get,name,starts,with,completed,checkpoint,assert,true,file,rename,to,new,file,moved,checkpoint,location,file,get,name,num,checkpoints,assert,true,num,checkpoints,0,fail,in,checkpoint,latch,trigger,completable,future,job,status,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,1,deadline,job,status,job,status,job,status,restarting,testing,utils,default,scheduled,executor,assert,equals,job,status,restarting,job,status,future,get,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,1,deadline,job,status,job,status,job,status,failing,testing,utils,default,scheduled,executor,assert,equals,job,status,failing,job,status,future,get,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,true,files,moved,checkpoint,location,list,files,assert,not,null,files,for,file,file,files,if,file,get,name,starts,with,completed,checkpoint,assert,true,file,rename,to,new,file,ha,storage,dir,file,get,name,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,50,deadline,job,status,job,status,job,status,finished,testing,utils,default,scheduled,executor,assert,equals,job,status,finished,job,status,future,get,assert,that,we,saw,illegal,restores,checkpoint,blocking,function,illegal,restores,get,is,0
ZooKeeperHighAvailabilityITCase -> @Test(timeout = 120_000L) 	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception;1529585865;Verify that we don't start a job from scratch if we cannot restore any of the_CompletedCheckpoints.__<p>Synchronization for the different steps and things we want to observe happens via_latches in the test method and the methods of {@link CheckpointBlockingFunction}.__<p>The test follows these steps:_<ol>_<li>Start job and block on a latch until we have done some checkpoints_<li>Block in the special function_<li>Move away the contents of the ZooKeeper HA directory to make restoring from_checkpoints impossible_<li>Unblock the special function, which now induces a failure_<li>Make sure that the job does not recover successfully_<li>Move back the HA directory_<li>Make sure that the job recovers, we use a latch to ensure that the operator_restored successfully_</ol>;@Test(timeout = 120_000L)_	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception {_		CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.set(1)__		CheckpointBlockingFunction.successfulRestores.set(0)__		CheckpointBlockingFunction.illegalRestores.set(0)__		CheckpointBlockingFunction.afterMessWithZooKeeper.set(false)__		CheckpointBlockingFunction.failedAlready.set(false)___		waitForCheckpointLatch = new OneShotLatch()__		failInCheckpointLatch = new OneShotLatch()___		ClusterClient<?> clusterClient = miniClusterResource.getClusterClient()__		final Deadline deadline = Deadline.now().plus(TEST_TIMEOUT)___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)__		env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0))__		env.enableCheckpointing(10)_ __		File checkpointLocation = TEMPORARY_FOLDER.newFolder()__		env.setStateBackend((StateBackend) new FsStateBackend(checkpointLocation.toURI()))___		DataStreamSource<String> source = env.addSource(new UnboundedSource())___		source_			.keyBy((str) -> str)_			.map(new CheckpointBlockingFunction())___		JobGraph jobGraph = env.getStreamGraph().getJobGraph()__		JobID jobID = Preconditions.checkNotNull(jobGraph.getJobID())___		clusterClient.setDetached(true)__		clusterClient.submitJob(jobGraph, ZooKeeperHighAvailabilityITCase.class.getClassLoader())___		_		waitForCheckpointLatch.await()___		_		File movedCheckpointLocation = TEMPORARY_FOLDER.newFolder()__		int numCheckpoints = 0__		File[] files = haStorageDir.listFiles()__		assertNotNull(files)__		for (File file : files) {_			if (file.getName().startsWith("completedCheckpoint")) {_				assertTrue(file.renameTo(new File(movedCheckpointLocation, file.getName())))__				numCheckpoints++__			}_		}_		_		_		_		_		_		_		assertTrue(numCheckpoints > 0)___		failInCheckpointLatch.trigger()___		_		CompletableFuture<JobStatus> jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(1),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.RESTARTING,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.RESTARTING, jobStatusFuture.get())___		jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(1),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.FAILING,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.FAILING, jobStatusFuture.get())___		_		CheckpointBlockingFunction.afterMessWithZooKeeper.set(true)___		files = movedCheckpointLocation.listFiles()__		assertNotNull(files)__		for (File file : files) {_			if (file.getName().startsWith("completedCheckpoint")) {_				assertTrue(file.renameTo(new File(haStorageDir, file.getName())))__			}_		}__		_		_		jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(50),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.FINISHED,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.FINISHED, jobStatusFuture.get())___		assertThat("We saw illegal restores.", CheckpointBlockingFunction.illegalRestores.get(), is(0))__	};verify,that,we,don,t,start,a,job,from,scratch,if,we,cannot,restore,any,of,the,completed,checkpoints,p,synchronization,for,the,different,steps,and,things,we,want,to,observe,happens,via,latches,in,the,test,method,and,the,methods,of,link,checkpoint,blocking,function,p,the,test,follows,these,steps,ol,li,start,job,and,block,on,a,latch,until,we,have,done,some,checkpoints,li,block,in,the,special,function,li,move,away,the,contents,of,the,zoo,keeper,ha,directory,to,make,restoring,from,checkpoints,impossible,li,unblock,the,special,function,which,now,induces,a,failure,li,make,sure,that,the,job,does,not,recover,successfully,li,move,back,the,ha,directory,li,make,sure,that,the,job,recovers,we,use,a,latch,to,ensure,that,the,operator,restored,successfully,ol;test,timeout,public,void,test,restore,behaviour,with,faulty,state,handles,throws,exception,checkpoint,blocking,function,allowed,initialize,calls,without,restore,set,1,checkpoint,blocking,function,successful,restores,set,0,checkpoint,blocking,function,illegal,restores,set,0,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,false,checkpoint,blocking,function,failed,already,set,false,wait,for,checkpoint,latch,new,one,shot,latch,fail,in,checkpoint,latch,new,one,shot,latch,cluster,client,cluster,client,mini,cluster,resource,get,cluster,client,final,deadline,deadline,deadline,now,plus,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,env,set,restart,strategy,restart,strategies,fixed,delay,restart,integer,0,env,enable,checkpointing,10,file,checkpoint,location,new,folder,env,set,state,backend,state,backend,new,fs,state,backend,checkpoint,location,to,uri,data,stream,source,string,source,env,add,source,new,unbounded,source,source,key,by,str,str,map,new,checkpoint,blocking,function,job,graph,job,graph,env,get,stream,graph,get,job,graph,job,id,job,id,preconditions,check,not,null,job,graph,get,job,id,cluster,client,set,detached,true,cluster,client,submit,job,job,graph,zoo,keeper,high,availability,itcase,class,get,class,loader,wait,for,checkpoint,latch,await,file,moved,checkpoint,location,new,folder,int,num,checkpoints,0,file,files,ha,storage,dir,list,files,assert,not,null,files,for,file,file,files,if,file,get,name,starts,with,completed,checkpoint,assert,true,file,rename,to,new,file,moved,checkpoint,location,file,get,name,num,checkpoints,assert,true,num,checkpoints,0,fail,in,checkpoint,latch,trigger,completable,future,job,status,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,1,deadline,job,status,job,status,job,status,restarting,testing,utils,default,scheduled,executor,assert,equals,job,status,restarting,job,status,future,get,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,1,deadline,job,status,job,status,job,status,failing,testing,utils,default,scheduled,executor,assert,equals,job,status,failing,job,status,future,get,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,true,files,moved,checkpoint,location,list,files,assert,not,null,files,for,file,file,files,if,file,get,name,starts,with,completed,checkpoint,assert,true,file,rename,to,new,file,ha,storage,dir,file,get,name,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,50,deadline,job,status,job,status,job,status,finished,testing,utils,default,scheduled,executor,assert,equals,job,status,finished,job,status,future,get,assert,that,we,saw,illegal,restores,checkpoint,blocking,function,illegal,restores,get,is,0
ZooKeeperHighAvailabilityITCase -> @Test(timeout = 120_000L) 	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception;1529586951;Verify that we don't start a job from scratch if we cannot restore any of the_CompletedCheckpoints.__<p>Synchronization for the different steps and things we want to observe happens via_latches in the test method and the methods of {@link CheckpointBlockingFunction}.__<p>The test follows these steps:_<ol>_<li>Start job and block on a latch until we have done some checkpoints_<li>Block in the special function_<li>Move away the contents of the ZooKeeper HA directory to make restoring from_checkpoints impossible_<li>Unblock the special function, which now induces a failure_<li>Make sure that the job does not recover successfully_<li>Move back the HA directory_<li>Make sure that the job recovers, we use a latch to ensure that the operator_restored successfully_</ol>;@Test(timeout = 120_000L)_	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception {_		CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.set(1)__		CheckpointBlockingFunction.successfulRestores.set(0)__		CheckpointBlockingFunction.illegalRestores.set(0)__		CheckpointBlockingFunction.afterMessWithZooKeeper.set(false)__		CheckpointBlockingFunction.failedAlready.set(false)___		waitForCheckpointLatch = new OneShotLatch()__		failInCheckpointLatch = new OneShotLatch()___		ClusterClient<?> clusterClient = miniClusterResource.getClusterClient()__		final Deadline deadline = Deadline.now().plus(TEST_TIMEOUT)___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)__		env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0))__		env.enableCheckpointing(10)_ __		File checkpointLocation = TEMPORARY_FOLDER.newFolder()__		env.setStateBackend((StateBackend) new FsStateBackend(checkpointLocation.toURI()))___		DataStreamSource<String> source = env.addSource(new UnboundedSource())___		source_			.keyBy((str) -> str)_			.map(new CheckpointBlockingFunction())___		JobGraph jobGraph = env.getStreamGraph().getJobGraph()__		JobID jobID = Preconditions.checkNotNull(jobGraph.getJobID())___		clusterClient.setDetached(true)__		clusterClient.submitJob(jobGraph, ZooKeeperHighAvailabilityITCase.class.getClassLoader())___		_		waitForCheckpointLatch.await()___		_		File movedCheckpointLocation = TEMPORARY_FOLDER.newFolder()__		int numCheckpoints = 0__		File[] files = haStorageDir.listFiles()__		assertNotNull(files)__		for (File file : files) {_			if (file.getName().startsWith("completedCheckpoint")) {_				assertTrue(file.renameTo(new File(movedCheckpointLocation, file.getName())))__				numCheckpoints++__			}_		}_		_		_		_		_		_		_		assertTrue(numCheckpoints > 0)___		failInCheckpointLatch.trigger()___		_		CompletableFuture<JobStatus> jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(1),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.RESTARTING,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.RESTARTING, jobStatusFuture.get())___		jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(1),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.FAILING,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.FAILING, jobStatusFuture.get())___		_		CheckpointBlockingFunction.afterMessWithZooKeeper.set(true)___		files = movedCheckpointLocation.listFiles()__		assertNotNull(files)__		for (File file : files) {_			if (file.getName().startsWith("completedCheckpoint")) {_				assertTrue(file.renameTo(new File(haStorageDir, file.getName())))__			}_		}__		_		_		jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(50),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.FINISHED,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.FINISHED, jobStatusFuture.get())___		assertThat("We saw illegal restores.", CheckpointBlockingFunction.illegalRestores.get(), is(0))__	};verify,that,we,don,t,start,a,job,from,scratch,if,we,cannot,restore,any,of,the,completed,checkpoints,p,synchronization,for,the,different,steps,and,things,we,want,to,observe,happens,via,latches,in,the,test,method,and,the,methods,of,link,checkpoint,blocking,function,p,the,test,follows,these,steps,ol,li,start,job,and,block,on,a,latch,until,we,have,done,some,checkpoints,li,block,in,the,special,function,li,move,away,the,contents,of,the,zoo,keeper,ha,directory,to,make,restoring,from,checkpoints,impossible,li,unblock,the,special,function,which,now,induces,a,failure,li,make,sure,that,the,job,does,not,recover,successfully,li,move,back,the,ha,directory,li,make,sure,that,the,job,recovers,we,use,a,latch,to,ensure,that,the,operator,restored,successfully,ol;test,timeout,public,void,test,restore,behaviour,with,faulty,state,handles,throws,exception,checkpoint,blocking,function,allowed,initialize,calls,without,restore,set,1,checkpoint,blocking,function,successful,restores,set,0,checkpoint,blocking,function,illegal,restores,set,0,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,false,checkpoint,blocking,function,failed,already,set,false,wait,for,checkpoint,latch,new,one,shot,latch,fail,in,checkpoint,latch,new,one,shot,latch,cluster,client,cluster,client,mini,cluster,resource,get,cluster,client,final,deadline,deadline,deadline,now,plus,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,env,set,restart,strategy,restart,strategies,fixed,delay,restart,integer,0,env,enable,checkpointing,10,file,checkpoint,location,new,folder,env,set,state,backend,state,backend,new,fs,state,backend,checkpoint,location,to,uri,data,stream,source,string,source,env,add,source,new,unbounded,source,source,key,by,str,str,map,new,checkpoint,blocking,function,job,graph,job,graph,env,get,stream,graph,get,job,graph,job,id,job,id,preconditions,check,not,null,job,graph,get,job,id,cluster,client,set,detached,true,cluster,client,submit,job,job,graph,zoo,keeper,high,availability,itcase,class,get,class,loader,wait,for,checkpoint,latch,await,file,moved,checkpoint,location,new,folder,int,num,checkpoints,0,file,files,ha,storage,dir,list,files,assert,not,null,files,for,file,file,files,if,file,get,name,starts,with,completed,checkpoint,assert,true,file,rename,to,new,file,moved,checkpoint,location,file,get,name,num,checkpoints,assert,true,num,checkpoints,0,fail,in,checkpoint,latch,trigger,completable,future,job,status,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,1,deadline,job,status,job,status,job,status,restarting,testing,utils,default,scheduled,executor,assert,equals,job,status,restarting,job,status,future,get,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,1,deadline,job,status,job,status,job,status,failing,testing,utils,default,scheduled,executor,assert,equals,job,status,failing,job,status,future,get,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,true,files,moved,checkpoint,location,list,files,assert,not,null,files,for,file,file,files,if,file,get,name,starts,with,completed,checkpoint,assert,true,file,rename,to,new,file,ha,storage,dir,file,get,name,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,50,deadline,job,status,job,status,job,status,finished,testing,utils,default,scheduled,executor,assert,equals,job,status,finished,job,status,future,get,assert,that,we,saw,illegal,restores,checkpoint,blocking,function,illegal,restores,get,is,0
ZooKeeperHighAvailabilityITCase -> @Test(timeout = 120_000L) 	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception;1532940351;Verify that we don't start a job from scratch if we cannot restore any of the_CompletedCheckpoints.__<p>Synchronization for the different steps and things we want to observe happens via_latches in the test method and the methods of {@link CheckpointBlockingFunction}.__<p>The test follows these steps:_<ol>_<li>Start job and block on a latch until we have done some checkpoints_<li>Block in the special function_<li>Move away the contents of the ZooKeeper HA directory to make restoring from_checkpoints impossible_<li>Unblock the special function, which now induces a failure_<li>Make sure that the job does not recover successfully_<li>Move back the HA directory_<li>Make sure that the job recovers, we use a latch to ensure that the operator_restored successfully_</ol>;@Test(timeout = 120_000L)_	public void testRestoreBehaviourWithFaultyStateHandles() throws Exception {_		CheckpointBlockingFunction.allowedInitializeCallsWithoutRestore.set(1)__		CheckpointBlockingFunction.successfulRestores.set(0)__		CheckpointBlockingFunction.illegalRestores.set(0)__		CheckpointBlockingFunction.afterMessWithZooKeeper.set(false)__		CheckpointBlockingFunction.failedAlready.set(false)___		waitForCheckpointLatch = new OneShotLatch()__		failInCheckpointLatch = new OneShotLatch()___		ClusterClient<?> clusterClient = miniClusterResource.getClusterClient()__		final Deadline deadline = Deadline.now().plus(TEST_TIMEOUT)___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)__		env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0))__		env.enableCheckpointing(10)_ __		File checkpointLocation = TEMPORARY_FOLDER.newFolder()__		env.setStateBackend((StateBackend) new FsStateBackend(checkpointLocation.toURI()))___		DataStreamSource<String> source = env.addSource(new UnboundedSource())___		source_			.keyBy((str) -> str)_			.map(new CheckpointBlockingFunction())___		JobGraph jobGraph = env.getStreamGraph().getJobGraph()__		JobID jobID = Preconditions.checkNotNull(jobGraph.getJobID())___		clusterClient.setDetached(true)__		clusterClient.submitJob(jobGraph, ZooKeeperHighAvailabilityITCase.class.getClassLoader())___		_		waitForCheckpointLatch.await()___		log.debug("Messing with HA directory")__		_		File movedCheckpointLocation = TEMPORARY_FOLDER.newFolder()__		AtomicInteger numCheckpoints = new AtomicInteger()__		Files.walkFileTree(haStorageDir.toPath(), new SimpleFileVisitor<Path>() {_			@Override_			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {_				if (file.getFileName().toString().startsWith("completedCheckpoint")) {_					log.debug("Moving original checkpoint file {}.", file)__					try {_						Files.move(file, movedCheckpointLocation.toPath().resolve(file.getFileName()))__						numCheckpoints.incrementAndGet()__					} catch (IOException ioe) {_						_						log.debug("Exception while moving HA files.", ioe)__					}_				}_				return FileVisitResult.CONTINUE__			}_		})___		_		_		_		_		_		_		assertTrue(numCheckpoints.get() > 0)___		log.debug("Resuming job")__		failInCheckpointLatch.trigger()___		assertNotNull("fullRestarts metric could not be accessed.", RestartReporter.numRestarts)__		while (RestartReporter.numRestarts.getValue() < 5 && deadline.hasTimeLeft()) {_			Thread.sleep(50)__		}_		assertThat(RestartReporter.numRestarts.getValue(), is(greaterThan(4L)))___		_		CheckpointBlockingFunction.afterMessWithZooKeeper.set(true)__		log.debug("Restored zookeeper")___		Files.walkFileTree(movedCheckpointLocation.toPath(), new SimpleFileVisitor<Path>() {_			@Override_			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {_				Files.move(file, haStorageDir.toPath().resolve(file.getFileName()))__				return FileVisitResult.CONTINUE__			}_		})___		_		_		CompletableFuture<JobStatus> jobStatusFuture = FutureUtils.retrySuccesfulWithDelay(_			() -> clusterClient.getJobStatus(jobID),_			Time.milliseconds(50),_			deadline,_			(jobStatus) -> jobStatus == JobStatus.FINISHED,_			TestingUtils.defaultScheduledExecutor())__		assertEquals(JobStatus.FINISHED, jobStatusFuture.get())___		assertThat("We saw illegal restores.", CheckpointBlockingFunction.illegalRestores.get(), is(0))__	};verify,that,we,don,t,start,a,job,from,scratch,if,we,cannot,restore,any,of,the,completed,checkpoints,p,synchronization,for,the,different,steps,and,things,we,want,to,observe,happens,via,latches,in,the,test,method,and,the,methods,of,link,checkpoint,blocking,function,p,the,test,follows,these,steps,ol,li,start,job,and,block,on,a,latch,until,we,have,done,some,checkpoints,li,block,in,the,special,function,li,move,away,the,contents,of,the,zoo,keeper,ha,directory,to,make,restoring,from,checkpoints,impossible,li,unblock,the,special,function,which,now,induces,a,failure,li,make,sure,that,the,job,does,not,recover,successfully,li,move,back,the,ha,directory,li,make,sure,that,the,job,recovers,we,use,a,latch,to,ensure,that,the,operator,restored,successfully,ol;test,timeout,public,void,test,restore,behaviour,with,faulty,state,handles,throws,exception,checkpoint,blocking,function,allowed,initialize,calls,without,restore,set,1,checkpoint,blocking,function,successful,restores,set,0,checkpoint,blocking,function,illegal,restores,set,0,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,false,checkpoint,blocking,function,failed,already,set,false,wait,for,checkpoint,latch,new,one,shot,latch,fail,in,checkpoint,latch,new,one,shot,latch,cluster,client,cluster,client,mini,cluster,resource,get,cluster,client,final,deadline,deadline,deadline,now,plus,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,env,set,restart,strategy,restart,strategies,fixed,delay,restart,integer,0,env,enable,checkpointing,10,file,checkpoint,location,new,folder,env,set,state,backend,state,backend,new,fs,state,backend,checkpoint,location,to,uri,data,stream,source,string,source,env,add,source,new,unbounded,source,source,key,by,str,str,map,new,checkpoint,blocking,function,job,graph,job,graph,env,get,stream,graph,get,job,graph,job,id,job,id,preconditions,check,not,null,job,graph,get,job,id,cluster,client,set,detached,true,cluster,client,submit,job,job,graph,zoo,keeper,high,availability,itcase,class,get,class,loader,wait,for,checkpoint,latch,await,log,debug,messing,with,ha,directory,file,moved,checkpoint,location,new,folder,atomic,integer,num,checkpoints,new,atomic,integer,files,walk,file,tree,ha,storage,dir,to,path,new,simple,file,visitor,path,override,public,file,visit,result,visit,file,path,file,basic,file,attributes,attrs,if,file,get,file,name,to,string,starts,with,completed,checkpoint,log,debug,moving,original,checkpoint,file,file,try,files,move,file,moved,checkpoint,location,to,path,resolve,file,get,file,name,num,checkpoints,increment,and,get,catch,ioexception,ioe,log,debug,exception,while,moving,ha,files,ioe,return,file,visit,result,continue,assert,true,num,checkpoints,get,0,log,debug,resuming,job,fail,in,checkpoint,latch,trigger,assert,not,null,full,restarts,metric,could,not,be,accessed,restart,reporter,num,restarts,while,restart,reporter,num,restarts,get,value,5,deadline,has,time,left,thread,sleep,50,assert,that,restart,reporter,num,restarts,get,value,is,greater,than,4l,checkpoint,blocking,function,after,mess,with,zoo,keeper,set,true,log,debug,restored,zookeeper,files,walk,file,tree,moved,checkpoint,location,to,path,new,simple,file,visitor,path,override,public,file,visit,result,visit,file,path,file,basic,file,attributes,attrs,throws,ioexception,files,move,file,ha,storage,dir,to,path,resolve,file,get,file,name,return,file,visit,result,continue,completable,future,job,status,job,status,future,future,utils,retry,succesful,with,delay,cluster,client,get,job,status,job,id,time,milliseconds,50,deadline,job,status,job,status,job,status,finished,testing,utils,default,scheduled,executor,assert,equals,job,status,finished,job,status,future,get,assert,that,we,saw,illegal,restores,checkpoint,blocking,function,illegal,restores,get,is,0
